[
    {
        "title": "Text Justification",
        "question_content": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\n\n\tA word is defined as a character sequence consisting of non-space characters only.\n\tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n\tThe input array words contains at least one word.\n\n&nbsp;\nExample 1:\n\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n&nbsp; &nbsp;\"This &nbsp; &nbsp;is &nbsp; &nbsp;an\",\n&nbsp; &nbsp;\"example &nbsp;of text\",\n&nbsp; &nbsp;\"justification. &nbsp;\"\n]\nExample 2:\n\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n&nbsp; \"What &nbsp; must &nbsp; be\",\n&nbsp; \"acknowledgment &nbsp;\",\n&nbsp; \"shall be &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\n\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n&nbsp; \"Science &nbsp;is &nbsp;what we\",\n  \"understand &nbsp; &nbsp; &nbsp;well\",\n&nbsp; \"enough to explain to\",\n&nbsp; \"a &nbsp;computer. &nbsp;Art is\",\n&nbsp; \"everything &nbsp;else &nbsp;we\",\n&nbsp; \"do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 300\n\t1 <= words[i].length <= 20\n\twords[i] consists of only English letters and symbols.\n\t1 <= maxWidth <= 100\n\twords[i].length <= maxWidth",
        "solutions": [
            {
                "id": 24902,
                "title": "java-easy-to-understand-broken-into-several-functions",
                "content": "We start with left being the first word.\\n\\nfindRight: Then we greedily try to go as far right as possible until we fill our current line.\\n\\nThen we justify one line at a time.\\n\\njustify: In all cases we pad the right side with spaces until we reach max width for the line;\\n1. If it's one word then it is easy, the result is just that word.\\n2. If it's the last line then the result is all words separated by a single space.\\n3. Otherwise we calculate the size of each space evenly and if there is a remainder we distribute an extra space until it is gone.\\n\\n```\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace('\\\\0', ' ');\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace('\\\\0', ' ');\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24891,
                "title": "concise-python-solution-10-lines",
                "content": "--------------------------------------------\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        return res + [\\' \\'.join(cur).ljust(maxWidth)]\\n\\nHow does it work? Well in the question statement, the sentence \"Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right\" was just a really long and awkward way to say *round robin*. The following line implements the round robin logic: \\n\\n    for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n\\nWhat does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The \"or 1\" part is for dealing with the edge case len(cur) == 1.\\n\\n###### Note: I found that this problem & solution is directly being used in the \"Elements of Programming Interviews in Python\" book. Cool I guess, but the book should include an acknowledgement or link to this source.\\n--------------------------------------------\\n\\nThe following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time.\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                if len(cur) == 1:\\n                    res.append( cur[0] + \\' \\'*(maxWidth - num_of_letters) )\\n                else:\\n                    num_spaces = maxWidth - num_of_letters\\n                    space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\\n                    for i in range(num_extra_spaces):\\n                        cur[i] += \\' \\'\\n                    res.append( (\\' \\'*space_between_words).join(cur) )\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        res.append( \\' \\'.join(cur) + \\' \\'*(maxWidth - num_of_letters - len(cur) + 1) )\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "--------------------------------------------\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        return res + [\\' \\'.join(cur).ljust(maxWidth)]\\n\\nHow does it work? Well in the question statement, the sentence \"Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right\" was just a really long and awkward way to say *round robin*. The following line implements the round robin logic: \\n\\n    for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n\\nWhat does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The \"or 1\" part is for dealing with the edge case len(cur) == 1.\\n\\n###### Note: I found that this problem & solution is directly being used in the \"Elements of Programming Interviews in Python\" book. Cool I guess, but the book should include an acknowledgement or link to this source.\\n--------------------------------------------\\n\\nThe following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time.\\n\\n    def fullJustify(self, words, maxWidth):\\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                if len(cur) == 1:\\n                    res.append( cur[0] + \\' \\'*(maxWidth - num_of_letters) )\\n                else:\\n                    num_spaces = maxWidth - num_of_letters\\n                    space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1)\\n                    for i in range(num_extra_spaces):\\n                        cur[i] += \\' \\'\\n                    res.append( (\\' \\'*space_between_words).join(cur) )\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        res.append( \\' \\'.join(cur) + \\' \\'*(maxWidth - num_of_letters - len(cur) + 1) )\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2992661,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        \\n        cur_wlist  = []\\n        cur_ch_cnt = 0   # for the space consideration\\n     \\n        for w in words: \\n            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:\\n                for i in range(maxWidth - cur_ch_cnt):  # insert space\\n                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += \\' \\'\\n               \\n                res.append(\\'\\'.join(cur_wlist)) # insert a this row \\n                cur_wlist, cur_ch_cnt = [], 0 # prepare a new row, resetting\\n                \\n            cur_wlist += [w]\\n            cur_ch_cnt += len(w)\\n            \\n        return res + [\\' \\'.join(cur_wlist).ljust(maxWidth)]\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n\\n        int word = 0;\\n\\n        while(word<words.length){\\n\\n            int j = word-1;\\n            int characters = 0;\\n\\n\\n            while(j+1<words.length && characters+words[j+1].length() + j+1-word<=maxWidth)\\n            {\\n                j++;\\n                characters+=words[j].length();\\n            }\\n            result.add(line(words , word , j, characters , maxWidth));\\n            word = j+1;\\n        }\\n        return result;\\n    }\\n      public String line(String words[],int start,int end, int Linelen,int max)\\n    {\\n        StringBuilder a = new StringBuilder();\\n        int p=1,q=0;\\n        if(end!=start)\\n        {\\n            p=(max-Linelen)/(end-start);\\n            q=(max-Linelen)%(end-start);\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            a.append(words[i]);\\n            if(i!=end)\\n            {\\n                if(end==words.length-1) a.append(\" \");\\n                else {\\n                    for(int j=1;j<=p;j++) a.append(\" \");\\n                    if(q-->=1) a.append(\" \");\\n                }\\n            }\\n        }\\n        while(a.length()<max) a.append(\" \");\\n        return a.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        \\n        cur_wlist  = []\\n        cur_ch_cnt = 0   # for the space consideration\\n     \\n        for w in words: \\n            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:\\n                for i in range(maxWidth - cur_ch_cnt):  # insert space\\n                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += \\' \\'\\n               \\n                res.append(\\'\\'.join(cur_wlist)) # insert a this row \\n                cur_wlist, cur_ch_cnt = [], 0 # prepare a new row, resetting\\n                \\n            cur_wlist += [w]\\n            cur_ch_cnt += len(w)\\n            \\n        return res + [\\' \\'.join(cur_wlist).ljust(maxWidth)]\\n```\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n\\n        int word = 0;\\n\\n        while(word<words.length){\\n\\n            int j = word-1;\\n            int characters = 0;\\n\\n\\n            while(j+1<words.length && characters+words[j+1].length() + j+1-word<=maxWidth)\\n            {\\n                j++;\\n                characters+=words[j].length();\\n            }\\n            result.add(line(words , word , j, characters , maxWidth));\\n            word = j+1;\\n        }\\n        return result;\\n    }\\n      public String line(String words[],int start,int end, int Linelen,int max)\\n    {\\n        StringBuilder a = new StringBuilder();\\n        int p=1,q=0;\\n        if(end!=start)\\n        {\\n            p=(max-Linelen)/(end-start);\\n            q=(max-Linelen)%(end-start);\\n        }\\n        \\n        for(int i=start;i<=end;i++)\\n        {\\n            a.append(words[i]);\\n            if(i!=end)\\n            {\\n                if(end==words.length-1) a.append(\" \");\\n                else {\\n                    for(int j=1;j<=p;j++) a.append(\" \");\\n                    if(q-->=1) a.append(\" \");\\n                }\\n            }\\n        }\\n        while(a.length()<max) a.append(\" \");\\n        return a.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24873,
                "title": "share-my-concise-c-solution-less-than-20-lines",
                "content": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> res;\\n        for(int i = 0, k, l; i < words.size(); i += k) {\\n            for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n                l += words[i+k].size();\\n            }\\n            string tmp = words[i];\\n            for(int j = 0; j < k - 1; j++) {\\n                if(i + k >= words.size()) tmp += \" \";\\n                else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\\n                tmp += words[i+j+1];\\n            }\\n            tmp += string(L - tmp.size(), ' ');\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n\\nFor each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can't be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space.",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> res;\\n        for(int i = 0, k, l; i < words.size(); i += k) {\\n            for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n                l += words[i+k].size();\\n            }\\n            string tmp = words[i];\\n            for(int j = 0; j < k - 1; j++) {\\n                if(i + k >= words.size()) tmp += \" \";\\n                else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), ' ');\\n                tmp += words[i+j+1];\\n            }\\n            tmp += string(L - tmp.size(), ' ');\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n\\nFor each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can't be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space.",
                "codeTag": "Unknown"
            },
            {
                "id": 24876,
                "title": "simple-java-solution",
                "content": "    public class Solution {\\n        public List<String> fullJustify(String[] words, int L) {\\n            List<String> lines = new ArrayList<String>();\\n            \\n            int index = 0;\\n            while (index < words.length) {\\n                int count = words[index].length();\\n                int last = index + 1;\\n                while (last < words.length) {\\n                    if (words[last].length() + count + 1 > L) break;\\n                    count += words[last].length() + 1;\\n                    last++;\\n                }\\n                \\n                StringBuilder builder = new StringBuilder();\\n                int diff = last - index - 1;\\n                // if last line or number of words in the line is 1, left-justified\\n                if (last == words.length || diff == 0) {\\n                    for (int i = index; i < last; i++) {\\n                        builder.append(words[i] + \" \");\\n                    }\\n                    builder.deleteCharAt(builder.length() - 1);\\n                    for (int i = builder.length(); i < L; i++) {\\n                        builder.append(\" \");\\n                    }\\n                } else {\\n                    // middle justified\\n                    int spaces = (L - count) / diff;\\n                    int r = (L - count) % diff;\\n                    for (int i = index; i < last; i++) {\\n                        builder.append(words[i]);\\n                        if (i < last - 1) {\\n                            for (int j = 0; j <= (spaces + ((i - index) < r ? 1 : 0)); j++) {\\n                                builder.append(\" \");\\n                            }\\n                        }\\n                    }\\n                }\\n                lines.add(builder.toString());\\n                index = last;\\n            }\\n            \\n            \\n            return lines;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> fullJustify(String[] words, int L) {\\n            List<String> lines = new ArrayList<String>();\\n            \\n            int index = 0;\\n            while (index < words.length) {\\n                int count = words[index].length();\\n                int last = index + 1;\\n                while (last < words.length) {\\n                    if (words[last].length() + count + 1 > L) break;\\n                    count += words[last].length() + 1;\\n                    last++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 24965,
                "title": "easy-understanding-solution",
                "content": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> ans, vs;\\n        string str;\\n        \\n        int len = 0;\\n        for (int i = 0; i < words.size(); ++i) {\\n            if (len + vs.size() + words[i].size() <= L) {\\n                // vs not full, need to get more words in the line\\n                vs.push_back(words[i]);\\n                len += words[i].size();\\n            }\\n            else {\\n                // vs full, get the whole line\\n                if (vs.size() == 1) {\\n                    // just one word, the left justify\\n                    str = vs[0];\\n                    str.append(L - str.size(), ' ');\\n                    ans.push_back(str);\\n                }\\n                else if (vs.size() > 1) {\\n                    // the first \"mod\" words get \"div+1\" spaces\\n                    // the remaining words get \"div\" spaces\\n                    int div = (L - len) / (vs.size() - 1);\\n                    int mod = (L - len) % (vs.size() - 1);\\n                    str = vs[0];\\n                    for (int j = 1; j < vs.size(); ++j) {\\n                        if (j <= mod) str.append(div+1, ' '); // one more space\\n                        else str.append(div, ' ');\\n                        str += vs[j];\\n                    }\\n                    ans.push_back(str);\\n                }\\n                \\n                vs.clear();\\n                vs.push_back(words[i]);\\n                len = words[i].size();\\n            }\\n        }\\n        \\n        // the last line, left justified and no extra space is inserted between words\\n        str = vs[0];\\n        for (int j = 1; j < vs.size(); ++j) str += ' ' + vs[j];\\n        str.append(L-str.size(), ' ');\\n        ans.push_back(str);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string> &words, int L) {\\n        vector<string> ans, vs;\\n        string str;\\n        \\n        int len = 0;\\n        for (int i = 0; i < words.size(); ++i) {\\n            if (len + vs.size() + words[i].size() <= L) {\\n                // vs not full, need to get more words in the line\\n                vs.push_back(words[i]);\\n                len += words[i].size();\\n            }\\n            else {\\n                // vs full, get the whole line\\n                if (vs.size() == 1) {\\n                    // just one word, the left justify\\n                    str = vs[0];\\n                    str.append(L - str.size(), ' ');\\n                    ans.push_back(str);\\n                }\\n                else if (vs.size() > 1) {\\n                    // the first \"mod\" words get \"div+1\" spaces\\n                    // the remaining words get \"div\" spaces\\n                    int div = (L - len) / (vs.size() - 1);\\n                    int mod = (L - len) % (vs.size() - 1);\\n                    str = vs[0];\\n                    for (int j = 1; j < vs.size(); ++j) {\\n                        if (j <= mod) str.append(div+1, ' '); // one more space\\n                        else str.append(div, ' ');\\n                        str += vs[j];\\n                    }\\n                    ans.push_back(str);\\n                }\\n                \\n                vs.clear();\\n                vs.push_back(words[i]);\\n                len = words[i].size();\\n            }\\n        }\\n        \\n        // the last line, left justified and no extra space is inserted between words\\n        str = vs[0];\\n        for (int j = 1; j < vs.size(); ++j) str += ' ' + vs[j];\\n        str.append(L-str.size(), ' ');\\n        ans.push_back(str);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1243483,
                "title": "intuitive-code-with-explanation",
                "content": "**This problem can be divided into main 2 parts :-**\\n*  First part is to find enough number of words in each line but length of each line should be less then maxWidth(which is pretty straight forward).\\n\\n*  Second part is to format each line.(which is difficult)\\n\\n**Code is written in C++ but after reading explanation you can translate it in your favourite language.**\\n\\n**1. first part:-**\\nThe below function is doing 1st part, it\\'s calling spaceJustifer function just before inserting output string into result vector(or else we can just insert strings without justification into result vector then we can justify each line at the end). just to make sure we are on same page spaceJustifier is getting a input like this `\"This is an\"`  i.e single space to seperate each word, and spaceJustifier is returning us string like this `\"This    is    an\"` i.e inserting 1 space between `this` and `is` . \\n```\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result; //result vector which will store each line\\n        string output = words[0]; //add first word to output string\\n        for (int i = 1; i<words.size(); i++){\\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \\n\\t\\t\\t\\n\\t\\t\\t\\t\\toutput += \" \"+words[i]; //add space before adding word\\n            \\n            else{ \\n\\t\\t\\t   //this else will be executed when current line can\\'t add current words \\n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \\n                result.push_back(output);\\n                //now we added output to result vector now we can start a new line \\n                output = words[i]; //add current word to output(start of new line)\\n            }\\n        }\\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\\n        result.push_back(output); //adding last line to result array\\n        return result;\\n    }\\n```\\n**2. The below function is doing main part of justification.**\\n   `spaceJustifier(string str, int maxWidth, int isLast)` function accepting 3 parameters :-\\n   1. first is str which will accept string/line ex - `\"This is an\"`\\n   2. Second is maxWidth.\\n   3. Third is a flag which will tell us, is the current string is last line or not.\\n    why we intereseted in last line? because last line must be left-justified instead of fully-justified.\\n\\t\\nbelow are the condition/operations we are checking.\\n\\n1. The first condition is **`str.length() == maxWidth`** for string whose length is already equal to max width so we **return line as it is.**\\n\\n2. Now if **`str.length() < maxWidth`** we will calculate spaces which are already in the string. Ex- `\"This is an\"` has 2 spaces.\\n\\n3. After finding number of spaces we will check if `spacesInString == 0 || isLast == 1 ` i.e if number of spaces is equal to 0 and if the current string is last line or not. if string has 0 spaces it means there is only one word inside string. for one word string has to be left-justified same as last line. that is why both conditions are put together\\n\\n4. Now if 1st and 3st condition are checked and we haven\\'t returned the string it means we have to fully justify the line. \\n\\tto do this we need to calculate number of spaces which need to be inserted to make string equal to `maxWidth` we can do this by ``spaceToBeInserted = maxWidth - str.length()``\\n\\tnow we need to find how much spaces we should insert at `each slot` (slot is index of space in the string) to make the given string equal to `maxWidth`. ex- `\"This is an\"` and `maxWidth` is 16. spaces we need to insert in the string to make it equal to maxWidth is 6 [16-10(length of string)]\\n\\tthe above ex has 2 slots or spaces already, so we need add 6 more spaces equally. we can find how much extra space `each slot` will get by dividing `spaceToBeInserted` by `spaces in strings` i.e `eachSlot = spacesToBeInserted / spacesInString`\\n\\t\\nThe above condition will work till `spacesToBeInserted` is fully divisible by `spacesInString`. \\n\\n5. Let us take another example where  `spacesToBeInserted` is not fully divisible by `spacesInString` :-\\nSuppose string is  `\"so fine That all the\"`(maxWidth is 25) here `spacesToBeInserted` is 5 and `spacesInString`is 4, now we can\\'t divide spaces     evenly. In this case according to question we should divide the string as evenly as possible. To divide it evenly we will find reminder when `spacesToBeInserted` is divided by `spacesInString` which will tells us `leftOverSpaces` which we need to insert from left to right. below\\nhere first will find `eachSlot` value which is 5/4 = 1 and `leftOverSpaces` will be 5%4 = 1. now we will fill spaces from left to right :-\\n`\"so_ _fine_ _That_ _all_ _the\"` (underscore represent spaces)1 space is added at each slot now all slot have 2 spaces. \\nnow from left to right we will be adding 1 space to each slot till `leftOverSpaces` become zero.\\n`\"so_ _ _fine_ _That_ _all_ _the\"` after inserting space at first slot `leftOverSpaces` become 0 so no more space is added after that.\\n\\nbelow code add both `eachSlot` space and `leftOverSpaces` at same time so it will directly add 3 spaces between `\"so_ _ _fine\"`  instead of 2 spaces.\\n\\n**if there is a mistake please comment.**\\n\\n\\t\\n    string spaceJustifier(string str, int maxWidth, int isLast){\\n        //condition if line length is equal to maxWidth so return line as it is.\\n        if(str.length() == maxWidth)\\n            return str;\\n        \\n        int spacesInString = 0; //count total spaces in the line \\n        for(int i = 0; i<str.length(); i++){\\n            if(str[i] == \\' \\')\\n                spacesInString++;\\n        }\\n        int spacesToBeInserted = maxWidth - str.length(); //spaces to be inserted will be maxWidth - line length\\n        //Left Justifier \\n        //if line has only 1 word(number of spaces in one word is 0 ex \"hi\") || it\\'s last line then left justify the line\\n        if(spacesInString == 0 || isLast == 1){ \\n            str.insert(str.length(), spacesToBeInserted,\\' \\'); //insert required spaces in right of line ex \"do                  \"\\n            return str;\\n        }\\n        int eachSlot = spacesToBeInserted / spacesInString; \\n        int leftOverSpace = spacesToBeInserted % spacesInString; \\n        //EXPLANATION FOR EACH SLOT\\n        //(spacesToBeInserted / spacesInString) will tell us how much space should we insert at eachSlot\\n        //ex - (spacesToBeInserted = 6)/(spaces in string = 2) then each slot will get 3 extra spaces ex - \"hi_hi\" => \"hi_ _ _ _hi_ _ _ _\" will be output\\n        \\n        //EXPLANATION FOR LEFT OVER SPACE\\n        //when the spacesToBeInserted is not divisibe by spacesInString \\n        //EX if we spacesToBeInserted = 5 and spaces in string = 2.\\n        //since 5/2 is not fully Divisble we will find remainder 5%2 to get left overspace.\\n        \\n        \\n        //EX - so_fine_That_all_the. and maxWidth is 25\\n        //      in above case spacesToBeInserted = 5 and spaces in stirng = 4.\\n        //      eachSlot will be 5/4 is 1. ie increase spaces by 1 \\n        \\n        //output will be -> so_ _fine_ _That_ _all_ _the\\n        \\n        //      since 5/4 is not fully divisible. we will find leftOverSpaces = 5%4 = 1;\\n        //      this leftOverSpace will be distributed from left to right ie each slot will get 1,1,1 from left to right\\n        \\n        //output will be -> so_ _ _fine_ _That_ _all_ _the\\n        //                        \\u2191\\n        //                    leftOverSpace added \\n        \\n        //if we had more leftoverspaces then it will be added to next slot.\\n        \\n        for(int i = 0; i<str.length(); i++){\\n            if(str[i] == \\' \\' && (eachSlot > 0 || leftOverSpace >0 )){ //we add spaces till (eachSlot > 0 || leftOverSpace >0)\\n                //required noOfSpaces = eachSlot + (leftOverSpace-- > 0 ? 1:0)\\n                //((leftOverSpace--) > 0 ? 1:0) will return 1 if leftoverspace>0.\\n                //(leftOverSpace--) post decrement\\n                int noOfSpaces = eachSlot + ((leftOverSpace--) > 0 ? 1:0);\\n                str.insert(i, noOfSpaces , \\' \\'); //inserting spaces\\n                i+=noOfSpaces;   //increament count with no of spaces inserted each time \\n            }\\n            \\n        }\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result; //result vector which will store each line\\n        string output = words[0]; //add first word to output string\\n        for (int i = 1; i<words.size(); i++){\\n            if(output.length() + words[i].length() + 1 <= maxWidth) //+1 for space \\n\\t\\t\\t\\n\\t\\t\\t\\t\\toutput += \" \"+words[i]; //add space before adding word\\n            \\n            else{ \\n\\t\\t\\t   //this else will be executed when current line can\\'t add current words \\n                output = spaceJustifier(output, maxWidth, 0); //formatting space before adding it to result \\n                result.push_back(output);\\n                //now we added output to result vector now we can start a new line \\n                output = words[i]; //add current word to output(start of new line)\\n            }\\n        }\\n        //the above loop will not add last line to result because last line to will always satify (output.length()+words[i].length()+1<=maxWidth) condition\\n        output = spaceJustifier(output, maxWidth, 1); //justifying spaces in last line\\n        result.push_back(output); //adding last line to result array\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952119,
                "title": "94-14-2-approaches-greedy",
                "content": "# Interview Problem Understanding\\n\\nIn interviews, understanding the problem at hand is half the battle. Let\\'s break down the \"Text Justification\" challenge:\\n\\n**The Scenario**: Imagine you\\'re building a word processor, and you need to implement the \"Justify\" alignment feature. This means that when a user selects a group of words and chooses the \"Justify\" option, the text is adjusted so that each line spans the entire width of the available space. Words are spaced out, and additional spaces are added between them to achieve this uniform width.\\n\\n**The Challenge**: Given an array of strings (or words) and a defined maximum width for each line:\\n- Your task is to format the text such that each line is exactly the specified maximum width.\\n- Each line should be both left and right justified. This means the words on each line are separated by one or more spaces to ensure the line extends from the very left to the very right.\\n- There\\'s a catch, though. For lines that aren\\'t the last, if the spaces don\\'t divide evenly, the leftmost gaps get more spaces. For the very last line or a line with a single word, it should be left-justified, and the extra spaces are added to the end.\\n\\n**Example**:\\nSuppose you\\'re given the words `[\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]` and a `maxWidth` of 16. This means each line of the output can only be 16 characters wide. Your output should resemble:\\n\\n```\\n[\\n  \"This    is    an\",\\n  \"example  of text\",\\n  \"justification.  \"\\n]\\n```\\n\\n**Input/Output**:\\n- **Input**: You\\'re provided with an array of words and a maximum width for each line.\\n- **Output**: Your goal is to return a list of strings, where each string is a line of text that adheres to the justification rules.\\n\\n---\\n\\n# Live Coding + Explenation Modulo-based\\nhttps://youtu.be/KGfXrj7G0W0?si=VmyOm2RqX6yfMm9w\\n\\n---\\n\\n## Approach 1: Modulo-based Space Distribution\\n\\nTo solve the \"Text Justification\" problem using this approach, we pack words into each line using a greedy strategy. We then distribute spaces among the words on each line, using modulo arithmetic to decide where to place the extra spaces.\\n\\n### Key Data Structures:\\n- **List**: To store the current words for a line and the result.\\n\\n### Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - We start by initializing empty lists for the result and the current line words.\\n   - A counter is also initialized to keep track of the total length of words in the current line.\\n   \\n2. **Processing Each Word**:\\n   - For each word, we check if adding the next word to the current line would make it exceed the maximum width.\\n   - If it does, we proceed to justify the current line. This involves distributing spaces among the words. The modulo arithmetic is handy here, ensuring that extra spaces are evenly spread among the words.\\n   - Once the line is justified, we reset the lists and counter for the next line.\\n   - A special case is the last line, where we simply left-justify the words.\\n\\n3. **Wrap-up**:\\n   - Once all the words are processed and lines are justified, we return the result list.\\n\\n## Example:\\n\\nGiven the `words = [\"This\", \"is\", \"an\", \"example\"]` and `maxWidth = 16`:\\n\\n- The word \"This\" is added to the current line.\\n- The word \"is\" is added to the current line.\\n- The word \"an\" is added to the current line, completing it with the string \"This    is    an\".\\n- The word \"example\" starts a new line.\\n\\n---\\n\\n## Approach 2: Gap-based Space Distribution\\n\\nIn this method, the way we pack words into each line remains similar to the first approach. However, when it comes to distributing spaces, the logic is a tad different. Instead of using modulo arithmetic directly, we compute the number of gaps between words and then decide how many spaces to put in each gap. This makes the logic more intuitive.\\n\\n### Key Data Structures:\\n- **List**: To store the current words for a line and the result.\\n\\n### Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - As before, we initialize empty lists for the result and the current line words.\\n   - A counter keeps track of the total length of words in the current line.\\n   \\n2. **Processing Each Word**:\\n   - For every word, we check if adding it to the current line would cross the maximum width.\\n   - If yes, we justify the current line. This time, we compute the total number of spaces required for the current line. This is based on the maximum width and the length of words on the line.\\n   - We then determine how many gaps exist between the words and compute the number of spaces that can be evenly distributed across these gaps.\\n   - Any extra spaces that can\\'t be evenly distributed are then added to the gaps from left to right.\\n   - The last line is handled specially, where we left-justify the words.\\n\\n3. **Wrap-up**:\\n   - After processing all the words and justifying the lines, we return the result list.\\n\\n---\\n\\n# Complexity:\\n\\n**Time Complexity:** Both approaches process each word once and have a time complexity of $$O(n)$$, where $$n$$ is the number of words.\\n\\n**Space Complexity:** The space complexity for both methods is $$O(n \\\\times m)$$, where $$n$$ is the number of words and $$m$$ is the average length of the words.\\n\\n---\\n\\n# Performance:\\n\\n| Language    | Runtime (ms) | Memory (MB) |\\n|-------------|--------------|-------------|\\n| Rust        | 1 ms         | 2.1 MB      |\\n| Go          | 1 ms         | 2.1 MB      |\\n| Java        | 1 ms         | 40.7 MB     |\\n| C++         | 4 ms         | 7.6 MB      |\\n| Python3 (v2)| 34 ms        | 16.3 MB     |\\n| Python3 (v1)| 34 ms        | 16.1 MB     |\\n| JavaScript  | 55 ms        | 42.2 MB     |\\n| C#          | 139 ms       | 43.7 MB     |\\n\\n![p2a.png](https://assets.leetcode.com/users/images/4e42f0d5-2bfd-476c-b39e-40984d1d300a_1692839284.047317.png)\\n\\n# Code Modulo-based\\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, line, width = [], [], 0\\n\\n        for w in words:\\n            if width + len(w) + len(line) > maxWidth:\\n                for i in range(maxWidth - width): line[i % (len(line) - 1 or 1)] += \\' \\'\\n                res, line, width = res + [\\'\\'.join(line)], [], 0\\n            line += [w]\\n            width += len(w)\\n\\n        return res + [\\' \\'.join(line).ljust(maxWidth)]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res;\\n        std::vector<std::string> cur;\\n        int num_of_letters = 0;\\n\\n        for (std::string word : words) {\\n            if (word.size() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.size() - 1 ? cur.size() - 1 : 1)] += \\' \\';\\n                }\\n                res.push_back(\"\");\\n                for (std::string s : cur) res.back() += s;\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push_back(word);\\n            num_of_letters += word.size();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (std::string s : cur) last_line += s + \\' \\';\\n        last_line = last_line.substr(0, last_line.size()-1);  // remove trailing space\\n        while (last_line.size() < maxWidth) last_line += \\' \\';\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int num_of_letters = 0;\\n\\n        for (String word : words) {\\n            if (word.length() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur.set(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1), cur.get(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1)) + \" \");\\n                }\\n                StringBuilder sb = new StringBuilder();\\n                for (String s : cur) sb.append(s);\\n                res.add(sb.toString());\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.add(word);\\n            num_of_letters += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder();\\n        for (int i = 0; i < cur.size(); i++) {\\n            lastLine.append(cur.get(i));\\n            if (i != cur.size() - 1) lastLine.append(\" \");\\n        }\\n        while (lastLine.length() < maxWidth) lastLine.append(\" \");\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let cur = [];\\n        let num_of_letters = 0;\\n\\n        for (let word of words) {\\n            if (word.length + cur.length + num_of_letters > maxWidth) {\\n                for (let i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.length - 1 || 1)] += \\' \\';\\n                }\\n                res.push(cur.join(\\'\\'));\\n                cur = [];\\n                num_of_letters = 0;\\n            }\\n            cur.push(word);\\n            num_of_letters += word.length;\\n        }\\n\\n        let lastLine = cur.join(\\' \\');\\n        while (lastLine.length < maxWidth) lastLine += \\' \\';\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        var res = new List<string>();\\n        var cur = new List<string>();\\n        int num_of_letters = 0;\\n\\n        foreach (var word in words) {\\n            if (word.Length + cur.Count + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.Count - 1 > 0 ? cur.Count - 1 : 1)] += \" \";\\n                }\\n                res.Add(string.Join(\"\", cur));\\n                cur.Clear();\\n                num_of_letters = 0;\\n            }\\n            cur.Add(word);\\n            num_of_letters += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", cur);\\n        while (lastLine.Length < maxWidth) lastLine += \" \";\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\\n``` Go []\\nfunc fullJustify(words []string, maxWidth int) []string {\\n    var res []string\\n    var cur []string\\n    num_of_letters := 0\\n\\n    for _, word := range words {\\n        if len(word) + len(cur) + num_of_letters > maxWidth {\\n            for i := 0; i < maxWidth - num_of_letters; i++ {\\n                cur[i % max(1, len(cur) - 1)] += \" \"\\n            }\\n            res = append(res, strings.Join(cur, \"\"))\\n            cur = cur[:0]\\n            num_of_letters = 0\\n        }\\n        cur = append(cur, word)\\n        num_of_letters += len(word)\\n    }\\n\\n    lastLine := strings.Join(cur, \" \")\\n    for len(lastLine) < maxWidth {\\n        lastLine += \" \"\\n    }\\n    res = append(res, lastLine)\\n\\n    return res\\n}\\n\\n// Helper function to get the maximum of two integers\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\\n        let mut res = Vec::new();\\n        let mut cur = Vec::new();\\n        let mut num_of_letters: i32 = 0;\\n\\n        for word in &words {\\n            if word.len() as i32 + cur.len() as i32 + num_of_letters > max_width {\\n                for i in 0..(max_width - num_of_letters) {\\n                    let idx = i as usize % (if cur.len() > 1 { cur.len() - 1 } else { cur.len() });\\n                    cur[idx] = format!(\"{} \", cur[idx]);\\n                }\\n                res.push(cur.join(\"\"));\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push(word.clone());\\n            num_of_letters += word.len() as i32;\\n        }\\n\\n        let last_line = cur.join(\" \");\\n        res.push(format!(\"{:<width$}\", last_line, width=max_width as usize));\\n\\n        res\\n    }\\n}\\n```\\n\\n# Code Gap-based\\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, cur_words, cur_len = [], [], 0\\n\\n        for word in words:\\n            if cur_len + len(word) + len(cur_words) > maxWidth:\\n                total_spaces = maxWidth - cur_len\\n                gaps = len(cur_words) - 1\\n                if gaps == 0:\\n                    res.append(cur_words[0] + \\' \\' * total_spaces)\\n                else:\\n                    space_per_gap = total_spaces // gaps\\n                    extra_spaces = total_spaces % gaps\\n                    line = \\'\\'\\n                    for i, w in enumerate(cur_words):\\n                        line += w\\n                        if i < gaps:\\n                            line += \\' \\' * space_per_gap\\n                            if i < extra_spaces:\\n                                line += \\' \\'\\n                    res.append(line)\\n                cur_words, cur_len = [], 0\\n            cur_words.append(word)\\n            cur_len += len(word)\\n\\n        last_line = \\' \\'.join(cur_words)\\n        remaining_spaces = maxWidth - len(last_line)\\n        res.append(last_line + \\' \\' * remaining_spaces)\\n\\n        return res\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res, cur_words;\\n        int cur_len = 0;\\n\\n        for (const std::string& word : words) {\\n            if (cur_len + word.length() + cur_words.size() > maxWidth) {\\n                int total_spaces = maxWidth - cur_len;\\n                int gaps = cur_words.size() - 1;\\n                if (gaps == 0) {\\n                    res.push_back(cur_words[0] + std::string(total_spaces, \\' \\'));\\n                } else {\\n                    int space_per_gap = total_spaces / gaps;\\n                    int extra_spaces = total_spaces % gaps;\\n                    std::string line = \"\";\\n                    for (int i = 0; i < cur_words.size(); ++i) {\\n                        line += cur_words[i];\\n                        if (i < gaps) {\\n                            line += std::string(space_per_gap, \\' \\');\\n                            if (i < extra_spaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push_back(line);\\n                }\\n                cur_words.clear();\\n                cur_len = 0;\\n            }\\n            cur_words.push_back(word);\\n            cur_len += word.length();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (const std::string& word : cur_words) {\\n            if (!last_line.empty()) {\\n                last_line += \\' \\';\\n            }\\n            last_line += word;\\n        }\\n        last_line += std::string(maxWidth - last_line.length(), \\' \\');\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> curWords = new ArrayList<>();\\n        int curLen = 0;\\n\\n        for (String word : words) {\\n            if (curLen + word.length() + curWords.size() > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.size() - 1;\\n                if (gaps == 0) {\\n                    res.add(curWords.get(0) + \" \".repeat(totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.size(); i++) {\\n                        line.append(curWords.get(i));\\n                        if (i < gaps) {\\n                            line.append(\" \".repeat(spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.add(line.toString());\\n                }\\n                curWords.clear();\\n                curLen = 0;\\n            }\\n            curWords.add(word);\\n            curLen += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", curWords));\\n        while (lastLine.length() < maxWidth) {\\n            lastLine.append(\\' \\');\\n        }\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        List<string> curWords = new List<string>();\\n        int curLen = 0;\\n\\n        foreach (string word in words) {\\n            if (curLen + word.Length + curWords.Count > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.Count - 1;\\n                if (gaps == 0) {\\n                    res.Add(curWords[0] + new string(\\' \\', totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.Count; i++) {\\n                        line.Append(curWords[i]);\\n                        if (i < gaps) {\\n                            line.Append(new string(\\' \\', spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.Append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.Add(line.ToString());\\n                }\\n                curWords.Clear();\\n                curLen = 0;\\n            }\\n            curWords.Add(word);\\n            curLen += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", curWords);\\n        while (lastLine.Length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let curWords = [];\\n        let curLen = 0;\\n\\n        for (let word of words) {\\n            if (curLen + word.length + curWords.length > maxWidth) {\\n                let totalSpaces = maxWidth - curLen;\\n                let gaps = curWords.length - 1;\\n                if (gaps === 0) {\\n                    res.push(curWords[0] + \\' \\'.repeat(totalSpaces));\\n                } else {\\n                    let spacePerGap = Math.floor(totalSpaces / gaps);\\n                    let extraSpaces = totalSpaces % gaps;\\n                    let line = \\'\\';\\n                    for (let i = 0; i < curWords.length; i++) {\\n                        line += curWords[i];\\n                        if (i < gaps) {\\n                            line += \\' \\'.repeat(spacePerGap);\\n                            if (i < extraSpaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push(line);\\n                }\\n                curWords = [];\\n                curLen = 0;\\n            }\\n            curWords.push(word);\\n            curLen += word.length;\\n        }\\n\\n        let lastLine = curWords.join(\\' \\');\\n        while (lastLine.length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\\n\\nThe choice between the two methods will depend on the specific use-case and the preference for clarity vs. conciseness. Both approaches offer an efficient way to tackle the problem of text justification. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String"
                ],
                "code": "```\\n[\\n  \"This    is    an\",\\n  \"example  of text\",\\n  \"justification.  \"\\n]\\n```\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, line, width = [], [], 0\\n\\n        for w in words:\\n            if width + len(w) + len(line) > maxWidth:\\n                for i in range(maxWidth - width): line[i % (len(line) - 1 or 1)] += \\' \\'\\n                res, line, width = res + [\\'\\'.join(line)], [], 0\\n            line += [w]\\n            width += len(w)\\n\\n        return res + [\\' \\'.join(line).ljust(maxWidth)]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res;\\n        std::vector<std::string> cur;\\n        int num_of_letters = 0;\\n\\n        for (std::string word : words) {\\n            if (word.size() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.size() - 1 ? cur.size() - 1 : 1)] += \\' \\';\\n                }\\n                res.push_back(\"\");\\n                for (std::string s : cur) res.back() += s;\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push_back(word);\\n            num_of_letters += word.size();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (std::string s : cur) last_line += s + \\' \\';\\n        last_line = last_line.substr(0, last_line.size()-1);  // remove trailing space\\n        while (last_line.size() < maxWidth) last_line += \\' \\';\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int num_of_letters = 0;\\n\\n        for (String word : words) {\\n            if (word.length() + cur.size() + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur.set(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1), cur.get(i % (cur.size() - 1 > 0 ? cur.size() - 1 : 1)) + \" \");\\n                }\\n                StringBuilder sb = new StringBuilder();\\n                for (String s : cur) sb.append(s);\\n                res.add(sb.toString());\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.add(word);\\n            num_of_letters += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder();\\n        for (int i = 0; i < cur.size(); i++) {\\n            lastLine.append(cur.get(i));\\n            if (i != cur.size() - 1) lastLine.append(\" \");\\n        }\\n        while (lastLine.length() < maxWidth) lastLine.append(\" \");\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let cur = [];\\n        let num_of_letters = 0;\\n\\n        for (let word of words) {\\n            if (word.length + cur.length + num_of_letters > maxWidth) {\\n                for (let i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.length - 1 || 1)] += \\' \\';\\n                }\\n                res.push(cur.join(\\'\\'));\\n                cur = [];\\n                num_of_letters = 0;\\n            }\\n            cur.push(word);\\n            num_of_letters += word.length;\\n        }\\n\\n        let lastLine = cur.join(\\' \\');\\n        while (lastLine.length < maxWidth) lastLine += \\' \\';\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        var res = new List<string>();\\n        var cur = new List<string>();\\n        int num_of_letters = 0;\\n\\n        foreach (var word in words) {\\n            if (word.Length + cur.Count + num_of_letters > maxWidth) {\\n                for (int i = 0; i < maxWidth - num_of_letters; i++) {\\n                    cur[i % (cur.Count - 1 > 0 ? cur.Count - 1 : 1)] += \" \";\\n                }\\n                res.Add(string.Join(\"\", cur));\\n                cur.Clear();\\n                num_of_letters = 0;\\n            }\\n            cur.Add(word);\\n            num_of_letters += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", cur);\\n        while (lastLine.Length < maxWidth) lastLine += \" \";\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\n``` Go []\\nfunc fullJustify(words []string, maxWidth int) []string {\\n    var res []string\\n    var cur []string\\n    num_of_letters := 0\\n\\n    for _, word := range words {\\n        if len(word) + len(cur) + num_of_letters > maxWidth {\\n            for i := 0; i < maxWidth - num_of_letters; i++ {\\n                cur[i % max(1, len(cur) - 1)] += \" \"\\n            }\\n            res = append(res, strings.Join(cur, \"\"))\\n            cur = cur[:0]\\n            num_of_letters = 0\\n        }\\n        cur = append(cur, word)\\n        num_of_letters += len(word)\\n    }\\n\\n    lastLine := strings.Join(cur, \" \")\\n    for len(lastLine) < maxWidth {\\n        lastLine += \" \"\\n    }\\n    res = append(res, lastLine)\\n\\n    return res\\n}\\n\\n// Helper function to get the maximum of two integers\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\\n        let mut res = Vec::new();\\n        let mut cur = Vec::new();\\n        let mut num_of_letters: i32 = 0;\\n\\n        for word in &words {\\n            if word.len() as i32 + cur.len() as i32 + num_of_letters > max_width {\\n                for i in 0..(max_width - num_of_letters) {\\n                    let idx = i as usize % (if cur.len() > 1 { cur.len() - 1 } else { cur.len() });\\n                    cur[idx] = format!(\"{} \", cur[idx]);\\n                }\\n                res.push(cur.join(\"\"));\\n                cur.clear();\\n                num_of_letters = 0;\\n            }\\n            cur.push(word.clone());\\n            num_of_letters += word.len() as i32;\\n        }\\n\\n        let last_line = cur.join(\" \");\\n        res.push(format!(\"{:<width$}\", last_line, width=max_width as usize));\\n\\n        res\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res, cur_words, cur_len = [], [], 0\\n\\n        for word in words:\\n            if cur_len + len(word) + len(cur_words) > maxWidth:\\n                total_spaces = maxWidth - cur_len\\n                gaps = len(cur_words) - 1\\n                if gaps == 0:\\n                    res.append(cur_words[0] + \\' \\' * total_spaces)\\n                else:\\n                    space_per_gap = total_spaces // gaps\\n                    extra_spaces = total_spaces % gaps\\n                    line = \\'\\'\\n                    for i, w in enumerate(cur_words):\\n                        line += w\\n                        if i < gaps:\\n                            line += \\' \\' * space_per_gap\\n                            if i < extra_spaces:\\n                                line += \\' \\'\\n                    res.append(line)\\n                cur_words, cur_len = [], 0\\n            cur_words.append(word)\\n            cur_len += len(word)\\n\\n        last_line = \\' \\'.join(cur_words)\\n        remaining_spaces = maxWidth - len(last_line)\\n        res.append(last_line + \\' \\' * remaining_spaces)\\n\\n        return res\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<std::string> fullJustify(std::vector<std::string>& words, int maxWidth) {\\n        std::vector<std::string> res, cur_words;\\n        int cur_len = 0;\\n\\n        for (const std::string& word : words) {\\n            if (cur_len + word.length() + cur_words.size() > maxWidth) {\\n                int total_spaces = maxWidth - cur_len;\\n                int gaps = cur_words.size() - 1;\\n                if (gaps == 0) {\\n                    res.push_back(cur_words[0] + std::string(total_spaces, \\' \\'));\\n                } else {\\n                    int space_per_gap = total_spaces / gaps;\\n                    int extra_spaces = total_spaces % gaps;\\n                    std::string line = \"\";\\n                    for (int i = 0; i < cur_words.size(); ++i) {\\n                        line += cur_words[i];\\n                        if (i < gaps) {\\n                            line += std::string(space_per_gap, \\' \\');\\n                            if (i < extra_spaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push_back(line);\\n                }\\n                cur_words.clear();\\n                cur_len = 0;\\n            }\\n            cur_words.push_back(word);\\n            cur_len += word.length();\\n        }\\n\\n        std::string last_line = \"\";\\n        for (const std::string& word : cur_words) {\\n            if (!last_line.empty()) {\\n                last_line += \\' \\';\\n            }\\n            last_line += word;\\n        }\\n        last_line += std::string(maxWidth - last_line.length(), \\' \\');\\n        res.push_back(last_line);\\n\\n        return res;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        List<String> curWords = new ArrayList<>();\\n        int curLen = 0;\\n\\n        for (String word : words) {\\n            if (curLen + word.length() + curWords.size() > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.size() - 1;\\n                if (gaps == 0) {\\n                    res.add(curWords.get(0) + \" \".repeat(totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.size(); i++) {\\n                        line.append(curWords.get(i));\\n                        if (i < gaps) {\\n                            line.append(\" \".repeat(spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.add(line.toString());\\n                }\\n                curWords.clear();\\n                curLen = 0;\\n            }\\n            curWords.add(word);\\n            curLen += word.length();\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", curWords));\\n        while (lastLine.length() < maxWidth) {\\n            lastLine.append(\\' \\');\\n        }\\n        res.add(lastLine.toString());\\n\\n        return res;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        List<string> curWords = new List<string>();\\n        int curLen = 0;\\n\\n        foreach (string word in words) {\\n            if (curLen + word.Length + curWords.Count > maxWidth) {\\n                int totalSpaces = maxWidth - curLen;\\n                int gaps = curWords.Count - 1;\\n                if (gaps == 0) {\\n                    res.Add(curWords[0] + new string(\\' \\', totalSpaces));\\n                } else {\\n                    int spacePerGap = totalSpaces / gaps;\\n                    int extraSpaces = totalSpaces % gaps;\\n                    StringBuilder line = new StringBuilder();\\n                    for (int i = 0; i < curWords.Count; i++) {\\n                        line.Append(curWords[i]);\\n                        if (i < gaps) {\\n                            line.Append(new string(\\' \\', spacePerGap));\\n                            if (i < extraSpaces) {\\n                                line.Append(\\' \\');\\n                            }\\n                        }\\n                    }\\n                    res.Add(line.ToString());\\n                }\\n                curWords.Clear();\\n                curLen = 0;\\n            }\\n            curWords.Add(word);\\n            curLen += word.Length;\\n        }\\n\\n        string lastLine = string.Join(\" \", curWords);\\n        while (lastLine.Length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.Add(lastLine);\\n\\n        return res;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n        let res = [];\\n        let curWords = [];\\n        let curLen = 0;\\n\\n        for (let word of words) {\\n            if (curLen + word.length + curWords.length > maxWidth) {\\n                let totalSpaces = maxWidth - curLen;\\n                let gaps = curWords.length - 1;\\n                if (gaps === 0) {\\n                    res.push(curWords[0] + \\' \\'.repeat(totalSpaces));\\n                } else {\\n                    let spacePerGap = Math.floor(totalSpaces / gaps);\\n                    let extraSpaces = totalSpaces % gaps;\\n                    let line = \\'\\';\\n                    for (let i = 0; i < curWords.length; i++) {\\n                        line += curWords[i];\\n                        if (i < gaps) {\\n                            line += \\' \\'.repeat(spacePerGap);\\n                            if (i < extraSpaces) {\\n                                line += \\' \\';\\n                            }\\n                        }\\n                    }\\n                    res.push(line);\\n                }\\n                curWords = [];\\n                curLen = 0;\\n            }\\n            curWords.push(word);\\n            curLen += word.length;\\n        }\\n\\n        let lastLine = curWords.join(\\' \\');\\n        while (lastLine.length < maxWidth) {\\n            lastLine += \\' \\';\\n        }\\n        res.push(lastLine);\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191149,
                "title": "readable-python-solution-which-beats-99-65",
                "content": "The challenge  is to answer  two questions:\\n1.  How many words we need to form each line;  \\n2.  How many spaces we should insert between two words.\\n\\nThe first question is solved by the helper function: getKwords(), and the second question is solved by the helper function: insertSpace().\\n``` \\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \\'\\'\\'\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \\'\\'\\'\\n        n = len(words)\\n        L = maxWidth\\n        i = 0     # the index of the current word   \\n        ans = [] \\n        \\n        def getKwords(i):\\n            k = 0 # figure out how many words can fit into a line\\n            l = \\' \\'.join(words[i:i+k]) \\n            while len(l) <= L and i+k <= n:\\n                k += 1\\n                l = \\' \\'.join(words[i:i+k])\\n            k -= 1 \\n            return k\\n        \\n        \\n        def insertSpace(i, k):\\n            \\'\\'\\' concatenate words[i:i+k] into one line\\'\\'\\'\\n            l = \\' \\'.join(words[i:i+k])       \\n            if k == 1 or i + k == n:        # if the line contains only one word or it is the last line  \\n                spaces = L - len(l)         # we just need to left assigned it\\n                line = l + \\' \\' * spaces \\n            else:                           \\n                spaces = L - len(l) + (k-1) # total number of spaces we need insert  \\n                space = spaces // (k-1)     # average number of spaces we should insert between two words\\n                left = spaces % (k-1)       # number of \\'left\\' words, i.e. words that have 1 more space than the other words on the right side\\n                if left > 0:\\n                    line = ( \" \" * (space + 1) ).join(words[i:i+left])  # left words\\n                    line += \" \" * (space + 1)                           # spaces between left words & right words\\n                    line += (\" \" * space).join(words[i+left:i+k])       # right woreds\\n                else: \\n                    line = (\" \" * space).join(words[i:i+k])\\n            return line\\n        \\n\\n        while i < n: \\n            k = getKwords(i)  \\n            line = insertSpace(i, k) # create a line which contains words from words[i] to words[i+k-1]\\n            ans.append(line) \\n            i += k \\n        return ans\\t\\t\\n``` ",
                "solutionTags": [],
                "code": "``` \\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \\'\\'\\'\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \\'\\'\\'\\n        n = len(words)\\n        L = maxWidth\\n        i = 0     # the index of the current word   \\n        ans = [] \\n        \\n        def getKwords(i):\\n            k = 0 # figure out how many words can fit into a line\\n            l = \\' \\'.join(words[i:i+k]) \\n            while len(l) <= L and i+k <= n:\\n                k += 1\\n                l = \\' \\'.join(words[i:i+k])\\n            k -= 1 \\n            return k\\n        \\n        \\n        def insertSpace(i, k):\\n            \\'\\'\\' concatenate words[i:i+k] into one line\\'\\'\\'\\n            l = \\' \\'.join(words[i:i+k])       \\n            if k == 1 or i + k == n:        # if the line contains only one word or it is the last line  \\n                spaces = L - len(l)         # we just need to left assigned it\\n                line = l + \\' \\' * spaces \\n            else:                           \\n                spaces = L - len(l) + (k-1) # total number of spaces we need insert  \\n                space = spaces // (k-1)     # average number of spaces we should insert between two words\\n                left = spaces % (k-1)       # number of \\'left\\' words, i.e. words that have 1 more space than the other words on the right side\\n                if left > 0:\\n                    line = ( \" \" * (space + 1) ).join(words[i:i+left])  # left words\\n                    line += \" \" * (space + 1)                           # spaces between left words & right words\\n                    line += (\" \" * space).join(words[i+left:i+k])       # right woreds\\n                else: \\n                    line = (\" \" * space).join(words[i:i+k])\\n            return line\\n        \\n\\n        while i < n: \\n            k = getKwords(i)  \\n            line = insertSpace(i, k) # create a line which contains words from words[i] to words[i+k-1]\\n            ans.append(line) \\n            i += k \\n        return ans\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572814,
                "title": "one-pass-easy-to-understand-with-comments-o-n",
                "content": "We\\'ll build the result array line by line while iterating over words in the input. Whenever the current line gets too big, we\\'ll appropriately format it and proceed with the next line until for loop is over. Last but not least, we\\'ll need to left-justify the last line.\\n\\nTime complexity is **O(n)**:\\nThere is just one for loop, which iterates over words provided as input.\\nSpace complexity: **O(n + l)**\\nWhere **n** is lenght of words, and **l** max length of words in one line. Worst case scenario **l = n**, which will add up to **O(2n)** but in asymptotic analysis we don\\'t care about constants so final complexity is linear: **O(n)**\\n\\n```\\nclass Solution:\\n\\t# Why slots: https://docs.python.org/3/reference/datamodel.html#slots\\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\\n    __slots__ = ()\\n\\t\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n\\t    # Init return array in which, we\\'ll store justified lines\\n        lines = []\\n\\t\\t# current line width\\n        width = 0\\n\\t\\t# current line words\\n        line = []\\n        \\n        for word in words:\\n\\t\\t\\t# Gather as many words that will fit under maxWidth restrictions.\\n\\t\\t\\t# Line length is a sum of:\\n\\t\\t\\t# 1) Current word length\\n\\t\\t\\t# 2) Sum of words already in the current line\\n\\t\\t\\t# 3) Number of spaces (each word needs to be separated by at least one space)\\n            if (len(word) + width + len(line)) <= maxWidth:\\n                width += len(word)\\n                line.append(word)\\n                continue\\n            \\n\\t\\t\\t# If the current line only contains one word, fill the remaining string with spaces.\\n            if len(line) == 1:\\n\\t\\t\\t\\t# Use the format function to fill the remaining string with spaces easily and readable.\\n\\t\\t\\t\\t# For letcode police, yes you could do something like:\\n\\t\\t\\t\\t#     line = \" \".join(line)\\n\\t\\t\\t\\t#     line += \" \" * (maxWidth - len(line))\\n\\t\\t\\t\\t#     lines.append(line)\\n\\t\\t\\t\\t# to be more \"raw\", but I see no point in that.\\n                lines.append(\\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\\n                )\\n            else:\\n\\t\\t\\t    # Else calculate how many common spaces and extra spaces are there for the current line.\\n\\t\\t\\t\\t# Example:\\n                #  line = [\\'a\\', \\'computer.\\', \\'Art\\', \\'is\\']\\n\\t\\t\\t\\t# width left in line equals to: maxWidth - width: 20 - 15 = 5\\n\\t\\t\\t\\t# len(line) - 1 because to the last word, we aren\\'t adding any spaces\\n\\t\\t\\t\\t# Now divmod will give us how many spaces are for all words and how many extra to distribute.\\n\\t\\t\\t\\t# divmod(5, 3) = 1, 2\\n\\t\\t\\t\\t# This means there should be one common space for each word, and for the first two, add one extra space.\\n                space, extra = divmod(\\n                    maxWidth - width,\\n                    len(line) - 1\\n                )\\n                \\n                i = 0\\n\\t\\t\\t\\t# Distribute extra spaces first\\n\\t\\t\\t\\t# There cannot be a case where extra spaces count is greater or equal to number words in the current line.\\n                while extra > 0:\\n                    line[i] += \" \"\\n                    extra -= 1\\n                    i += 1\\n                \\n\\t\\t\\t\\t# Join line array into a string by common spaces, and append to justified lines.\\n                lines.append(\\n                    (\" \" * space).join(line)\\n                )\\n            \\n\\t\\t\\t# Create new line array with the current word in iteration, and reset current line width as well.\\n            line = [word]\\n            width = len(word)\\n        \\n\\t\\t# Last but not least format last line to be left-justified with no extra space inserted between words.\\n\\t\\t# No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\\n        lines.append(\\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\\n        )\\n        \\n        return lines\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\t# Why slots: https://docs.python.org/3/reference/datamodel.html#slots\\n    # TLDR: 1. faster attribute access. 2. space savings in memory.\\n    # For letcode problems this can save ~ 0.1MB of memory <insert is something meme>\\n    __slots__ = ()\\n\\t\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n\\t    # Init return array in which, we\\'ll store justified lines\\n        lines = []\\n\\t\\t# current line width\\n        width = 0\\n\\t\\t# current line words\\n        line = []\\n        \\n        for word in words:\\n\\t\\t\\t# Gather as many words that will fit under maxWidth restrictions.\\n\\t\\t\\t# Line length is a sum of:\\n\\t\\t\\t# 1) Current word length\\n\\t\\t\\t# 2) Sum of words already in the current line\\n\\t\\t\\t# 3) Number of spaces (each word needs to be separated by at least one space)\\n            if (len(word) + width + len(line)) <= maxWidth:\\n                width += len(word)\\n                line.append(word)\\n                continue\\n            \\n\\t\\t\\t# If the current line only contains one word, fill the remaining string with spaces.\\n            if len(line) == 1:\\n\\t\\t\\t\\t# Use the format function to fill the remaining string with spaces easily and readable.\\n\\t\\t\\t\\t# For letcode police, yes you could do something like:\\n\\t\\t\\t\\t#     line = \" \".join(line)\\n\\t\\t\\t\\t#     line += \" \" * (maxWidth - len(line))\\n\\t\\t\\t\\t#     lines.append(line)\\n\\t\\t\\t\\t# to be more \"raw\", but I see no point in that.\\n                lines.append(\\n                    \"{0: <{width}}\".format( \" \".join(line), width=maxWidth)\\n                )\\n            else:\\n\\t\\t\\t    # Else calculate how many common spaces and extra spaces are there for the current line.\\n\\t\\t\\t\\t# Example:\\n                #  line = [\\'a\\', \\'computer.\\', \\'Art\\', \\'is\\']\\n\\t\\t\\t\\t# width left in line equals to: maxWidth - width: 20 - 15 = 5\\n\\t\\t\\t\\t# len(line) - 1 because to the last word, we aren\\'t adding any spaces\\n\\t\\t\\t\\t# Now divmod will give us how many spaces are for all words and how many extra to distribute.\\n\\t\\t\\t\\t# divmod(5, 3) = 1, 2\\n\\t\\t\\t\\t# This means there should be one common space for each word, and for the first two, add one extra space.\\n                space, extra = divmod(\\n                    maxWidth - width,\\n                    len(line) - 1\\n                )\\n                \\n                i = 0\\n\\t\\t\\t\\t# Distribute extra spaces first\\n\\t\\t\\t\\t# There cannot be a case where extra spaces count is greater or equal to number words in the current line.\\n                while extra > 0:\\n                    line[i] += \" \"\\n                    extra -= 1\\n                    i += 1\\n                \\n\\t\\t\\t\\t# Join line array into a string by common spaces, and append to justified lines.\\n                lines.append(\\n                    (\" \" * space).join(line)\\n                )\\n            \\n\\t\\t\\t# Create new line array with the current word in iteration, and reset current line width as well.\\n            line = [word]\\n            width = len(word)\\n        \\n\\t\\t# Last but not least format last line to be left-justified with no extra space inserted between words.\\n\\t\\t# No matter the input, there always be the last line at the end of for loop, which makes things even easier considering the requirement.\\n        lines.append(\\n            \"{0: <{width}}\".format(\" \".join(line), width=maxWidth)\\n        )\\n        \\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24972,
                "title": "i-guess-i-just-wrote-an-essay-but-finally-passed-all-test-cases-ugh",
                "content": "    public List<String> fullJustify(String[] words, int L) {\\n        int length = L;\\n        ArrayList<String> cur_line = new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        if(words[0]==\"\")\\n        {\\n            String resNull =\"\";\\n            for(int i=0; i<L;i++)\\n                resNull=resNull+\" \";\\n            res.add(resNull);\\n            return res;\\n        }\\n        for(int i=0; i<words.length; i++)\\n        {\\n            //there is room left for current line ex:\"this is a bat  \"\\n            if(length-(words[i].length()+1)>0)  \\n            {\\n                length=length-(words[i].length()+1); //get remainning available spaces in cur line\\n                cur_line.add(words[i]); //add the word to the list \\n            }\\n            //just fit in current line   ex:\"this is a book\" or \"this is a bat \"\\n            else if(length-(words[i].length()+1)==-1 ||length-(words[i].length()+1)==0) \\n            {\\n                cur_line.add(words[i]); //add the last word to the list\\n                //proccess line\\n                boolean lastLine;\\n                if(i==words.length-1) lastLine=true;\\n                else lastLine=false;\\n                res.add(processLine(cur_line, L, lastLine));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line = new ArrayList<String>();\\n            }\\n            //there is no room to fit this one\\n            else if(length-(words[i].length()+1)<-1)\\n            {\\n                //first proccess cur line\\n                res.add(processLine(cur_line, L, false));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line=new ArrayList<String>();\\n                //put this one it it\\n                length=length-(words[i].length()+1);\\n                cur_line.add(words[i]);\\n            }\\n        }\\n        if(cur_line.size()!=0)\\n            res.add(processLine(cur_line, L, true));\\n        return res;\\n    }\\n    public String processLine(ArrayList<String>words, int L, boolean lastLine)\\n    {\\n        String lineString=\"\";\\n        if(words.size()==1)\\n        {\\n            String singleWord = words.get(0);\\n            int len =singleWord.length();\\n            for(int i=0;i<L-len;i++)\\n                singleWord = singleWord+\" \";\\n            return singleWord;\\n        }\\n        int reminder = L;\\n        for(String word: words)\\n            reminder = reminder-word.length();\\n        if(lastLine==true)\\n        {\\n            for(String word:words)\\n            {\\n                if(reminder!=0)\\n                    lineString = lineString+word+\" \";\\n                else\\n                    lineString = lineString+word;\\n                reminder--;\\n            }\\n            for(int i=0; i<reminder;i++)\\n                lineString = lineString+\" \";\\n            return lineString;\\n        }\\n        //there is extra spaces-->reminder\\n        int flag = reminder % (words.size()-1);\\n        int commonSpace = reminder/(words.size()-1);\\n        int extra = flag>0? 1:0;\\n        for(int i=0; i<words.size()-1;i++)\\n        {\\n            String spaces=\"\";\\n            for(int count =0; count<(commonSpace+extra);count++)\\n                 spaces = spaces+\" \";\\n            lineString = lineString +words.get(i)+spaces;\\n            flag--;\\n            extra = flag>0? 1:0;\\n        }\\n        lineString = lineString +words.get(words.size()-1);\\n        return lineString;\\n    }",
                "solutionTags": [],
                "code": "    public List<String> fullJustify(String[] words, int L) {\\n        int length = L;\\n        ArrayList<String> cur_line = new ArrayList<String>();\\n        List<String> res = new ArrayList<String>();\\n        if(words[0]==\"\")\\n        {\\n            String resNull =\"\";\\n            for(int i=0; i<L;i++)\\n                resNull=resNull+\" \";\\n            res.add(resNull);\\n            return res;\\n        }\\n        for(int i=0; i<words.length; i++)\\n        {\\n            //there is room left for current line ex:\"this is a bat  \"\\n            if(length-(words[i].length()+1)>0)  \\n            {\\n                length=length-(words[i].length()+1); //get remainning available spaces in cur line\\n                cur_line.add(words[i]); //add the word to the list \\n            }\\n            //just fit in current line   ex:\"this is a book\" or \"this is a bat \"\\n            else if(length-(words[i].length()+1)==-1 ||length-(words[i].length()+1)==0) \\n            {\\n                cur_line.add(words[i]); //add the last word to the list\\n                //proccess line\\n                boolean lastLine;\\n                if(i==words.length-1) lastLine=true;\\n                else lastLine=false;\\n                res.add(processLine(cur_line, L, lastLine));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line = new ArrayList<String>();\\n            }\\n            //there is no room to fit this one\\n            else if(length-(words[i].length()+1)<-1)\\n            {\\n                //first proccess cur line\\n                res.add(processLine(cur_line, L, false));\\n                //start a new line\\n                length=L; //recover length--next line\\n                cur_line=new ArrayList<String>();\\n                //put this one it it\\n                length=length-(words[i].length()+1);\\n                cur_line.add(words[i]);\\n            }\\n        }\\n        if(cur_line.size()!=0)\\n            res.add(processLine(cur_line, L, true));\\n        return res;\\n    }\\n    public String processLine(ArrayList<String>words, int L, boolean lastLine)\\n    {\\n        String lineString=\"\";\\n        if(words.size()==1)\\n        {\\n            String singleWord = words.get(0);\\n            int len =singleWord.length();\\n            for(int i=0;i<L-len;i++)\\n                singleWord = singleWord+\" \";\\n            return singleWord;\\n        }\\n        int reminder = L;\\n        for(String word: words)\\n            reminder = reminder-word.length();\\n        if(lastLine==true)\\n        {\\n            for(String word:words)\\n            {\\n                if(reminder!=0)\\n                    lineString = lineString+word+\" \";\\n                else\\n                    lineString = lineString+word;\\n                reminder--;\\n            }\\n            for(int i=0; i<reminder;i++)\\n                lineString = lineString+\" \";\\n            return lineString;\\n        }\\n        //there is extra spaces-->reminder\\n        int flag = reminder % (words.size()-1);\\n        int commonSpace = reminder/(words.size()-1);\\n        int extra = flag>0? 1:0;\\n        for(int i=0; i<words.size()-1;i++)\\n        {\\n            String spaces=\"\";\\n            for(int count =0; count<(commonSpace+extra);count++)\\n                 spaces = spaces+\" \";\\n            lineString = lineString +words.get(i)+spaces;\\n            flag--;\\n            extra = flag>0? 1:0;\\n        }\\n        lineString = lineString +words.get(words.size()-1);\\n        return lineString;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 390686,
                "title": "straightforward-python-solution-with-detailed-explanation",
                "content": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justifySingleLine(line, width, max_width):\\n            num_words = len(line)\\n            total_spaces = max_width - width\\n            if num_words == 1:\\n                # if there is only word in line\\n                # just insert total_spaces for the remainder of line\\n                return line[0] + \\' \\' * total_spaces\\n            else:\\n                locations = num_words - 1\\n                # spaces_inserted[i] is the number of spaces inserted between the words line[i] and line[i+1]\\n                spaces_inserted = locations * [total_spaces // locations]\\n                # distribute the remaining spaces to the left positions\\n                for i in range(total_spaces % locations):\\n                    spaces_inserted[i] += 1\\n                s = \\'\\'\\n                for i in range(locations):\\n                    s += line[i] # add the word line[i]\\n                    s += spaces_inserted[i] * \\' \\'# insert spaces\\n                s += line[-1] # add the last word\\n                return s\\n\\n        answer = []\\n        line, width = [], 0\\n        for word in words:\\n            if width + len(word) + len(line) <= maxWidth:\\n                # keep adding words until we can fill out maxWidth\\n                # width = sum of length of all words\\n                # len(word) = length of current word\\n                # len(line) = least number of spaces needed to be inserted\\n                line.append(word)\\n                width += len(word)\\n            else:\\n                # justify the line and add it to result\\n                answer.append(justifySingleLine(line, width, maxWidth))\\n                # reset new line and new width\\n                line, width = [word], len(word)\\n        remaining_spaces = maxWidth - width - len(line)\\n        answer.append(\\' \\'.join(line) + (remaining_spaces + 1) * \\' \\')\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justifySingleLine(line, width, max_width):\\n            num_words = len(line)\\n            total_spaces = max_width - width\\n            if num_words == 1:\\n                # if there is only word in line\\n                # just insert total_spaces for the remainder of line\\n                return line[0] + \\' \\' * total_spaces\\n            else:\\n                locations = num_words - 1\\n                # spaces_inserted[i] is the number of spaces inserted between the words line[i] and line[i+1]\\n                spaces_inserted = locations * [total_spaces // locations]\\n                # distribute the remaining spaces to the left positions\\n                for i in range(total_spaces % locations):\\n                    spaces_inserted[i] += 1\\n                s = \\'\\'\\n                for i in range(locations):\\n                    s += line[i] # add the word line[i]\\n                    s += spaces_inserted[i] * \\' \\'# insert spaces\\n                s += line[-1] # add the last word\\n                return s\\n\\n        answer = []\\n        line, width = [], 0\\n        for word in words:\\n            if width + len(word) + len(line) <= maxWidth:\\n                # keep adding words until we can fill out maxWidth\\n                # width = sum of length of all words\\n                # len(word) = length of current word\\n                # len(line) = least number of spaces needed to be inserted\\n                line.append(word)\\n                width += len(word)\\n            else:\\n                # justify the line and add it to result\\n                answer.append(justifySingleLine(line, width, maxWidth))\\n                # reset new line and new width\\n                line, width = [word], len(word)\\n        remaining_spaces = maxWidth - width - len(line)\\n        answer.append(\\' \\'.join(line) + (remaining_spaces + 1) * \\' \\')\\n        return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 149785,
                "title": "clean-javascript-solution",
                "content": "```javascript\\nconst fullJustify = (words, maxWidth) => {\\n  const n = words.length;\\n  const res = [];\\n\\n  for (var i = 0; i < n; i = j) {\\n    // Step 1. Use j to find out where to cut the row (i ... j-1)\\n    let len = -1;\\n    for (var j = i; j < n && len + 1 + words[j].length <= maxWidth; j++) {\\n      len += 1 + words[j].length;\\n    }\\n\\n    // Step 2. Calculate how many spaces to add for each word\\n    let spaces = 1; // avg. spaces reserved for each word\\n    let extra = 0; // extra left spaces\\n\\n    if (j !== i + 1 && j !== n) {\\n      spaces = (maxWidth - len) / (j - 1 - i) + 1;\\n      extra = (maxWidth - len) % (j - 1 - i);\\n    }\\n\\n    // Step 3. Build the row with spaces + extra space + word\\n    let row = words[i];\\n    for (let k = i + 1; k < j; k++, extra--) {\\n      row += \\' \\'.repeat(spaces + (extra > 0 ? 1 : 0)) + words[k];\\n    }\\n    row += \\' \\'.repeat(maxWidth - row.length);\\n\\n    // Step 4. Push the row to final result\\n    res.push(row);\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst fullJustify = (words, maxWidth) => {\\n  const n = words.length;\\n  const res = [];\\n\\n  for (var i = 0; i < n; i = j) {\\n    // Step 1. Use j to find out where to cut the row (i ... j-1)\\n    let len = -1;\\n    for (var j = i; j < n && len + 1 + words[j].length <= maxWidth; j++) {\\n      len += 1 + words[j].length;\\n    }\\n\\n    // Step 2. Calculate how many spaces to add for each word\\n    let spaces = 1; // avg. spaces reserved for each word\\n    let extra = 0; // extra left spaces\\n\\n    if (j !== i + 1 && j !== n) {\\n      spaces = (maxWidth - len) / (j - 1 - i) + 1;\\n      extra = (maxWidth - len) % (j - 1 - i);\\n    }\\n\\n    // Step 3. Build the row with spaces + extra space + word\\n    let row = words[i];\\n    for (let k = i + 1; k < j; k++, extra--) {\\n      row += \\' \\'.repeat(spaces + (extra > 0 ? 1 : 0)) + words[k];\\n    }\\n    row += \\' \\'.repeat(maxWidth - row.length);\\n\\n    // Step 4. Push the row to final result\\n    res.push(row);\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181479,
                "title": "very-easy-java-solution-with-explanation-beats-100",
                "content": "- The idea is to get the window from the words which can fit in a line.\\n    - while getting this window, we also keep following track:\\n        - len : len for the window from start to end including one space as minimum req \\n            Example len = 10 for \"THIS IS AN\"\\n        - count : keeps track of space holders in the string. Initial kept to -1.\\n            Example count = 2 for \"THIS IS AN\"\\n    - Upon getting the window, we now call a function addLine() which creates a line keeping track of 4 things\\n        - same : The equals spaces every word pair will have between them\\n        - extra : The extra ones, which are given one by one from left and decremented every time\\n        - trail : For cases such as last line OR only one word in the line, we need to append trail number of spaces to the line.\\n    \\n    Time Complexity : O(N*maxWidth) : N is number of lines\\n    Space Complexity : O(maxWidth)  : Space for a single line\\n\\t\\t\\n```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n         \\n        List<String> result = new ArrayList<>();\\n        int len = -1 , count = -1, start = 0;\\n        \\n        for(int i=0;i<words.length;i++){            \\n            if(len+words[i].length()+1<=maxWidth){\\n                len += words[i].length()+1;\\n                count++;                \\n            }\\n            else{                 \\n                addLine(words,start,i-1,len,count,maxWidth,result,false);\\n                start = i;\\n                i--;\\n                len = -1;\\n                count= -1;\\n            }\\n        }\\n        addLine(words,start,words.length-1,len,count,maxWidth,result,true);\\n        return result;\\n    }\\n    \\n    public void addLine(String[] words,int start, int end, int len, int count, int maxWidth, List<String> result,boolean isLast){\\n        \\n            int spaces = maxWidth-len;\\n            spaces += count;         \\n            int same = isLast || (count==0)? 0 : spaces/count;\\n            int extra = isLast || (count==0)? count : spaces%count;        \\n            int trail = isLast || (count==0) ? maxWidth-len : 0;\\n\\t\\t\\t\\t\\t\\t\\n            StringBuilder line = new StringBuilder();\\n                \\n            while(start<=end){\\n                line.append(words[start]);                    \\n                for(int k=0;k<same && start!=end;k++)\\n                    line.append(\\' \\');\\n                    \\n                if(extra>0){\\n                    line.append(\\' \\');\\n                    extra--;\\n                }\\n                start++;\\n            }        \\n            while(trail>0){\\n                line.append(\\' \\');\\n                trail--;\\n            }                \\n            result.add(line.toString());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n         \\n        List<String> result = new ArrayList<>();\\n        int len = -1 , count = -1, start = 0;\\n        \\n        for(int i=0;i<words.length;i++){            \\n            if(len+words[i].length()+1<=maxWidth){\\n                len += words[i].length()+1;\\n                count++;                \\n            }\\n            else{                 \\n                addLine(words,start,i-1,len,count,maxWidth,result,false);\\n                start = i;\\n                i--;\\n                len = -1;\\n                count= -1;\\n            }\\n        }\\n        addLine(words,start,words.length-1,len,count,maxWidth,result,true);\\n        return result;\\n    }\\n    \\n    public void addLine(String[] words,int start, int end, int len, int count, int maxWidth, List<String> result,boolean isLast){\\n        \\n            int spaces = maxWidth-len;\\n            spaces += count;         \\n            int same = isLast || (count==0)? 0 : spaces/count;\\n            int extra = isLast || (count==0)? count : spaces%count;        \\n            int trail = isLast || (count==0) ? maxWidth-len : 0;\\n\\t\\t\\t\\t\\t\\t\\n            StringBuilder line = new StringBuilder();\\n                \\n            while(start<=end){\\n                line.append(words[start]);                    \\n                for(int k=0;k<same && start!=end;k++)\\n                    line.append(\\' \\');\\n                    \\n                if(extra>0){\\n                    line.append(\\' \\');\\n                    extra--;\\n                }\\n                start++;\\n            }        \\n            while(trail>0){\\n                line.append(\\' \\');\\n                trail--;\\n            }                \\n            result.add(line.toString());\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25002,
                "title": "share-my-2-ms-30-lines-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> fullJustify(vector<string> &words, int L) {\\n            vector<string> ans;\\n            int begin = 0;\\n            while (begin < words.size()) {\\n                int last = begin;\\n                int linesize = words[begin++].size();\\n                while (begin < words.size() && linesize + 1 + words[begin].size() <= L) {\\n                    linesize += 1 + words[begin].size();\\n                    begin++;\\n                }\\n                \\n                int spaces = 1, extra = 0;\\n                if (begin < words.size() && begin != last + 1) {\\n                    spaces = (L - linesize) / (begin - last - 1) + 1;\\n                    extra = (L - linesize) % (begin - last - 1);\\n                }\\n                \\n                ans.push_back(words[last++]);\\n                while (extra--) {\\n                    ans.back().append(spaces+1, ' ');\\n                    ans.back().append(words[last++]);\\n                }\\n                while (last < begin) {\\n                    ans.back().append(spaces, ' ');\\n                    ans.back().append(words[last++]);\\n                }\\n                ans.back().append(L-ans.back().size(), ' ');\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> fullJustify(vector<string> &words, int L) {\\n            vector<string> ans;\\n            int begin = 0;\\n            while (begin < words.size()) {\\n                int last = begin;\\n                int linesize = words[begin++].size();\\n                while (begin < words.size() && linesize + 1 + words[begin].size() <= L) {\\n                    linesize += 1 + words[begin].size();\\n                    begin++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3952309,
                "title": "100-fast-easy-code-with-explanation-c-java-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust use loops .Try to understand the problem otherwise question is easy.\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n\\n1. Initialize an empty vector `res` to store the justified lines of text.\\n\\n2. Iterate through the input `words` vector using an index `i` to keep track of the current word being processed.\\n\\n3. In each iteration, find a range of words that can fit within the `maxWidth` limit. To do this, increment the index `j` while the accumulated length of the words (including spaces) remains within the limit.\\n\\n4. There are three cases to consider for formatting the words into a line:\\n\\n   a. If the range `[i, j)` contains only one word, or it\\'s the last line, left-justify the words. Add spaces between each word and pad the line with spaces on the right to achieve the `maxWidth`.\\n\\n   b. If the line has more than one word but it\\'s not the last line, calculate the total number of words in the line `tw` and the total space available `ts`. Divide `ts` by `(tw - 1)` to determine the standard space between words, and calculate the extra spaces that need to be distributed.\\n\\n5. Construct the justified line of text:\\n\\n   a. Initialize an empty string `s` to build the line.\\n\\n   b. For each word in the range `[i, j)`, append the word to `s`.\\n\\n   c. If it\\'s not the last word in the line, add the standard spacing calculated earlier. Distribute the extra spaces if available.\\n\\n6. Push the constructed line `s` into the result vector `res`.\\n\\n7. Update the index `i` to the value of `j - 1` to move to the next line.\\n\\n8. Repeat the process until all words are processed.\\n\\n9. Return the `res` vector containing the justified lines of text.\\n\\n**Explanation**:\\n\\nThe approach divides the problem into two main cases based on the number of words in a line. For lines containing only one word or being the last line, the words are left-justified with spaces added to reach the `maxWidth`. For lines with multiple words that are not the last line, spaces are distributed evenly between words to achieve the target width.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot (312).png](https://assets.leetcode.com/users/images/0c825012-e2c3-4f4e-9d13-5f02764c3ba8_1692850690.487161.png)\\n\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int c=words[i].size();\\n            int wc=words[i].size();\\n            while(j<n&&c+words[j].size()+1<=maxWidth){\\n                c+=words[j].size()+1;\\n                wc+=words[j].length();\\n                j++;\\n            }\\n           if(j==n||(j-i)==1){\\n               string s=\"\";\\n               for(int p=i;p<j;p++){\\n                   s+=words[p];\\n                   if(p!=j-1)\\n                   s+=\\' \\';\\n               }\\n               int ts=maxWidth-s.size();\\n               for(int k=0;k<ts;k++){\\n                   s+=\\' \\';\\n               }\\n               res.push_back(s);\\n               i=j-1;\\n           }\\n           else{\\n             int tw=j-i;\\n             int ts=maxWidth-wc;\\n             int es=ts/(tw-1);\\n             int extra=ts%(tw-1);\\n             string s=\"\";\\n             for(int p=i;p<j;p++){\\n                 s+=words[p];\\n                 if(extra>0){\\n                    s+=\\' \\';\\n                    extra--;\\n                 }\\n                 if(p!=j-1){\\n                for(int k=0;k<es;k++){\\n                   s+=\\' \\';\\n               }\\n                 }\\n             }\\n             res.push_back(s);\\n              i=j-1;\\n           }\\n           i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int n = words.length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].length();\\n            int wc = words[i].length();\\n            while (j < n && c + words[j].length() + 1 <= maxWidth) {\\n                c += words[j].length() + 1;\\n                wc += words[j].length();\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (p != j - 1)\\n                        s.append(\\' \\');\\n                }\\n                int ts = maxWidth - s.length();\\n                for (int k = 0; k < ts; k++) {\\n                    s.append(\\' \\');\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (extra > 0) {\\n                        s.append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        for (int k = 0; k < es; k++) {\\n                            s.append(\\' \\');\\n                        }\\n                    }\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        n = len(words)\\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            c = len(words[i])\\n            wc = len(words[i])\\n            while j < n and c + len(words[j]) + 1 <= maxWidth:\\n                c += len(words[j]) + 1\\n                wc += len(words[j])\\n                j += 1\\n            if j == n or j - i == 1:\\n                s = \\' \\'.join(words[i:j])\\n                ts = maxWidth - len(s)\\n                s += \\' \\' * ts\\n                res.append(s)\\n                i = j\\n            else:\\n                tw = j - i\\n                ts = maxWidth - wc\\n                es = ts // (tw - 1)\\n                extra = ts % (tw - 1)\\n                s = \\'\\'\\n                for p in range(i, j):\\n                    s += words[p]\\n                    if extra > 0:\\n                        s += \\' \\'\\n                        extra -= 1\\n                    if p != j - 1:\\n                        s += \\' \\' * es\\n                res.append(s)\\n                i = j\\n            i += 1\\n        return res\\n\\n```\\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        int n = words.Length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].Length;\\n            int wc = words[i].Length;\\n            while (j < n && c + words[j].Length + 1 <= maxWidth) {\\n                c += words[j].Length + 1;\\n                wc += words[j].Length;\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (p != j - 1)\\n                        s.Append(\\' \\');\\n                }\\n                int ts = maxWidth - s.Length;\\n                s.Append(\\' \\', ts);\\n                res.Add(s.ToString());\\n                i = j;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (extra > 0) {\\n                        s.Append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        s.Append(\\' \\', es);\\n                    }\\n                }\\n                res.Add(s.ToString());\\n                i = j;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            int j=i+1;\\n            int c=words[i].size();\\n            int wc=words[i].size();\\n            while(j<n&&c+words[j].size()+1<=maxWidth){\\n                c+=words[j].size()+1;\\n                wc+=words[j].length();\\n                j++;\\n            }\\n           if(j==n||(j-i)==1){\\n               string s=\"\";\\n               for(int p=i;p<j;p++){\\n                   s+=words[p];\\n                   if(p!=j-1)\\n                   s+=\\' \\';\\n               }\\n               int ts=maxWidth-s.size();\\n               for(int k=0;k<ts;k++){\\n                   s+=\\' \\';\\n               }\\n               res.push_back(s);\\n               i=j-1;\\n           }\\n           else{\\n             int tw=j-i;\\n             int ts=maxWidth-wc;\\n             int es=ts/(tw-1);\\n             int extra=ts%(tw-1);\\n             string s=\"\";\\n             for(int p=i;p<j;p++){\\n                 s+=words[p];\\n                 if(extra>0){\\n                    s+=\\' \\';\\n                    extra--;\\n                 }\\n                 if(p!=j-1){\\n                for(int k=0;k<es;k++){\\n                   s+=\\' \\';\\n               }\\n                 }\\n             }\\n             res.push_back(s);\\n              i=j-1;\\n           }\\n           i++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int n = words.length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].length();\\n            int wc = words[i].length();\\n            while (j < n && c + words[j].length() + 1 <= maxWidth) {\\n                c += words[j].length() + 1;\\n                wc += words[j].length();\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (p != j - 1)\\n                        s.append(\\' \\');\\n                }\\n                int ts = maxWidth - s.length();\\n                for (int k = 0; k < ts; k++) {\\n                    s.append(\\' \\');\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.append(words[p]);\\n                    if (extra > 0) {\\n                        s.append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        for (int k = 0; k < es; k++) {\\n                            s.append(\\' \\');\\n                        }\\n                    }\\n                }\\n                res.add(s.toString());\\n                i = j - 1;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        n = len(words)\\n        i = 0\\n        while i < n:\\n            j = i + 1\\n            c = len(words[i])\\n            wc = len(words[i])\\n            while j < n and c + len(words[j]) + 1 <= maxWidth:\\n                c += len(words[j]) + 1\\n                wc += len(words[j])\\n                j += 1\\n            if j == n or j - i == 1:\\n                s = \\' \\'.join(words[i:j])\\n                ts = maxWidth - len(s)\\n                s += \\' \\' * ts\\n                res.append(s)\\n                i = j\\n            else:\\n                tw = j - i\\n                ts = maxWidth - wc\\n                es = ts // (tw - 1)\\n                extra = ts % (tw - 1)\\n                s = \\'\\'\\n                for p in range(i, j):\\n                    s += words[p]\\n                    if extra > 0:\\n                        s += \\' \\'\\n                        extra -= 1\\n                    if p != j - 1:\\n                        s += \\' \\' * es\\n                res.append(s)\\n                i = j\\n            i += 1\\n        return res\\n\\n```\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> res = new List<string>();\\n        int n = words.Length;\\n        int i = 0;\\n        while (i < n) {\\n            int j = i + 1;\\n            int c = words[i].Length;\\n            int wc = words[i].Length;\\n            while (j < n && c + words[j].Length + 1 <= maxWidth) {\\n                c += words[j].Length + 1;\\n                wc += words[j].Length;\\n                j++;\\n            }\\n            if (j == n || j - i == 1) {\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (p != j - 1)\\n                        s.Append(\\' \\');\\n                }\\n                int ts = maxWidth - s.Length;\\n                s.Append(\\' \\', ts);\\n                res.Add(s.ToString());\\n                i = j;\\n            } else {\\n                int tw = j - i;\\n                int ts = maxWidth - wc;\\n                int es = ts / (tw - 1);\\n                int extra = ts % (tw - 1);\\n                StringBuilder s = new StringBuilder();\\n                for (int p = i; p < j; p++) {\\n                    s.Append(words[p]);\\n                    if (extra > 0) {\\n                        s.Append(\\' \\');\\n                        extra--;\\n                    }\\n                    if (p != j - 1) {\\n                        s.Append(\\' \\', es);\\n                    }\\n                }\\n                res.Add(s.ToString());\\n                i = j;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987109,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n     public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n}\\n```\\n\\n***JavaScript***\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n     private  val SEPARATOR = \" \" \\n    \\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n\\n        val result = mutableListOf<String>() // keeps the lines as a sting in a paragraph\\n        val currentLineWords = mutableListOf<String>()// keeps track of all the words for the current line\\n        var availableSpacePerLine = maxWidth //  keeps track of the available space in the current line\\n\\n        words.forEach { word ->\\n            availableSpacePerLine -= word.length\\n            when {\\n                (availableSpacePerLine == 0) -> { // the words perfectly fit\\n                    currentLineWords.add(word)\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    availableSpacePerLine = maxWidth\\n                }\\n                (availableSpacePerLine < 0) -> { // too much words in a line adjust!\\n                    availableSpacePerLine += (word.length + 1) //remove the claimed space for current\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine = maxWidth - (word.length + 1)\\n                }\\n                (availableSpacePerLine > 0) -> { // space is still available in the current line\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine--\\n                }\\n            }\\n        }\\n\\n        // Process the last line if there is one\\n        if (currentLineWords.isNotEmpty()) {\\n            result.add(toLineString(availableSpacePerLine + 1, currentLineWords, true))\\n        }\\n        return result\\n    }\\n    \\n\\n    private fun toLineString(\\n        noOfSpaceToBeDistributed: Int,\\n        wordsInLine: MutableList<String>,\\n        isLastLine: Boolean = false\\n    ): String {\\n        return if (wordsInLine.size == 1 || isLastLine) { // if there is only one word in a line or if the line is the last one , all the remaining spaces should just go to the end of the sentence\\n            wordsInLine.joinToString(SEPARATOR) + SEPARATOR.repeat(noOfSpaceToBeDistributed)\\n        } else { // other wise we have to evenly distribute the remaining lines\\n            val spaceToBeAddedToAllWords = (Math.floorDiv(\\n                noOfSpaceToBeDistributed,\\n                wordsInLine.lastIndex\\n            )) + 1 // the +1 is because we already take in to consideration a space when calculating noOfSpaceToBeDistributed\\n            \\n            for (i in 0 until noOfSpaceToBeDistributed % wordsInLine.lastIndex) {\\n                wordsInLine[i] += SEPARATOR\\n            }\\n            wordsInLine.joinToString(SEPARATOR.repeat(spaceToBeAddedToAllWords))\\n        }\\n    }\\n  \\n  \\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n     public List<String> fullJustify(String[] words, int maxWidth) {\\n        int left = 0; List<String> result = new ArrayList<>();\\n        \\n        while (left < words.length) {\\n            int right = findRight(left, words, maxWidth);\\n            result.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        \\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n            \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return padResult(words[left], maxWidth);\\n        \\n        boolean isLastLine = right == words.length - 1;\\n        int numSpaces = right - left;\\n        int totalSpace = maxWidth - wordsLength(left, right, words);\\n        \\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (int i = left; i <= right; i++)\\n            result.append(words[i])\\n                .append(space)\\n                .append(remainder-- > 0 ? \" \" : \"\");\\n        \\n        return padResult(result.toString().trim(), maxWidth);\\n    }\\n    \\n    private int wordsLength(int left, int right, String[] words) {\\n        int wordsLength = 0;\\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\\n        return wordsLength;\\n    }\\n    \\n    private String padResult(String result, int maxWidth) {\\n        return result + blank(maxWidth - result.length());\\n    }\\n    \\n    private String blank(int length) {\\n        return new String(new char[length]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n}\\n```\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```\n```\\nclass Solution {\\n     private  val SEPARATOR = \" \" \\n    \\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n\\n        val result = mutableListOf<String>() // keeps the lines as a sting in a paragraph\\n        val currentLineWords = mutableListOf<String>()// keeps track of all the words for the current line\\n        var availableSpacePerLine = maxWidth //  keeps track of the available space in the current line\\n\\n        words.forEach { word ->\\n            availableSpacePerLine -= word.length\\n            when {\\n                (availableSpacePerLine == 0) -> { // the words perfectly fit\\n                    currentLineWords.add(word)\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    availableSpacePerLine = maxWidth\\n                }\\n                (availableSpacePerLine < 0) -> { // too much words in a line adjust!\\n                    availableSpacePerLine += (word.length + 1) //remove the claimed space for current\\n                    result.add(toLineString(availableSpacePerLine, currentLineWords))\\n\\n                    // Start a new line\\n                    currentLineWords.clear()\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine = maxWidth - (word.length + 1)\\n                }\\n                (availableSpacePerLine > 0) -> { // space is still available in the current line\\n                    currentLineWords.add(word)\\n                    availableSpacePerLine--\\n                }\\n            }\\n        }\\n\\n        // Process the last line if there is one\\n        if (currentLineWords.isNotEmpty()) {\\n            result.add(toLineString(availableSpacePerLine + 1, currentLineWords, true))\\n        }\\n        return result\\n    }\\n    \\n\\n    private fun toLineString(\\n        noOfSpaceToBeDistributed: Int,\\n        wordsInLine: MutableList<String>,\\n        isLastLine: Boolean = false\\n    ): String {\\n        return if (wordsInLine.size == 1 || isLastLine) { // if there is only one word in a line or if the line is the last one , all the remaining spaces should just go to the end of the sentence\\n            wordsInLine.joinToString(SEPARATOR) + SEPARATOR.repeat(noOfSpaceToBeDistributed)\\n        } else { // other wise we have to evenly distribute the remaining lines\\n            val spaceToBeAddedToAllWords = (Math.floorDiv(\\n                noOfSpaceToBeDistributed,\\n                wordsInLine.lastIndex\\n            )) + 1 // the +1 is because we already take in to consideration a space when calculating noOfSpaceToBeDistributed\\n            \\n            for (i in 0 until noOfSpaceToBeDistributed % wordsInLine.lastIndex) {\\n                wordsInLine[i] += SEPARATOR\\n            }\\n            wordsInLine.joinToString(SEPARATOR.repeat(spaceToBeAddedToAllWords))\\n        }\\n    }\\n  \\n  \\n}\\n```\n```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446139,
                "title": "well-commented-javascript-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let buf = [];\\n    let width = maxWidth;\\n    \\n    // Greedy pack each line\\n    // when that fails add the line to the result with the added padding\\n    // and start a new line\\n    words.forEach(word => {\\n        // Check if the word fits in the current line\\n        // A word fits if theres enough room for the word and\\n        // a space between it and the word to the left\\n        if (word.length <= (width - buf.length)) {\\n            buf.push(word);\\n            width -= word.length;\\n        } else {\\n            // The word did not fit on the line, send this line for padding\\n            addWordToResult(res, buf.slice(), maxWidth);\\n            \\n            // Start a new line with the current word\\n            buf = [word];\\n            // reset the current line width\\n            width = maxWidth - word.length;\\n        }\\n    });\\n    \\n    // This is the final lines processing\\n    // According the rules this should only be left justified\\n    // so add all padding to the right not between the words\\n    if (buf.length) {\\n        let str = buf.join(\\' \\');\\n        str += \\' \\'.repeat(maxWidth - str.length);\\n        res.push(str);\\n    }\\n    \\n    return res;\\n};\\n\\n// Max words are on each line now pad them with spaces\\nfunction addWordToResult(res, buf, maxWidth) {\\n    // How many spaces are needed\\n    let spaces = maxWidth - buf.reduce((acc, cur) => cur.length + acc, 0);\\n    \\n    // If there is only one word on the line\\n    // then just add the padding to the end and return\\n    if (buf.length === 1) {\\n        buf[0] += \\' \\'.repeat(spaces);\\n        res.push(buf[0]);\\n        return;\\n    }\\n    \\n    // If the line has more than one word,\\n    // decrement the spaces which are created during the buf.join(\\' \\')\\n    // which is n - 1 spaces\\n    spaces -= buf.length - 1;\\n    \\n    // All words except the last should have spaces added to their string\\n    const end = buf.length - 1;\\n    let index = 0;\\n    \\n    // If there are spaces to distribute, distribute them\\n    // evenly looping back to the beginning of the buffer\\n    while (spaces-- > 0) {\\n        buf[index] += \\' \\';\\n        \\n        index = (index + 1) % end;\\n    }\\n    \\n    res.push(buf.join(\\' \\'))\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let buf = [];\\n    let width = maxWidth;\\n    \\n    // Greedy pack each line\\n    // when that fails add the line to the result with the added padding\\n    // and start a new line\\n    words.forEach(word => {\\n        // Check if the word fits in the current line\\n        // A word fits if theres enough room for the word and\\n        // a space between it and the word to the left\\n        if (word.length <= (width - buf.length)) {\\n            buf.push(word);\\n            width -= word.length;\\n        } else {\\n            // The word did not fit on the line, send this line for padding\\n            addWordToResult(res, buf.slice(), maxWidth);\\n            \\n            // Start a new line with the current word\\n            buf = [word];\\n            // reset the current line width\\n            width = maxWidth - word.length;\\n        }\\n    });\\n    \\n    // This is the final lines processing\\n    // According the rules this should only be left justified\\n    // so add all padding to the right not between the words\\n    if (buf.length) {\\n        let str = buf.join(\\' \\');\\n        str += \\' \\'.repeat(maxWidth - str.length);\\n        res.push(str);\\n    }\\n    \\n    return res;\\n};\\n\\n// Max words are on each line now pad them with spaces\\nfunction addWordToResult(res, buf, maxWidth) {\\n    // How many spaces are needed\\n    let spaces = maxWidth - buf.reduce((acc, cur) => cur.length + acc, 0);\\n    \\n    // If there is only one word on the line\\n    // then just add the padding to the end and return\\n    if (buf.length === 1) {\\n        buf[0] += \\' \\'.repeat(spaces);\\n        res.push(buf[0]);\\n        return;\\n    }\\n    \\n    // If the line has more than one word,\\n    // decrement the spaces which are created during the buf.join(\\' \\')\\n    // which is n - 1 spaces\\n    spaces -= buf.length - 1;\\n    \\n    // All words except the last should have spaces added to their string\\n    const end = buf.length - 1;\\n    let index = 0;\\n    \\n    // If there are spaces to distribute, distribute them\\n    // evenly looping back to the beginning of the buffer\\n    while (spaces-- > 0) {\\n        buf[index] += \\' \\';\\n        \\n        index = (index + 1) % end;\\n    }\\n    \\n    res.push(buf.join(\\' \\'))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953480,
                "title": "c-string-faster-than-100-day-24",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &w, int check)\\n    {\\n        vector<string> ans;\\n        int i = 0;\\n        while (i < w.size())\\n        {\\n            int end = i;\\n            int space = 0;\\n            int word = 0;\\n            string s = \"\";\\n            int word_length = 0;\\n            for (int j = i; j < w.size(); j++)\\n            {\\n                if (j == i)\\n                {\\n                    word++;\\n                    word_length += w[j].size();\\n                }\\n                else\\n                {\\n                    if (word_length + space + 1 + w[j].size() > check)\\n                        break;\\n                    else\\n                    {\\n                        space++;\\n                        word++;\\n                        word_length += w[j].size();\\n                        end = j;\\n                    }\\n                }\\n            }\\n            if (end != w.size() - 1)\\n            {\\n                int extra = 0;\\n                int spc = 0;\\n                if (space)\\n                {\\n                    spc = (check - word_length) / space;\\n                    extra = (check - word_length) % space;\\n                }\\n                for (int j = i; j <= end; j++)\\n                {\\n                    s += w[j];\\n                    for (int k = 0; k < spc && j != end; k++)\\n                    {\\n                        s += \" \";\\n                    }\\n                    if (extra)\\n                    {\\n                        extra--;\\n                        s += \" \";\\n                    }\\n                }\\n                if (space == 0)\\n                {\\n                    int k = s.size();\\n                    for (int j = 1; j <= (check - k); j++)\\n                    {\\n                        s += \" \";\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int j = i; j <= end; j++)\\n                {\\n                    if (j == i)\\n                        s += w[j];\\n                    else\\n                    {\\n                        s += \" \";\\n                        s += w[j];\\n                    }\\n                }\\n                int k = s.size();\\n                for (int j = 1; j <= (check - k); j++)\\n                {\\n                    s += \" \";\\n                }\\n            }\\n            i = end + 1;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c55adefd-96e8-4eb9-93ba-fd2b676955cd_1692866831.3735065.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &w, int check)\\n    {\\n        vector<string> ans;\\n        int i = 0;\\n        while (i < w.size())\\n        {\\n            int end = i;\\n            int space = 0;\\n            int word = 0;\\n            string s = \"\";\\n            int word_length = 0;\\n            for (int j = i; j < w.size(); j++)\\n            {\\n                if (j == i)\\n                {\\n                    word++;\\n                    word_length += w[j].size();\\n                }\\n                else\\n                {\\n                    if (word_length + space + 1 + w[j].size() > check)\\n                        break;\\n                    else\\n                    {\\n                        space++;\\n                        word++;\\n                        word_length += w[j].size();\\n                        end = j;\\n                    }\\n                }\\n            }\\n            if (end != w.size() - 1)\\n            {\\n                int extra = 0;\\n                int spc = 0;\\n                if (space)\\n                {\\n                    spc = (check - word_length) / space;\\n                    extra = (check - word_length) % space;\\n                }\\n                for (int j = i; j <= end; j++)\\n                {\\n                    s += w[j];\\n                    for (int k = 0; k < spc && j != end; k++)\\n                    {\\n                        s += \" \";\\n                    }\\n                    if (extra)\\n                    {\\n                        extra--;\\n                        s += \" \";\\n                    }\\n                }\\n                if (space == 0)\\n                {\\n                    int k = s.size();\\n                    for (int j = 1; j <= (check - k); j++)\\n                    {\\n                        s += \" \";\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for (int j = i; j <= end; j++)\\n                {\\n                    if (j == i)\\n                        s += w[j];\\n                    else\\n                    {\\n                        s += \" \";\\n                        s += w[j];\\n                    }\\n                }\\n                int k = s.size();\\n                for (int j = 1; j <= (check - k); j++)\\n                {\\n                    s += \" \";\\n                }\\n            }\\n            i = end + 1;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1042723,
                "title": "intuitive-readable-python-solution-beats-95-90",
                "content": "I was just given a variant of this question on a Karat, so I wanted to solve it on LC. I noticed a lot of the discussion answers were a bit rough to read, so I wanted to share this readible yet performant answer.\\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans, cur = [], []\\n        chars = 0\\n        \\n        for word in words:\\n            # if cur is empty or the total chars + total needed spaces + next word fit\\n            if not cur or (len(word) + chars + len(cur)) <= maxWidth:\\n                cur.append(word)\\n                chars += len(word)\\n            else:\\n                # place spaces, append the line to the ans, and move on\\n                line = self.placeSpacesBetween(cur, maxWidth - chars)\\n                ans.append(line)\\n                cur.clear()\\n                cur.append(word)\\n                chars = len(word)\\n        \\n        # left justify any remaining text, which is easy\\n        if cur:\\n            extra_spaces = maxWidth - chars - len(cur) + 1\\n            ans.append(\\' \\'.join(cur) + \\' \\' * extra_spaces)\\n            \\n        return ans\\n    \\n    \\n    def placeSpacesBetween(self, words, spaces):\\n        if len(words) == 1: return words[0] + \\' \\' * spaces\\n        \\n        space_groups = len(words)-1\\n        spaces_between_words = spaces // space_groups\\n        extra_spaces = spaces % space_groups\\n        \\n        cur = []\\n        for word in words:\\n            cur.append(word)\\n            \\n            # place the min of remaining spaces or spaces between words plus an extra if available\\n            cur_extra = min(1, extra_spaces)\\n            spaces_to_place = min(spaces_between_words + cur_extra, spaces)\\n\\n            cur.append(\\' \\' * spaces_to_place)\\n            \\n            if extra_spaces: extra_spaces -= 1\\n            spaces -= spaces_to_place\\n        \\n        return \\'\\'.join(cur)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24989,
                "title": "easy-java-implementation",
                "content": "- I divide the solution to this question into two parts:\\n - one is for counting the valid number of words which can fit into one line, i.e. helper() function does it and also passes the next index to be traversed in the next turn (it can be modified as iterative way if you are more comfortable with).\\n\\n - the other part serves as a string editor, i.e. addList() uses the actual valid words lengths (len) and index of start (i, inclusive) and end (j, exclusive) to count the spaces to be added.\\n\\n-\\n\\n    public class Solution {\\n    private List<String> result;\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        result = new ArrayList<String>();\\n        if (words == null || words.length == 0 || maxWidth < 0) return result;\\n        if (maxWidth == 0) {\\n            result.add(\"\");\\n            return result;\\n        }\\n        helper(words, 0, maxWidth);\\n        return result;\\n    }\\n    \\n    public void helper(String[] words, int start, int L) {\\n        if (start >= words.length) return;\\n        \\n        int i = start, len = 0, total = 0, next = -1;\\n        while (total < L && i < words.length) {\\n            total += words[i].length();\\n            if (total > L) { // only in this case we need skip i++\\n                next = i;\\n                break;\\n            }\\n            len += words[i].length();\\n            total++; // count space\\n            i++;\\n        }\\n        \\n        if (next == -1) next = i;\\n        addList(words, start, next, len, L);\\n        \\n        helper(words, next, L);\\n    }\\n    \\n    public void addList(String[] words, int i, int j, int len, int L) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int count = j-i-1, space = 0, more = 0, s = 0;\\n        if (count == 0 || j == words.length) { // the last line\\n            for (int k = i; k < j; k++) {\\n                sb.append(words[k]);\\n                if (k == j-1) break;\\n                sb.append(\" \");\\n            }\\n            space = L - sb.length();\\n            s = 0;\\n            while (s++ < space) sb.append(\" \");\\n        } else {\\n            space = (L - len) / count; more = (L - len) % count;\\n            for (int k = i; k < j; k++) {\\n                sb.append(words[k]);\\n                s = 0;\\n                if (k == j-1) break;\\n                while (s++ < space) sb.append(\" \");\\n                if (more-- > 0) sb.append(\" \");\\n            }\\n        }\\n        \\n        result.add(sb.toString());\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private List<String> result;\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        result = new ArrayList<String>();\\n        if (words == null || words.length == 0 || maxWidth < 0) return result;\\n        if (maxWidth == 0) {\\n            result.add(\"\");\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1810892,
                "title": "java-simple-approach-with-explanation-runtime-0-ms-100-faster",
                "content": "# **Please upvote if you like the solution**\\n\\n```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0, length = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            /**\\n             * Try to add words till its under maxWidth length\\n             */\\n            if (words[i].length() <= (maxWidth - length)) {\\n                // + 1 because after each word there should be a space\\n                length += words[i].length() + 1;\\n                continue;\\n            }\\n            /**\\n             * Process the words which can be part of the justified sentence\\n             */\\n            else {\\n                /**\\n                 * Intention is try to get the remaining Spaces number and number of words part of the sentence\\n                 * As we have to distribute the spaces as evenly as possible, we can figure put the in between spaces\\n                 * between the words by doing remainingSpaces / noOfWords\\n                 * and there is a possibility that after evenly distributed the spaces also there can be some extra spaces\\n                 * which are pending.\\n                 *  Like for an example\\n                 *      remainingSpaces = 8 and noOfWords = 3\\n                 *      So in between spaces will be 8 / 3 = 2 spaces. But still 8 - (3 * 2) = 2 spaces are remaining\\n                 *      As per the problem those spaces can be placed sequentially between the words (till possible)\\n                 */\\n\\n                /**\\n                 * Adding + 1 because none of the justified sentence should end with \" \" (space) and we have added space\\n                 * for each word while calculating the length of the words. So, just removing the space after last word\\n                 */\\n                int remainingSpaces = maxWidth - length + 1;\\n\\n                /**\\n                 * Decreasing the number of word by 1 because\\n                 * If for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 *  There should not be any trailing spaces.\\n                 */\\n                int noOfWords = i - start - 1;\\n                int extraSpaceBetweenWords = 0;\\n\\n                if (noOfWords > 0) {\\n                    extraSpaceBetweenWords = remainingSpaces / noOfWords;\\n                    remainingSpaces = remainingSpaces % noOfWords;\\n                }\\n\\n                /**\\n                 * Append the word, extra space & remainingSpaces (if present)\\n                 * Iterating till (i - 1) position as we want to add those extra spaces in between words not at end\\n                 * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 */\\n                while (start < i - 1) {\\n                    sb.append(words[start++]).append(\" \");\\n                    int k = 0;\\n                    while (k < extraSpaceBetweenWords) {\\n                        sb.append(\" \");\\n                        k++;\\n                    }\\n                    if (remainingSpaces > 0) {\\n                        sb.append(\" \");\\n                        remainingSpaces--;\\n                    }\\n                }\\n                // Appending the last word part of sentence\\n                sb.append(words[start]);\\n\\n                /**\\n                 *  This will execute only for the cases where there is only 1 word part of the sentence\\n                 *  and its not covered as part of the previous while loop\\n                 */\\n                while (remainingSpaces > 0) {\\n                    sb.append(\" \");\\n                    remainingSpaces--;\\n                }\\n                result.add(sb.toString());\\n\\n                /**\\n                 * reset start position to current position\\n                 * update the length of the current word\\n                 * resetting the StringBuilder\\n                 */\\n                start = i;\\n                length = words[i].length() + 1;\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        /**\\n         * Processing the last sentence, which should be left-justified and no extra space is inserted between words.\\n         *\\n         * Iterating till (words.length - 1) position as we want to add those extra spaces in between words not at end\\n         * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n         *  (word1 - word2) And (word2 - word3)\\n         */\\n        sb.setLength(0);\\n        while (start < words.length - 1) {\\n            sb.append(words[start++]).append(\" \");\\n        }\\n        // Appending the last word part of sentence\\n        sb.append(words[start]);\\n\\n        /**\\n         * Filling the rest position with extra spaces\\n         */\\n        while (sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        result.add(sb.toString());\\n\\n        return result;\\n    }\\n    \\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/016be550-127a-490a-9021-3a5610a1fcb3_1646168702.7983997.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\n        List<String> result = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int start = 0, length = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            /**\\n             * Try to add words till its under maxWidth length\\n             */\\n            if (words[i].length() <= (maxWidth - length)) {\\n                // + 1 because after each word there should be a space\\n                length += words[i].length() + 1;\\n                continue;\\n            }\\n            /**\\n             * Process the words which can be part of the justified sentence\\n             */\\n            else {\\n                /**\\n                 * Intention is try to get the remaining Spaces number and number of words part of the sentence\\n                 * As we have to distribute the spaces as evenly as possible, we can figure put the in between spaces\\n                 * between the words by doing remainingSpaces / noOfWords\\n                 * and there is a possibility that after evenly distributed the spaces also there can be some extra spaces\\n                 * which are pending.\\n                 *  Like for an example\\n                 *      remainingSpaces = 8 and noOfWords = 3\\n                 *      So in between spaces will be 8 / 3 = 2 spaces. But still 8 - (3 * 2) = 2 spaces are remaining\\n                 *      As per the problem those spaces can be placed sequentially between the words (till possible)\\n                 */\\n\\n                /**\\n                 * Adding + 1 because none of the justified sentence should end with \" \" (space) and we have added space\\n                 * for each word while calculating the length of the words. So, just removing the space after last word\\n                 */\\n                int remainingSpaces = maxWidth - length + 1;\\n\\n                /**\\n                 * Decreasing the number of word by 1 because\\n                 * If for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 *  There should not be any trailing spaces.\\n                 */\\n                int noOfWords = i - start - 1;\\n                int extraSpaceBetweenWords = 0;\\n\\n                if (noOfWords > 0) {\\n                    extraSpaceBetweenWords = remainingSpaces / noOfWords;\\n                    remainingSpaces = remainingSpaces % noOfWords;\\n                }\\n\\n                /**\\n                 * Append the word, extra space & remainingSpaces (if present)\\n                 * Iterating till (i - 1) position as we want to add those extra spaces in between words not at end\\n                 * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n                 *  (word1 - word2) And (word2 - word3)\\n                 */\\n                while (start < i - 1) {\\n                    sb.append(words[start++]).append(\" \");\\n                    int k = 0;\\n                    while (k < extraSpaceBetweenWords) {\\n                        sb.append(\" \");\\n                        k++;\\n                    }\\n                    if (remainingSpaces > 0) {\\n                        sb.append(\" \");\\n                        remainingSpaces--;\\n                    }\\n                }\\n                // Appending the last word part of sentence\\n                sb.append(words[start]);\\n\\n                /**\\n                 *  This will execute only for the cases where there is only 1 word part of the sentence\\n                 *  and its not covered as part of the previous while loop\\n                 */\\n                while (remainingSpaces > 0) {\\n                    sb.append(\" \");\\n                    remainingSpaces--;\\n                }\\n                result.add(sb.toString());\\n\\n                /**\\n                 * reset start position to current position\\n                 * update the length of the current word\\n                 * resetting the StringBuilder\\n                 */\\n                start = i;\\n                length = words[i].length() + 1;\\n                sb.setLength(0);\\n            }\\n        }\\n\\n        /**\\n         * Processing the last sentence, which should be left-justified and no extra space is inserted between words.\\n         *\\n         * Iterating till (words.length - 1) position as we want to add those extra spaces in between words not at end\\n         * Like if for a sentence 3 words are eligible the spaces should be distributed between\\n         *  (word1 - word2) And (word2 - word3)\\n         */\\n        sb.setLength(0);\\n        while (start < words.length - 1) {\\n            sb.append(words[start++]).append(\" \");\\n        }\\n        // Appending the last word part of sentence\\n        sb.append(words[start]);\\n\\n        /**\\n         * Filling the rest position with extra spaces\\n         */\\n        while (sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        result.add(sb.toString());\\n\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495455,
                "title": "simple-10-lines-c-solution-0ms-100-8-9mb-100",
                "content": "For the current line, the idea is to select a number of words based on their length. The selection is represented by the interval `[i,j)`. Each time a word is selected, we reduce the remaining `room`, until the next word doesn\\'t fit the line.\\n\\nThen, we compute the `gap` as the **quotient** of the `room` and the number of words *minus one* (`gap = room / (j - i - 1)`). There is possibly remaining `room` as the **remainder** of this division isn\\'t necessarily null (`room -= gap * (j - i - 1)`) . Therefore we add `gap + 1` spaces for the `room` first gaps and `gap` spaces for the others, i.e. `gap + (room-- > 0 ? 1 : 0)`.\\n\\nOnce the line is done (`i == j`), we start a new line and this until all words have been consumed (`i == n`).\\n\\n**Note :** One should pay attention that the *last* word of a line is treated differently.\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size(), room, gap;\\n        vector<string> text;\\n        \\n        for (int i = 0, j = 0; i < n;) { // Two pointers i and j\\n            for (room = maxWidth; j < n and room >= j - i + words[j].length();) // While there is enough room\\n                room -= words[j++].length();\\n\\n            gap = (j - i == 1) or (j == n) ? 0 : room / (j - i - 1); // If one word or last line gap is null\\n            room -= gap * (j - i - 1); // Remainder\\n            \\n            text.push_back(\"\");\\n            while (i < j - 1)\\n                text.back().append(words[i++]).append(gap + (room-- > 0 ? 1 : 0), \\' \\');\\n            text.back().append(words[i++]).append(max(room, 0), \\' \\');\\n        }\\n        \\n        return text;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size(), room, gap;\\n        vector<string> text;\\n        \\n        for (int i = 0, j = 0; i < n;) { // Two pointers i and j\\n            for (room = maxWidth; j < n and room >= j - i + words[j].length();) // While there is enough room\\n                room -= words[j++].length();\\n\\n            gap = (j - i == 1) or (j == n) ? 0 : room / (j - i - 1); // If one word or last line gap is null\\n            room -= gap * (j - i - 1); // Remainder\\n            \\n            text.push_back(\"\");\\n            while (i < j - 1)\\n                text.back().append(words[i++]).append(gap + (room-- > 0 ? 1 : 0), \\' \\');\\n            text.back().append(words[i++]).append(max(room, 0), \\' \\');\\n        }\\n        \\n        return text;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24898,
                "title": "short-javascript-o-n-solution",
                "content": "The two-pass version where we preprocess the words into rows is easier to understand:\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [[]];\\n    res[0].letters = 0;\\n    for (let word of words) {\\n        let row = res[res.length - 1];\\n        if (row.length && row.letters + row.length + word.length > maxWidth) {\\n            res.push([]);\\n            row = res[res.length - 1];\\n            row.letters = 0;\\n        }\\n        row.push(word);\\n        row.letters += word.length;\\n    }\\n    for (let r = 0; r < res.length; r++) {\\n        let row = res[r];\\n        if (row.length === 1 || r === res.length - 1) {\\n            res[r] = row.join(' ') + ' '.repeat(maxWidth - row.letters - row.length + 1);\\n            continue;\\n        }\\n        let line = row[0];\\n        let spaces = maxWidth - row.letters;\\n        let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n        let addSpace = spaces % (row.length - 1);\\n        for (let w = 1; w < row.length; w++) {\\n            line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n        }\\n        res[r] = line;\\n    }\\n    return res;\\n};\\n```\\nWe can also do this in one pass:\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    for (let res = [[]], i = 0, letters = 0; i <= words.length; letters += words[i++].length) {\\n        let row = res[res.length - 1];\\n        if (i === words.length || row.length && letters + row.length + words[i].length > maxWidth) {\\n            if (row.length === 1 || i === words.length) {\\n                res[res.length - 1] = row.join(' ') + ' '.repeat(maxWidth - letters - row.length + 1);\\n                if (i === words.length) return res;\\n            } else {\\n                let line = row[0];\\n                let spaces = maxWidth - letters;\\n                let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n                let addSpace = spaces % (row.length - 1);\\n                for (let w = 1; w < row.length; w++) {\\n                    line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n                }\\n                res[res.length - 1] = line;\\n            }\\n            res.push([]);\\n            letters = 0;\\n        }\\n        res[res.length - 1].push(words[i]);\\n    }\\n};\\n```\\nI prefer the longer version, as there isn't any speed/space advantage either way.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [[]];\\n    res[0].letters = 0;\\n    for (let word of words) {\\n        let row = res[res.length - 1];\\n        if (row.length && row.letters + row.length + word.length > maxWidth) {\\n            res.push([]);\\n            row = res[res.length - 1];\\n            row.letters = 0;\\n        }\\n        row.push(word);\\n        row.letters += word.length;\\n    }\\n    for (let r = 0; r < res.length; r++) {\\n        let row = res[r];\\n        if (row.length === 1 || r === res.length - 1) {\\n            res[r] = row.join(' ') + ' '.repeat(maxWidth - row.letters - row.length + 1);\\n            continue;\\n        }\\n        let line = row[0];\\n        let spaces = maxWidth - row.letters;\\n        let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n        let addSpace = spaces % (row.length - 1);\\n        for (let w = 1; w < row.length; w++) {\\n            line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n        }\\n        res[r] = line;\\n    }\\n    return res;\\n};\\n```\n```\\nvar fullJustify = function(words, maxWidth) {\\n    for (let res = [[]], i = 0, letters = 0; i <= words.length; letters += words[i++].length) {\\n        let row = res[res.length - 1];\\n        if (i === words.length || row.length && letters + row.length + words[i].length > maxWidth) {\\n            if (row.length === 1 || i === words.length) {\\n                res[res.length - 1] = row.join(' ') + ' '.repeat(maxWidth - letters - row.length + 1);\\n                if (i === words.length) return res;\\n            } else {\\n                let line = row[0];\\n                let spaces = maxWidth - letters;\\n                let minSpaces = ' '.repeat(Math.floor(spaces / (row.length - 1)));\\n                let addSpace = spaces % (row.length - 1);\\n                for (let w = 1; w < row.length; w++) {\\n                    line += minSpaces + (w <= addSpace ? ' ' : '') + row[w];\\n                }\\n                res[res.length - 1] = line;\\n            }\\n            res.push([]);\\n            letters = 0;\\n        }\\n        res[res.length - 1].push(words[i]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24962,
                "title": "15-line-python-solution-40ms",
                "content": "    def fullJustify(self, words, maxWidth):\\n        i, N, result = 0, len(words), []\\n        while i < N:\\n            # decide how many words to be put in one line\\n            oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i])\\n            while j < N and currWidth + 1 + len(words[j]) <= maxWidth:\\n                oneLine.append(words[j])\\n                currWidth += 1 + len(words[j])\\n                spaceNum -= len(words[j])\\n                positionNum, j = positionNum + 1, j + 1\\n            i = j\\n            # decide the layout of one line\\n            if i < N and positionNum:\\n                spaces = [' ' * (spaceNum / positionNum + (k < spaceNum % positionNum)) for k in range(positionNum)] + ['']\\n            else: # last line or the line only has one word\\n                spaces = [' '] * positionNum + [' ' * (maxWidth - currWidth)]\\n            result.append(''.join([s for pair in zip(oneLine, spaces) for s in pair]))\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def fullJustify(self, words, maxWidth):\\n        i, N, result = 0, len(words), []\\n        while i < N:\\n            # decide how many words to be put in one line\\n            oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i])\\n            while j < N and currWidth + 1 + len(words[j]) <= maxWidth:\\n                oneLine.append(words[j])\\n                currWidth += 1 + len(words[j])\\n                spaceNum -= len(words[j])\\n                positionNum, j = positionNum + 1, j + 1\\n            i = j\\n            # decide the layout of one line\\n            if i < N and positionNum:\\n                spaces = [' ' * (spaceNum / positionNum + (k < spaceNum % positionNum)) for k in range(positionNum)] + ['']\\n            else: # last line or the line only has one word\\n                spaces = [' '] * positionNum + [' ' * (maxWidth - currWidth)]\\n            result.append(''.join([s for pair in zip(oneLine, spaces) for s in pair]))\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 3952295,
                "title": "ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nThe algorithm justifies a given list of words into lines with a specified maximum width. It iterates through the words, adding them to a line if they fit within the width limit, or starts a new line if not. After splitting the text into lines, it evenly distributes extra spaces among words to justify the lines, ensuring the last line is left-justified. The final justified lines are returned as a result.\\n\\n---\\n\\n\\n# Solution Video\\nUsually, I put a video to visualize solution but today I have to go on business trip and come back at late night. Please subscribe to my channel from URL below and don\\'t miss my latest solution videos in the future.\\n\\nI have 247 videos as of August 24th, 2023. Currently there are 2,071 subscribers.\\n\\n\\u25A0 Subscribe URL\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. **Initialization of Variables:**\\n   - Initialize an empty list `result` to store the final justified lines.\\n   - Initialize an empty list `line` to temporarily store words for the current line being processed.\\n   - Initialize an integer variable `line_length` to track the length of words in the current line.\\n\\n2. **Loop through Words:**\\n   - Loop through each word in the `words` list.\\n   - Check if adding the current `word` to the current line would exceed the `maxWidth` for the line.\\n   - If the addition doesn\\'t exceed, append the `word` to the `line` and update the `line_length` accordingly.\\n   - If the addition exceeds, append the current `line` to the `result`, start a new line with the current `word`, and update `line_length`.\\n\\n3. **Append Last Line:**\\n   - Append the last `line` to the `result`.\\n\\n4. **Initialization for Justified Lines:**\\n   - Initialize an empty list `justified_lines` to store the lines after justification.\\n\\n5. **Loop through Lines for Justification:**\\n   - Loop through each line in `result` except the last one (from 0 to `len(result) - 2`).\\n   - Get the current `line` from the `result`.\\n   - Calculate the total number of words in the `line` as `num_words`.\\n   - Calculate the total number of spaces available for justification as `num_spaces` by subtracting the sum of lengths of words in the line from `maxWidth`.\\n\\n6. **Handle Zero Space Gaps:**\\n   - Calculate the number of space gaps (`space_gaps`) by taking the maximum of `num_words - 1` and 1 (to ensure there\\'s at least one gap).\\n\\n7. **Calculate Spaces per Gap:**\\n   - Calculate the number of spaces per gap (`spaces_per_gap`) by performing integer division `num_spaces // space_gaps`.\\n\\n8. **Calculate Extra Spaces:**\\n   - Calculate the remaining extra spaces (`extra_spaces`) after distributing spaces evenly among gaps using modulo `num_spaces % space_gaps`.\\n\\n9. **Building Justified Line:**\\n   - Initialize an empty string `justified_line` to build the justified line.\\n   - Iterate through each `word` in the `line`.\\n   - Concatenate the `word` to the `justified_line`.\\n   - Check if there are more spaces to distribute (`space_gaps > 0`).\\n   - If yes, calculate the number of spaces to add (`spaces_to_add`) by adding `spaces_per_gap` and an extra space if `extra_spaces` is greater than 0.\\n   - Concatenate the calculated number of spaces to the `justified_line`.\\n   - Decrement `extra_spaces` and `space_gaps`.\\n\\n10. **Append Justified Line:**\\n    - Append the `justified_line` to the `justified_lines` list.\\n\\n11. **Construct the Last Line:**\\n    - Join the words in the last `result` line with a single space to form the `last_line`.\\n    - Add the required number of spaces at the end to make the total length `maxWidth`.\\n\\n12. **Append Last Line to Justified Lines:**\\n    - Append the `last_line` to the `justified_lines` list.\\n\\n13. **Return Justified Lines:**\\n    - Return the list of `justified_lines`.\\n\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []  # To store the final justified lines\\n        line = []    # To temporarily store words for current line\\n        line_length = 0  # To track the length of the words in the current line\\n        \\n        # Loop through each word in the input words list\\n        for word in words:\\n            # Check if adding the current word exceeds the maxWidth for the line\\n            if line_length + len(line) + len(word) <= maxWidth:\\n                line.append(word)  # Add the word to the line\\n                line_length += len(word)  # Update the line length\\n            else:\\n                result.append(line)  # Add the words in the line to the result\\n                line = [word]  # Start a new line with the current word\\n                line_length = len(word)  # Set the line length to the word\\'s length\\n        \\n        result.append(line)  # Append the last line to the result\\n        \\n        justified_lines = []\\n        \\n        # Loop through each line except the last one\\n        for i in range(len(result) - 1):\\n            line = result[i]\\n            num_words = len(line)\\n            num_spaces = maxWidth - sum(len(word) for word in line)\\n            \\n            # Handle the case when space_gaps is zero\\n            space_gaps = max(num_words - 1, 1)\\n            \\n            spaces_per_gap = num_spaces // space_gaps\\n            extra_spaces = num_spaces % space_gaps\\n\\n            justified_line = \"\"\\n            \\n            # Iterate through each word in the line\\n            for word in line:\\n                justified_line += word\\n                \\n                # Check if there are more spaces to distribute\\n                if space_gaps > 0:\\n                    spaces_to_add = spaces_per_gap + (1 if extra_spaces > 0 else 0)\\n                    justified_line += \" \" * spaces_to_add\\n                    extra_spaces -= 1\\n                    space_gaps -= 1\\n\\n            justified_lines.append(justified_line)\\n\\n        last_line = \" \".join(result[-1])\\n        last_line += \" \" * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n\\n        return justified_lines\\n```\\n```javascript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const result = [];\\n    let line = [];\\n    let lineLength = 0;\\n\\n    for (const word of words) {\\n        if (lineLength + line.length + word.length <= maxWidth) {\\n            line.push(word);\\n            lineLength += word.length;\\n        } else {\\n            result.push(line);\\n            line = [word];\\n            lineLength = word.length;\\n        }\\n    }\\n\\n    result.push(line);\\n\\n    const justifiedLines = [];\\n    for (let i = 0; i < result.length - 1; i++) {\\n        line = result[i];\\n        const numWords = line.length;\\n        const numSpaces = maxWidth - line.reduce((acc, word) => acc + word.length, 0);\\n\\n        let spaceGaps = Math.max(numWords - 1, 1);\\n        const spacesPerGap = Math.floor(numSpaces / spaceGaps);\\n        let extraSpaces = numSpaces % spaceGaps;\\n\\n        let justifiedLine = \"\";\\n        for (const word of line) {\\n            justifiedLine += word;\\n\\n            if (spaceGaps > 0) {\\n                const spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                justifiedLine += \" \".repeat(spacesToAdd);\\n                extraSpaces -= 1;\\n                spaceGaps -= 1;\\n            }\\n        }\\n\\n        justifiedLines.push(justifiedLine);\\n    }\\n\\n    const lastLine = result[result.length - 1].join(\" \");\\n    justifiedLines.push(lastLine + \" \".repeat(maxWidth - lastLine.length));\\n\\n    return justifiedLines;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> line = new ArrayList<>();\\n        int lineLength = 0;\\n\\n        for (String word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.add(word);\\n                lineLength += word.length();\\n            } else {\\n                result.add(line);\\n                line = new ArrayList<>();\\n                line.add(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.add(line);\\n\\n        List<String> justifiedLines = new ArrayList<>();\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result.get(i);\\n            int numWords = line.size();\\n            int numSpaces = maxWidth - line.stream().mapToInt(String::length).sum();\\n\\n            int spaceGaps = Math.max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            StringBuilder justifiedLine = new StringBuilder();\\n            for (String word : line) {\\n                justifiedLine.append(word);\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine.append(\" \".repeat(spacesToAdd));\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.add(justifiedLine.toString());\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", result.get(result.size() - 1)));\\n        lastLine.append(\" \".repeat(maxWidth - lastLine.length()));\\n        justifiedLines.add(lastLine.toString());\\n\\n        return justifiedLines;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        std::vector<std::vector<std::string>> result;\\n        std::vector<std::string> line;\\n        int lineLength = 0;\\n\\n        for (const std::string& word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.push_back(word);\\n                lineLength += word.length();\\n            } else {\\n                result.push_back(line);\\n                line.clear();\\n                line.push_back(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.push_back(line);\\n\\n        std::vector<std::string> justifiedLines;\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result[i];\\n            int numWords = line.size();\\n            int numSpaces = maxWidth;\\n            for (const std::string& word : line) {\\n                numSpaces -= word.length();\\n            }\\n\\n            int spaceGaps = std::max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            std::string justifiedLine = \"\";\\n            for (const std::string& word : line) {\\n                justifiedLine += word;\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine += std::string(spacesToAdd, \\' \\');\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.push_back(justifiedLine);\\n        }\\n\\n        std::string lastLine = \"\";\\n        for (const std::string& word : result[result.size() - 1]) {\\n            lastLine += word + \" \";\\n        }\\n        lastLine.pop_back();\\n        lastLine += std::string(maxWidth - lastLine.length(), \\' \\');\\n        justifiedLines.push_back(lastLine);\\n\\n        return justifiedLines;      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []  # To store the final justified lines\\n        line = []    # To temporarily store words for current line\\n        line_length = 0  # To track the length of the words in the current line\\n        \\n        # Loop through each word in the input words list\\n        for word in words:\\n            # Check if adding the current word exceeds the maxWidth for the line\\n            if line_length + len(line) + len(word) <= maxWidth:\\n                line.append(word)  # Add the word to the line\\n                line_length += len(word)  # Update the line length\\n            else:\\n                result.append(line)  # Add the words in the line to the result\\n                line = [word]  # Start a new line with the current word\\n                line_length = len(word)  # Set the line length to the word\\'s length\\n        \\n        result.append(line)  # Append the last line to the result\\n        \\n        justified_lines = []\\n        \\n        # Loop through each line except the last one\\n        for i in range(len(result) - 1):\\n            line = result[i]\\n            num_words = len(line)\\n            num_spaces = maxWidth - sum(len(word) for word in line)\\n            \\n            # Handle the case when space_gaps is zero\\n            space_gaps = max(num_words - 1, 1)\\n            \\n            spaces_per_gap = num_spaces // space_gaps\\n            extra_spaces = num_spaces % space_gaps\\n\\n            justified_line = \"\"\\n            \\n            # Iterate through each word in the line\\n            for word in line:\\n                justified_line += word\\n                \\n                # Check if there are more spaces to distribute\\n                if space_gaps > 0:\\n                    spaces_to_add = spaces_per_gap + (1 if extra_spaces > 0 else 0)\\n                    justified_line += \" \" * spaces_to_add\\n                    extra_spaces -= 1\\n                    space_gaps -= 1\\n\\n            justified_lines.append(justified_line)\\n\\n        last_line = \" \".join(result[-1])\\n        last_line += \" \" * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n\\n        return justified_lines\\n```\n```javascript []\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const result = [];\\n    let line = [];\\n    let lineLength = 0;\\n\\n    for (const word of words) {\\n        if (lineLength + line.length + word.length <= maxWidth) {\\n            line.push(word);\\n            lineLength += word.length;\\n        } else {\\n            result.push(line);\\n            line = [word];\\n            lineLength = word.length;\\n        }\\n    }\\n\\n    result.push(line);\\n\\n    const justifiedLines = [];\\n    for (let i = 0; i < result.length - 1; i++) {\\n        line = result[i];\\n        const numWords = line.length;\\n        const numSpaces = maxWidth - line.reduce((acc, word) => acc + word.length, 0);\\n\\n        let spaceGaps = Math.max(numWords - 1, 1);\\n        const spacesPerGap = Math.floor(numSpaces / spaceGaps);\\n        let extraSpaces = numSpaces % spaceGaps;\\n\\n        let justifiedLine = \"\";\\n        for (const word of line) {\\n            justifiedLine += word;\\n\\n            if (spaceGaps > 0) {\\n                const spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                justifiedLine += \" \".repeat(spacesToAdd);\\n                extraSpaces -= 1;\\n                spaceGaps -= 1;\\n            }\\n        }\\n\\n        justifiedLines.push(justifiedLine);\\n    }\\n\\n    const lastLine = result[result.length - 1].join(\" \");\\n    justifiedLines.push(lastLine + \" \".repeat(maxWidth - lastLine.length));\\n\\n    return justifiedLines;    \\n};\\n```\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> result = new ArrayList<>();\\n        List<String> line = new ArrayList<>();\\n        int lineLength = 0;\\n\\n        for (String word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.add(word);\\n                lineLength += word.length();\\n            } else {\\n                result.add(line);\\n                line = new ArrayList<>();\\n                line.add(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.add(line);\\n\\n        List<String> justifiedLines = new ArrayList<>();\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result.get(i);\\n            int numWords = line.size();\\n            int numSpaces = maxWidth - line.stream().mapToInt(String::length).sum();\\n\\n            int spaceGaps = Math.max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            StringBuilder justifiedLine = new StringBuilder();\\n            for (String word : line) {\\n                justifiedLine.append(word);\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine.append(\" \".repeat(spacesToAdd));\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.add(justifiedLine.toString());\\n        }\\n\\n        StringBuilder lastLine = new StringBuilder(String.join(\" \", result.get(result.size() - 1)));\\n        lastLine.append(\" \".repeat(maxWidth - lastLine.length()));\\n        justifiedLines.add(lastLine.toString());\\n\\n        return justifiedLines;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        std::vector<std::vector<std::string>> result;\\n        std::vector<std::string> line;\\n        int lineLength = 0;\\n\\n        for (const std::string& word : words) {\\n            if (lineLength + line.size() + word.length() <= maxWidth) {\\n                line.push_back(word);\\n                lineLength += word.length();\\n            } else {\\n                result.push_back(line);\\n                line.clear();\\n                line.push_back(word);\\n                lineLength = word.length();\\n            }\\n        }\\n\\n        result.push_back(line);\\n\\n        std::vector<std::string> justifiedLines;\\n        for (int i = 0; i < result.size() - 1; i++) {\\n            line = result[i];\\n            int numWords = line.size();\\n            int numSpaces = maxWidth;\\n            for (const std::string& word : line) {\\n                numSpaces -= word.length();\\n            }\\n\\n            int spaceGaps = std::max(numWords - 1, 1);\\n            int spacesPerGap = numSpaces / spaceGaps;\\n            int extraSpaces = numSpaces % spaceGaps;\\n\\n            std::string justifiedLine = \"\";\\n            for (const std::string& word : line) {\\n                justifiedLine += word;\\n\\n                if (spaceGaps > 0) {\\n                    int spacesToAdd = spacesPerGap + (extraSpaces > 0 ? 1 : 0);\\n                    justifiedLine += std::string(spacesToAdd, \\' \\');\\n                    extraSpaces -= 1;\\n                    spaceGaps -= 1;\\n                }\\n            }\\n\\n            justifiedLines.push_back(justifiedLine);\\n        }\\n\\n        std::string lastLine = \"\";\\n        for (const std::string& word : result[result.size() - 1]) {\\n            lastLine += word + \" \";\\n        }\\n        lastLine.pop_back();\\n        lastLine += std::string(maxWidth - lastLine.length(), \\' \\');\\n        justifiedLines.push_back(lastLine);\\n\\n        return justifiedLines;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048424,
                "title": "short-python-code-with-explanation",
                "content": "If you like my code, please hit ^ button. \\uD83D\\uDE0A Good luck at the interview!\\n```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # We\\'ll pop from words so reversing it first\\n        words = list(reversed(words))\\n        result = []\\n        \\n        while words:\\n            line = []\\n            \\n            # while the next word, wont be too much, I keep adding\\n            while words and len(\\'\\'.join(line)) + len(words[-1]) <= maxWidth:        \\n                line.append(words.pop() + \\' \\')\\n                \\n            # fixing the last word by removing extra space\\n            line[-1] = line[-1][:-1]\\n                \\n            # if last line or single word, I\\'ll just left justify the line\\n            if not words or len(line) == 1:\\n                result.append(\\'\\'.join(line).ljust(maxWidth))\\n                \\n            # otherwise, I\\'ll add spaces to all words except to last one\\n            # until we reach the desired maxWidth\\n            else:\\n                n = len(\\'\\'.join(line))\\n                while n < maxWidth:\\n                    for i in range(len(line) -1):\\n                        if n == maxWidth: break\\n                        line[i] += \\' \\'\\n                        n += 1\\n                        \\n                result.append(\\'\\'.join(line))\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        # We\\'ll pop from words so reversing it first\\n        words = list(reversed(words))\\n        result = []\\n        \\n        while words:\\n            line = []\\n            \\n            # while the next word, wont be too much, I keep adding\\n            while words and len(\\'\\'.join(line)) + len(words[-1]) <= maxWidth:        \\n                line.append(words.pop() + \\' \\')\\n                \\n            # fixing the last word by removing extra space\\n            line[-1] = line[-1][:-1]\\n                \\n            # if last line or single word, I\\'ll just left justify the line\\n            if not words or len(line) == 1:\\n                result.append(\\'\\'.join(line).ljust(maxWidth))\\n                \\n            # otherwise, I\\'ll add spaces to all words except to last one\\n            # until we reach the desired maxWidth\\n            else:\\n                n = len(\\'\\'.join(line))\\n                while n < maxWidth:\\n                    for i in range(len(line) -1):\\n                        if n == maxWidth: break\\n                        line[i] += \\' \\'\\n                        n += 1\\n                        \\n                result.append(\\'\\'.join(line))\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952704,
                "title": "100-fast-easy-greedy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**The key intuition behind this problem is to understand how to distribute the spaces between words in each line in order to achieve both left and right justification.**\\n\\nSee the code you will be easily understand.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int start = 0;\\n\\n        while (start <words.size()) {\\n            int end = start;\\n            int lineLength = words[end].length();\\n\\n            while (end + 1 < words.size() && lineLength + words[end + 1].length() + (end + 1 - start) <= maxWidth) {\\n                ++end;\\n                lineLength += words[end].length();\\n            }\\n\\n            string line = words[start];\\n            int numWords = end - start;\\n\\n            if (end == words.size() - 1 || numWords == 0) { // Left justify for last line or single word line\\n                for (int i = start + 1; i <= end; ++i) {\\n                    line += \" \" + words[i];\\n                }\\n                line += string(maxWidth - line.length(), \\' \\');\\n            } else {\\n                int totalSpaces = maxWidth - lineLength;\\n                int spacesBetweenWords = totalSpaces / numWords;\\n                int extraSpaces = totalSpaces % numWords;\\n\\n                for (int i = start + 1; i <= end; ++i) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line += string(spaces, \\' \\') + words[i];\\n                }\\n            }\\n\\n            result.push_back(line);\\n            start = end + 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n# PLS UPVOTE IF HELPFUL.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int start = 0;\\n\\n        while (start <words.size()) {\\n            int end = start;\\n            int lineLength = words[end].length();\\n\\n            while (end + 1 < words.size() && lineLength + words[end + 1].length() + (end + 1 - start) <= maxWidth) {\\n                ++end;\\n                lineLength += words[end].length();\\n            }\\n\\n            string line = words[start];\\n            int numWords = end - start;\\n\\n            if (end == words.size() - 1 || numWords == 0) { // Left justify for last line or single word line\\n                for (int i = start + 1; i <= end; ++i) {\\n                    line += \" \" + words[i];\\n                }\\n                line += string(maxWidth - line.length(), \\' \\');\\n            } else {\\n                int totalSpaces = maxWidth - lineLength;\\n                int spacesBetweenWords = totalSpaces / numWords;\\n                int extraSpaces = totalSpaces % numWords;\\n\\n                for (int i = start + 1; i <= end; ++i) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line += string(spaces, \\' \\') + words[i];\\n                }\\n            }\\n\\n            result.push_back(line);\\n            start = end + 1;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778961,
                "title": "easy-modulated-c-solution-100-faster-no-kidding-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\n// function to find the length of the words in the temp vector used to storing answer of every row\\nint findLen(vector<string> s) {\\n    int cnt = 0;\\n    for(auto it: s) {\\n        cnt += it.length();\\n    }\\n    return cnt;\\n}\\n\\n// function used to make the string -> more than 1 string in 1 row\\nstring makeString(vector<string> s, int div, int rem) {\\n    string news = \"\";\\n    for(int i = 0; i < s.size(); i++) {\\n        news += s[i];\\n        if(i != s.size() - 1) {\\n            for(int j = 0; j < div; j++) news += \" \";\\n            if(rem > 0) {\\n                news += \" \";\\n                rem--;\\n            }\\n        }\\n    }\\n    return news;\\n}\\n\\n// function used to make the string -> 1 string in 1 row\\nstring makeStringOne(vector<string> temp, int maxWidth) {\\n    string s = \"\";\\n    for(int i = 0; i < temp.size(); i++) {\\n        s += temp[i];\\n        if(i != temp.size() - 1) s += \" \";\\n    }\\n    int left = maxWidth - s.length();\\n    while(left--) s += \" \";\\n    return s;\\n}\\n\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int n = words.size();\\n    vector<string> ans;\\n    vector<string> temp;\\n    int left = maxWidth;\\n    bool isFirst = true;\\n    for(int i = 0; i < n; i++) {\\n        // we\\'re checking the length of every word, if the length of the word plus the one space needed before it(if it\\'s not the first word) is less than equal to the length left, then we add it else we add it to the next row.\\n        int wordLen = words[i].length();\\n        if(isFirst && wordLen <= left) {\\n            temp.push_back(words[i]);\\n            left -= wordLen;\\n            isFirst = false;\\n        } else if(!isFirst && wordLen + 1 <= left) {\\n            temp.push_back(words[i]);\\n            left -= (wordLen + 1);\\n        } else {\\n            string s = \"\";\\n            int totalLen = findLen(temp);\\n            int spacesLeft = maxWidth - totalLen;\\n            int wordCount = temp.size();\\n            // if there is one word in the vector we add it specially as the spaces would be different than the ones with more than 1 word in the vector.\\n            if(wordCount == 1) {\\n                s = makeStringOne(temp, maxWidth); \\n            } else {\\n                int div = 0, rem = 0;\\n                div = spacesLeft / (wordCount - 1);\\n                if(spacesLeft % (wordCount-1) != 0)\\n                rem = spacesLeft % (wordCount-1);\\n                s = makeString(temp, div, rem);\\n            }\\n            ans.push_back(s); \\n            temp.clear();\\n            left = maxWidth;\\n            isFirst = true;\\n            i--;\\n        }\\n    }\\n    if(temp.size() > 0) {\\n        string s = \"\";\\n        s = makeStringOne(temp, maxWidth);\\n        ans.push_back(s);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\n// function to find the length of the words in the temp vector used to storing answer of every row\\nint findLen(vector<string> s) {\\n    int cnt = 0;\\n    for(auto it: s) {\\n        cnt += it.length();\\n    }\\n    return cnt;\\n}\\n\\n// function used to make the string -> more than 1 string in 1 row\\nstring makeString(vector<string> s, int div, int rem) {\\n    string news = \"\";\\n    for(int i = 0; i < s.size(); i++) {\\n        news += s[i];\\n        if(i != s.size() - 1) {\\n            for(int j = 0; j < div; j++) news += \" \";\\n            if(rem > 0) {\\n                news += \" \";\\n                rem--;\\n            }\\n        }\\n    }\\n    return news;\\n}\\n\\n// function used to make the string -> 1 string in 1 row\\nstring makeStringOne(vector<string> temp, int maxWidth) {\\n    string s = \"\";\\n    for(int i = 0; i < temp.size(); i++) {\\n        s += temp[i];\\n        if(i != temp.size() - 1) s += \" \";\\n    }\\n    int left = maxWidth - s.length();\\n    while(left--) s += \" \";\\n    return s;\\n}\\n\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int n = words.size();\\n    vector<string> ans;\\n    vector<string> temp;\\n    int left = maxWidth;\\n    bool isFirst = true;\\n    for(int i = 0; i < n; i++) {\\n        // we\\'re checking the length of every word, if the length of the word plus the one space needed before it(if it\\'s not the first word) is less than equal to the length left, then we add it else we add it to the next row.\\n        int wordLen = words[i].length();\\n        if(isFirst && wordLen <= left) {\\n            temp.push_back(words[i]);\\n            left -= wordLen;\\n            isFirst = false;\\n        } else if(!isFirst && wordLen + 1 <= left) {\\n            temp.push_back(words[i]);\\n            left -= (wordLen + 1);\\n        } else {\\n            string s = \"\";\\n            int totalLen = findLen(temp);\\n            int spacesLeft = maxWidth - totalLen;\\n            int wordCount = temp.size();\\n            // if there is one word in the vector we add it specially as the spaces would be different than the ones with more than 1 word in the vector.\\n            if(wordCount == 1) {\\n                s = makeStringOne(temp, maxWidth); \\n            } else {\\n                int div = 0, rem = 0;\\n                div = spacesLeft / (wordCount - 1);\\n                if(spacesLeft % (wordCount-1) != 0)\\n                rem = spacesLeft % (wordCount-1);\\n                s = makeString(temp, div, rem);\\n            }\\n            ans.push_back(s); \\n            temp.clear();\\n            left = maxWidth;\\n            isFirst = true;\\n            i--;\\n        }\\n    }\\n    if(temp.size() > 0) {\\n        string s = \"\";\\n        s = makeStringOne(temp, maxWidth);\\n        ans.push_back(s);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082328,
                "title": "c-easy-to-understand-break-into-small-functions",
                "content": "May look a bit long but each function should be easy to understand\\n\\n```\\nclass Solution {\\nprivate:\\n    /*\\n    starts from words[index], try pack max number of words into a line\\n    return packed words in \"lineWords\"\\n    be aware \"index\" is passed as reference hence it will be changed for the entire solution\\n    */\\n    void packWords(const vector<string>& words, int maxWidth, int& index, vector<string>& lineWords) {\\n        while (index < words.size()) {\\n            int wordSize = words[index].size();\\n            if (wordSize > maxWidth) { // cant fit any more word\\n                break;\\n            }\\n            maxWidth -= words[index].size();\\n            --maxWidth; // count one space between words\\n            lineWords.push_back(words[index]);\\n            ++index; // point index to next available word\\n        }\\n    }\\n    \\n    /*\\n    justify words to left side for last line and for the line with only one word\\n    return justified result in \"line\"\\n    */\\n    void leftJustify(const vector<string>& words, int maxWidth, string& line) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append one space for each word, except last word\\n                line += \" \";\\n            }\\n        }\\n        \\n        // append spaces to fill up the line\\n        int extraSpaces = maxWidth - line.size();\\n        line.append(extraSpaces, \\' \\');\\n    }\\n    \\n    /*\\n    fully justify one line\\n    return justified result in \"line\"\\n    */\\n    void fullJustify(const vector<string>& words, int maxWidth, string& line) {\\n        if (words.size() == 1) { // for lines with only one word we should do left justify\\n            leftJustify(words, maxWidth, line);\\n            return;\\n        }\\n        \\n        int totalCharLen = 0;\\n        for (const auto& word : words) {\\n            totalCharLen += word.size();\\n        }\\n        \\n        int totalSpaces = maxWidth - totalCharLen;\\n        int spaceSize = totalSpaces / (words.size() - 1);\\n        int extraSpaces = totalSpaces % (words.size() - 1);\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append spaces for each word except last one\\n                line.append(spaceSize, \\' \\');\\n                if (extraSpaces > 0) {\\n                    line += \" \";\\n                    --extraSpaces;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        string line = \"\";\\n        vector<string> lineWords; // words to fit into each line\\n        int index = 0;\\n        while (index < words.size()) { // loop through all words\\n            packWords(words, maxWidth, index, lineWords);\\n            if (index < words.size()) {\\n                fullJustify(lineWords, maxWidth, line);\\n            }\\n            else {\\n                leftJustify(lineWords, maxWidth, line);\\n            }\\n            output.push_back(line);\\n            \\n            // clear cache and start processing a new line\\n            line.clear();\\n            lineWords.clear();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /*\\n    starts from words[index], try pack max number of words into a line\\n    return packed words in \"lineWords\"\\n    be aware \"index\" is passed as reference hence it will be changed for the entire solution\\n    */\\n    void packWords(const vector<string>& words, int maxWidth, int& index, vector<string>& lineWords) {\\n        while (index < words.size()) {\\n            int wordSize = words[index].size();\\n            if (wordSize > maxWidth) { // cant fit any more word\\n                break;\\n            }\\n            maxWidth -= words[index].size();\\n            --maxWidth; // count one space between words\\n            lineWords.push_back(words[index]);\\n            ++index; // point index to next available word\\n        }\\n    }\\n    \\n    /*\\n    justify words to left side for last line and for the line with only one word\\n    return justified result in \"line\"\\n    */\\n    void leftJustify(const vector<string>& words, int maxWidth, string& line) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append one space for each word, except last word\\n                line += \" \";\\n            }\\n        }\\n        \\n        // append spaces to fill up the line\\n        int extraSpaces = maxWidth - line.size();\\n        line.append(extraSpaces, \\' \\');\\n    }\\n    \\n    /*\\n    fully justify one line\\n    return justified result in \"line\"\\n    */\\n    void fullJustify(const vector<string>& words, int maxWidth, string& line) {\\n        if (words.size() == 1) { // for lines with only one word we should do left justify\\n            leftJustify(words, maxWidth, line);\\n            return;\\n        }\\n        \\n        int totalCharLen = 0;\\n        for (const auto& word : words) {\\n            totalCharLen += word.size();\\n        }\\n        \\n        int totalSpaces = maxWidth - totalCharLen;\\n        int spaceSize = totalSpaces / (words.size() - 1);\\n        int extraSpaces = totalSpaces % (words.size() - 1);\\n        for (int i = 0; i < words.size(); ++i) {\\n            line += words[i];\\n            if (i != words.size() - 1) { // append spaces for each word except last one\\n                line.append(spaceSize, \\' \\');\\n                if (extraSpaces > 0) {\\n                    line += \" \";\\n                    --extraSpaces;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        string line = \"\";\\n        vector<string> lineWords; // words to fit into each line\\n        int index = 0;\\n        while (index < words.size()) { // loop through all words\\n            packWords(words, maxWidth, index, lineWords);\\n            if (index < words.size()) {\\n                fullJustify(lineWords, maxWidth, line);\\n            }\\n            else {\\n                leftJustify(lineWords, maxWidth, line);\\n            }\\n            output.push_back(line);\\n            \\n            // clear cache and start processing a new line\\n            line.clear();\\n            lineWords.clear();\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915710,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func fullJustify(_ words: [String], _ maxWidth: Int) -> [String] {\\n        var res: [String] = []\\n        var i = 0\\n        \\n        while i < words.count {\\n            var j = i\\n            var tmpLength = 0\\n            \\n            while j < words.count {\\n                tmpLength += words[j].count + ((j > i) ? 1 : 0)\\n                \\n                if tmpLength <= maxWidth { j += 1 } \\n                else {\\n                    res.append(stringWithWords(words, maxWidth, i, j))\\n                    break\\n                }\\n            }\\n            \\n            if j == words.count {\\n                res.append(stringWithWords(words, maxWidth, i, j))\\n            }\\n            i = j\\n        }\\n        \\n        return res\\n    }\\n\\n\\n    func stringWithWords(_ words: [String], _ maxWidth: Int, _ i: Int, _ j: Int) -> String {\\n        var length = 0\\n        var string = \"\"\\n        \\n        func space(_ n: Int) -> String {\\n            var string = \"\"\\n            for _ in 0..<n { string += \" \" }\\n            return string\\n        }\\n        \\n        func space(_ index: Int, _ count: Int, _ length: Int, _ maxWidth: Int, _ isLast: Bool) -> String {\\n            if isLast { return index == count - 1 ? space(maxWidth - length - count + 1) : \" \" }\\n            if count == 1 { return space(maxWidth - length) }\\n            if index == count - 1 { return \"\" }\\n            return space((maxWidth - length) / (count - 1)) + (index < ((maxWidth - length) % (count - 1)) ? \" \" : \"\")\\n        }\\n\\n        for k in i..<j { length += words[k].count }\\n        \\n        for k in i..<j {\\n            string += words[k] + space(k - i, j - i, length, maxWidth, j == words.count)\\n        }\\n        \\n        return string\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954308,
                "title": "100-faster-c-solution-beginner-friendly-two-pointer",
                "content": "# Do upvote, if it helped :)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### The idea here is to see how many words can be added to a line with only one space between the words, and then adding the required padding to the sentences, if needed. And left justify the last line of the paragraph.\\n\\n__Its is easy to understand that__ `n` __words on a line with require__`n-1`__space, at least. Now, if we have `k` words on a line and__ `maxWidth` __as__ `mw`__. Then the extra space available to us will be__ `mw` - `length of all words combine`, __say__ `extra space`.\\nNow This extra space has to be even distributed among the k words, i.e. in `k-1` spaces between the words.__\\n\\n__One more thing to note here is that if only one word can be accomodated in the line, then we just have to fill the rest of the line with spaces,__ `extra space`__.__\\n\\n##### Lets take an Example :\\n`Words: {\"This\",\"is\",\"my\",\"house\"}`, `maxWidth` __= 34\\nNow in order to check how many words can be placed in one line, we can traverse the entire array of words, and we can keep adding the words to a line till the following condition is satisfied:__ \\n\\n`curr_length of words` + `number of words - 1` <= `maxWidth`\\n\\n `number of words - 1` : This is used because we will be putting atleast one space between the words on the same line.\\n\\n__Once the we know the number of words, we can get the minimum spaces that has to be put between the words, For our example__\\n`Length of all words` = 13, `number of words` = 4;\\n__therefore, by the condition mentioned before, all the words can be placed in one line.__\\n`extra space` = `maxWidth` - `length of all words combined`\\n`extra space` = 35 - 13 = 22\\n__So 22 spaces are to filled in 3 blanks, between 4 words__\\npadding : Minimum spaces to be filled in between gaps to reach maxWidth\\n__`padding` = `extra space`/ `number of words - 1` = 22/3 = 7__\\n__We still have 1 space left, that needs to be adjusted, \\nconsider ut as `extra padding`, that is given by \\n`extra space` % `number of words - 1`__\\n__This means 1 extra space will be added to first `x` pairs,__\\n`x` = `extra padding`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n__We will be using a two pointer approach to add the words from the starting index to the ending index. To do this create two variables:\\n `start`: To track the index of the first word of the current line \\n`end` : To track the index of last word of the current line\\n`curr_len` : To store the current length of the sentence__\\n\\n\\n>## Traverse the array of words\\n> `wd` = `end - start + 1` __gives the number of words in the current line__\\n   `curr_len` = `length of the words in the line` + `wd`\\n__adding wd accounts for the minimum number of spaces between each pair of words(i.e. 1).__\\n>### If `curr_len`  + `size of the current word` <= `maxWidth`\\n>> __Add the size of current word to `curr_len`, and incresae the word count, by increasing `end` = `end + 1`__\\n> \\n> ### Else\\n>> __It\\'s time to fix the current line / sentence and move on to the next one__\\n>> __Start the `sentence` as the word at index `start`\\nCalculate the `extra_space` = `maxWidth` - `curr_len`\\n`padding` = `extra_space` / `max(1 , wd - 1)`\\n`extra` = `extra_space` % `max(1 , wd - 1)`__\\n>> ###### __Padding adding is the minimum space that will be added between each pair of words, even distribution__\\n>> ###### __Extra is the uneven distribution of space required to reach the `maxWidth` length__\\n>> __Traverse from index `start + 1` to `end`__\\n>>>__Add the padding to the `sentence`\\nAdd the extra padding\\nAdd the `curr_word`\\nIF there is only one word__\\n>>>> __Fill the rest of the line with space__\\n>>>\\n>>> __Add the `sentence` to the `ans` vector\\nSet :\\n`start` as `end + 1`, \\n`curr_len` = `curr_word.size()`, \\n`end` = `end + 1`__\\n>>\\n> #### __Once the Loop is exited, we are left with the last line, that is to be left-justified__\\n>__Start the `sentence` as the word at index `start`\\nTraverse from index `start + 1` to `end`__\\n>>__Add a space to the `sentence`\\nAdd the `curr_word`__\\n>\\n>__Fill the rest of the line with spaces\\nAdd the `sentence` to the `ans` vector\\nReturn the answer vector `ans`__\\n\\n# Complexity\\n- Time complexity: $$O(n*k*padding)$$ \\n   n = number of words\\n   k = max number of words that can be added in a line\\n   padding = minimum space between a pair of words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/68402346-1a9f-44f3-847d-4f00250e0d6d_1692880996.3664916.png)\\n\\n\\n# Code\\n``` cpp []\\nclass Solution // 100% faster\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        // Vector to store the sentences\\n        vector<string> ans;\\n        int curr_len = 0, start = 0, end = -1;\\n        for (string s : words)\\n        {\\n            if ((end - start + 1) + curr_len + s.size() <= maxWidth)\\n                curr_len += s.size(), end++;\\n            else\\n            {\\n                // Start the current line as the word at index start\\n                string sentence = words[start];\\n                int extra_space = maxWidth - curr_len, padding = extra_space / max(1, end - start);\\n                // extra is the extra space that has to be adjusted so as to make the length equal to maxWidth\\n                int extra = extra_space % max(1, end - start);\\n                // Now add the words from \\'start index + 1\\' to \\'end index\\'\\n                for (int i = start + 1; i <= end; i++)\\n                {\\n                    // Add the padding first\\n                    for (int j = 0; j < padding; j++)\\n                        sentence += \" \";\\n                    // Add the xtra padding, if needed\\n                    if (extra)\\n                        sentence += \" \", extra--;\\n                    sentence += words[i];\\n                }\\n                // Just in case the sentence has only one word\\n                while (sentence.size() < maxWidth)\\n                    sentence += \" \";\\n                ans.push_back(sentence);\\n                // Set the current word as the starting point of the new line\\n                start = end + 1, curr_len = s.size(), end++;\\n            }\\n        }\\n        // Last line has to be dealt with a bit differently, i.e. left justified\\n        string sentence = words[start];\\n        for (int i = start + 1; i <= end; i++)\\n            sentence += \" \" + words[i];\\n        while (sentence.size() < maxWidth)\\n            sentence += \" \";\\n        ans.push_back(sentence);\\n        return ans;\\n    }\\n};\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/864f254a-ae64-4983-937e-f741badbc63b_1692881287.4776943.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "``` cpp []\\nclass Solution // 100% faster\\n{\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        // Vector to store the sentences\\n        vector<string> ans;\\n        int curr_len = 0, start = 0, end = -1;\\n        for (string s : words)\\n        {\\n            if ((end - start + 1) + curr_len + s.size() <= maxWidth)\\n                curr_len += s.size(), end++;\\n            else\\n            {\\n                // Start the current line as the word at index start\\n                string sentence = words[start];\\n                int extra_space = maxWidth - curr_len, padding = extra_space / max(1, end - start);\\n                // extra is the extra space that has to be adjusted so as to make the length equal to maxWidth\\n                int extra = extra_space % max(1, end - start);\\n                // Now add the words from \\'start index + 1\\' to \\'end index\\'\\n                for (int i = start + 1; i <= end; i++)\\n                {\\n                    // Add the padding first\\n                    for (int j = 0; j < padding; j++)\\n                        sentence += \" \";\\n                    // Add the xtra padding, if needed\\n                    if (extra)\\n                        sentence += \" \", extra--;\\n                    sentence += words[i];\\n                }\\n                // Just in case the sentence has only one word\\n                while (sentence.size() < maxWidth)\\n                    sentence += \" \";\\n                ans.push_back(sentence);\\n                // Set the current word as the starting point of the new line\\n                start = end + 1, curr_len = s.size(), end++;\\n            }\\n        }\\n        // Last line has to be dealt with a bit differently, i.e. left justified\\n        string sentence = words[start];\\n        for (int i = start + 1; i <= end; i++)\\n            sentence += \" \" + words[i];\\n        while (sentence.size() < maxWidth)\\n            sentence += \" \";\\n        ans.push_back(sentence);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952302,
                "title": "python-java-c-simple-solution",
                "content": "# ANNOUNCEMENT:\\n**Join the discord and don\\'t forget to Subscribe the youtube channel to access the premium content materials related to computer science and data science in the discord. (For Only first 10,000 Subscribers)**\\n\\n**Happy Learning,  Cheers Guys \\uD83D\\uDE0A**\\n\\n# Click the Link in my Profile to Subscribe\\n\\n# An UPVOTE will be encouraging \\uD83D\\uDC4D\\n\\n#Intuition\\n\\n- Initialize an empty result list to store the justified lines, an empty current line (cur), and a variable to keep track of the total number of letters in the current line (numOfLetters).\\n\\n- Iterate through the list of words one by one.\\n\\nFor each word:\\n\\n- Check if adding the word to the current line would exceed the maximum width. If it would, it\\'s time to justify the current line.\\n- Calculate the number of spaces that need to be added to distribute them evenly. This is done by finding the difference between the maximum width and the total number of letters in the current line.\\n- Distribute these spaces evenly among the words in the current line. The modulo operator is used to ensure that spaces are distributed evenly, even if there are more words than spaces.\\n- Add the justified line to the result list.\\n- Clear the current line and reset the numOfLetters counter.\\n- Continue adding words to the current line until you reach a point where adding the next word would exceed the maximum width.\\n\\n- For the last line of text, left-justify it by adding spaces between words. Ensure that the total width of the line matches the maximum width.\\n\\n- Return the list of justified lines as the final result.\\n\\n```Python []\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        result, cur, num_of_letters = [], [], 0\\n\\n        for word in words:\\n            if num_of_letters + len(word) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i % (len(cur) - 1 or 1)] += \\' \\'\\n                result.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n\\n            cur += [word]\\n            num_of_letters += len(word)\\n\\n        return result + [\\' \\'.join(cur).ljust(maxWidth)]\\n```\\n```Java []\\n\\npublic class TextJustification {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int numOfLetters = 0;\\n\\n        for (String word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur.set(i % (cur.size() - 1), cur.get(i % (cur.size() - 1)) + \" \");\\n                }\\n                result.add(String.join(\"\", cur));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.add(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        result.add(String.join(\" \", cur) + \" \".repeat(maxWidth - numOfLetters - cur.size() + 1));\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\n\\nclass TextJustification {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> cur;\\n        int numOfLetters = 0;\\n\\n        for (const string& word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur[i % (cur.size() - 1)] += \\' \\';\\n                }\\n                result.push_back(accumulate(cur.begin(), cur.end(), string(\"\")));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.push_back(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        string lastLine = accumulate(cur.begin(), cur.end(), string(\" \"));\\n        lastLine += string(maxWidth - numOfLetters - cur.size() + 1, \\' \\');\\n        result.push_back(lastLine);\\n\\n        return result;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        result, cur, num_of_letters = [], [], 0\\n\\n        for word in words:\\n            if num_of_letters + len(word) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i % (len(cur) - 1 or 1)] += \\' \\'\\n                result.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n\\n            cur += [word]\\n            num_of_letters += len(word)\\n\\n        return result + [\\' \\'.join(cur).ljust(maxWidth)]\\n```\n```Java []\\n\\npublic class TextJustification {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        int numOfLetters = 0;\\n\\n        for (String word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur.set(i % (cur.size() - 1), cur.get(i % (cur.size() - 1)) + \" \");\\n                }\\n                result.add(String.join(\"\", cur));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.add(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        result.add(String.join(\" \", cur) + \" \".repeat(maxWidth - numOfLetters - cur.size() + 1));\\n\\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\n\\nclass TextJustification {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> cur;\\n        int numOfLetters = 0;\\n\\n        for (const string& word : words) {\\n            if (numOfLetters + word.length() + cur.size() > maxWidth) {\\n                int spacesToAdd = maxWidth - numOfLetters;\\n                for (int i = 0; i < spacesToAdd; i++) {\\n                    cur[i % (cur.size() - 1)] += \\' \\';\\n                }\\n                result.push_back(accumulate(cur.begin(), cur.end(), string(\"\")));\\n                cur.clear();\\n                numOfLetters = 0;\\n            }\\n\\n            cur.push_back(word);\\n            numOfLetters += word.length();\\n        }\\n\\n        string lastLine = accumulate(cur.begin(), cur.end(), string(\" \"));\\n        lastLine += string(maxWidth - numOfLetters - cur.size() + 1, \\' \\');\\n        result.push_back(lastLine);\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300817,
                "title": "java-solution-with-comments-beats-100",
                "content": "```\\npublic List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;      //index of word in words array\\n        int wordsLen = 0;   // sum of all words that can be put in same line\\n        int spaces = 0;     // sapces that need to be filled\\n        \\n        while(index < words.length) {\\n            if((tempLen + words[index].length()) <= maxLen) {   //check if cur word can be put in cur line\\n                tempLen += words[index].length() + 1;\\n                tempList.add(words[index++]);\\n            }else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size();\\n                spaces = maxLen - wordsLen;\\n                if(tempList.size() == 1) {          // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0));\\n                    for(int i = 0; i < spaces; i++) {\\n                        sb.append(\" \");\\n                    }\\n                    ans.add(sb.toString());\\n                }else if(tempList.size() > 1){      // there\\'s many words in cur line, do the evenly spaceing\\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) {\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \");\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1));\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear();  \\n                tempLen = 0;\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) {\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++)\\n                  sb.append(\" \");\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;      //index of word in words array\\n        int wordsLen = 0;   // sum of all words that can be put in same line\\n        int spaces = 0;     // sapces that need to be filled\\n        \\n        while(index < words.length) {\\n            if((tempLen + words[index].length()) <= maxLen) {   //check if cur word can be put in cur line\\n                tempLen += words[index].length() + 1;\\n                tempList.add(words[index++]);\\n            }else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size();\\n                spaces = maxLen - wordsLen;\\n                if(tempList.size() == 1) {          // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0));\\n                    for(int i = 0; i < spaces; i++) {\\n                        sb.append(\" \");\\n                    }\\n                    ans.add(sb.toString());\\n                }else if(tempList.size() > 1){      // there\\'s many words in cur line, do the evenly spaceing\\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) {\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \");\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1));\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear();  \\n                tempLen = 0;\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) {\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++)\\n                  sb.append(\" \");\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1297598,
                "title": "the-first-hard-level-question-i-ve-ever-solved",
                "content": "The function reorderSpaces is basically a updated version of an easy level problem on leetcode (https://leetcode.com/problems/rearrange-spaces-between-words/) , if you haven\\'t solved that yet just go through it once.\\n```\\nclass Solution:\\n    def reorderSpaces(self, text: str) -> str:\\n        spaces = text.count(\" \")\\n        s = text.split(\" \")\\n        \\n        while \"\" in s :\\n            s.remove(\"\")\\n            \\n        if len(s) == 1:\\n            return s[0] + \" \"*spaces\\n        \\n        #min no of spaces between each word\\n        nsw = spaces//(len(s)-1)\\n        #no. of spaces left \\n        nsl = spaces%(len(s)-1)\\n        result = \"\"\\n        for i in range(len(s)) :\\n            if i != len(s)-1 :\\n                result += s[i] + (\" \")*nsw\\n                if nsl > 0:\\n                    result += \" \"\\n                    nsl -= 1\\n            else:\\n                result += s[i]  \\n        return result\\n            \\n\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        result = []\\n        \\n        last = words.pop(0)\\n        while words:\\n            if len(last) + len(words[0])  >= maxWidth :\\n                t = last + (\" \")*(maxWidth-len(last))\\n                last = words.pop(0)\\n                result.append(t)\\n            \\n            elif len(last) + len(words[0]) < maxWidth :\\n                last = last + \" \" + words.pop(0)             \\n        result.append(last + (\" \")*(maxWidth-len(last)))\\n        \\n        for i in range(len(result)-1):\\n            result[i] = self.reorderSpaces(result[i])\\n            \\n            \\n        return result          \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reorderSpaces(self, text: str) -> str:\\n        spaces = text.count(\" \")\\n        s = text.split(\" \")\\n        \\n        while \"\" in s :\\n            s.remove(\"\")\\n            \\n        if len(s) == 1:\\n            return s[0] + \" \"*spaces\\n        \\n        #min no of spaces between each word\\n        nsw = spaces//(len(s)-1)\\n        #no. of spaces left \\n        nsl = spaces%(len(s)-1)\\n        result = \"\"\\n        for i in range(len(s)) :\\n            if i != len(s)-1 :\\n                result += s[i] + (\" \")*nsw\\n                if nsl > 0:\\n                    result += \" \"\\n                    nsl -= 1\\n            else:\\n                result += s[i]  \\n        return result\\n            \\n\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        result = []\\n        \\n        last = words.pop(0)\\n        while words:\\n            if len(last) + len(words[0])  >= maxWidth :\\n                t = last + (\" \")*(maxWidth-len(last))\\n                last = words.pop(0)\\n                result.append(t)\\n            \\n            elif len(last) + len(words[0]) < maxWidth :\\n                last = last + \" \" + words.pop(0)             \\n        result.append(last + (\" \")*(maxWidth-len(last)))\\n        \\n        for i in range(len(result)-1):\\n            result[i] = self.reorderSpaces(result[i])\\n            \\n            \\n        return result          \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065918,
                "title": "java-0ms-clean-code-with-fully-documentation",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // the final justified list of lines to return.\\n        List<String> justified = new ArrayList();\\n       \\n        // a queue to store all the words of a current line.\\n        Queue<String> currentLine = new LinkedList();\\n        \\n        // efficiently build a new line with a string builder.\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // keep track of all the lengths of each word on the current line (to compare to maxWidth).\\n        int currentLineLen = 0;\\n        \\n        for(String word : words){\\n            \\n            // track both the current words length and the count of all the words in the current line \\n            // (this count represents the single space between each word so far)\\n            int n = word.length();\\n            int m = currentLine.size();\\n            \\n            // if all the words so far in the line, plus a single space between each of them, plus the current word length is \\n            // less than or equal to the max width of a line, then add the current word to the current line.\\n            if(currentLineLen + n + m <= maxWidth){\\n                currentLine.add(word);\\n                currentLineLen += n;\\n            \\n            // otherwise, render the current line with the correct spacing between each word and start a new line with the current word.\\n            }else{\\n                int extraSpace = maxWidth - currentLineLen;\\n                justified.add(getLine(extraSpace, currentLine, sb));\\n                \\n                currentLine.add(word);\\n                sb.setLength(0);\\n                currentLineLen = n;\\n            }\\n        }\\n        \\n        // if after looping through each word, there are still words left in the current line\\n        // then add them to the justified list of lines through a special final string.\\n        if(!currentLine.isEmpty()){\\n            int remainingSpace = maxWidth - (currentLineLen + currentLine.size() - 1);\\n            justified.add(generateLastLine(remainingSpace, currentLine, sb));\\n        }\\n        \\n        return justified;\\n    }\\n    \\n    /**\\n     * This method renders a standard line (not the final line) by taking the total amount of space\\n     * left in the line an distributing the space as equally as possible between the words of the, but \\n     * giving words on the left more space between them than words on the right if the remaining free space\\n     * cant be split equally between all the words.\\n    **/\\n    private String getLine(int extraSpace, Queue<String> currentLine, StringBuilder sb){\\n        \\n        int wordCount = currentLine.size() - 1;\\n        \\n        boolean singleWordLine = wordCount == 0;\\n        \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n\\n            if(!currentLine.isEmpty() || singleWordLine){\\n                \\n                int currentSpace = !singleWordLine ? extraSpace / wordCount : extraSpace;\\n                \\n                if(!singleWordLine && extraSpace % wordCount != 0)\\n                    currentSpace++;\\n                \\n                addEmptySpace(currentSpace, sb);\\n                \\n                extraSpace -= currentSpace;\\n                wordCount--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method renders the final line by placing a single space in between each word and then adding\\n     * any remaing empty space to the end of the line.\\n    **/ \\n    private String generateLastLine(int remainingSpace, Queue<String> currentLine, StringBuilder sb){\\n         \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n            \\n            if(!currentLine.isEmpty())\\n                sb.append(\" \");\\n        }\\n        \\n        if(remainingSpace > 0)\\n            addEmptySpace(remainingSpace, sb);\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method will add the number of empty spaces to the current string builder to match a given length.\\n    **/\\n    private void addEmptySpace(int len, StringBuilder sb){\\n        for(int i = 0; i < len; i++)\\n            sb.append(\" \");\\n    }\\n}\\n```\\n\\nruntime: O(n)\\nspace O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // the final justified list of lines to return.\\n        List<String> justified = new ArrayList();\\n       \\n        // a queue to store all the words of a current line.\\n        Queue<String> currentLine = new LinkedList();\\n        \\n        // efficiently build a new line with a string builder.\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // keep track of all the lengths of each word on the current line (to compare to maxWidth).\\n        int currentLineLen = 0;\\n        \\n        for(String word : words){\\n            \\n            // track both the current words length and the count of all the words in the current line \\n            // (this count represents the single space between each word so far)\\n            int n = word.length();\\n            int m = currentLine.size();\\n            \\n            // if all the words so far in the line, plus a single space between each of them, plus the current word length is \\n            // less than or equal to the max width of a line, then add the current word to the current line.\\n            if(currentLineLen + n + m <= maxWidth){\\n                currentLine.add(word);\\n                currentLineLen += n;\\n            \\n            // otherwise, render the current line with the correct spacing between each word and start a new line with the current word.\\n            }else{\\n                int extraSpace = maxWidth - currentLineLen;\\n                justified.add(getLine(extraSpace, currentLine, sb));\\n                \\n                currentLine.add(word);\\n                sb.setLength(0);\\n                currentLineLen = n;\\n            }\\n        }\\n        \\n        // if after looping through each word, there are still words left in the current line\\n        // then add them to the justified list of lines through a special final string.\\n        if(!currentLine.isEmpty()){\\n            int remainingSpace = maxWidth - (currentLineLen + currentLine.size() - 1);\\n            justified.add(generateLastLine(remainingSpace, currentLine, sb));\\n        }\\n        \\n        return justified;\\n    }\\n    \\n    /**\\n     * This method renders a standard line (not the final line) by taking the total amount of space\\n     * left in the line an distributing the space as equally as possible between the words of the, but \\n     * giving words on the left more space between them than words on the right if the remaining free space\\n     * cant be split equally between all the words.\\n    **/\\n    private String getLine(int extraSpace, Queue<String> currentLine, StringBuilder sb){\\n        \\n        int wordCount = currentLine.size() - 1;\\n        \\n        boolean singleWordLine = wordCount == 0;\\n        \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n\\n            if(!currentLine.isEmpty() || singleWordLine){\\n                \\n                int currentSpace = !singleWordLine ? extraSpace / wordCount : extraSpace;\\n                \\n                if(!singleWordLine && extraSpace % wordCount != 0)\\n                    currentSpace++;\\n                \\n                addEmptySpace(currentSpace, sb);\\n                \\n                extraSpace -= currentSpace;\\n                wordCount--;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method renders the final line by placing a single space in between each word and then adding\\n     * any remaing empty space to the end of the line.\\n    **/ \\n    private String generateLastLine(int remainingSpace, Queue<String> currentLine, StringBuilder sb){\\n         \\n        while(!currentLine.isEmpty()){\\n            sb.append(currentLine.poll());\\n            \\n            if(!currentLine.isEmpty())\\n                sb.append(\" \");\\n        }\\n        \\n        if(remainingSpace > 0)\\n            addEmptySpace(remainingSpace, sb);\\n        \\n        return sb.toString();\\n    }\\n    \\n    /**\\n     * This method will add the number of empty spaces to the current string builder to match a given length.\\n    **/\\n    private void addEmptySpace(int len, StringBuilder sb){\\n        for(int i = 0; i < len; i++)\\n            sb.append(\" \");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24885,
                "title": "share-my-ac-easy-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        if(maxWidth == 0) return {\"\"};\\n        int i = 0, j = 0;\\n        while(j != words.size()){\\n            int len = -1;\\n            while(j < words.size() && len + words[j].size() + 1 <= maxWidth)\\n                len += words[j++].size() + 1;\\n            int space = maxWidth - len + j - i - 1;\\n            int k = i;\\n            while(space){\\n                words[k++] += \" \";\\n                space--;\\n                if(j != words.size() && (k == j - 1 || k == j)) k = i;\\n                if(j == words.size() && k == j) k = j - 1;\\n            }\\n            string line = \"\";\\n            for(int l = i; l < j; l++)\\n                line += words[l];\\n            res.push_back(line);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string>res;\\n        if(maxWidth == 0) return {\"\"};\\n        int i = 0, j = 0;\\n        while(j != words.size()){\\n            int len = -1;\\n            while(j < words.size() && len + words[j].size() + 1 <= maxWidth)\\n                len += words[j++].size() + 1;\\n            int space = maxWidth - len + j - i - 1;\\n            int k = i;\\n            while(space){\\n                words[k++] += \" \";\\n                space--;\\n                if(j != words.size() && (k == j - 1 || k == j)) k = i;\\n                if(j == words.size() && k == j) k = j - 1;\\n            }\\n            string line = \"\";\\n            for(int l = i; l < j; l++)\\n                line += words[l];\\n            res.push_back(line);\\n            i = j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24969,
                "title": "long-but-working-dp-java-solution",
                "content": "This is based on Roy Tushar's solution. See https://www.youtube.com/watch?v=RORuwHiblPc\\n\\n\\n\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {    \\t\\n        \\n        List<String> results = new LinkedList<>();   \\n        \\n        if(words == null) {\\n            return results;\\n        }        \\n        \\n        int[][] costsMatrix = createCostMatrix(words, maxWidth);\\n        \\n        int len = words.length;\\n        \\n        int[] minCosts = new int[len];\\n        int[] paths = new int[len];\\n        \\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        \\n        for(int i = len-1; i >= 0; i--) {\\n            \\n            minCosts[i] = costsMatrix[i][len-1];\\n            paths[i] = len;         \\n            \\n            for(int j = i+1; j < len; j++) {\\n                \\n                if(costsMatrix[i][j-1] != Integer.MAX_VALUE &&\\n                    minCosts[j] + costsMatrix[i][j-1] < minCosts[i]) {\\n                    \\n                    minCosts[i] = minCosts[j] + costsMatrix[i][j-1];\\n                    paths[i] = j;                            \\n                }\\n            }            \\n        }\\n\\n        JustifierIterator iter = new JustifierIterator(words, paths, maxWidth);\\n        \\n        while(iter.hasNext()) {\\n            results.add(iter.next());\\n        }\\n        \\n        return results;        \\n    }\\n    \\n    private int[][] createCostMatrix(String[] words, int maxWidth) {\\n        \\n        int len = words.length;\\n        int[][] costMatrix = new int[len][len];\\n        \\n        for(int row = 0; row < len-1; row++) {\\n            \\n            int usedSpace = 0;\\n            Arrays.fill(costMatrix[row], Integer.MAX_VALUE);\\n            \\n            for(int col = row; col < len; col++) {\\n                \\n            \\tusedSpace += words[col].length();\\n                if(usedSpace <= maxWidth) {\\n                \\tif(col == len-1) {\\n                \\t\\tcostMatrix[row][col] = 0;\\n                \\t} else {                \\t\\n\\t                \\tint unusedSpace = maxWidth - usedSpace;\\n\\t                    costMatrix[row][col] = unusedSpace * unusedSpace;\\n                \\t}\\n                } else {\\n                \\tif(col > 0) {\\n                \\t\\tcostMatrix[row][col-1] = 0;\\n                \\t}\\n                    break;\\n                }\\n                usedSpace++;\\n            }                        \\n        }\\n        \\n        costMatrix[len-1][len-1] = 0;\\n        \\n        return costMatrix;\\n    }\\n    \\n    private class JustifierIterator {\\n        \\n        String[] words;\\n        int[] paths;\\n        int maxWidth;\\n        \\n        int pathsIndex;\\n        \\n        public JustifierIterator(String[] words, int[] paths, int maxWidth) {\\n        \\tthis.paths = paths;\\n            this.words = words;\\n            this.maxWidth = maxWidth;\\n        }\\n        \\n        public boolean hasNext() {\\n            return pathsIndex < words.length;\\n        }\\n        \\n        public String next() {\\n        \\t\\n            int numWords = paths[pathsIndex] - pathsIndex; \\n            int spacesCount = calculateNumSpaces(pathsIndex, numWords);\\n            \\n            String result = generateSentence(pathsIndex, numWords, spacesCount);\\n            pathsIndex = paths[pathsIndex];\\n            \\n            return result;\\n        }\\n        \\n        private int calculateNumSpaces(int initialIndex, int numWords) {\\n            \\n            int numChars = 0;\\n            \\n            for(int i = 0; i < numWords; i++) {\\n                \\n                numChars += words[initialIndex + i].length();\\n            }\\n            \\n            return maxWidth - numChars;\\n        }\\n        \\n        private String generateSentence(int initialIndex, int numWords, int spacesCount) {\\n            \\n            StringBuilder sentence = new StringBuilder();\\n            \\n            if(numWords == 1) {\\n                sentence.append(words[initialIndex]);\\n                sentence.append(generateSpaces(maxWidth-words[initialIndex].length()));\\n                return sentence.toString();\\n            }\\n            \\n            if(initialIndex + numWords == words.length) {\\n                \\n                int len = 0;\\n                \\n                for(int i = 0; i < numWords; i++) {\\n\\n                    sentence.append(words[initialIndex+i]);\\n                    len += words[initialIndex+i].length();\\n                    \\n                    if(len < maxWidth) {\\n                        sentence.append(\" \");\\n                        len++;\\n                    }\\n                }                \\n                sentence.append(generateSpaces(maxWidth-len));\\n                return sentence.toString();\\n            }\\n            \\n            int evenDivision = spacesCount / (numWords-1);\\n            int leftOverSpaces = spacesCount % (numWords-1);\\n            \\n            for(int i = 0; i < numWords-1; i++) {\\n                \\n                int spacesToAdd = evenDivision;\\n                if(leftOverSpaces > 0) {\\n                    spacesToAdd++;\\n                    leftOverSpaces--;\\n                }\\n                \\n                sentence.append(words[initialIndex+i]);\\n                sentence.append(generateSpaces(spacesToAdd));\\n            }\\n            \\n            sentence.append(words[initialIndex+numWords-1]);\\n            \\n            return sentence.toString();\\n        }\\n        \\n        private char[] generateSpaces(int spacesCount) {\\n            \\n            char[] blankSequence = new char[spacesCount];\\n            Arrays.fill(blankSequence, ' ');\\n            \\n            return blankSequence;\\n        }        \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "This is based on Roy Tushar's solution. See https://www.youtube.com/watch?v=RORuwHiblPc\\n\\n\\n\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {    \\t\\n        \\n        List<String> results = new LinkedList<>();   \\n        \\n        if(words == null) {\\n            return results;\\n        }        \\n        \\n        int[][] costsMatrix = createCostMatrix(words, maxWidth);\\n        \\n        int len = words.length;\\n        \\n        int[] minCosts = new int[len];\\n        int[] paths = new int[len];\\n        \\n        Arrays.fill(minCosts, Integer.MAX_VALUE);\\n        \\n        for(int i = len-1; i >= 0; i--) {\\n            \\n            minCosts[i] = costsMatrix[i][len-1];\\n            paths[i] = len;         \\n            \\n            for(int j = i+1; j < len; j++) {\\n                \\n                if(costsMatrix[i][j-1] != Integer.MAX_VALUE &&\\n                    minCosts[j] + costsMatrix[i][j-1] < minCosts[i]) {\\n                    \\n                    minCosts[i] = minCosts[j] + costsMatrix[i][j-1];\\n                    paths[i] = j;                            \\n                }\\n            }            \\n        }\\n\\n        JustifierIterator iter = new JustifierIterator(words, paths, maxWidth);\\n        \\n        while(iter.hasNext()) {\\n            results.add(iter.next());\\n        }\\n        \\n        return results;        \\n    }\\n    \\n    private int[][] createCostMatrix(String[] words, int maxWidth) {\\n        \\n        int len = words.length;\\n        int[][] costMatrix = new int[len][len];\\n        \\n        for(int row = 0; row < len-1; row++) {\\n            \\n            int usedSpace = 0;\\n            Arrays.fill(costMatrix[row], Integer.MAX_VALUE);\\n            \\n            for(int col = row; col < len; col++) {\\n                \\n            \\tusedSpace += words[col].length();\\n                if(usedSpace <= maxWidth) {\\n                \\tif(col == len-1) {\\n                \\t\\tcostMatrix[row][col] = 0;\\n                \\t} else {                \\t\\n\\t                \\tint unusedSpace = maxWidth - usedSpace;\\n\\t                    costMatrix[row][col] = unusedSpace * unusedSpace;\\n                \\t}\\n                } else {\\n                \\tif(col > 0) {\\n                \\t\\tcostMatrix[row][col-1] = 0;\\n                \\t}\\n                    break;\\n                }\\n                usedSpace++;\\n            }                        \\n        }\\n        \\n        costMatrix[len-1][len-1] = 0;\\n        \\n        return costMatrix;\\n    }\\n    \\n    private class JustifierIterator {\\n        \\n        String[] words;\\n        int[] paths;\\n        int maxWidth;\\n        \\n        int pathsIndex;\\n        \\n        public JustifierIterator(String[] words, int[] paths, int maxWidth) {\\n        \\tthis.paths = paths;\\n            this.words = words;\\n            this.maxWidth = maxWidth;\\n        }\\n        \\n        public boolean hasNext() {\\n            return pathsIndex < words.length;\\n        }\\n        \\n        public String next() {\\n        \\t\\n            int numWords = paths[pathsIndex] - pathsIndex; \\n            int spacesCount = calculateNumSpaces(pathsIndex, numWords);\\n            \\n            String result = generateSentence(pathsIndex, numWords, spacesCount);\\n            pathsIndex = paths[pathsIndex];\\n            \\n            return result;\\n        }\\n        \\n        private int calculateNumSpaces(int initialIndex, int numWords) {\\n            \\n            int numChars = 0;\\n            \\n            for(int i = 0; i < numWords; i++) {\\n                \\n                numChars += words[initialIndex + i].length();\\n            }\\n            \\n            return maxWidth - numChars;\\n        }\\n        \\n        private String generateSentence(int initialIndex, int numWords, int spacesCount) {\\n            \\n            StringBuilder sentence = new StringBuilder();\\n            \\n            if(numWords == 1) {\\n                sentence.append(words[initialIndex]);\\n                sentence.append(generateSpaces(maxWidth-words[initialIndex].length()));\\n                return sentence.toString();\\n            }\\n            \\n            if(initialIndex + numWords == words.length) {\\n                \\n                int len = 0;\\n                \\n                for(int i = 0; i < numWords; i++) {\\n\\n                    sentence.append(words[initialIndex+i]);\\n                    len += words[initialIndex+i].length();\\n                    \\n                    if(len < maxWidth) {\\n                        sentence.append(\" \");\\n                        len++;\\n                    }\\n                }                \\n                sentence.append(generateSpaces(maxWidth-len));\\n                return sentence.toString();\\n            }\\n            \\n            int evenDivision = spacesCount / (numWords-1);\\n            int leftOverSpaces = spacesCount % (numWords-1);\\n            \\n            for(int i = 0; i < numWords-1; i++) {\\n                \\n                int spacesToAdd = evenDivision;\\n                if(leftOverSpaces > 0) {\\n                    spacesToAdd++;\\n                    leftOverSpaces--;\\n                }\\n                \\n                sentence.append(words[initialIndex+i]);\\n                sentence.append(generateSpaces(spacesToAdd));\\n            }\\n            \\n            sentence.append(words[initialIndex+numWords-1]);\\n            \\n            return sentence.toString();\\n        }\\n        \\n        private char[] generateSpaces(int spacesCount) {\\n            \\n            char[] blankSequence = new char[spacesCount];\\n            Arrays.fill(blankSequence, ' ');\\n            \\n            return blankSequence;\\n        }        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3952544,
                "title": "putta-easy-solution-c-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int L) {\\n    vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string> &words, int L) {\\n    vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952161,
                "title": "beats-100-js-ts-java-c-c-c-python-python3-kotlin-php",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }\\n        \\n        // Calculate the total number of spaces needed in the line.\\n        int totalSpaces = maxWidth - lineLength;\\n        \\n        // If it\\'s the last line or only one word in the line, left-justify.\\n        if (end == wordsSize || end - start == 1) {\\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    result[*returnSize][idx++] = \\' \\';\\n                }\\n            }\\n            while (idx < maxWidth) {\\n                result[*returnSize][idx++] = \\' \\';\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        } else {\\n            int spaceBetweenWords = totalSpaces / (end - start - 1);\\n            int extraSpaces = totalSpaces % (end - start - 1);\\n            \\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    int spaces = spaceBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                    extraSpaces--;\\n                    for (int j = 0; j < spaces; j++) {\\n                        result[*returnSize][idx++] = \\' \\';\\n                    }\\n                }\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        }\\n        \\n        (*returnSize)++;\\n        start = end;\\n    }\\n    \\n    return result;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0;\\n        \\n        while (i < words.size()) {\\n            int lineLen = words[i].size();\\n            int j = i + 1;\\n            \\n            // Find the words that can fit in the current line\\n            while (j < words.size() && lineLen + 1 + words[j].size() <= maxWidth) {\\n                lineLen += 1 + words[j].size();\\n                j++;\\n            }\\n            \\n            int numWords = j - i;\\n            int totalSpaces = maxWidth - lineLen + numWords - 1;\\n            \\n            // Construct the formatted line\\n            string line = words[i];\\n            if (numWords == 1 || j == words.size()) { // Left-justify\\n                for (int k = i + 1; k < j; k++) {\\n                    line += \" \" + words[k];\\n                }\\n                line += string(maxWidth - line.size(), \\' \\'); // Pad with spaces\\n            } else { // Fully justify\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                for (int k = i + 1; k < j; k++) {\\n                    int spaces = k - i <= extraSpaces ? spacesBetweenWords + 1 : spacesBetweenWords;\\n                    line += string(spaces, \\' \\') + words[k];\\n                }\\n            }\\n            \\n            result.push_back(line);\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n```Typescript []\\nfunction fullJustify(words: string[], maxWidth: number): string[] {\\n    let res = [], str = \"\", i = 0, n = words.length, x = 0;\\n    while( i < n ){\\n        if( (str + words[i]).length === maxWidth ){\\n            str += words[i++];\\n            res.push(str);\\n            str = \"\";\\n            x = i;\\n        }\\n        else if( (str + words[i]).length > maxWidth ){\\n            let j = x, cnt = maxWidth - (str.length - 1);\\n            while( cnt > 0 && j < i - 1 ){\\n                words[j++] += \" \";\\n                cnt--;\\n                if( j === i - 1 && cnt > 0 )j = x\\n            }\\n            let tempStr = \"\"; j = x;\\n            while( j < i )tempStr += j < i - 1 ?  words[j++] + \" \" : words[j++];\\n            while( tempStr.length < maxWidth )tempStr += \" \"\\n            res.push(tempStr);\\n            str = \"\";\\n            x = i;\\n        }\\n        else str += words[i++] + \" \";\\n    }\\n    if( str.length > 0 ){\\n        let cnt = maxWidth - str.length;\\n        while( cnt > 0 ){\\n            str += \" \";\\n            cnt--;\\n        }\\n        res.push(str)\\n    }\\n    return res\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n\\n        while (index < words.length) {\\n            int lineStart = index;\\n            int lineLength = words[index].length();\\n            index++;\\n\\n            while (index < words.length && lineLength + words[index].length() + (index - lineStart) <= maxWidth) {\\n                lineLength += words[index].length();\\n                index++;\\n            }\\n\\n            int totalSpaces = maxWidth - lineLength;\\n            int numWords = index - lineStart;\\n\\n            StringBuilder line = new StringBuilder(words[lineStart]);\\n            \\n            if (numWords == 1 || index == words.length) { // Left-justify last line or single-word lines\\n                for (int i = lineStart + 1; i < index; i++) {\\n                    line.append(\\' \\').append(words[i]);\\n                }\\n                line.append(String.valueOf(\\' \\').repeat(maxWidth - line.length())); // Add extra spaces at the end\\n            } else {\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                \\n                for (int i = lineStart + 1; i < index; i++) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line.append(String.valueOf(\\' \\').repeat(spaces)).append(words[i]);\\n                }\\n            }\\n\\n            result.add(line.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Justify the current line\\n                spaces_to_add = maxWidth - line_length\\n                if len(line) == 1:\\n                    result.append(line[0] + \\' \\' * spaces_to_add)\\n                else:\\n                    num_gaps = len(line) - 1\\n                    spaces_per_gap = spaces_to_add // num_gaps\\n                    extra_spaces = spaces_to_add % num_gaps\\n                    justified_line = line[0]\\n                    for i in range(1, len(line)):\\n                        spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)\\n                        justified_line += \\' \\' * spaces + line[i]\\n                    result.append(justified_line)\\n                \\n                # Reset line and line_length\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Left-justify the last line\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        result.append(last_line)\\n        \\n        return result\\n```\\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []  # Stores words for the current line\\n        line_length = 0\\n        \\n        for word in words:\\n            # Check if adding the current word to the line exceeds the maxWidth\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Distribute extra spaces between words\\n                num_words = len(line)\\n                total_spaces = maxWidth - line_length\\n                \\n                if num_words == 1:\\n                    # Left-justify if there\\'s only one word in the line\\n                    result.append(line[0] + \\' \\' * (maxWidth - len(line[0])))\\n                else:\\n                    # Calculate even and extra spaces\\n                    spaces_per_word = total_spaces // (num_words - 1)\\n                    extra_spaces = total_spaces % (num_words - 1)\\n                    \\n                    # Create the justified line\\n                    justified_line = \"\"\\n                    for i in range(num_words - 1):\\n                        justified_line += line[i] + \\' \\' * spaces_per_word\\n                        if extra_spaces > 0:\\n                            justified_line += \\' \\'\\n                            extra_spaces -= 1\\n                    justified_line += line[num_words - 1]\\n                    result.append(justified_line)\\n                \\n                # Reset line variables for the next line\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Last line: left-justify and no extra spaces\\n        result.append(\\' \\'.join(line) + \\' \\' * (maxWidth - line_length - len(line) + 1))\\n        \\n        return result\\n```\\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = startIndex;\\n            int lineLength = 0;\\n\\n            // Find the range of words that can fit in the current line\\n            while (endIndex < words.Length && lineLength + words[endIndex].Length + (endIndex - startIndex) <= maxWidth) {\\n                lineLength += words[endIndex].Length;\\n                endIndex++;\\n            }\\n\\n            // Calculate the number of total spaces and gaps between words\\n            int totalSpaces = maxWidth - lineLength;\\n            int totalGaps = endIndex - startIndex - 1;\\n            \\n            StringBuilder lineBuilder = new StringBuilder();\\n\\n            // If it\\'s the last line or only one word in the line, left-justify\\n            if (endIndex == words.Length || totalGaps == 0) {\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        lineBuilder.Append(\\' \\');\\n                    }\\n                }\\n                while (lineBuilder.Length < maxWidth) {\\n                    lineBuilder.Append(\\' \\');\\n                }\\n            } else {\\n                int spacesPerGap = totalSpaces / totalGaps;\\n                int extraSpaces = totalSpaces % totalGaps;\\n\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        int spacesToAdd = spacesPerGap + (i - startIndex < extraSpaces ? 1 : 0);\\n                        lineBuilder.Append(\\' \\', spacesToAdd);\\n                    }\\n                }\\n            }\\n\\n            result.Add(lineBuilder.ToString());\\n            startIndex = endIndex;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```Javascript []\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n        val result = mutableListOf<String>()\\n        var lineWords = mutableListOf<String>()\\n        var lineLength = 0\\n        \\n        for (word in words) {\\n            if (lineLength + lineWords.size + word.length <= maxWidth) {\\n                lineWords.add(word)\\n                lineLength += word.length\\n            } else {\\n                result.add(constructLine(lineWords, maxWidth, lineLength))\\n                lineWords.clear()\\n                lineWords.add(word)\\n                lineLength = word.length\\n            }\\n        }\\n        \\n        // Last line\\n        if (lineWords.isNotEmpty()) {\\n            val lastLine = lineWords.joinToString(\" \")\\n            result.add(lastLine.padEnd(maxWidth))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun constructLine(words: List<String>, maxWidth: Int, lineLength: Int): String {\\n        val numWords = words.size\\n        if (numWords == 1) {\\n            return words[0].padEnd(maxWidth)\\n        }\\n        \\n        val totalSpaces = maxWidth - lineLength\\n        val spaceSlots = numWords - 1\\n        val baseSpace = totalSpaces / spaceSlots\\n        val extraSpaceSlots = totalSpaces % spaceSlots\\n        \\n        val lineBuilder = StringBuilder()\\n        for (i in 0 until numWords - 1) {\\n            lineBuilder.append(words[i])\\n            lineBuilder.append(\" \".repeat(baseSpace))\\n            if (i < extraSpaceSlots) {\\n                lineBuilder.append(\" \")\\n            }\\n        }\\n        lineBuilder.append(words.last())\\n        \\n        return lineBuilder.toString()\\n    }\\n}\\n```\\n```PHP []\\nclass Solution {\\n    /**\\n     * @param String[] $words\\n     * @param Integer $maxWidth\\n     * @return String[]\\n     */\\n    function fullJustify($words, $maxWidth) {\\n        $result = [];\\n        $line = [];\\n        $lineWidth = 0;\\n        \\n        foreach ($words as $word) {\\n            // Check if adding the next word exceeds maxWidth\\n            if ($lineWidth + count($line) + strlen($word) > $maxWidth) {\\n                $formattedLine = $this->formatLine($line, $lineWidth, $maxWidth);\\n                $result[] = $formattedLine;\\n                \\n                $line = [];\\n                $lineWidth = 0;\\n            }\\n            \\n            $line[] = $word;\\n            $lineWidth += strlen($word);\\n        }\\n        \\n        // Handle the last line\\n        $lastLine = implode(\\' \\', $line);\\n        $lastLine .= str_repeat(\\' \\', $maxWidth - strlen($lastLine));\\n        $result[] = $lastLine;\\n        \\n        return $result;\\n    }\\n    \\n    // Helper function to format a line\\n    private function formatLine($line, $lineWidth, $maxWidth) {\\n        $numWords = count($line);\\n        $numSpaces = $maxWidth - $lineWidth;\\n        \\n        if ($numWords === 1) {\\n            return $line[0] . str_repeat(\\' \\', $numSpaces);\\n        }\\n        \\n        $avgSpaces = floor($numSpaces / ($numWords - 1));\\n        $extraSpaces = $numSpaces % ($numWords - 1);\\n        \\n        $formattedLine = $line[0];\\n        \\n        for ($i = 1; $i < $numWords; $i++) {\\n            $numPaddingSpaces = $avgSpaces + ($i <= $extraSpaces ? 1 : 0);\\n            $formattedLine .= str_repeat(\\' \\', $numPaddingSpaces) . $line[$i];\\n        }\\n        \\n        return $formattedLine;\\n    }\\n}\\n```\\n\\n\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize) {\\n    char **result = (char **)malloc(sizeof(char *) * wordsSize);\\n    *returnSize = 0;\\n    \\n    int start = 0;  // Index of the first word in the current line.\\n    \\n    while (start < wordsSize) {\\n        int end = start;  // Index of the last word in the current line.\\n        int lineLength = 0;  // Length of the words and spaces in the current line.\\n        \\n        // Calculate the number of words and total length that can fit in the current line.\\n        while (end < wordsSize && lineLength + strlen(words[end]) + end - start <= maxWidth) {\\n            lineLength += strlen(words[end]);\\n            end++;\\n        }\\n        \\n        // Calculate the total number of spaces needed in the line.\\n        int totalSpaces = maxWidth - lineLength;\\n        \\n        // If it\\'s the last line or only one word in the line, left-justify.\\n        if (end == wordsSize || end - start == 1) {\\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    result[*returnSize][idx++] = \\' \\';\\n                }\\n            }\\n            while (idx < maxWidth) {\\n                result[*returnSize][idx++] = \\' \\';\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        } else {\\n            int spaceBetweenWords = totalSpaces / (end - start - 1);\\n            int extraSpaces = totalSpaces % (end - start - 1);\\n            \\n            result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));\\n            int idx = 0;\\n            for (int i = start; i < end; i++) {\\n                strcpy(result[*returnSize] + idx, words[i]);\\n                idx += strlen(words[i]);\\n                if (i != end - 1) {\\n                    int spaces = spaceBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                    extraSpaces--;\\n                    for (int j = 0; j < spaces; j++) {\\n                        result[*returnSize][idx++] = \\' \\';\\n                    }\\n                }\\n            }\\n            result[*returnSize][maxWidth] = \\'\\\\0\\';\\n        }\\n        \\n        (*returnSize)++;\\n        start = end;\\n    }\\n    \\n    return result;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0;\\n        \\n        while (i < words.size()) {\\n            int lineLen = words[i].size();\\n            int j = i + 1;\\n            \\n            // Find the words that can fit in the current line\\n            while (j < words.size() && lineLen + 1 + words[j].size() <= maxWidth) {\\n                lineLen += 1 + words[j].size();\\n                j++;\\n            }\\n            \\n            int numWords = j - i;\\n            int totalSpaces = maxWidth - lineLen + numWords - 1;\\n            \\n            // Construct the formatted line\\n            string line = words[i];\\n            if (numWords == 1 || j == words.size()) { // Left-justify\\n                for (int k = i + 1; k < j; k++) {\\n                    line += \" \" + words[k];\\n                }\\n                line += string(maxWidth - line.size(), \\' \\'); // Pad with spaces\\n            } else { // Fully justify\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                for (int k = i + 1; k < j; k++) {\\n                    int spaces = k - i <= extraSpaces ? spacesBetweenWords + 1 : spacesBetweenWords;\\n                    line += string(spaces, \\' \\') + words[k];\\n                }\\n            }\\n            \\n            result.push_back(line);\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```Typescript []\\nfunction fullJustify(words: string[], maxWidth: number): string[] {\\n    let res = [], str = \"\", i = 0, n = words.length, x = 0;\\n    while( i < n ){\\n        if( (str + words[i]).length === maxWidth ){\\n            str += words[i++];\\n            res.push(str);\\n            str = \"\";\\n            x = i;\\n        }\\n        else if( (str + words[i]).length > maxWidth ){\\n            let j = x, cnt = maxWidth - (str.length - 1);\\n            while( cnt > 0 && j < i - 1 ){\\n                words[j++] += \" \";\\n                cnt--;\\n                if( j === i - 1 && cnt > 0 )j = x\\n            }\\n            let tempStr = \"\"; j = x;\\n            while( j < i )tempStr += j < i - 1 ?  words[j++] + \" \" : words[j++];\\n            while( tempStr.length < maxWidth )tempStr += \" \"\\n            res.push(tempStr);\\n            str = \"\";\\n            x = i;\\n        }\\n        else str += words[i++] + \" \";\\n    }\\n    if( str.length > 0 ){\\n        let cnt = maxWidth - str.length;\\n        while( cnt > 0 ){\\n            str += \" \";\\n            cnt--;\\n        }\\n        res.push(str)\\n    }\\n    return res\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        int index = 0;\\n\\n        while (index < words.length) {\\n            int lineStart = index;\\n            int lineLength = words[index].length();\\n            index++;\\n\\n            while (index < words.length && lineLength + words[index].length() + (index - lineStart) <= maxWidth) {\\n                lineLength += words[index].length();\\n                index++;\\n            }\\n\\n            int totalSpaces = maxWidth - lineLength;\\n            int numWords = index - lineStart;\\n\\n            StringBuilder line = new StringBuilder(words[lineStart]);\\n            \\n            if (numWords == 1 || index == words.length) { // Left-justify last line or single-word lines\\n                for (int i = lineStart + 1; i < index; i++) {\\n                    line.append(\\' \\').append(words[i]);\\n                }\\n                line.append(String.valueOf(\\' \\').repeat(maxWidth - line.length())); // Add extra spaces at the end\\n            } else {\\n                int spacesBetweenWords = totalSpaces / (numWords - 1);\\n                int extraSpaces = totalSpaces % (numWords - 1);\\n                \\n                for (int i = lineStart + 1; i < index; i++) {\\n                    int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n                    line.append(String.valueOf(\\' \\').repeat(spaces)).append(words[i]);\\n                }\\n            }\\n\\n            result.add(line.toString());\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        result = []\\n        line = []\\n        line_length = 0\\n        \\n        for word in words:\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Justify the current line\\n                spaces_to_add = maxWidth - line_length\\n                if len(line) == 1:\\n                    result.append(line[0] + \\' \\' * spaces_to_add)\\n                else:\\n                    num_gaps = len(line) - 1\\n                    spaces_per_gap = spaces_to_add // num_gaps\\n                    extra_spaces = spaces_to_add % num_gaps\\n                    justified_line = line[0]\\n                    for i in range(1, len(line)):\\n                        spaces = spaces_per_gap + (1 if i <= extra_spaces else 0)\\n                        justified_line += \\' \\' * spaces + line[i]\\n                    result.append(justified_line)\\n                \\n                # Reset line and line_length\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Left-justify the last line\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        result.append(last_line)\\n        \\n        return result\\n```\n```Python3 []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []  # Stores words for the current line\\n        line_length = 0\\n        \\n        for word in words:\\n            # Check if adding the current word to the line exceeds the maxWidth\\n            if line_length + len(line) + len(word) > maxWidth:\\n                # Distribute extra spaces between words\\n                num_words = len(line)\\n                total_spaces = maxWidth - line_length\\n                \\n                if num_words == 1:\\n                    # Left-justify if there\\'s only one word in the line\\n                    result.append(line[0] + \\' \\' * (maxWidth - len(line[0])))\\n                else:\\n                    # Calculate even and extra spaces\\n                    spaces_per_word = total_spaces // (num_words - 1)\\n                    extra_spaces = total_spaces % (num_words - 1)\\n                    \\n                    # Create the justified line\\n                    justified_line = \"\"\\n                    for i in range(num_words - 1):\\n                        justified_line += line[i] + \\' \\' * spaces_per_word\\n                        if extra_spaces > 0:\\n                            justified_line += \\' \\'\\n                            extra_spaces -= 1\\n                    justified_line += line[num_words - 1]\\n                    result.append(justified_line)\\n                \\n                # Reset line variables for the next line\\n                line = []\\n                line_length = 0\\n            \\n            line.append(word)\\n            line_length += len(word)\\n        \\n        # Last line: left-justify and no extra spaces\\n        result.append(\\' \\'.join(line) + \\' \\' * (maxWidth - line_length - len(line) + 1))\\n        \\n        return result\\n```\n```C# []\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = startIndex;\\n            int lineLength = 0;\\n\\n            // Find the range of words that can fit in the current line\\n            while (endIndex < words.Length && lineLength + words[endIndex].Length + (endIndex - startIndex) <= maxWidth) {\\n                lineLength += words[endIndex].Length;\\n                endIndex++;\\n            }\\n\\n            // Calculate the number of total spaces and gaps between words\\n            int totalSpaces = maxWidth - lineLength;\\n            int totalGaps = endIndex - startIndex - 1;\\n            \\n            StringBuilder lineBuilder = new StringBuilder();\\n\\n            // If it\\'s the last line or only one word in the line, left-justify\\n            if (endIndex == words.Length || totalGaps == 0) {\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        lineBuilder.Append(\\' \\');\\n                    }\\n                }\\n                while (lineBuilder.Length < maxWidth) {\\n                    lineBuilder.Append(\\' \\');\\n                }\\n            } else {\\n                int spacesPerGap = totalSpaces / totalGaps;\\n                int extraSpaces = totalSpaces % totalGaps;\\n\\n                for (int i = startIndex; i < endIndex; i++) {\\n                    lineBuilder.Append(words[i]);\\n                    if (i < endIndex - 1) {\\n                        int spacesToAdd = spacesPerGap + (i - startIndex < extraSpaces ? 1 : 0);\\n                        lineBuilder.Append(\\' \\', spacesToAdd);\\n                    }\\n                }\\n            }\\n\\n            result.Add(lineBuilder.ToString());\\n            startIndex = endIndex;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```Javascript []\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```\n```Kotlin []\\nclass Solution {\\n    fun fullJustify(words: Array<String>, maxWidth: Int): List<String> {\\n        val result = mutableListOf<String>()\\n        var lineWords = mutableListOf<String>()\\n        var lineLength = 0\\n        \\n        for (word in words) {\\n            if (lineLength + lineWords.size + word.length <= maxWidth) {\\n                lineWords.add(word)\\n                lineLength += word.length\\n            } else {\\n                result.add(constructLine(lineWords, maxWidth, lineLength))\\n                lineWords.clear()\\n                lineWords.add(word)\\n                lineLength = word.length\\n            }\\n        }\\n        \\n        // Last line\\n        if (lineWords.isNotEmpty()) {\\n            val lastLine = lineWords.joinToString(\" \")\\n            result.add(lastLine.padEnd(maxWidth))\\n        }\\n        \\n        return result\\n    }\\n    \\n    private fun constructLine(words: List<String>, maxWidth: Int, lineLength: Int): String {\\n        val numWords = words.size\\n        if (numWords == 1) {\\n            return words[0].padEnd(maxWidth)\\n        }\\n        \\n        val totalSpaces = maxWidth - lineLength\\n        val spaceSlots = numWords - 1\\n        val baseSpace = totalSpaces / spaceSlots\\n        val extraSpaceSlots = totalSpaces % spaceSlots\\n        \\n        val lineBuilder = StringBuilder()\\n        for (i in 0 until numWords - 1) {\\n            lineBuilder.append(words[i])\\n            lineBuilder.append(\" \".repeat(baseSpace))\\n            if (i < extraSpaceSlots) {\\n                lineBuilder.append(\" \")\\n            }\\n        }\\n        lineBuilder.append(words.last())\\n        \\n        return lineBuilder.toString()\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\n    /**\\n     * @param String[] $words\\n     * @param Integer $maxWidth\\n     * @return String[]\\n     */\\n    function fullJustify($words, $maxWidth) {\\n        $result = [];\\n        $line = [];\\n        $lineWidth = 0;\\n        \\n        foreach ($words as $word) {\\n            // Check if adding the next word exceeds maxWidth\\n            if ($lineWidth + count($line) + strlen($word) > $maxWidth) {\\n                $formattedLine = $this->formatLine($line, $lineWidth, $maxWidth);\\n                $result[] = $formattedLine;\\n                \\n                $line = [];\\n                $lineWidth = 0;\\n            }\\n            \\n            $line[] = $word;\\n            $lineWidth += strlen($word);\\n        }\\n        \\n        // Handle the last line\\n        $lastLine = implode(\\' \\', $line);\\n        $lastLine .= str_repeat(\\' \\', $maxWidth - strlen($lastLine));\\n        $result[] = $lastLine;\\n        \\n        return $result;\\n    }\\n    \\n    // Helper function to format a line\\n    private function formatLine($line, $lineWidth, $maxWidth) {\\n        $numWords = count($line);\\n        $numSpaces = $maxWidth - $lineWidth;\\n        \\n        if ($numWords === 1) {\\n            return $line[0] . str_repeat(\\' \\', $numSpaces);\\n        }\\n        \\n        $avgSpaces = floor($numSpaces / ($numWords - 1));\\n        $extraSpaces = $numSpaces % ($numWords - 1);\\n        \\n        $formattedLine = $line[0];\\n        \\n        for ($i = 1; $i < $numWords; $i++) {\\n            $numPaddingSpaces = $avgSpaces + ($i <= $extraSpaces ? 1 : 0);\\n            $formattedLine .= str_repeat(\\' \\', $numPaddingSpaces) . $line[$i];\\n        }\\n        \\n        return $formattedLine;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3952159,
                "title": "c-strings-with-examples-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe fundamental operations for strings should be known to solve such questions. LC has different kinds of hard questions. To solve this question one does not need special algorithms or tricks.\\nBut it is  very annoying for debugging until to get right answer!\\n\\nMaybe solve the easy question first.\\n[1592. Rearrange Spaces Between Words](https://leetcode.com/problems/rearrange-spaces-between-words/description/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermine which words are in which line.\\nThe function ```print_wIdx``` handles where extra whitespaces to insert.\\n\\nFor 2nd approach, every line is initialized with\\n```\\nline = string(maxWidth, \\' \\');\\n```\\nand then the function copy in C++ algorithm is used for copying the ```words[i]``` to the right place; its performance is better than operator+ and beats 100.00% with runtime 0 ms. It is to mention that if operator+ for strings is used, the string line will be allocated several times.\\n\\nLet\\'s consider the string words=\\n```[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]```\\n\\nTake care where extra whitespaces to insert\\n\\nmaxWidth=20 \\n```\\n|Science  is  what we|\\n|understand      well|\\n|enough to explain to|\\n|a  computer.  Art is|\\n|everything  else  we|\\n|do                  |\\n```\\nmaxWidth=19\\n```\\n|Science  is what we|\\n|understand     well|\\n|enough  to  explain|\\n|to  a computer. Art|\\n|is  everything else|\\n|we do              |\\n```\\nmaxWidth=21\\n```\\n|Science  is  what  we|\\n|understand       well|\\n|enough  to explain to|\\n|a  computer.  Art  is|\\n|everything else we do|\\n```\\nOther testcase:\\n```\\n[\"My\",\"momma\",\"always\",\"said,\",\"\\\\\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you\\'re\",\"gonna\",\"get.\"]\\n20\\n```\\nans\\n```\\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\\n|you\\'re gonna get.   | no extra space\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    string space(int c) {\\n        return string(c, \\' \\');\\n    }\\n\\n    vector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n        for (int i = 0; i < wIdx.size(); i++) {\\n            int numWords = wIdx[i].first.size();\\n            int totalLen = wIdx[i].second;\\n            int totalSpaces = maxWidth - totalLen;\\n            int numGaps = numWords - 1;\\n            int numSpaces = 1;\\n            int remainingSpaces = 0;\\n\\n            if (numGaps > 0) {\\n                numSpaces = totalSpaces / numGaps;\\n                remainingSpaces = totalSpaces % numGaps;\\n            }\\n\\n            string line = words[wIdx[i].first[0]]; // Start with the first word\\n            for (int j = 1; j < numWords; j++) {\\n                if (i == wIdx.size() - 1) {\\n                    // Last line, left justify\\n                    line += space(1);\\n                } \\n                else {\\n                    line+= space(numSpaces+(remainingSpaces>0?1:0));\\n                    remainingSpaces--;\\n                }\\n                line+= words[wIdx[i].first[j]];\\n            }\\n\\n            if (line.size() < maxWidth)\\n                line+= space(maxWidth-line.size());\\n\\n            ans.push_back(line);\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<pair<vector<int>, int>> wIdx(1);\\n        int cur = 0;\\n        int len = 0;\\n        for (int i = 0; i < n; i++) {\\n            //wlen=sum of length of words w/o space in 1 line\\n            int wlen = words[i].size();\\n            len += wlen;\\n            if (len > maxWidth) {\\n                wIdx.push_back({{i}, wlen});\\n                cur++;\\n                len = wlen;\\n            } \\n            else {\\n                wIdx[cur].first.push_back(i);\\n                wIdx[cur].second += wlen;\\n            }\\n            len++; //at least 1 whitespace between words\\n        }\\n\\n        return print_wIdx(words, wIdx, maxWidth);\\n    }\\n};\\n\\n```\\n# Other implementation for print_wIdx using C++ algorithm copy has runtime 0 ms and beats 100.00%\\n```\\nvector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n    vector<string> ans;\\n\\n    for (int i = 0; i < wIdx.size(); i++) {\\n        int numWords = wIdx[i].first.size();\\n        int totalSpaces = maxWidth - wIdx[i].second;\\n        int numGaps = numWords-1;\\n        int numSpaces = 1;\\n        int remainingSpaces = 0;\\n\\n        if (numGaps > 0) {\\n            auto [q, r] = div(totalSpaces, numGaps);\\n            numSpaces = q, remainingSpaces = r;\\n    //        cout<<q<<\"\\\\n\"<<r<<endl;\\n        }\\n\\n        string line = string(maxWidth, \\' \\');\\n        auto& w0 = words[wIdx[i].first[0]];\\n        copy(w0.begin(), w0.end(), line.begin()); // Copy the first word\\n\\n        int pos = w0.size();\\n        for (int j = 1; j < numWords; j++) {\\n            if (i != wIdx.size() - 1) {\\n                pos += numSpaces +(remainingSpaces > 0 ? 1 : 0);\\n                remainingSpaces--;\\n            }\\n            else pos++;\\n            auto& w = words[wIdx[i].first[j]];\\n            copy(w.begin(), w.end(), line.begin() + pos); // Copy each word\\n            pos += w.size();\\n        }\\n        ans.push_back(line);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```print_wIdx```\n```\\nline = string(maxWidth, \\' \\');\\n```\n```words[i]```\n```[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]```\n```\\n|Science  is  what we|\\n|understand      well|\\n|enough to explain to|\\n|a  computer.  Art is|\\n|everything  else  we|\\n|do                  |\\n```\n```\\n|Science  is what we|\\n|understand     well|\\n|enough  to  explain|\\n|to  a computer. Art|\\n|is  everything else|\\n|we do              |\\n```\n```\\n|Science  is  what  we|\\n|understand       well|\\n|enough  to explain to|\\n|a  computer.  Art  is|\\n|everything else we do|\\n```\n```\\n[\"My\",\"momma\",\"always\",\"said,\",\"\\\\\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you\\'re\",\"gonna\",\"get.\"]\\n20\\n```\n```\\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\\n|you\\'re gonna get.   | no extra space\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n\\n    string space(int c) {\\n        return string(c, \\' \\');\\n    }\\n\\n    vector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n        for (int i = 0; i < wIdx.size(); i++) {\\n            int numWords = wIdx[i].first.size();\\n            int totalLen = wIdx[i].second;\\n            int totalSpaces = maxWidth - totalLen;\\n            int numGaps = numWords - 1;\\n            int numSpaces = 1;\\n            int remainingSpaces = 0;\\n\\n            if (numGaps > 0) {\\n                numSpaces = totalSpaces / numGaps;\\n                remainingSpaces = totalSpaces % numGaps;\\n            }\\n\\n            string line = words[wIdx[i].first[0]]; // Start with the first word\\n            for (int j = 1; j < numWords; j++) {\\n                if (i == wIdx.size() - 1) {\\n                    // Last line, left justify\\n                    line += space(1);\\n                } \\n                else {\\n                    line+= space(numSpaces+(remainingSpaces>0?1:0));\\n                    remainingSpaces--;\\n                }\\n                line+= words[wIdx[i].first[j]];\\n            }\\n\\n            if (line.size() < maxWidth)\\n                line+= space(maxWidth-line.size());\\n\\n            ans.push_back(line);\\n        }\\n\\n        return ans;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<pair<vector<int>, int>> wIdx(1);\\n        int cur = 0;\\n        int len = 0;\\n        for (int i = 0; i < n; i++) {\\n            //wlen=sum of length of words w/o space in 1 line\\n            int wlen = words[i].size();\\n            len += wlen;\\n            if (len > maxWidth) {\\n                wIdx.push_back({{i}, wlen});\\n                cur++;\\n                len = wlen;\\n            } \\n            else {\\n                wIdx[cur].first.push_back(i);\\n                wIdx[cur].second += wlen;\\n            }\\n            len++; //at least 1 whitespace between words\\n        }\\n\\n        return print_wIdx(words, wIdx, maxWidth);\\n    }\\n};\\n\\n```\n```\\nvector<string> print_wIdx(vector<string>& words, vector<pair<vector<int>, int>>& wIdx, int maxWidth) {\\n    vector<string> ans;\\n\\n    for (int i = 0; i < wIdx.size(); i++) {\\n        int numWords = wIdx[i].first.size();\\n        int totalSpaces = maxWidth - wIdx[i].second;\\n        int numGaps = numWords-1;\\n        int numSpaces = 1;\\n        int remainingSpaces = 0;\\n\\n        if (numGaps > 0) {\\n            auto [q, r] = div(totalSpaces, numGaps);\\n            numSpaces = q, remainingSpaces = r;\\n    //        cout<<q<<\"\\\\n\"<<r<<endl;\\n        }\\n\\n        string line = string(maxWidth, \\' \\');\\n        auto& w0 = words[wIdx[i].first[0]];\\n        copy(w0.begin(), w0.end(), line.begin()); // Copy the first word\\n\\n        int pos = w0.size();\\n        for (int j = 1; j < numWords; j++) {\\n            if (i != wIdx.size() - 1) {\\n                pos += numSpaces +(remainingSpaces > 0 ? 1 : 0);\\n                remainingSpaces--;\\n            }\\n            else pos++;\\n            auto& w = words[wIdx[i].first[j]];\\n            copy(w.begin(), w.end(), line.begin() + pos); // Copy each word\\n            pos += w.size();\\n        }\\n        ans.push_back(line);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 948678,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justify(part, totalLen):\\n        \\n            if len(part) == 1:\\n                return justifyLeft(part, totalLen)\\n            \\n            tatalSpaces = maxWidth - totalLen\\n            minSpaces = tatalSpaces // (len(part) - 1)\\n            extraSpaces = tatalSpaces % (len(part) - 1)\\n            \\n            spaces = [\\'\\'] * len(words)\\n            for i in range(1, len(words)):\\n                space = \\' \\' * minSpaces\\n                if extraSpaces > 0:\\n                    space += \\' \\'\\n                    extraSpaces -= 1\\n                spaces[i] = space\\n\\n            return \"\".join(map(lambda x: x[0] + x[1], zip(spaces, part)))\\n        \\n        def justifyLeft(part, totalLen):\\n            extraSpaces = len(part) - 1 if len(part) >= 2 else 0             \\n            return \" \".join(part) + \\' \\' * (maxWidth - totalLen - extraSpaces)\\n        \\n        result = []\\n        \\n        currentLen = 0\\n        current = []\\n        \\n        for word in words:\\n            spaces = len(current)\\n            \\n            if currentLen + len(word) + spaces > maxWidth:\\n                row = justify(current, currentLen)                    \\n                result.append(row)\\n\\n                currentLen = 0                \\n                current = []\\n                \\n            current.append(word)\\n            currentLen += len(word)\\n\\n        row = justifyLeft(current, currentLen)                    \\n        result.append(row)\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def justify(part, totalLen):\\n        \\n            if len(part) == 1:\\n                return justifyLeft(part, totalLen)\\n            \\n            tatalSpaces = maxWidth - totalLen\\n            minSpaces = tatalSpaces // (len(part) - 1)\\n            extraSpaces = tatalSpaces % (len(part) - 1)\\n            \\n            spaces = [\\'\\'] * len(words)\\n            for i in range(1, len(words)):\\n                space = \\' \\' * minSpaces\\n                if extraSpaces > 0:\\n                    space += \\' \\'\\n                    extraSpaces -= 1\\n                spaces[i] = space\\n\\n            return \"\".join(map(lambda x: x[0] + x[1], zip(spaces, part)))\\n        \\n        def justifyLeft(part, totalLen):\\n            extraSpaces = len(part) - 1 if len(part) >= 2 else 0             \\n            return \" \".join(part) + \\' \\' * (maxWidth - totalLen - extraSpaces)\\n        \\n        result = []\\n        \\n        currentLen = 0\\n        current = []\\n        \\n        for word in words:\\n            spaces = len(current)\\n            \\n            if currentLen + len(word) + spaces > maxWidth:\\n                row = justify(current, currentLen)                    \\n                result.append(row)\\n\\n                currentLen = 0                \\n                current = []\\n                \\n            current.append(word)\\n            currentLen += len(word)\\n\\n        row = justifyLeft(current, currentLen)                    \\n        result.append(row)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952386,
                "title": "beginner-friendly-simple-java-solution-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#### This code  justifies an array of words within a given `maxWidth`:\\n1. Iterate through words, grouping them into lines that fit within `maxWidth`, and adjust spaces between words to achieve full justification. Add each line to the `result` list.\\n2. Return the `result` list containing justified lines.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty list `result` to store the final justified lines.\\n- Loop through the array of words:\\n         - For each iteration, set i as the current index and initialize `wordCount` and `lineLength` to 0.\\n         - Increment `wordCount` while the accumulated length of words within the line does not exceed `maxWidth`.\\n- Inside the loop, create a `lineBuilder` and start appending the words:\\n            - If `wordCount` is 1 or at the end of the array, append the words with single spaces in between.\\n            - Otherwise, calculate `totalSpaces` and `extraSpaces` for justification.\\n            - Append words with calculated spaces.\\n- Add the completed line (in `lineBuilder`) to the `result` list.\\n- Continue the outer loop using the next index after the current line (`i += wordCount`).\\n- After processing all lines, return the `result` list.\\n\\n    \\n    \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (int i = 0, wordCount, lineLength; i < words.length; i += wordCount) {\\n            for (wordCount = 0, lineLength = 0; \\n                 i + wordCount < words.length && \\n                 lineLength + words[i + wordCount].length() + wordCount <= maxWidth; \\n                 wordCount++) {\\n                lineLength += words[i + wordCount].length();\\n            }\\n            \\n            StringBuilder lineBuilder = new StringBuilder(words[i]);\\n            \\n            if (wordCount == 1 || i + wordCount == words.length) {\\n                for (int j = 1; j < wordCount; j++) {\\n                    lineBuilder.append(\" \").append(words[i + j]);\\n                }\\n                lineBuilder.append(\" \".repeat(maxWidth - lineBuilder.length()));\\n            } else {\\n                int totalSpaces = (maxWidth - lineLength) / (wordCount - 1);\\n                int extraSpaces = (maxWidth - lineLength) % (wordCount - 1);\\n                \\n                for (int j = 1; j < wordCount; j++) {\\n                    int spacesToAdd = totalSpaces + (extraSpaces-- > 0 ? 1 : 0);\\n                    lineBuilder.append(\" \".repeat(spacesToAdd)).append(words[i + j]);\\n                }\\n            } \\n            result.add(lineBuilder.toString());\\n        }   \\n        return result;\\n    }\\n}\\n\\n```\\n# If you like the solution please Upvote.\\n![29c341f2-e223-4bc6-8894-efb9ed7a6744_1692496789.0986528.png](https://assets.leetcode.com/users/images/2c413272-3028-4385-896a-9f49ca949dd3_1692845736.9024503.png)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n        \\n        for (int i = 0, wordCount, lineLength; i < words.length; i += wordCount) {\\n            for (wordCount = 0, lineLength = 0; \\n                 i + wordCount < words.length && \\n                 lineLength + words[i + wordCount].length() + wordCount <= maxWidth; \\n                 wordCount++) {\\n                lineLength += words[i + wordCount].length();\\n            }\\n            \\n            StringBuilder lineBuilder = new StringBuilder(words[i]);\\n            \\n            if (wordCount == 1 || i + wordCount == words.length) {\\n                for (int j = 1; j < wordCount; j++) {\\n                    lineBuilder.append(\" \").append(words[i + j]);\\n                }\\n                lineBuilder.append(\" \".repeat(maxWidth - lineBuilder.length()));\\n            } else {\\n                int totalSpaces = (maxWidth - lineLength) / (wordCount - 1);\\n                int extraSpaces = (maxWidth - lineLength) % (wordCount - 1);\\n                \\n                for (int j = 1; j < wordCount; j++) {\\n                    int spacesToAdd = totalSpaces + (extraSpaces-- > 0 ? 1 : 0);\\n                    lineBuilder.append(\" \".repeat(spacesToAdd)).append(words[i + j]);\\n                }\\n            } \\n            result.add(lineBuilder.toString());\\n        }   \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707606,
                "title": "c-readable-modularized-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    /** \\n     * Returns string containing left-aligned line formed using words[low..high]\\n     * @param maxWidth: Total length of the line\\n     */\\n    string getLeftAlignedLine(int low, int high, vector<string>& words, int maxWidth) {\\n        string line;\\n        for(int i = low; i <= high; i++)\\n            line += words[i] + \" \";\\n        line.pop_back();\\n        line += string(maxWidth - line.size(), \\' \\');\\n        return line;\\n    }\\n    \\n    /**\\n     * Returns string containing justified line formed using words[low..high]\\n     * @param extraSpace: Number of extra spaces that need to be spread evenly between\\n     *      the words. This count doesn\\'t include the single spaces that already need\\n     *      to be inserted between each pair of words.\\n     */\\n    string getJustifiedLine(int low, int high, vector<string>& words, int extraSpaces) {\\n        string line;\\n        int n = high - low + 1, slots = n - 1;\\n        \\n        // The number of extra spaces that must be inserted between every pair of words.\\n        // Some pairs might have (space+1) spaces between them if the total is in excess.\\n        int space = slots > 0 ? extraSpaces / slots : -1;        \\n\\n        for(int i = 0; i < n - 1; i++) {\\n            line += words[low + i] + \" \" + string(space, \\' \\');\\n            slots--;\\n            extraSpaces -= space;\\n            \\n            // Greedily add an extra space after the current word if the remaining\\n            // spaces are still in excess.\\n            if(extraSpaces > slots * space) {\\n                line += \" \";\\n                extraSpaces--;\\n            }\\n        }\\n        line += words[high] + string(extraSpaces, \\' \\');\\n        return line;\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        for(int i = 0; i < words.size(); i++) {\\n            int currWidth = 0;\\n            int j = i;\\n            while(j < words.size() && (currWidth + words[j].size()) <= maxWidth)\\n                currWidth += words[j++].size() + 1;\\n            j < words.size()\\n                ? res.push_back(getJustifiedLine(i, j - 1, words, maxWidth - currWidth + 1))\\n                : res.push_back(getLeftAlignedLine(i, j - 1, words, maxWidth));\\n            i = j - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    /** \\n     * Returns string containing left-aligned line formed using words[low..high]\\n     * @param maxWidth: Total length of the line\\n     */\\n    string getLeftAlignedLine(int low, int high, vector<string>& words, int maxWidth) {\\n        string line;\\n        for(int i = low; i <= high; i++)\\n            line += words[i] + \" \";\\n        line.pop_back();\\n        line += string(maxWidth - line.size(), \\' \\');\\n        return line;\\n    }\\n    \\n    /**\\n     * Returns string containing justified line formed using words[low..high]\\n     * @param extraSpace: Number of extra spaces that need to be spread evenly between\\n     *      the words. This count doesn\\'t include the single spaces that already need\\n     *      to be inserted between each pair of words.\\n     */\\n    string getJustifiedLine(int low, int high, vector<string>& words, int extraSpaces) {\\n        string line;\\n        int n = high - low + 1, slots = n - 1;\\n        \\n        // The number of extra spaces that must be inserted between every pair of words.\\n        // Some pairs might have (space+1) spaces between them if the total is in excess.\\n        int space = slots > 0 ? extraSpaces / slots : -1;        \\n\\n        for(int i = 0; i < n - 1; i++) {\\n            line += words[low + i] + \" \" + string(space, \\' \\');\\n            slots--;\\n            extraSpaces -= space;\\n            \\n            // Greedily add an extra space after the current word if the remaining\\n            // spaces are still in excess.\\n            if(extraSpaces > slots * space) {\\n                line += \" \";\\n                extraSpaces--;\\n            }\\n        }\\n        line += words[high] + string(extraSpaces, \\' \\');\\n        return line;\\n    }\\n\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        for(int i = 0; i < words.size(); i++) {\\n            int currWidth = 0;\\n            int j = i;\\n            while(j < words.size() && (currWidth + words[j].size()) <= maxWidth)\\n                currWidth += words[j++].size() + 1;\\n            j < words.size()\\n                ? res.push_back(getJustifiedLine(i, j - 1, words, maxWidth - currWidth + 1))\\n                : res.push_back(getLeftAlignedLine(i, j - 1, words, maxWidth));\\n            i = j - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633915,
                "title": "fast-and-thoroughly-explained-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        const int totalWords = words.size()-1;\\n        for (int begin=0, moreWords=0; begin<=totalWords; begin=moreWords) {\\n            string currentBlock(maxWidth, \\' \\');\\n            /* In problem statement, it is specified that each word is guaranteed to be\\n             * grether than 0 and not exceed maxWidth, so I can safely add first word. */\\n            currentBlock.replace(0, words[begin].size(), words[begin]);\\n            /* Now current block of text is ready with first word and remainig spaces,\\n             * I just need to calculate how many more words I can fit in this block. */\\n            int remainingSpace = maxWidth - words[begin].size();\\n            for (moreWords=begin+1; moreWords <=totalWords && words[moreWords].size() < remainingSpace; moreWords++) {\\n                /* First word in current block is already added before this for loop.\\n                 * Additional word(s) can be added in current justification block. As this\\n                 * is additional word, at least one space is needed in calculation\\n                 * for remaining space. Above \\'<\\' condition make sure that we have space for\\n                 * one additional space */\\n                remainingSpace -= words[moreWords].size()+1;\\n            }\\n            /* Word joints are total separating gap between words, for which we need to do\\n             * space management */\\n            int wordJoints = moreWords - begin -1;\\n            if (wordJoints) {\\n                /*Ok so we have more than one word in this justification block*/\\n                int evenlyDistributedSpace = 1; /*One space is already provisioned in above loop */\\n                int unEvenSpace = 0;\\n                if (moreWords <= totalWords) {\\n                /* Control is here means current justification block is not the last\\n                 * block, so we need to do some mathematics on remaining space and evenly\\n                 * distribute it between the words (word joints). Remember for last block\\n                 * this is not needed as it is left aligned and additional words are only\\n                 * placed one white space apart */\\n                    evenlyDistributedSpace += remainingSpace / wordJoints;\\n                    unEvenSpace = remainingSpace % wordJoints;\\n                }\\n                for (int i=begin+1, index=words[begin].size(); i < moreWords; i++) {\\n                    index += evenlyDistributedSpace + (unEvenSpace-- > 0);\\n                    currentBlock.replace(index, words[i].size(), words[i]);\\n                    index += words[i].size();\\n                }\\n            }\\n            result.push_back(currentBlock);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529356,
                "title": "python-3-o-n",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        count, cur_words = 0, []\\n        res = []\\n        for word in words:\\n            if count+ len(word) + len(cur_words) > maxWidth:\\n                spaces = maxWidth - count\\n                for i in range(spaces):\\n                    cur_words[i % (len(cur_words)-1 if len(cur_words)>1 else 1)] += \\' \\'\\n                res.append(\"\".join(cur_words))\\n                count, cur_words = 0, []\\n            count+=len(word)\\n            cur_words.append(word)\\n        \\n\\t\\t# last row\\n        spaces = maxWidth - count - (len(cur_words)-1)\\n        res.append(\" \".join(cur_words)+\" \"*spaces)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        count, cur_words = 0, []\\n        res = []\\n        for word in words:\\n            if count+ len(word) + len(cur_words) > maxWidth:\\n                spaces = maxWidth - count\\n                for i in range(spaces):\\n                    cur_words[i % (len(cur_words)-1 if len(cur_words)>1 else 1)] += \\' \\'\\n                res.append(\"\".join(cur_words))\\n                count, cur_words = 0, []\\n            count+=len(word)\\n            cur_words.append(word)\\n        \\n\\t\\t# last row\\n        spaces = maxWidth - count - (len(cur_words)-1)\\n        res.append(\" \".join(cur_words)+\" \"*spaces)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117010,
                "title": "clear-and-readable-c-solution-beats-100",
                "content": "I'm not sure if they upgraded the C# compiler, but this solution appears to be 100ms faster than previous solutions. Additionally, it is intuitive to read.\n\n```\npublic class Line {\n    private readonly int TotalChars;\n    private int CharsLeft;\n    public List<string> Words;\n    \n    public int Spaces {\n        get {\n            int allWordsLen = Words.Aggregate(0, (prev, next) => prev + next.Length);\n            return TotalChars - allWordsLen - (Words.Count - 1);\n        }\n    }\n    public Line(int avail) {\n        TotalChars = avail;\n        CharsLeft = avail;\n        \n        Words = new List<string>();\n    }\n    public bool Consume(string word) {\n        if (word.Length <= CharsLeft) {\n            CharsLeft -= word.Length + 1; //+1 for a space\n            Words.Add(word);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public override string ToString() {        \n        return Words.Aggregate((prev, next) => string.Format(\"{0} {1}\", prev, next));  \n    }\n}\n\npublic class Solution {\n    \n    public static string Justify(Line line) {\n        //We want to distribute the available spaces into a few different buckets.\n        //To be correct, the last bucket must always contain zero spaces.\n        //This is why I'm % by buckets.Length - 1 in the loop\n        \n        int[] buckets = new int[line.Words.Count];\n        int totalToDistribute = line.Spaces;\n        int index = 0;\n        \n        int totalBuckets = Math.Max(buckets.Length - 1, 1);\n        while (totalToDistribute > 0) {\n            buckets[index]++;\n            totalToDistribute--;\n            index = (index + 1) % totalBuckets;\n        }\n        \n        var withPadding = line.Words.Zip(buckets, (word, bucket) => {\n            return string.Concat(word, new String(' ', bucket));\n        });\n        \n        return withPadding.Aggregate((first, second) => string.Format(\"{0} {1}\", first, second));\n    }\n    \n    public static string LeftJustify(Line line) {\n        return string.Concat(line.ToString(), new String(' ', line.Spaces));\n    }\n    \n    public IList<string> FullJustify(string[] wordsArray, int maxWidth) {\n        Queue<string> words = new Queue<string>(wordsArray);\n        List<Line> lines = new List<Line>();\n        \n        while (words.Count > 0) {\n            Line line = new Line(maxWidth);\n            while (words.Count > 0 && line.Consume(words.Peek())) {\n                words.Dequeue();\n            }\n            lines.Add(line);\n        }\n        \n        //We justify all the lines until the very last\n        List<string> result = new List<string>();\n        for (int i = 0; i < lines.Count - 1; i++) {\n            result.Add(Justify(lines[i]));\n        }\n        //And then do a special left justify on the last.\n        result.Add(LeftJustify(lines.Last()));\n        return result;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\npublic class Line {\n    private readonly int TotalChars;\n    private int CharsLeft;\n    public List<string> Words;\n    \n    public int Spaces {\n        get {\n            int allWordsLen = Words.Aggregate(0, (prev, next) => prev + next.Length);\n            return TotalChars - allWordsLen - (Words.Count - 1);\n        }\n    }\n    public Line(int avail) {\n        TotalChars = avail;\n        CharsLeft = avail;\n        \n        Words = new List<string>();\n    }\n    public bool Consume(string word) {\n        if (word.Length <= CharsLeft) {\n            CharsLeft -= word.Length + 1; //+1 for a space\n            Words.Add(word);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    public override string ToString() {        \n        return Words.Aggregate((prev, next) => string.Format(\"{0} {1}\", prev, next));  \n    }\n}\n\npublic class Solution {\n    \n    public static string Justify(Line line) {\n        //We want to distribute the available spaces into a few different buckets.\n        //To be correct, the last bucket must always contain zero spaces.\n        //This is why I'm % by buckets.Length - 1 in the loop\n        \n        int[] buckets = new int[line.Words.Count];\n        int totalToDistribute = line.Spaces;\n        int index = 0;\n        \n        int totalBuckets = Math.Max(buckets.Length - 1, 1);\n        while (totalToDistribute > 0) {\n            buckets[index]++;\n            totalToDistribute--;\n            index = (index + 1) % totalBuckets;\n        }\n        \n        var withPadding = line.Words.Zip(buckets, (word, bucket) => {\n            return string.Concat(word, new String(' ', bucket));\n        });\n        \n        return withPadding.Aggregate((first, second) => string.Format(\"{0} {1}\", first, second));\n    }\n    \n    public static string LeftJustify(Line line) {\n        return string.Concat(line.ToString(), new String(' ', line.Spaces));\n    }\n    \n    public IList<string> FullJustify(string[] wordsArray, int maxWidth) {\n        Queue<string> words = new Queue<string>(wordsArray);\n        List<Line> lines = new List<Line>();\n        \n        while (words.Count > 0) {\n            Line line = new Line(maxWidth);\n            while (words.Count > 0 && line.Consume(words.Peek())) {\n                words.Dequeue();\n            }\n            lines.Add(line);\n        }\n        \n        //We justify all the lines until the very last\n        List<string> result = new List<string>();\n        for (int i = 0; i < lines.Count - 1; i++) {\n            result.Add(Justify(lines[i]));\n        }\n        //And then do a special left justify on the last.\n        result.Add(LeftJustify(lines.Last()));\n        return result;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 24974,
                "title": "concise-solution-in-ruby",
                "content": "fit as many words into one line as possible, then join the words with proper number of spaces.\\n\\n    def full_justify(words, max_width)\\n      v, line = [], []\\n      words.each do |word|\\n        if (line+[word]).join(' ').size > max_width\\n          v.push(join_line(line, max_width))\\n          line = []\\n        end\\n        line.push(word)\\n      end\\n      v.push(join_line(line, max_width, true))\\n    end\\n    \\n    def join_line(line, max_width, last = false)\\n      return line.join(' ') + ' '*(max_width-line.join(' ').size) if (line.size == 1 or last == true)\\n      space, extra = (max_width-line.join.size).divmod(line.size-1)\\n      line[0..extra].join(' '*(space+1)) + ' '*space + line[extra+1..-1].join(' '*space)\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "fit as many words into one line as possible, then join the words with proper number of spaces.\\n\\n    def full_justify(words, max_width)\\n      v, line = [], []\\n      words.each do |word|\\n        if (line+[word]).join(' ').size > max_width\\n          v.push(join_line(line, max_width))\\n          line = []\\n        end\\n        line.push(word)\\n      end\\n      v.push(join_line(line, max_width, true))\\n    end\\n    \\n    def join_line(line, max_width, last = false)\\n      return line.join(' ') + ' '*(max_width-line.join(' ').size) if (line.size == 1 or last == true)\\n      space, extra = (max_width-line.join.size).divmod(line.size-1)\\n      line[0..extra].join(' '*(space+1)) + ' '*space + line[extra+1..-1].join(' '*space)\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 1324217,
                "title": "python-version-of-the-nicely-broken-java-code",
                "content": "Python version of the amazing Java code https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n```\\n\\'\\'\\'\\nAlgorithm: https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n1. while there are words:\\n2.     collect words that will go in the same line\\n3.     fix spaces in these words\\n\\'\\'\\'\\nclass Solution:\\n    def findSameLineWords(self, start, maxWidth, words):\\n        chars = 0\\n        \\'\\'\\'\\n        maxWidth + 1 cause the last word of every sentence doesn\\'t have a space, so in case the last word of the sentence fits exactly we need to accomodate the fact that it has no trailing space\\n        \"enough to explain to\" maxWidth=20\\n        \\'\\'\\' \\n        while start < len(words) and chars + len(words[start]) + 1 <= maxWidth + 1:\\n            chars += len(words[start]) + 1\\n            start += 1\\n        return start - 1\\n    \\n    \\n    def fixSpaces(self, start, end, words, maxWidth):\\n        generate_spaces = lambda x: \\' \\' * x\\n        \\n        answer = []\\n        \\n        # if only 1 word: pad spaces at the end\\n        if end == start:\\n            answer.append(words[start])\\n            answer.append(generate_spaces(maxWidth - len(words[start])))\\n            return \\'\\'.join(answer)\\n        \\n        # special care is required for the last line as it has no spaces between words \\n        is_last_line = (end == len(words) - 1)\\n        total_chars = sum(len(words[i]) for i in range(start, end + 1))\\n        total_spaces = maxWidth - total_chars \\n        even_spaces = total_spaces // (end - start) if is_last_line is False else 1\\n        remainder_spaces = total_spaces - even_spaces * (end - start) if is_last_line is False else 0\\n        \\n        # print(words[start : end + 1], \\'total_chars:\\', total_chars, \\'total_spaces:\\', total_spaces, \\'even_spaces:\\', even_spaces, \\'remainder_spaces:\\', remainder_spaces)\\n        \\n        for idx in range(start, end + 1):\\n            answer.append(words[idx])\\n            answer.append(generate_spaces(even_spaces))\\n            if remainder_spaces > 0:\\n                answer.append(generate_spaces(1))\\n                remainder_spaces -= 1\\n        sentence = \\'\\'.join(answer[: -1])     # remove the trailing spaces\\n        if is_last_line is False:            # if not the last sentence return without the trailing spaces\\n            return sentence\\n        else:                                # add the trailing spaces\\n            return sentence + generate_spaces(maxWidth - len(sentence))\\n                \\n        \\n        \\n    def fullJustify(self, words, maxWidth):\\n        start = 0\\n        answer = []\\n        while start < len(words):\\n            end = self.findSameLineWords(start, maxWidth, words)\\n            answer.append(self.fixSpaces(start, end, words, maxWidth))\\n            # print(start, end)\\n            start = end + 1\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nAlgorithm: https://leetcode.com/problems/text-justification/discuss/24902/Java-easy-to-understand-broken-into-several-functions\\n1. while there are words:\\n2.     collect words that will go in the same line\\n3.     fix spaces in these words\\n\\'\\'\\'\\nclass Solution:\\n    def findSameLineWords(self, start, maxWidth, words):\\n        chars = 0\\n        \\'\\'\\'\\n        maxWidth + 1 cause the last word of every sentence doesn\\'t have a space, so in case the last word of the sentence fits exactly we need to accomodate the fact that it has no trailing space\\n        \"enough to explain to\" maxWidth=20\\n        \\'\\'\\' \\n        while start < len(words) and chars + len(words[start]) + 1 <= maxWidth + 1:\\n            chars += len(words[start]) + 1\\n            start += 1\\n        return start - 1\\n    \\n    \\n    def fixSpaces(self, start, end, words, maxWidth):\\n        generate_spaces = lambda x: \\' \\' * x\\n        \\n        answer = []\\n        \\n        # if only 1 word: pad spaces at the end\\n        if end == start:\\n            answer.append(words[start])\\n            answer.append(generate_spaces(maxWidth - len(words[start])))\\n            return \\'\\'.join(answer)\\n        \\n        # special care is required for the last line as it has no spaces between words \\n        is_last_line = (end == len(words) - 1)\\n        total_chars = sum(len(words[i]) for i in range(start, end + 1))\\n        total_spaces = maxWidth - total_chars \\n        even_spaces = total_spaces // (end - start) if is_last_line is False else 1\\n        remainder_spaces = total_spaces - even_spaces * (end - start) if is_last_line is False else 0\\n        \\n        # print(words[start : end + 1], \\'total_chars:\\', total_chars, \\'total_spaces:\\', total_spaces, \\'even_spaces:\\', even_spaces, \\'remainder_spaces:\\', remainder_spaces)\\n        \\n        for idx in range(start, end + 1):\\n            answer.append(words[idx])\\n            answer.append(generate_spaces(even_spaces))\\n            if remainder_spaces > 0:\\n                answer.append(generate_spaces(1))\\n                remainder_spaces -= 1\\n        sentence = \\'\\'.join(answer[: -1])     # remove the trailing spaces\\n        if is_last_line is False:            # if not the last sentence return without the trailing spaces\\n            return sentence\\n        else:                                # add the trailing spaces\\n            return sentence + generate_spaces(maxWidth - len(sentence))\\n                \\n        \\n        \\n    def fullJustify(self, words, maxWidth):\\n        start = 0\\n        answer = []\\n        while start < len(words):\\n            end = self.findSameLineWords(start, maxWidth, words)\\n            answer.append(self.fixSpaces(start, end, words, maxWidth))\\n            # print(start, end)\\n            start = end + 1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129791,
                "title": "java-solution-with-explanation-0-ms",
                "content": "The idea was to keep adding words to a buffer (an ArrayList) while the width is under the maxWidth and build a new line if it overflows.\\nIn particular, a width is the sum of following two values ```A``` and ```B```:\\n\\n- ```A``` Sum of number of characters of words in the buffer\\n- ```B``` Minimal number of necessary spaces for building a line from the words in the buffer\\n\\n```B``` can be simply calculated from the size of the buffer.\\nI.e. if we want to build a line from N words then we need at least N-1 spaces in total to separate each word.\\n\\nWhen we build a new line from the words in the buffer, we will need ```maxWidth - A```  spaces in total.\\nDepending on if it is the last line or not, we need to distribute these spaces accordingly.\\n\\nTime complexity: O(N): N is number of words\\nSpace complexity: O(N): In worst case, I\\'ll store all words to the buffer\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> answer = new ArrayList<>();\\n        \\n        List<String> buffer = new ArrayList<>();\\n        \\n        // Sum of characters of words in the buffer\\n        int sumChars = 0;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            // Build a new line when it exceeds the maxWidth if you append the current word to the buffer too.\\n            // buffer.size() represents the minimal number of spaces we need to build a line.\\n            if(word.length() + sumChars + buffer.size() > maxWidth) {\\n                // maxWidth - sumChars is the total number of spaces we need to build this line\\n                String line = buildLine(buffer, maxWidth - sumChars, false);\\n                answer.add(line);\\n                sumChars = 0;\\n                buffer.clear();\\n            }\\n            \\n            sumChars += word.length();\\n            buffer.add(word);\\n            \\n            // Build the last line if it is the last word\\n            if(i == words.length - 1) {\\n                String line = buildLine(buffer, maxWidth - sumChars, true);\\n                answer.add(line);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // Helper method that builds a line from a list of words and number of spaces to be distributed.\\n    private String buildLine(List<String> words, int spaces, boolean isLastLine) {\\n        StringBuilder builder = new StringBuilder();\\n        \\n        // Last line: separate the words with single spaces\\n        if(isLastLine) {\\n            for(Iterator<String> it = words.iterator(); it.hasNext();) {\\n                builder.append(it.next());\\n                \\n                if(it.hasNext()) {\\n                    builder.append(\" \");\\n                    spaces--;\\n                }\\n            }\\n        // Otherwise, calculate necessary amount of spaces to be add in each iteration\\n        } else {\\n            for(int i = 0; i < words.size(); i++) {\\n                builder.append(words.get(i));\\n                \\n                if(i < words.size() -1) {\\n                    // If we still have N words in the list then we need to distribute the remaining spaces to N-1 slots.\\n                    int divisor = (words.size() - i) - 1;\\n                    int spacesForThisSlot = (spaces + divisor - 1) / divisor; // round up\\n                    \\n                    for(int j = 0; j < spacesForThisSlot; j++) {\\n                        builder.append(\" \");\\n                        spaces--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Fill the rest of the line with spaces when there are leftovers\\n        // This happens if it is the last line or the words list had only one element\\n        for(int i = 0; i < spaces; i++) {\\n            builder.append(\" \");\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```A```\n```B```\n```A```\n```B```\n```B```\n```maxWidth - A```\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> answer = new ArrayList<>();\\n        \\n        List<String> buffer = new ArrayList<>();\\n        \\n        // Sum of characters of words in the buffer\\n        int sumChars = 0;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            // Build a new line when it exceeds the maxWidth if you append the current word to the buffer too.\\n            // buffer.size() represents the minimal number of spaces we need to build a line.\\n            if(word.length() + sumChars + buffer.size() > maxWidth) {\\n                // maxWidth - sumChars is the total number of spaces we need to build this line\\n                String line = buildLine(buffer, maxWidth - sumChars, false);\\n                answer.add(line);\\n                sumChars = 0;\\n                buffer.clear();\\n            }\\n            \\n            sumChars += word.length();\\n            buffer.add(word);\\n            \\n            // Build the last line if it is the last word\\n            if(i == words.length - 1) {\\n                String line = buildLine(buffer, maxWidth - sumChars, true);\\n                answer.add(line);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    // Helper method that builds a line from a list of words and number of spaces to be distributed.\\n    private String buildLine(List<String> words, int spaces, boolean isLastLine) {\\n        StringBuilder builder = new StringBuilder();\\n        \\n        // Last line: separate the words with single spaces\\n        if(isLastLine) {\\n            for(Iterator<String> it = words.iterator(); it.hasNext();) {\\n                builder.append(it.next());\\n                \\n                if(it.hasNext()) {\\n                    builder.append(\" \");\\n                    spaces--;\\n                }\\n            }\\n        // Otherwise, calculate necessary amount of spaces to be add in each iteration\\n        } else {\\n            for(int i = 0; i < words.size(); i++) {\\n                builder.append(words.get(i));\\n                \\n                if(i < words.size() -1) {\\n                    // If we still have N words in the list then we need to distribute the remaining spaces to N-1 slots.\\n                    int divisor = (words.size() - i) - 1;\\n                    int spacesForThisSlot = (spaces + divisor - 1) / divisor; // round up\\n                    \\n                    for(int j = 0; j < spacesForThisSlot; j++) {\\n                        builder.append(\" \");\\n                        spaces--;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Fill the rest of the line with spaces when there are leftovers\\n        // This happens if it is the last line or the words list had only one element\\n        for(int i = 0; i < spaces; i++) {\\n            builder.append(\" \");\\n        }\\n        \\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908663,
                "title": "short-java",
                "content": "The idea is from [@ashish-sjc](https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines./303690). \\n1. Use List<StringBuilder> to store a line so we can add space after each word without creating a new string.\\n2. Iterate through each word, add to the current line, if current line is full, format the current line and add word to next line.\\n3. In #2, a line is fully justified when the next word does not fit the line. In other words, the current line won\\'t be fully justified until we process the next word. Since the last line does not have the next word, it won\\'t be fully justified. This fits the requirement perfectly because the last line requires a different format, left justification.\\n```\\n\\t public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res=new ArrayList<>();\\n        List<StringBuilder> line=new ArrayList<>();\\n        int totLetters=0;\\n        for(String word:words) {\\n            int len=word.length(), size=line.size();\\n            if(totLetters+size+len>maxWidth) {\\n                int space = maxWidth - totLetters;\\n                if(size==1) {\\n                    res.add(line.get(0).toString()+\" \".repeat(space));\\n                } else {\\n                    int spc=space/(size-1), r=space%(size-1);\\n                    for(int i=0;i<r;i++)\\n                        line.get(i).append(\" \");\\n                    res.add(String.join(\" \".repeat(spc),line));\\n                }\\n                totLetters=0;\\n                line.clear();\\n            }\\n            totLetters+=len;\\n            line.add(new StringBuilder(word));\\n        }\\n        String last=String.join(\" \",line);\\n        res.add(String.format(\"%-\"+maxWidth+\"s\",last));\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\t public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res=new ArrayList<>();\\n        List<StringBuilder> line=new ArrayList<>();\\n        int totLetters=0;\\n        for(String word:words) {\\n            int len=word.length(), size=line.size();\\n            if(totLetters+size+len>maxWidth) {\\n                int space = maxWidth - totLetters;\\n                if(size==1) {\\n                    res.add(line.get(0).toString()+\" \".repeat(space));\\n                } else {\\n                    int spc=space/(size-1), r=space%(size-1);\\n                    for(int i=0;i<r;i++)\\n                        line.get(i).append(\" \");\\n                    res.add(String.join(\" \".repeat(spc),line));\\n                }\\n                totLetters=0;\\n                line.clear();\\n            }\\n            totLetters+=len;\\n            line.add(new StringBuilder(word));\\n        }\\n        String last=String.join(\" \",line);\\n        res.add(String.format(\"%-\"+maxWidth+\"s\",last));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672626,
                "title": "python3-a-concise-solution",
                "content": "This implementation is based on the amazing solution given by @sherlock321 in this [thread](https://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines.). I\\'ve made a few changes to reflect my coding style. Credit goes to the original author. \\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans = []\\n        line, width = [], 0\\n        \\n        for word in words: \\n            if width + len(line) + len(word) > maxWidth: \\n                n, k = divmod(maxWidth - width, max(1, len(line)-1))\\n                for i in range(max(1, len(line)-1)): \\n                    line[i] += \" \" * (n + (i < k))\\n                ans.append(\"\".join(line))\\n                line, width = [], 0\\n            line.append(word)\\n            width += len(word)\\n            \\n        ans.append(\" \".join(line).ljust(maxWidth))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        ans = []\\n        line, width = [], 0\\n        \\n        for word in words: \\n            if width + len(line) + len(word) > maxWidth: \\n                n, k = divmod(maxWidth - width, max(1, len(line)-1))\\n                for i in range(max(1, len(line)-1)): \\n                    line[i] += \" \" * (n + (i < k))\\n                ans.append(\"\".join(line))\\n                line, width = [], 0\\n            line.append(word)\\n            width += len(word)\\n            \\n        ans.append(\" \".join(line).ljust(maxWidth))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 519796,
                "title": "go-0ms-solution-easy-to-understand",
                "content": "```go\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tjustify := []string{}\\n\\tcurrent, curLength := []string{}, 0\\n\\tfor i, w := range words {\\n\\t\\tif curLength + len(current) + len(w) > maxWidth {\\n\\t\\t\\tif len(current) == 1 {\\n\\t\\t\\t\\t// only one word, all spaces are to the right of the word\\n\\t\\t\\t\\tcurLine := current[0] + strings.Repeat(\" \", maxWidth-len(current[0]))\\n\\t\\t\\t\\tjustify = append(justify, curLine)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdiff := maxWidth - curLength\\n\\t\\t\\t\\tspaces := diff / (len(current)-1)\\n\\t\\t\\t\\tmore := diff % (len(current)-1)\\n\\t\\t\\t\\tcurLine := bytes.Buffer{}\\n\\t\\t\\t\\tfor ci, cw := range current {\\n\\t\\t\\t\\t\\tcurLine.WriteString(cw)\\n\\t\\t\\t\\t\\tif ci != len(current) - 1 {\\n\\t\\t\\t\\t\\t\\tmoreBlanks := 0\\n\\t\\t\\t\\t\\t\\tif more > 0 {\\n\\t\\t\\t\\t\\t\\t\\tmoreBlanks = 1\\n\\t\\t\\t\\t\\t\\t\\tmore--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurLine.WriteString(strings.Repeat(\" \", spaces+ moreBlanks))\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tjustify = append(justify, curLine.String())\\n\\t\\t\\t}\\n\\t\\t\\tcurrent, curLength = []string{}, 0\\n\\t\\t}\\n\\n\\t\\tcurLength += len(w)\\n\\t\\tcurrent = append(current, w)\\n\\n\\t\\t// last line, left justified and no extra space is inserted between words\\n\\t\\tif i == len(words) - 1 {\\n\\t\\t\\tlastLine := strings.Join(current, \" \")\\n\\t\\t\\tlastLine = lastLine + strings.Repeat(\" \", maxWidth-len(lastLine))\\n\\t\\t\\tjustify = append(justify, lastLine)\\n\\t\\t}\\n\\t}\\n\\treturn justify\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tjustify := []string{}\\n\\tcurrent, curLength := []string{}, 0\\n\\tfor i, w := range words {\\n\\t\\tif curLength + len(current) + len(w) > maxWidth {\\n\\t\\t\\tif len(current) == 1 {\\n\\t\\t\\t\\t// only one word, all spaces are to the right of the word\\n\\t\\t\\t\\tcurLine := current[0] + strings.Repeat(\" \", maxWidth-len(current[0]))\\n\\t\\t\\t\\tjustify = append(justify, curLine)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdiff := maxWidth - curLength\\n\\t\\t\\t\\tspaces := diff / (len(current)-1)\\n\\t\\t\\t\\tmore := diff % (len(current)-1)\\n\\t\\t\\t\\tcurLine := bytes.Buffer{}\\n\\t\\t\\t\\tfor ci, cw := range current {\\n\\t\\t\\t\\t\\tcurLine.WriteString(cw)\\n\\t\\t\\t\\t\\tif ci != len(current) - 1 {\\n\\t\\t\\t\\t\\t\\tmoreBlanks := 0\\n\\t\\t\\t\\t\\t\\tif more > 0 {\\n\\t\\t\\t\\t\\t\\t\\tmoreBlanks = 1\\n\\t\\t\\t\\t\\t\\t\\tmore--\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurLine.WriteString(strings.Repeat(\" \", spaces+ moreBlanks))\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tjustify = append(justify, curLine.String())\\n\\t\\t\\t}\\n\\t\\t\\tcurrent, curLength = []string{}, 0\\n\\t\\t}\\n\\n\\t\\tcurLength += len(w)\\n\\t\\tcurrent = append(current, w)\\n\\n\\t\\t// last line, left justified and no extra space is inserted between words\\n\\t\\tif i == len(words) - 1 {\\n\\t\\t\\tlastLine := strings.Join(current, \" \")\\n\\t\\t\\tlastLine = lastLine + strings.Repeat(\" \", maxWidth-len(lastLine))\\n\\t\\t\\tjustify = append(justify, lastLine)\\n\\t\\t}\\n\\t}\\n\\treturn justify\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156704,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        curr_line = []\\n        curr_line_width = 0\\n        lines = []\\n        \\n        for word in words:\\n            if len(word) + curr_line_width + len(curr_line) > maxWidth:\\n                # Need to add justified line\\n                nspaces = len(curr_line) - 1 if len(curr_line) - 1 else 1\\n                for i in range(maxWidth - curr_line_width):\\n                    curr_line[i % nspaces] += \" \"\\n                lines.append(\"\".join(curr_line))\\n                curr_line = []\\n                curr_line_width = 0\\n            curr_line.append(word)\\n            curr_line_width += len(word)\\n        \\n        last_line = \" \".join(curr_line)\\n        last_line = last_line.strip()\\n        last_line = last_line + \" \"*(maxWidth - len(last_line))\\n        lines.append(last_line)\\n        return lines\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        curr_line = []\\n        curr_line_width = 0\\n        lines = []\\n        \\n        for word in words:\\n            if len(word) + curr_line_width + len(curr_line) > maxWidth:\\n                # Need to add justified line\\n                nspaces = len(curr_line) - 1 if len(curr_line) - 1 else 1\\n                for i in range(maxWidth - curr_line_width):\\n                    curr_line[i % nspaces] += \" \"\\n                lines.append(\"\".join(curr_line))\\n                curr_line = []\\n                curr_line_width = 0\\n            curr_line.append(word)\\n            curr_line_width += len(word)\\n        \\n        last_line = \" \".join(curr_line)\\n        last_line = last_line.strip()\\n        last_line = last_line + \" \"*(maxWidth - len(last_line))\\n        lines.append(last_line)\\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955974,
                "title": "c-beats-100-binary-search-detailed-explaination",
                "content": "# Intuition\\nUpon examining the problem, it becomes clear that the task involves determining the number of words that can fit on each line while considering the need for padding. The solution is achieved by first calculating the required padding for even distribution, with any extra padding allocated to the left side of the words.\\n\\nTo illustrate, the arrangement should resemble:\\n[**WORD1**]--*PADDING*--[**WORD2**]--*PADDING*--[**WORD3**]\\n\\nThe goal is to ensure that this entire construction spans a length equal to \"maxWidth\". The process for calculating word counts and arranging padding is elaborated in the forthcoming \"Approach\" section.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach to solving this problem can be divided into several steps:\\n\\n**Word Length Prefix Sum:** Construct an array to hold the lengths of individual words (or you can do the prefix sum directly), and another array for their prefix sum. The prefix sum array, being non-decreasing, allows efficient binary search. This binary search aids in determining the number of words that can fit within a given line length.\\n\\n**Predicate Function** - Feasibility Check: Define a predicate function called isPossible, which checks if a specific word count can fit within a line. This function relies on the prefix sum array and the given conditions to decide if a certain word count is feasible for the line length.\\n\\n**Binary Search**: Utilize binary search to find the optimal word count that can be accommodated in a line, while meeting the length constraint. The binary search narrows down the word count to a feasible range.\\n\\n**Padding Calculation:** Calculate the padding required for distribution. Determine the minimum length of padding between words and the remaining padding that needs to be allocated. Extra padding, if applicable, is distributed starting from the left.\\n\\n**Line Formation:** Create a string named curr with the length of maxWidth, initialized with spaces. Insert words into the curr string, followed by the calculated padding. This process is continued until the desired line length is achieved.\\n\\n**Updating Pointers:** Update the alreadyTaken pointer to indicate the words that have been included in the current line.\\n\\n**Iterative Process:** Iterate through the words while constructing lines until all words are processed.\\n\\nThe provided code implementation employs this approach, integrating binary search, padding distribution, and line formation to produce justified lines of text.\\n\\nThis approach ensures that each line adheres to the \"maxWidth\" criterion while optimizing word distribution and padding arrangement. The binary search and efficient padding calculations contribute to a time complexity of O(N * (maxWidth + log N)), where N represents the number of words in the input. The space complexity is O(N) due to the storage of the word length prefix sum array.\\n\\nCheck the Comments in \"Source Code\".\\nIf you have any question, put them in the comment section.\\nPlease upvote. If you have liked it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N * (maxWidth + log N))\\n- N : words.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int N;\\n    int maxWidth;\\n    int alreadyTaken;\\n    vector<int> preFixLength;\\n    bool isPossible(int count) {                    // T.C: O(1)\\n        int spaceNeeded = count - alreadyTaken - 1;\\n        int totalWordsLen = preFixLength[count] - preFixLength[alreadyTaken];\\n        return (totalWordsLen + spaceNeeded) <= maxWidth;\\n    }\\n    int fitWords(int fromIndex, vector<string> &words, vector<string> &ans) {\\n        // Binary Search\\n        int l = alreadyTaken, r = N + 1;\\n        // Invariance\\n        // isPossible(l) is always true\\n        // isPossible(r) is always false\\n        while (l + 1 < r) {                         // T.C: O(log n)\\n            int m = l + (r - l) / 2;\\n            if (isPossible(m))\\n                l = m;\\n            else\\n                r = m;\\n        }\\n        // We can place (alreadyTaken, l] in our curr\\n        int wordCount = l - alreadyTaken;\\n        int totalWordsLen = preFixLength[l] - preFixLength[alreadyTaken];\\n        int spaceNeeded = maxWidth - totalWordsLen;\\n        int gapNeeded = 1, extraGap = 0;\\n        if (wordCount > 1 && l != N) {\\n            gapNeeded = spaceNeeded / (wordCount - 1);\\n            extraGap = spaceNeeded % (wordCount - 1);\\n        } \\n        int k = 0;\\n        string curr(maxWidth, \\' \\');                 // T.C: O(maxWidth)\\n        for (int i = alreadyTaken; i < l; i++) {    // T.C: O(maxWidth)\\n            for (int j = 0; j < words[i].size(); j++) {\\n                curr[k++] = words[i][j]; \\n            }\\n            // Put Spaces\\n            k += gapNeeded;\\n            if (extraGap) {\\n                k++;\\n                extraGap--;\\n            }\\n        }\\n        // Update alreadyTaken\\n        alreadyTaken = l;\\n        ans.push_back(curr);\\n        return l;\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int _maxWidth) {\\n        /* Approach:\\n            1. Binary Search -- T.C: O(n * (maxWidth + log n)), S.C: O(n)\\n        */\\n\\n        // Approach 1\\n        alreadyTaken = 0;\\n        N = words.size();\\n        maxWidth = _maxWidth;\\n        preFixLength.assign(N + 1, 0);\\n        // Calculate Prefix Length\\n        for (int i = 1; i <= N; i++) {\\n            preFixLength[i] = preFixLength[i - 1] + words[i - 1].size();\\n        }\\n\\n        vector<string> ans;\\n\\n        int i = 0;\\n        while (i < N) {     // T.C: O(n * (maxWidth + log n))\\n            i = fitWords(i, words, ans);\\n        }\\n        /* Reasoning behind the time complexity:\\n            In the worst case, we are given such words, that our output contains only one word in each line\\n            Complexity of our fitWords() function is O(maxWidth + log (Search Range))\\n            In this case:\\n                i is incremented by 1 and serach space reduces by 1\\n                so the while loop will run \\'N\\' times to call fitWords() function\\n                Time Complexity:\\n                    [maxWidth + log (N)] + [maxWidth + log (N - 1)] + . . . . . [maxWidth + log (2)]\\n                    Which is = N * (maxWidth + log N)\\n        */\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N;\\n    int maxWidth;\\n    int alreadyTaken;\\n    vector<int> preFixLength;\\n    bool isPossible(int count) {                    // T.C: O(1)\\n        int spaceNeeded = count - alreadyTaken - 1;\\n        int totalWordsLen = preFixLength[count] - preFixLength[alreadyTaken];\\n        return (totalWordsLen + spaceNeeded) <= maxWidth;\\n    }\\n    int fitWords(int fromIndex, vector<string> &words, vector<string> &ans) {\\n        // Binary Search\\n        int l = alreadyTaken, r = N + 1;\\n        // Invariance\\n        // isPossible(l) is always true\\n        // isPossible(r) is always false\\n        while (l + 1 < r) {                         // T.C: O(log n)\\n            int m = l + (r - l) / 2;\\n            if (isPossible(m))\\n                l = m;\\n            else\\n                r = m;\\n        }\\n        // We can place (alreadyTaken, l] in our curr\\n        int wordCount = l - alreadyTaken;\\n        int totalWordsLen = preFixLength[l] - preFixLength[alreadyTaken];\\n        int spaceNeeded = maxWidth - totalWordsLen;\\n        int gapNeeded = 1, extraGap = 0;\\n        if (wordCount > 1 && l != N) {\\n            gapNeeded = spaceNeeded / (wordCount - 1);\\n            extraGap = spaceNeeded % (wordCount - 1);\\n        } \\n        int k = 0;\\n        string curr(maxWidth, \\' \\');                 // T.C: O(maxWidth)\\n        for (int i = alreadyTaken; i < l; i++) {    // T.C: O(maxWidth)\\n            for (int j = 0; j < words[i].size(); j++) {\\n                curr[k++] = words[i][j]; \\n            }\\n            // Put Spaces\\n            k += gapNeeded;\\n            if (extraGap) {\\n                k++;\\n                extraGap--;\\n            }\\n        }\\n        // Update alreadyTaken\\n        alreadyTaken = l;\\n        ans.push_back(curr);\\n        return l;\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int _maxWidth) {\\n        /* Approach:\\n            1. Binary Search -- T.C: O(n * (maxWidth + log n)), S.C: O(n)\\n        */\\n\\n        // Approach 1\\n        alreadyTaken = 0;\\n        N = words.size();\\n        maxWidth = _maxWidth;\\n        preFixLength.assign(N + 1, 0);\\n        // Calculate Prefix Length\\n        for (int i = 1; i <= N; i++) {\\n            preFixLength[i] = preFixLength[i - 1] + words[i - 1].size();\\n        }\\n\\n        vector<string> ans;\\n\\n        int i = 0;\\n        while (i < N) {     // T.C: O(n * (maxWidth + log n))\\n            i = fitWords(i, words, ans);\\n        }\\n        /* Reasoning behind the time complexity:\\n            In the worst case, we are given such words, that our output contains only one word in each line\\n            Complexity of our fitWords() function is O(maxWidth + log (Search Range))\\n            In this case:\\n                i is incremented by 1 and serach space reduces by 1\\n                so the while loop will run \\'N\\' times to call fitWords() function\\n                Time Complexity:\\n                    [maxWidth + log (N)] + [maxWidth + log (N - 1)] + . . . . . [maxWidth + log (2)]\\n                    Which is = N * (maxWidth + log N)\\n        */\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721607,
                "title": "beats-100-full-explaination-tc-o-n-maxwidth",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPartition approach will work as we have to store as many consecutive words possible in a line, with a constraint that every word is separate by atleast one space with another word. \\n\\nSo, for a line to be valid, the constraints come out to be -\\n`totalLengthOfTheWordsInTheLine + totalNumberOfWordsInTheCurrentLine - 1 <= maxWidth`\\nSo for a line to contain 3 words,the sum  of lengths of all the three words and 2 spaces should be less than or equal to maxWidth.\\n\\nAs soon as the constraint is broken or the length of the line becomes greater than maxWidth, we start storing word in a new line.\\n\\n---\\n```\\nFor Example -\\nwords = [\"abc\",\"ab\",\"ab\",\"a\",\"fgabc\"]\\nmaxWidth = 7\\n\\nOutput - \\n\"abc-ab-\"\\n\"ab---a-\"\\n\"fgabc--\"\\n\\nwhere \\'-\\' represent a single space\\n```\\n\\nThe first line contains abc,ab only and not abc,ab,ab because the words need to be separated by atleast one space, so the length of line abc,ab,ab would be `(3 + 2 + 2) + (3-1) = 7 + 2 = 9`, that would excede the maxWidth criteria, so \"ab\" on index 2 goes to a new line.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize line1 with length of `word[0]`. Since it is the only word in the line and the last word should not be followed by a space, the total length of the line1 remains the same.\\nWe iterate over the words array from `i = 1 to n-1`, storing words in a vector `temp`that belongs to same line, checking if the ith word can be added to the current line. We will be taking a separate variable,`prevLen` to store the totalLengthOfTheWords in the current line, and updating it while iterating. The least number of spaces the current line will be having for adding the current word is `lineSpaces = temp.size()`,i.e., `temp.size() - 1` for existing words, and `+ 1` for adding current word, so overall, `temp.size()` spaces.\\n\\nThe condition of being added to the current line being - \\n`prevLen + lineSpaces + curWordLength <= maxWidth`.\\nSo for creating a new line, condition becomes - \\n`prevLen + lineSpaces + curWordLength > maxWidth`\\nAfter a line, `temp`, can no longer hold more words, we add it to the `lines` vector, and store the space the line can have in a `space` vector, as `maxWidth - prevLen`.\\n\\nNote - After iteration, we have to add the last line in the `lines` vector as it won\\'t be added in the iterating loop.\\n\\nAfter storing all the lines and the corresponding number of spaces they can have. We will be iterating over all the lines and converting them into string with spaces, and store in the `ans` vector.\\n\\nWe have two justifications for a line-\\n1. <b>Left Only Justification</b> - For line containing one word, and the last line.\\n2. <b>Left and Right Justification</b> - For all the other lines not mentioned in 1.\\n\\nSo to append spaces, we have three states -\\n1. <b>When the line is the last line, or the line contains only one word -</b>\\nIn this case, we will be adding only one space after every word, except the last word. The remaining spaces will be added after the last word, to make it left justified \\n\\n2. <b>The line which is not the last line, and contains more than one word-</b>\\nIn this case, we will find out the least number of spaces that we can add between two consecutive words by `sp = space[i]/(numberOfWords-1)`, extra space being `spExtra = space[i]%(numberOfWords-1)`.\\nAs to distribute `space[i]` between `numberOfWords` words, even space will be `sp`, and `extraSpace` that is used only `1` time after each word until it becomes `0`. <i>As per the question statement - <b>\\'Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\'</b></i>\\nSince extra spaces will be less than the total positions where we can add space, i.e., `spExtra < sp`, therefore we will be adding only `1` extra space, if `spExtra` is not already exhausted.\\n\\n# Complexity\\n- <b>Time complexity: $$O(n+n*maxWidth)$$</b>\\n-$$O(n)$$ for storing character in their respective line\\n-$$O(n.maxWidth)$$ for iterating over all lines to store answer.\\nIn worst case, every line contains a single word, so `n` lines, and for each line we iterate over `maxWidth` characters, to append word characters and spaces. So total iteration becomse $$n*maxWidth$$\\n\\n- <b>Space complexity: $$O(n + n*TotalWordLength+TotalWrdLength + maxWidth)$$</b>\\nSince, maximmum number of lines will be `n` in worst case, therefore space utiltized by \\n-`space` vector for storing space will be $$O(n)$$.\\n-Maximum space utilized by `line` vector will be $$O(n*totalWordLength)$$. Since it stores words only.\\n-$$O(TotalWordLength)$$ for `temp` vector.\\n-String `curr` will also have space complexity of $$O(maxWidth)$$, as it will contain maxWidth characters.\\nSo total space complexity will be $$O(n + n*TotalWordLength+TotalWrdLength + maxWidth)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<vector<string>> lines;\\n        vector<int> spaces;\\n\\n        vector<string> temp = {words[0]};\\n        int i = 1, prevLen = words[0].length();\\n        while(i<n){\\n            int curWordLength = words[i].length();\\n            int prevLineSpaces = temp.size();\\n            if(prevLen + prevLineSpaces + curWordLength > maxWidth){\\n                //if cannot add current word to prev line\\n\\n                //adding prev line to ansvector\\n                lines.push_back(temp);\\n                spaces.push_back(maxWidth - prevLen);\\n\\n                //creating new line\\n                prevLen = curWordLength;\\n                temp.clear();\\n                temp.push_back(words[i]);\\n            }\\n            else{\\n                //adding word to current line\\n                prevLen += curWordLength;\\n                temp.push_back(words[i]);\\n            }\\n            i++;\\n        }\\n        //adding last line\\n        lines.push_back(temp);\\n        spaces.push_back(maxWidth-prevLen);\\n\\n        vector<string> ans;\\n        int sz = lines.size();\\n        //generating line string\\n        for(int j = 0;j<sz;++j){\\n            int numberOfWords = lines[j].size();\\n            int sp = spaces[j];\\n            string cur;\\n            //if last line or contains a single character\\n            if(j == sz-1 || numberOfWords==1){\\n                //left only justified\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //not to add space after last character if no extra space is there\\n                    if(sp){\\n                        cur += \\' \\';\\n                        sp--;\\n                    }\\n                }\\n                //padding extra space after last word\\n                if(sp) while(sp--) cur+=\\' \\';\\n            }\\n            else{\\n                //left & right justified\\n                //extra space to be added after first word\\n                int spExtra = sp%(numberOfWords-1);\\n                sp = sp/(numberOfWords-1);\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //adding even space\\n                    if(l!=numberOfWords-1) for(int k=0;k<sp;++k) cur+=\\' \\';\\n                    //adding extra space after first word only\\n                    if(spExtra){\\n                        cur += \\' \\';\\n                        spExtra--;\\n                    }\\n                }\\n            }\\n            ans.push_back(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nFor Example -\\nwords = [\"abc\",\"ab\",\"ab\",\"a\",\"fgabc\"]\\nmaxWidth = 7\\n\\nOutput - \\n\"abc-ab-\"\\n\"ab---a-\"\\n\"fgabc--\"\\n\\nwhere \\'-\\' represent a single space\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<vector<string>> lines;\\n        vector<int> spaces;\\n\\n        vector<string> temp = {words[0]};\\n        int i = 1, prevLen = words[0].length();\\n        while(i<n){\\n            int curWordLength = words[i].length();\\n            int prevLineSpaces = temp.size();\\n            if(prevLen + prevLineSpaces + curWordLength > maxWidth){\\n                //if cannot add current word to prev line\\n\\n                //adding prev line to ansvector\\n                lines.push_back(temp);\\n                spaces.push_back(maxWidth - prevLen);\\n\\n                //creating new line\\n                prevLen = curWordLength;\\n                temp.clear();\\n                temp.push_back(words[i]);\\n            }\\n            else{\\n                //adding word to current line\\n                prevLen += curWordLength;\\n                temp.push_back(words[i]);\\n            }\\n            i++;\\n        }\\n        //adding last line\\n        lines.push_back(temp);\\n        spaces.push_back(maxWidth-prevLen);\\n\\n        vector<string> ans;\\n        int sz = lines.size();\\n        //generating line string\\n        for(int j = 0;j<sz;++j){\\n            int numberOfWords = lines[j].size();\\n            int sp = spaces[j];\\n            string cur;\\n            //if last line or contains a single character\\n            if(j == sz-1 || numberOfWords==1){\\n                //left only justified\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //not to add space after last character if no extra space is there\\n                    if(sp){\\n                        cur += \\' \\';\\n                        sp--;\\n                    }\\n                }\\n                //padding extra space after last word\\n                if(sp) while(sp--) cur+=\\' \\';\\n            }\\n            else{\\n                //left & right justified\\n                //extra space to be added after first word\\n                int spExtra = sp%(numberOfWords-1);\\n                sp = sp/(numberOfWords-1);\\n                for(int l = 0;l<numberOfWords;++l){\\n                    string s = lines[j][l];\\n                    cur += s;\\n                    //adding even space\\n                    if(l!=numberOfWords-1) for(int k=0;k<sp;++k) cur+=\\' \\';\\n                    //adding extra space after first word only\\n                    if(spExtra){\\n                        cur += \\' \\';\\n                        spExtra--;\\n                    }\\n                }\\n            }\\n            ans.push_back(cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033003,
                "title": "c-implementation-easy-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    string get_spaces(int n) {\\n        string spaces = \"\";\\n        for(int i = 0; i < n; i++)\\n            spaces += \" \";\\n        return spaces;\\n    }\\n    \\n    \\n    string justify(vector<string> &words, int mxWidth) {\\n        int len = 0;\\n        for(string word: words) \\n            len += word.length();\\n        \\n        int total = mxWidth - len;\\n        \\n        if(words.size() == 1) \\n            return words[0] + get_spaces(total);\\n        \\n        \\n        int space = total / (words.size()-1);\\n        int rem = total % (words.size()-1);\\n        \\n        string line = words[0];\\n        for(int i = 1; i < words.size(); i++) {\\n            // extra spaces give to leftmost rem words\\n            if(i <= rem)\\n                line += get_spaces(space+1) + words[i];\\n            else \\n                line += get_spaces(space) + words[i];\\n        }\\n        \\n        return line;\\n    }\\n    \\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int curr = 0;\\n        vector<string> tmp;\\n        vector<string> ans;\\n        \\n        for(string word: words) {\\n            if(curr + word.length() <= maxWidth) {\\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            } else {\\n                curr = 0;\\n                string line = justify(tmp, maxWidth);\\n                ans.push_back(line);\\n                tmp.clear();\\n                \\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            }\\n        }\\n        \\n        string line = tmp[0];\\n        for(int i = 1; i < tmp.size(); i++)\\n            line += \" \" + tmp[i];\\n        \\n        // add extra spaces to the end\\n        line += get_spaces(maxWidth-line.length());\\n        ans.push_back(line);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    string get_spaces(int n) {\\n        string spaces = \"\";\\n        for(int i = 0; i < n; i++)\\n            spaces += \" \";\\n        return spaces;\\n    }\\n    \\n    \\n    string justify(vector<string> &words, int mxWidth) {\\n        int len = 0;\\n        for(string word: words) \\n            len += word.length();\\n        \\n        int total = mxWidth - len;\\n        \\n        if(words.size() == 1) \\n            return words[0] + get_spaces(total);\\n        \\n        \\n        int space = total / (words.size()-1);\\n        int rem = total % (words.size()-1);\\n        \\n        string line = words[0];\\n        for(int i = 1; i < words.size(); i++) {\\n            // extra spaces give to leftmost rem words\\n            if(i <= rem)\\n                line += get_spaces(space+1) + words[i];\\n            else \\n                line += get_spaces(space) + words[i];\\n        }\\n        \\n        return line;\\n    }\\n    \\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int curr = 0;\\n        vector<string> tmp;\\n        vector<string> ans;\\n        \\n        for(string word: words) {\\n            if(curr + word.length() <= maxWidth) {\\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            } else {\\n                curr = 0;\\n                string line = justify(tmp, maxWidth);\\n                ans.push_back(line);\\n                tmp.clear();\\n                \\n                tmp.push_back(word);\\n                curr += word.length() + 1;\\n            }\\n        }\\n        \\n        string line = tmp[0];\\n        for(int i = 1; i < tmp.size(); i++)\\n            line += \" \" + tmp[i];\\n        \\n        // add extra spaces to the end\\n        line += get_spaces(maxWidth-line.length());\\n        ans.push_back(line);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005474,
                "title": "very-clean-and-clear-python-solution-easy-to-understand",
                "content": "Really **not easy**, requiring no algorithm but good coding skills!\\n\\nInitiate a **running line**.\\nInitiate a **running line length**.\\nWrite helper function **format()**\\nWrite helper function **formatLastline()**\\nIn the main function, we **check and collect the words that could put in one line**, and call helper fumction.\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        running_line = []\\n        line_length = 0\\n        res = []\\n        for word in words:\\n            if line_length + len(running_line) + len(word) <= maxWidth:\\n                line_length += len(word)\\n                running_line.append(word)\\n            else:\\n                res.append(self._format(running_line, maxWidth))\\n                line_length = len(word)\\n                running_line = [word]\\n        if len(running_line):\\n            res.append(self._formatLast(running_line, maxWidth))\\n        return res\\n\\n    def _format(self, line, maxWidth):\\n        if len(line) == 1:\\n            return line[0] + \" \" * (maxWidth - len(line[0]))\\n        \\n        length = sum([len(word) for word in line])\\n        gaps = len(line) - 1\\n        s = line[0]\\n        for index, word in enumerate(line[1:]):\\n            if index < (maxWidth - length) % gaps:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + \" \" + word\\n            else:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + word\\n        return s\\n        \\n    def _formatLast(self, line, maxWidth):\\n        s = \" \".join(line)\\n        return s + \" \" * (maxWidth - len(s))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        running_line = []\\n        line_length = 0\\n        res = []\\n        for word in words:\\n            if line_length + len(running_line) + len(word) <= maxWidth:\\n                line_length += len(word)\\n                running_line.append(word)\\n            else:\\n                res.append(self._format(running_line, maxWidth))\\n                line_length = len(word)\\n                running_line = [word]\\n        if len(running_line):\\n            res.append(self._formatLast(running_line, maxWidth))\\n        return res\\n\\n    def _format(self, line, maxWidth):\\n        if len(line) == 1:\\n            return line[0] + \" \" * (maxWidth - len(line[0]))\\n        \\n        length = sum([len(word) for word in line])\\n        gaps = len(line) - 1\\n        s = line[0]\\n        for index, word in enumerate(line[1:]):\\n            if index < (maxWidth - length) % gaps:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + \" \" + word\\n            else:\\n                s = s + \" \" * ((maxWidth - length) // gaps) + word\\n        return s\\n        \\n    def _formatLast(self, line, maxWidth):\\n        s = \" \".join(line)\\n        return s + \" \" * (maxWidth - len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938449,
                "title": "easy-python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Input check\\n        if not len(words):\\n            return []\\n        \\n        result = []\\n        current_line_len, curr_line = 0, []\\n        \\n        for word in words: \\n            # Incase the new word cannot fit the current line,\\n            # add the spaces and create a new entry in final result\\n            if current_line_len + len(word) + len(curr_line) > maxWidth:    \\n                for i in range(maxWidth - current_line_len): \\n                    curr_line[i % (len(curr_line) - 1 or 1) ] += \\' \\'\\n                    \\n                result.append(\\'\\'.join(curr_line))   # Add to result\\n                current_line_len, curr_line = 0, [] # Reset curr_line and len of current line\\n                \\n            current_line_len += len(word)\\n            curr_line.append(word)\\n            \\n        return result + [\\' \\'.join(curr_line).ljust(maxWidth)]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Input check\\n        if not len(words):\\n            return []\\n        \\n        result = []\\n        current_line_len, curr_line = 0, []\\n        \\n        for word in words: \\n            # Incase the new word cannot fit the current line,\\n            # add the spaces and create a new entry in final result\\n            if current_line_len + len(word) + len(curr_line) > maxWidth:    \\n                for i in range(maxWidth - current_line_len): \\n                    curr_line[i % (len(curr_line) - 1 or 1) ] += \\' \\'\\n                    \\n                result.append(\\'\\'.join(curr_line))   # Add to result\\n                current_line_len, curr_line = 0, [] # Reset curr_line and len of current line\\n                \\n            current_line_len += len(word)\\n            curr_line.append(word)\\n            \\n        return result + [\\' \\'.join(curr_line).ljust(maxWidth)]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1895596,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        lines = self.constructLines(words, maxWidth)\\n        lines = self.addSpaces(lines, maxWidth)\\n        lines = list(map(lambda x : \"\".join(x), lines))\\n        return lines\\n    \\n    def constructLines(self, words, maxWidth):\\n        lines = []\\n        \\n        # Construct words per line\\n        wordLensInPara = list(map(len, words))\\n        i, j = 0, 0\\n        while i < len(words):\\n            while j < len(words):\\n                totalWordLen, numSpaces = sum(wordLensInPara[i:j+1]), (j-i)\\n                width = totalWordLen + numSpaces\\n                if width > maxWidth: break\\n                else: j += 1\\n            lines.append(words[i:j])\\n            i = j\\n        \\n        return lines\\n    \\n    def addSpaces(self, lines, maxWidth):\\n        for line in lines:\\n            numWords = len(line)\\n            lineLen = sum(map(len, line))\\n            numSpaces = maxWidth - lineLen\\n            \\n            # Standard line\\n            if lines.index(line) < len(lines)-1:\\n                if numWords == 1: # One word\\n                    line[0] += \" \" * numSpaces\\n                else: # Multiple words\\n                    numSpacesPerWord, extraSpaces = divmod(numSpaces,numWords-1)\\n                    for i in range(len(line)-1):\\n                        line[i] += \" \" * numSpacesPerWord\\n\\n                        if extraSpaces > 0:\\n                            line[i] += \" \"\\n                            extraSpaces -= 1\\n            # Last line\\n            else:\\n                for i in range(len(line)-1):\\n                    line[i] += \" \"\\n                    numSpaces -= 1\\n                line[-1] += \" \" * numSpaces\\n            \\n        return lines\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words, maxWidth):\\n        lines = self.constructLines(words, maxWidth)\\n        lines = self.addSpaces(lines, maxWidth)\\n        lines = list(map(lambda x : \"\".join(x), lines))\\n        return lines\\n    \\n    def constructLines(self, words, maxWidth):\\n        lines = []\\n        \\n        # Construct words per line\\n        wordLensInPara = list(map(len, words))\\n        i, j = 0, 0\\n        while i < len(words):\\n            while j < len(words):\\n                totalWordLen, numSpaces = sum(wordLensInPara[i:j+1]), (j-i)\\n                width = totalWordLen + numSpaces\\n                if width > maxWidth: break\\n                else: j += 1\\n            lines.append(words[i:j])\\n            i = j\\n        \\n        return lines\\n    \\n    def addSpaces(self, lines, maxWidth):\\n        for line in lines:\\n            numWords = len(line)\\n            lineLen = sum(map(len, line))\\n            numSpaces = maxWidth - lineLen\\n            \\n            # Standard line\\n            if lines.index(line) < len(lines)-1:\\n                if numWords == 1: # One word\\n                    line[0] += \" \" * numSpaces\\n                else: # Multiple words\\n                    numSpacesPerWord, extraSpaces = divmod(numSpaces,numWords-1)\\n                    for i in range(len(line)-1):\\n                        line[i] += \" \" * numSpacesPerWord\\n\\n                        if extraSpaces > 0:\\n                            line[i] += \" \"\\n                            extraSpaces -= 1\\n            # Last line\\n            else:\\n                for i in range(len(line)-1):\\n                    line[i] += \" \"\\n                    numSpaces -= 1\\n                line[-1] += \" \" * numSpaces\\n            \\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746085,
                "title": "clean-c-code-faster-than-100",
                "content": "class Solution {\\npublic:\\n    \\n    string makeLine(vector<string>&v, int toFill){\\n        string res = \"\";\\n        // One word line\\n        if(v.size() == 1){\\n            res += v[0];\\n            while(toFill--) res += \\' \\';\\n            return res;\\n        }\\n        \\n        //Multiple word line\\n        int space = toFill / (v.size()-1);\\n        int extras = toFill % (v.size()-1);\\n        res += v[0];\\n        for(int i=1;i<v.size();i++){\\n            for(int j=0;j<space;j++) res += \\' \\';\\n            if(extras){\\n                extras --;\\n                res += \\' \\';\\n            }\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    \\n     string makeLastLine(vector<string>&v, int toFill){\\n        string res = v[0];\\n        for(int i=1;i<v.size();i++){\\n            toFill --;\\n            res += \\' \\';\\n            res += v[i];\\n        }\\n        while(toFill --) res += \\' \\';\\n        return res;\\n     }\\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> taken;\\n        int lineLen = 0;\\n        for(auto word: words){\\n            if(lineLen+word.size()+taken.size() > maxWidth){\\n                res.push_back(makeLine(taken, maxWidth-lineLen));\\n                taken.clear();\\n                taken.push_back(word);\\n                lineLen = word.size();\\n            } else{\\n                taken.push_back(word);\\n                lineLen += word.size();\\n            }\\n        }\\n        // Last line\\n        res.push_back(makeLastLine(taken, maxWidth-lineLen));\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string makeLine(vector<string>&v, int toFill){\\n        string res = \"\";\\n        // One word line\\n        if(v.size() == 1){\\n            res += v[0];\\n            while(toFill--) res += \\' \\';\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1396429,
                "title": "java-life-is-easier-by-using-stringjoiner",
                "content": "The biggest headache for this problem is corner cases with padding space. By using StringJoiner would avoid most of them .\\nAt least allow you focus on the logic but not the stupid missing or extra space here and there . \\n```\\nimport java.util.StringJoiner;\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        // Final result\\n        List<String> result = new ArrayList<>(); \\n        // List of words fit in one line \\n        List<String> line = new ArrayList<>();\\n        \\n        int lineCount = 0; \\n        for (String word : words) {\\n            if ((lineCount + word.length() + line.size() - 1) >= maxWidth) {\\n                 result.add(indent(line, lineCount, maxWidth, false));\\n                 line.clear();\\n                 lineCount = 0; \\n            } \\n            line.add(word);           \\n            lineCount += word.length();\\n        }\\n        result.add(indent(line, lineCount, maxWidth, true));\\n        return result; \\n    }\\n    private String indent(List<String> line, int lineCount, int maxWidth, boolean last) {\\n        StringJoiner sj = new StringJoiner(\" \"); \\n        // Last Line \\n        if (last) {\\n           for (String w : line) {\\n               sj.add(w);\\n           }\\n           int remain = maxWidth - sj.length(); \\n           appendSpace(sj, remain);\\n           return sj.toString(); \\n        }\\n        sj.add(line.get(0));\\n        int spaces = maxWidth - lineCount; \\n        int gapSize = line.size() - 1;\\n        // Only one word , add padding and return ; \\n        if (line.size() == 1) {\\n            appendSpace(sj, spaces);\\n            return sj.toString();             \\n        }\\n        int gap = spaces / gapSize;\\n        // Extra space after average gap \\n        int leftOver = spaces % gapSize; \\n        for (int j = 1; j < line.size(); j++) {\\n            int g = gap ;\\n            if (leftOver > 0) {\\n                g++; \\n                leftOver--;\\n            }\\n            appendSpace(sj, g - 1);\\n            sj.add(line.get(j));\\n        }\\n        return sj.toString(); \\n    }\\n    \\n    private void appendSpace(StringJoiner sj, int count) {\\n           for (int i = 0; i < count ; i++) {\\n               sj.add(\"\");\\n           }        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.StringJoiner;\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        // Final result\\n        List<String> result = new ArrayList<>(); \\n        // List of words fit in one line \\n        List<String> line = new ArrayList<>();\\n        \\n        int lineCount = 0; \\n        for (String word : words) {\\n            if ((lineCount + word.length() + line.size() - 1) >= maxWidth) {\\n                 result.add(indent(line, lineCount, maxWidth, false));\\n                 line.clear();\\n                 lineCount = 0; \\n            } \\n            line.add(word);           \\n            lineCount += word.length();\\n        }\\n        result.add(indent(line, lineCount, maxWidth, true));\\n        return result; \\n    }\\n    private String indent(List<String> line, int lineCount, int maxWidth, boolean last) {\\n        StringJoiner sj = new StringJoiner(\" \"); \\n        // Last Line \\n        if (last) {\\n           for (String w : line) {\\n               sj.add(w);\\n           }\\n           int remain = maxWidth - sj.length(); \\n           appendSpace(sj, remain);\\n           return sj.toString(); \\n        }\\n        sj.add(line.get(0));\\n        int spaces = maxWidth - lineCount; \\n        int gapSize = line.size() - 1;\\n        // Only one word , add padding and return ; \\n        if (line.size() == 1) {\\n            appendSpace(sj, spaces);\\n            return sj.toString();             \\n        }\\n        int gap = spaces / gapSize;\\n        // Extra space after average gap \\n        int leftOver = spaces % gapSize; \\n        for (int j = 1; j < line.size(); j++) {\\n            int g = gap ;\\n            if (leftOver > 0) {\\n                g++; \\n                leftOver--;\\n            }\\n            appendSpace(sj, g - 1);\\n            sj.add(line.get(j));\\n        }\\n        return sj.toString(); \\n    }\\n    \\n    private void appendSpace(StringJoiner sj, int count) {\\n           for (int i = 0; i < count ; i++) {\\n               sj.add(\"\");\\n           }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744200,
                "title": "100-java-this-is-how-normal-programmer-thinks-p",
                "content": "**Inline comments**\\n\\n```\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ) {\\n            int current_length = 0; // get the current length\\n            ArrayList<String> current = new ArrayList<>(); // make a list of current strings\\n            while (i < words.length && current_length < maxWidth) { // add to the list till the length reaches the maxwidth\\n                if (words[i].length() + current_length <= maxWidth) {\\n                    current.add(words[i]);\\n                    current_length += words[i].length();\\n                    current_length += 1; // add space for each of the words\\n                    i++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            current_length--; // once we have list of words and length, remove the last space\\n            int num_of_words = current.size();\\n            /*\\n            below code has 3 cases\\n            case 1: when we have reached the last words in total list,so the result should be left justified.\\n             */\\n            if (i >= words.length) { // check if i is greater than equal to input list.\\n                // left justify the output.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \");\\n                    }\\n                }\\n                int len = stringBuilder.toString().length();\\n                for (int j = len; j < maxWidth; j++)\\n                    stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            } \\n              /*\\n            below code has 3 cases\\n            case 2: when there are more than one word in the current list.\\n             */\\n            else if (num_of_words > 1) {\\n                int rem = maxWidth - current_length; // get the remaining number of character\\n                // note : current_length already consist one space between words.\\n                int space_between_words = rem / (current.size() - 1); // so the remaining space is remaining length / (number of words)\\n                int extra = rem % (current.size() - 1); // this extra should be left as possible.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \"); // current word space\\n                        for (int k = 0; k < space_between_words; k++) { // add remaing space for each word as per formula\\n                            stringBuilder.append(\" \");\\n                        }\\n                        if (extra > 0) { // extra is added as left as possible, till we have.\\n                            stringBuilder.append(\" \");\\n                            extra--;\\n                        }\\n                    }\\n                }\\n                result.add(stringBuilder.toString());\\n                  /*\\n            below code has 3 cases\\n            case 3:when the current list contains single word\\n            make it left justified\\n             */\\n            } else {\\n                StringBuilder stringBuilder = new StringBuilder();\\n                stringBuilder.append(current.get(0));\\n                for (int j = current.get(0).length(); j < maxWidth; j++) stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            }\\n        }\\n        return result;\\n```",
                "solutionTags": [],
                "code": "```\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; ) {\\n            int current_length = 0; // get the current length\\n            ArrayList<String> current = new ArrayList<>(); // make a list of current strings\\n            while (i < words.length && current_length < maxWidth) { // add to the list till the length reaches the maxwidth\\n                if (words[i].length() + current_length <= maxWidth) {\\n                    current.add(words[i]);\\n                    current_length += words[i].length();\\n                    current_length += 1; // add space for each of the words\\n                    i++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            current_length--; // once we have list of words and length, remove the last space\\n            int num_of_words = current.size();\\n            /*\\n            below code has 3 cases\\n            case 1: when we have reached the last words in total list,so the result should be left justified.\\n             */\\n            if (i >= words.length) { // check if i is greater than equal to input list.\\n                // left justify the output.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \");\\n                    }\\n                }\\n                int len = stringBuilder.toString().length();\\n                for (int j = len; j < maxWidth; j++)\\n                    stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            } \\n              /*\\n            below code has 3 cases\\n            case 2: when there are more than one word in the current list.\\n             */\\n            else if (num_of_words > 1) {\\n                int rem = maxWidth - current_length; // get the remaining number of character\\n                // note : current_length already consist one space between words.\\n                int space_between_words = rem / (current.size() - 1); // so the remaining space is remaining length / (number of words)\\n                int extra = rem % (current.size() - 1); // this extra should be left as possible.\\n                StringBuilder stringBuilder = new StringBuilder();\\n                for (int j = 0; j < current.size(); j++) {\\n                    if (j == current.size() - 1) stringBuilder.append(current.get(j));\\n                    else {\\n                        stringBuilder.append(current.get(j));\\n                        stringBuilder.append(\" \"); // current word space\\n                        for (int k = 0; k < space_between_words; k++) { // add remaing space for each word as per formula\\n                            stringBuilder.append(\" \");\\n                        }\\n                        if (extra > 0) { // extra is added as left as possible, till we have.\\n                            stringBuilder.append(\" \");\\n                            extra--;\\n                        }\\n                    }\\n                }\\n                result.add(stringBuilder.toString());\\n                  /*\\n            below code has 3 cases\\n            case 3:when the current list contains single word\\n            make it left justified\\n             */\\n            } else {\\n                StringBuilder stringBuilder = new StringBuilder();\\n                stringBuilder.append(current.get(0));\\n                for (int j = current.get(0).length(); j < maxWidth; j++) stringBuilder.append(\" \");\\n                result.add(stringBuilder.toString());\\n            }\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363913,
                "title": "very-simple-and-straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int curLen = 0;\\n        List<String> curLine = new LinkedList<>(); \\n        for(int i = 0; i < words.length; i++){\\n            if(curLen == 0){\\n                curLen += words[i].length();\\n                curLine.add(words[i]);\\n            }\\n            else if(curLen+1+words[i].length()>maxWidth){\\n                addLine(res, maxWidth, curLine, false);\\n                curLine.clear();\\n                i--;\\n                curLen = 0;\\n            }else{\\n                curLen += words[i].length()+1;\\n                curLine.add(words[i]);                \\n            }            \\n        }\\n        //add last line \\n        addLine(res, maxWidth, curLine, true);\\n        return res;        \\n    }\\n    void addLine(List<String> res, int maxWidth, List<String> curLine, boolean isLastLine){\\n        StringBuilder sb = new StringBuilder();\\n        if(isLastLine||curLine.size()==1){\\n            // left-justified\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0)\\n                    sb.append(\\' \\');\\n                sb.append(curLine.get(i));\\n            }\\n            while(sb.length()<maxWidth)\\n                sb.append(\\' \\');\\n        }else{\\n            //fully-justified\\n            int len = maxWidth;\\n            for(String s: curLine)\\n                len -= s.length();\\n            int j = 0;\\n            j = len % (curLine.size() - 1);\\n            len = len / (curLine.size() - 1);\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0){\\n                    for(int k = 0; k < len; k++)\\n                        sb.append(\\' \\');\\n                    if(j>0){\\n                        sb.append(\\' \\');\\n                        j--;\\n                    }\\n                }\\n                sb.append(curLine.get(i));                \\n            }                       \\n        }\\n        res.add(sb.toString());\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        int curLen = 0;\\n        List<String> curLine = new LinkedList<>(); \\n        for(int i = 0; i < words.length; i++){\\n            if(curLen == 0){\\n                curLen += words[i].length();\\n                curLine.add(words[i]);\\n            }\\n            else if(curLen+1+words[i].length()>maxWidth){\\n                addLine(res, maxWidth, curLine, false);\\n                curLine.clear();\\n                i--;\\n                curLen = 0;\\n            }else{\\n                curLen += words[i].length()+1;\\n                curLine.add(words[i]);                \\n            }            \\n        }\\n        //add last line \\n        addLine(res, maxWidth, curLine, true);\\n        return res;        \\n    }\\n    void addLine(List<String> res, int maxWidth, List<String> curLine, boolean isLastLine){\\n        StringBuilder sb = new StringBuilder();\\n        if(isLastLine||curLine.size()==1){\\n            // left-justified\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0)\\n                    sb.append(\\' \\');\\n                sb.append(curLine.get(i));\\n            }\\n            while(sb.length()<maxWidth)\\n                sb.append(\\' \\');\\n        }else{\\n            //fully-justified\\n            int len = maxWidth;\\n            for(String s: curLine)\\n                len -= s.length();\\n            int j = 0;\\n            j = len % (curLine.size() - 1);\\n            len = len / (curLine.size() - 1);\\n            for(int i = 0; i < curLine.size(); i++){\\n                if(i!=0){\\n                    for(int k = 0; k < len; k++)\\n                        sb.append(\\' \\');\\n                    if(j>0){\\n                        sb.append(\\' \\');\\n                        j--;\\n                    }\\n                }\\n                sb.append(curLine.get(i));                \\n            }                       \\n        }\\n        res.add(sb.toString());\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954437,
                "title": "brute-force-easy-to-understand-simulation-c-full-explanation-step-by-step",
                "content": "# Intuition\\nThe idea is to analyse the constraints first. On analysis it is well observed that simulating the entire process is time friendly. Therefore we think on designing a justification algorithm for each sentence and then present our answer.\\n\\n# Approach\\nThe approach is pretty straight forward.\\n\\n**Step 1:** Form sentences. \\n1. To do this iterate over all the words and check if words combined together, exceed the max width or not. Once this happens start forming a new sentence. \\n2. There is a catch here. Every word has to be counted with atleast one space for presentation reasons. (Each word must be separated by atleast one space).\\n3. The last word in every sentence can go without the space described above.\\n\\n**Step 2:** Once we have the sentences in the form of words they are going to contain, we now have to calculate the number of spaces we have insert at the end of each word.(excluding the last)\\n1. Note: If number of words in a sentence are \\'N\\', the number of spaces between these words would be \\'N-1\\'.\\n2. Note: Each space should be equal or almost equal (depending on division of total extra space among words).\\n3. For every sentence:\\n   `Total charCount = sum of word sizes`\\n   `Spaces feasible = maxWidth- charCount`\\n4. Space per word (sppw) = total space / (number of words-1)\\n   `sppw = spaces / (sentences[i].size() -1)` \\n\\n**Step 3:** Insert the spaces calculated to each word.\\nHowever this is not enough.\\n\\n**WHAT IF THE SPACES DONT DISTRIBUTE EQUALLY?**\\n1. To handle such a case when the spaces leave a remainder, you would have to iterate over all the words one by one and give them one extra space until the remainder exhausts.\\n2. This would ensure near equal distribution.\\n\\n**Step 3:** Handle Special Cases\\n1. Sentence with only one word\\n   In such a case, all the spaces feasible go after that single word and makes the entire string left aligned.\\n2. The last sentence\\n   According to the question the last sentence should be left aligned, i.e. every word should be spaced by 1, and the remaining spaces should be added to the last.\\n\\n# Complexity\\n- Time complexity:\\nTo calculate the upper bound, lets assume that every sentence has max width, and contains one word only.\\nTherefore, number of character comparisions is given by\\n```\\nNumber of sentences * max width of a sentence\\nNumber of sentences = number of words = 300 (at max).\\nMax width of a sentence = 100\\n```\\n\\nTotal number of character comparisions made= 300 * 100 = 3e4 operations (upper bound).\\n\\n- Space complexity:\\nIn the same way the space required to store the words, in an array of array of strings, would take up 3e4 space (upper bound).\\n\\n\\n# **An upvote would be highly appreaciated if you understand. Happy Learning!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<vector<string>> sentences;\\n        \\n        int curSize=0;\\n        vector<string> sentence;\\n\\n        // Step 1: Form sentences.\\n        for(auto word: words)\\n        {\\n            curSize+= word.size()+1;\\n            if(curSize> maxWidth+1)\\n            {\\n                sentences.push_back(sentence);\\n                sentence.clear();\\n                sentence.push_back(word);\\n                curSize= word.size()+1;\\n                continue;\\n            }\\n            \\n            sentence.push_back(word);\\n        }\\n        \\n        sentences.push_back(sentence);\\n        \\n        for(int i=0; i<sentences.size(); i++)\\n        {\\n            int m= sentences[i].size();\\n            if(m==1) //Step 3: Case of 1 word sentence\\n            {\\n                // cout<<sentences[i][0]<<endl;\\n                int sz= sentences[i][0].size();\\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][0].push_back(\\' \\');\\n                \\n                // cout<<sentences[i][0].size()<<endl;\\n                continue;\\n            }\\n            \\n            if(i==sentences.size()-1) // Case of last sentence\\n            {\\n                int sz=0;\\n                for(int j=0; j<sentences[i].size()-1; j++) //words\\n                {\\n                    sentences[i][j].push_back(\\' \\');\\n                    sz+= sentences[i][j].size();\\n                }\\n                // cout<<sz<<endl;\\n                sz+= sentences[i][sentences[i].size()-1].size();\\n                // cout<<sz<<endl;\\n                \\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][sentences[i].size()-1].push_back(\\' \\');\\n                \\n                continue;\\n            }\\n            \\n            // Step 2: Calculation of spaces per word\\n            int sz=0;\\n            for(int j=0; j<sentences[i].size(); j++)\\n                sz+= sentences[i][j].size();\\n            \\n            int sp= maxWidth - sz;\\n            int sppw=  sp/(m-1);\\n            int nsz=0;\\n            \\n            for(int j=0; j< sentences[i].size()-1; j++)\\n            {\\n                for(int k=0; k<sppw; k++)\\n                    sentences[i][j].push_back(\\' \\');\\n                \\n                nsz+= sentences[i][j].size();\\n            }\\n            \\n            nsz+= sentences[i][sentences[i].size()-1].size();\\n            \\n            // Handle remainder\\n            for(int j=0, k=0; j<sentences[i].size()&&  k< maxWidth-nsz; k++,j++)\\n            {\\n                sentences[i][j].push_back(\\' \\');\\n            }\\n            \\n        }\\n        \\n        // Form answer in required format\\n        vector<string> ans;\\n        \\n        for(auto s: sentences)\\n        {\\n            string sen;\\n            for(auto w: s)\\n                sen+= w;\\n            ans.push_back(sen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nNumber of sentences * max width of a sentence\\nNumber of sentences = number of words = 300 (at max).\\nMax width of a sentence = 100\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<vector<string>> sentences;\\n        \\n        int curSize=0;\\n        vector<string> sentence;\\n\\n        // Step 1: Form sentences.\\n        for(auto word: words)\\n        {\\n            curSize+= word.size()+1;\\n            if(curSize> maxWidth+1)\\n            {\\n                sentences.push_back(sentence);\\n                sentence.clear();\\n                sentence.push_back(word);\\n                curSize= word.size()+1;\\n                continue;\\n            }\\n            \\n            sentence.push_back(word);\\n        }\\n        \\n        sentences.push_back(sentence);\\n        \\n        for(int i=0; i<sentences.size(); i++)\\n        {\\n            int m= sentences[i].size();\\n            if(m==1) //Step 3: Case of 1 word sentence\\n            {\\n                // cout<<sentences[i][0]<<endl;\\n                int sz= sentences[i][0].size();\\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][0].push_back(\\' \\');\\n                \\n                // cout<<sentences[i][0].size()<<endl;\\n                continue;\\n            }\\n            \\n            if(i==sentences.size()-1) // Case of last sentence\\n            {\\n                int sz=0;\\n                for(int j=0; j<sentences[i].size()-1; j++) //words\\n                {\\n                    sentences[i][j].push_back(\\' \\');\\n                    sz+= sentences[i][j].size();\\n                }\\n                // cout<<sz<<endl;\\n                sz+= sentences[i][sentences[i].size()-1].size();\\n                // cout<<sz<<endl;\\n                \\n                for(int j=0; j< maxWidth- sz; j++)\\n                    sentences[i][sentences[i].size()-1].push_back(\\' \\');\\n                \\n                continue;\\n            }\\n            \\n            // Step 2: Calculation of spaces per word\\n            int sz=0;\\n            for(int j=0; j<sentences[i].size(); j++)\\n                sz+= sentences[i][j].size();\\n            \\n            int sp= maxWidth - sz;\\n            int sppw=  sp/(m-1);\\n            int nsz=0;\\n            \\n            for(int j=0; j< sentences[i].size()-1; j++)\\n            {\\n                for(int k=0; k<sppw; k++)\\n                    sentences[i][j].push_back(\\' \\');\\n                \\n                nsz+= sentences[i][j].size();\\n            }\\n            \\n            nsz+= sentences[i][sentences[i].size()-1].size();\\n            \\n            // Handle remainder\\n            for(int j=0, k=0; j<sentences[i].size()&&  k< maxWidth-nsz; k++,j++)\\n            {\\n                sentences[i][j].push_back(\\' \\');\\n            }\\n            \\n        }\\n        \\n        // Form answer in required format\\n        vector<string> ans;\\n        \\n        for(auto s: sentences)\\n        {\\n            string sen;\\n            for(auto w: s)\\n                sen+= w;\\n            ans.push_back(sen);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3668893,
                "title": "beats-92-14",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n    List<string> result = new List<string>();\\n    List<string> currentLine = new List<string>();\\n    int currentLength = 0;\\n\\n    foreach (string word in words)\\n    {\\n        if (currentLength + currentLine.Count + word.Length > maxWidth)\\n        {\\n            int numWords = currentLine.Count;\\n            int numSpaces = maxWidth - currentLength;\\n            string justifiedLine = \"\";\\n\\n            if (numWords == 1)\\n                justifiedLine = currentLine[0] + new string(\\' \\', numSpaces);\\n            else\\n            {\\n                int spacesBetweenWords = numSpaces / (numWords - 1);\\n                int extraSpaces = numSpaces % (numWords - 1);\\n\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < numWords - 1; i++)\\n                {\\n                    sb.Append(currentLine[i]);\\n                    sb.Append(new string(\\' \\', spacesBetweenWords));\\n\\n                    if (i < extraSpaces)\\n                    {\\n                        sb.Append(\\' \\');\\n                    }\\n                }\\n\\n                sb.Append(currentLine[numWords - 1]);\\n                justifiedLine = sb.ToString();\\n            }\\n\\n            result.Add(justifiedLine);\\n            currentLine.Clear();\\n            currentLength = 0;\\n        }\\n\\n        currentLine.Add(word);\\n        currentLength += word.Length;\\n    }\\n\\n    string lastLine = string.Join(\" \", currentLine);\\n    lastLine += new string(\\' \\', maxWidth - lastLine.Length);\\n    result.Add(lastLine);\\n\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n    List<string> result = new List<string>();\\n    List<string> currentLine = new List<string>();\\n    int currentLength = 0;\\n\\n    foreach (string word in words)\\n    {\\n        if (currentLength + currentLine.Count + word.Length > maxWidth)\\n        {\\n            int numWords = currentLine.Count;\\n            int numSpaces = maxWidth - currentLength;\\n            string justifiedLine = \"\";\\n\\n            if (numWords == 1)\\n                justifiedLine = currentLine[0] + new string(\\' \\', numSpaces);\\n            else\\n            {\\n                int spacesBetweenWords = numSpaces / (numWords - 1);\\n                int extraSpaces = numSpaces % (numWords - 1);\\n\\n                StringBuilder sb = new StringBuilder();\\n\\n                for (int i = 0; i < numWords - 1; i++)\\n                {\\n                    sb.Append(currentLine[i]);\\n                    sb.Append(new string(\\' \\', spacesBetweenWords));\\n\\n                    if (i < extraSpaces)\\n                    {\\n                        sb.Append(\\' \\');\\n                    }\\n                }\\n\\n                sb.Append(currentLine[numWords - 1]);\\n                justifiedLine = sb.ToString();\\n            }\\n\\n            result.Add(justifiedLine);\\n            currentLine.Clear();\\n            currentLength = 0;\\n        }\\n\\n        currentLine.Add(word);\\n        currentLength += word.Length;\\n    }\\n\\n    string lastLine = string.Join(\" \", currentLine);\\n    lastLine += new string(\\' \\', maxWidth - lastLine.Length);\\n    result.Add(lastLine);\\n\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180889,
                "title": "68-text-justification-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        i = 0\\n        while i < len(words):\\n            j, total_len = i, 0\\n            while j < len(words) and total_len + len(words[j]) + j - i <= maxWidth:\\n                total_len += len(words[j])\\n                j += 1\\n            if j == len(words):\\n                res.append(\" \".join(words[i:j]) + \" \" * (maxWidth - total_len - (j - i - 1)))\\n            else:\\n                spaces = maxWidth - total_len\\n                slots = j - i - 1\\n                if slots == 0:\\n                    res.append(words[i] + \" \" * spaces)\\n                else:\\n                    spaces_per_slot = spaces // slots\\n                    extra_spaces = spaces % slots\\n                    line = words[i]\\n                    for k in range(i + 1, j):\\n                        line += \" \" * (spaces_per_slot + (1 if extra_spaces > 0 else 0))\\n                        extra_spaces -= 1\\n                        line += words[k]\\n                    res.append(line)\\n            i = j\\n        return res\\n\\n``````\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # list to store the justified lines\\n        justified_lines = []\\n        # list to store the current line of words\\n        line = []\\n        # length of the current line\\n        line_length = 0\\n        # loop through all words\\n        for word in words:\\n            # if adding the current word to the line and a space would exceed the maxWidth\\n            if line_length + len(word) + len(line) > maxWidth:\\n                # calculate the number of spaces needed to be added to the line\\n                spaces = maxWidth - line_length\\n                # distribute the spaces as evenly as possible between the words\\n                for i in range(spaces):\\n                    line[i % (len(line) - 1 or 1)] += \\' \\'\\n                # add the line to the justified_lines list\\n                justified_lines.append(\\'\\'.join(line))\\n                # reset line and line_length for the next line\\n                line = []\\n                line_length = 0\\n            # add the current word to the line\\n            line.append(word)\\n            line_length += len(word)\\n        # handle the last line, which is left-justified\\n        last_line = \\' \\'.join(line)\\n        last_line += \\' \\' * (maxWidth - len(last_line))\\n        justified_lines.append(last_line)\\n        return justified_lines\\n\\n```\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        res = []\\n        i = 0\\n        while i < len(words):\\n            j, total_len = i, 0\\n            while j < len(words) and total_len + len(words[j]) + j - i <= maxWidth:\\n                total_len += len(words[j])\\n                j += 1\\n            if j == len(words):\\n                res.append(\" \".join(words[i:j]) + \" \" * (maxWidth - total_len - (j - i - 1)))\\n            else:\\n                spaces = maxWidth - total_len\\n                slots = j - i - 1\\n                if slots == 0:\\n                    res.append(words[i] + \" \" * spaces)\\n                else:\\n                    spaces_per_slot = spaces // slots\\n                    extra_spaces = spaces % slots\\n                    line = words[i]\\n                    for k in range(i + 1, j):\\n                        line += \" \" * (spaces_per_slot + (1 if extra_spaces > 0 else 0))\\n                        extra_spaces -= 1\\n                        line += words[k]\\n                    res.append(line)\\n            i = j\\n        return res\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795688,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        if (words == null || words.length == 0 || maxWidth <= 0) {\\n            return new ArrayList<String>();\\n        }\\n\\n        List<String> result = new ArrayList<String>();\\n        List<String> row = new ArrayList<String>();\\n        int index = 0, len = 0;\\n        while (index < words.length) {\\n            String word = words[index];\\n            if ((row.size() == 0 && len + word.length() > maxWidth) \\n                || (row.size() > 0 && len + word.length() + 1 > maxWidth)) {\\n                result.add(formatHelper(row, len, maxWidth, false));\\n                row = new ArrayList<String>();\\n                len = 0;\\n            } else {\\n                row.add(word);\\n                if (len == 0) {\\n                    len += word.length();\\n                } else {\\n                    len += (word.length() + 1);\\n                }\\n                index++;\\n            }\\n        }\\n        if (!row.isEmpty()) {\\n            result.add(formatHelper(row, len, maxWidth, true));\\n        }\\n        return result;\\n    }\\n\\n    private String formatHelper(List<String> row, int len, int maxWidth, boolean isLastRow) {\\n        StringBuilder result = new StringBuilder();\\n        int diff = maxWidth - len;\\n        int interLen = (row.size() > 1) ? (diff / (row.size() - 1)) : diff;\\n        StringBuilder interString = new StringBuilder();\\n        for (int i = 0; i < interLen; i++) {\\n            interString.append(\" \");\\n        }\\n        int largerInterCount = diff - interLen * (row.size() == 1 ? 1 : (row.size() - 1));\\n        for (int i = 0; i < row.size(); i++) {\\n            result.append(row.get(i));\\n            if (isLastRow) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n            } else if (i < row.size() - 1 || row.size() == 1) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n                result.append(interString);\\n                if (largerInterCount-- > 0) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        if (isLastRow) {\\n            while (result.length() < maxWidth) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        if (words == null || words.length == 0 || maxWidth <= 0) {\\n            return new ArrayList<String>();\\n        }\\n\\n        List<String> result = new ArrayList<String>();\\n        List<String> row = new ArrayList<String>();\\n        int index = 0, len = 0;\\n        while (index < words.length) {\\n            String word = words[index];\\n            if ((row.size() == 0 && len + word.length() > maxWidth) \\n                || (row.size() > 0 && len + word.length() + 1 > maxWidth)) {\\n                result.add(formatHelper(row, len, maxWidth, false));\\n                row = new ArrayList<String>();\\n                len = 0;\\n            } else {\\n                row.add(word);\\n                if (len == 0) {\\n                    len += word.length();\\n                } else {\\n                    len += (word.length() + 1);\\n                }\\n                index++;\\n            }\\n        }\\n        if (!row.isEmpty()) {\\n            result.add(formatHelper(row, len, maxWidth, true));\\n        }\\n        return result;\\n    }\\n\\n    private String formatHelper(List<String> row, int len, int maxWidth, boolean isLastRow) {\\n        StringBuilder result = new StringBuilder();\\n        int diff = maxWidth - len;\\n        int interLen = (row.size() > 1) ? (diff / (row.size() - 1)) : diff;\\n        StringBuilder interString = new StringBuilder();\\n        for (int i = 0; i < interLen; i++) {\\n            interString.append(\" \");\\n        }\\n        int largerInterCount = diff - interLen * (row.size() == 1 ? 1 : (row.size() - 1));\\n        for (int i = 0; i < row.size(); i++) {\\n            result.append(row.get(i));\\n            if (isLastRow) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n            } else if (i < row.size() - 1 || row.size() == 1) {\\n                if (i < row.size() - 1) {\\n                    result.append(\" \");\\n                }\\n                result.append(interString);\\n                if (largerInterCount-- > 0) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        if (isLastRow) {\\n            while (result.length() < maxWidth) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742430,
                "title": "c-solution-with-inline-comments",
                "content": "**For Details see inline comments in the following code:**\\nm --> Number of words.\\nn --> Total number of characters.\\n**Time Complexity:** O(mn)\\n**Space complexity:**  O(mn)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        \\n        for(int i = 0, w; i < n; i = w) {\\n            // Length of text with 1 space (except at end of a line)              \\n            int len = -1; // last word in a line doesn\\'t require space at end.\\n            // Check how much can be accomodated in a line\\n            for(w = i; w < n && len + words[w].length() + 1 <= maxWidth; w++) {\\n                len += words[w].length() + 1;\\n            }\\n            \\n            string str = words[i];\\n            \\n            // Initially only one space and zero extra spaces.\\n            int space = 1, extra = 0;\\n            if(w != i + 1 && w != words.size()) { // not 1 string, not last line -> ###\\n                // Spaces remaining at end -> (maxWidth - len)\\n                // Slots --> (w - i - 1)\\n                space = (maxWidth - len) / (w - i - 1) + 1;\\n                extra = (maxWidth - len) % (w - i - 1);\\n            }\\n            \\n            // Debug Info: (Uncomment to see)\\n            // cout<<\"w: \"<<w<<\" \";\\n            // cout<<\"len: \"<<len<<\" \";\\n            // cout<<\"space: \"<<space<<\" \";\\n            // cout<<\"extra: \"<<extra<<endl;\\n            \\n            // Adjust spaces remaining in slots \\n            for(int j = i + 1; j < w; ++j) {\\n                for(int s = space; s > 0; s--) str += \\' \\';\\n                // Put extra spaces in left aligned manner as we going left to right\\n                if(extra-- > 0) str += \\' \\';\\n                str += words[j];\\n            }\\n            \\n            // Putting extra spaces for last line -> ###\\n            int strLen = maxWidth - str.length();\\n            while(strLen-- > 0) str += \\' \\';\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        \\n        for(int i = 0, w; i < n; i = w) {\\n            // Length of text with 1 space (except at end of a line)              \\n            int len = -1; // last word in a line doesn\\'t require space at end.\\n            // Check how much can be accomodated in a line\\n            for(w = i; w < n && len + words[w].length() + 1 <= maxWidth; w++) {\\n                len += words[w].length() + 1;\\n            }\\n            \\n            string str = words[i];\\n            \\n            // Initially only one space and zero extra spaces.\\n            int space = 1, extra = 0;\\n            if(w != i + 1 && w != words.size()) { // not 1 string, not last line -> ###\\n                // Spaces remaining at end -> (maxWidth - len)\\n                // Slots --> (w - i - 1)\\n                space = (maxWidth - len) / (w - i - 1) + 1;\\n                extra = (maxWidth - len) % (w - i - 1);\\n            }\\n            \\n            // Debug Info: (Uncomment to see)\\n            // cout<<\"w: \"<<w<<\" \";\\n            // cout<<\"len: \"<<len<<\" \";\\n            // cout<<\"space: \"<<space<<\" \";\\n            // cout<<\"extra: \"<<extra<<endl;\\n            \\n            // Adjust spaces remaining in slots \\n            for(int j = i + 1; j < w; ++j) {\\n                for(int s = space; s > 0; s--) str += \\' \\';\\n                // Put extra spaces in left aligned manner as we going left to right\\n                if(extra-- > 0) str += \\' \\';\\n                str += words[j];\\n            }\\n            \\n            // Putting extra spaces for last line -> ###\\n            int strLen = maxWidth - str.length();\\n            while(strLen-- > 0) str += \\' \\';\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2701534,
                "title": "simle-java-solution",
                "content": "This is my intuitive and somple solution on Java:\\n\\n```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> processedStrings = new ArrayList<>();\\n        int width = 0, wordsCount = 0;\\n\\n        for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {\\n            width += words[wordIndex].length();\\n            wordsCount++;\\n\\n            if (wordIndex == words.length - 1\\n                    || width + words[wordIndex + 1].length() + wordsCount - 1 >= maxWidth) {\\n                int allSpaces = maxWidth - width;\\n                StringBuilder processedString = new StringBuilder();\\n\\n                while (--wordsCount >= 0) {\\n                    processedString.append(words[wordIndex - wordsCount]);\\n                    int spaces = wordIndex == words.length - 1\\n                            ? 1\\n                            : (int) Math.ceil((double) allSpaces / wordsCount);\\n                    processedString.append(\" \".repeat(Math.max(0, Math.min(spaces, allSpaces))));\\n                    allSpaces -= spaces;\\n                }\\n\\n                processedString.append(\" \".repeat(Math.max(0, allSpaces)));\\n                processedStrings.add(processedString.toString());\\n                wordsCount = 0;\\n                width = 0;\\n            }\\n        }\\n\\n        return processedStrings;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> processedStrings = new ArrayList<>();\\n        int width = 0, wordsCount = 0;\\n\\n        for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {\\n            width += words[wordIndex].length();\\n            wordsCount++;\\n\\n            if (wordIndex == words.length - 1\\n                    || width + words[wordIndex + 1].length() + wordsCount - 1 >= maxWidth) {\\n                int allSpaces = maxWidth - width;\\n                StringBuilder processedString = new StringBuilder();\\n\\n                while (--wordsCount >= 0) {\\n                    processedString.append(words[wordIndex - wordsCount]);\\n                    int spaces = wordIndex == words.length - 1\\n                            ? 1\\n                            : (int) Math.ceil((double) allSpaces / wordsCount);\\n                    processedString.append(\" \".repeat(Math.max(0, Math.min(spaces, allSpaces))));\\n                    allSpaces -= spaces;\\n                }\\n\\n                processedString.append(\" \".repeat(Math.max(0, allSpaces)));\\n                processedStrings.add(processedString.toString());\\n                wordsCount = 0;\\n                width = 0;\\n            }\\n        }\\n\\n        return processedStrings;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616085,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] # Collections used to get all the lines.\\n        \\n        i = 0 # Index of the current word\\n        current_width = 0 # Keeps track of the current width we\\'ve processed for a given line.\\n        line = []\\n        \\n        while i < len(words):\\n            word = words[i]\\n            \\n\\t\\t\\t# Verify that the current_width + current word does not exceed the max width.\\n            if (current_width + len(word)) <= maxWidth:\\n                line.append(word)\\n                current_width += len(word) + 1 # Since all words must have a minimum of 1 space, that +1 is for the space\\n                i += 1\\n            else: \\n\\t\\t\\t\\t# We\\'ve reached the point where we can\\'t process any new words. So we process the line seen so far.\\n\\t\\t\\t\\t# Note: We don\\'t increment i here because we want to reprocess it for the next line.\\n                current_line = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Calculate the total number of spaces we need. In the if statement above, we added +1 for space between words.\\n\\t\\t\\t\\t# Here we\\'re removing all those for easier calculation in the future. That is what the + len(line) is for; 1 space per word.\\n                necessary_spaces = maxWidth - current_width + len(line) \\n                if len(line) == 1: # Edge case where the line only has 1 word.\\n                    current_line += line[0] + \" \" * necessary_spaces # Append all spaces at the end in this instance.\\n                else: # There\\'s more than 1 word in the line so we need to process all of them.\\n                    for j in range(len(line)):\\n                        line_word = line[j]\\n\\t\\t\\t\\t\\t\\t# So between each word we need to distribute spaces evenly. \\n\\t\\t\\t\\t\\t\\t# The intuition here is that, except for the last word, we\\'ll need to calculate how many spaces we need.\\n\\t\\t\\t\\t\\t\\t# Example: if you have these words for a line [\"This\", \"is\", \"an\"] with a maxWidth = 16\\n\\t\\t\\t\\t\\t\\t# there are 3 words and you need to divide it between 2 spaces: \"this\" and \"is\" and \"is\" and \"an\" so that means\\n\\t\\t\\t\\t\\t\\t# you need 8 spaces evenly. We use remaining_words below to calculate the required_spaces below using the logic seen below.\\n\\t\\t\\t\\t\\t\\t# For the last word in a line, we don\\'t need any spaces so it is always 0.\\n\\t\\t\\t\\t\\t\\t# We use the ceil function here because if maxWidth is odd, then we have to distribute to the left side first (or greedily).\\n                        remaining_words = len(line) - (j + 1)\\n                        required_spaces = ceil(necessary_spaces / remaining_words) if remaining_words else 0\\n                        current_line += line_word + \" \" * required_spaces\\n                        necessary_spaces -= required_spaces # Subtract from necessary spaces. In the example above it would take 8 -> 4.\\n\\t\\t\\t\\t\\t\\t\\n                lines.append(current_line) # Add the result of the current line.\\n                line = []\\n                current_width = 0\\n\\n\\t\\t# It\\'s possible that we have processed all the words, but have some left over in the line. So we\\'ll add the remainder.\\n\\t\\t# Based on the problem description we want to only add a space between each word here and then add any remaining\\n\\t\\t# spaces at the end.\\n        if line: \\n            necessary_spaces = maxWidth - current_width + 1\\n            current_line = \\' \\'.join(line) + \" \" * necessary_spaces\\n            lines.append(current_line)\\n        return lines\\n```\\n\\nSome optimizations exist. I\\'m using string concatenation for the current line, but appending to the list may be preferred,.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] # Collections used to get all the lines.\\n        \\n        i = 0 # Index of the current word\\n        current_width = 0 # Keeps track of the current width we\\'ve processed for a given line.\\n        line = []\\n        \\n        while i < len(words):\\n            word = words[i]\\n            \\n\\t\\t\\t# Verify that the current_width + current word does not exceed the max width.\\n            if (current_width + len(word)) <= maxWidth:\\n                line.append(word)\\n                current_width += len(word) + 1 # Since all words must have a minimum of 1 space, that +1 is for the space\\n                i += 1\\n            else: \\n\\t\\t\\t\\t# We\\'ve reached the point where we can\\'t process any new words. So we process the line seen so far.\\n\\t\\t\\t\\t# Note: We don\\'t increment i here because we want to reprocess it for the next line.\\n                current_line = \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Calculate the total number of spaces we need. In the if statement above, we added +1 for space between words.\\n\\t\\t\\t\\t# Here we\\'re removing all those for easier calculation in the future. That is what the + len(line) is for; 1 space per word.\\n                necessary_spaces = maxWidth - current_width + len(line) \\n                if len(line) == 1: # Edge case where the line only has 1 word.\\n                    current_line += line[0] + \" \" * necessary_spaces # Append all spaces at the end in this instance.\\n                else: # There\\'s more than 1 word in the line so we need to process all of them.\\n                    for j in range(len(line)):\\n                        line_word = line[j]\\n\\t\\t\\t\\t\\t\\t# So between each word we need to distribute spaces evenly. \\n\\t\\t\\t\\t\\t\\t# The intuition here is that, except for the last word, we\\'ll need to calculate how many spaces we need.\\n\\t\\t\\t\\t\\t\\t# Example: if you have these words for a line [\"This\", \"is\", \"an\"] with a maxWidth = 16\\n\\t\\t\\t\\t\\t\\t# there are 3 words and you need to divide it between 2 spaces: \"this\" and \"is\" and \"is\" and \"an\" so that means\\n\\t\\t\\t\\t\\t\\t# you need 8 spaces evenly. We use remaining_words below to calculate the required_spaces below using the logic seen below.\\n\\t\\t\\t\\t\\t\\t# For the last word in a line, we don\\'t need any spaces so it is always 0.\\n\\t\\t\\t\\t\\t\\t# We use the ceil function here because if maxWidth is odd, then we have to distribute to the left side first (or greedily).\\n                        remaining_words = len(line) - (j + 1)\\n                        required_spaces = ceil(necessary_spaces / remaining_words) if remaining_words else 0\\n                        current_line += line_word + \" \" * required_spaces\\n                        necessary_spaces -= required_spaces # Subtract from necessary spaces. In the example above it would take 8 -> 4.\\n\\t\\t\\t\\t\\t\\t\\n                lines.append(current_line) # Add the result of the current line.\\n                line = []\\n                current_width = 0\\n\\n\\t\\t# It\\'s possible that we have processed all the words, but have some left over in the line. So we\\'ll add the remainder.\\n\\t\\t# Based on the problem description we want to only add a space between each word here and then add any remaining\\n\\t\\t# spaces at the end.\\n        if line: \\n            necessary_spaces = maxWidth - current_width + 1\\n            current_line = \\' \\'.join(line) + \" \" * necessary_spaces\\n            lines.append(current_line)\\n        return lines\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564093,
                "title": "easy-to-understand-java-greedy-solution",
                "content": "I am going solve this problem using greedy approach.\\n\\nThe greedy approach involves having two pointers \"i\" and \"j\". We move our \"j\" pointer forward until we get to a point where the words in the line go over our \"maxWidth\" parameter. Once that occurs, we now know all of the words that are going to be inside of the line.\\n\\nNext, we will count the number of words we have in the line. If we have a single word OR we are on the last line, then we will be left justifying the line, otherwise we middle justify. To left justify a line, we take the difference between the total amount of word characters we have and our \"maxWidth\" and this will tell us how many spaces there needs to be inside of the line.\\nThere should only be a single space between each word, but the last word will have the rest of the unused spaces to the very right of it, causing the line to left justify properly. In order to middle justify, we take the the number of spaces needed and the number of sections of spaces required. To get the section number, we do \"j\" - \"i\" - 1. Then divide our spaces with the section number which gives us a number to evenly distribute the spaces in between each word in the line. If we have extra spaces, the spaces will be added to the left-most words from left to right.\\n\\nThe time and space complexity of our solution is going to be O(lines * maxWidth). We must iterate, for each potential line, to the \"maxWidth\" since the spaces will be repeated. Under the hood, the \"repeat\" function is just running a for loop duplicating the character.\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int n = words.length;\\n        int i=0,j,lineLength;\\n        while(i<n){\\n            j=i+1;\\n            lineLength=words[i].length();\\n          while(j<n&&(lineLength+words[j].length()+(j-i-1)<maxWidth))\\n            {\\n              lineLength+=words[j].length();\\n              j++;\\n            }\\n          int diff =maxWidth-lineLength;\\n          int noOfWords=j-i;\\n            if(noOfWords==1||j>=n)\\n                result.add(leftJustify(diff,noOfWords,words,i,j));\\n            else\\n                result.add(middleJustify(diff,noOfWords,words,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    public static String leftJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n        StringBuilder  leftJustifyAns = new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++){\\n           leftJustifyAns.append(\" \"+words[k]);\\n        }\\n       leftJustifyAns.append(\" \".repeat(spacesOnRight));\\n        return  leftJustifyAns.toString();\\n    }\\n    public static String middleJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n         StringBuilder  middleJustifyAns = new StringBuilder(words[i]);\\n       \\n        int spacesNeeded= j-i-1;\\n        int spaces =diff/spacesNeeded;\\n        int extraSpaces = diff%spaces;\\n        for(int k=i+1;k<j;++k){\\n            int spacesToApply=spaces+(extraSpaces-- > 0 ? 1 : 0);\\n            middleJustifyAns.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return  middleJustifyAns.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int n = words.length;\\n        int i=0,j,lineLength;\\n        while(i<n){\\n            j=i+1;\\n            lineLength=words[i].length();\\n          while(j<n&&(lineLength+words[j].length()+(j-i-1)<maxWidth))\\n            {\\n              lineLength+=words[j].length();\\n              j++;\\n            }\\n          int diff =maxWidth-lineLength;\\n          int noOfWords=j-i;\\n            if(noOfWords==1||j>=n)\\n                result.add(leftJustify(diff,noOfWords,words,i,j));\\n            else\\n                result.add(middleJustify(diff,noOfWords,words,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    public static String leftJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n        StringBuilder  leftJustifyAns = new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++){\\n           leftJustifyAns.append(\" \"+words[k]);\\n        }\\n       leftJustifyAns.append(\" \".repeat(spacesOnRight));\\n        return  leftJustifyAns.toString();\\n    }\\n    public static String middleJustify(int diff,int noOfWords,String[] words,int i,int j)\\n    {\\n         StringBuilder  middleJustifyAns = new StringBuilder(words[i]);\\n       \\n        int spacesNeeded= j-i-1;\\n        int spaces =diff/spacesNeeded;\\n        int extraSpaces = diff%spaces;\\n        for(int k=i+1;k<j;++k){\\n            int spacesToApply=spaces+(extraSpaces-- > 0 ? 1 : 0);\\n            middleJustifyAns.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return  middleJustifyAns.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418813,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Simulation***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int max_width) {\\n        \\n        int n = words.size();\\n        \\n        vector<string> res;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            int start = i;\\n            \\n            // total characters keeps track of count of included characters\\n            \\n            int total_characters = 0;\\n            \\n            // count_words keeps track of no. of included words\\n            \\n            int count_words = 0;\\n            \\n            // include the words \\n            \\n            while(i < n && total_characters + count_words + words[i].size() <= max_width)\\n            {\\n                total_characters += words[i].size();\\n                \\n                count_words++;\\n                \\n                i++;\\n            }\\n            \\n            // calculate the no. of spaces we have to insert\\n           \\n            int total_spaces = max_width - total_characters;\\n            \\n            // if no. of words included = 1, then provide all the spaces after the word\\n            \\n            if(count_words == 1)\\n            {\\n                string temp_res = \"\";\\n                \\n                // append the word\\n                \\n                temp_res += words[start];\\n                \\n                // now append the spaces\\n                \\n                string space(total_spaces, \\' \\');\\n                \\n                temp_res += space;\\n                \\n                res.push_back(temp_res);\\n                \\n                continue;\\n            }\\n            \\n            // if no. of word is more than 1\\n            \\n            // 1st provide equal spaces between words, then distribute the remaining spaces \\n            \\n            // no. of places where space will be provided is = total words - 1\\n            \\n            int equal_spaces = total_spaces / (count_words - 1);\\n            \\n            int rem_spaces = total_spaces % (count_words - 1);\\n            \\n            // create a spaces array, which will store the no. of spaces provided between words from left side\\n            \\n            vector<int> spaces(count_words - 1, equal_spaces);\\n            \\n            // distribute the rem spaces from left to right\\n            \\n            int j = 0;\\n            \\n            while(rem_spaces)\\n            {\\n                spaces[j++] += 1;\\n                \\n                rem_spaces--;\\n            }  \\n            \\n            // j will point to the index of spaces array\\n            \\n            j = 0;\\n            \\n            string temp_res = \"\";\\n            \\n            // 1st case, if the text is not in the last line\\n            \\n            if(i < n)\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide the spaces\\n                    \\n                    if(j < spaces.size())\\n                    {\\n                        string space(spaces[j++], \\' \\');\\n                        \\n                        temp_res += space;\\n                    } \\n                }\\n            }\\n            \\n            // second case if the text is in the last line\\n            \\n            else\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide spaces\\n                    \\n                    temp_res += \\' \\';\\n                    \\n                    // decrement the spaces\\n                    \\n                    total_spaces--;\\n                }\\n                \\n                // if the total_spaces <= 0, then pop the last extra space\\n                \\n                if(total_spaces <= 0)\\n                {\\n                    temp_res.pop_back();\\n                }\\n                \\n                // otherwise push the spaces into temp_res\\n                \\n                else\\n                {\\n                    string space(total_spaces, \\' \\');\\n                    \\n                    temp_res += space;\\n                } \\n            }\\n            \\n            // push the temp_res into res array\\n            \\n            res.push_back(temp_res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int max_width) {\\n        \\n        int n = words.size();\\n        \\n        vector<string> res;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            int start = i;\\n            \\n            // total characters keeps track of count of included characters\\n            \\n            int total_characters = 0;\\n            \\n            // count_words keeps track of no. of included words\\n            \\n            int count_words = 0;\\n            \\n            // include the words \\n            \\n            while(i < n && total_characters + count_words + words[i].size() <= max_width)\\n            {\\n                total_characters += words[i].size();\\n                \\n                count_words++;\\n                \\n                i++;\\n            }\\n            \\n            // calculate the no. of spaces we have to insert\\n           \\n            int total_spaces = max_width - total_characters;\\n            \\n            // if no. of words included = 1, then provide all the spaces after the word\\n            \\n            if(count_words == 1)\\n            {\\n                string temp_res = \"\";\\n                \\n                // append the word\\n                \\n                temp_res += words[start];\\n                \\n                // now append the spaces\\n                \\n                string space(total_spaces, \\' \\');\\n                \\n                temp_res += space;\\n                \\n                res.push_back(temp_res);\\n                \\n                continue;\\n            }\\n            \\n            // if no. of word is more than 1\\n            \\n            // 1st provide equal spaces between words, then distribute the remaining spaces \\n            \\n            // no. of places where space will be provided is = total words - 1\\n            \\n            int equal_spaces = total_spaces / (count_words - 1);\\n            \\n            int rem_spaces = total_spaces % (count_words - 1);\\n            \\n            // create a spaces array, which will store the no. of spaces provided between words from left side\\n            \\n            vector<int> spaces(count_words - 1, equal_spaces);\\n            \\n            // distribute the rem spaces from left to right\\n            \\n            int j = 0;\\n            \\n            while(rem_spaces)\\n            {\\n                spaces[j++] += 1;\\n                \\n                rem_spaces--;\\n            }  \\n            \\n            // j will point to the index of spaces array\\n            \\n            j = 0;\\n            \\n            string temp_res = \"\";\\n            \\n            // 1st case, if the text is not in the last line\\n            \\n            if(i < n)\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide the spaces\\n                    \\n                    if(j < spaces.size())\\n                    {\\n                        string space(spaces[j++], \\' \\');\\n                        \\n                        temp_res += space;\\n                    } \\n                }\\n            }\\n            \\n            // second case if the text is in the last line\\n            \\n            else\\n            {\\n                for(int k = start; k < i; k++)\\n                {\\n                    // push the word into temp res\\n                    \\n                    temp_res += words[k];\\n                    \\n                    // provide spaces\\n                    \\n                    temp_res += \\' \\';\\n                    \\n                    // decrement the spaces\\n                    \\n                    total_spaces--;\\n                }\\n                \\n                // if the total_spaces <= 0, then pop the last extra space\\n                \\n                if(total_spaces <= 0)\\n                {\\n                    temp_res.pop_back();\\n                }\\n                \\n                // otherwise push the spaces into temp_res\\n                \\n                else\\n                {\\n                    string space(total_spaces, \\' \\');\\n                    \\n                    temp_res += space;\\n                } \\n            }\\n            \\n            // push the temp_res into res array\\n            \\n            res.push_back(temp_res);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338338,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int L) {\\n         vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int L) {\\n         vector<string> res;\\n    for(int i = 0, k, l; i < words.size(); i += k) {\\n        for(k = l = 0; i + k < words.size() and l + words[i+k].size() <= L - k; k++) {\\n            l += words[i+k].size();\\n        }\\n        string tmp = words[i];\\n        for(int j = 0; j < k - 1; j++) {\\n            if(i + k >= words.size()) tmp += \" \";\\n            else tmp += string((L - l) / (k - 1) + (j < (L - l) % (k - 1)), \\' \\');\\n            tmp += words[i+j+1];\\n        }\\n        tmp += string(L - tmp.size(), \\' \\');\\n        res.push_back(tmp);\\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192845,
                "title": "java-solution-with-o-n-time-o-1-space-complexity",
                "content": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(int i=0; i<words.length; i++) {\\n            StringBuilder line = new StringBuilder();\\n            int len = 0;\\n            int wlen =0;\\n            int start=i;\\n            int end = i;\\n            while(end<words.length && len + words[end].length() <= maxWidth) {\\n                len += words[end].length()+1;\\n                wlen += words[end].length();\\n                end++;\\n            }\\n            int gaps = end - start - 1;\\n            int padding = end == words.length ? gaps : maxWidth-wlen;\\n\\n            int spacing = gaps == 0 ? 1 : padding / gaps;\\n            int extraSpace = gaps != 0 ? padding % gaps : 0;\\n            for(int j=start; j<end; j++) {\\n                line.append(words[j]);\\n                if(j!= end-1) {\\n                    line.append(\" \".repeat(spacing));\\n                }\\n                if(extraSpace>0) {\\n                    line.append(\" \");\\n                    extraSpace--;\\n                }\\n            }\\n            while(line.length() < maxWidth) {\\n                line.append(\" \");\\n            }\\n            i = end-1;\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(int i=0; i<words.length; i++) {\\n            StringBuilder line = new StringBuilder();\\n            int len = 0;\\n            int wlen =0;\\n            int start=i;\\n            int end = i;\\n            while(end<words.length && len + words[end].length() <= maxWidth) {\\n                len += words[end].length()+1;\\n                wlen += words[end].length();\\n                end++;\\n            }\\n            int gaps = end - start - 1;\\n            int padding = end == words.length ? gaps : maxWidth-wlen;\\n\\n            int spacing = gaps == 0 ? 1 : padding / gaps;\\n            int extraSpace = gaps != 0 ? padding % gaps : 0;\\n            for(int j=start; j<end; j++) {\\n                line.append(words[j]);\\n                if(j!= end-1) {\\n                    line.append(\" \".repeat(spacing));\\n                }\\n                if(extraSpace>0) {\\n                    line.append(\" \");\\n                    extraSpace--;\\n                }\\n            }\\n            while(line.length() < maxWidth) {\\n                line.append(\" \");\\n            }\\n            i = end-1;\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176270,
                "title": "javascript-simple-commented-iterative-solution",
                "content": "Based on [this solution](https://leetcode.com/problems/text-justification/discuss/446139/Well-commented-JavaScript-solution)\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\n**Intuition**\\n\\nAs we iterate through the words to form a line, we need to keep track of two things:\\n\\n1) How much space is left in that line\\n2) The words we\\'ve used so far in the line\\n\\nFor the space left, we can start with the `maxWidth` and decrease it by the length of any newly added word and the space needed to separate it from the previous word.  We can use an array to keep track of the words added so far to the line and perform a simple join operation later on to construct the line with a space between each word.  If a new word would cause the line to exceed the `maxWidth`, we can justify the existing line and start a new line with that word.\\n\\nThe tricky part comes from figuring out how to justify a line.  If a line only has a single word, it\\'s treated like the final line in which the word is left justified and any remaining space is added to the end.  If there\\'s more than one word, we\\'ll need to iteratively add the space remaining to each letter at a time which can be accomplished with a while loop that keeps track of which index in the array of words we should be on in each iteration.\\n\\nAfter we exit the for loop, we\\'ve finished checking each word, but if the line array still has words in it, we treat it as the final line in which everything needs to be left justified and whatever is left is filled with trailing spaces.  We simply join the words with an empty space and add on the difference between `maxWidth` and the length of the words + the spaces between them.\\n\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let line = [words[0]];\\n\\t// spaceLeft will keep track of the trailing space left after\\n\\t// accounting for both the length of the words and the spaces between them\\n    let spaceLeft = maxWidth - words[0].length;\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        // Only add a new word to the line if\\n        // there\\'s enough space for it and the \\n        // space before it.\\n        const word = words[i];\\n        if (spaceLeft >= word.length + 1) {\\n            line.push(word);\\n            spaceLeft -= (word.length + 1);\\n        } else {\\n\\t\\t\\t// There\\'s not enough space left for the word\\n\\t\\t\\t// and the space before it.  Justify the existing\\n\\t\\t\\t// line and start a new line with the word.\\n            res.push(justifyLine(line, spaceLeft));\\n            line = [word];\\n            spaceLeft = maxWidth - word.length;\\n        }\\n    }\\n    \\n    // We\\'ve added the final word but there\\'s still space \\n    // left. In this case, we justify the line left and add\\n    // all the left over space to the end of the line.\\n    if (line.length) {\\n        let lastLine = line.join(\\' \\');\\n        lastLine += \\' \\'.repeat(maxWidth - lastLine.length);\\n        res.push(lastLine);\\n    }\\n    \\n    return res;\\n};\\n\\nconst justifyLine = (line, spaceLeft) => {\\n    // Remember, if there\\'s only a single word, it\\'s treated\\n\\t// as being left justified so all the spaces are added to the end\\n\\tif (line.length === 1) {\\n        return line[0] + \\' \\'.repeat(spaceLeft);\\n    }\\n    \\n    // The total amount of spacing will be the spaces\\n    // between words and the space left. Since we can let\\n    // the join operation take care of the spaces between\\n    // words, we only need to add the space left.\\n    let i = 0;\\n    while (spaceLeft > 0) {\\n        line[i] += \\' \\';\\n        // We don\\'t want to add a space to the final word\\n        // so when we reach it, we loop back to the start\\n        i = (i + 1) % (line.length - 1);\\n        spaceLeft--;\\n    }\\n    \\n    return line.join(\\' \\');\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9862f77b-4ef5-4cba-9de3-a64aeb7ef0d1_1655759410.4639826.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function(words, maxWidth) {\\n    const res = [];\\n    let line = [words[0]];\\n\\t// spaceLeft will keep track of the trailing space left after\\n\\t// accounting for both the length of the words and the spaces between them\\n    let spaceLeft = maxWidth - words[0].length;\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        // Only add a new word to the line if\\n        // there\\'s enough space for it and the \\n        // space before it.\\n        const word = words[i];\\n        if (spaceLeft >= word.length + 1) {\\n            line.push(word);\\n            spaceLeft -= (word.length + 1);\\n        } else {\\n\\t\\t\\t// There\\'s not enough space left for the word\\n\\t\\t\\t// and the space before it.  Justify the existing\\n\\t\\t\\t// line and start a new line with the word.\\n            res.push(justifyLine(line, spaceLeft));\\n            line = [word];\\n            spaceLeft = maxWidth - word.length;\\n        }\\n    }\\n    \\n    // We\\'ve added the final word but there\\'s still space \\n    // left. In this case, we justify the line left and add\\n    // all the left over space to the end of the line.\\n    if (line.length) {\\n        let lastLine = line.join(\\' \\');\\n        lastLine += \\' \\'.repeat(maxWidth - lastLine.length);\\n        res.push(lastLine);\\n    }\\n    \\n    return res;\\n};\\n\\nconst justifyLine = (line, spaceLeft) => {\\n    // Remember, if there\\'s only a single word, it\\'s treated\\n\\t// as being left justified so all the spaces are added to the end\\n\\tif (line.length === 1) {\\n        return line[0] + \\' \\'.repeat(spaceLeft);\\n    }\\n    \\n    // The total amount of spacing will be the spaces\\n    // between words and the space left. Since we can let\\n    // the join operation take care of the spaces between\\n    // words, we only need to add the space left.\\n    let i = 0;\\n    while (spaceLeft > 0) {\\n        line[i] += \\' \\';\\n        // We don\\'t want to add a space to the final word\\n        // so when we reach it, we loop back to the start\\n        i = (i + 1) % (line.length - 1);\\n        spaceLeft--;\\n    }\\n    \\n    return line.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033072,
                "title": "python-easy-solution-explanation-faster-than-92-03-o-n",
                "content": "\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:    \\n        justified = []\\n        currRow = [] # the current row of strings that fit in maxWidth accounting for additional spaces\\n\\t\\t\\n        for i in range(len(words)):\\n            space = maxWidth # track space available\\n            space_occupied = 0 # track space taken\\n            for j in range(len(currRow)):\\n                wordLength = len(currRow[j])\\n                space_occupied += wordLength\\n                space -= wordLength\\n            \\n            # adjust for the spaces needed for each word which is the number of words - 1\\n            space -= len(currRow) - 1\\n            \\n            # if there is still space for another word and a space\\n            # append the word to the current row\\n            if space >= len(words[i]) + 1:\\n                currRow.append(words[i])\\n                \\n            # if not, append the justified row and assign the word the current row as the first  and only element\\n            else:\\n                row = self.justifyRow(currRow, maxWidth, space_occupied)\\n                justified.append(row)\\n                currRow = [words[i]]\\n               \\n\\t\\t# append the last row justifying it left\\n        if len(currRow) > 0:\\n            last = \"\"\\n            for i in range(len(currRow)):\\n                last += currRow[i] + \" \" if len(last) + len(currRow[i]) < maxWidth else currRow[i]\\n            justified.append(last.ljust(maxWidth))\\n            \\n        return justified\\n                \\n    # justifies the row given the row, max width, and the space occupied\\n    def justifyRow(self, row: List[str], maxWidth: int, space_occupied: int) -> str:\\n        length = len(row)\\n\\t\\t# return left justified if it is the only word in the row\\n        if length == 1:\\n            return row[0].ljust(maxWidth)\\n        else:\\n            justifiedRow = \"\"\\n            space_avail = maxWidth - space_occupied\\n            additional = space_avail % (length - 1)  # number of additional spaces needed for unevenness\\n            space_between = space_avail // (length - 1)  # the base number of spaces in between each word\\n            for i in range(length):\\n                justLen = len(row[i]) + space_between  # number of spaces for each word without additional\\n                # if there are additional spaces left, append it to the current word\\n\\t\\t\\t\\tif additional > 0:\\n                    justifiedRow += row[i].ljust(justLen + 1)\\n                    additional -= 1\\n\\t\\t\\t\\t# since all words and their spaces in between are accounted for, append the last word\\n                elif i == length - 1:\\n                    justifiedRow += row[i]\\n\\t\\t\\t\\t# everything else needs to add the space between\\n                else:\\n                    justifiedRow += row[i].ljust(justLen)\\n            \\n            return justifiedRow",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:    \\n        justified = []\\n        currRow = [] # the current row of strings that fit in maxWidth accounting for additional spaces\\n\\t\\t\\n        for i in range(len(words)):\\n            space = maxWidth # track space available\\n            space_occupied = 0 # track space taken\\n            for j in range(len(currRow)):\\n                wordLength = len(currRow[j])\\n                space_occupied += wordLength\\n                space -= wordLength\\n            \\n            # adjust for the spaces needed for each word which is the number of words - 1\\n            space -= len(currRow) - 1\\n            \\n            # if there is still space for another word and a space\\n            # append the word to the current row\\n            if space >= len(words[i]) + 1:\\n                currRow.append(words[i])\\n                \\n            # if not, append the justified row and assign the word the current row as the first  and only element\\n            else:\\n                row = self.justifyRow(currRow, maxWidth, space_occupied)\\n                justified.append(row)\\n                currRow = [words[i]]\\n               \\n\\t\\t# append the last row justifying it left\\n        if len(currRow) > 0:\\n            last = \"\"\\n            for i in range(len(currRow)):\\n                last += currRow[i] + \" \" if len(last) + len(currRow[i]) < maxWidth else currRow[i]\\n            justified.append(last.ljust(maxWidth))\\n            \\n        return justified\\n                \\n    # justifies the row given the row, max width, and the space occupied\\n    def justifyRow(self, row: List[str], maxWidth: int, space_occupied: int) -> str:\\n        length = len(row)\\n\\t\\t# return left justified if it is the only word in the row\\n        if length == 1:\\n            return row[0].ljust(maxWidth)\\n        else:\\n            justifiedRow = \"\"\\n            space_avail = maxWidth - space_occupied\\n            additional = space_avail % (length - 1)  # number of additional spaces needed for unevenness\\n            space_between = space_avail // (length - 1)  # the base number of spaces in between each word\\n            for i in range(length):\\n                justLen = len(row[i]) + space_between  # number of spaces for each word without additional\\n                # if there are additional spaces left, append it to the current word\\n\\t\\t\\t\\tif additional > 0:\\n                    justifiedRow += row[i].ljust(justLen + 1)\\n                    additional -= 1\\n\\t\\t\\t\\t# since all words and their spaces in between are accounted for, append the last word\\n                elif i == length - 1:\\n                    justifiedRow += row[i]\\n\\t\\t\\t\\t# everything else needs to add the space between\\n                else:\\n                    justifiedRow += row[i].ljust(justLen)\\n            \\n            return justifiedRow",
                "codeTag": "Python3"
            },
            {
                "id": 2023640,
                "title": "simple-java-solution-with-detailed-explanation",
                "content": "Break this problem into two parts.\\n1. Separate the words for each line\\n2. Format each line by applying text alignment (Either middle alignment or left alignment)\\n\\n# Now Lets see how can we separate words from the input per line.\\nSuppose our input looks like below\\n**Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16**\\nThe output will be like below\\n**\"This    is    an\",\\n\"example  of text\",\\n\"justification.  \"**\\n\\nSo for each line we may have multiple words(String). So lets declare a List which items is aslo a list to store our word. Again the end result will be just a plain string list. Lets define also\\n```\\nList<List<String>> lines = new ArrayList<>();\\nList<String> result = new ArrayList<>();\\n```\\n\\nNow how we are going to pick word for a line? Suppose you have a word and a line. You can place this word in that line if after adding the word total size of this line (Total character) will not increase the maxWidth. So suppose you picked that word. Now for the next word you need to know how many remaining characters you have. So we need to track the remaining characters per line. Initially remaining characters will be maxWidth. So inside a map we the key will be line index and value will be the remaining characters.\\n\\nLets declare the map as well as insert initial value for the lines and remaining characters for that line like below\\n```\\nint currentLine = 0;\\nlines.add(new ArrayList<String>());\\ncharMap.put(currentLine, maxWidth);\\n```\\n\\nNow we have the initial setup. In which line we are adding the next word will be determined by **currentLine** variable. Iniially it is 0 as we are filling from the first line (index 0).\\n\\nNow we loop through all the words and try to put those words in the line. \\n```\\nfor (String word : words) {\\n     int remainingChar = charMap.get(currentLine);\\n     if (word.length() <= remainingChar) {\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      } else {\\n         currentLine++;\\n         lines.add(new ArrayList<String>());\\n         charMap.put(currentLine, maxWidth);\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      }\\n}\\n```\\n\\nThats it. So what we did? Initially currentLine = 0 and at first we inserted maxWidth for the 0 in the **charMap**. So remainingChar is 16 here. Now we are checking if **current word <= remainingChar** . If it is we will add this word in the line by calling the function addWordToLine. \\n\\nIf not that means we need a new line. Right? So we are incrementing the currentLine number adding a new ArrayList in the lines as well as remainingCharacter for that line. So we have a new line setup. Now we can call addWordToLine() function to add the word in the line.\\n\\n**Now lets look what is happening inside addWordToLine function.**\\n\\n```\\n public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }\\n```\\n\\nAs this function called, we know that we can add the word. So added the word in the first line. As we added the word we need to subtract the word length from the remainingChar. So we did that in the second line.\\n\\nNow we have a very crucial trick here. After adding a word it may cover the maxLength. Its ok. But if we have more space left then a new word can come in this line next. So between two words we must seprate them by a space. Right? So if for this line if we have space left we will consider a space. Hence, we subtracted 1 from the remainingChar. (This is important. If you find difficult read this paragraph and rethink multiple times.) \\n\\nSo we have separated all the words based on lines. Now we need to format those line to generate the output.\\n\\n# Lets see how can we format the lines?\\n```\\n public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n```\\n\\nSimple function. Right? Now think when you will do left justification and when midddle justification? If a line contains only one word it will be left justified or left aligned. Also if a line is the last line it will be left justified. So we did this here. For the alignment we passing the line and maxWidth to two separate function **makeLeftAligned** and **makeMiddleAligned**\\n\\n**Now first see what is happening inside makeLeftAligned function**\\nPreviously in a line list we just added the string but did not added any spaces. Now we have to add spaces between word as well as space in the end if required.\\n\\n```\\n ublic String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n```\\n\\nI think you understand what I did. First we called a function **getCharacterCount** which just return the total word. You can optmize here. You can calculate this while adding word in the line in the first method. However, I did like this to keep my code clean. Here is the getCharacterCount function\\n\\n```\\n private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\\n\\nSo we first get the actual character count. Then we subtracted it from maxWidth to get the remainingCharacter. This we need to fill with spacea. So for each character we are adding a space and we decrementing the remainingPos variable. So we added one space between words. But we may have remaining position in the end. So we fill those position with space inside while loop.\\n\\n**Now see what we did inside makeMiddleAligned function?**\\n\\n```\\n public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n```\\n\\nFirst calculated the remainingChar which we need to fillup. In case of middle alignment it is littlle bit tricky. We need to add spaces between words. So we could not add space after last word. Now how can we know how many space we need to add after each word? Again remainingChar can be odd number. So how we are going to distribute those spaces?\\n\\nDon\\'t worry. Space after each word will be\\nint spaces = Ceil(remainingChar / (wordCountPerLine - i - 1))\\nWhy we are doing that? If we have 3 word we are putting the spaces before two words or we can say after two words. So thats why -1. Now why -i? Suppose we have 5 remainingChar and wordCountPerLine = 3.\\nSo after adding 1 word to stringbuilder it will go inside if and i = 0 so\\nspaces = Ceil(5 / ( 3 - 0 - 1) )\\nspaces = Ceil (5 / 2)\\nspaces = 3\\n\\nSo after the first word it will put three spaces and we subtract this from remainChar as it has been full filled with spaces.\\nremainChar = 5 - 3 = 2\\nNow when i = 1 means adding another word what will happen?\\nspaces = Ceil (2 / (3 - 1 - 1))\\nspaces = Ceil (2 / 1)\\nspaces = 2\\n\\nSo we need to give 2 spaces. After that remainingChar will be 0. \\n\\nNow we can return the result. Lets look the whole code at once\\n\\n```\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> lines = new ArrayList<>();\\n        List<String> result = new ArrayList<>();\\n        Map<Integer, Integer> charMap = new HashMap<>();\\n        int currentLine = 0;\\n        \\n        lines.add(new ArrayList<String>());\\n        charMap.put(currentLine, maxWidth);\\n        \\n        for (String word : words) {\\n            int remainingChar = charMap.get(currentLine);\\n            if (word.length() <= remainingChar) {\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            } else {\\n                currentLine++;\\n                lines.add(new ArrayList<String>());\\n                charMap.put(currentLine, maxWidth);\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            }\\n        }\\n            \\n        formatLines(lines, result, maxWidth);\\n        return result;\\n    }\\n    \\n    public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }              \\n    \\n    public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n    \\n    public String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\\n\\nIt looks large. But if you break down the problem multiple steps you can unit test each and every function and can check your logic. \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nList<List<String>> lines = new ArrayList<>();\\nList<String> result = new ArrayList<>();\\n```\n```\\nint currentLine = 0;\\nlines.add(new ArrayList<String>());\\ncharMap.put(currentLine, maxWidth);\\n```\n```\\nfor (String word : words) {\\n     int remainingChar = charMap.get(currentLine);\\n     if (word.length() <= remainingChar) {\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      } else {\\n         currentLine++;\\n         lines.add(new ArrayList<String>());\\n         charMap.put(currentLine, maxWidth);\\n         addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n      }\\n}\\n```\n```\\n public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }\\n```\n```\\n public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n```\n```\\n ublic String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n```\n```\\n private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```\n```\\n public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n```\n```\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<List<String>> lines = new ArrayList<>();\\n        List<String> result = new ArrayList<>();\\n        Map<Integer, Integer> charMap = new HashMap<>();\\n        int currentLine = 0;\\n        \\n        lines.add(new ArrayList<String>());\\n        charMap.put(currentLine, maxWidth);\\n        \\n        for (String word : words) {\\n            int remainingChar = charMap.get(currentLine);\\n            if (word.length() <= remainingChar) {\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            } else {\\n                currentLine++;\\n                lines.add(new ArrayList<String>());\\n                charMap.put(currentLine, maxWidth);\\n                addWordToLine(currentLine, lines, charMap, word, maxWidth);\\n            }\\n        }\\n            \\n        formatLines(lines, result, maxWidth);\\n        return result;\\n    }\\n    \\n    public void addWordToLine(\\n        Integer currentLine, \\n        List<List<String>> lines, \\n        Map<Integer, Integer> charMap, \\n        String word,\\n        int maxWidth) {\\n        \\n        lines.get(currentLine).add(word);\\n        // Now change remaining and add space if required\\n        charMap.put(currentLine, charMap.get(currentLine) - word.length());\\n       \\n        // We have to add a space if at least one position left otherwise we\\n        // can not add a new word. So subtracting one from remaining character\\n        if (charMap.get(currentLine) != 0) {\\n            charMap.put(currentLine, charMap.get(currentLine) - 1);\\n        }\\n    }              \\n    \\n    public void formatLines(\\n        List<List<String>> lines, \\n        List<String> result, \\n        int maxWidth\\n    ) {\\n       for (int currentLine = 0; currentLine < lines.size(); currentLine++) {\\n           List<String> line = lines.get(currentLine);\\n           \\n           if (line.size() == 1 || currentLine == lines.size() - 1) {\\n               result.add(makeLeftAligned(line, maxWidth));\\n           } else {\\n               result.add(makeMiddleAligned(line, maxWidth));\\n           }\\n       }  \\n    }\\n    \\n    public String makeLeftAligned(List<String> words, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingPos = maxWidth - getCharacterCount(words);\\n        \\n        for (String word : words) {\\n            builder.append(word);\\n            if (remainingPos > 0) {\\n                builder.append(\\' \\');\\n                remainingPos--;\\n            }\\n        }\\n        \\n        while (remainingPos > 0) {\\n            builder.append(\\' \\');\\n            remainingPos--;\\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    public String makeMiddleAligned(List<String> line, int maxWidth) {\\n        StringBuilder builder = new StringBuilder();\\n        int remainingChar = maxWidth - getCharacterCount(line);\\n        \\n        for (int i = 0; i < line.size(); i++) {\\n            builder.append(line.get(i));\\n            \\n            // Do not add space after last word\\n            if (i != line.size() - 1) {\\n                int wordsRequiredSpaceCount = line.size() -i - 1;\\n                int spaces = (int) Math.ceil((double) remainingChar / (double) wordsRequiredSpaceCount);\\n                remainingChar -= spaces;\\n                \\n                for (int j = 0; j < spaces; j++) {\\n                    builder.append(\\' \\');\\n                }\\n            } \\n        }\\n        \\n        return builder.toString();\\n    }\\n    \\n    private int getCharacterCount(List<String> line) {\\n        int count = 0;\\n        for (String word : line) {\\n            count += word.length();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640627,
                "title": "java-much-more-readable-clean-1ms-solution-with-inline-comments",
                "content": "```\\n  public List<String> fullJustify(String[] words, int maxWidth) {\\n    var result = new ArrayList<String>();\\n    // Trick: Use queue and poll, cleaner way to collect & process words. No messy cursors\\n    // No need to renew too, naturally polled empty\\n    var wordList = new LinkedList<String>();\\n    var textWidth = 0;\\n\\n    for (int i = 0; i < words.length; ) {\\n      // Need minimum 1 whitespace btw words!\\n      // Trick: Use wordsToAdd.size to account for whitespaces, instead of +1 to width!\\n      // Naturally excludes last word\\'s, doesn\\'t include curr count.\\n      if (textWidth + words[i].length() + wordList.size() <= maxWidth) {\\n        textWidth += words[i].length();\\n        wordList.add(words[i]);\\n        i++;\\n        continue;\\n      }\\n\\n      var spacesInbtw = (maxWidth - textWidth) / Math.max(1, wordList.size() - 1);\\n      var extraSpaces = (maxWidth - textWidth) % Math.max(1, wordList.size() - 1);\\n\\n      var line = generateLine(wordList, maxWidth, spacesInbtw, extraSpaces--);\\n      result.add(line);\\n      textWidth = 0;\\n    }\\n\\n    var line = generateLine(wordList, maxWidth, 1, 0);\\n    result.add(line);\\n\\n    return result;\\n  }\\n\\n  private String generateLine(LinkedList<String> wordsToAdd, int maxWidth, int spacesBtw, int extraSpaces) {\\n    var line = new StringBuffer();\\n    var spaces = addSpaces(spacesBtw);\\n    while (wordsToAdd.size() > 0) {\\n      line.append(wordsToAdd.poll())\\n        .append(spaces)\\n        .append(extraSpaces-- > 0 ? \" \" : \"\");\\n    }\\n    // For filling last line\\n    line.append(addSpaces(maxWidth - line.length()));\\n    return line.substring(0, maxWidth);\\n  }\\n\\n  private String addSpaces(int spaceWidth) {\\n    var spaces = new StringBuffer();\\n    while (spaceWidth-- > 0) {\\n      spaces.append(\" \");\\n    }\\n    return spaces.toString();\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public List<String> fullJustify(String[] words, int maxWidth) {\\n    var result = new ArrayList<String>();\\n    // Trick: Use queue and poll, cleaner way to collect & process words. No messy cursors\\n    // No need to renew too, naturally polled empty\\n    var wordList = new LinkedList<String>();\\n    var textWidth = 0;\\n\\n    for (int i = 0; i < words.length; ) {\\n      // Need minimum 1 whitespace btw words!\\n      // Trick: Use wordsToAdd.size to account for whitespaces, instead of +1 to width!\\n      // Naturally excludes last word\\'s, doesn\\'t include curr count.\\n      if (textWidth + words[i].length() + wordList.size() <= maxWidth) {\\n        textWidth += words[i].length();\\n        wordList.add(words[i]);\\n        i++;\\n        continue;\\n      }\\n\\n      var spacesInbtw = (maxWidth - textWidth) / Math.max(1, wordList.size() - 1);\\n      var extraSpaces = (maxWidth - textWidth) % Math.max(1, wordList.size() - 1);\\n\\n      var line = generateLine(wordList, maxWidth, spacesInbtw, extraSpaces--);\\n      result.add(line);\\n      textWidth = 0;\\n    }\\n\\n    var line = generateLine(wordList, maxWidth, 1, 0);\\n    result.add(line);\\n\\n    return result;\\n  }\\n\\n  private String generateLine(LinkedList<String> wordsToAdd, int maxWidth, int spacesBtw, int extraSpaces) {\\n    var line = new StringBuffer();\\n    var spaces = addSpaces(spacesBtw);\\n    while (wordsToAdd.size() > 0) {\\n      line.append(wordsToAdd.poll())\\n        .append(spaces)\\n        .append(extraSpaces-- > 0 ? \" \" : \"\");\\n    }\\n    // For filling last line\\n    line.append(addSpaces(maxWidth - line.length()));\\n    return line.substring(0, maxWidth);\\n  }\\n\\n  private String addSpaces(int spaceWidth) {\\n    var spaces = new StringBuffer();\\n    while (spaceWidth-- > 0) {\\n      spaces.append(\" \");\\n    }\\n    return spaces.toString();\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518515,
                "title": "c-90-speed",
                "content": "I never see .NET code on here so here is my C# version. I tried to break out the functions to make it easier to read.\\n\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> retval = new List<string>();\\n        \\n        List<string> lwords = new List<string>();\\n        int sublen = 0;\\n        int words_len = 0;\\n        foreach(string word in words){\\n            sublen += word.Length + 1;\\n            //\\'+1\\' is for the space added above\\n            if(sublen > maxWidth + 1){ \\n                string line = BuildLine(lwords, maxWidth, words_len);\\n                retval.Add(line);\\n                lwords.Clear();\\n                //Remember to add back in the current word\\n                sublen = word.Length + 1;\\n                words_len = 0;\\n            }\\n            lwords.Add(word);     \\n            words_len += word.Length;       \\n        }\\n        \\n        //Do any remaining words\\n        if(lwords.Count() > 0 ){\\n            string line = \"\";\\n            foreach(string word in lwords){\\n                line += $\"{word} \";\\n            }\\n            //NOTE: \\'Trim()\\' is to remove the space on the last word\\n            line = line.Trim().PadRight(maxWidth);\\n            retval.Add(line);\\n        }\\n        \\n        return retval;\\n    }\\n    \\n    private string BuildLine(List<string> words, int maxWidth, int words_len){\\n        int word_count = words.Count();\\n        int spaces = maxWidth - words_len;\\n        \\n        //Special Cases: Handle a single or double word\\n        if(word_count == 1){\\n            return words[0].PadRight(maxWidth);\\n        }else if (word_count == 2){\\n            return words[0] + \"\".PadRight(spaces) + words[1];\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //Number of space blocks\\n        int num_of_spaces = word_count - 1;\\n        //spaces per space block\\n        int spaces_per_word = spaces / num_of_spaces;\\n        //Extra spaces\\n        int extra = spaces % num_of_spaces;\\n        \\n        for(int i = 0; i < word_count; i++){\\n            string word = words[i];\\n            sb.Append(word);\\n            //Append spaces except for the last word\\n            if( i != word_count - 1)\\n                sb.Append(\\' \\',spaces_per_word);\\n            //Check for extra spaces\\n            if( extra > 0 ){\\n                sb.Append(\\' \\',1);\\n                extra--;\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> retval = new List<string>();\\n        \\n        List<string> lwords = new List<string>();\\n        int sublen = 0;\\n        int words_len = 0;\\n        foreach(string word in words){\\n            sublen += word.Length + 1;\\n            //\\'+1\\' is for the space added above\\n            if(sublen > maxWidth + 1){ \\n                string line = BuildLine(lwords, maxWidth, words_len);\\n                retval.Add(line);\\n                lwords.Clear();\\n                //Remember to add back in the current word\\n                sublen = word.Length + 1;\\n                words_len = 0;\\n            }\\n            lwords.Add(word);     \\n            words_len += word.Length;       \\n        }\\n        \\n        //Do any remaining words\\n        if(lwords.Count() > 0 ){\\n            string line = \"\";\\n            foreach(string word in lwords){\\n                line += $\"{word} \";\\n            }\\n            //NOTE: \\'Trim()\\' is to remove the space on the last word\\n            line = line.Trim().PadRight(maxWidth);\\n            retval.Add(line);\\n        }\\n        \\n        return retval;\\n    }\\n    \\n    private string BuildLine(List<string> words, int maxWidth, int words_len){\\n        int word_count = words.Count();\\n        int spaces = maxWidth - words_len;\\n        \\n        //Special Cases: Handle a single or double word\\n        if(word_count == 1){\\n            return words[0].PadRight(maxWidth);\\n        }else if (word_count == 2){\\n            return words[0] + \"\".PadRight(spaces) + words[1];\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        //Number of space blocks\\n        int num_of_spaces = word_count - 1;\\n        //spaces per space block\\n        int spaces_per_word = spaces / num_of_spaces;\\n        //Extra spaces\\n        int extra = spaces % num_of_spaces;\\n        \\n        for(int i = 0; i < word_count; i++){\\n            string word = words[i];\\n            sb.Append(word);\\n            //Append spaces except for the last word\\n            if( i != word_count - 1)\\n                sb.Append(\\' \\',spaces_per_word);\\n            //Check for extra spaces\\n            if( extra > 0 ){\\n                sb.Append(\\' \\',1);\\n                extra--;\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456052,
                "title": "python-3-easy-implementation",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        bucket = []\\n        \\n        ans = []\\n        \\n        count = 0\\n        \\n        for word in words:\\n\\t\\t\\t#Keep track of total length so far including 1 space per word\\n            if count + len(bucket) + len(word) > maxWidth:\\n\\t\\t\\t\\t#Calculate total spaces needed\\n                spaces = maxWidth - count\\n                i = 0\\n\\t\\t\\t\\t#Distribute spaces evenly in all words except the last\\n                while spaces > 0:\\n                    bucket[i] += \\' \\'\\n                    if len(bucket) > 1:\\n                        i =  ( i + 1 ) % ( len( bucket ) - 1 )\\n                    spaces -= 1\\n                ans .append(\\'\\'.join(bucket))\\n                bucket, count = [], 0\\n            bucket.append(word)\\n            count += len(word)\\n        \\n        #Last line should be left justifies, so append normally\\n        ans.append(\\' \\'.join(bucket))\\n\\t\\t#Add additional spaces in the end\\n\\t\\tspaces = maxWidth - count - (len(bucket)-1)\\n        ans[-1] += \\' \\'*spaces\\n        \\n\\t\\t#Voila you get the ans in O(n) time\\n        return (ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        bucket = []\\n        \\n        ans = []\\n        \\n        count = 0\\n        \\n        for word in words:\\n\\t\\t\\t#Keep track of total length so far including 1 space per word\\n            if count + len(bucket) + len(word) > maxWidth:\\n\\t\\t\\t\\t#Calculate total spaces needed\\n                spaces = maxWidth - count\\n                i = 0\\n\\t\\t\\t\\t#Distribute spaces evenly in all words except the last\\n                while spaces > 0:\\n                    bucket[i] += \\' \\'\\n                    if len(bucket) > 1:\\n                        i =  ( i + 1 ) % ( len( bucket ) - 1 )\\n                    spaces -= 1\\n                ans .append(\\'\\'.join(bucket))\\n                bucket, count = [], 0\\n            bucket.append(word)\\n            count += len(word)\\n        \\n        #Last line should be left justifies, so append normally\\n        ans.append(\\' \\'.join(bucket))\\n\\t\\t#Add additional spaces in the end\\n\\t\\tspaces = maxWidth - count - (len(bucket)-1)\\n        ans[-1] += \\' \\'*spaces\\n        \\n\\t\\t#Voila you get the ans in O(n) time\\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184405,
                "title": "java-20-lines-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> output= new ArrayList<>();\\n        int n= words.length;\\n        for(int i= 0, k= 1; i<n; i+= k, k= 1){\\n            // calculate k == how many words we can fit in this line (always at least one) with minimum gap of 1 space\\n\\t\\t\\t// and len == what is the total length of these words (then reduced by number of gaps k-1 before passing into printJustified)\\n\\t\\t\\tint len= words[i].length();\\n            for(int j= i+1, nextLen; j<n; j++, k++, len= nextLen)\\n                if((nextLen= len+1 + words[j].length()) > maxWidth) break;\\n\\t\\t\\t// justify left if there is only one word in the line or if it is the last line\\n            output.add(printJustified(words, maxWidth, i, k, len-k+1, k==1 || i+k == n));\\n        }\\n        return output;\\n    }\\n\\n    // i: first word, k: word count, len: line length (no spaces), left: left-justified otherwise full\\n    private String printJustified(String[] words, int maxWidth, int i, int k, int len, boolean left){\\n        int gapLen= left?1:(maxWidth-len)/(k-1), longGaps= left?0:(maxWidth-len)%(k-1);\\n        String gap= \" \".repeat(gapLen), longGap= \" \".repeat(gapLen+1);\\n        StringBuilder line= new StringBuilder(words[i]);\\n        for(int j=1; j<k; j++)\\n            line.append(j<=longGaps?longGap:gap).append(words[i+j]);\\n        if(left) line.append(\" \".repeat(maxWidth-line.length()));\\n        return line.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> output= new ArrayList<>();\\n        int n= words.length;\\n        for(int i= 0, k= 1; i<n; i+= k, k= 1){\\n            // calculate k == how many words we can fit in this line (always at least one) with minimum gap of 1 space\\n\\t\\t\\t// and len == what is the total length of these words (then reduced by number of gaps k-1 before passing into printJustified)\\n\\t\\t\\tint len= words[i].length();\\n            for(int j= i+1, nextLen; j<n; j++, k++, len= nextLen)\\n                if((nextLen= len+1 + words[j].length()) > maxWidth) break;\\n\\t\\t\\t// justify left if there is only one word in the line or if it is the last line\\n            output.add(printJustified(words, maxWidth, i, k, len-k+1, k==1 || i+k == n));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 997123,
                "title": "python-3-99-faster",
                "content": "```\\ndef fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        cur,st,i,ans=len(words[0]),0,1,[]\\n        while i<len(words):\\n            while i<len(words) and  cur+len(words[i])+1<=maxWidth:\\n                cur+=len(words[i])+1\\n                i+=1\\n            if i==len(words):\\n                tmp=\"\"\\n                for x in range(st,i):\\n                    tmp+=words[x]+\" \"\\n                if len(tmp)>maxWidth:\\n                    ans.append(tmp[:maxWidth])\\n                else:\\n                    ans.append(tmp+\" \"*(maxWidth-len(tmp)))\\n                return ans\\n            else:\\n                if i-st==1:\\n                    ans.append(words[st]+\" \"*(maxWidth-len(words[st])))\\n                else:\\n                    gap=i-st-1\\n                    sp=maxWidth-sum(map(len,words[st:i]))\\n                    nor=sp//gap\\n                    mor=sp%gap\\n                    tmp=\"\"\\n                    for x in range(mor):\\n                        tmp+=words[st+x]+\" \"*(nor+1)\\n                    for x in range(mor,gap):\\n                        tmp+=words[st+x]+\" \"*nor\\n                    tmp+=words[st+gap]\\n                    ans.append(tmp)\\n            st=i\\n            cur=len(words[st])\\n            i+=1\\n        if i==len(words):\\n            ans.append(words[i-1]+\" \"*(maxWidth-len(words[st])))\\n            return ans\\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        cur,st,i,ans=len(words[0]),0,1,[]\\n        while i<len(words):\\n            while i<len(words) and  cur+len(words[i])+1<=maxWidth:\\n                cur+=len(words[i])+1\\n                i+=1\\n            if i==len(words):\\n                tmp=\"\"\\n                for x in range(st,i):\\n                    tmp+=words[x]+\" \"\\n                if len(tmp)>maxWidth:\\n                    ans.append(tmp[:maxWidth])\\n                else:\\n                    ans.append(tmp+\" \"*(maxWidth-len(tmp)))\\n                return ans\\n            else:\\n                if i-st==1:\\n                    ans.append(words[st]+\" \"*(maxWidth-len(words[st])))\\n                else:\\n                    gap=i-st-1\\n                    sp=maxWidth-sum(map(len,words[st:i]))\\n                    nor=sp//gap\\n                    mor=sp%gap\\n                    tmp=\"\"\\n                    for x in range(mor):\\n                        tmp+=words[st+x]+\" \"*(nor+1)\\n                    for x in range(mor,gap):\\n                        tmp+=words[st+x]+\" \"*nor\\n                    tmp+=words[st+gap]\\n                    ans.append(tmp)\\n            st=i\\n            cur=len(words[st])\\n            i+=1\\n        if i==len(words):\\n            ans.append(words[i-1]+\" \"*(maxWidth-len(words[st])))\\n            return ans\\n\\t\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 748432,
                "title": "java-solution",
                "content": "I followed video here to understand, easy to do it afterwards.\\nhttps://www.youtube.com/watch?v=TePHubQTgQ8\\n```\\nclass Solution {\\n        public List<String> fullJustify(String[] words, int maxWidth) {\\n            if(words.length==0 || maxWidth==0) return new ArrayList<>();\\n            int index = 0;\\n            int last = 0;\\n            int n = words.length;\\n\\n            List<String> res = new ArrayList<>();\\n\\n            while(index < n){\\n                int totalChars = words[index].length();\\n                int gaps = 0;\\n                last = index+1;\\n                while(last < n && (totalChars +1+ words[last].length()) <= maxWidth){\\n                    totalChars += (1 + words[last].length());\\n                    last ++;\\n                }\\n                StringBuilder sb = new StringBuilder(\"\");\\n                gaps = last - index - 1;\\n                if(last == n || gaps ==0){\\n                    for(int i=index;i<last;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n                    }\\n                    sb.delete(sb.length()-1,sb.length());\\n                    for(int i=0;i<maxWidth - totalChars;i++){\\n                        sb.append(\" \");\\n                    }\\n                }else{\\n                    int spaces = (maxWidth - totalChars)/( gaps);\\n                    int extra = (maxWidth-totalChars) % (gaps);\\n                    for(int i=index;i<last-1;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n\\n                        for(int j=0;j<spaces + (i-index<extra?1:0);j++){\\n                            sb.append(\" \");\\n                        }\\n                    }\\n                    sb.append(words[last-1]);\\n                }\\n                res.add(sb.toString());\\n                index = last;\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public List<String> fullJustify(String[] words, int maxWidth) {\\n            if(words.length==0 || maxWidth==0) return new ArrayList<>();\\n            int index = 0;\\n            int last = 0;\\n            int n = words.length;\\n\\n            List<String> res = new ArrayList<>();\\n\\n            while(index < n){\\n                int totalChars = words[index].length();\\n                int gaps = 0;\\n                last = index+1;\\n                while(last < n && (totalChars +1+ words[last].length()) <= maxWidth){\\n                    totalChars += (1 + words[last].length());\\n                    last ++;\\n                }\\n                StringBuilder sb = new StringBuilder(\"\");\\n                gaps = last - index - 1;\\n                if(last == n || gaps ==0){\\n                    for(int i=index;i<last;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n                    }\\n                    sb.delete(sb.length()-1,sb.length());\\n                    for(int i=0;i<maxWidth - totalChars;i++){\\n                        sb.append(\" \");\\n                    }\\n                }else{\\n                    int spaces = (maxWidth - totalChars)/( gaps);\\n                    int extra = (maxWidth-totalChars) % (gaps);\\n                    for(int i=index;i<last-1;i++){\\n                        sb.append(words[i]);\\n                        sb.append(\" \");\\n\\n                        for(int j=0;j<spaces + (i-index<extra?1:0);j++){\\n                            sb.append(\" \");\\n                        }\\n                    }\\n                    sb.append(words[last-1]);\\n                }\\n                res.add(sb.toString());\\n                index = last;\\n            }\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481553,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string>results;\\n        vector<string>vec;\\n        string str;\\n        int length = 0;\\n        \\n        for(int i=0; i<words.size(); i++)\\n        {\\n            int total_length = words[i].size() + length + vec.size();\\n            if(total_length <= maxWidth) //Can the word fit in the line\\n            {\\n                vec.push_back(words[i]);\\n                length += words[i].length();\\n            }\\n            else//vec is full. No more words fit in a line\\n            {\\n                if(vec.size() == 1)\\n                {\\n                    str = vec[0];\\n                    str.append(maxWidth - str.size(), \\' \\');\\n                    results.push_back(str);\\n                }\\n                else if(vec.size() > 1)\\n                {\\n                    int divide = (maxWidth - length) / (vec.size()-1);\\n                    int mod = (maxWidth - length) % (vec.size() - 1);\\n                    \\n                    str = vec[0];\\n                    \\n                    for(int j = 1; j<vec.size(); j++)\\n                    {\\n                        if(j <= mod)\\n                        {\\n                            str.append(divide+1, \\' \\');\\n                        }\\n                        else\\n                        {\\n                            str.append(divide, \\' \\');\\n                        }\\n                        str += vec[j];\\n                    }\\n                    results.push_back(str);\\n                }\\n                vec.clear();\\n                vec.push_back(words[i]);\\n                length = words[i].size();\\n            }\\n        }\\n        \\n        str = vec[0];\\n        for (int j = 1; j < vec.size(); ++j) str += \\' \\' + vec[j];\\n\\t    str.append(maxWidth - str.size(), \\' \\');\\n\\t    results.push_back(str);\\n\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string>results;\\n        vector<string>vec;\\n        string str;\\n        int length = 0;\\n        \\n        for(int i=0; i<words.size(); i++)\\n        {\\n            int total_length = words[i].size() + length + vec.size();\\n            if(total_length <= maxWidth) //Can the word fit in the line\\n            {\\n                vec.push_back(words[i]);\\n                length += words[i].length();\\n            }\\n            else//vec is full. No more words fit in a line\\n            {\\n                if(vec.size() == 1)\\n                {\\n                    str = vec[0];\\n                    str.append(maxWidth - str.size(), \\' \\');\\n                    results.push_back(str);\\n                }\\n                else if(vec.size() > 1)\\n                {\\n                    int divide = (maxWidth - length) / (vec.size()-1);\\n                    int mod = (maxWidth - length) % (vec.size() - 1);\\n                    \\n                    str = vec[0];\\n                    \\n                    for(int j = 1; j<vec.size(); j++)\\n                    {\\n                        if(j <= mod)\\n                        {\\n                            str.append(divide+1, \\' \\');\\n                        }\\n                        else\\n                        {\\n                            str.append(divide, \\' \\');\\n                        }\\n                        str += vec[j];\\n                    }\\n                    results.push_back(str);\\n                }\\n                vec.clear();\\n                vec.push_back(words[i]);\\n                length = words[i].size();\\n            }\\n        }\\n        \\n        str = vec[0];\\n        for (int j = 1; j < vec.size(); ++j) str += \\' \\' + vec[j];\\n\\t    str.append(maxWidth - str.size(), \\' \\');\\n\\t    results.push_back(str);\\n\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313566,
                "title": "c-85-beaten-brute-force-beatings-iterative-solution-o-n-some-clever-tricks",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string> aResult;\\n        \\n        int aLineStart = 0;\\n        int aSeek = 0;\\n        \\n        char aBuff[maxWidth + 1];\\n        aBuff[maxWidth] = 0;\\n        \\n        for (aLineStart=0;aLineStart<words.size();aLineStart=aSeek) {\\n            \\n            int aWidth = 0;\\n            for (aSeek=aLineStart;aSeek<words.size() && aWidth + words[aSeek].size() + (aSeek - aLineStart) <= maxWidth;aSeek++) {\\n                aWidth += words[aSeek].size();\\n            }\\n            \\n            int aSpacing = 1;\\n            int aExtra = 0;\\n            if ((aSeek - aLineStart) > 1 && aSeek < words.size()) {\\n                aSpacing = (maxWidth - aWidth) / (aSeek - aLineStart - 1);\\n                aExtra   = (maxWidth - aWidth) % (aSeek - aLineStart - 1);\\n            }\\n            \\n            int aPaste = 0;\\n            for (int i=aLineStart;i<aSeek;i++) {\\n                for (int k=0;k<words[i].size();k++) {\\n                    aBuff[aPaste++] = words[i][k];\\n                }\\n                if (i < (aSeek - 1)) {\\n                    for (int k=0;k<aSpacing;k++) { aBuff[aPaste++] = \\' \\'; }\\n                    if (aExtra-- > 0) { aBuff[aPaste++] = \\' \\'; }\\n                }\\n            }\\n            \\n            while (aPaste < maxWidth) { aBuff[aPaste++] = \\' \\'; }\\n            \\n            aResult.push_back(string(aBuff));\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nKaboom, baby. I thought I could squeak out extra speed with the static buffer. Doesn\\'t seem to beat the top 20%.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n        vector<string> aResult;\\n        \\n        int aLineStart = 0;\\n        int aSeek = 0;\\n        \\n        char aBuff[maxWidth + 1];\\n        aBuff[maxWidth] = 0;\\n        \\n        for (aLineStart=0;aLineStart<words.size();aLineStart=aSeek) {\\n            \\n            int aWidth = 0;\\n            for (aSeek=aLineStart;aSeek<words.size() && aWidth + words[aSeek].size() + (aSeek - aLineStart) <= maxWidth;aSeek++) {\\n                aWidth += words[aSeek].size();\\n            }\\n            \\n            int aSpacing = 1;\\n            int aExtra = 0;\\n            if ((aSeek - aLineStart) > 1 && aSeek < words.size()) {\\n                aSpacing = (maxWidth - aWidth) / (aSeek - aLineStart - 1);\\n                aExtra   = (maxWidth - aWidth) % (aSeek - aLineStart - 1);\\n            }\\n            \\n            int aPaste = 0;\\n            for (int i=aLineStart;i<aSeek;i++) {\\n                for (int k=0;k<words[i].size();k++) {\\n                    aBuff[aPaste++] = words[i][k];\\n                }\\n                if (i < (aSeek - 1)) {\\n                    for (int k=0;k<aSpacing;k++) { aBuff[aPaste++] = \\' \\'; }\\n                    if (aExtra-- > 0) { aBuff[aPaste++] = \\' \\'; }\\n                }\\n            }\\n            \\n            while (aPaste < maxWidth) { aBuff[aPaste++] = \\' \\'; }\\n            \\n            aResult.push_back(string(aBuff));\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242607,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`, where `n` is the total number of characters in the text.\\n\\n```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        line = []\\n        word_count = 0\\n        char_count = 0\\n        res = []\\n        for word in words:\\n            length = char_count+1+len(word)\\n            if length > maxWidth:\\n                space_left = maxWidth - char_count\\n                if word_count == 1:\\n                    string = line[0]+\" \"*(maxWidth-len(line[0]))\\n                    res.append(string)\\n                    line = [word]\\n                    char_count = len(word)\\n                else:\\n                    q, r = divmod(space_left, word_count-1)\\n                    front = (\" \"*(q+2)).join(line[:r+1])\\n                    end = (\" \"*(q+1)).join(line[r+1:])\\n                    string = front+\" \"*(q+1)+end\\n                    if string:\\n                        res.append(string)\\n                    line = [word]\\n                    word_count = 1\\n                    char_count = len(word)\\n            else:\\n                if line:\\n                    char_count += len(word)+1\\n                else:\\n                    char_count += len(word)\\n                line.append(word)\\n                word_count += 1\\n        if line:\\n            line = \" \".join(line)\\n            line += \" \"*(maxWidth-len(line))\\n            res.append(line)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        line = []\\n        word_count = 0\\n        char_count = 0\\n        res = []\\n        for word in words:\\n            length = char_count+1+len(word)\\n            if length > maxWidth:\\n                space_left = maxWidth - char_count\\n                if word_count == 1:\\n                    string = line[0]+\" \"*(maxWidth-len(line[0]))\\n                    res.append(string)\\n                    line = [word]\\n                    char_count = len(word)\\n                else:\\n                    q, r = divmod(space_left, word_count-1)\\n                    front = (\" \"*(q+2)).join(line[:r+1])\\n                    end = (\" \"*(q+1)).join(line[r+1:])\\n                    string = front+\" \"*(q+1)+end\\n                    if string:\\n                        res.append(string)\\n                    line = [word]\\n                    word_count = 1\\n                    char_count = len(word)\\n            else:\\n                if line:\\n                    char_count += len(word)+1\\n                else:\\n                    char_count += len(word)\\n                line.append(word)\\n                word_count += 1\\n        if line:\\n            line = \" \".join(line)\\n            line += \" \"*(maxWidth-len(line))\\n            res.append(line)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213677,
                "title": "verbose-python-solution",
                "content": "```python\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        i, l = 0, len(words)\\n        output = []\\n        \\n        while i < l:\\n            j, line_words, line, rem_width = i, [], \\'\\', maxWidth\\n\\n            # if only the word can fit in the line, no remaining cols\\n            if len(words[i]) == maxWidth:\\n                i+= 1\\n                output.append(words[i-1])\\n                continue\\n\\n            # calculate remaining width after fitting words on line\\n            while i < len(words) and len(words[i]) +1 <= rem_width:\\n                # ignore first word but add spaces to rest\\n                if len(line_words) > 0: rem_width -=1\\n                rem_width -= len(words[i])\\n                line_words.append(words[i])\\n                i+=1\\n\\n            # left justify if no extra spaces or words\\n            if i == len(words) or rem_width == 0 or len(line_words) == 1:\\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    line += \\' \\'\\n                    line += words[j]\\n                    j+= 1\\n                while rem_width > 0:\\n                    line += \\' \\'\\n                    rem_width -= 1\\n                output.append(line)\\n                continue\\n\\n            # if there are leftover spaces after fitting words    \\n            if rem_width > 0:\\n                num_spaces = rem_width //(len(line_words) -1) + 1\\n                extra_spaces = rem_width % (len(line_words) -1)\\n                \\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    k = num_spaces\\n                    while k > 0:\\n                        line += \\' \\'\\n                        k-=1\\n                    if extra_spaces > 0:\\n                        extra_spaces -= 1\\n                        line += \\' \\'\\n                    line += words[j]\\n                    j+=1\\n                output.append(line)\\n                continue\\n            \\n            \\n        return output\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def fullJustify(self, words, maxWidth):\\n        \"\"\"\\n        :type words: List[str]\\n        :type maxWidth: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        i, l = 0, len(words)\\n        output = []\\n        \\n        while i < l:\\n            j, line_words, line, rem_width = i, [], \\'\\', maxWidth\\n\\n            # if only the word can fit in the line, no remaining cols\\n            if len(words[i]) == maxWidth:\\n                i+= 1\\n                output.append(words[i-1])\\n                continue\\n\\n            # calculate remaining width after fitting words on line\\n            while i < len(words) and len(words[i]) +1 <= rem_width:\\n                # ignore first word but add spaces to rest\\n                if len(line_words) > 0: rem_width -=1\\n                rem_width -= len(words[i])\\n                line_words.append(words[i])\\n                i+=1\\n\\n            # left justify if no extra spaces or words\\n            if i == len(words) or rem_width == 0 or len(line_words) == 1:\\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    line += \\' \\'\\n                    line += words[j]\\n                    j+= 1\\n                while rem_width > 0:\\n                    line += \\' \\'\\n                    rem_width -= 1\\n                output.append(line)\\n                continue\\n\\n            # if there are leftover spaces after fitting words    \\n            if rem_width > 0:\\n                num_spaces = rem_width //(len(line_words) -1) + 1\\n                extra_spaces = rem_width % (len(line_words) -1)\\n                \\n                line += words[j]\\n                j+=1\\n                while j < i:\\n                    k = num_spaces\\n                    while k > 0:\\n                        line += \\' \\'\\n                        k-=1\\n                    if extra_spaces > 0:\\n                        extra_spaces -= 1\\n                        line += \\' \\'\\n                    line += words[j]\\n                    j+=1\\n                output.append(line)\\n                continue\\n            \\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197996,
                "title": "javascript-90-with-comments",
                "content": "I was asked this in an Uber interview...Perfect justify logic was complicated...I adapted the algorithm from \\n\\nhttps://leetcode.com/problems/text-justification/discuss/24891/Concise-python-solution-10-lines.\\n\\n...as the author says...the justification explanation is a complicated way to just say round robin distribution...\\n\\n```\\n// You should pack your words in a greedy approach; \\n// that is, pack as many words as you can in each line. \\n// Pad extra spaces \\' \\' when necessary so that each line \\n// has exactly maxWidth characters.\\nvar createLines = function(words, maxWidth) {\\n    let lines = [];\\n    \\n    let p = 0;\\n    \\n    while(p < words.length) {\\n        let line = [];\\n        \\n        while(p < words.length) {\\n            let peek = words[p];\\n            let peeklen = [...line, peek].join(\\' \\').length;\\n\\n            if(peeklen <= maxWidth) {\\n                line.push(peek);\\n                \\n                p++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        lines.push(line);\\n    }\\n    \\n    return lines;\\n};\\n\\nvar justifyLines = function(lines, maxWidth) {\\n    const justified = [];\\n    \\n    const push = (line, space) => {\\n        let text = line.join(space);\\n       \\n        let extra = \\' \\'.repeat(maxWidth-text.length);\\n        \\n        justified.push(text + extra);\\n    };\\n    \\n    for(let l = 0; l < lines.length -1; l++) {\\n        const line = lines[l];\\n        \\n        let spaces = (maxWidth - line.join(\\'\\').length);\\n        \\n\\t\\t// Extra spaces between words should be distributed as evenly as possible. \\n\\t\\t// If the number of spaces on a line do not divide evenly between words, \\n\\t\\t// the empty slots on the left will be assigned more spaces than the slots on the right.\\n        for(let i = 0; i < spaces; i++) {\\n            const index = i%((line.length-1) || 1);\\n\\n            line[index] += \\' \\';\\n        }\\n        \\n        push(line, \\'\\');\\n    };\\n    \\n\\t// For the last line of text, it should be left justified \\n\\t// and no extra space is inserted between words.\\n    push(lines[lines.length-1],  \\' \\');\\n    \\n    return justified;\\n}\\n\\nvar fullJustify = function(words, maxWidth) {\\n    let lines = createLines(words, maxWidth);\\n    \\n    lines = justifyLines(lines, maxWidth);\\n    \\n    return lines;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// You should pack your words in a greedy approach; \\n// that is, pack as many words as you can in each line. \\n// Pad extra spaces \\' \\' when necessary so that each line \\n// has exactly maxWidth characters.\\nvar createLines = function(words, maxWidth) {\\n    let lines = [];\\n    \\n    let p = 0;\\n    \\n    while(p < words.length) {\\n        let line = [];\\n        \\n        while(p < words.length) {\\n            let peek = words[p];\\n            let peeklen = [...line, peek].join(\\' \\').length;\\n\\n            if(peeklen <= maxWidth) {\\n                line.push(peek);\\n                \\n                p++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        lines.push(line);\\n    }\\n    \\n    return lines;\\n};\\n\\nvar justifyLines = function(lines, maxWidth) {\\n    const justified = [];\\n    \\n    const push = (line, space) => {\\n        let text = line.join(space);\\n       \\n        let extra = \\' \\'.repeat(maxWidth-text.length);\\n        \\n        justified.push(text + extra);\\n    };\\n    \\n    for(let l = 0; l < lines.length -1; l++) {\\n        const line = lines[l];\\n        \\n        let spaces = (maxWidth - line.join(\\'\\').length);\\n        \\n\\t\\t// Extra spaces between words should be distributed as evenly as possible. \\n\\t\\t// If the number of spaces on a line do not divide evenly between words, \\n\\t\\t// the empty slots on the left will be assigned more spaces than the slots on the right.\\n        for(let i = 0; i < spaces; i++) {\\n            const index = i%((line.length-1) || 1);\\n\\n            line[index] += \\' \\';\\n        }\\n        \\n        push(line, \\'\\');\\n    };\\n    \\n\\t// For the last line of text, it should be left justified \\n\\t// and no extra space is inserted between words.\\n    push(lines[lines.length-1],  \\' \\');\\n    \\n    return justified;\\n}\\n\\nvar fullJustify = function(words, maxWidth) {\\n    let lines = createLines(words, maxWidth);\\n    \\n    lines = justifyLines(lines, maxWidth);\\n    \\n    return lines;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24952,
                "title": "recursive-python-solution-with-detailed-comments",
                "content": "    import math\\n\\n    def fullJustify(self, words, maxWidth):\\n        \\n        # Handle corner cases\\n        \\n        n = len(words)\\n        if n == 0:\\n            return words\\n        if words[0] == \"\":\\n            return [\" \" * maxWidth]\\n            \\n        # Greedily put words in words_line until full\\n            \\n        words_line = [words[0]]\\n        i, len_words, len_spaces = 1, len(words[0]), 0\\n        while i < len(words) and len_spaces + len_words <= maxWidth:\\n            words_line.append(words[i])\\n            len_words += len(words[i])\\n            len_spaces += 1\\n            i += 1\\n        \\n        # Remove last word if went beyond maxWidth\\n        \\n        if len_spaces + len_words > maxWidth:\\n            a = words_line.pop()\\n            len_words -= len(a)\\n            len_spaces -= 1\\n        \\n        # Need to fill slots with spaces\\n        \\n        slots = len(words_line) - 1 if len(words_line) > 1 else 1\\n        spaces = maxWidth - len_words\\n        padding = []\\n        \\n        # Fill padding between words depending on the case\\n        \\n        spaces_, slots_ = spaces, slots\\n        while spaces_ % slots_ != 0:\\n            sp = int(math.ceil(spaces_/float(slots_)))\\n            padding += [sp]\\n            spaces_ -= sp\\n            slots_ -= 1\\n        padding += [int(spaces_ // slots_)] * slots_\\n\\n        # Last line, padding is different\\n\\n        if len(words[len(words_line):]) == 0:\\n            padding = [1] * (len(words_line) - 1) + [spaces - (len(words_line) - 1)]\\n            \\n        # Construct line\\n        \\n        i, line = 0, \"\"\\n        for word in words_line:\\n            line += word\\n            if i < len(padding):\\n                line += \" \" * padding[i]\\n            i += 1\\n            \\n        # Recursive call on rest of phrase\\n\\n        further_lines = self.fullJustify(words[len(words_line):], maxWidth)\\n        return [line] + further_lines",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    import math\\n\\n    def fullJustify(self, words, maxWidth):\\n        \\n        # Handle corner cases\\n        \\n        n = len(words)\\n        if n == 0:\\n            return words\\n        if words[0] == \"\":\\n            return [\" \" * maxWidth]\\n            \\n        # Greedily put words in words_line until full\\n            \\n        words_line = [words[0]]\\n        i, len_words, len_spaces = 1, len(words[0]), 0\\n        while i < len(words) and len_spaces + len_words <= maxWidth:\\n            words_line.append(words[i])\\n            len_words += len(words[i])\\n            len_spaces += 1\\n            i += 1\\n        \\n        # Remove last word if went beyond maxWidth\\n        \\n        if len_spaces + len_words > maxWidth:\\n            a = words_line.pop()\\n            len_words -= len(a)\\n            len_spaces -= 1\\n        \\n        # Need to fill slots with spaces\\n        \\n        slots = len(words_line) - 1 if len(words_line) > 1 else 1\\n        spaces = maxWidth - len_words\\n        padding = []\\n        \\n        # Fill padding between words depending on the case\\n        \\n        spaces_, slots_ = spaces, slots\\n        while spaces_ % slots_ != 0:\\n            sp = int(math.ceil(spaces_/float(slots_)))\\n            padding += [sp]\\n            spaces_ -= sp\\n            slots_ -= 1\\n        padding += [int(spaces_ // slots_)] * slots_\\n\\n        # Last line, padding is different\\n\\n        if len(words[len(words_line):]) == 0:\\n            padding = [1] * (len(words_line) - 1) + [spaces - (len(words_line) - 1)]\\n            \\n        # Construct line\\n        \\n        i, line = 0, \"\"\\n        for word in words_line:\\n            line += word\\n            if i < len(padding):\\n                line += \" \" * padding[i]\\n            i += 1\\n            \\n        # Recursive call on rest of phrase\\n\\n        further_lines = self.fullJustify(words[len(words_line):], maxWidth)\\n        return [line] + further_lines",
                "codeTag": "Python3"
            },
            {
                "id": 24975,
                "title": "c-solution-with-comments",
                "content": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n          int idx = 0;\\n          vector<string> ret;\\n          while (idx < words.size()) {\\n            // get the current line\\n            int end = idx;\\n            int total = 0;\\n            vector<string> line;\\n            while (end < words.size() \\\\\\n        \\t   && total+line.size()+words[end].length() <= maxWidth) {\\n              line.push_back(words[end]);\\n              total += words[end].length();\\n              end ++;\\n            }\\n            // the last line or just a single word -> left alignment\\n            // just pad the end with spaces\\n            string l = words[idx];\\n            if (end == words.size() || line.size()==1) {      \\n              for (int i = idx+1; i < end; i ++)\\n                l += \" \" + words[i];\\n              l += string(maxWidth-(total+line.size()-1), ' ');\\n            }\\n            // distribute the spaces evenly\\n            else {\\n              int space_len = maxWidth - total;\\n              int left = space_len % (line.size()-1);\\n              int base = space_len / (line.size()-1);\\n              int cnt = 0;\\n              for (int i = idx+1; i < end; i ++) {\\n                l += string(base, ' ');\\n                // add extra\\n                if (cnt < left) {\\n                  l += \" \";\\n                  cnt ++;\\n                }\\n                l += words[i];\\n              }\\n            }\\n            ret.push_back(l);\\n            idx = end;\\n          }\\n          return ret;\\n    }",
                "solutionTags": [],
                "code": "    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n          int idx = 0;\\n          vector<string> ret;\\n          while (idx < words.size()) {\\n            // get the current line\\n            int end = idx;\\n            int total = 0;\\n            vector<string> line;\\n            while (end < words.size() \\\\\\n        \\t   && total+line.size()+words[end].length() <= maxWidth) {\\n              line.push_back(words[end]);\\n              total += words[end].length();\\n              end ++;\\n            }\\n            // the last line or just a single word -> left alignment\\n            // just pad the end with spaces\\n            string l = words[idx];\\n            if (end == words.size() || line.size()==1) {      \\n              for (int i = idx+1; i < end; i ++)\\n                l += \" \" + words[i];\\n              l += string(maxWidth-(total+line.size()-1), ' ');\\n            }\\n            // distribute the spaces evenly\\n            else {\\n              int space_len = maxWidth - total;\\n              int left = space_len % (line.size()-1);\\n              int base = space_len / (line.size()-1);\\n              int cnt = 0;\\n              for (int i = idx+1; i < end; i ++) {\\n                l += string(base, ' ');\\n                // add extra\\n                if (cnt < left) {\\n                  l += \" \";\\n                  cnt ++;\\n                }\\n                l += words[i];\\n              }\\n            }\\n            ret.push_back(l);\\n            idx = end;\\n          }\\n          return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4050577,
                "title": "text-justification-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955510,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterate through the input words and form lines that fit within the maximum width.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main logic is within the fullJustify function. It iterates through the input words and forms lines that fit within the maximum width. It then uses the addSpaces function to create the justified lines.\\n\\nThe condition for the last line is checked using the isLastLine boolean flag.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(M), M-No of input characteres in a stream\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addSpaces(vector<string>& words, int maxWidth, int i, int j, bool isLast) {\\n        string result = words[i];\\n        if (i == j || isLast) {  // For a single-word line or last line\\n            for (int k = i + 1; k <= j; ++k) {\\n                result += \" \" + words[k];\\n            }\\n            result += string(maxWidth - result.length(), \\' \\');\\n            return result;\\n        }\\n\\n        int totalSpaces = maxWidth - accumulate(words.begin() + i, words.begin() + j + 1, 0, [](int len, const string& word) { return len + word.length(); });\\n        int slots = j - i;  // Number of slots between words\\n        int spacesBetweenWords = totalSpaces / slots;\\n        int extraSpaces = totalSpaces % slots;\\n\\n        for (int k = i + 1; k <= j; ++k) {\\n            int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n            result += string(spaces, \\' \\') + words[k];\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0, n = words.size();\\n\\n        while (i < n) {\\n            int j = i, lineLength = 0;\\n            while (j < n && lineLength + words[j].length() + (j - i) <= maxWidth) {\\n                lineLength += words[j].length();\\n                j++;\\n            }\\n\\n            bool isLastLine = (j == n);\\n            result.push_back(addSpaces(words, maxWidth, i, j - 1, isLastLine));\\n\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addSpaces(vector<string>& words, int maxWidth, int i, int j, bool isLast) {\\n        string result = words[i];\\n        if (i == j || isLast) {  // For a single-word line or last line\\n            for (int k = i + 1; k <= j; ++k) {\\n                result += \" \" + words[k];\\n            }\\n            result += string(maxWidth - result.length(), \\' \\');\\n            return result;\\n        }\\n\\n        int totalSpaces = maxWidth - accumulate(words.begin() + i, words.begin() + j + 1, 0, [](int len, const string& word) { return len + word.length(); });\\n        int slots = j - i;  // Number of slots between words\\n        int spacesBetweenWords = totalSpaces / slots;\\n        int extraSpaces = totalSpaces % slots;\\n\\n        for (int k = i + 1; k <= j; ++k) {\\n            int spaces = spacesBetweenWords + (extraSpaces-- > 0 ? 1 : 0);\\n            result += string(spaces, \\' \\') + words[k];\\n        }\\n\\n        return result;\\n    }\\n\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        int i = 0, n = words.size();\\n\\n        while (i < n) {\\n            int j = i, lineLength = 0;\\n            while (j < n && lineLength + words[j].length() + (j - i) <= maxWidth) {\\n                lineLength += words[j].length();\\n                j++;\\n            }\\n\\n            bool isLastLine = (j == n);\\n            result.push_back(addSpaces(words, maxWidth, i, j - 1, isLastLine));\\n\\n            i = j;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954019,
                "title": "easy-ad-hoc-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        vector<string> ans;\\n        int i = 0, j = 0;\\n        while (i < words.size())\\n        {\\n            int charCnt = words[i].length(), spaceCnt = 0;\\n            j = i + 1;\\n            while (j < words.size() && charCnt + spaceCnt + 1 + words[j].length() <= maxWidth)\\n            {\\n                charCnt += words[j].length();\\n                spaceCnt++;\\n                j++;\\n            }\\n            int rem = maxWidth - charCnt;\\n            int equalDistribute = (spaceCnt == 0) ? 0 : rem / spaceCnt;\\n            int extraDistribute = (spaceCnt == 0) ? 0 : rem % spaceCnt;\\n            if (j == words.size())\\n            {\\n                equalDistribute = 1;\\n                extraDistribute = 0;\\n            }\\n            string s;\\n            for (int k = i; k < j; ++k)\\n            {\\n                s += words[k];\\n                if (k == j - 1)\\n                    break;\\n                for (int p = 0; p < equalDistribute; ++p)\\n                {\\n                    s.push_back(\\' \\');\\n                }\\n                if (extraDistribute > 0)\\n                {\\n                    s.push_back(\\' \\');\\n                    extraDistribute--;\\n                }\\n            }\\n            while (s.length() < maxWidth)\\n            {\\n                s.push_back(\\' \\');\\n            }\\n            ans.push_back(s);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<string> fullJustify(vector<string> &words, int maxWidth)\\n    {\\n        vector<string> ans;\\n        int i = 0, j = 0;\\n        while (i < words.size())\\n        {\\n            int charCnt = words[i].length(), spaceCnt = 0;\\n            j = i + 1;\\n            while (j < words.size() && charCnt + spaceCnt + 1 + words[j].length() <= maxWidth)\\n            {\\n                charCnt += words[j].length();\\n                spaceCnt++;\\n                j++;\\n            }\\n            int rem = maxWidth - charCnt;\\n            int equalDistribute = (spaceCnt == 0) ? 0 : rem / spaceCnt;\\n            int extraDistribute = (spaceCnt == 0) ? 0 : rem % spaceCnt;\\n            if (j == words.size())\\n            {\\n                equalDistribute = 1;\\n                extraDistribute = 0;\\n            }\\n            string s;\\n            for (int k = i; k < j; ++k)\\n            {\\n                s += words[k];\\n                if (k == j - 1)\\n                    break;\\n                for (int p = 0; p < equalDistribute; ++p)\\n                {\\n                    s.push_back(\\' \\');\\n                }\\n                if (extraDistribute > 0)\\n                {\\n                    s.push_back(\\' \\');\\n                    extraDistribute--;\\n                }\\n            }\\n            while (s.length() < maxWidth)\\n            {\\n                s.push_back(\\' \\');\\n            }\\n            ans.push_back(s);\\n            i = j;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954009,
                "title": "optimal-text-justification-a-deep-dive-into-greedy-line-formatting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this post, we will tackle the \"Text Justification\" problem, where we are given an array of words and a maximum width, and we need to format the text such that each line has exactly the specified width and is fully justified. We\\'ll discuss the intuition behind the solution, step-by-step approach to solve the problem, the provided code solution, as well as the time and space complexity analysis.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo tackle this problem, we\\'ll use a greedy approach. We will iterate through the `words` array and try to pack as many words as possible in each line while adhering to the `maxWidth` constraint. We\\'ll maintain a begin pointer to track the start of the current line, a `len` variable to track the length of words in the current line, and iterate through the words.\\n\\nWhenever adding a new word to the current line would exceed the `maxWidth`, we will finalize the current line by calling a helper function `connect()`. This function will construct the line by adding the words and the appropriate number of spaces between them. If it\\'s the last line, we\\'ll add only single spaces between words.\\n\\nFinally, we\\'ll handle the last line separately, ensuring it\\'s left-justified with no extra spaces added.\\n\\n# Complexity\\n- Time Complexity:\\nThe time complexity of this solution is O(N), where N is the number of words in the input array. We iterate through the words once to construct the lines, and the connect function runs in constant time since it\\'s processing a fixed number of words.\\n\\n- Space Complexity:\\nThe space complexity is also O(N), as we are using additional space to store the output lines.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        const int n = words.size();\\n        int begin = 0, len = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (len + words[i].size() + (i - begin) > maxWidth) {\\n                res.emplace_back(connect(words, maxWidth, begin, i, len, false));\\n                begin = i;\\n                len = 0;\\n            }\\n            len += words[i].size();\\n        }\\n        res.emplace_back(connect(words, maxWidth, begin, n, len, true));\\n        return res;\\n    }\\nprivate:\\n    string connect(const vector<string>& words, int maxWidth,\\n                   int begin, int end, int len,\\n                   bool is_last) {\\n        string s;\\n        int n = end - begin;\\n        for (int i = 0; i < n; ++i) {\\n            s += words[begin + i];\\n            addSpaces(i, n - 1, maxWidth - len, is_last, &s);\\n        }\\n        if (s.size() < maxWidth) {\\n            s.append(maxWidth - s.size(), \\' \\');\\n        }\\n        return s;\\n    }\\n    void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {\\n        if (i < spaceCnt) {\\n            int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);\\n            s->append(spaces, \\' \\');\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953512,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition and approach dicussed in detail in video solution\\nhttps://youtu.be/hLXrrg-cd98\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int left = 0;\\n        std::vector<string> answer;\\n        while (left < words.size()) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.push_back(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\nprivate:\\n\\n    int getRightPtr(int left, vector<string>& words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.size() && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    string justify(int left, int right, vector<string>& words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        bool isLastLine = right == words.size() - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        string space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        string answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.size() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.size() && answer[leftPtr]  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer[rightPtr] == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substr(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    string addRemSpaces(string answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + string(maxWidth - answer.length(), \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, vector<string>& words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    string findSpaceSeq(int count) {\\n        return std::string(count, \\' \\');\\n    }\\n    \\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n    int left = 0;\\n        List<String> answer = new ArrayList<>();\\n        while (left < words.length) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\n    int getRightPtr(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        boolean isLastLine = right == words.length - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        String space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        String answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.length() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.length() && answer.charAt(leftPtr)  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer.charAt(rightPtr) == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substring(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    String addRemSpaces(String answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + new String(new char[maxWidth - answer.length()]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, String[] words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    String findSpaceSeq(int count) {\\n        return new String(new char[count]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int left = 0;\\n        std::vector<string> answer;\\n        while (left < words.size()) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.push_back(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\nprivate:\\n\\n    int getRightPtr(int left, vector<string>& words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.size() && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    string justify(int left, int right, vector<string>& words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        bool isLastLine = right == words.size() - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        string space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        string answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.size() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.size() && answer[leftPtr]  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer[rightPtr] == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substr(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    string addRemSpaces(string answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + string(maxWidth - answer.length(), \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, vector<string>& words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    string findSpaceSeq(int count) {\\n        return std::string(count, \\' \\');\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n    int left = 0;\\n        List<String> answer = new ArrayList<>();\\n        while (left < words.length) {\\n            int right = getRightPtr(left, words, maxWidth);\\n            answer.add(justify(left, right, words, maxWidth));\\n            left = right + 1;\\n        }\\n        return answer;\\n    }\\n    int getRightPtr(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right++].length();\\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\\n            sum += 1 + words[right++].length();\\n        return right - 1;\\n    }\\n\\n    String justify(int left, int right, String[] words, int maxWidth) {\\n        if (right - left == 0) return addRemSpaces(words[left], maxWidth);\\n\\n        boolean isLastLine = right == words.length - 1;\\n    \\n        int numSpaces = right - left;\\n    \\n        int totalSpace = maxWidth - findLengthOfRange(left, right, words);\\n    \\n        String space = isLastLine ? \" \" : findSpaceSeq(totalSpace / numSpaces);\\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\\n    \\n        String answer = \"\";\\n        for (int i = left; i <= right; i++) {\\n            answer += (words[i]) + (space) + (remainder-- > 0 ? \" \" : \"\");\\n        }\\n    \\n        int leftPtr = 0, rightPtr = answer.length() - 1;\\n\\n        //removing trailing spaces\\n        while(left < answer.length() && answer.charAt(leftPtr)  ==  \\' \\'){\\n            leftPtr++;\\n        }\\n        while(rightPtr > - 1 && answer.charAt(rightPtr) == \\' \\'){\\n            rightPtr--;\\n        }\\n        return addRemSpaces(answer.substring(leftPtr, rightPtr + 1 - leftPtr), maxWidth);\\n        }\\n\\n    String addRemSpaces(String answer, int maxWidth) {\\n        if (answer.length() >= maxWidth) return answer;\\n        return answer + new String(new char[maxWidth - answer.length()]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n\\n    int findLengthOfRange(int left, int right, String[] words) {\\n        int length = 0;\\n        for (int i = left; i <= right; i++) {\\n            length += words[i].length();\\n        }\\n        return length;\\n    }\\n\\n    String findSpaceSeq(int count) {\\n        return new String(new char[count]).replace(\\'\\\\0\\', \\' \\');\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953504,
                "title": "simple-c-solution",
                "content": "# Intuition\\nAdd as many words to a line while it is <= maxWidth\\nJustify by then adding spaces until that line == maxWidth\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n\\t\\tList<string> result = new List<string>();\\n\\t\\tList<string> temp = new List<string>();\\n\\t\\tstring line = string.Empty;\\n\\t\\tforeach (string word in words)\\n\\t\\t{\\n\\t\\t\\tif (temp.Count + word.Length + temp.Sum(x => x.Length) <= maxWidth)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.Add(word);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Justify\\n\\t\\t\\t\\tresult.Add(Justify(temp, maxWidth));\\n\\t\\t\\t\\ttemp = new List<string>() { word };\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (temp.Count > 0)\\n\\t\\t{\\n\\t\\t\\tresult.Add(string.Join(\" \", temp).PadRight(maxWidth));\\n\\t\\t}\\n\\t\\treturn result.ToArray();\\n    }\\n\\n\\tpublic string Justify(List<string> words, int maxWidth)\\n\\t{\\n\\t\\tif (words.Count == 1)\\n\\t\\t{\\n\\t\\t\\treturn words[0].PadRight(maxWidth);\\n\\t\\t}\\n        while (words.Sum(x => x.Length) < maxWidth)\\n        {\\n            // We can\\'t justify last word\\n            for (int i = 0; i < words.Count - 1; i++)\\n            {\\n                words[i] = words[i] + \" \";\\n                if (words.Sum(x => x.Length) == maxWidth)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\treturn string.Join(\"\", words);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n\\t\\tList<string> result = new List<string>();\\n\\t\\tList<string> temp = new List<string>();\\n\\t\\tstring line = string.Empty;\\n\\t\\tforeach (string word in words)\\n\\t\\t{\\n\\t\\t\\tif (temp.Count + word.Length + temp.Sum(x => x.Length) <= maxWidth)\\n\\t\\t\\t{\\n\\t\\t\\t\\ttemp.Add(word);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Justify\\n\\t\\t\\t\\tresult.Add(Justify(temp, maxWidth));\\n\\t\\t\\t\\ttemp = new List<string>() { word };\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (temp.Count > 0)\\n\\t\\t{\\n\\t\\t\\tresult.Add(string.Join(\" \", temp).PadRight(maxWidth));\\n\\t\\t}\\n\\t\\treturn result.ToArray();\\n    }\\n\\n\\tpublic string Justify(List<string> words, int maxWidth)\\n\\t{\\n\\t\\tif (words.Count == 1)\\n\\t\\t{\\n\\t\\t\\treturn words[0].PadRight(maxWidth);\\n\\t\\t}\\n        while (words.Sum(x => x.Length) < maxWidth)\\n        {\\n            // We can\\'t justify last word\\n            for (int i = 0; i < words.Count - 1; i++)\\n            {\\n                words[i] = words[i] + \" \";\\n                if (words.Sum(x => x.Length) == maxWidth)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\treturn string.Join(\"\", words);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953142,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nWe have a task of justifying a list of words into lines of equal width while adhering to a specified maximum width. So we iterate through the words, progressively building lines and calculating the total length of characters in the current line. When the addition of a new word would exceed the maximum width, we distribute spaces evenly between words to achieve the target width. The last line is handled separately, being left-aligned with extra spaces added to the right.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n- So we iterate through each word in the words vector. We check if adding the current word to the current line would exceed the maxWidth limit. If it does, we enter a block to format and justify the current line. We distribute spaces evenly between words to achieve the desired line width, with the exception of the last line which is left-aligned.\\n\\n- After formatting the current line, it is added to the result vector, and the current vector is cleared along with resetting numLen to 0.\\n\\n- If the current word can be added to the current line without exceeding the maxWidth, the word is added to the current vector, and its length is added to numLen.\\n\\n- Once all words have been processed, we handle the last line by concatenating the words with single spaces between them, and then adding extra spaces to the right to achieve the maxWidth.\\n\\n- The last line is added to the result vector, and the final result vector containing justified lines is returned.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> current;\\n        int numLen=0;\\n        for(string word:words){\\n            if(word.size()+current.size()+numLen>maxWidth){\\n                for(int i=0;i<maxWidth-numLen;i++){\\n                    current[i%(current.size()-1?current.size()-1:1)]+=\\' \\';\\n                }\\n                result.push_back(\"\");\\n                for(string s:current) result.back()+=s;\\n                current.clear();\\n                numLen=0;\\n            }\\n            current.push_back(word);\\n            numLen+=word.size();\\n        }\\n        string lastLine=\"\";\\n        for(string s:current) lastLine+=s+\\' \\';\\n        lastLine=lastLine.substr(0,lastLine.size()-1);\\n        while(lastLine.size()<maxWidth) lastLine+=\\' \\';\\n        result.push_back(lastLine);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        vector<string> current;\\n        int numLen=0;\\n        for(string word:words){\\n            if(word.size()+current.size()+numLen>maxWidth){\\n                for(int i=0;i<maxWidth-numLen;i++){\\n                    current[i%(current.size()-1?current.size()-1:1)]+=\\' \\';\\n                }\\n                result.push_back(\"\");\\n                for(string s:current) result.back()+=s;\\n                current.clear();\\n                numLen=0;\\n            }\\n            current.push_back(word);\\n            numLen+=word.size();\\n        }\\n        string lastLine=\"\";\\n        for(string s:current) lastLine+=s+\\' \\';\\n        lastLine=lastLine.substr(0,lastLine.size()-1);\\n        while(lastLine.size()<maxWidth) lastLine+=\\' \\';\\n        result.push_back(lastLine);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952495,
                "title": "c-easy-solution-faster-than-100-excellent-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is we will maintain the spaces required for the words in the temporary vector and also the number of characters in the current word. If we found that the total lenght is greater than or equal to maximum length then we will perform the operation.\\n\\n        int spacesReq;\\n        int currLen = 0;\\n\\n        vector<string> temp;\\n        vector<string> result;\\n\\n        for(auto &word : words){\\n            int wordLen = word.size();\\n            spacesReq = temp.size();\\n            if(currLen + wordLen + spacesReq > maxWidth){\\n                string answer = \"\";\\n                int spaces = maxWidth - currLen;\\n                if(temp.size() == 1){\\n                    answer = temp[0];\\n                    while(spaces --> 0) answer += \" \";\\n                    result.push_back(answer);\\n                }\\n                else{\\n                    int spaceBetween = spaces / (temp.size() - 1);\\n                    int extraSpaces = maxWidth - currLen - spaceBetween * (temp.size() - 1);\\n                    answer = temp[0];\\n                    string bet = \"\";\\n                    while(spaceBetween --> 0) bet += \" \";\\n                    for(int i = 1 ; i < temp.size() ; i++){\\n                        answer += bet;\\n                        if(extraSpaces > 0){\\n                            answer += \" \";\\n                            extraSpaces -= 1;\\n                        }\\n                        answer += temp[i];\\n                    }\\n                    result.push_back(answer);\\n                }\\n                temp.clear();\\n                currLen = wordLen;\\n                temp.push_back(word);\\n            }\\n            else{\\n                currLen += wordLen;\\n                temp.push_back(word);\\n            }\\n        }\\n\\n        if(temp.size() >= 1){\\n            string answer = temp[0];\\n            for(int i = 1 ; i < temp.size() ; i++){\\n                answer += \" \" + temp[i];\\n            }\\n            while(answer.size() < maxWidth) answer += \" \";\\n            result.push_back(answer);\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is we will maintain the spaces required for the words in the temporary vector and also the number of characters in the current word. If we found that the total lenght is greater than or equal to maximum length then we will perform the operation.\\n\\n        int spacesReq;\\n        int currLen = 0;\\n\\n        vector<string> temp;\\n        vector<string> result;\\n\\n        for(auto &word : words){\\n            int wordLen = word.size();\\n            spacesReq = temp.size();\\n            if(currLen + wordLen + spacesReq > maxWidth){\\n                string answer = \"\";\\n                int spaces = maxWidth - currLen;\\n                if(temp.size() == 1){\\n                    answer = temp[0];\\n                    while(spaces --> 0) answer += \" \";\\n                    result.push_back(answer);\\n                }\\n                else{\\n                    int spaceBetween = spaces / (temp.size() - 1);\\n                    int extraSpaces = maxWidth - currLen - spaceBetween * (temp.size() - 1);\\n                    answer = temp[0];\\n                    string bet = \"\";\\n                    while(spaceBetween --> 0) bet += \" \";\\n                    for(int i = 1 ; i < temp.size() ; i++){\\n                        answer += bet;\\n                        if(extraSpaces > 0){\\n                            answer += \" \";\\n                            extraSpaces -= 1;\\n                        }\\n                        answer += temp[i];\\n                    }\\n                    result.push_back(answer);\\n                }\\n                temp.clear();\\n                currLen = wordLen;\\n                temp.push_back(word);\\n            }\\n            else{\\n                currLen += wordLen;\\n                temp.push_back(word);\\n            }\\n        }\\n\\n        if(temp.size() >= 1){\\n            string answer = temp[0];\\n            for(int i = 1 ; i < temp.size() ; i++){\\n                answer += \" \" + temp[i];\\n            }\\n            while(answer.size() < maxWidth) answer += \" \";\\n            result.push_back(answer);\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952371,
                "title": "c-solution-for-text-justification-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to format a given list of words into lines of a given maximum width while adhering to the specified rules for justification. The key intuition is to process the words one by one, adding them to the current line as long as they fit within the maxWidth. If the current line is not full, we distribute extra spaces between the words to achieve full justification. When a line is full, we move on to the next line. We repeat this process until all words are processed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty list to store the resulting lines.\\n1. Loop through the words array, processing each word and building lines.\\n1. For each line, calculate the number of words that can fit in the line without exceeding maxWidth.\\n1. Calculate the total spaces needed to achieve full justification for the words in the line.\\n1. Depending on whether it\\'s the last line or there\\'s only one word in the line, handle left justification.\\n1. For other lines, calculate the spaces between words and distribute them evenly.\\n1. Add the constructed line to the result list.\\n1. Move the word index to the next word that was not included in the current line.\\n1. Return the list of formatted lines.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(n), where n is the number of words in the input array. We iterate through each word once, and for each word, we perform constant time operations like calculating lengths and spaces.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n + m), where n is the number of words in the input array and m is the length of the longest word. We store the formatted lines in a list, which takes O(n) space. Additionally, we use StringBuilder to construct the lines, which might require up to O(m) space for each line during the construction process.\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = GetEndIndex(words, startIndex, maxWidth);\\n            int spaceCount = endIndex - startIndex;\\n\\n            StringBuilder line = new StringBuilder();\\n\\n            if (spaceCount == 0 || endIndex == words.Length - 1) {\\n                // Left-justify the last line or lines with only one word.\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        line.Append(\\' \\');\\n                    }\\n                }\\n                line.Append(\\' \\', maxWidth - line.Length);\\n            } else {\\n                int totalSpaces = maxWidth - CalculateWordLength(words, startIndex, endIndex);\\n                int spacesBetweenWords = totalSpaces / spaceCount;\\n                int extraSpaces = totalSpaces % spaceCount;\\n\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        int spaces = spacesBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                        line.Append(\\' \\', spaces);\\n                        extraSpaces--;\\n                    }\\n                }\\n            }\\n\\n            result.Add(line.ToString());\\n            startIndex = endIndex + 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int GetEndIndex(string[] words, int startIndex, int maxWidth) {\\n        int endIndex = startIndex;\\n        int lineLength = words[startIndex].Length;\\n\\n        while (endIndex + 1 < words.Length && lineLength + words[endIndex + 1].Length + 1 <= maxWidth) {\\n            endIndex++;\\n            lineLength += words[endIndex].Length + 1;\\n        }\\n\\n        return endIndex;\\n    }\\n\\n    private int CalculateWordLength(string[] words, int startIndex, int endIndex) {\\n        int length = 0;\\n        for (int i = startIndex; i <= endIndex; i++) {\\n            length += words[i].Length;\\n        }\\n        return length;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        List<string> result = new List<string>();\\n        int startIndex = 0;\\n\\n        while (startIndex < words.Length) {\\n            int endIndex = GetEndIndex(words, startIndex, maxWidth);\\n            int spaceCount = endIndex - startIndex;\\n\\n            StringBuilder line = new StringBuilder();\\n\\n            if (spaceCount == 0 || endIndex == words.Length - 1) {\\n                // Left-justify the last line or lines with only one word.\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        line.Append(\\' \\');\\n                    }\\n                }\\n                line.Append(\\' \\', maxWidth - line.Length);\\n            } else {\\n                int totalSpaces = maxWidth - CalculateWordLength(words, startIndex, endIndex);\\n                int spacesBetweenWords = totalSpaces / spaceCount;\\n                int extraSpaces = totalSpaces % spaceCount;\\n\\n                for (int i = startIndex; i <= endIndex; i++) {\\n                    line.Append(words[i]);\\n                    if (i < endIndex) {\\n                        int spaces = spacesBetweenWords + (extraSpaces > 0 ? 1 : 0);\\n                        line.Append(\\' \\', spaces);\\n                        extraSpaces--;\\n                    }\\n                }\\n            }\\n\\n            result.Add(line.ToString());\\n            startIndex = endIndex + 1;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int GetEndIndex(string[] words, int startIndex, int maxWidth) {\\n        int endIndex = startIndex;\\n        int lineLength = words[startIndex].Length;\\n\\n        while (endIndex + 1 < words.Length && lineLength + words[endIndex + 1].Length + 1 <= maxWidth) {\\n            endIndex++;\\n            lineLength += words[endIndex].Length + 1;\\n        }\\n\\n        return endIndex;\\n    }\\n\\n    private int CalculateWordLength(string[] words, int startIndex, int endIndex) {\\n        int length = 0;\\n        for (int i = startIndex; i <= endIndex; i++) {\\n            length += words[i].Length;\\n        }\\n        return length;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952286,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> result;\\n        for(int i = 0, j; i < words.size(); i = j) {\\n            int width = 0;\\n            for(j = i; j < words.size() && width + words[j].size() + j - i <= maxWidth; j++) {\\n                width += words[j].size();\\n            }\\n            int space = 1, extra = 0;\\n            if(j - i != 1 && j != words.size()) {\\n                space = (maxWidth - width) / (j - i - 1);\\n                extra = (maxWidth - width) % (j - i - 1);\\n            }\\n            string line = words[i];\\n            for(int k = i + 1; k < j; k++) {\\n                line += string(space, \\' \\');\\n                if(extra > 0) {\\n                    extra--;\\n                    line += \" \";\\n                }\\n                line += words[k];\\n            }\\n            \\n            line += string(maxWidth - line.size(), \\' \\');\\n            result.push_back(line);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952236,
                "title": "0ms-o-n-most-efficient-solution-simplest-code-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem, despite marked hard, is actually a simple one. It requires no algorithm skills but edge case handlings. The key is to simply keep your code simple and readable, so that you know the edge cases are properly covered.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first scan words, do some arithmetics to find width and decide a line, then we pack a line, in simple iterations.\\n```\\nint width = words[start].size();\\nint end = start + 1;\\nwhile (end < words.size()) {\\n  int new_width = width + words[end].size() + 1;\\n  if (new_width > maxWidth) {\\n    break;\\n  }\\n  width = new_width;\\n  ++end;\\n}\\n// Now we pack words[start, end) into a line.\\n```\\nNothing is tricky here except to remember the `+1` for each extra words.\\n\\nThen we pack `words[start, end)` into a single text line, with spaces properly distributed.\\nBy default each gap between words have one space, but in order to (also) right justify the text line we need to add extra spaces. And we might also need to add one more extra space for some gaps in the left. These can all be calculated using simple arithmetics.\\nMake sure to compute `extra_space_per_gap` and `one_more_space_gaps` **outside the inner loop** as a good habit for performance and readability.\\n```\\nint count = end - start;\\nstring& line = text.emplace_back();\\nline.append(words[start]);\\n\\nint extra_space_per_gap = 0;\\nint one_more_space_gaps = 0;\\nif (count > 1 && end < words.size()) {  // Not last line or single word line.\\n  int gap = count - 1;\\n  int extra_space = maxWidth - width;\\n  extra_space_per_gap = extra_space / gap;\\n  one_more_space_gaps = extra_space % gap;\\n}\\nfor (int i = 1; i < count; ++i) {\\n  int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n  line.resize(line.size() + space_count, \\' \\');\\n  line.append(words[start + i]);\\n}\\nline.resize(maxWidth, \\' \\');\\n```\\nNote that we need to handle last line differently.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$ Where $N$ is the size of the input data. More specifically $N$ is the sum of the lengths of all the `words`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int start = 0;\\n    vector<string> text;\\n    while (start < words.size()) {\\n      int width = words[start].size();\\n      int end = start + 1;\\n      while (end < words.size()) {\\n        int new_width = width + words[end].size() + 1;\\n        if (new_width > maxWidth) {\\n          break;\\n        }\\n        width = new_width;\\n        ++end;\\n      }\\n      // Now we pack words[start, end) into a line.\\n      int count = end - start;\\n      string& line = text.emplace_back();\\n      line.append(words[start]);\\n\\n      int extra_space_per_gap = 0;\\n      int one_more_space_gaps = 0;\\n      if (count > 1 && end < words.size()) {  // Not last line or single word line.\\n        int gap = count - 1;\\n        int extra_space = maxWidth - width;\\n        extra_space_per_gap = extra_space / gap;\\n        one_more_space_gaps = extra_space % gap;\\n      }\\n      for (int i = 1; i < count; ++i) {\\n        int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n        line.resize(line.size() + space_count, \\' \\');\\n        line.append(words[start + i]);\\n      }\\n      line.resize(maxWidth, \\' \\');\\n      start = end;\\n    }\\n    return text;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nint width = words[start].size();\\nint end = start + 1;\\nwhile (end < words.size()) {\\n  int new_width = width + words[end].size() + 1;\\n  if (new_width > maxWidth) {\\n    break;\\n  }\\n  width = new_width;\\n  ++end;\\n}\\n// Now we pack words[start, end) into a line.\\n```\n```\\nint count = end - start;\\nstring& line = text.emplace_back();\\nline.append(words[start]);\\n\\nint extra_space_per_gap = 0;\\nint one_more_space_gaps = 0;\\nif (count > 1 && end < words.size()) {  // Not last line or single word line.\\n  int gap = count - 1;\\n  int extra_space = maxWidth - width;\\n  extra_space_per_gap = extra_space / gap;\\n  one_more_space_gaps = extra_space % gap;\\n}\\nfor (int i = 1; i < count; ++i) {\\n  int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n  line.resize(line.size() + space_count, \\' \\');\\n  line.append(words[start + i]);\\n}\\nline.resize(maxWidth, \\' \\');\\n```\n```\\nclass Solution {\\npublic:\\n  vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n    int start = 0;\\n    vector<string> text;\\n    while (start < words.size()) {\\n      int width = words[start].size();\\n      int end = start + 1;\\n      while (end < words.size()) {\\n        int new_width = width + words[end].size() + 1;\\n        if (new_width > maxWidth) {\\n          break;\\n        }\\n        width = new_width;\\n        ++end;\\n      }\\n      // Now we pack words[start, end) into a line.\\n      int count = end - start;\\n      string& line = text.emplace_back();\\n      line.append(words[start]);\\n\\n      int extra_space_per_gap = 0;\\n      int one_more_space_gaps = 0;\\n      if (count > 1 && end < words.size()) {  // Not last line or single word line.\\n        int gap = count - 1;\\n        int extra_space = maxWidth - width;\\n        extra_space_per_gap = extra_space / gap;\\n        one_more_space_gaps = extra_space % gap;\\n      }\\n      for (int i = 1; i < count; ++i) {\\n        int space_count = 1 + extra_space_per_gap + (one_more_space_gaps-- > 0);\\n        line.resize(line.size() + space_count, \\' \\');\\n        line.append(words[start + i]);\\n      }\\n      line.resize(maxWidth, \\' \\');\\n      start = end;\\n    }\\n    return text;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952203,
                "title": "c-easy-solution-100-o-n",
                "content": "#### Approach:\\nI will break the question into 2 sub questions: \\n1. First part is finding which how many words I can include in my current line. I would just be finding be the words not adding them in the line now, I will add the words in the line in second part.\\n2.  Second part is adding words in the line and also justifying the line at the same time.\\n3. Repeating the 1st and 2nd part for every line till every word is added in some line.\\n\\n#### Points to Note: \\n1. I will **not** make the line first and then justify it.\\n2. While updating current length of line I am adding 1+words[i].size() (except when current length is 0 where I add words[i[.size()).\\n\\tThis extra plus 1 is kept because every word in a line must have atleast 1 space between them.\\n3. Say there are m words in line for justifying the line and *left* is the amount of extra space in line. \\n\\tSo in total there will m-1 number of gaps in the line , so *left* number of spaces needs to be added in the line for justifying. \\n\\tIn the 1st (left%(m-1) ) gaps there will be *((left/gap)+1)* extra spaces and in the remaining spaces there will be *(left/gap)* extra spaces.\\n4. In case there is only a single word in line or it is the last line then all the extra spaces needs to be added at the end of the line.\\n5. Try to use words[i].size() instead of words[i].length to find out size of word. The .size() method runs in O(1) time while the .length() runs in O(n) time.\\n\\n\\n#### Code:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n\\t\\tint k=maxWidth;\\n        string temp=\"\";\\n        int n=words.size();\\n        \\n        vector<string> ans;\\n        \\n        int i=0;\\n        int currsize=0;\\n        int prev=0;\\n        \\n        while(i<n){\\n            \\n            \\n            \\n            int curr=words[i].size();\\n            i++;\\n            \\n            while(i<n and (curr+words[i].size()+1)<=k){\\n                curr+=(words[i].size()+1);\\n                i++;\\n            }\\n            \\n            string temp=\"\";\\n            ans.push_back(temp);\\n            int m=i-prev;\\n            \\n            if(i==n or m==1){\\n                \\n                for(int j=prev;j<i;j++){\\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                }\\n                \\n                int z=ans[currsize].size();\\n                while(z<k){\\n                    ans[currsize]+=\\' \\';\\n                    z++;\\n                }\\n                \\n            }else{\\n                \\n                int gap=m-1;\\n                int left=k-curr;\\n                \\n                int a=left/gap;\\n                \\n                int x=(gap-(left%gap)) ; // gaps with \\'a\\' no. of spaces\\n                int y=left%gap ; // gaps with \\'a+1\\' no. of spaces\\n                \\n                \\n                for(int j=prev;j<i;j++){\\n                    \\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                    \\n                    if(x>0 or y>0){\\n                        for(int t=0;t<a;t++){\\n                            ans[currsize]+=\\' \\';\\n                        }\\n                    }\\n                    \\n                    if(y>0){\\n                        ans[currsize]+=\\' \\';\\n                        y--;\\n                    }else{\\n                        x--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currsize++;\\n            prev=i;\\n            \\n        }\\n        \\n        \\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        \\n\\t\\tint k=maxWidth;\\n        string temp=\"\";\\n        int n=words.size();\\n        \\n        vector<string> ans;\\n        \\n        int i=0;\\n        int currsize=0;\\n        int prev=0;\\n        \\n        while(i<n){\\n            \\n            \\n            \\n            int curr=words[i].size();\\n            i++;\\n            \\n            while(i<n and (curr+words[i].size()+1)<=k){\\n                curr+=(words[i].size()+1);\\n                i++;\\n            }\\n            \\n            string temp=\"\";\\n            ans.push_back(temp);\\n            int m=i-prev;\\n            \\n            if(i==n or m==1){\\n                \\n                for(int j=prev;j<i;j++){\\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                }\\n                \\n                int z=ans[currsize].size();\\n                while(z<k){\\n                    ans[currsize]+=\\' \\';\\n                    z++;\\n                }\\n                \\n            }else{\\n                \\n                int gap=m-1;\\n                int left=k-curr;\\n                \\n                int a=left/gap;\\n                \\n                int x=(gap-(left%gap)) ; // gaps with \\'a\\' no. of spaces\\n                int y=left%gap ; // gaps with \\'a+1\\' no. of spaces\\n                \\n                \\n                for(int j=prev;j<i;j++){\\n                    \\n                    ans[currsize]+=words[j];\\n                    if(j!=(i-1)){\\n                        ans[currsize]+=\\' \\';\\n                    }\\n                    \\n                    if(x>0 or y>0){\\n                        for(int t=0;t<a;t++){\\n                            ans[currsize]+=\\' \\';\\n                        }\\n                    }\\n                    \\n                    if(y>0){\\n                        ans[currsize]+=\\' \\';\\n                        y--;\\n                    }else{\\n                        x--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currsize++;\\n            prev=i;\\n            \\n        }\\n        \\n        \\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952174,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        n=len(words)\\n        ans=[]\\n        i=0\\n        while i<n:\\n            temp=[]\\n            seen=0\\n            cur=\"\"\\n            while i<n and seen+len(words[i])+len(temp)<=maxWidth:\\n                temp.append(words[i])\\n                seen+=len(words[i])\\n                i+=1\\n\\n            m=len(temp)\\n            if (m-1)!=0 and i!=n:\\n                q,r=divmod(maxWidth-seen,(m-1))\\n                sp=[q+(1 if j<r else 0) for j in range(m-1)]\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'*sp[j]\\n                cur+=temp[-1]\\n\\n            else:\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'\\n                cur+=temp[-1]\\n                cur+=\\' \\'*(maxWidth-len(cur))\\n\\n            ans.append(cur)\\n        return ans                        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        n=len(words)\\n        ans=[]\\n        i=0\\n        while i<n:\\n            temp=[]\\n            seen=0\\n            cur=\"\"\\n            while i<n and seen+len(words[i])+len(temp)<=maxWidth:\\n                temp.append(words[i])\\n                seen+=len(words[i])\\n                i+=1\\n\\n            m=len(temp)\\n            if (m-1)!=0 and i!=n:\\n                q,r=divmod(maxWidth-seen,(m-1))\\n                sp=[q+(1 if j<r else 0) for j in range(m-1)]\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'*sp[j]\\n                cur+=temp[-1]\\n\\n            else:\\n                for j in range(m-1):\\n                    cur+=temp[j]+\\' \\'\\n                cur+=temp[-1]\\n                cur+=\\' \\'*(maxWidth-len(cur))\\n\\n            ans.append(cur)\\n        return ans                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771390,
                "title": "text-justification-o-n-javascript-memory-87-99-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar fullJustify = function (words, maxWidth) {\\n  const builtArray = [];\\n  let tempArray = [];\\n  let tempLen = 0;\\n\\n  const createSpaceOfGivenSize = size => {\\n    let space = ``;\\n    for (let index = 0; index < size; index++) {\\n      space += ` `;\\n    }\\n    return space;\\n  };\\n\\n  //pack your words in a greedy approach; that is, pack as many words as you can in each line\\n  for (let index = 0; index < words.length; index++) {\\n    if (tempLen + tempArray.length + words[index].length <= maxWidth) {\\n      tempArray.push (words[index]);\\n      tempLen += words[index].length;\\n    } else {\\n      builtArray.push ({\\n        array: tempArray,\\n        size: tempLen,\\n      });\\n      tempArray = [words[index]];\\n      tempLen = words[index].length;\\n      continue;\\n    }\\n  }\\n\\n  //for last iteration\\n  builtArray.push ({\\n    array: tempArray,\\n    size: tempLen,\\n  });\\n  const output = [];\\n  for (let index = 0; index < builtArray.length; index++) {\\n    let {array, size} = builtArray[index];\\n    const totalWord = array.length;\\n    const totalRequiredSpace = maxWidth - size;\\n    if (index === builtArray.length - 1) {\\n      // because the last line must be left-justified instead of fully-justified.\\n      const str =\\n        array.join (` `) +\\n        createSpaceOfGivenSize (totalRequiredSpace - (array.length - 1));\\n      output.push (str);\\n    } else {\\n      let extraSpace = totalRequiredSpace % (totalWord - 1);\\n      //If the number of spaces on a line does not divide evenly between words,\\n      if (extraSpace) {\\n        const spaces = [];\\n        //Extra spaces between words should be distributed as evenly as possible.\\n        let spacePerWord = (totalRequiredSpace - extraSpace) / (totalWord - 1);\\n        for (let index = 0; index < totalWord - 1; index++) {\\n          spaces.push (createSpaceOfGivenSize (spacePerWord));\\n        }\\n        let tempTotalWord = totalWord - 1 - 1;\\n        // the empty slots on the left will be assigned more spaces than the slots on the right.\\n        while (extraSpace) {\\n          const temp = extraSpace % tempTotalWord;\\n          spacePerWord = parseInt (extraSpace / tempTotalWord);\\n          for (let index = 0; index < tempTotalWord; index++) {\\n            spaces[index] += createSpaceOfGivenSize (spacePerWord);\\n          }\\n          tempTotalWord -= 1;\\n          extraSpace = temp;\\n        }\\n        let tempString = ``;\\n        for (let index = 0; index < totalWord; index++) {\\n          //Each line has exactly maxWidth characters.\\n          if (spaces[index]) {\\n            tempString += array[index] + spaces[index] || ``;\\n          } else {\\n            tempString += array[index];\\n          }\\n        }\\n        output.push (tempString);\\n      } else {\\n        //If the number of spaces on a line divide evenly between words,\\n        if (totalWord - 1) {\\n          output.push (\\n            array.join (\\n              createSpaceOfGivenSize (totalRequiredSpace / (totalWord - 1))\\n            )\\n          );\\n        } else {\\n          output.push (array[0] + createSpaceOfGivenSize (totalRequiredSpace));\\n        }\\n      }\\n    }\\n  }\\n  return output;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dee00410-e5ae-4791-a47c-9d22b55f5f1b_1689480610.4518938.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fullJustify = function (words, maxWidth) {\\n  const builtArray = [];\\n  let tempArray = [];\\n  let tempLen = 0;\\n\\n  const createSpaceOfGivenSize = size => {\\n    let space = ``;\\n    for (let index = 0; index < size; index++) {\\n      space += ` `;\\n    }\\n    return space;\\n  };\\n\\n  //pack your words in a greedy approach; that is, pack as many words as you can in each line\\n  for (let index = 0; index < words.length; index++) {\\n    if (tempLen + tempArray.length + words[index].length <= maxWidth) {\\n      tempArray.push (words[index]);\\n      tempLen += words[index].length;\\n    } else {\\n      builtArray.push ({\\n        array: tempArray,\\n        size: tempLen,\\n      });\\n      tempArray = [words[index]];\\n      tempLen = words[index].length;\\n      continue;\\n    }\\n  }\\n\\n  //for last iteration\\n  builtArray.push ({\\n    array: tempArray,\\n    size: tempLen,\\n  });\\n  const output = [];\\n  for (let index = 0; index < builtArray.length; index++) {\\n    let {array, size} = builtArray[index];\\n    const totalWord = array.length;\\n    const totalRequiredSpace = maxWidth - size;\\n    if (index === builtArray.length - 1) {\\n      // because the last line must be left-justified instead of fully-justified.\\n      const str =\\n        array.join (` `) +\\n        createSpaceOfGivenSize (totalRequiredSpace - (array.length - 1));\\n      output.push (str);\\n    } else {\\n      let extraSpace = totalRequiredSpace % (totalWord - 1);\\n      //If the number of spaces on a line does not divide evenly between words,\\n      if (extraSpace) {\\n        const spaces = [];\\n        //Extra spaces between words should be distributed as evenly as possible.\\n        let spacePerWord = (totalRequiredSpace - extraSpace) / (totalWord - 1);\\n        for (let index = 0; index < totalWord - 1; index++) {\\n          spaces.push (createSpaceOfGivenSize (spacePerWord));\\n        }\\n        let tempTotalWord = totalWord - 1 - 1;\\n        // the empty slots on the left will be assigned more spaces than the slots on the right.\\n        while (extraSpace) {\\n          const temp = extraSpace % tempTotalWord;\\n          spacePerWord = parseInt (extraSpace / tempTotalWord);\\n          for (let index = 0; index < tempTotalWord; index++) {\\n            spaces[index] += createSpaceOfGivenSize (spacePerWord);\\n          }\\n          tempTotalWord -= 1;\\n          extraSpace = temp;\\n        }\\n        let tempString = ``;\\n        for (let index = 0; index < totalWord; index++) {\\n          //Each line has exactly maxWidth characters.\\n          if (spaces[index]) {\\n            tempString += array[index] + spaces[index] || ``;\\n          } else {\\n            tempString += array[index];\\n          }\\n        }\\n        output.push (tempString);\\n      } else {\\n        //If the number of spaces on a line divide evenly between words,\\n        if (totalWord - 1) {\\n          output.push (\\n            array.join (\\n              createSpaceOfGivenSize (totalRequiredSpace / (totalWord - 1))\\n            )\\n          );\\n        } else {\\n          output.push (array[0] + createSpaceOfGivenSize (totalRequiredSpace));\\n        }\\n      }\\n    }\\n  }\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631796,
                "title": "solution-in-java-python",
                "content": "## Just follow through the code and you will be good to go.\\n---\\n# Code\\n```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> line = new ArrayList<>();\\n        int ctr = 0;\\n        int width = 0;\\n        while(ctr<words.length)\\n        {\\n            String word = words[ctr];\\n            if(word.length()+width<=maxWidth)\\n            {\\n                line.add(word);\\n                width+=word.length()+1;\\n                ctr++;\\n            }\\n            else\\n            {\\n                int spaces = maxWidth-width+line.size();\\n                int j = 0;\\n                int k = 0;\\n                while(k < spaces)\\n                {\\n                    if(j>=line.size()-1)\\n                    {\\n                        j = 0;\\n                    }\\n                    line.set(j,line.get(j)+\" \");\\n                    k++;\\n                    j++;\\n                }\\n                String temp = \"\";\\n                for(String str: line)\\n                {\\n                    temp+=str;\\n                }\\n                result.add(temp);\\n                line.clear();\\n                width = 0;\\n            }\\n        }\\n        for(int i = 0;i<line.size()-1;i++)\\n        {\\n            line.set(i,line.get(i)+\" \");\\n        }\\n        for(int x = 0;x<maxWidth-width+1;x++)\\n        {\\n            line.set(line.size()-1,line.get(line.size()-1)+\" \");\\n        }\\n        String temp = \"\";\\n        for(String str: line)\\n        {\\n            temp+=str;\\n        }\\n        result.add(temp);\\n        return result;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []\\n        width = 0 \\n        i = 0\\n        while i<len(words):\\n            word = words[i]\\n            if width+len(word)<=maxWidth:\\n                line.append(word)\\n                width+=len(word)+1\\n                i+=1\\n            else:\\n                spaces = maxWidth-width+len(line)\\n                j = 0\\n                s = 0\\n                while s<spaces:\\n                    if j>=len(line)-1:\\n                        j=0\\n                    line[j]+=\" \"\\n                    s+=1\\n                    j+=1\\n                result.append(\"\".join(line))\\n                line = []\\n                width = 0\\n        for word in range(len(line)-1):\\n            line[word]+=\" \"\\n        line[-1]+=\" \" * (maxWidth-width+1)\\n        result.append(\"\".join(line))\\n        return result\\n\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.\\uD83D\\uDC4D*\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> line = new ArrayList<>();\\n        int ctr = 0;\\n        int width = 0;\\n        while(ctr<words.length)\\n        {\\n            String word = words[ctr];\\n            if(word.length()+width<=maxWidth)\\n            {\\n                line.add(word);\\n                width+=word.length()+1;\\n                ctr++;\\n            }\\n            else\\n            {\\n                int spaces = maxWidth-width+line.size();\\n                int j = 0;\\n                int k = 0;\\n                while(k < spaces)\\n                {\\n                    if(j>=line.size()-1)\\n                    {\\n                        j = 0;\\n                    }\\n                    line.set(j,line.get(j)+\" \");\\n                    k++;\\n                    j++;\\n                }\\n                String temp = \"\";\\n                for(String str: line)\\n                {\\n                    temp+=str;\\n                }\\n                result.add(temp);\\n                line.clear();\\n                width = 0;\\n            }\\n        }\\n        for(int i = 0;i<line.size()-1;i++)\\n        {\\n            line.set(i,line.get(i)+\" \");\\n        }\\n        for(int x = 0;x<maxWidth-width+1;x++)\\n        {\\n            line.set(line.size()-1,line.get(line.size()-1)+\" \");\\n        }\\n        String temp = \"\";\\n        for(String str: line)\\n        {\\n            temp+=str;\\n        }\\n        result.add(temp);\\n        return result;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        result = []\\n        line = []\\n        width = 0 \\n        i = 0\\n        while i<len(words):\\n            word = words[i]\\n            if width+len(word)<=maxWidth:\\n                line.append(word)\\n                width+=len(word)+1\\n                i+=1\\n            else:\\n                spaces = maxWidth-width+len(line)\\n                j = 0\\n                s = 0\\n                while s<spaces:\\n                    if j>=len(line)-1:\\n                        j=0\\n                    line[j]+=\" \"\\n                    s+=1\\n                    j+=1\\n                result.append(\"\".join(line))\\n                line = []\\n                width = 0\\n        for word in range(len(line)-1):\\n            line[word]+=\" \"\\n        line[-1]+=\" \" * (maxWidth-width+1)\\n        result.append(\"\".join(line))\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525236,
                "title": "pure-c",
                "content": "# Implemented:\\n```\\n1. cJust()        - Center justify\\n2. lJust()        - Left justify for last string\\n3. countStrings() - Strings counter for accurate mem alloc\\n```\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth);\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr);\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr);\\n\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize)\\n{\\n    *returnSize = countStrings(words, wordsSize, maxWidth);     // Get Number Of Justified Strings\\n    int currStr = 0;                                            // Current Result String Index\\n    const char **strings = calloc(sizeof(char *), *returnSize); // Mem Alloc\\n    for(int i = 0; i < *returnSize; i++)                        // Mem Alloc\\n        strings[i] = calloc(sizeof(char), ( maxWidth + 1 ) );   // Mem Alloc\\n\\n    char ** tail     = &words[0]; // Tail of Accumulated Words\\n    char ** head     = tail;      // Head of Accumulated Words\\n    char ** lastWord = &words[wordsSize-1];\\n    int len = strlen(*head);   // Init len with first word length value\\n\\n    for ( head; ; head++ )  // Iterate Each Word\\n    {\\n        if ( head == lastWord ) { // If Last Word - Justify Accumulated Words and Break\\n            lJust(tail, head - tail + 1, maxWidth, strings[currStr]);\\n            break;\\n        }\\n        \\n        const int  nextWordLen = strlen(*(head + 1));\\n        const int  nextLen     = len + 1 + nextWordLen; // Accumulate String length. +1 space \\n        const bool lenExceeded = nextLen > maxWidth;  \\n\\n        if ( lenExceeded ) {\\n            cJust(tail, head - tail + 1, maxWidth, maxWidth - len, strings[currStr++]); // Justify String\\n            tail = head + 1; // Set New Tail\\n        }\\n\\n        len  = lenExceeded ?  nextWordLen : nextLen;  // Accumulate Length or Reset\\n    }\\n    return strings;\\n}\\n\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth)\\n{\\n    int counter = 0; // Strings Counter\\n    int len = strlen(words[0]); // Init Len With First Word Length Value\\n\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        if ( isLastWord ) { // If Last Word - Increase Counter And Break\\n            ++counter;\\n            break;\\n        }\\n        int nextWordLen = strlen(words[i + 1]); // Get Next Word Length\\n        int nextLen = len + 1 + nextWordLen;    // Get Summary Length Including Next Word And Spaces Between\\n\\n        if (nextLen > maxWidth) { // If Length Oversized - Increase Counter\\n            ++counter;\\n        }\\n        len = nextLen > maxWidth ? nextWordLen : nextLen;  // Update Summary Length\\n    }\\n    return counter;\\n}\\n\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr)\\n{\\n    int n = 0; // Index For jStr\\n    const int gaps = wordsSize == 1 ? 1 : wordsSize - 1; // Total Space Gaps\\n    int spaces = wordsSize-1 + extraSpaces; // Total Spaces To Insert\\n\\n    for( int i = 0; i<wordsSize; i++) // Iterate Each Word\\n    {\\n        while(*words[i]) {\\n            jStr[n++] = *(words[i]++); // Copy Aa Word To Result String\\n        }\\n        if ( n < maxWidth ) {            \\n            int nSp = spaces / ( gaps - i ) + ( spaces % ( gaps - i ) ? 1 : 0 ); // Calc Number Of Spaces To Insert\\n            spaces -= nSp;\\n            while(nSp--) { // Append Spaces After Word\\n                jStr[n++] = \\' \\';\\n            }\\n        }\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr)\\n{\\n    int n = 0;\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        while(*words[i]) { // Copy Aa Word To Result String\\n            jStr[n++] = *(words[i]++);\\n        }\\n        if ( isLastWord ) { // Last Word - Break\\n            break;\\n        }\\n        jStr[n++] = \\' \\'; // +1 Space\\n    }\\n    while ( n < maxWidth ) { // Fill The End With Spaces\\n        jStr[n++] = \\' \\';\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. cJust()        - Center justify\\n2. lJust()        - Left justify for last string\\n3. countStrings() - Strings counter for accurate mem alloc\\n```\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth);\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr);\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr);\\n\\nchar ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize)\\n{\\n    *returnSize = countStrings(words, wordsSize, maxWidth);     // Get Number Of Justified Strings\\n    int currStr = 0;                                            // Current Result String Index\\n    const char **strings = calloc(sizeof(char *), *returnSize); // Mem Alloc\\n    for(int i = 0; i < *returnSize; i++)                        // Mem Alloc\\n        strings[i] = calloc(sizeof(char), ( maxWidth + 1 ) );   // Mem Alloc\\n\\n    char ** tail     = &words[0]; // Tail of Accumulated Words\\n    char ** head     = tail;      // Head of Accumulated Words\\n    char ** lastWord = &words[wordsSize-1];\\n    int len = strlen(*head);   // Init len with first word length value\\n\\n    for ( head; ; head++ )  // Iterate Each Word\\n    {\\n        if ( head == lastWord ) { // If Last Word - Justify Accumulated Words and Break\\n            lJust(tail, head - tail + 1, maxWidth, strings[currStr]);\\n            break;\\n        }\\n        \\n        const int  nextWordLen = strlen(*(head + 1));\\n        const int  nextLen     = len + 1 + nextWordLen; // Accumulate String length. +1 space \\n        const bool lenExceeded = nextLen > maxWidth;  \\n\\n        if ( lenExceeded ) {\\n            cJust(tail, head - tail + 1, maxWidth, maxWidth - len, strings[currStr++]); // Justify String\\n            tail = head + 1; // Set New Tail\\n        }\\n\\n        len  = lenExceeded ?  nextWordLen : nextLen;  // Accumulate Length or Reset\\n    }\\n    return strings;\\n}\\n\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n// -------------------------------------------------------------------------------------------------------\\n\\nint countStrings(char ** words, int wordsSize, int maxWidth)\\n{\\n    int counter = 0; // Strings Counter\\n    int len = strlen(words[0]); // Init Len With First Word Length Value\\n\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        if ( isLastWord ) { // If Last Word - Increase Counter And Break\\n            ++counter;\\n            break;\\n        }\\n        int nextWordLen = strlen(words[i + 1]); // Get Next Word Length\\n        int nextLen = len + 1 + nextWordLen;    // Get Summary Length Including Next Word And Spaces Between\\n\\n        if (nextLen > maxWidth) { // If Length Oversized - Increase Counter\\n            ++counter;\\n        }\\n        len = nextLen > maxWidth ? nextWordLen : nextLen;  // Update Summary Length\\n    }\\n    return counter;\\n}\\n\\nvoid cJust(char ** words, int wordsSize, int maxWidth, int extraSpaces, char * jStr)\\n{\\n    int n = 0; // Index For jStr\\n    const int gaps = wordsSize == 1 ? 1 : wordsSize - 1; // Total Space Gaps\\n    int spaces = wordsSize-1 + extraSpaces; // Total Spaces To Insert\\n\\n    for( int i = 0; i<wordsSize; i++) // Iterate Each Word\\n    {\\n        while(*words[i]) {\\n            jStr[n++] = *(words[i]++); // Copy Aa Word To Result String\\n        }\\n        if ( n < maxWidth ) {            \\n            int nSp = spaces / ( gaps - i ) + ( spaces % ( gaps - i ) ? 1 : 0 ); // Calc Number Of Spaces To Insert\\n            spaces -= nSp;\\n            while(nSp--) { // Append Spaces After Word\\n                jStr[n++] = \\' \\';\\n            }\\n        }\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\nvoid lJust(char ** words, int wordsSize, int maxWidth, char * jStr)\\n{\\n    int n = 0;\\n    for (int i = 0; i < wordsSize; i++ )  // Iterate Each Word\\n    {\\n        bool isLastWord = ( i == wordsSize - 1 );\\n\\n        while(*words[i]) { // Copy Aa Word To Result String\\n            jStr[n++] = *(words[i]++);\\n        }\\n        if ( isLastWord ) { // Last Word - Break\\n            break;\\n        }\\n        jStr[n++] = \\' \\'; // +1 Space\\n    }\\n    while ( n < maxWidth ) { // Fill The End With Spaces\\n        jStr[n++] = \\' \\';\\n    }\\n    jStr[n] =\\'\\\\0\\'; // Terminate String\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481581,
                "title": "c-100-fast-30-lines-comments-added",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<string> answer;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Step 1: find out how many words can fit on line with one space between words\\n            int begin = i, lineSize = words[i].size();\\n            while (i + 1 < n && words[i + 1].size() + lineSize + 1 <= maxWidth) {\\n                lineSize += words[++i].size() + 1; // +1 for space between prev and cur words\\n            }\\n            \\n            // Step 2: determine space size (round-robin distribution)\\n            int numWords = i - begin + 1, spaceSize = 1, numExtraSpaces = 0;\\n            if (numWords > 1 && i < n - 1) { // if greater than one word in line and this isn\\'t the last line\\n                int remaining = maxWidth - lineSize;\\n                spaceSize = remaining / (numWords - 1) + 1; // +1 since lineSize already includes 1 space betweeen words\\n                numExtraSpaces = remaining % (numWords - 1);\\n            }\\n            \\n            // Step 3: create line\\n            string line = words[begin];\\n            for (int j = 1; j < numWords; ++j) {\\n                // add space between prev and cur words\\n                line.append(spaceSize, \\' \\');\\n                if (j <= numExtraSpaces) {\\n                    line.push_back(\\' \\');\\n                }\\n                line += words[begin + j];\\n            }\\n            if (line.size() < maxWidth) { // add right padding\\n                line.append(maxWidth - line.size(), \\' \\');\\n            }\\n            \\n            answer.emplace_back(line);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n\\n![upvote2.jpg](https://assets.leetcode.com/users/images/a531facd-2a18-429a-9d39-94d46cddaf4b_1689310705.582009.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        vector<string> answer;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Step 1: find out how many words can fit on line with one space between words\\n            int begin = i, lineSize = words[i].size();\\n            while (i + 1 < n && words[i + 1].size() + lineSize + 1 <= maxWidth) {\\n                lineSize += words[++i].size() + 1; // +1 for space between prev and cur words\\n            }\\n            \\n            // Step 2: determine space size (round-robin distribution)\\n            int numWords = i - begin + 1, spaceSize = 1, numExtraSpaces = 0;\\n            if (numWords > 1 && i < n - 1) { // if greater than one word in line and this isn\\'t the last line\\n                int remaining = maxWidth - lineSize;\\n                spaceSize = remaining / (numWords - 1) + 1; // +1 since lineSize already includes 1 space betweeen words\\n                numExtraSpaces = remaining % (numWords - 1);\\n            }\\n            \\n            // Step 3: create line\\n            string line = words[begin];\\n            for (int j = 1; j < numWords; ++j) {\\n                // add space between prev and cur words\\n                line.append(spaceSize, \\' \\');\\n                if (j <= numExtraSpaces) {\\n                    line.push_back(\\' \\');\\n                }\\n                line += words[begin + j];\\n            }\\n            if (line.size() < maxWidth) { // add right padding\\n                line.append(maxWidth - line.size(), \\' \\');\\n            }\\n            \\n            answer.emplace_back(line);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907088,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2853652,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\npublic class Solution {\\n\\n    private class LineData {\\n\\n        int startIndexWords;\\n        int endIndexWords;\\n        int textLength;\\n        int singleSapcesBetweenWordsLength;\\n\\n        LineData(int index, String[] words) {\\n            if (index < words.length) {\\n                startIndexWords = index;\\n                endIndexWords = index;\\n                textLength = words[index].length();\\n                singleSapcesBetweenWordsLength = 0;\\n            }\\n        }\\n    }\\n\\n    private static final int SINGLE_SPACE = 1;\\n    private LineData lineData;\\n    private int maxWidth;\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        this.maxWidth = maxWidth;\\n        lineData = new LineData(0, words);\\n        List<String> fullyJustifiedText = new ArrayList<>();\\n\\n        for (int i = 1; i < words.length; ++i) {\\n\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n                continue;\\n            }\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = new LineData(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = new LineData(i, words);\\n        }\\n\\n        if (lineData.textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\n    private void createLine(List<String> fullyJustifiedText, String[] words, boolean isLastLine) {\\n\\n        int totalSpaceInLine = maxWidth - lineData.textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData.endIndexWords - lineData.startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        StringBuilder line = new StringBuilder();\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData.startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.add(line.toString());\\n            return;\\n        }\\n\\n        while (lineData.startIndexWords < lineData.endIndexWords) {\\n            line.append(words[lineData.startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData.startIndexWords;\\n        }\\n        line.append(words[lineData.endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.add(line.toString());\\n    }\\n\\n    private void appendSpaceToLine(int spacesToAppend, StringBuilder line) {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function (words, maxWidth) {\\n    const SINGLE_SPACE = 1;\\n    this.maxWidth = maxWidth;\\n    this.lineData = new LineData(0, words);\\n    const fullyJustifiedText = [];\\n\\n    for (let i = 1; i < words.length; ++i) {\\n\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length < maxWidth) {\\n            this.lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n            continue;\\n        }\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length === maxWidth) {\\n            lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n\\n            createLine(fullyJustifiedText, words, false);\\n            this.lineData = new LineData(++i, words);\\n            continue;\\n        }\\n        createLine(fullyJustifiedText, words, false);\\n        this.lineData = new LineData(i, words);\\n    }\\n\\n    if (this.lineData.textLength > 0) {\\n        createLine(fullyJustifiedText, words, true);\\n    }\\n    return fullyJustifiedText;\\n};\\n\\nclass LineData {\\n\\n    startIndexWords = 0;\\n    endIndexWords = 0;\\n    textLength = 0;\\n    singleSapcesBetweenWordsLength = 0;\\n\\n    /**\\n     * @param {number} index\\n     * @param {string[]} words\\n     */\\n    constructor(index, words) {\\n        if (index < words.length) {\\n            this.startIndexWords = index;\\n            this.endIndexWords = index;\\n            this.textLength = words[index].length;\\n            this.singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * @param {string[]} fullyJustifiedText\\n * @param {string[]} words \\n * @param {boolean} isLastLine\\n * @return {void}\\n */\\nfunction createLine(fullyJustifiedText, words, isLastLine) {\\n\\n    let totalSpaceInLine = this.maxWidth - this.lineData.textLength;\\n    let spaceBetweenWordsWithoutRemainder = 0;\\n    let totalSpaceRemainder = 0;\\n    let spaceAfterLastWordInLastLine = 0;\\n    let numberOfWords = this.lineData.endIndexWords - this.lineData.startIndexWords + 1;\\n\\n    if (!isLastLine) {\\n        spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? Math.floor(totalSpaceInLine / (numberOfWords - 1)) : totalSpaceInLine;\\n        totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n    } else {\\n        spaceBetweenWordsWithoutRemainder = 1;\\n        spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n    }\\n\\n    let line = [];\\n\\n    if (numberOfWords === 1 && !isLastLine) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n        fullyJustifiedText.push(line.join(\\'\\'));\\n        return;\\n    }\\n\\n    while (this.lineData.startIndexWords < this.lineData.endIndexWords) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        let spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n        appendSpaceToLine(spaceBetweenWords, line);\\n        ++this.lineData.startIndexWords;\\n    }\\n    line.push(words[this.lineData.endIndexWords]);\\n    appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n    fullyJustifiedText.push(line.join(\\'\\'));\\n}\\n\\n/**\\n * @param {number} spacesToAppend\\n * @param {string[]} line \\n * @return {void}\\n */\\nfunction appendSpaceToLine(spacesToAppend, line) {\\n    while (spacesToAppend-- > 0) {\\n        line.push(\" \");\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <string>\\n#include <memory>\\n#include <vector>\\nusing namespace std;\\n\\nstruct LineData {\\n    int startIndexWords = 0;\\n    int endIndexWords = 0;\\n    int textLength = 0;\\n    int singleSapcesBetweenWordsLength = 0;\\n\\n    LineData() = default;\\n\\n    LineData(int index, const vector<string>& words) {\\n        if (index < words.size()) {\\n            startIndexWords = index;\\n            endIndexWords = index;\\n            textLength = words[index].length();\\n            singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\n    inline static const int SINGLE_SPACE = 1;\\n    unique_ptr<LineData> lineData;\\n    size_t maxWidth;\\n\\npublic:\\n    vector<string> fullJustify(const vector<string>& words, int maxWidth) {\\n        this->maxWidth = maxWidth;\\n        lineData = make_unique<LineData>(0, words);\\n        vector<string> fullyJustifiedText;\\n\\n        for (int i = 1; i < words.size(); ++i) {\\n\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n                continue;\\n            }\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = make_unique<LineData>(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = make_unique<LineData>(i, words);\\n        }\\n\\n        if (lineData->textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\nprivate:\\n    void createLine(vector<string>& fullyJustifiedText, const vector<string>& words, bool isLastLine) const {\\n\\n        int totalSpaceInLine = maxWidth - lineData->textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData->endIndexWords - lineData->startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        string line;\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData->startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.push_back(line);\\n            return;\\n        }\\n\\n        while (lineData->startIndexWords < lineData->endIndexWords) {\\n            line.append(words[lineData->startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData->startIndexWords;\\n        }\\n        line.append(words[lineData->endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.push_back(line);\\n    }\\n\\n    void appendSpaceToLine(int spacesToAppend, string& line) const {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.List;\\nimport java.util.ArrayList;\\n\\npublic class Solution {\\n\\n    private class LineData {\\n\\n        int startIndexWords;\\n        int endIndexWords;\\n        int textLength;\\n        int singleSapcesBetweenWordsLength;\\n\\n        LineData(int index, String[] words) {\\n            if (index < words.length) {\\n                startIndexWords = index;\\n                endIndexWords = index;\\n                textLength = words[index].length();\\n                singleSapcesBetweenWordsLength = 0;\\n            }\\n        }\\n    }\\n\\n    private static final int SINGLE_SPACE = 1;\\n    private LineData lineData;\\n    private int maxWidth;\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        this.maxWidth = maxWidth;\\n        lineData = new LineData(0, words);\\n        List<String> fullyJustifiedText = new ArrayList<>();\\n\\n        for (int i = 1; i < words.length; ++i) {\\n\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n                continue;\\n            }\\n            if (lineData.textLength + lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData.textLength += words[i].length();\\n                ++lineData.singleSapcesBetweenWordsLength;\\n                ++lineData.endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = new LineData(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = new LineData(i, words);\\n        }\\n\\n        if (lineData.textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\n    private void createLine(List<String> fullyJustifiedText, String[] words, boolean isLastLine) {\\n\\n        int totalSpaceInLine = maxWidth - lineData.textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData.endIndexWords - lineData.startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        StringBuilder line = new StringBuilder();\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData.startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.add(line.toString());\\n            return;\\n        }\\n\\n        while (lineData.startIndexWords < lineData.endIndexWords) {\\n            line.append(words[lineData.startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData.startIndexWords;\\n        }\\n        line.append(words[lineData.endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.add(line.toString());\\n    }\\n\\n    private void appendSpaceToLine(int spacesToAppend, StringBuilder line) {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * @param {string[]} words\\n * @param {number} maxWidth\\n * @return {string[]}\\n */\\nvar fullJustify = function (words, maxWidth) {\\n    const SINGLE_SPACE = 1;\\n    this.maxWidth = maxWidth;\\n    this.lineData = new LineData(0, words);\\n    const fullyJustifiedText = [];\\n\\n    for (let i = 1; i < words.length; ++i) {\\n\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length < maxWidth) {\\n            this.lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n            continue;\\n        }\\n        if (this.lineData.textLength + this.lineData.singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length === maxWidth) {\\n            lineData.textLength += words[i].length;\\n            ++this.lineData.singleSapcesBetweenWordsLength;\\n            ++this.lineData.endIndexWords;\\n\\n            createLine(fullyJustifiedText, words, false);\\n            this.lineData = new LineData(++i, words);\\n            continue;\\n        }\\n        createLine(fullyJustifiedText, words, false);\\n        this.lineData = new LineData(i, words);\\n    }\\n\\n    if (this.lineData.textLength > 0) {\\n        createLine(fullyJustifiedText, words, true);\\n    }\\n    return fullyJustifiedText;\\n};\\n\\nclass LineData {\\n\\n    startIndexWords = 0;\\n    endIndexWords = 0;\\n    textLength = 0;\\n    singleSapcesBetweenWordsLength = 0;\\n\\n    /**\\n     * @param {number} index\\n     * @param {string[]} words\\n     */\\n    constructor(index, words) {\\n        if (index < words.length) {\\n            this.startIndexWords = index;\\n            this.endIndexWords = index;\\n            this.textLength = words[index].length;\\n            this.singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n}\\n\\n/**\\n * @param {string[]} fullyJustifiedText\\n * @param {string[]} words \\n * @param {boolean} isLastLine\\n * @return {void}\\n */\\nfunction createLine(fullyJustifiedText, words, isLastLine) {\\n\\n    let totalSpaceInLine = this.maxWidth - this.lineData.textLength;\\n    let spaceBetweenWordsWithoutRemainder = 0;\\n    let totalSpaceRemainder = 0;\\n    let spaceAfterLastWordInLastLine = 0;\\n    let numberOfWords = this.lineData.endIndexWords - this.lineData.startIndexWords + 1;\\n\\n    if (!isLastLine) {\\n        spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? Math.floor(totalSpaceInLine / (numberOfWords - 1)) : totalSpaceInLine;\\n        totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n    } else {\\n        spaceBetweenWordsWithoutRemainder = 1;\\n        spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n    }\\n\\n    let line = [];\\n\\n    if (numberOfWords === 1 && !isLastLine) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n        fullyJustifiedText.push(line.join(\\'\\'));\\n        return;\\n    }\\n\\n    while (this.lineData.startIndexWords < this.lineData.endIndexWords) {\\n        line.push(words[this.lineData.startIndexWords]);\\n        let spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n        appendSpaceToLine(spaceBetweenWords, line);\\n        ++this.lineData.startIndexWords;\\n    }\\n    line.push(words[this.lineData.endIndexWords]);\\n    appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n    fullyJustifiedText.push(line.join(\\'\\'));\\n}\\n\\n/**\\n * @param {number} spacesToAppend\\n * @param {string[]} line \\n * @return {void}\\n */\\nfunction appendSpaceToLine(spacesToAppend, line) {\\n    while (spacesToAppend-- > 0) {\\n        line.push(\" \");\\n    }\\n}\\n```\n```\\n#include <string>\\n#include <memory>\\n#include <vector>\\nusing namespace std;\\n\\nstruct LineData {\\n    int startIndexWords = 0;\\n    int endIndexWords = 0;\\n    int textLength = 0;\\n    int singleSapcesBetweenWordsLength = 0;\\n\\n    LineData() = default;\\n\\n    LineData(int index, const vector<string>& words) {\\n        if (index < words.size()) {\\n            startIndexWords = index;\\n            endIndexWords = index;\\n            textLength = words[index].length();\\n            singleSapcesBetweenWordsLength = 0;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\n    inline static const int SINGLE_SPACE = 1;\\n    unique_ptr<LineData> lineData;\\n    size_t maxWidth;\\n\\npublic:\\n    vector<string> fullJustify(const vector<string>& words, int maxWidth) {\\n        this->maxWidth = maxWidth;\\n        lineData = make_unique<LineData>(0, words);\\n        vector<string> fullyJustifiedText;\\n\\n        for (int i = 1; i < words.size(); ++i) {\\n\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() < maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n                continue;\\n            }\\n            if (lineData->textLength + lineData->singleSapcesBetweenWordsLength + SINGLE_SPACE + words[i].length() == maxWidth) {\\n                lineData->textLength += words[i].length();\\n                ++lineData->singleSapcesBetweenWordsLength;\\n                ++lineData->endIndexWords;\\n\\n                createLine(fullyJustifiedText, words, false);\\n                lineData = make_unique<LineData>(++i, words);\\n                continue;\\n            }\\n            createLine(fullyJustifiedText, words, false);\\n            lineData = make_unique<LineData>(i, words);\\n        }\\n\\n        if (lineData->textLength > 0) {\\n            createLine(fullyJustifiedText, words, true);\\n        }\\n        return fullyJustifiedText;\\n    }\\n\\nprivate:\\n    void createLine(vector<string>& fullyJustifiedText, const vector<string>& words, bool isLastLine) const {\\n\\n        int totalSpaceInLine = maxWidth - lineData->textLength;\\n        int spaceBetweenWordsWithoutRemainder = 0;\\n        int totalSpaceRemainder = 0;\\n        int spaceAfterLastWordInLastLine = 0;\\n        int numberOfWords = lineData->endIndexWords - lineData->startIndexWords + 1;\\n\\n        if (!isLastLine) {\\n            spaceBetweenWordsWithoutRemainder = (numberOfWords > 1) ? totalSpaceInLine / (numberOfWords - 1) : totalSpaceInLine;\\n            totalSpaceRemainder = (numberOfWords > 1) ? totalSpaceInLine % (numberOfWords - 1) : 0;\\n        } else {\\n            spaceBetweenWordsWithoutRemainder = 1;\\n            spaceAfterLastWordInLastLine = totalSpaceInLine - (numberOfWords - 1);\\n        }\\n\\n        string line;\\n\\n        if (numberOfWords == 1 && !isLastLine) {\\n            line.append(words[lineData->startIndexWords]);\\n            appendSpaceToLine(spaceBetweenWordsWithoutRemainder, line);\\n            fullyJustifiedText.push_back(line);\\n            return;\\n        }\\n\\n        while (lineData->startIndexWords < lineData->endIndexWords) {\\n            line.append(words[lineData->startIndexWords]);\\n            int spaceBetweenWords = (totalSpaceRemainder-- > 0) ? 1 + spaceBetweenWordsWithoutRemainder : spaceBetweenWordsWithoutRemainder;\\n            appendSpaceToLine(spaceBetweenWords, line);\\n            ++lineData->startIndexWords;\\n        }\\n        line.append(words[lineData->endIndexWords]);\\n        appendSpaceToLine(spaceAfterLastWordInLastLine, line);\\n        fullyJustifiedText.push_back(line);\\n    }\\n\\n    void appendSpaceToLine(int spacesToAppend, string& line) const {\\n        while (spacesToAppend-- > 0) {\\n            line.append(\" \");\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2526012,
                "title": "c-fast-and-brief-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        for (int i = 0, j;i < words.size();) {\\n            int len = -1; // remove the first space\\n            for (j = i;j < words.size() && len + words[j].length() + 1 <= maxWidth;j++) {\\n                len += (words[j].length() + 1); // add the space and the word\\n            }\\n            string line = words[i++]; // get the first word\\n            int num_words = j - i; // number of words\\n            int num_space = maxWidth - len; // number of spaces (exclude the single space above)\\n            int extra = (num_words > 0) ? num_space%num_words : 0; // extra spaces\\n            for (;i < j;i++) {\\n                int space = (j == words.size()) ? 0 : // if last line, no space needed\\n                    (num_space/num_words + (extra-- > 0)); // else append average, then the extra\\n                line += string(space+1, \\' \\') + words[i];\\n            }\\n            line += string(maxWidth - line.length(), \\' \\'); // add the remaining\\n            output.push_back(line);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> output;\\n        for (int i = 0, j;i < words.size();) {\\n            int len = -1; // remove the first space\\n            for (j = i;j < words.size() && len + words[j].length() + 1 <= maxWidth;j++) {\\n                len += (words[j].length() + 1); // add the space and the word\\n            }\\n            string line = words[i++]; // get the first word\\n            int num_words = j - i; // number of words\\n            int num_space = maxWidth - len; // number of spaces (exclude the single space above)\\n            int extra = (num_words > 0) ? num_space%num_words : 0; // extra spaces\\n            for (;i < j;i++) {\\n                int space = (j == words.size()) ? 0 : // if last line, no space needed\\n                    (num_space/num_words + (extra-- > 0)); // else append average, then the extra\\n                line += string(space+1, \\' \\') + words[i];\\n            }\\n            line += string(maxWidth - line.length(), \\' \\'); // add the remaining\\n            output.push_back(line);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468109,
                "title": "easy-to-understand-python-solution-by-intution",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Initilize three varaibles as we form line-by-line\\n        current_line_length = 0\\n        current_line_words = []\\n        ans = []\\n        for word in words: #-----> O(n)\\n            word_length = len(word)\\n            \"\"\"For each word, we consider the space after that word also\\n                We check if current line length exceeds the maxiWidth if this word is added or not\"\"\"\\n            if current_line_length+word_length+1 <= maxWidth or (current_line_length+word_length == maxWidth):\\n                \"\"\"\\n                Append the word to current line words\\n                \"\"\"\\n                current_line_words.append(word)\\n                current_line_length += word_length+1\\n            else:\\n                if len(current_line_words) == 1:\\n                    \"\"\"\\n                    If there is only word for this line, that word should be left-justified\\n                    \"\"\"\\n                    characters = len(current_line_words[0])\\n                    spaces = maxWidth-characters\\n                    ans.append(\"\".join(current_line_words+([\\' \\']*spaces)))\\n                else:\\n                    \"\"\"\\n                    If there are multiple words for this line\\n                    \"\"\"\\n                    characters = current_line_length-len(current_line_words)\\n                    spaces = maxWidth-characters\\n                    distribution_spaces = spaces//(len(current_line_words)-1)\\n                    if not spaces%(len(current_line_words)-1):\\n                        \"\"\"\\n                        If the spaces divide evenly between words\\n                        \"\"\"\\n                        spaces = \"\".join([\\' \\']*distribution_spaces)\\n                        ans.append(spaces.join(current_line_words))\\n                    else:\\n                        \"\"\"\\n                        If spaces does not divide evenly with words\\n                        \"\"\"\\n                        extras = spaces%(len(current_line_words)-1)\\n                        temp = \"\"\\n                        for i in range(len(current_line_words)-1):\\n                            temp += current_line_words[i]\\n                            if extras:\\n                                temp += \"\".join(([\\' \\']*distribution_spaces)+[\\' \\'])\\n                                extras -= 1\\n                            else:\\n                                temp += \"\".join(([\\' \\'] * distribution_spaces))\\n                        temp += current_line_words[-1]\\n                        ans.append(temp)\\n                \"\"\"\\n                This is the last line and should be justified evenly\\n                \"\"\"\\n                current_line_length = len(word)+1\\n                current_line_words.clear()\\n                current_line_words.append(word)\\n        temp = \" \".join(current_line_words)\\n        temp += \"\".join([\\' \\']*(maxWidth-len(temp)))\\n        ans.append(temp)\\n        return ans\\n```\\n\\nPlease vote this solution if you feel its helpful",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # Initilize three varaibles as we form line-by-line\\n        current_line_length = 0\\n        current_line_words = []\\n        ans = []\\n        for word in words: #-----> O(n)\\n            word_length = len(word)\\n            \"\"\"For each word, we consider the space after that word also\\n                We check if current line length exceeds the maxiWidth if this word is added or not\"\"\"\\n            if current_line_length+word_length+1 <= maxWidth or (current_line_length+word_length == maxWidth):\\n                \"\"\"\\n                Append the word to current line words\\n                \"\"\"\\n                current_line_words.append(word)\\n                current_line_length += word_length+1\\n            else:\\n                if len(current_line_words) == 1:\\n                    \"\"\"\\n                    If there is only word for this line, that word should be left-justified\\n                    \"\"\"\\n                    characters = len(current_line_words[0])\\n                    spaces = maxWidth-characters\\n                    ans.append(\"\".join(current_line_words+([\\' \\']*spaces)))\\n                else:\\n                    \"\"\"\\n                    If there are multiple words for this line\\n                    \"\"\"\\n                    characters = current_line_length-len(current_line_words)\\n                    spaces = maxWidth-characters\\n                    distribution_spaces = spaces//(len(current_line_words)-1)\\n                    if not spaces%(len(current_line_words)-1):\\n                        \"\"\"\\n                        If the spaces divide evenly between words\\n                        \"\"\"\\n                        spaces = \"\".join([\\' \\']*distribution_spaces)\\n                        ans.append(spaces.join(current_line_words))\\n                    else:\\n                        \"\"\"\\n                        If spaces does not divide evenly with words\\n                        \"\"\"\\n                        extras = spaces%(len(current_line_words)-1)\\n                        temp = \"\"\\n                        for i in range(len(current_line_words)-1):\\n                            temp += current_line_words[i]\\n                            if extras:\\n                                temp += \"\".join(([\\' \\']*distribution_spaces)+[\\' \\'])\\n                                extras -= 1\\n                            else:\\n                                temp += \"\".join(([\\' \\'] * distribution_spaces))\\n                        temp += current_line_words[-1]\\n                        ans.append(temp)\\n                \"\"\"\\n                This is the last line and should be justified evenly\\n                \"\"\"\\n                current_line_length = len(word)+1\\n                current_line_words.clear()\\n                current_line_words.append(word)\\n        temp = \" \".join(current_line_words)\\n        temp += \"\".join([\\' \\']*(maxWidth-len(temp)))\\n        ans.append(temp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392508,
                "title": "easy-understanding-java-solution",
                "content": "to further understand, please check the below link\\nhttps://www.youtube.com/watch?v=GqXlEbFVTXY\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int i=0, n=words.length;\\n        while(i<n) {\\n            int j=i+1;\\n            int lineLength=words[i].length();\\n            while(j<n && (lineLength+words[j].length()+(j-i-1)<maxWidth)) {\\n                lineLength+=words[j].length();\\n                j++;\\n            }\\n            int diff=maxWidth-lineLength;\\n            int noOfWords=j-i;\\n            if(noOfWords==1 || j>=n)\\n                result.add(leftJustify(words,diff,i,j));\\n            else\\n                result.add(middleJustify(words,diff,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++) {\\n            sb.append(\" \"+words[k]);\\n        }\\n        sb.append(\" \".repeat(spacesOnRight));\\n        return sb.toString();\\n    }\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesNeeded=j-i-1;\\n        int spaces=diff/spacesNeeded;\\n        int extraSpaces=diff%spacesNeeded;\\n        for(int k=i+1;k<j;k++) {\\n            int spacesToApply=spaces+(extraSpaces-->0?1:0);\\n            sb.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> result=new ArrayList<>();\\n        int i=0, n=words.length;\\n        while(i<n) {\\n            int j=i+1;\\n            int lineLength=words[i].length();\\n            while(j<n && (lineLength+words[j].length()+(j-i-1)<maxWidth)) {\\n                lineLength+=words[j].length();\\n                j++;\\n            }\\n            int diff=maxWidth-lineLength;\\n            int noOfWords=j-i;\\n            if(noOfWords==1 || j>=n)\\n                result.add(leftJustify(words,diff,i,j));\\n            else\\n                result.add(middleJustify(words,diff,i,j));\\n            i=j;\\n        }\\n        return result;\\n    }\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesOnRight=diff-(j-i-1);\\n        for(int k=i+1;k<j;k++) {\\n            sb.append(\" \"+words[k]);\\n        }\\n        sb.append(\" \".repeat(spacesOnRight));\\n        return sb.toString();\\n    }\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        StringBuilder sb=new StringBuilder(words[i]);\\n        int spacesNeeded=j-i-1;\\n        int spaces=diff/spacesNeeded;\\n        int extraSpaces=diff%spacesNeeded;\\n        for(int k=i+1;k<j;k++) {\\n            int spacesToApply=spaces+(extraSpaces-->0?1:0);\\n            sb.append(\" \".repeat(spacesToApply)+words[k]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376795,
                "title": "simple-js-solution-w-comments",
                "content": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N)\\n */\\n// Runtime: 89 ms, faster than 45.91% of JavaScript online submissions for Text Justification.\\n// Memory Usage: 42 MB, less than 58.01% of JavaScript online submissions for Text Justification.\\nconst fullJustify = (words, maxWidth) => {\\n\\tconst justifyLine = (line, width) => {\\n\\t\\t// if single word, it\\'s left justified, add spaces to the end\\n\\t\\tif (line.length === 1) {\\n\\t\\t\\tlet word = line[0];\\n\\n\\t\\t\\tword += \\' \\'.repeat(width);\\n\\t\\t\\treturn word;\\n\\n\\t\\t}\\n\\n\\t\\tconst end = line.length - 1; // all words except the last word should have spaced added to their string\\n\\t\\tlet i = 0;\\n\\n\\t\\t// distribute spaces evenly among the words\\n\\t\\twhile (width-- > 0) {\\n\\t\\t\\tline[i++] += \\' \\';\\n\\t\\t\\ti = i % end; // loop back to start to avoid adding space to the final word\\n\\t\\t}\\n\\n\\t\\treturn line.join(\\'\\');\\n\\t};\\n\\n\\tconst output = [];\\n\\tlet line = [];\\n\\tlet width = maxWidth; // spaces left\\n\\n\\t// greedily add words to each line\\n\\t// when current word cannot be added\\n\\t// justify and add current line and start a new line\\n\\tfor (const word of words) {\\n\\t\\t// if word fits: add word and update spaces left\\n\\t\\tif (word.length <= width - line.length) {\\n\\t\\t\\tline.push(word); // word fits: add word to current line\\n\\t\\t\\twidth -= word.length; // subtract length of current word and update spaces left\\n\\t\\t} else {\\n\\t\\t\\t// not enough spaces, word does not fit: justify current line and add to output\\n\\t\\t\\tconst justified = justifyLine(line, width);\\n\\n\\t\\t\\toutput.push(justified); // add justified line to output\\n\\t\\t\\tline = [word]; // start a new line with current word\\n\\t\\t\\twidth = maxWidth - word.length; // reset current line width\\n\\t\\t}\\n\\t}\\n\\n\\t// handle last line: justify words to the left and add spaces to the right\\n\\tif (line.length) {\\n\\t\\tlet lastLine = line.join(\\' \\'); // convert last line into string\\n\\t\\tconst spacesLeft = maxWidth - lastLine.length; // spaces left for last line\\n\\n\\t\\tlastLine += \\' \\'.repeat(spacesLeft);\\n\\t\\toutput.push(lastLine);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * *Time: O(N^2)\\n * *Space: O(N)\\n */\\n// Runtime: 89 ms, faster than 45.91% of JavaScript online submissions for Text Justification.\\n// Memory Usage: 42 MB, less than 58.01% of JavaScript online submissions for Text Justification.\\nconst fullJustify = (words, maxWidth) => {\\n\\tconst justifyLine = (line, width) => {\\n\\t\\t// if single word, it\\'s left justified, add spaces to the end\\n\\t\\tif (line.length === 1) {\\n\\t\\t\\tlet word = line[0];\\n\\n\\t\\t\\tword += \\' \\'.repeat(width);\\n\\t\\t\\treturn word;\\n\\n\\t\\t}\\n\\n\\t\\tconst end = line.length - 1; // all words except the last word should have spaced added to their string\\n\\t\\tlet i = 0;\\n\\n\\t\\t// distribute spaces evenly among the words\\n\\t\\twhile (width-- > 0) {\\n\\t\\t\\tline[i++] += \\' \\';\\n\\t\\t\\ti = i % end; // loop back to start to avoid adding space to the final word\\n\\t\\t}\\n\\n\\t\\treturn line.join(\\'\\');\\n\\t};\\n\\n\\tconst output = [];\\n\\tlet line = [];\\n\\tlet width = maxWidth; // spaces left\\n\\n\\t// greedily add words to each line\\n\\t// when current word cannot be added\\n\\t// justify and add current line and start a new line\\n\\tfor (const word of words) {\\n\\t\\t// if word fits: add word and update spaces left\\n\\t\\tif (word.length <= width - line.length) {\\n\\t\\t\\tline.push(word); // word fits: add word to current line\\n\\t\\t\\twidth -= word.length; // subtract length of current word and update spaces left\\n\\t\\t} else {\\n\\t\\t\\t// not enough spaces, word does not fit: justify current line and add to output\\n\\t\\t\\tconst justified = justifyLine(line, width);\\n\\n\\t\\t\\toutput.push(justified); // add justified line to output\\n\\t\\t\\tline = [word]; // start a new line with current word\\n\\t\\t\\twidth = maxWidth - word.length; // reset current line width\\n\\t\\t}\\n\\t}\\n\\n\\t// handle last line: justify words to the left and add spaces to the right\\n\\tif (line.length) {\\n\\t\\tlet lastLine = line.join(\\' \\'); // convert last line into string\\n\\t\\tconst spacesLeft = maxWidth - lastLine.length; // spaces left for last line\\n\\n\\t\\tlastLine += \\' \\'.repeat(spacesLeft);\\n\\t\\toutput.push(lastLine);\\n\\t}\\n\\n\\treturn output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2252192,
                "title": "simple-java-solution-0ms",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {        \\n        List<String> result = new ArrayList<>();\\n        int nextWordIndex = 0;\\n        while(nextWordIndex < words.length){\\n            int endIndex = wordsAllowed(words, nextWordIndex, maxWidth);\\n            result.add(createLine(words, nextWordIndex, endIndex, maxWidth));\\n            nextWordIndex = endIndex + 1;\\n        }\\n        return result;        \\n    }\\n        \\n    \\n    private int wordsAllowed(String[] words, int startIndex, int maxWidth){\\n        int spaceLeft = maxWidth;\\n        int endIndex = startIndex;\\n        spaceLeft -= words[endIndex].length();\\n        \\n        while(endIndex+1 < words.length && spaceLeft >= 1 + words[endIndex+1].length() ) {\\n            spaceLeft -= 1 + words[endIndex+1].length();\\n            endIndex++;\\n        }\\n        return endIndex;        \\n    }\\n    \\n    \\n    private String createLine(String[] words, int startIndex, int endIndex, int maxWidth){\\n        StringBuilder sb = new StringBuilder(maxWidth);        \\n        \\n        // Last Line or a single word line\\n        if (endIndex == words.length-1 || endIndex == startIndex) {\\n            for(int i = startIndex; i < endIndex ; i++){\\n                sb.append(words[i]);\\n                sb.append(\\' \\');\\n            }\\n            sb.append(words[endIndex]);\\n            for(int i = sb.length() + 1; i <= maxWidth; i++) sb.append(\\' \\');\\n        }\\n                \\n        else{\\n            int spaceSlots = endIndex - startIndex;\\n            int totalSpacesRequired = maxWidth;\\n            \\n            for(int i =startIndex; i<= endIndex; i++){\\n                totalSpacesRequired -= words[i].length();\\n            }\\n           \\n            String commonSpace = \" \".repeat(totalSpacesRequired / spaceSlots);\\n            int remainder = totalSpacesRequired % spaceSlots;\\n            \\n            int nextSpaceSlot = 1;\\n            for(int i = startIndex; i< endIndex; i++){\\n                sb.append(words[i]);\\n                sb.append(commonSpace);\\n                if (nextSpaceSlot++<= remainder) sb.append(\\' \\');               \\n            }   \\n            sb.append(words[endIndex]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {        \\n        List<String> result = new ArrayList<>();\\n        int nextWordIndex = 0;\\n        while(nextWordIndex < words.length){\\n            int endIndex = wordsAllowed(words, nextWordIndex, maxWidth);\\n            result.add(createLine(words, nextWordIndex, endIndex, maxWidth));\\n            nextWordIndex = endIndex + 1;\\n        }\\n        return result;        \\n    }\\n        \\n    \\n    private int wordsAllowed(String[] words, int startIndex, int maxWidth){\\n        int spaceLeft = maxWidth;\\n        int endIndex = startIndex;\\n        spaceLeft -= words[endIndex].length();\\n        \\n        while(endIndex+1 < words.length && spaceLeft >= 1 + words[endIndex+1].length() ) {\\n            spaceLeft -= 1 + words[endIndex+1].length();\\n            endIndex++;\\n        }\\n        return endIndex;        \\n    }\\n    \\n    \\n    private String createLine(String[] words, int startIndex, int endIndex, int maxWidth){\\n        StringBuilder sb = new StringBuilder(maxWidth);        \\n        \\n        // Last Line or a single word line\\n        if (endIndex == words.length-1 || endIndex == startIndex) {\\n            for(int i = startIndex; i < endIndex ; i++){\\n                sb.append(words[i]);\\n                sb.append(\\' \\');\\n            }\\n            sb.append(words[endIndex]);\\n            for(int i = sb.length() + 1; i <= maxWidth; i++) sb.append(\\' \\');\\n        }\\n                \\n        else{\\n            int spaceSlots = endIndex - startIndex;\\n            int totalSpacesRequired = maxWidth;\\n            \\n            for(int i =startIndex; i<= endIndex; i++){\\n                totalSpacesRequired -= words[i].length();\\n            }\\n           \\n            String commonSpace = \" \".repeat(totalSpacesRequired / spaceSlots);\\n            int remainder = totalSpacesRequired % spaceSlots;\\n            \\n            int nextSpaceSlot = 1;\\n            for(int i = startIndex; i< endIndex; i++){\\n                sb.append(words[i]);\\n                sb.append(commonSpace);\\n                if (nextSpaceSlot++<= remainder) sb.append(\\' \\');               \\n            }   \\n            sb.append(words[endIndex]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249331,
                "title": "0ms-with-detailed-comments",
                "content": "```\\nclass Solution {\\n  \\n  public List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;       // index of word in words array\\n        int wordsLen = 0;    // sum of all words that can be put in same line\\n        int spaces = 0;      // spaces that need to be filled\\n        \\n        while (index < words.length) { // check if the index is less than the length ...\\n            if ((tempLen + words[index].length()) <= maxLen) { // making sure that the current temp len is less than \\n                // max length ... so keep adding words as long as the length is less than max length ...\\n                // and this is the greedy algorithm ...\\n                tempLen += words[index].length() + 1; // increase the temp length by adding the current word ...\\n                tempList.add(words[index++]); // increase the index post addition to the temp list ...\\n            } else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size(); // temp length has the additional +1\\'s ... line 15 ...\\n                spaces = maxLen - wordsLen; // so this is the total number of spaces ... i.e., maxlen <minus> word len ...\\n                if(tempList.size() == 1) { // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0)); // add the first and only word ...\\n                    for(int i = 0; i < spaces; i++) { // fill the rest with spaces ...\\n                        sb.append(\" \"); // append with spaces ...\\n                    }\\n                    ans.add(sb.toString()); // add this string to the final answer\\n                } else if (tempList.size() > 1) { // there\\'s many words in cur line, do the evenly spaceing\\n                    \\n                    // you see tempList - 1 because ... lets say, you have 3 words\\n                    // w1 space1 w2 space2 w3\\n                    // as you can see ... spaces will be 1 less than the words ...\\n                    // \\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) { // if 3 words ...\\n                        // you are only going up to 2 ... and adding the last in line 48 ...\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){ // here we are adding the extra spaces\\n                            // because the question says \\n                            // If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \"); // and here we are adding the spaces ...\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1)); // line 48, adding the last word ...\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear(); // clear the temp list ...\\n                tempLen = 0; // set the temp length back to 0 ...\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) { // the -1 is because ... we want to keep that last space ...\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++) {\\n          sb.append(\" \");          \\n        }\\n\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\n  public List<String> fullJustify(String[] words, int maxLen) {\\n        List<String> ans = new ArrayList<>();\\n        List<String> tempList = new ArrayList<>();  //to store the words that can be put in one same line\\n        int tempLen = 0;     // track the length of current line: wordsLen + spaces between words\\n        int index = 0;       // index of word in words array\\n        int wordsLen = 0;    // sum of all words that can be put in same line\\n        int spaces = 0;      // spaces that need to be filled\\n        \\n        while (index < words.length) { // check if the index is less than the length ...\\n            if ((tempLen + words[index].length()) <= maxLen) { // making sure that the current temp len is less than \\n                // max length ... so keep adding words as long as the length is less than max length ...\\n                // and this is the greedy algorithm ...\\n                tempLen += words[index].length() + 1; // increase the temp length by adding the current word ...\\n                tempList.add(words[index++]); // increase the index post addition to the temp list ...\\n            } else {\\n                StringBuilder sb = new StringBuilder();\\n                wordsLen = tempLen - tempList.size(); // temp length has the additional +1\\'s ... line 15 ...\\n                spaces = maxLen - wordsLen; // so this is the total number of spaces ... i.e., maxlen <minus> word len ...\\n                if(tempList.size() == 1) { // there\\'s only one word at cur line, then just fill the spaces\\n                    sb.append(tempList.get(0)); // add the first and only word ...\\n                    for(int i = 0; i < spaces; i++) { // fill the rest with spaces ...\\n                        sb.append(\" \"); // append with spaces ...\\n                    }\\n                    ans.add(sb.toString()); // add this string to the final answer\\n                } else if (tempList.size() > 1) { // there\\'s many words in cur line, do the evenly spaceing\\n                    \\n                    // you see tempList - 1 because ... lets say, you have 3 words\\n                    // w1 space1 w2 space2 w3\\n                    // as you can see ... spaces will be 1 less than the words ...\\n                    // \\n                    int distance = spaces / (tempList.size() - 1);\\n                    int reminder = spaces % (tempList.size() - 1);\\n                    \\n                    for(int i = 0; i < tempList.size() - 1; i++) { // if 3 words ...\\n                        // you are only going up to 2 ... and adding the last in line 48 ...\\n                        sb.append(tempList.get(i));\\n                        if(reminder > 0){ // here we are adding the extra spaces\\n                            // because the question says \\n                            // If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\\n                            sb.append(\" \");\\n                            reminder--;\\n                        }\\n                        for(int j = 0; j < distance; j++)\\n                            sb.append(\" \"); // and here we are adding the spaces ...\\n                    }\\n                    sb.append(tempList.get(tempList.size() - 1)); // line 48, adding the last word ...\\n                    ans.add(sb.toString());   \\n                }\\n                tempList.clear(); // clear the temp list ...\\n                tempLen = 0; // set the temp length back to 0 ...\\n            }\\n        }\\n        \\n        // dealing with last line\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < tempList.size() - 1; i++) { // the -1 is because ... we want to keep that last space ...\\n            sb.append(tempList.get(i));\\n            sb.append(\" \");\\n        }\\n        sb.append(tempList.get(tempList.size() - 1));\\n        for(int i = 0; i < maxLen - (tempLen - 1); i++) {\\n          sb.append(\" \");          \\n        }\\n\\n        ans.add(sb.toString());\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125624,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    //\\u5F88\\u6076\\u5FC3\\u7684\\u4E00\\u9053\\u9898\\u76EE\\uFF0C\\u5B9E\\u73B0\\u633A\\u96BE\\n    //\\u4E3B\\u8981\\u662F3\\u70B9\\n    //1. \\u9700\\u8981\\u5BF9\\u6BCF\\u4E2A\\u5355\\u8BCD\\u4E2D\\u95F4\\u586B\\u4E0A\\u975E\\u5E38\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\uFF0C\\u8FD9\\u4E2A\\u7528line[i % (gaps)].Append(\" \");\\u6765\\u89E3\\u51B3\\uFF0C\\u8FD9\\u91CC\\u7528line.Count-1\\u6765\\u5F97\\u5230\\u5355\\u8BCD\\u4E4B\\u95F4\\u7684gaps\\u9700\\u8981\\u591A\\u5C11,\\u7136\\u540E\\u901A\\u8FC7\\u4F59\\u6570\\u6765\\u6765\\u56DE\\u7ED9\\u5355\\u8BCD\\u4E2D\\u95F4\\u52A0\\u4E0A\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\n    //Ex This_is_an_ _ _\\n    //   \\u4E0A\\u9762\\u8FD9\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u53EF\\u4EE5\\u770B\\u5230\\u4E00\\u4E2Aline\\u4E0A\\u603B\\u5171\\u67093\\u4E2A\\u5355\\u8BCD\\u7136\\u540E\\u9700\\u89812\\u4E2Agaps,\\u5982\\u4F55\\u628A\\u8FD9\\u4E9Bgap\\u5747\\u5300\\u5206\\u914D\\u7A7A\\u683C\\u5462\\uFF0C\\u90A3\\u5C31\\u662Fline[i%gaps].Append(\" \")\\n    //2. \\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u65B0\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u5355\\u8BCD\\u4E4B\\u95F4\\u9700\\u8981\\u9884\\u7559\\u7684\\u7A7A\\u683C\\u5982\\u679C\\u5927\\u4E8EmaxWidth\\u90A3\\u5C31\\u9700\\u8981\\u5228\\u53BB\\u65B0\\u5355\\u8BCD\\u5BF9\\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u4E2Dgaps\\u505A\\u7A7A\\u683C\\u5747\\u8861\\n    //3. \\u6700\\u540E\\u4E00\\u884C\\u5904\\u7406\\u7684\\u65F6\\u5019\\u76F4\\u63A5\\u7528string.Join(\" \", line)\\u628A\\u5355\\u8BCD\\u9694\\u5F00\\uFF0C\\u7136\\u540E\\u7528string.PadRight(maxWidth)\\u628A\\u5355\\u8BCD\\u505A\\u5DE6\\u5BF9\\u9F50\\u4E5F\\u5C31\\u662F\\u5F80\\u53F3\\u586B\\u5145\\u8DB3\\u591F\\u7684\\u7A7A\\u683C\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> res = new List<string>();\\n        List<StringBuilder> wordsEachLine = new List<StringBuilder>();\\n        int totalCharsEachLine = 0;\\n        int wordIndex = 0;\\n        while(wordIndex < words.Length)\\n        {\\n            string word = words[wordIndex];\\n            wordsEachLine.Add(new StringBuilder(word));\\n            totalCharsEachLine+=word.Length;\\n            //\\u5148\\u8BA1\\u7B97\\u5F53\\u524Dsingle gap\\u9700\\u8981\\u591A\\u5C11\\u4E2A\\n            // Ex This_is_an  \\u8FD9\\u91CC\\u5C31\\u9700\\u89812\\u4E2A\\n            int gaps = wordsEachLine.Count - 1;\\n            \\n            //\\u5982\\u679C\\u73B0\\u5728line\\u4E0A\\u5F53\\u524D\\u6240\\u5B58\\u5728\\u7684word\\u52A0\\u4E0A\\u4E0B\\u4E00\\u4E2Aword\\u548C\\u9700\\u8981\\u7684singleGaps\\u6570\\u91CF\\u518D\\u52A0\\u4E0A\\u989D\\u5916\\u76841\\uFF08\\u8FD9\\u91CC\\u56E0\\u4E3A\\u591A\\u52A0\\u4E86\\u4E00\\u4E2Aword\\uFF09\\u957F\\u5EA6\\u5927\\u4E8EmaxWidth\\uFF0C\\n            //\\u6211\\u4EEC\\u5C31\\u9700\\u8981\\u5F80gaps\\u91CC\\u9762\\u6DFB\\u52A0\\u65B0\\u7684\\u7A7A\\u683C\\u6765\\u5747\\u8861gap\\u7684\\u7A7A\\u683C\\u6570\\u91CF\\n            if (wordIndex + 1 < words.Length && totalCharsEachLine + words[wordIndex+1].Length + gaps + 1 > maxWidth)\\n            {\\n                int restSpaces = maxWidth - totalCharsEachLine;\\n                for(int i = 0; i < restSpaces; i++)\\n                {\\n                    if (wordsEachLine.Count == 1)\\n                    {\\n                        wordsEachLine[0].Append(\" \");\\n                    }\\n                    else\\n                    {\\n                        wordsEachLine[i % gaps].Append(\" \");\\n                    }\\n                }\\n                \\n                res.Add(string.Join(\"\", wordsEachLine));\\n                wordsEachLine = new List<StringBuilder>();\\n                totalCharsEachLine = 0;\\n            }\\n            \\n            wordIndex++;\\n        }\\n        \\n        if (wordsEachLine.Count > 0)\\n        {\\n            string lastLine = string.Join(\" \", wordsEachLine);\\n            string lastLineRightpad = lastLine.PadRight(maxWidth);\\n            res.Add(lastLineRightpad);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    //\\u5F88\\u6076\\u5FC3\\u7684\\u4E00\\u9053\\u9898\\u76EE\\uFF0C\\u5B9E\\u73B0\\u633A\\u96BE\\n    //\\u4E3B\\u8981\\u662F3\\u70B9\\n    //1. \\u9700\\u8981\\u5BF9\\u6BCF\\u4E2A\\u5355\\u8BCD\\u4E2D\\u95F4\\u586B\\u4E0A\\u975E\\u5E38\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\uFF0C\\u8FD9\\u4E2A\\u7528line[i % (gaps)].Append(\" \");\\u6765\\u89E3\\u51B3\\uFF0C\\u8FD9\\u91CC\\u7528line.Count-1\\u6765\\u5F97\\u5230\\u5355\\u8BCD\\u4E4B\\u95F4\\u7684gaps\\u9700\\u8981\\u591A\\u5C11,\\u7136\\u540E\\u901A\\u8FC7\\u4F59\\u6570\\u6765\\u6765\\u56DE\\u7ED9\\u5355\\u8BCD\\u4E2D\\u95F4\\u52A0\\u4E0A\\u5E73\\u5747\\u7684\\u7A7A\\u683C\\n    //Ex This_is_an_ _ _\\n    //   \\u4E0A\\u9762\\u8FD9\\u4E2A\\u4F8B\\u5B50\\u6211\\u4EEC\\u53EF\\u4EE5\\u770B\\u5230\\u4E00\\u4E2Aline\\u4E0A\\u603B\\u5171\\u67093\\u4E2A\\u5355\\u8BCD\\u7136\\u540E\\u9700\\u89812\\u4E2Agaps,\\u5982\\u4F55\\u628A\\u8FD9\\u4E9Bgap\\u5747\\u5300\\u5206\\u914D\\u7A7A\\u683C\\u5462\\uFF0C\\u90A3\\u5C31\\u662Fline[i%gaps].Append(\" \")\\n    //2. \\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u65B0\\u5355\\u8BCD\\u7684\\u957F\\u5EA6\\u52A0\\u4E0A\\u5355\\u8BCD\\u4E4B\\u95F4\\u9700\\u8981\\u9884\\u7559\\u7684\\u7A7A\\u683C\\u5982\\u679C\\u5927\\u4E8EmaxWidth\\u90A3\\u5C31\\u9700\\u8981\\u5228\\u53BB\\u65B0\\u5355\\u8BCD\\u5BF9\\u5F53\\u524D\\u6240\\u6709\\u5355\\u8BCD\\u4E2Dgaps\\u505A\\u7A7A\\u683C\\u5747\\u8861\\n    //3. \\u6700\\u540E\\u4E00\\u884C\\u5904\\u7406\\u7684\\u65F6\\u5019\\u76F4\\u63A5\\u7528string.Join(\" \", line)\\u628A\\u5355\\u8BCD\\u9694\\u5F00\\uFF0C\\u7136\\u540E\\u7528string.PadRight(maxWidth)\\u628A\\u5355\\u8BCD\\u505A\\u5DE6\\u5BF9\\u9F50\\u4E5F\\u5C31\\u662F\\u5F80\\u53F3\\u586B\\u5145\\u8DB3\\u591F\\u7684\\u7A7A\\u683C\\n    public IList<string> FullJustify(string[] words, int maxWidth) {\\n        IList<string> res = new List<string>();\\n        List<StringBuilder> wordsEachLine = new List<StringBuilder>();\\n        int totalCharsEachLine = 0;\\n        int wordIndex = 0;\\n        while(wordIndex < words.Length)\\n        {\\n            string word = words[wordIndex];\\n            wordsEachLine.Add(new StringBuilder(word));\\n            totalCharsEachLine+=word.Length;\\n            //\\u5148\\u8BA1\\u7B97\\u5F53\\u524Dsingle gap\\u9700\\u8981\\u591A\\u5C11\\u4E2A\\n            // Ex This_is_an  \\u8FD9\\u91CC\\u5C31\\u9700\\u89812\\u4E2A\\n            int gaps = wordsEachLine.Count - 1;\\n            \\n            //\\u5982\\u679C\\u73B0\\u5728line\\u4E0A\\u5F53\\u524D\\u6240\\u5B58\\u5728\\u7684word\\u52A0\\u4E0A\\u4E0B\\u4E00\\u4E2Aword\\u548C\\u9700\\u8981\\u7684singleGaps\\u6570\\u91CF\\u518D\\u52A0\\u4E0A\\u989D\\u5916\\u76841\\uFF08\\u8FD9\\u91CC\\u56E0\\u4E3A\\u591A\\u52A0\\u4E86\\u4E00\\u4E2Aword\\uFF09\\u957F\\u5EA6\\u5927\\u4E8EmaxWidth\\uFF0C\\n            //\\u6211\\u4EEC\\u5C31\\u9700\\u8981\\u5F80gaps\\u91CC\\u9762\\u6DFB\\u52A0\\u65B0\\u7684\\u7A7A\\u683C\\u6765\\u5747\\u8861gap\\u7684\\u7A7A\\u683C\\u6570\\u91CF\\n            if (wordIndex + 1 < words.Length && totalCharsEachLine + words[wordIndex+1].Length + gaps + 1 > maxWidth)\\n            {\\n                int restSpaces = maxWidth - totalCharsEachLine;\\n                for(int i = 0; i < restSpaces; i++)\\n                {\\n                    if (wordsEachLine.Count == 1)\\n                    {\\n                        wordsEachLine[0].Append(\" \");\\n                    }\\n                    else\\n                    {\\n                        wordsEachLine[i % gaps].Append(\" \");\\n                    }\\n                }\\n                \\n                res.Add(string.Join(\"\", wordsEachLine));\\n                wordsEachLine = new List<StringBuilder>();\\n                totalCharsEachLine = 0;\\n            }\\n            \\n            wordIndex++;\\n        }\\n        \\n        if (wordsEachLine.Count > 0)\\n        {\\n            string lastLine = string.Join(\" \", wordsEachLine);\\n            string lastLineRightpad = lastLine.PadRight(maxWidth);\\n            res.Add(lastLineRightpad);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112533,
                "title": "cpp-with-proper-thinking-process-commented",
                "content": "First thing, text justification is very common in word processing tools like MSWord `(Ctrl + j)`.\\n\\n**We need to think on below points:**\\n\\n1. How do we know how many words would fit in each line?\\n2. Once we know the how many words would fit in current line, how do we divide the spaces? What if spaces are uneven? How do we handle such part?\\n3. How do we handle last line?\\n\\n**Lets think . . .** \\n\\nWe can add the length of the words as we go forward + we need to add 1 space at-least just after every word we encounter. We\\u2019ll stop as soon as we couldn\\u2019t fit any more word bounded by `maxWidth`.\\n\\n**We can use two pointers to do that. Previous pointer will mark the starting of the word and next pointer will mark the ending of the word for the current line. We also need a sum that keeps track of how many characters it has seen yet.**\\n\\nLet\\u2019s code the basic part\\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n}\\n```\\n\\nAbove logic is wrong, we also need to add \\u201Cspace\\u201D while checking `<= maxWidth`. \\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + 1 + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n}\\n```\\n\\nAbove logic is also wrong, we can\\u2019t add 1 for the first word of the current line. We need something that will make above code add 0 for the first time then 1 each time afterwards.\\n\\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nbool startWord = true; // true for first word for each new line**\\nwhile (endWordIndex < int(words.size())) {\\n    int tempCharCount = charsTillNow + int(words[endWordIndex].size());\\n    if (!startWord) tempCharCount++; // For space after if not the first word\\n    if (tempCharCount <= maxWidth) {\\n        charsTillNow += tempCharCount;\\n        endWordIndex++;\\n        startWord = false;\\n        continue;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n\\t\\t// means after this next time while loop will be executed that would be for new line\\n    startWord = true;\\n}\\n```\\n\\nNow, `charTillNow` will have all the valid chars count + 1 space b/w each word.\\n\\n**How many words?**  `wordCount = endWordIndex - startWordIndex`\\n\\n**How many spaces?** We must subtract the additional spaces we considered in `charsTillNow`. Those would be `wordCount-1`.\\n\\n`spaceCount = maxWidth - (charsTillNow - (wordCount-1))`\\n\\n**How much minimum space to allocate?**\\n\\n`minSpaceForEachWord = spaceCount / (wordCount-1)` \\u2014> Division by 0 is likely\\n\\n**What about any extra space left? Due to improper division of spaceCount and space locations**\\n\\n`extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord)`\\n\\nWe\\u2019ll add these additional space from left to right as we go forward with each word of the current line. Note that `extraSpace` will be less than `minSpaceForEachWord` as its the remainder. so if we add 1 by 1 if its more than 0, we\\u2019ll run out before the last word. [as per problem constraint]\\n\\n**Let\\u2019s add these words bounded by [startWordIndex : endWordIndex)**\\n\\n```cpp\\nstring currentLine;\\n\\nwhile(startWordIndex < endWordIndex) {\\n    currentLine.append(words[startWordIndex]);\\n    // Now add space but do not add space for last word\\n    if (startWordIndex != endWordIndex - 1)\\n        currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n    startWordIndex++;\\n\\t\\textraSpace--; // even goes to negative, we really don\\'t care\\n}\\n```\\n\\nNote: if `extraSpace > 0` \\u2192 `int(extraspace>0)` will return 1 for `true`.\\n\\nFull code till now:\\n```\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int startWordIndex = 0;\\n        int endWordIndex = 0;\\n        int charsTillNow = 0;\\n        int wordCount, spaceLocations, spaceCount, minSpaceForEachWord, extraSpace;\\n        string currentLine;\\n\\n        bool startWord = true;\\n        while (endWordIndex < int(words.size())) {\\n            int tempCharCount = int(words[endWordIndex].size());\\n            if (!startWord) tempCharCount++; // For space\\n            if (tempCharCount + charsTillNow <= maxWidth) {\\n                charsTillNow += tempCharCount;\\n                endWordIndex++;\\n                startWord = false;\\n                continue;\\n            }\\n\\n            startWord = true;\\n            wordCount = endWordIndex - startWordIndex;\\n            spaceLocations = wordCount - 1; // we put space b/w each word so it will always be wordCount-1\\n            spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t// put the default value as full space count as we also need to handle if we found just one word\\n            // for one word, assign all spaceCount just after that word and there wouldn\\'t be any extraSpace thing if there is just one word\\n            minSpaceForEachWord = spaceCount;\\n            extraSpace = 0;\\n            if (wordCount > 1) { // if word is more than 1, then calculate properly\\n                minSpaceForEachWord = spaceCount / spaceLocations;\\n                extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord);\\n            }\\n\\n\\t\\t\\t// Create current Line\\n            while (startWordIndex < endWordIndex) {\\n                currentLine.append(words[startWordIndex]);\\n                // Now add space but do not add space for last word\\n                if (startWordIndex != endWordIndex - 1)\\n                    currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n                else if (wordCount == 1) // if word length is 1, above condition will fail always, so in that case put all the spaces behind\\n                    currentLine.append(string(spaceCount, \\' \\'));\\n                startWordIndex++;\\n                extraSpace--; // even go to negative, we really don\\'t care\\n            }\\n            ans.push_back(currentLine);\\n            currentLine.clear();\\n            charsTillNow = 0;\\n        }\\n\\t\\t\\n\\t\\t// Above while loop breaks leaving us handle the last line separately\\n        // we\\'ll come here for last line. It has different rule\\n        wordCount = endWordIndex - startWordIndex;\\n        spaceLocations = wordCount - 1;\\n        spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n        while (startWordIndex < endWordIndex) {\\n            currentLine.append(words[startWordIndex]);\\n            // For last line, just add one space\\n            if (startWordIndex != endWordIndex - 1)\\n                currentLine.append(\" \");\\n            startWordIndex++;\\n        }\\n\\t\\t// append the remaining spaces [totalspace - how much we already filled (spaceLocations)]\\n        currentLine.append(string(spaceCount-spaceLocations, \\' \\'));\\n        ans.push_back(currentLine);\\n        \\n        return ans;\\n\\n    }\\n```\\n\\n\\nPS: Above code can be modularized but I didn\\'t want to break the flow of going through the code.\\nI have also one solution that\\'s a little modularized that uses similar logic.\\n[https://leetcode.com/submissions/detail/714605666/]\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n}\\n```\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nwhile (endWordIndex < int(words.size())) {\\n    if (charsTillNow + 1 + int(words[endWordIndex].size()) <= maxWidth) {\\n        charsTillNow += int(words[endWordIndex].size());\\n        endWordIndex++;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n}\\n```\n```cpp\\nint startWordIndex = 0;\\nint endWordIndex = 0;\\nint charsTillNow = 0;\\n\\nbool startWord = true; // true for first word for each new line**\\nwhile (endWordIndex < int(words.size())) {\\n    int tempCharCount = charsTillNow + int(words[endWordIndex].size());\\n    if (!startWord) tempCharCount++; // For space after if not the first word\\n    if (tempCharCount <= maxWidth) {\\n        charsTillNow += tempCharCount;\\n        endWordIndex++;\\n        startWord = false;\\n        continue;\\n    }\\n    // we come here means we cannot accomodate any more word for current line\\n\\t\\t// means after this next time while loop will be executed that would be for new line\\n    startWord = true;\\n}\\n```\n```cpp\\nstring currentLine;\\n\\nwhile(startWordIndex < endWordIndex) {\\n    currentLine.append(words[startWordIndex]);\\n    // Now add space but do not add space for last word\\n    if (startWordIndex != endWordIndex - 1)\\n        currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n    startWordIndex++;\\n\\t\\textraSpace--; // even goes to negative, we really don\\'t care\\n}\\n```\n```\\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int startWordIndex = 0;\\n        int endWordIndex = 0;\\n        int charsTillNow = 0;\\n        int wordCount, spaceLocations, spaceCount, minSpaceForEachWord, extraSpace;\\n        string currentLine;\\n\\n        bool startWord = true;\\n        while (endWordIndex < int(words.size())) {\\n            int tempCharCount = int(words[endWordIndex].size());\\n            if (!startWord) tempCharCount++; // For space\\n            if (tempCharCount + charsTillNow <= maxWidth) {\\n                charsTillNow += tempCharCount;\\n                endWordIndex++;\\n                startWord = false;\\n                continue;\\n            }\\n\\n            startWord = true;\\n            wordCount = endWordIndex - startWordIndex;\\n            spaceLocations = wordCount - 1; // we put space b/w each word so it will always be wordCount-1\\n            spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t// put the default value as full space count as we also need to handle if we found just one word\\n            // for one word, assign all spaceCount just after that word and there wouldn\\'t be any extraSpace thing if there is just one word\\n            minSpaceForEachWord = spaceCount;\\n            extraSpace = 0;\\n            if (wordCount > 1) { // if word is more than 1, then calculate properly\\n                minSpaceForEachWord = spaceCount / spaceLocations;\\n                extraSpace = spaceCount - (spaceLocations * minSpaceForEachWord);\\n            }\\n\\n\\t\\t\\t// Create current Line\\n            while (startWordIndex < endWordIndex) {\\n                currentLine.append(words[startWordIndex]);\\n                // Now add space but do not add space for last word\\n                if (startWordIndex != endWordIndex - 1)\\n                    currentLine.append(string(minSpaceForEachWord + int(extraSpace > 0), \\' \\'));\\n                else if (wordCount == 1) // if word length is 1, above condition will fail always, so in that case put all the spaces behind\\n                    currentLine.append(string(spaceCount, \\' \\'));\\n                startWordIndex++;\\n                extraSpace--; // even go to negative, we really don\\'t care\\n            }\\n            ans.push_back(currentLine);\\n            currentLine.clear();\\n            charsTillNow = 0;\\n        }\\n\\t\\t\\n\\t\\t// Above while loop breaks leaving us handle the last line separately\\n        // we\\'ll come here for last line. It has different rule\\n        wordCount = endWordIndex - startWordIndex;\\n        spaceLocations = wordCount - 1;\\n        spaceCount = maxWidth - (charsTillNow - spaceLocations);\\n        while (startWordIndex < endWordIndex) {\\n            currentLine.append(words[startWordIndex]);\\n            // For last line, just add one space\\n            if (startWordIndex != endWordIndex - 1)\\n                currentLine.append(\" \");\\n            startWordIndex++;\\n        }\\n\\t\\t// append the remaining spaces [totalspace - how much we already filled (spaceLocations)]\\n        currentLine.append(string(spaceCount-spaceLocations, \\' \\'));\\n        ans.push_back(currentLine);\\n        \\n        return ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897672,
                "title": "simple-solution-in-java-100-faster",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<String> resText = new ArrayList<>();\\n        int i = 0;\\n        while(i < words.length){\\n            StringBuilder resStr = new StringBuilder(words[i]);\\n            \\n            int j = i + 1;\\n            int currWidth = words[i].length();\\n            while(j < words.length && currWidth + 1 + words[j].length() <= maxWidth){\\n                currWidth += 1 + words[j].length();\\n                j++;\\n            }\\n            \\n            // Number of words in the current line are: (excluding the first one)\\n            int numWords = j - i - 1;\\n            \\n            if(numWords == 0 || j == words.length){\\n                // Last Line\\n                for(int k=i+1; k<j; k++){\\n                    resStr.append(\" \");\\n                    resStr.append(words[k]);\\n                }\\n                \\n                // Do padding at the end \\n                int remLen = maxWidth - resStr.length();\\n                for(int space=0; space < remLen; space++){\\n                    resStr.append(\" \");\\n                }\\n                \\n            }else{\\n                int numSpace = (maxWidth - currWidth)/numWords;\\n                int extraSpace = (maxWidth - currWidth)%numWords;\\n                \\n                for(int k=i+1; k<j; k++){\\n                    for(int space=0; space < numSpace; space++){\\n                        resStr.append(\" \");\\n                    }\\n                    \\n                    if(extraSpace > 0){\\n                        resStr.append(\" \");\\n                        extraSpace--;\\n                    }\\n                    \\n                    resStr.append(\" \"); // One space was already included \\n                    resStr.append(words[k]);\\n                }\\n                \\n            }\\n            \\n            resText.add(resStr.toString());\\n            i = j;\\n        }\\n        \\n        return resText;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<String> resText = new ArrayList<>();\\n        int i = 0;\\n        while(i < words.length){\\n            StringBuilder resStr = new StringBuilder(words[i]);\\n            \\n            int j = i + 1;\\n            int currWidth = words[i].length();\\n            while(j < words.length && currWidth + 1 + words[j].length() <= maxWidth){\\n                currWidth += 1 + words[j].length();\\n                j++;\\n            }\\n            \\n            // Number of words in the current line are: (excluding the first one)\\n            int numWords = j - i - 1;\\n            \\n            if(numWords == 0 || j == words.length){\\n                // Last Line\\n                for(int k=i+1; k<j; k++){\\n                    resStr.append(\" \");\\n                    resStr.append(words[k]);\\n                }\\n                \\n                // Do padding at the end \\n                int remLen = maxWidth - resStr.length();\\n                for(int space=0; space < remLen; space++){\\n                    resStr.append(\" \");\\n                }\\n                \\n            }else{\\n                int numSpace = (maxWidth - currWidth)/numWords;\\n                int extraSpace = (maxWidth - currWidth)%numWords;\\n                \\n                for(int k=i+1; k<j; k++){\\n                    for(int space=0; space < numSpace; space++){\\n                        resStr.append(\" \");\\n                    }\\n                    \\n                    if(extraSpace > 0){\\n                        resStr.append(\" \");\\n                        extraSpace--;\\n                    }\\n                    \\n                    resStr.append(\" \"); // One space was already included \\n                    resStr.append(words[k]);\\n                }\\n                \\n            }\\n            \\n            resText.add(resStr.toString());\\n            i = j;\\n        }\\n        \\n        return resText;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804542,
                "title": "clean-easy-to-understand-python-o-n",
                "content": "```\\nclass Solution:\\n    def createSentence(self, line):\\n        sentence = \\'\\'\\n        for word, spaceCount in line:\\n            sentence+=word\\n            sentence+=\\' \\'*spaceCount\\n            \\n        return sentence\\n    \\n    def adjustSpaces(self, line, spaceLeft):\\n        lastSpaces = line[-1][1]\\n        line[-1][1] = 0\\n        spaceLeft +=lastSpaces\\n        totalWords = len(line)\\n        \\n        if totalWords == 1:\\n            line[0][1] = spaceLeft\\n            return self.createSentence(line)\\n        \\n        for i in range(totalWords-1, 0, -1):\\n            spaceAfterWord = spaceLeft//i\\n            spaceLeft-=spaceAfterWord\\n            \\n            line[i-1][1] += spaceAfterWord\\n            \\n        return self.createSentence(line)    \\n        \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        line = []\\n        cUsage = 0\\n        output = []\\n        for word in words:\\n            if cUsage + len(word) > maxWidth:\\n                output.append(self.adjustSpaces(line, maxWidth-cUsage))\\n                cUsage = len(word)+1\\n                line = [[word,1]]\\n                \\n            elif cUsage + len(word) == maxWidth:\\n                line.append([word,0])\\n                cUsage = maxWidth\\n                \\n            else:\\n                line.append([word,1])\\n                cUsage+=len(word)+1\\n                \\n        line[-1][1] += maxWidth - cUsage\\n        output.append(self.createSentence(line))\\n                \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def createSentence(self, line):\\n        sentence = \\'\\'\\n        for word, spaceCount in line:\\n            sentence+=word\\n            sentence+=\\' \\'*spaceCount\\n            \\n        return sentence\\n    \\n    def adjustSpaces(self, line, spaceLeft):\\n        lastSpaces = line[-1][1]\\n        line[-1][1] = 0\\n        spaceLeft +=lastSpaces\\n        totalWords = len(line)\\n        \\n        if totalWords == 1:\\n            line[0][1] = spaceLeft\\n            return self.createSentence(line)\\n        \\n        for i in range(totalWords-1, 0, -1):\\n            spaceAfterWord = spaceLeft//i\\n            spaceLeft-=spaceAfterWord\\n            \\n            line[i-1][1] += spaceAfterWord\\n            \\n        return self.createSentence(line)    \\n        \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        line = []\\n        cUsage = 0\\n        output = []\\n        for word in words:\\n            if cUsage + len(word) > maxWidth:\\n                output.append(self.adjustSpaces(line, maxWidth-cUsage))\\n                cUsage = len(word)+1\\n                line = [[word,1]]\\n                \\n            elif cUsage + len(word) == maxWidth:\\n                line.append([word,0])\\n                cUsage = maxWidth\\n                \\n            else:\\n                line.append([word,1])\\n                cUsage+=len(word)+1\\n                \\n        line[-1][1] += maxWidth - cUsage\\n        output.append(self.createSentence(line))\\n                \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740385,
                "title": "python-simple-faster-than-97-60",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        def balanceSpaces(string, isLast):\\n            spacesToAdd = maxWidth - len(string)\\n            stringAsList = string.split(\\' \\')\\n            \\n            if len(stringAsList) == 1 or isLast:\\n                return string + (\\' \\' * spacesToAdd)\\n            else:\\n                while spacesToAdd:\\n                    for i in range(len(stringAsList) - 1):\\n                        if spacesToAdd:\\n                            stringAsList[i] += \\' \\'\\n                            spacesToAdd -= 1\\n                        else:\\n                            break\\n            return \\' \\'.join(stringAsList)\\n        \\n        output = []\\n        \\n        currLayer = \"\"\\n        for each in words:\\n            if not currLayer:\\n                currLayer += each\\n            elif len(currLayer + \\' \\' + each) <= maxWidth:\\n                currLayer += \\' \\' + each\\n            else:\\n                output.append(balanceSpaces(currLayer, False))\\n                currLayer = each\\n        \\n        output.append(balanceSpaces(currLayer, True))\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        \\n        def balanceSpaces(string, isLast):\\n            spacesToAdd = maxWidth - len(string)\\n            stringAsList = string.split(\\' \\')\\n            \\n            if len(stringAsList) == 1 or isLast:\\n                return string + (\\' \\' * spacesToAdd)\\n            else:\\n                while spacesToAdd:\\n                    for i in range(len(stringAsList) - 1):\\n                        if spacesToAdd:\\n                            stringAsList[i] += \\' \\'\\n                            spacesToAdd -= 1\\n                        else:\\n                            break\\n            return \\' \\'.join(stringAsList)\\n        \\n        output = []\\n        \\n        currLayer = \"\"\\n        for each in words:\\n            if not currLayer:\\n                currLayer += each\\n            elif len(currLayer + \\' \\' + each) <= maxWidth:\\n                currLayer += \\' \\' + each\\n            else:\\n                output.append(balanceSpaces(currLayer, False))\\n                currLayer = each\\n        \\n        output.append(balanceSpaces(currLayer, True))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731481,
                "title": "greedy-python-solution",
                "content": "I split this up into three parts: First, partitioning the array into blocks to be justified, then justifying these blocks either left or right. Partitioning is easy, we just take as many words as we can, considering that we need at least one space after the first word. Justifying left is very easy as well.\\n\\nFully justifying is also not hard, the number of spaces you use is the integer division of the number of gaps and the difference between the width and the used space. We need the reminder of this division as well to distribute the excess space on the left.\\n\\n```python\\nclass Solution:\\n    def justifyFull(self, curLine: List[str], maxWidth: int) -> str:\\n        spacingNeeded: int = maxWidth - sum([len(word) for word in curLine])\\n        numGaps: int = max(1, len(curLine) - 1)\\n        numSpacesBase: int = spacingNeeded // numGaps\\n        numExtra: int = spacingNeeded % numGaps\\n        \\n        line: List[str] = []\\n        \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n            else:\\n                line.append(\" \" * numSpacesBase)\\n                if i <= numExtra:\\n                    line.append(\" \")\\n                line.append(word)\\n        return \"\".join(line)\\n    \\n    def justifyLeft(self, curLine: List[str], maxWidth: int) -> str:\\n        line: List[str] = []\\n        spaceUsed: int = 0\\n            \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n                spaceUsed += len(word)\\n            else:\\n                line.append(\" \")\\n                line.append(word)\\n                spaceUsed += len(word) + 1\\n        if spaceUsed < maxWidth:\\n            line.append(\" \" * (maxWidth - spaceUsed))\\n        return \"\".join(line)\\n\\n                \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        curWidth: int = 0\\n        curLine: List[str] = []\\n        justified: List[str] = []\\n        \\n        for i, word in enumerate(words):\\n            addedLength = 0\\n            if curWidth == 0:\\n                addedLength = len(word)\\n            else:\\n                addedLength = len(word) + 1\\n            \\n            if curWidth + addedLength > maxWidth:\\n                if len(curLine) > 1:\\n                    justified.append(self.justifyFull(curLine, maxWidth))\\n                else:\\n                    justified.append(self.justifyLeft(curLine, maxWidth))\\n                    \\n                curWidth = len(word)\\n                curLine = [word]\\n            else:\\n                curWidth += addedLength\\n                curLine.append(word)\\n                \\n        if curWidth > 0:\\n            justified.append(self.justifyLeft(curLine, maxWidth))\\n        \\n        return justified\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def justifyFull(self, curLine: List[str], maxWidth: int) -> str:\\n        spacingNeeded: int = maxWidth - sum([len(word) for word in curLine])\\n        numGaps: int = max(1, len(curLine) - 1)\\n        numSpacesBase: int = spacingNeeded // numGaps\\n        numExtra: int = spacingNeeded % numGaps\\n        \\n        line: List[str] = []\\n        \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n            else:\\n                line.append(\" \" * numSpacesBase)\\n                if i <= numExtra:\\n                    line.append(\" \")\\n                line.append(word)\\n        return \"\".join(line)\\n    \\n    def justifyLeft(self, curLine: List[str], maxWidth: int) -> str:\\n        line: List[str] = []\\n        spaceUsed: int = 0\\n            \\n        for i, word in enumerate(curLine):\\n            if i == 0:\\n                line.append(word)\\n                spaceUsed += len(word)\\n            else:\\n                line.append(\" \")\\n                line.append(word)\\n                spaceUsed += len(word) + 1\\n        if spaceUsed < maxWidth:\\n            line.append(\" \" * (maxWidth - spaceUsed))\\n        return \"\".join(line)\\n\\n                \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        curWidth: int = 0\\n        curLine: List[str] = []\\n        justified: List[str] = []\\n        \\n        for i, word in enumerate(words):\\n            addedLength = 0\\n            if curWidth == 0:\\n                addedLength = len(word)\\n            else:\\n                addedLength = len(word) + 1\\n            \\n            if curWidth + addedLength > maxWidth:\\n                if len(curLine) > 1:\\n                    justified.append(self.justifyFull(curLine, maxWidth))\\n                else:\\n                    justified.append(self.justifyLeft(curLine, maxWidth))\\n                    \\n                curWidth = len(word)\\n                curLine = [word]\\n            else:\\n                curWidth += addedLength\\n                curLine.append(word)\\n                \\n        if curWidth > 0:\\n            justified.append(self.justifyLeft(curLine, maxWidth))\\n        \\n        return justified\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643285,
                "title": "c-easy-to-understand-broken-into-several-methods",
                "content": "```\\npublic class Solution\\n{\\n    public IList<string> FullJustify(string[] words, int maxWidth)\\n    {\\n        var lines = new List<string>();\\n\\n        var left = 0;\\n        var lineLength = 0;\\n        var wordsLength = 0;\\n\\n        for (var i = 0; i < words.Length; i++)\\n        {\\n            var word = words[i];\\n            if (lineLength + word.Length > maxWidth)\\n            {\\n                lines.Add(JustifyLine(words, maxWidth, left, i - 1, wordsLength));\\n                \\n                // reset state\\n                lineLength = 0;\\n                wordsLength = 0;\\n                left = i;\\n            }\\n\\n            lineLength += word.Length + 1;\\n            wordsLength += word.Length;\\n        }\\n\\n        // yustify the last line\\n        if (left <= words.Length - 1)\\n        {\\n            var line = string.Join(\" \", words.Skip(left));\\n            lines.Add(line + new string(\\' \\', maxWidth - line.Length));\\n        }\\n\\n        return lines;\\n    }\\n\\n    private string JustifyLine(string[] words, int maxWidth, int start, int end, int wordsLength)\\n    {\\n        var builder = new StringBuilder();\\n        var spaces = maxWidth - wordsLength;\\n\\n        // justify one word\\n        if (start == end)\\n        {\\n            builder.Append(words[start]);\\n            builder.Append(\\' \\', spaces);\\n\\n            return builder.ToString();\\n        }\\n\\n        // justify multiple words\\n        var gaps = end - start;\\n\\n        for (var i = start; i <= end; i++)\\n        {\\n            builder.Append(words[i]);\\n\\n            // adding spaces if the word isn\\'t last\\n            if (i != end)\\n            {\\n                var count = spaces / gaps + (spaces % gaps == 0 ? 0 : 1);\\n                builder.Append(\\' \\', count);\\n\\n                spaces -= count;\\n                gaps--;\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> FullJustify(string[] words, int maxWidth)\\n    {\\n        var lines = new List<string>();\\n\\n        var left = 0;\\n        var lineLength = 0;\\n        var wordsLength = 0;\\n\\n        for (var i = 0; i < words.Length; i++)\\n        {\\n            var word = words[i];\\n            if (lineLength + word.Length > maxWidth)\\n            {\\n                lines.Add(JustifyLine(words, maxWidth, left, i - 1, wordsLength));\\n                \\n                // reset state\\n                lineLength = 0;\\n                wordsLength = 0;\\n                left = i;\\n            }\\n\\n            lineLength += word.Length + 1;\\n            wordsLength += word.Length;\\n        }\\n\\n        // yustify the last line\\n        if (left <= words.Length - 1)\\n        {\\n            var line = string.Join(\" \", words.Skip(left));\\n            lines.Add(line + new string(\\' \\', maxWidth - line.Length));\\n        }\\n\\n        return lines;\\n    }\\n\\n    private string JustifyLine(string[] words, int maxWidth, int start, int end, int wordsLength)\\n    {\\n        var builder = new StringBuilder();\\n        var spaces = maxWidth - wordsLength;\\n\\n        // justify one word\\n        if (start == end)\\n        {\\n            builder.Append(words[start]);\\n            builder.Append(\\' \\', spaces);\\n\\n            return builder.ToString();\\n        }\\n\\n        // justify multiple words\\n        var gaps = end - start;\\n\\n        for (var i = start; i <= end; i++)\\n        {\\n            builder.Append(words[i]);\\n\\n            // adding spaces if the word isn\\'t last\\n            if (i != end)\\n            {\\n                var count = spaces / gaps + (spaces % gaps == 0 ? 0 : 1);\\n                builder.Append(\\' \\', count);\\n\\n                spaces -= count;\\n                gaps--;\\n            }\\n        }\\n\\n        return builder.ToString();\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1620628,
                "title": "java-100-faster-with-explanation",
                "content": "Overall time: O(n)\\nspace: O(n)\\nPlease consider upvote if you like my solution. Thank you!\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\t\\t// list to be returned\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// store the combined word length in *section* list\\n        int length = 0;\\n\\t\\t// *section* list to store the words at current iteration\\n        List<String> section = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n\\t\\t\\t// if and only if the word that we are currently looking at exceeds the wordWidth limit\\n\\t\\t\\t// we start to build a solution at this level\\n            if (length + section.size() + words[i].length() > maxWidth) {\\n\\t\\t\\t\\t// number of spaces total\\n                int diff = maxWidth - length;\\n                StringBuilder sb = new StringBuilder();\\n                int spaceCount = section.size() > 1 ? diff / (section.size() - 1) : diff;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// extra spaces when we can\\'t evenly distribute them\\n                int extraCount = section.size() > 1 ? diff % (section.size() - 1) : 0;\\n                diff -= extraCount;\\n                for (int j = 0; j < section.size(); j++) {\\n                    sb.append(section.get(j));\\n                    if (extraCount > 0) {\\n                        addSpace(sb, 1);\\n                        extraCount -= 1;\\n                    }\\n                    if (diff > 0) {\\n                        addSpace(sb, spaceCount);\\n                        diff -= spaceCount;\\n                    }\\n                }\\n                \\n                list.add(sb.toString());\\n\\t\\t\\t\\t// clear section list for next iteration\\n                section.clear();\\n\\t\\t\\t\\t// clear length counter for next iteration\\n                length = 0;\\n            }\\n            section.add(words[i]);\\n            length += words[i].length();\\n        }\\n        // build the last line differently\\n        if (!section.isEmpty()) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 0;\\n            for (int j = 0; j < section.size(); j++) {\\n                sb.append(section.get(j));\\n                if (j != section.size() - 1) {\\n                    addSpace(sb, 1);\\n                    count += 1;\\n                }\\n            }\\n            int diff = maxWidth - length - count;\\n            addSpace(sb, diff);\\n            list.add(sb.toString());\\n        }\\n        \\n        return list;\\n    }\\n    // helper function to append spaces to string builder\\n    private void addSpace(StringBuilder sb, int count) {\\n        for (int i = 0; i < count; i++) {\\n            sb.append(\" \");\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n\\t\\t// list to be returned\\n        List<String> list = new ArrayList<>();\\n        \\n\\t\\t// store the combined word length in *section* list\\n        int length = 0;\\n\\t\\t// *section* list to store the words at current iteration\\n        List<String> section = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n\\t\\t\\t// if and only if the word that we are currently looking at exceeds the wordWidth limit\\n\\t\\t\\t// we start to build a solution at this level\\n            if (length + section.size() + words[i].length() > maxWidth) {\\n\\t\\t\\t\\t// number of spaces total\\n                int diff = maxWidth - length;\\n                StringBuilder sb = new StringBuilder();\\n                int spaceCount = section.size() > 1 ? diff / (section.size() - 1) : diff;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// extra spaces when we can\\'t evenly distribute them\\n                int extraCount = section.size() > 1 ? diff % (section.size() - 1) : 0;\\n                diff -= extraCount;\\n                for (int j = 0; j < section.size(); j++) {\\n                    sb.append(section.get(j));\\n                    if (extraCount > 0) {\\n                        addSpace(sb, 1);\\n                        extraCount -= 1;\\n                    }\\n                    if (diff > 0) {\\n                        addSpace(sb, spaceCount);\\n                        diff -= spaceCount;\\n                    }\\n                }\\n                \\n                list.add(sb.toString());\\n\\t\\t\\t\\t// clear section list for next iteration\\n                section.clear();\\n\\t\\t\\t\\t// clear length counter for next iteration\\n                length = 0;\\n            }\\n            section.add(words[i]);\\n            length += words[i].length();\\n        }\\n        // build the last line differently\\n        if (!section.isEmpty()) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 0;\\n            for (int j = 0; j < section.size(); j++) {\\n                sb.append(section.get(j));\\n                if (j != section.size() - 1) {\\n                    addSpace(sb, 1);\\n                    count += 1;\\n                }\\n            }\\n            int diff = maxWidth - length - count;\\n            addSpace(sb, diff);\\n            list.add(sb.toString());\\n        }\\n        \\n        return list;\\n    }\\n    // helper function to append spaces to string builder\\n    private void addSpace(StringBuilder sb, int count) {\\n        for (int i = 0; i < count; i++) {\\n            sb.append(\" \");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613771,
                "title": "0-ms-java-solution-faster-than-100-of-java-solutions",
                "content": "I really sacrificed readability/elegance for performance on this one. I use start and end pointers into the given array to avoid keeping a list of words. Use linked list to avoid cost of resizing array list (even though it is amortized constant, we never index into the list so a linked list works fine). Used loops rather than streams, also for speed. \\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Text Justification.\\nMemory Usage: 37.1 MB, less than 95.74% of Java online submissions for Text Justification.\\n\\n```\\nclass Solution {\\n    private int maxWidth;\\n    private String[] words;\\n    \\n    public List<String> fullJustify(String[] ws, int maxW) {        \\n        \\n        List<String> text = new LinkedList<>();        \\n        maxWidth = maxW;\\n        words = ws; \\n        // Use start/end indexes into words array to avoid making a list of words in current line (for efficiency).\\n        int start = 0; \\n        int end = 1;\\n        int lineLen = words[start].length();\\n        \\n        for (; end < words.length; end++) {\\n            String word = words[end];\\n            \\n            if (lineLen + word.length() + 1 <= maxWidth) { // Word fits in this line. Plus one is for a space.\\n                lineLen += word.length() + 1; \\n            } else { // Word does not fit in this line, space out current line and start a new one.\\n                text.add(constructLine(start, end, lineLen));\\n                start = end;\\n                lineLen = word.length();\\n            }   \\n        }\\n        \\n        if (end - start > 0) {\\n            text.add(lineWithoutInterWordPadding(start, end, lineLen));\\n        }\\n        \\n        return text;\\n    }\\n    \\n    private String lineWithoutInterWordPadding(int start, int end, int lineLength) {\\n        // Don\\'t use stream Collectors.joining(\" \") here, even though it is more readable. The below is faster.\\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \");\\n            line.append(words[i]);\\n        }\\n        return line.toString() + \" \".repeat(maxWidth - lineLength);\\n    }\\n    \\n    private String constructLine(int start, int end, int lineLength) {\\n        int numSpaces = end - (start + 1);\\n        \\n        if (numSpaces == 0) { // Only one word in the line.\\n            return lineWithoutInterWordPadding(start, end, lineLength);\\n        }\\n        \\n        int padding = maxWidth - lineLength;       // Extra padding needed.\\n        int spaceNeeded = padding / numSpaces + 1; // Padding between each word (extra + minimum one).\\n        int leftOverSpaces = padding % numSpaces;  // Extra spaces that don\\'t divide evenly between words.\\n        \\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        \\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \".repeat(spaceNeeded));\\n            if (leftOverSpaces-- > 0) {\\n                line.append(\\' \\');\\n            }\\n            line.append(words[i]);\\n        }\\n        \\n        return line.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int maxWidth;\\n    private String[] words;\\n    \\n    public List<String> fullJustify(String[] ws, int maxW) {        \\n        \\n        List<String> text = new LinkedList<>();        \\n        maxWidth = maxW;\\n        words = ws; \\n        // Use start/end indexes into words array to avoid making a list of words in current line (for efficiency).\\n        int start = 0; \\n        int end = 1;\\n        int lineLen = words[start].length();\\n        \\n        for (; end < words.length; end++) {\\n            String word = words[end];\\n            \\n            if (lineLen + word.length() + 1 <= maxWidth) { // Word fits in this line. Plus one is for a space.\\n                lineLen += word.length() + 1; \\n            } else { // Word does not fit in this line, space out current line and start a new one.\\n                text.add(constructLine(start, end, lineLen));\\n                start = end;\\n                lineLen = word.length();\\n            }   \\n        }\\n        \\n        if (end - start > 0) {\\n            text.add(lineWithoutInterWordPadding(start, end, lineLen));\\n        }\\n        \\n        return text;\\n    }\\n    \\n    private String lineWithoutInterWordPadding(int start, int end, int lineLength) {\\n        // Don\\'t use stream Collectors.joining(\" \") here, even though it is more readable. The below is faster.\\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \");\\n            line.append(words[i]);\\n        }\\n        return line.toString() + \" \".repeat(maxWidth - lineLength);\\n    }\\n    \\n    private String constructLine(int start, int end, int lineLength) {\\n        int numSpaces = end - (start + 1);\\n        \\n        if (numSpaces == 0) { // Only one word in the line.\\n            return lineWithoutInterWordPadding(start, end, lineLength);\\n        }\\n        \\n        int padding = maxWidth - lineLength;       // Extra padding needed.\\n        int spaceNeeded = padding / numSpaces + 1; // Padding between each word (extra + minimum one).\\n        int leftOverSpaces = padding % numSpaces;  // Extra spaces that don\\'t divide evenly between words.\\n        \\n        StringBuilder line = new StringBuilder();\\n        line.append(words[start]);\\n        \\n        for (int i = start + 1; i < end; i++) {\\n            line.append(\" \".repeat(spaceNeeded));\\n            if (leftOverSpaces-- > 0) {\\n                line.append(\\' \\');\\n            }\\n            line.append(words[i]);\\n        }\\n        \\n        return line.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603795,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        string s;\\n        for(auto it:words) \\n        {\\n            if(s.length() + it.length() > maxWidth) \\n            {\\n                s = s.substr(1);\\n                s = add_spaces(s, s.length(), maxWidth, maxWidth-s.length());\\n                ans.push_back(s);\\n                s = \" \" + it;\\n            }\\n            else \\n            {\\n                s = s + \" \" + it;\\n            }\\n        }\\n        s = s.substr(1);\\n        ans.push_back(s);\\n        string tmp = ans.back();\\n        ans.pop_back();\\n        int sz = tmp.size();\\n        for(int i=0; i<maxWidth-sz; i++) tmp += \" \";\\n        ans.push_back(tmp);\\n        return ans;\\n    }\\n    \\n    string add_spaces(string s, int sz, int maxWidth, int extra) \\n    {\\n        int cnt = 0;\\n        vector<string> v;\\n        string tmp;\\n        \\n        // count total numbet=r of spaces necessary and storing all the words in given string\\n        for(int i=0; i<sz; i++) \\n        {\\n            if(s[i] != \\' \\') tmp += s[i];\\n            else {\\n                v.push_back(tmp);\\n                cnt++;\\n                tmp = \" \";\\n            }\\n        }\\n        v.push_back(tmp);\\n        extra += cnt;\\n        \\n        int tot = v.size();\\n        // if there\\'s only one word simply add spaces after the word\\n        if(cnt == 0) \\n        {\\n            string ans;\\n            ans += v[0];\\n            for(int i=0; i<extra; i++) ans += \" \";\\n            return ans;\\n        }\\n        \\n        string ans;\\n        // if total spaces are evenly divided between words\\n        // insert (totalSpaces)/(totalWords-1) spaces between each words\\n        if(extra % (tot-1) == 0) \\n        {\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    for(int j=0; j<(extra/(tot-1))-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        } \\n        else // else insert extra spaces between first (totalSpaces)%(totalWords-1) words\\n        {\\n            int extra_space = extra % (tot-1);\\n            int y = extra / (tot-1);\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    if(extra_space > 0) {\\n                        for(int j=0; j<y; j++) ans +=  \" \";\\n                        extra_space--;\\n                    }\\n                    else for(int j=0; j<y-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int n = words.size();\\n        string s;\\n        for(auto it:words) \\n        {\\n            if(s.length() + it.length() > maxWidth) \\n            {\\n                s = s.substr(1);\\n                s = add_spaces(s, s.length(), maxWidth, maxWidth-s.length());\\n                ans.push_back(s);\\n                s = \" \" + it;\\n            }\\n            else \\n            {\\n                s = s + \" \" + it;\\n            }\\n        }\\n        s = s.substr(1);\\n        ans.push_back(s);\\n        string tmp = ans.back();\\n        ans.pop_back();\\n        int sz = tmp.size();\\n        for(int i=0; i<maxWidth-sz; i++) tmp += \" \";\\n        ans.push_back(tmp);\\n        return ans;\\n    }\\n    \\n    string add_spaces(string s, int sz, int maxWidth, int extra) \\n    {\\n        int cnt = 0;\\n        vector<string> v;\\n        string tmp;\\n        \\n        // count total numbet=r of spaces necessary and storing all the words in given string\\n        for(int i=0; i<sz; i++) \\n        {\\n            if(s[i] != \\' \\') tmp += s[i];\\n            else {\\n                v.push_back(tmp);\\n                cnt++;\\n                tmp = \" \";\\n            }\\n        }\\n        v.push_back(tmp);\\n        extra += cnt;\\n        \\n        int tot = v.size();\\n        // if there\\'s only one word simply add spaces after the word\\n        if(cnt == 0) \\n        {\\n            string ans;\\n            ans += v[0];\\n            for(int i=0; i<extra; i++) ans += \" \";\\n            return ans;\\n        }\\n        \\n        string ans;\\n        // if total spaces are evenly divided between words\\n        // insert (totalSpaces)/(totalWords-1) spaces between each words\\n        if(extra % (tot-1) == 0) \\n        {\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    for(int j=0; j<(extra/(tot-1))-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        } \\n        else // else insert extra spaces between first (totalSpaces)%(totalWords-1) words\\n        {\\n            int extra_space = extra % (tot-1);\\n            int y = extra / (tot-1);\\n            for(int i=0; i<v.size(); i++) \\n            {\\n                ans += v[i];\\n                if(i != v.size()-1)\\n                {\\n                    if(extra_space > 0) {\\n                        for(int j=0; j<y; j++) ans +=  \" \";\\n                        extra_space--;\\n                    }\\n                    else for(int j=0; j<y-1; j++) ans +=  \" \";\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597909,
                "title": "python-solution-with-recursive-helper-function",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\\n        \"\"\"Given a list of words and a max line width, justify the text to fit each line.\\n        \\n        Take a greedy approach.\\n        Words by themselves AND the line will be left-justified.\\n            The last line will have no extra spaces between words.\\n        Normal lines will have spaces evenly distributed between words, with more\\n            spaces going to the left-most slots.\\n        \"\"\"\\n        output = []\\n\\n        while words:\\n            # Calling this with maxWidth + 1 accomodates for the \\n            # recursive fit_line function adding +1 space\\n            # for every word (when in reality there\\'s one less space than words)\\n            line = self.fit_line(words, maxWidth + 1)\\n            # This shortens the list to only include the remaining words,\\n            # and gives the loop a termination condition.\\n            words = words[len(line):]\\n\\n            # Case for the last line, or any line that only has one word.\\n            if len(line) == 1 or not words:\\n                output.append(self.left_justify(line, maxWidth))\\n            # Case for normal lines.\\n            else:\\n                output.append(self.center_justify(line, maxWidth))\\n        \\n        return output\\n    \\n    def fit_line(self, sublist: list[str], max_width) -> list[str]:\\n        \"\"\"Fit as many words as possible from sublist onto a line.\"\"\"\\n        # If the sublist is empty or if we can\\'t put anything else onto the line.\\n        if not sublist or max_width == 0:\\n            return []\\n        # We can\\'t fit any more words on this line (no more space left).\\n        elif len(sublist[0]) + 1 > max_width:\\n            return []\\n        else:\\n            # The first word in this list, plus the most words from the remaining\\n            # sublist that can fit. The +1 at the end is to account for the 1\\n            # mandatory space between words.\\n            return [sublist[0]] + self.fit_line(sublist[1:], max_width - (len(sublist[0]) + 1))\\n    \\n    def center_justify(self, sublist: list[str], max_width: int) -> str:\\n        \"\"\"Center justify the words in sublist, and return that as a string.\"\"\"\\n        # Calculate how much space we have left.\\n        space_left = self.find_space_left(sublist, max_width)\\n\\n        # Create space slots.\\n        # There are one less slots than number of words.\\n        space_slots = [\" \"] * (len(sublist) - 1)\\n\\n        slot_index = 0\\n        while space_left:\\n            space_slots[slot_index] += \" \"\\n            space_left -= 1\\n            # This will keep the index between 0 and the number of space_slots.\\n            slot_index += 1\\n            slot_index = slot_index % len(space_slots)\\n        \\n        # Add a blank space slot before the first word, now space_slots and\\n        # sublist have the same number of elements.\\n        space_slots.insert(0, \"\")\\n\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        return \"\".join(together)\\n    \\n    def left_justify(self, sublist: list[str], max_width: int) -> str:\\n        space_left = self.find_space_left(sublist, max_width)\\n        \\n        # Create space slots as though we were center justifying.\\n        # The difference is we don\\'t need to rotate bewteen slots.\\n        space_slots = [\"\"] + [\" \"] * (len(sublist) - 1)\\n\\n        # Join the words and the space slots.\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        output = \"\".join(together)\\n        # Add all the remaining spaces to the end.\\n        output += \" \" * space_left\\n\\n        return output\\n    \\n    def find_space_left(self, words: list[str], max_width: int) -> int:\\n        # The max width - minimum number of spaces - combined length of words.\\n        return max_width - (len(words) - 1) - sum([len(w) for w in words])\\n\\'\\'\\'\\n\\nThere\\'s probably room for some optimization, but I feel like this one is easy to understand.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\\n        \"\"\"Given a list of words and a max line width, justify the text to fit each line.\\n        \\n        Take a greedy approach.\\n        Words by themselves AND the line will be left-justified.\\n            The last line will have no extra spaces between words.\\n        Normal lines will have spaces evenly distributed between words, with more\\n            spaces going to the left-most slots.\\n        \"\"\"\\n        output = []\\n\\n        while words:\\n            # Calling this with maxWidth + 1 accomodates for the \\n            # recursive fit_line function adding +1 space\\n            # for every word (when in reality there\\'s one less space than words)\\n            line = self.fit_line(words, maxWidth + 1)\\n            # This shortens the list to only include the remaining words,\\n            # and gives the loop a termination condition.\\n            words = words[len(line):]\\n\\n            # Case for the last line, or any line that only has one word.\\n            if len(line) == 1 or not words:\\n                output.append(self.left_justify(line, maxWidth))\\n            # Case for normal lines.\\n            else:\\n                output.append(self.center_justify(line, maxWidth))\\n        \\n        return output\\n    \\n    def fit_line(self, sublist: list[str], max_width) -> list[str]:\\n        \"\"\"Fit as many words as possible from sublist onto a line.\"\"\"\\n        # If the sublist is empty or if we can\\'t put anything else onto the line.\\n        if not sublist or max_width == 0:\\n            return []\\n        # We can\\'t fit any more words on this line (no more space left).\\n        elif len(sublist[0]) + 1 > max_width:\\n            return []\\n        else:\\n            # The first word in this list, plus the most words from the remaining\\n            # sublist that can fit. The +1 at the end is to account for the 1\\n            # mandatory space between words.\\n            return [sublist[0]] + self.fit_line(sublist[1:], max_width - (len(sublist[0]) + 1))\\n    \\n    def center_justify(self, sublist: list[str], max_width: int) -> str:\\n        \"\"\"Center justify the words in sublist, and return that as a string.\"\"\"\\n        # Calculate how much space we have left.\\n        space_left = self.find_space_left(sublist, max_width)\\n\\n        # Create space slots.\\n        # There are one less slots than number of words.\\n        space_slots = [\" \"] * (len(sublist) - 1)\\n\\n        slot_index = 0\\n        while space_left:\\n            space_slots[slot_index] += \" \"\\n            space_left -= 1\\n            # This will keep the index between 0 and the number of space_slots.\\n            slot_index += 1\\n            slot_index = slot_index % len(space_slots)\\n        \\n        # Add a blank space slot before the first word, now space_slots and\\n        # sublist have the same number of elements.\\n        space_slots.insert(0, \"\")\\n\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        return \"\".join(together)\\n    \\n    def left_justify(self, sublist: list[str], max_width: int) -> str:\\n        space_left = self.find_space_left(sublist, max_width)\\n        \\n        # Create space slots as though we were center justifying.\\n        # The difference is we don\\'t need to rotate bewteen slots.\\n        space_slots = [\"\"] + [\" \"] * (len(sublist) - 1)\\n\\n        # Join the words and the space slots.\\n        together = zip(space_slots, sublist)\\n        together = [s + w for s, w in together]\\n        output = \"\".join(together)\\n        # Add all the remaining spaces to the end.\\n        output += \" \" * space_left\\n\\n        return output\\n    \\n    def find_space_left(self, words: list[str], max_width: int) -> int:\\n        # The max width - minimum number of spaces - combined length of words.\\n        return max_width - (len(words) - 1) - sum([len(w) for w in words])\\n\\'\\'\\'\\n\\nThere\\'s probably room for some optimization, but I feel like this one is easy to understand.",
                "codeTag": "Java"
            },
            {
                "id": 1590497,
                "title": "go-solution-0-ms-100-00-2-3-mb-52-44",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\n/*\\n\\n68. Text Justification\\n\\nhttps://leetcode.com/problems/text-justification/\\n\\n*/\\n\\nfunc nextWords(words []string, maxWidth int, index int) ([]string, int) {\\n\\tresult := make([]string, 0)\\n\\n\\twidth := 0\\n\\tfirst := true\\n\\n\\tfor {\\n\\t\\tif index >= len(words) {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tword := words[index]\\n\\n\\t\\twidth += len(word)\\n\\t\\tif !first {\\n\\t\\t\\twidth++\\n\\t\\t} else {\\n\\t\\t\\tfirst = false\\n\\t\\t}\\n\\n\\t\\tif width > maxWidth {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tresult = append(result, word)\\n\\n\\t\\tindex++\\n\\t}\\n}\\n\\nfunc generateRow(words []string, maxWidth int, lastRow bool) string {\\n\\tif lastRow {\\n\\t\\tresult := strings.Join(words, \" \")\\n\\n\\t\\treturn result + strings.Repeat(\" \", maxWidth-len(result))\\n\\t}\\n\\n\\ttotalWordsWidth := 0\\n\\tfor _, word := range words {\\n\\t\\ttotalWordsWidth += len(word)\\n\\t}\\n\\n\\tresult := \"\"\\n\\tfor index, word := range words {\\n\\t\\tresult += word\\n\\t\\ttotalWordsWidth -= len(word)\\n\\t\\textraSpace := maxWidth - len(result) - totalWordsWidth\\n\\t\\twordsLeft := len(words) - index - 1\\n\\n\\t\\tif wordsLeft == 0 {\\n\\t\\t\\tresult += strings.Repeat(\" \", maxWidth-len(result))\\n\\t\\t} else {\\n\\t\\t\\tresult += strings.Repeat(\" \", extraSpace/wordsLeft)\\n\\t\\t\\tif extraSpace%wordsLeft != 0 {\\n\\t\\t\\t\\tresult += \" \"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tresults := make([]string, 0)\\n\\n\\tindex := 0\\n\\n\\tfor {\\n\\t\\tvar row []string\\n\\t\\trow, index = nextWords(words, maxWidth, index)\\n\\n\\t\\tresults = append(results, generateRow(row, maxWidth, index >= len(words)))\\n\\n\\t\\tif index >= len(words) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n}\\n\\nfunc printResult(result []string) {\\n\\tfor _, row := range result {\\n\\t\\tfmt.Println(\"[\" + row + \"]\")\\n\\t}\\n\\n\\tfmt.Println()\\n}\\n\\nfunc main() {\\n\\twords1 := []string{\\n\\t\\t\"This\",\\n\\t\\t\"is\",\\n\\t\\t\"an\",\\n\\t\\t\"example\",\\n\\t\\t\"of\",\\n\\t\\t\"text\",\\n\\t\\t\"justification.\",\\n\\t}\\n\\n\\t// [This    is    an]\\n\\t// [example  of text]\\n\\t// [justification.  ]\\n\\n\\tprintResult(fullJustify(words1, 16))\\n\\n\\twords2 := []string{\\n\\t\\t\"What\",\\n\\t\\t\"must\",\\n\\t\\t\"be\",\\n\\t\\t\"acknowledgment\",\\n\\t\\t\"shall\",\\n\\t\\t\"be\",\\n\\t}\\n\\n\\t// [What   must   be]\\n\\t// [acknowledgment  ]\\n\\t// [shall be        ]\\n\\n\\tprintResult(fullJustify(words2, 16))\\n\\n\\twords3 := []string{\\n\\t\\t\"Science\",\\n\\t\\t\"is\",\\n\\t\\t\"what\",\\n\\t\\t\"we\",\\n\\t\\t\"understand\",\\n\\t\\t\"well\",\\n\\t\\t\"enough\",\\n\\t\\t\"to\",\\n\\t\\t\"explain\",\\n\\t\\t\"to\",\\n\\t\\t\"a\",\\n\\t\\t\"computer.\",\\n\\t\\t\"Art\",\\n\\t\\t\"is\",\\n\\t\\t\"everything\",\\n\\t\\t\"else\",\\n\\t\\t\"we\",\\n\\t\\t\"do\",\\n\\t}\\n\\n\\t// [Science  is  what we]\\n\\t// [understand      well]\\n\\t// [enough to explain to]\\n\\t// [a  computer.  Art is]\\n\\t// [everything  else  we]\\n\\t// [do                  ]\\n\\n\\tprintResult(fullJustify(words3, 20))\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Iterator"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strings\"\\n)\\n\\n/*\\n\\n68. Text Justification\\n\\nhttps://leetcode.com/problems/text-justification/\\n\\n*/\\n\\nfunc nextWords(words []string, maxWidth int, index int) ([]string, int) {\\n\\tresult := make([]string, 0)\\n\\n\\twidth := 0\\n\\tfirst := true\\n\\n\\tfor {\\n\\t\\tif index >= len(words) {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tword := words[index]\\n\\n\\t\\twidth += len(word)\\n\\t\\tif !first {\\n\\t\\t\\twidth++\\n\\t\\t} else {\\n\\t\\t\\tfirst = false\\n\\t\\t}\\n\\n\\t\\tif width > maxWidth {\\n\\t\\t\\treturn result, index\\n\\t\\t}\\n\\n\\t\\tresult = append(result, word)\\n\\n\\t\\tindex++\\n\\t}\\n}\\n\\nfunc generateRow(words []string, maxWidth int, lastRow bool) string {\\n\\tif lastRow {\\n\\t\\tresult := strings.Join(words, \" \")\\n\\n\\t\\treturn result + strings.Repeat(\" \", maxWidth-len(result))\\n\\t}\\n\\n\\ttotalWordsWidth := 0\\n\\tfor _, word := range words {\\n\\t\\ttotalWordsWidth += len(word)\\n\\t}\\n\\n\\tresult := \"\"\\n\\tfor index, word := range words {\\n\\t\\tresult += word\\n\\t\\ttotalWordsWidth -= len(word)\\n\\t\\textraSpace := maxWidth - len(result) - totalWordsWidth\\n\\t\\twordsLeft := len(words) - index - 1\\n\\n\\t\\tif wordsLeft == 0 {\\n\\t\\t\\tresult += strings.Repeat(\" \", maxWidth-len(result))\\n\\t\\t} else {\\n\\t\\t\\tresult += strings.Repeat(\" \", extraSpace/wordsLeft)\\n\\t\\t\\tif extraSpace%wordsLeft != 0 {\\n\\t\\t\\t\\tresult += \" \"\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc fullJustify(words []string, maxWidth int) []string {\\n\\tresults := make([]string, 0)\\n\\n\\tindex := 0\\n\\n\\tfor {\\n\\t\\tvar row []string\\n\\t\\trow, index = nextWords(words, maxWidth, index)\\n\\n\\t\\tresults = append(results, generateRow(row, maxWidth, index >= len(words)))\\n\\n\\t\\tif index >= len(words) {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn results\\n}\\n\\nfunc printResult(result []string) {\\n\\tfor _, row := range result {\\n\\t\\tfmt.Println(\"[\" + row + \"]\")\\n\\t}\\n\\n\\tfmt.Println()\\n}\\n\\nfunc main() {\\n\\twords1 := []string{\\n\\t\\t\"This\",\\n\\t\\t\"is\",\\n\\t\\t\"an\",\\n\\t\\t\"example\",\\n\\t\\t\"of\",\\n\\t\\t\"text\",\\n\\t\\t\"justification.\",\\n\\t}\\n\\n\\t// [This    is    an]\\n\\t// [example  of text]\\n\\t// [justification.  ]\\n\\n\\tprintResult(fullJustify(words1, 16))\\n\\n\\twords2 := []string{\\n\\t\\t\"What\",\\n\\t\\t\"must\",\\n\\t\\t\"be\",\\n\\t\\t\"acknowledgment\",\\n\\t\\t\"shall\",\\n\\t\\t\"be\",\\n\\t}\\n\\n\\t// [What   must   be]\\n\\t// [acknowledgment  ]\\n\\t// [shall be        ]\\n\\n\\tprintResult(fullJustify(words2, 16))\\n\\n\\twords3 := []string{\\n\\t\\t\"Science\",\\n\\t\\t\"is\",\\n\\t\\t\"what\",\\n\\t\\t\"we\",\\n\\t\\t\"understand\",\\n\\t\\t\"well\",\\n\\t\\t\"enough\",\\n\\t\\t\"to\",\\n\\t\\t\"explain\",\\n\\t\\t\"to\",\\n\\t\\t\"a\",\\n\\t\\t\"computer.\",\\n\\t\\t\"Art\",\\n\\t\\t\"is\",\\n\\t\\t\"everything\",\\n\\t\\t\"else\",\\n\\t\\t\"we\",\\n\\t\\t\"do\",\\n\\t}\\n\\n\\t// [Science  is  what we]\\n\\t// [understand      well]\\n\\t// [enough to explain to]\\n\\t// [a  computer.  Art is]\\n\\t// [everything  else  we]\\n\\t// [do                  ]\\n\\n\\tprintResult(fullJustify(words3, 20))\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1566039,
                "title": "python-concise-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # number of characters that a group of words occupy is\\n        # numTotalLetters + words - 1 (for spaces)\\n        # The moment a new word causes this computation to exceed max width is when we introduce a new row\\n        # Spread the spaces of the remainder of maxwidth and this computation as spaces for each word in a round robin left to right \\n        \\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        \\n        remainder = \\' \\'.join(cur)\\n        remainder += \\' \\' * (maxWidth - len(remainder))\\n        \\n        return res + [remainder]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # number of characters that a group of words occupy is\\n        # numTotalLetters + words - 1 (for spaces)\\n        # The moment a new word causes this computation to exceed max width is when we introduce a new row\\n        # Spread the spaces of the remainder of maxwidth and this computation as spaces for each word in a round robin left to right \\n        \\n        res, cur, num_of_letters = [], [], 0\\n        for w in words:\\n            if num_of_letters + len(w) + len(cur) > maxWidth:\\n                for i in range(maxWidth - num_of_letters):\\n                    cur[i%(len(cur)-1 or 1)] += \\' \\'\\n                res.append(\\'\\'.join(cur))\\n                cur, num_of_letters = [], 0\\n            cur += [w]\\n            num_of_letters += len(w)\\n        \\n        remainder = \\' \\'.join(cur)\\n        remainder += \\' \\' * (maxWidth - len(remainder))\\n        \\n        return res + [remainder]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546004,
                "title": "java-simple-short-and-easy-for-dummies-like-me-heavily-commented",
                "content": "```\\n/*\\nBasic Idea:\\n1. Add words to each line until they fit within maxWidth\\n2. Calculate the extra spaces remaining, (maxWidth - characterCountAdded)\\n3. Distribute the extra spaces among every word in the line in a Round Robin Fashion. Now your line is justified.\\n4. Add the justified line to the resultList\\n5. Repeat it for the rest of the words\\n*/\\n\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // ArrayList to store the justified text result\\n        List<String> result = new ArrayList<>();\\n        \\n        // ArrayList to store a justified line\\n        // We use StringBuilder instead of String, because we want to append spaces to it\\n        List<StringBuilder> line = new ArrayList<>();\\n        \\n        // No of characters in a given line\\n        int charCount = 0;\\n        \\n        for (String word : words) {\\n            \\n            int spacesNeeded = line.size(); // represents single space needed between words\\n            if (charCount + word.length() + spacesNeeded > maxWidth) {\\n                // We could not add the new word to the line\\n                // Hence, lets justify the words already present in the line\\n                \\n                // In order to justify, we need to calculate the extra spaces\\n                // and distribute the spaces among the words in a Round Robin Fashion\\n                int spacesAvailable = maxWidth - charCount;\\n                for (int i = 0; i < spacesAvailable; i++) {\\n                    if (line.size() == 1) {\\n                        // If there is only one word present in the line,\\n                        // keep adding all the available spaces to the end of the single word\\n                        line.get(0).append(\" \");    \\n                    } else {\\n                        // If there are more than 1 word in the line,\\n                        // Add spaces to every word one after the other, except the last word (question\\'s requirement)\\n                        // Since we do not want to add space to the last word, we are doing line.size() - 1, else it would be just line.size()\\n                        line.get(i % (line.size() - 1)).append(\" \");\\n                    }\\n                }\\n                \\n                // convert the line list to String\\n                // Since we already added all the necessary spacing,\\n                // we just need to join with empty string \"\"\\n                result.add(String.join(\"\", line));\\n                line.clear(); // empty the line\\n                charCount = 0; // clear the charCount\\n            }\\n            \\n            \\n            // Add the current word, because we are within the maxWidth\\n            line.add(new StringBuilder(word));\\n            charCount += word.length(); // Increment the charCount for the word added\\n            \\n        }\\n        \\n        // We are at the last line\\n        // Last line needs to be Left Justified,\\n        // meaning we still need to add all the extra spaces to the right\\n        if (!line.isEmpty()) { // check if line is not empty, (not sure if this is needed, just to be safe)\\n            // Build the lastLine String,\\n            // for which we need to join with a single space because we did not add any space before\\n            String lastLine = String.join(\" \", line);\\n            // Left Justification is done here,\\n            // Ex: String.format(\"%-6s\", \"12345\") will give \"12345 \"  (12345 and 1 extra space)\\n            // Ex: String.format(\"%-7s\", \"12345\") will give \"12345  \" (12345 and 2 extra spaces)\\n            // Ex: String.format(\"%-5s\", \"12345\") will give \"12345\"   (12345 and 0 extra spaces)\\n            String justifiedLastLine = String.format(\"%-\"+maxWidth+\"s\", lastLine);\\n            result.add(justifiedLastLine); // Add to result\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nBasic Idea:\\n1. Add words to each line until they fit within maxWidth\\n2. Calculate the extra spaces remaining, (maxWidth - characterCountAdded)\\n3. Distribute the extra spaces among every word in the line in a Round Robin Fashion. Now your line is justified.\\n4. Add the justified line to the resultList\\n5. Repeat it for the rest of the words\\n*/\\n\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        // ArrayList to store the justified text result\\n        List<String> result = new ArrayList<>();\\n        \\n        // ArrayList to store a justified line\\n        // We use StringBuilder instead of String, because we want to append spaces to it\\n        List<StringBuilder> line = new ArrayList<>();\\n        \\n        // No of characters in a given line\\n        int charCount = 0;\\n        \\n        for (String word : words) {\\n            \\n            int spacesNeeded = line.size(); // represents single space needed between words\\n            if (charCount + word.length() + spacesNeeded > maxWidth) {\\n                // We could not add the new word to the line\\n                // Hence, lets justify the words already present in the line\\n                \\n                // In order to justify, we need to calculate the extra spaces\\n                // and distribute the spaces among the words in a Round Robin Fashion\\n                int spacesAvailable = maxWidth - charCount;\\n                for (int i = 0; i < spacesAvailable; i++) {\\n                    if (line.size() == 1) {\\n                        // If there is only one word present in the line,\\n                        // keep adding all the available spaces to the end of the single word\\n                        line.get(0).append(\" \");    \\n                    } else {\\n                        // If there are more than 1 word in the line,\\n                        // Add spaces to every word one after the other, except the last word (question\\'s requirement)\\n                        // Since we do not want to add space to the last word, we are doing line.size() - 1, else it would be just line.size()\\n                        line.get(i % (line.size() - 1)).append(\" \");\\n                    }\\n                }\\n                \\n                // convert the line list to String\\n                // Since we already added all the necessary spacing,\\n                // we just need to join with empty string \"\"\\n                result.add(String.join(\"\", line));\\n                line.clear(); // empty the line\\n                charCount = 0; // clear the charCount\\n            }\\n            \\n            \\n            // Add the current word, because we are within the maxWidth\\n            line.add(new StringBuilder(word));\\n            charCount += word.length(); // Increment the charCount for the word added\\n            \\n        }\\n        \\n        // We are at the last line\\n        // Last line needs to be Left Justified,\\n        // meaning we still need to add all the extra spaces to the right\\n        if (!line.isEmpty()) { // check if line is not empty, (not sure if this is needed, just to be safe)\\n            // Build the lastLine String,\\n            // for which we need to join with a single space because we did not add any space before\\n            String lastLine = String.join(\" \", line);\\n            // Left Justification is done here,\\n            // Ex: String.format(\"%-6s\", \"12345\") will give \"12345 \"  (12345 and 1 extra space)\\n            // Ex: String.format(\"%-7s\", \"12345\") will give \"12345  \" (12345 and 2 extra spaces)\\n            // Ex: String.format(\"%-5s\", \"12345\") will give \"12345\"   (12345 and 0 extra spaces)\\n            String justifiedLastLine = String.format(\"%-\"+maxWidth+\"s\", lastLine);\\n            result.add(justifiedLastLine); // Add to result\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531563,
                "title": "c-solutuion",
                "content": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n\\t\\t\\tvector<string> vec;\\n        \\n        int i = 0;\\n        \\n        while(i<words.size())\\n        {\\n            int j = i+1;\\n            int sum = words[i].length();\\n            int curr = 0;\\n            while(j<words.size() and sum+words[j].size()+1+curr<=maxWidth)\\n            {\\n                sum += words[j].length();\\n                j++;\\n                curr++;\\n            }\\n            string now = \"\";\\n            int extra = (curr==0)?0:(maxWidth - sum)/curr;\\n            int more = (curr==0)?0:(maxWidth - sum)%curr;\\n            if(j==words.size())\\n            {\\n                 for(int k=i;k<j;k++)\\n                {\\n                      now += words[k];\\n                     now += \" \";\\n                }\\n                now.pop_back();\\n            }\\n            else\\n            {\\n                 for(int k=i;k<j;k++)\\n                {\\n                    now += words[k];\\n                    if(k==j-1)\\n                        break;\\n                    for(int g=0;g<extra;g++)\\n                    {\\n                        now += \" \";\\n                    }\\n                    if(more)\\n                    {\\n                        now += \" \";\\n                        more--;\\n                    }\\n                }\\n            }\\n           \\n            cout<<now.length()<<\" \";\\n            while(now.length()<maxWidth)\\n                now += \" \";\\n            vec.push_back(now);\\n            i=j;\\n        }\\n        \\n        return vec;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution\\n{\\n\\tpublic:\\n\\t\\tvector<string> fullJustify(vector<string>& words, int maxWidth) {\\n\\t\\t\\tvector<string> vec;\\n        \\n        int i = 0;\\n        \\n        while(i<words.size())\\n        {\\n            int j = i+1;\\n            int sum = words[i].length();\\n            int curr = 0;\\n            while(j<words.size() and sum+words[j].size()+1+curr<=maxWidth)\\n            {\\n                sum += words[j].length();\\n                j++;\\n                curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1525084,
                "title": "python-approach-with-comments-to-explain-the-logic",
                "content": "**I divided the code in 2 methods:**\\n1. One that have the Justify logic\\n2. The main method\\n\\nThe one with the Justify logic will check an edge case where only 1 word fits into the line so it has to fill blanks at the end of the line.\\n\\nThe rest is just calculating the length of the spaces and how many reminders are so we need to an extra space.\\n\\nThe main method will start with the first word in the current line and check if we can add another word to the line and meet the condition that fits in a line of max_width.\\n\\n**O(N) Time Complexity:** We have to traverse the words 1 time in the main method which is O(N) + another time when formatting which is O(N) and join method will traverse the words and its spaces ~O(N+N-1) = O(2N-1) which is in total O(4N) ~= O(N)\\n\\n**O(N) Space Complexity:** Current Line can store potentially all the words which is an additional space of O(N) + O(N+N-1) for the words and spaces in the formating which is still O(N) so the space will require O(3N-1) ~= O(N)\\n\\n```\\nclass Solution:\\n    \\n    # formatLine will justify left and right sizes or just left\\n    # if there are only 1 word\\n    def formatLine(self, line, cur_len, max_length):\\n        \\n        # If we have N words we need N-1 spaces to separate\\n        spaces = len(line) - 1\\n        if spaces == 0:\\n            line.append(\\' \\' * (max_length - cur_len))\\n            return \\'\\'.join(line)\\n        \\n        # To know the length of spaces we need to know the remaining\\n        # characters to fill the line (max_length - cur_len) and divide\\n        # this remaining characters between the amount of spaces\\n        space_length = (max_length - cur_len) // spaces\\n\\t\\t\\n        # We might have a reminder and we will use an extra space from left\\n        # to right until we fill the gaps\\n        space_reminders = (max_length - cur_len) % spaces\\n        \\n        sb = [line[0]]\\n        space = \\' \\' * space_length\\n        \\n        for i in range(1, len(line)):\\n            # space already have the right length except for the reminder\\n            sb.append(space)\\n            if space_reminders > 0:\\n                # adding one reminder if we have\\n                sb.append(\\' \\')\\n                space_reminders -= 1\\n            # Adding the actual word\\n            sb.append(line[i])\\n        \\n        # This will finally format the line\\n        return \\'\\'.join(sb)\\n    \\n    \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # line have all de words we can add in a single line\\n        line = [words[0]]\\n\\t\\t\\n        # length for all the words in the current line but not taking in count\\n        # the spaces\\n        cur_len = len(words[0])\\n\\t\\t\\n        # final answer\\n        ans = []\\n        \\n        for i in range(1, len(words)):\\n            # If we add another word there will be N+1 words in the line so we\\n            # need N spaces at least\\n            min_need_spaces = len(line)\\n            \\n            # If we add another word the minimum length of the line will be\\n            # the total length we have so far for that line + the length of the\\n            # word we want to add and the minimum amount of spaces that we need\\n            # to separate the words\\n            if (cur_len + len(words[i]) + min_need_spaces) > maxWidth:\\n                # If the condition is met, we can\\'t add another word\\n                ans.append(self.formatLine(line, cur_len, maxWidth))\\n\\t\\t\\t\\t\\n                # As the line has been formatted we start over\\n                line.clear()\\n                cur_len = 0\\n            \\n            line.append(words[i])\\n            cur_len += len(words[i])\\n        \\n        # We just fill the last line with spaces at the end so it reaches the maxWidth\\n        last = \\' \\'.join(line)\\n        ans.append(last + (\\' \\' * (maxWidth - len(last))))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # formatLine will justify left and right sizes or just left\\n    # if there are only 1 word\\n    def formatLine(self, line, cur_len, max_length):\\n        \\n        # If we have N words we need N-1 spaces to separate\\n        spaces = len(line) - 1\\n        if spaces == 0:\\n            line.append(\\' \\' * (max_length - cur_len))\\n            return \\'\\'.join(line)\\n        \\n        # To know the length of spaces we need to know the remaining\\n        # characters to fill the line (max_length - cur_len) and divide\\n        # this remaining characters between the amount of spaces\\n        space_length = (max_length - cur_len) // spaces\\n\\t\\t\\n        # We might have a reminder and we will use an extra space from left\\n        # to right until we fill the gaps\\n        space_reminders = (max_length - cur_len) % spaces\\n        \\n        sb = [line[0]]\\n        space = \\' \\' * space_length\\n        \\n        for i in range(1, len(line)):\\n            # space already have the right length except for the reminder\\n            sb.append(space)\\n            if space_reminders > 0:\\n                # adding one reminder if we have\\n                sb.append(\\' \\')\\n                space_reminders -= 1\\n            # Adding the actual word\\n            sb.append(line[i])\\n        \\n        # This will finally format the line\\n        return \\'\\'.join(sb)\\n    \\n    \\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        # line have all de words we can add in a single line\\n        line = [words[0]]\\n\\t\\t\\n        # length for all the words in the current line but not taking in count\\n        # the spaces\\n        cur_len = len(words[0])\\n\\t\\t\\n        # final answer\\n        ans = []\\n        \\n        for i in range(1, len(words)):\\n            # If we add another word there will be N+1 words in the line so we\\n            # need N spaces at least\\n            min_need_spaces = len(line)\\n            \\n            # If we add another word the minimum length of the line will be\\n            # the total length we have so far for that line + the length of the\\n            # word we want to add and the minimum amount of spaces that we need\\n            # to separate the words\\n            if (cur_len + len(words[i]) + min_need_spaces) > maxWidth:\\n                # If the condition is met, we can\\'t add another word\\n                ans.append(self.formatLine(line, cur_len, maxWidth))\\n\\t\\t\\t\\t\\n                # As the line has been formatted we start over\\n                line.clear()\\n                cur_len = 0\\n            \\n            line.append(words[i])\\n            cur_len += len(words[i])\\n        \\n        # We just fill the last line with spaces at the end so it reaches the maxWidth\\n        last = \\' \\'.join(line)\\n        ans.append(last + (\\' \\' * (maxWidth - len(last))))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485789,
                "title": "object-oriented-approach-java",
                "content": "I solved this using an object-oriented approach where I created a `Line` object for each line that was going to be returned. Each `Line` object contains a list of words, and concatenates the words in its `toString()` method. I just found this approach clean, but in other regards it is no different from solutions already shared here. The `fullJustify` method itself is very small with this approach.\\n\\n```\\nclass Solution {\\n    private static final class Line {\\n        private int maxLength;\\n        private int currentLength = 0;\\n        private List<String> words = new ArrayList<>();\\n        private boolean lastWord = false;\\n        \\n        private Line(int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n        \\n        private boolean tryAdd(String word) {\\n            if (currentLength == 0) {\\n                currentLength += word.length();\\n                words.add(word);\\n                return true;\\n            }\\n            boolean canAddWord = currentLength + word.length() + 1 <= maxLength;\\n            if (canAddWord) {\\n                currentLength += word.length() + 1;\\n                words.add(word);\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        private void flagAsLastWord() {\\n            lastWord = true;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            if (lastWord) {\\n                return toStringLastWord();\\n            } else {\\n                return toStringNotLastWord();\\n            }\\n        }\\n        \\n        private String toStringNotLastWord() {\\n            \\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            int numEmptySpots = this.words.size() == 1 ? 1 : this.words.size() - 1;\\n            int spareSpaces = emptySpaces % numEmptySpots;\\n            int minSpacesPerSpot = emptySpaces / numEmptySpots;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (int i = 0; i < words.size(); i++) {\\n                String word = words.get(i);\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    int spacesAfterWord;\\n                    if (spareSpaces > 0) {\\n                        spacesAfterWord = minSpacesPerSpot + 1;\\n                        spareSpaces--;\\n                    } else {\\n                        spacesAfterWord = minSpacesPerSpot;\\n                    }\\n                    emptySpaces -= spacesAfterWord;\\n                    for (int j = 0; j < spacesAfterWord; j++) {\\n                        sb.append(\\' \\');\\n                    }\\n                }\\n                \\n            }\\n            return sb.toString();\\n        }\\n        \\n        private String toStringLastWord() {\\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (String word : words) {\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    sb.append(\\' \\');\\n                    emptySpaces--;\\n                }\\n            }\\n            for (int i = 0; i < emptySpaces; i++) {\\n                sb.append(\\' \\');\\n            }\\n            return sb.toString();\\n        }\\n    }\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(new Line(maxWidth));\\n        \\n        for (String word : words) {\\n            Line last = lines.get(lines.size() - 1);\\n            if (!last.tryAdd(word)) {\\n                Line newLine = new Line(maxWidth);\\n                lines.add(newLine);\\n                newLine.tryAdd(word);\\n            }\\n        }\\n        \\n        Line last = lines.get(lines.size() - 1);\\n        last.flagAsLastWord();\\n        \\n        List<String> result = new ArrayList<>(lines.size());\\n        for (Line line : lines) {\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final class Line {\\n        private int maxLength;\\n        private int currentLength = 0;\\n        private List<String> words = new ArrayList<>();\\n        private boolean lastWord = false;\\n        \\n        private Line(int maxLength) {\\n            this.maxLength = maxLength;\\n        }\\n        \\n        private boolean tryAdd(String word) {\\n            if (currentLength == 0) {\\n                currentLength += word.length();\\n                words.add(word);\\n                return true;\\n            }\\n            boolean canAddWord = currentLength + word.length() + 1 <= maxLength;\\n            if (canAddWord) {\\n                currentLength += word.length() + 1;\\n                words.add(word);\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        private void flagAsLastWord() {\\n            lastWord = true;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            if (lastWord) {\\n                return toStringLastWord();\\n            } else {\\n                return toStringNotLastWord();\\n            }\\n        }\\n        \\n        private String toStringNotLastWord() {\\n            \\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            int numEmptySpots = this.words.size() == 1 ? 1 : this.words.size() - 1;\\n            int spareSpaces = emptySpaces % numEmptySpots;\\n            int minSpacesPerSpot = emptySpaces / numEmptySpots;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (int i = 0; i < words.size(); i++) {\\n                String word = words.get(i);\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    int spacesAfterWord;\\n                    if (spareSpaces > 0) {\\n                        spacesAfterWord = minSpacesPerSpot + 1;\\n                        spareSpaces--;\\n                    } else {\\n                        spacesAfterWord = minSpacesPerSpot;\\n                    }\\n                    emptySpaces -= spacesAfterWord;\\n                    for (int j = 0; j < spacesAfterWord; j++) {\\n                        sb.append(\\' \\');\\n                    }\\n                }\\n                \\n            }\\n            return sb.toString();\\n        }\\n        \\n        private String toStringLastWord() {\\n            int charCount = 0;\\n            for (String word : words) {\\n                charCount += word.length();\\n            }\\n            int emptySpaces = this.maxLength - charCount;\\n            \\n            StringBuilder sb = new StringBuilder(this.maxLength);\\n            for (String word : words) {\\n                sb.append(word);\\n                if (emptySpaces > 0) {\\n                    sb.append(\\' \\');\\n                    emptySpaces--;\\n                }\\n            }\\n            for (int i = 0; i < emptySpaces; i++) {\\n                sb.append(\\' \\');\\n            }\\n            return sb.toString();\\n        }\\n    }\\n\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        List<Line> lines = new ArrayList<>();\\n        lines.add(new Line(maxWidth));\\n        \\n        for (String word : words) {\\n            Line last = lines.get(lines.size() - 1);\\n            if (!last.tryAdd(word)) {\\n                Line newLine = new Line(maxWidth);\\n                lines.add(newLine);\\n                newLine.tryAdd(word);\\n            }\\n        }\\n        \\n        Line last = lines.get(lines.size() - 1);\\n        last.flagAsLastWord();\\n        \\n        List<String> result = new ArrayList<>(lines.size());\\n        for (Line line : lines) {\\n            result.add(line.toString());\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465043,
                "title": "java-simple-implementation-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> list = new ArrayList<>();\\n        int i = 0;\\n        while(true){\\n            List<String> al = new ArrayList<>();\\n            int len = 0;\\n            while(i < words.length && len + words[i].length() <= maxWidth){\\n                al.add(words[i]);\\n                len += words[i].length() + 1;\\n                i++;\\n            }\\n            len--;\\n            int remLen = maxWidth - len;\\n            if(i == words.length){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n                break;\\n            } else if(al.size() == 1){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n            } else{\\n                int div = remLen / (al.size() - 1), rem = remLen % (al.size() - 1);\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    for(int k = 0; k < div; k++)\\n                        sb.append(\" \");\\n                    if(rem-- > 0)\\n                        sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                list.add(sb.toString());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> list = new ArrayList<>();\\n        int i = 0;\\n        while(true){\\n            List<String> al = new ArrayList<>();\\n            int len = 0;\\n            while(i < words.length && len + words[i].length() <= maxWidth){\\n                al.add(words[i]);\\n                len += words[i].length() + 1;\\n                i++;\\n            }\\n            len--;\\n            int remLen = maxWidth - len;\\n            if(i == words.length){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n                break;\\n            } else if(al.size() == 1){\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                while(remLen-- > 0)\\n                    sb.append(\" \");\\n                list.add(sb.toString());\\n            } else{\\n                int div = remLen / (al.size() - 1), rem = remLen % (al.size() - 1);\\n                StringBuilder sb = new StringBuilder(al.get(0));\\n                int j = 1;\\n                while(j < al.size()){\\n                    sb.append(\" \");\\n                    for(int k = 0; k < div; k++)\\n                        sb.append(\" \");\\n                    if(rem-- > 0)\\n                        sb.append(\" \");\\n                    sb.append(al.get(j++));\\n                }\\n                list.add(sb.toString());\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435489,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        // step 1: find words that can fit this line\\n        // step 2: justify\\n        int start = 0, end = 0;\\n        vector<string> res;\\n        while (end < words.size()) {\\n            int len = 0, total = 0;\\n            while (end < words.size() && len + words[end].size() <= maxWidth) {\\n                len += words[end].size() + 1;\\n                total += words[end].size();\\n                ++end;\\n            }\\n            bool isLast = (end == words.size());\\n            res.push_back(justify(words, start, end, maxWidth - total, isLast));\\n            start = end;\\n        }\\n        return res;\\n    }\\n    \\n    string justify(const vector<string>& words, int start, int end, int space, bool isLast) {\\n        string line;\\n        if (!isLast) {\\n            // eg: \"Science  is  what we\" maxwidth = 20\\n            // characters: 7 + 2 + 4 + 2 = 15\\n            // left = 20 - 15 = 5\\n            // 5/3 => 5 % 3 != 0? => space 1 = 5/3 + 1 = 2\\n            // 3/2 -> 3 % 2 != 0? => space 2 = 3/2 + 1 = 2\\n            // 1 => space 3 = 1\\n\\t\\t\\tint count = end - start - 1;  // number of space slots = number of words - 1\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (count > 0) {\\n                    int cur = space % count != 0? space/count + 1: space/count;\\n                    line.insert(line.end(), cur, \\' \\');\\n                    space -= cur;\\n                    --count;\\n                }\\n            }\\n        } else {\\n            for (int i = start; i < end; ++i) {\\n                line += words[i];\\n                if (space-- > 0) line.push_back(\\' \\');\\n            }\\n        }\\n        if (space > 0) line.insert(line.end(), space, \\' \\');\\n        return line;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429859,
                "title": "simplest-and-cleanest-solutions-java-and-python",
                "content": "Java\\n```\\nclass Solution {\\n    public void appendSpaces(StringBuilder sb, int spaces) {\\n        for (int i = 0; i < spaces; i++) {\\n            sb.append(\\' \\');\\n        }\\n    }\\n    \\n    public String makeLeftJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        for (int i = 1; i < row.size(); i++) {\\n            sb.append(\\' \\');\\n            sb.append(row.get(i));\\n        }\\n        appendSpaces(sb, totalSpaces + 1 - row.size());\\n        return sb.toString();\\n    }\\n    \\n    public String makeJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        if (row.size() <= 1) {\\n            // only one word in row: left-justify\\n            appendSpaces(sb, totalSpaces);\\n        } else {\\n            int n = row.size() - 1;\\n            // distribute total spaces among n slots\\n            int q = totalSpaces / n;\\n            int r = totalSpaces % n;\\n            for (int i = 1; i <= n; i++) {\\n                int spaces = q + (i <= r ? 1 : 0);\\n                appendSpaces(sb, spaces);\\n                sb.append(row.get(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> row = new ArrayList<>();\\n        int charCount = 0;\\n        for (String word : words) {\\n            // check if we exceed maxWidth if we add word to the current row\\n            // remember that for k words, we need at least k-1 spaces\\n            if (charCount + word.length() + row.size() > maxWidth) {\\n                result.add(makeJustifiedLine(row, maxWidth - charCount));\\n                row.clear();\\n                charCount = 0;\\n            }\\n            row.add(word);\\n            charCount += word.length();\\n        }\\n        // last row is left-justified\\n        result.add(makeLeftJustifiedLine(row, maxWidth - charCount));\\n        return result;\\n    }\\n}\\n```\\nPython3\\n```\\n class Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def makeLeftJustifiedLine(wordsRow, totalSpaces):\\n            return \\' \\'.join(wordsRow) + (\\' \\' *  (totalSpaces + 1 - len(wordsRow)))\\n        def makeJustifiedLine(wordsRow, totalSpaces):\\n            l = len(wordsRow)\\n            if l <= 1:\\n                return \\'\\'.join(wordsRow) + (\\' \\' * totalSpaces)\\n            # distribute total spaces among l-1 slots\\n            q, r = divmod(totalSpaces, l-1)\\n            line = [wordsRow[0]]\\n            for i in range(1,l):\\n                spaces = q + (1 if i <= r else 0)\\n                line.append(\\' \\' * spaces)\\n                line.append(wordsRow[i])\\n            return \\'\\'.join(line)\\n        result = []\\n        row = []\\n        charCount = 0\\n        for word in words:\\n            # check if we exceed maxWidth if we add word to the current row\\n            # remember that for k words, we need at least k-1 spaces\\n            if charCount + len(word) + len(row) > maxWidth:\\n                result.append(makeJustifiedLine(row, maxWidth - charCount))\\n                row.clear()\\n                charCount = 0\\n            row.append(word)\\n            charCount += len(word)\\n        # last row is left-justified\\n        result.append(makeLeftJustifiedLine(row, maxWidth - charCount))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void appendSpaces(StringBuilder sb, int spaces) {\\n        for (int i = 0; i < spaces; i++) {\\n            sb.append(\\' \\');\\n        }\\n    }\\n    \\n    public String makeLeftJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        for (int i = 1; i < row.size(); i++) {\\n            sb.append(\\' \\');\\n            sb.append(row.get(i));\\n        }\\n        appendSpaces(sb, totalSpaces + 1 - row.size());\\n        return sb.toString();\\n    }\\n    \\n    public String makeJustifiedLine(List<String> row, int totalSpaces) {\\n        StringBuilder sb = new StringBuilder(row.get(0));\\n        if (row.size() <= 1) {\\n            // only one word in row: left-justify\\n            appendSpaces(sb, totalSpaces);\\n        } else {\\n            int n = row.size() - 1;\\n            // distribute total spaces among n slots\\n            int q = totalSpaces / n;\\n            int r = totalSpaces % n;\\n            for (int i = 1; i <= n; i++) {\\n                int spaces = q + (i <= r ? 1 : 0);\\n                appendSpaces(sb, spaces);\\n                sb.append(row.get(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        ArrayList<String> result = new ArrayList<>();\\n        ArrayList<String> row = new ArrayList<>();\\n        int charCount = 0;\\n        for (String word : words) {\\n            // check if we exceed maxWidth if we add word to the current row\\n            // remember that for k words, we need at least k-1 spaces\\n            if (charCount + word.length() + row.size() > maxWidth) {\\n                result.add(makeJustifiedLine(row, maxWidth - charCount));\\n                row.clear();\\n                charCount = 0;\\n            }\\n            row.add(word);\\n            charCount += word.length();\\n        }\\n        // last row is left-justified\\n        result.add(makeLeftJustifiedLine(row, maxWidth - charCount));\\n        return result;\\n    }\\n}\\n```\n```\\n class Solution:\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        def makeLeftJustifiedLine(wordsRow, totalSpaces):\\n            return \\' \\'.join(wordsRow) + (\\' \\' *  (totalSpaces + 1 - len(wordsRow)))\\n        def makeJustifiedLine(wordsRow, totalSpaces):\\n            l = len(wordsRow)\\n            if l <= 1:\\n                return \\'\\'.join(wordsRow) + (\\' \\' * totalSpaces)\\n            # distribute total spaces among l-1 slots\\n            q, r = divmod(totalSpaces, l-1)\\n            line = [wordsRow[0]]\\n            for i in range(1,l):\\n                spaces = q + (1 if i <= r else 0)\\n                line.append(\\' \\' * spaces)\\n                line.append(wordsRow[i])\\n            return \\'\\'.join(line)\\n        result = []\\n        row = []\\n        charCount = 0\\n        for word in words:\\n            # check if we exceed maxWidth if we add word to the current row\\n            # remember that for k words, we need at least k-1 spaces\\n            if charCount + len(word) + len(row) > maxWidth:\\n                result.append(makeJustifiedLine(row, maxWidth - charCount))\\n                row.clear()\\n                charCount = 0\\n            row.append(word)\\n            charCount += len(word)\\n        # last row is left-justified\\n        result.append(makeLeftJustifiedLine(row, maxWidth - charCount))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331025,
                "title": "python-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], max_width: int) -> List[str]:        \\n        def left_justify(line):\\n            tmp = \" \".join(line)\\n            return tmp + \" \" * (max_width - len(tmp))\\n\\n        def justify(line):\\n            number_of_spaces = len(line) - 1\\n            if number_of_spaces == 0:\\n                return left_justify(line)\\n            \\n            available_space = max_width - sum(len(w) for w in line)\\n            space_size = available_space // number_of_spaces\\n            extra = available_space % number_of_spaces\\n            \\n            result = \"\"\\n            for i, word in enumerate(line):\\n                result += word\\n                if i != len(line) - 1:\\n                    result += \" \" * (space_size + int(i < extra))\\n            return result\\n        \\n        result = []\\n        current = [words[0]]\\n        counter = len(words[0])\\n\\n        for word in words[1:]:\\n            if counter + 1 + len(word) <= max_width:\\n                current.append(word)\\n                counter += 1 + len(word)\\n            else:\\n                result.append(justify(current))\\n                current = [word]\\n                counter = len(word)\\n        \\n        result.append(left_justify(current))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def fullJustify(self, words: List[str], max_width: int) -> List[str]:        \\n        def left_justify(line):\\n            tmp = \" \".join(line)\\n            return tmp + \" \" * (max_width - len(tmp))\\n\\n        def justify(line):\\n            number_of_spaces = len(line) - 1\\n            if number_of_spaces == 0:\\n                return left_justify(line)\\n            \\n            available_space = max_width - sum(len(w) for w in line)\\n            space_size = available_space // number_of_spaces\\n            extra = available_space % number_of_spaces\\n            \\n            result = \"\"\\n            for i, word in enumerate(line):\\n                result += word\\n                if i != len(line) - 1:\\n                    result += \" \" * (space_size + int(i < extra))\\n            return result\\n        \\n        result = []\\n        current = [words[0]]\\n        counter = len(words[0])\\n\\n        for word in words[1:]:\\n            if counter + 1 + len(word) <= max_width:\\n                current.append(word)\\n                counter += 1 + len(word)\\n            else:\\n                result.append(justify(current))\\n                current = [word]\\n                counter = len(word)\\n        \\n        result.append(left_justify(current))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316379,
                "title": "java-solution-with-detailed-explanation-0ms-100-runtime-97-memory",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int wordCount = 0;\\n        int lastIndex = 0;\\n        int runningLength=0;\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            /**\\n            * runningLength : total length of words until current word is added\\n            * s.length() : length of current word\\n            * wordCount : count of words till now (represents minimum spaces we would need with all the words already include)\\n            * Adding all of this tells us if current word can fit into current line\\n            *\\n            */\\n            if (runningLength + s.length() + wordCount > maxWidth) {\\n                //create a line since adding current word crosses the width\\n                int extraSpace = maxWidth - runningLength;\\n                // space per word, but not if wordCount is only 1                 \\n                int spw = wordCount > 1 ? extraSpace / (wordCount - 1) : 0;\\n                // left over spaces which need to be added 1 after each word until it last\\n                int los = wordCount > 1 ? extraSpace % (wordCount - 1) : 0;\\n                // construct line\\n                result.add(constructLine(words, lastIndex, wordCount, spw, los, maxWidth));\\n                // reset word count and running length\\n                wordCount = 0;\\n                runningLength = 0;\\n                // update last index to indicate index of word to start new line from\\n                lastIndex = i;\\n            }\\n            // add word length to running length\\n            runningLength += s.length();             \\n            wordCount ++;\\n        }\\n        // last line\\n        if (runningLength > 0) {\\n            result.add(constructLine(words, lastIndex, wordCount, 1, 0, maxWidth));\\n        }\\n        return result;\\n    }\\n    \\n    private String constructLine(String[] words, int li, int n, int spw, int los, int maxWidth) {\\n        StringBuffer sb = new StringBuffer();\\n        // start appending words in the line\\n        for (int i = li; i < li + n - 1; i ++) {\\n            sb.append(words[i]);\\n            // append `space per word` spaces after each word, until last word\\n            for (int j = 0; j < spw; j++) {\\n                sb.append(\" \");\\n            }\\n            // append one space from `left over space` after each word, and decrement left over space\\n            sb.append(los-- > 0 ? \" \" : \"\");\\n        }\\n        // append last word\\n        sb.append(words[li + n - 1]);\\n        \\n        // this is specifically for situation when line length still not matches width, append spaces at the end\\n        // Two situation can lead to this:\\n        // 1. line only has one word, so we are not adding any space from above logic\\n        // 2. its last line, so  we are only adding one space per word\\n        if (sb.length() < maxWidth) {\\n            int diff = maxWidth - sb.length();\\n            while (diff-- > 0) {\\n                sb.append(\" \");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int wordCount = 0;\\n        int lastIndex = 0;\\n        int runningLength=0;\\n        List<String> result = new ArrayList<>();\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            /**\\n            * runningLength : total length of words until current word is added\\n            * s.length() : length of current word\\n            * wordCount : count of words till now (represents minimum spaces we would need with all the words already include)\\n            * Adding all of this tells us if current word can fit into current line\\n            *\\n            */\\n            if (runningLength + s.length() + wordCount > maxWidth) {\\n                //create a line since adding current word crosses the width\\n                int extraSpace = maxWidth - runningLength;\\n                // space per word, but not if wordCount is only 1                 \\n                int spw = wordCount > 1 ? extraSpace / (wordCount - 1) : 0;\\n                // left over spaces which need to be added 1 after each word until it last\\n                int los = wordCount > 1 ? extraSpace % (wordCount - 1) : 0;\\n                // construct line\\n                result.add(constructLine(words, lastIndex, wordCount, spw, los, maxWidth));\\n                // reset word count and running length\\n                wordCount = 0;\\n                runningLength = 0;\\n                // update last index to indicate index of word to start new line from\\n                lastIndex = i;\\n            }\\n            // add word length to running length\\n            runningLength += s.length();             \\n            wordCount ++;\\n        }\\n        // last line\\n        if (runningLength > 0) {\\n            result.add(constructLine(words, lastIndex, wordCount, 1, 0, maxWidth));\\n        }\\n        return result;\\n    }\\n    \\n    private String constructLine(String[] words, int li, int n, int spw, int los, int maxWidth) {\\n        StringBuffer sb = new StringBuffer();\\n        // start appending words in the line\\n        for (int i = li; i < li + n - 1; i ++) {\\n            sb.append(words[i]);\\n            // append `space per word` spaces after each word, until last word\\n            for (int j = 0; j < spw; j++) {\\n                sb.append(\" \");\\n            }\\n            // append one space from `left over space` after each word, and decrement left over space\\n            sb.append(los-- > 0 ? \" \" : \"\");\\n        }\\n        // append last word\\n        sb.append(words[li + n - 1]);\\n        \\n        // this is specifically for situation when line length still not matches width, append spaces at the end\\n        // Two situation can lead to this:\\n        // 1. line only has one word, so we are not adding any space from above logic\\n        // 2. its last line, so  we are only adding one space per word\\n        if (sb.length() < maxWidth) {\\n            int diff = maxWidth - sb.length();\\n            while (diff-- > 0) {\\n                sb.append(\" \");\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242044,
                "title": "easy-to-understand-java-solution-with-comments",
                "content": "Ask of the problem is to justify the words on each line. For the solution, we will try to place each word on the current line. We will try to fit as many words as we can on each line by trying to keep \"at least one space\" between each word.\\n\\nLogic is straightforward:\\n*  Iterate over each word and ask:\\n\\t*  Can this word \"fit\" on the current line?\\n\\t\\t*  If yes, add it to the sentence list, reduce the remaining characters\\n\\t\\t*  If no, Justify all the words added so far in the sentence and reiterate on this word so that it can be considered for next line\\n\\t\\t\\t*  If there\\'s only one word on this line, we leftJustify() it\\n\\t\\t\\t*  For more than one word, we fullJustify() them\\n*  How do we determine whether the current word will \"fit\" on the current line?\\n\\t*  By comparing the length of the current word with the remaining character count\\n\\t*  if the word.length() <= remaining, it fits\\n\\t*  In this case, remaining = remaining - (word.length()+1)\\n\\t*  Why + 1 ? Because there must be \"at least one space\" between this word and next word\\n*  What about the last line?\\n\\t*  In case of the last line, we will reach the end of the array and there will be still some words in the sentence list, we will simply call leftJustify()\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        //Stores num of words on each line in the output\\n        int numWords = 0;\\n        //Stores the sum of lengths of all the words on a line in the output - Doesn\\'t account for spaces\\n        int sum = 0;\\n        //Stores how many more characters are remaining on the current line of the output\\n        int remaining = maxWidth;\\n        //Stores all the words that will go on the current line of the output\\n        List<String> sentence = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++) {\\n            //Checks if the word can be chosen for current line\\n            if(words[i].length() <= remaining) {\\n                //If the word is chosen for current line, add it to sentence list\\n                sentence.add(words[i]);\\n                //Remaining = Remaining - size of the word + 1 character for space after it\\n                remaining -= (words[i].length()+1);\\n                //Increasing num of words on this line of the output\\n                numWords++;\\n                //sum = sum of length of all the words on current line + length of chosen word\\n                sum += words[i].length();\\n            }\\n            //If the word can\\'t fit on the current line, Justify the words of current line and\\n            //Iterate over this word again to consider it for next line\\n            else {\\n                //Checking if the line has more than 1 word\\n                if(numWords > 1) {\\n                    //space[] stores the number of space between each word\\n                    //Total number of spaces = maxWidth-sum\\n                    //Total number of slots for spaces = numWords - 1\\n                    //eg: \"Science is what we\" - numWords = 4, total slots for spaces = 4-1 = 3 (between each word)\\n                    int[] space = new int[numWords-1];\\n                    calcSpaces(space, maxWidth-sum);\\n                    res.add(fullJustify(sentence, space));\\n                } else {\\n                    res.add(leftJustify(sentence, maxWidth));\\n                }\\n                //Since the current word was not taken on current line, we need to reiterate on this word, therefore --i\\n                --i;\\n                //Reinitializing all the counters for next line\\n                sum = 0;\\n                numWords = 0;\\n                remaining = maxWidth;\\n                sentence = new ArrayList<>();\\n            }\\n        }\\n        //If the sentence still has words, then leftJustify the sentence\\n        //Eg: \"Leetcode is fun\", maxWidth = 20\\n        //All the words fit on same line, so leftJustify. This is also useful for last line of the output\\n        if(!sentence.isEmpty()) {\\n            res.add(leftJustify(sentence, maxWidth));\\n        }\\n        return res;\\n    }\\n    \\n    void calcSpaces(int[] space, int numSpace) {\\n        int n = space.length;\\n        Arrays.fill(space, numSpace/n);\\n        int remaining = numSpace%n;\\n        int i = 0;\\n        while(remaining > 0) {\\n            space[i]++;\\n            ++i;\\n            --remaining;\\n        }\\n    }\\n    \\n    String leftJustify(List<String> sentence, int maxWidth) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String w : sentence) {\\n            sb.append(w).append(\" \");\\n        }\\n        //In case the last character of the last word of the sentence occupy maxWidth, we don\\'t need that leading space, so removing it\\n        sb.deleteCharAt(sb.length()-1);\\n        //Padding with spaces to reach maxWidth\\n        while(sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    String fullJustify(List<String> sentence, int[] space) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < sentence.size()-1; i++) {\\n            sb.append(sentence.get(i));\\n            while(space[i] > 0) {\\n                sb.append(\" \");\\n                space[i]--;\\n            }\\n        }\\n        sb.append(sentence.get(sentence.size()-1));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList<>();\\n        //Stores num of words on each line in the output\\n        int numWords = 0;\\n        //Stores the sum of lengths of all the words on a line in the output - Doesn\\'t account for spaces\\n        int sum = 0;\\n        //Stores how many more characters are remaining on the current line of the output\\n        int remaining = maxWidth;\\n        //Stores all the words that will go on the current line of the output\\n        List<String> sentence = new ArrayList<>();\\n        for(int i = 0; i < words.length; i++) {\\n            //Checks if the word can be chosen for current line\\n            if(words[i].length() <= remaining) {\\n                //If the word is chosen for current line, add it to sentence list\\n                sentence.add(words[i]);\\n                //Remaining = Remaining - size of the word + 1 character for space after it\\n                remaining -= (words[i].length()+1);\\n                //Increasing num of words on this line of the output\\n                numWords++;\\n                //sum = sum of length of all the words on current line + length of chosen word\\n                sum += words[i].length();\\n            }\\n            //If the word can\\'t fit on the current line, Justify the words of current line and\\n            //Iterate over this word again to consider it for next line\\n            else {\\n                //Checking if the line has more than 1 word\\n                if(numWords > 1) {\\n                    //space[] stores the number of space between each word\\n                    //Total number of spaces = maxWidth-sum\\n                    //Total number of slots for spaces = numWords - 1\\n                    //eg: \"Science is what we\" - numWords = 4, total slots for spaces = 4-1 = 3 (between each word)\\n                    int[] space = new int[numWords-1];\\n                    calcSpaces(space, maxWidth-sum);\\n                    res.add(fullJustify(sentence, space));\\n                } else {\\n                    res.add(leftJustify(sentence, maxWidth));\\n                }\\n                //Since the current word was not taken on current line, we need to reiterate on this word, therefore --i\\n                --i;\\n                //Reinitializing all the counters for next line\\n                sum = 0;\\n                numWords = 0;\\n                remaining = maxWidth;\\n                sentence = new ArrayList<>();\\n            }\\n        }\\n        //If the sentence still has words, then leftJustify the sentence\\n        //Eg: \"Leetcode is fun\", maxWidth = 20\\n        //All the words fit on same line, so leftJustify. This is also useful for last line of the output\\n        if(!sentence.isEmpty()) {\\n            res.add(leftJustify(sentence, maxWidth));\\n        }\\n        return res;\\n    }\\n    \\n    void calcSpaces(int[] space, int numSpace) {\\n        int n = space.length;\\n        Arrays.fill(space, numSpace/n);\\n        int remaining = numSpace%n;\\n        int i = 0;\\n        while(remaining > 0) {\\n            space[i]++;\\n            ++i;\\n            --remaining;\\n        }\\n    }\\n    \\n    String leftJustify(List<String> sentence, int maxWidth) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String w : sentence) {\\n            sb.append(w).append(\" \");\\n        }\\n        //In case the last character of the last word of the sentence occupy maxWidth, we don\\'t need that leading space, so removing it\\n        sb.deleteCharAt(sb.length()-1);\\n        //Padding with spaces to reach maxWidth\\n        while(sb.length() < maxWidth) {\\n            sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    String fullJustify(List<String> sentence, int[] space) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < sentence.size()-1; i++) {\\n            sb.append(sentence.get(i));\\n            while(space[i] > 0) {\\n                sb.append(\" \");\\n                space[i]--;\\n            }\\n        }\\n        sb.append(sentence.get(sentence.size()-1));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228647,
                "title": "thinking-process-greedy-approach",
                "content": "**Insights from problem description:**\\n* Two types of line to form\\n\\t* Fully-Justified (all lines except last line)\\n\\t* Left-justified (last line)\\n\\n**For each fully justified line, we can form the line in greedy way**- \\n1. Include as many word as possible in the current line where consecuative words are separated by single space until current line length smaller than maxWidth\\n2. Add one more word in current line and If **currentLineLength == maxWidth**, current line fits in the maxWidth perfectly where consecuative words in current line are separated by single space. Add this line to final result. \\n3. Add one more word in current line and If **current Line Length exceeds maxWidth**, exclude last added word from the current line-\\n\\t1. Distribute remaining-width-to-fill number of space evenly among each space placeholder of current line. **Number of space placeholder in current line = number of word in current line - 1**\\n\\t2. Number of space in each space placeholder = **((maxWidth - currentLineLength) // ( Number of space placeholder in current line)) +1**\\n\\t3. If there are some width to fill up ( **(maxWidth - currentLineLength)% ( Number of space placeholder in current line)** ) which can not be distributed evenly among each space placeholder of current line, distribute it from leftmost space placeholder to rightmost space placeholder of current line\\n\\n**For the last line which is left-justified**, \\n1. Include all remaining words in the current line where consecuative words are sperated by single space\\n2. Add  **(maxWidth - currentLineLength)** number of space at the end of current line\\n\\n**Time Complexity**:\\nWe have to traverse the words list at most 2 times and for each word, we have to calculate corresponding word length. Thus, the time complexity will be **O(len(words) * maxWordLen)**.\\n\\n**Space Complexity**:\\nWe are not using any additional space except the list to store the final result. In the worst case, each word in the words list can form a  line. Thus, **O(len(words) * maxWidth)**.\\n\\n**Code**\\n```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] #final result\\n        currentLine = \\'\\'\\n        left = 0 # tracks first word in current line\\n        \\n        currentLineLength = 0\\n        remainingWidth = 0 \\n        \\n        firstWord = True\\n        wordsLen = len(words)\\n        \\n        for i in range(wordsLen):\\n            wordLen = len(words[i])  \\n            \\n            # First word of the current line\\n            if firstWord:\\n                firstWord = False\\n                currentLineLength = wordLen\\n                left = i\\n            \\n            # Adding words[i] and a single space in the current line exceeds the maxWidth, thus words[i] will not be included in current line\\n            elif currentLineLength + 1 + wordLen > maxWidth:\\n                #  wordCount = number of words in the current line\\n                wordCount = i - left\\n                \\n                # For all lines except last line, distribute remaining width evenly among the each space placeholder\\n                if wordCount > 1: \\n                    # Number of space in each space placeholder = (remaining place to fill // (number of space placeholder)) + 1 (single space counted in currentLineLength). This is evenly distributed space\\n                    # Number of space placeholder in the current line = wordCount - 1 \\n                    totalSpaceInEachPlaceHolder = ((maxWidth - currentLineLength) // (wordCount - 1)) + 1 \\n            \\n                    # remainingWidth number of space can not be distributed evenly\\n                    remainingWidth = (maxWidth - currentLineLength) % (wordCount - 1)\\n                    \\n                else:\\n                    # Current line contains single word, thus 0 space placeHolder\\n                    totalSpaceInEachPlaceHolder = 0\\n                    remainingWidth = maxWidth - currentLineLength\\n                    \\n                line = words[left]\\n                left += 1\\n                \\n                # Process the current line and add it to final result\\n                # For fully-justified lines(all lines except last line), we have to distribute remainingWidth number of space to the space placeholder from leftmost space placeholder of current line to right\\n                while left < i:\\n                    line += (\" \"* totalSpaceInEachPlaceHolder)\\n                    if remainingWidth > 0:\\n                        line += \" \"\\n                        remainingWidth -= 1\\n                    line += words[left]\\n                    left += 1\\n                    \\n                if remainingWidth > 0:\\n                    line += (\" \"* remainingWidth)\\n                if line:\\n                    lines.append(line)\\n                \\n                currentLineLength = wordLen\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] fits perfectly in the maxWidth. Start new line after processing this line\\n            elif currentLineLength + 1 + wordLen == maxWidth:\\n                lines.append(\" \".join(words[left:i+1]))\\n                firstWord = True\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] does not fill upto maxWidth. Add one space and current word to the current line\\n            else:\\n                currentLineLength += 1 + wordLen\\n        \\n        # All words are processed and no remaingwidth to fill with space\\n        if firstWord:\\n            return lines\\n        \\n        \\n        # Process the last line. \\n        # It is left-justified: Add single space between consecutive word and remainingWidth number of space at the end\\n        wordCount = wordsLen - left\\n        if wordCount > 1:\\n            totalSpaceInEachPlaceHolder =  1\\n        else:\\n            totalSpaceInEachPlaceHolder = 0\\n            \\n        remainingWidth = maxWidth - currentLineLength\\n        line = words[left]\\n        left += 1\\n\\n        # Add single space between consecutive word of last line\\n        while left < wordsLen:\\n            line += (\" \"* totalSpaceInEachPlaceHolder)\\n            line += words[left]\\n            left += 1\\n\\n        # Add remainingWidth number of space at the end of last line\\n        if remainingWidth > 0:\\n            line += (\" \"* remainingWidth)\\n        if line:\\n            lines.append(line)\\n            \\n        return lines\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\\n        lines = [] #final result\\n        currentLine = \\'\\'\\n        left = 0 # tracks first word in current line\\n        \\n        currentLineLength = 0\\n        remainingWidth = 0 \\n        \\n        firstWord = True\\n        wordsLen = len(words)\\n        \\n        for i in range(wordsLen):\\n            wordLen = len(words[i])  \\n            \\n            # First word of the current line\\n            if firstWord:\\n                firstWord = False\\n                currentLineLength = wordLen\\n                left = i\\n            \\n            # Adding words[i] and a single space in the current line exceeds the maxWidth, thus words[i] will not be included in current line\\n            elif currentLineLength + 1 + wordLen > maxWidth:\\n                #  wordCount = number of words in the current line\\n                wordCount = i - left\\n                \\n                # For all lines except last line, distribute remaining width evenly among the each space placeholder\\n                if wordCount > 1: \\n                    # Number of space in each space placeholder = (remaining place to fill // (number of space placeholder)) + 1 (single space counted in currentLineLength). This is evenly distributed space\\n                    # Number of space placeholder in the current line = wordCount - 1 \\n                    totalSpaceInEachPlaceHolder = ((maxWidth - currentLineLength) // (wordCount - 1)) + 1 \\n            \\n                    # remainingWidth number of space can not be distributed evenly\\n                    remainingWidth = (maxWidth - currentLineLength) % (wordCount - 1)\\n                    \\n                else:\\n                    # Current line contains single word, thus 0 space placeHolder\\n                    totalSpaceInEachPlaceHolder = 0\\n                    remainingWidth = maxWidth - currentLineLength\\n                    \\n                line = words[left]\\n                left += 1\\n                \\n                # Process the current line and add it to final result\\n                # For fully-justified lines(all lines except last line), we have to distribute remainingWidth number of space to the space placeholder from leftmost space placeholder of current line to right\\n                while left < i:\\n                    line += (\" \"* totalSpaceInEachPlaceHolder)\\n                    if remainingWidth > 0:\\n                        line += \" \"\\n                        remainingWidth -= 1\\n                    line += words[left]\\n                    left += 1\\n                    \\n                if remainingWidth > 0:\\n                    line += (\" \"* remainingWidth)\\n                if line:\\n                    lines.append(line)\\n                \\n                currentLineLength = wordLen\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] fits perfectly in the maxWidth. Start new line after processing this line\\n            elif currentLineLength + 1 + wordLen == maxWidth:\\n                lines.append(\" \".join(words[left:i+1]))\\n                firstWord = True\\n                \\n            # Current line containing words[left], words[left+1], ..., words[i] does not fill upto maxWidth. Add one space and current word to the current line\\n            else:\\n                currentLineLength += 1 + wordLen\\n        \\n        # All words are processed and no remaingwidth to fill with space\\n        if firstWord:\\n            return lines\\n        \\n        \\n        # Process the last line. \\n        # It is left-justified: Add single space between consecutive word and remainingWidth number of space at the end\\n        wordCount = wordsLen - left\\n        if wordCount > 1:\\n            totalSpaceInEachPlaceHolder =  1\\n        else:\\n            totalSpaceInEachPlaceHolder = 0\\n            \\n        remainingWidth = maxWidth - currentLineLength\\n        line = words[left]\\n        left += 1\\n\\n        # Add single space between consecutive word of last line\\n        while left < wordsLen:\\n            line += (\" \"* totalSpaceInEachPlaceHolder)\\n            line += words[left]\\n            left += 1\\n\\n        # Add remainingWidth number of space at the end of last line\\n        if remainingWidth > 0:\\n            line += (\" \"* remainingWidth)\\n        if line:\\n            lines.append(line)\\n            \\n        return lines\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1160268,
                "title": "python-solution-easy-to-understand",
                "content": "Got this question in an interview then worked on my solution to get it to work! Not as complicated once I understood the problem! Split the problem into first how to parse the string and decide what goes into a line, then how to actually add the spaces. Then I do the last line seperately since it\\'s dealt with differently! \\n\\n\\t output_string = []\\n        \\n        #figure out how many can fit in a line (less than the width)\\n        curr_word_pos = 0 \\n        curr_width = 0\\n        curr_line = []\\n\\n        while curr_word_pos < len(words):\\n\\n            curr_word = words[curr_word_pos]\\n\\n            #if curr word can fit (without space b/c might be last word in line), then add to curr_line list and move position to next word\\n            if (curr_width+len(curr_word)) <= maxWidth: \\n                \\n                                  \\n                curr_line.append(curr_word)\\n                \\n                curr_width+=len(curr_word) + 1\\n                \\n                curr_word_pos +=1\\n                \\n            \\n            #no space left, process current words into line\\n            else: \\n\\n                #process the line, add spaces, \\n                spaces = maxWidth - curr_width + len(curr_line)\\n                \\n                #go through all left over spaces and add behind each word that isn\\'t the last one\\n                added = 0\\n                pos = 0\\n            \\n                while (added < spaces):\\n\\n                    #avoid last word\\n                    if pos >= len(curr_line)-1:\\n                        pos = 0\\n                        \\n                    curr_line[pos] += \" \"\\n                    added +=1\\n                    pos+=1\\n                    \\n                #building a string of the curr line and appending to output array\\n                output_string.append(\"\".join(curr_line))\\n                    \\n                #reset these for the next line \\n                curr_line = []\\n                curr_width  = 0\\n           \\n        \\n        #add each word with normal number of spaces for last line\\n        for word in range(len(curr_line)-1):\\n\\n            curr_line[word] +=\" \"\\n        \\n        #add all extra spaces to last line\\n        curr_line[-1]+=(maxWidth-curr_width+1)*\" \"\\n                \\n        output_string.append(\"\".join(curr_line))\\n            \\n        return output_string",
                "solutionTags": [
                    "Python"
                ],
                "code": "Got this question in an interview then worked on my solution to get it to work! Not as complicated once I understood the problem! Split the problem into first how to parse the string and decide what goes into a line, then how to actually add the spaces. Then I do the last line seperately since it\\'s dealt with differently! \\n\\n\\t output_string = []\\n        \\n        #figure out how many can fit in a line (less than the width)\\n        curr_word_pos = 0 \\n        curr_width = 0\\n        curr_line = []\\n\\n        while curr_word_pos < len(words):\\n\\n            curr_word = words[curr_word_pos]\\n\\n            #if curr word can fit (without space b/c might be last word in line), then add to curr_line list and move position to next word\\n            if (curr_width+len(curr_word)) <= maxWidth: \\n                \\n                                  \\n                curr_line.append(curr_word)\\n                \\n                curr_width+=len(curr_word) + 1\\n                \\n                curr_word_pos +=1\\n                \\n            \\n            #no space left, process current words into line\\n            else: \\n\\n                #process the line, add spaces, \\n                spaces = maxWidth - curr_width + len(curr_line)\\n                \\n                #go through all left over spaces and add behind each word that isn\\'t the last one\\n                added = 0\\n                pos = 0\\n            \\n                while (added < spaces):\\n\\n                    #avoid last word\\n                    if pos >= len(curr_line)-1:\\n                        pos = 0\\n                        \\n                    curr_line[pos] += \" \"\\n                    added +=1\\n                    pos+=1\\n                    \\n                #building a string of the curr line and appending to output array\\n                output_string.append(\"\".join(curr_line))\\n                    \\n                #reset these for the next line \\n                curr_line = []\\n                curr_width  = 0\\n           \\n        \\n        #add each word with normal number of spaces for last line\\n        for word in range(len(curr_line)-1):\\n\\n            curr_line[word] +=\" \"\\n        \\n        #add all extra spaces to last line\\n        curr_line[-1]+=(maxWidth-curr_width+1)*\" \"\\n                \\n        output_string.append(\"\".join(curr_line))\\n            \\n        return output_string",
                "codeTag": "Unknown"
            },
            {
                "id": 1126418,
                "title": "javascript-easy-to-understand-99-4",
                "content": "![image](https://assets.leetcode.com/users/images/3ec3ac94-a3bd-46bc-8c48-5a3668d3877c_1616683285.730853.png)\\n\\n```\\nvar fullJustify = function(words, maxWidth) {\\n    let currentLine = \\'\\', lines = [];\\n\\t//Group words into lines.\\n    for (const word of words) {\\n        if (!currentLine.length) currentLine += word;\\n        else if (word.length + 1 + currentLine.length <= maxWidth) currentLine += \\' \\' + word\\n        else {\\n            lines.push(currentLine);\\n            currentLine = word\\n        }\\n    }\\n    lines.push(currentLine)\\n    for (let i = 0; i < lines.length; i++) {\\n\\t\\t//Handle Last Line\\n        if (i === lines.length - 1) {\\n            lines[i] = lines[i] + \\' \\'.repeat(maxWidth - lines[i].length)\\n        } else {\\n            currentLine = lines[i];\\n            const lineLen = lines[i].replace(/[ ]/g, \\'\\').length;\\n\\t\\t\\t//Below handles if line only has one word. currLine.length - lineLen gives # of spaces on line.\\n            //If they are ===, then line has no spaces.  \\n            if (currentLine.length === lineLen) {\\n                currentLine = currentLine + \\' \\'.repeat(maxWidth - lineLen)\\n            } else {\\n                //This block handles regular lines with spaces.  Replace all spaces with biggest\\n\\t\\t\\t\\t//necessary space, then remove from right to left until lineWidth === maxWidth.\\n                //RepeatSpaces is the size of the largest space in the line.\\n                const repeatSpaces = Math.ceil((maxWidth - lineLen) / (lines[i].length - lineLen));\\n                currentLine = currentLine.replace(/[ ]/g, \\' \\'.repeat(repeatSpaces));\\n                while (currentLine.length > maxWidth) {\\n                    let spacePos = currentLine.lastIndexOf(\\' \\'.repeat(repeatSpaces));\\n                    currentLine = currentLine.substring(0, spacePos) + currentLine.substring(spacePos + 1)\\n                }\\n            }\\n            lines[i] = currentLine\\n        }\\n    }\\n    return lines\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let currentLine = \\'\\', lines = [];\\n\\t//Group words into lines.\\n    for (const word of words) {\\n        if (!currentLine.length) currentLine += word;\\n        else if (word.length + 1 + currentLine.length <= maxWidth) currentLine += \\' \\' + word\\n        else {\\n            lines.push(currentLine);\\n            currentLine = word\\n        }\\n    }\\n    lines.push(currentLine)\\n    for (let i = 0; i < lines.length; i++) {\\n\\t\\t//Handle Last Line\\n        if (i === lines.length - 1) {\\n            lines[i] = lines[i] + \\' \\'.repeat(maxWidth - lines[i].length)\\n        } else {\\n            currentLine = lines[i];\\n            const lineLen = lines[i].replace(/[ ]/g, \\'\\').length;\\n\\t\\t\\t//Below handles if line only has one word. currLine.length - lineLen gives # of spaces on line.\\n            //If they are ===, then line has no spaces.  \\n            if (currentLine.length === lineLen) {\\n                currentLine = currentLine + \\' \\'.repeat(maxWidth - lineLen)\\n            } else {\\n                //This block handles regular lines with spaces.  Replace all spaces with biggest\\n\\t\\t\\t\\t//necessary space, then remove from right to left until lineWidth === maxWidth.\\n                //RepeatSpaces is the size of the largest space in the line.\\n                const repeatSpaces = Math.ceil((maxWidth - lineLen) / (lines[i].length - lineLen));\\n                currentLine = currentLine.replace(/[ ]/g, \\' \\'.repeat(repeatSpaces));\\n                while (currentLine.length > maxWidth) {\\n                    let spacePos = currentLine.lastIndexOf(\\' \\'.repeat(repeatSpaces));\\n                    currentLine = currentLine.substring(0, spacePos) + currentLine.substring(spacePos + 1)\\n                }\\n            }\\n            lines[i] = currentLine\\n        }\\n    }\\n    return lines\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059497,
                "title": "javascript-solution-iterative-98-48-faster-76-06-less-memory-usage",
                "content": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar fullJustify = function(words, maxWidth) {\\n    let result = [];\\n    \\n    let line = [];\\n    let lineLength = 0;\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        let w = words[i];\\n        \\n        if(lineLength === 0 && w.length <= maxWidth) {\\n\\t\\t\\t// Note: We add first word assuming no space will be added after it. As we know this is not the case. \\n\\t\\t\\t//       The space for first word will be accounted for by our last word in the line & \\n\\t\\t\\t//       the lack of space after last word is accounted for by this first word.\\n            line.push(w);\\n            lineLength += w.length;\\n        } else if(lineLength + w.length + 1 <= maxWidth){\\n\\t\\t\\t// we add word and consider it\\'s length plus a space following it\\n            line.push(w);\\n            lineLength += (w.length + 1);\\n        } else {\\n\\t\\t\\t//OUR LINE IS FULL AND SHOULD BE ADDED TO THE RESULT\\n\\t\\t\\t\\n            // add the required single space after each word except last one\\n            line = addMinSpace(line);\\n            \\n            // find remaining space to distribute\\n            let remainingSpace = maxWidth - lineLength;\\n            \\n            // add remaining space to each word expect last one\\n            line = distributeSpaces(line, remainingSpace);\\n\\n            // turn array into a single string\\n            let temp = line.join(\"\")\\n            \\n            // If the line only had one large word, we add remaining spaces to it\\'s end just like how we would later do for last line\\n            if(line.length === 1) temp = addRemainingSpaces(temp, remainingSpace)\\n            \\n            result.push(temp);\\n            \\n            // reset the line and it\\'s length\\n            line = [];\\n            lineLength = 0;\\n            \\n            // add this new word like it\\'s the first one\\n            line.push(w);\\n            lineLength += w.length;\\n        }\\n    }\\n    \\n    \\n    // pad our final line\\n    line = addMinSpace(line);\\n    \\n    // create final string\\n    let temp = line.join(\"\")\\n    \\n    // find remaining padding \\n    let remainingSpace = maxWidth - lineLength;\\n    \\n    // add remaining padding to end of our final line\\n    temp = addRemainingSpaces(temp, remainingSpace)\\n    \\n    // add final line to result\\n    result.push(temp);\\n \\n    // return result\\n    return result;\\n    \\n\\t// Adds single space after each word except last one\\n    function addMinSpace(line) {\\n        for(let i = 0; i < line.length - 1; i++) line[i] += \" \";\\n        return line;\\n    }\\n    \\n\\t// add remaining spaces to end of line\\n    function addRemainingSpaces(line, spaces) {\\n        while(spaces > 0) {\\n            line += \" \";\\n            spaces--;\\n        }\\n        return line;\\n    }\\n    \\n\\t// distribute remaining spaces from left to right\\n    function distributeSpaces(arr, spaces) {\\n        while(spaces > 0 && arr.length > 1) {\\n           for(let i = 0; i < arr.length - 1; i++) {\\n                if(spaces <= 0) break;\\n                arr[i] = arr[i] + \" \";\\n                spaces --;\\n            } \\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907092,
                "title": "java-1ms-fast-solution-explained",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n        METHOD:\\n        1. We need to check where the words length exceeds the maxWidth. When that happens, we need to add it to the result.\\n        2. During adding spaces, there are 2 allignments to consider:\\n            a. Left justify: (use in last line, or the lines where there is only one word) In this, the spaces will be at the end of the list\\n            b. Middle justify: in this, the spaces will be equally distributed in between the words. If there are any extra spaces, \\n            those will be added from left to right.\\n            Eg: if there are 3 words and 5 spaces\\n            word1_ _ _word2_ _word3\\n\\n\\n```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n                /*\\n        */\\n        List<String> result= new ArrayList<>();  \\n        //We need to traverse the list to see upto where the words can be added\\n        int i=0; \\n        while(i<words.length){\\n            int j= i+1;\\n            //Initially the linelength just has the length of the word at position i\\n            int linelength= words[i].length();\\n            //Here, j+i-1 is the minimum spaces required between the words\\n            while(j<words.length && (linelength+words[j].length()+(j-i-1)<maxWidth)){\\n                linelength+= words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth-linelength;\\n            int numberOfWords=j-i;\\n            //Checking for the left justify case\\n            if(numberOfWords==1 || j >= words.length) result.add(leftJustify(words, diff,i,j));\\n            else result.add(middleJustify(words, diff,i,j));    \\n\\n            i=j;\\n        }\\n        return result;\\n    }\\n\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        //Groups of spaces we need (equal to number of words-1)\\n        int groupSpaces= j-i-1;\\n        //Spaces minimum after every word\\n        int space= diff/groupSpaces;\\n        //The extra spaces left which would be added from the left to right\\n        int extraSpace= diff%groupSpaces;\\n        \\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //The spaces required after every word \\n            int spacesApply= space+(extraSpace-- >0 ? 1:0);\\n            str.append(\" \".repeat(spacesApply)+words[k]);\\n        }\\n        return str.toString();\\n    }\\n\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        //number of spaces which are going to be at the end\\n        int rightSpaces= diff-(j-i-1);\\n        //Initially add the string at position i\\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //Adding 1 space after the word\\n            str.append(\" \"+words[k]);\\n        }\\n        //Add the extra spaces in the end\\n        str.append(\" \".repeat(rightSpaces));\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n                /*\\n        */\\n        List<String> result= new ArrayList<>();  \\n        //We need to traverse the list to see upto where the words can be added\\n        int i=0; \\n        while(i<words.length){\\n            int j= i+1;\\n            //Initially the linelength just has the length of the word at position i\\n            int linelength= words[i].length();\\n            //Here, j+i-1 is the minimum spaces required between the words\\n            while(j<words.length && (linelength+words[j].length()+(j-i-1)<maxWidth)){\\n                linelength+= words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth-linelength;\\n            int numberOfWords=j-i;\\n            //Checking for the left justify case\\n            if(numberOfWords==1 || j >= words.length) result.add(leftJustify(words, diff,i,j));\\n            else result.add(middleJustify(words, diff,i,j));    \\n\\n            i=j;\\n        }\\n        return result;\\n    }\\n\\n    private String middleJustify(String[] words, int diff, int i, int j) {\\n        //Groups of spaces we need (equal to number of words-1)\\n        int groupSpaces= j-i-1;\\n        //Spaces minimum after every word\\n        int space= diff/groupSpaces;\\n        //The extra spaces left which would be added from the left to right\\n        int extraSpace= diff%groupSpaces;\\n        \\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //The spaces required after every word \\n            int spacesApply= space+(extraSpace-- >0 ? 1:0);\\n            str.append(\" \".repeat(spacesApply)+words[k]);\\n        }\\n        return str.toString();\\n    }\\n\\n    private String leftJustify(String[] words, int diff, int i, int j) {\\n        //number of spaces which are going to be at the end\\n        int rightSpaces= diff-(j-i-1);\\n        //Initially add the string at position i\\n        StringBuilder str= new StringBuilder(words[i]);\\n        for(int k=i+1; k<j; k++){\\n            //Adding 1 space after the word\\n            str.append(\" \"+words[k]);\\n        }\\n        //Add the extra spaces in the end\\n        str.append(\" \".repeat(rightSpaces));\\n        return str.toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833996,
                "title": "easy-explanation-with-algorithm-and-code-c",
                "content": "The question seems quite difficult,but when u understand its simple. Basically u have to fit as many words as possible in single line with even spacing between them,if a word dosen\\'t fit it will go to next line.\\nRefernce Example:\\n```\\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\\nmaxWidth = 16\\n```\\n1. To make this possible we have to do a greedy approach,fit as many words in a line with single space between words, we take single space because if we have words whose toatl length is equal to maxWidth then we cant add spaces and will look like \"thisisanexample\".\\n In above example we can fit \"this,is,an\",if we try to fit \"example\" it will exceed maxWidth. So we know first line consits of \"this\",\"is\",\"an\".\\nFor this line we have to add spaces evenly between words until it reaches maxWidth.\\nSo for `\"This\",\"is\",\"an\"` should be a string `\"This     is    an\"` which has length == maxWidth.\\n3. Now we know how we can justify a line ,we need to form these lines\\n\\nAlgorithm\\n```\\nresult=[]                //To store the justified lines\\ncur_line=[]             //this is store the words in current line\\nnum_of_letters=0       // number of letters in current line  \\nIterate each word in input:\\n\\tcheck if we add word to cur_line exceeds maxWidth:\\n\\t\\tif it exceeds : \\n\\t\\t\\tadd spaces evenly to current line and add it result\\n\\t\\t\\tSince we are done with cur_line we empty it and set num_of_letters to 0\\n\\t\\tadd the word to cur_line                          //if the word exceeds maxWidth this word will be added to a newline beacuse we reset cur_line in previous step\\n\\t\\tadd num_of_letters with length of word\\nafter iterating all words check if cur_line is empty      // we add line to result only when it exceeds maxWidth,but when we finish all words some words might be left in cur_line\\nif not empty :\\n\\tadd spaces and add to result \\n\\nreturn result\\n```\\nNow u know approach try it, if u get stuck continue reading\\n* **Formula to check whether word will fit in cur_line** : `num_of_letters+len(word) + len(cur_line) > maxWidth`\\n\\tKeep in mind len(cur_line) is number of words in cur_line,so if there are two words it translates to single spaces between words after adding third word.\\n\\tUnderstand above statement properly,u are doing this in greedy approach words should have atleast a single space between them.\\n\\tEx: \\n\\t`cur_line=\"this\",is\",\"an\"` and  word to be added `\"example\"` then condition will be\\n\\tnum_of_letters=8, len(word)=len(\"example\")=7,len(cur_line)=3 so 8+3+7>16 so we break the line and add \"example\" to next Line.\\n\\t\"this is an example\" >16 (adding example will make line>maxWidth)\\n*  **How to justify a line** :To do that we need to find number of spaces to insert so it reaches maxWidth, so `maxWidth - num_of_letters (in cur_line) ` gives it.\\nSay we have 4 words (u have to fill 3 spots ) and 5 spaces to add to reach maxWidth,we need to distribute evenly from left to right according to question, so (2,2,1) will be spacing between them.(Think of adding 5 stones to 3 containers from left to right one at a time ,at end how many stones are in each container?)\\ndivide the number of spaces to add by (num of words -1) .\\nThe Qutioent is space to be added between words.\\nThe remainder is extra spaces we need to distribute from left to right one at a time (Think of stones 5/3=1 , 5%3=2 so first two containers will have extra one stone (1+1, 1+1, 1).\\nTo make it simple u are adding spaces in Round robin fashion,just to do it in one step we divide and use qutieont and remainder.\\n**A corner case while justifying is what if that line has only word then we need to add empty spaces until it reaches maxWidth**\\nWhile justifying last line a single space between words is enough with last word appended with spaces to cover maxWidth. (Last line should be left justified according to Problem)\\n\\n\\n\\nCode in C++\\n```\\nstring fillSpaces(vector<string> line,int num_letters, int maxWidth){\\n        string res;\\n        int spaces_to_add=maxWidth-num_letters;\\n        int between_space=spaces_to_add/(line.size()-1);\\n        int extra_spaces=spaces_to_add%(line.size()-1);\\n        for(int i=0;i<line.size()-1;i++){\\n            res+=line[i] + string(between_space,\\' \\')+ string(extra_spaces?1:0,\\' \\');\\n            if(extra_spaces>0) extra_spaces--;\\n        }\\n        res+=line.back();\\n        \\n        return res;\\n    }\\n    \\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> line;\\n        int cur_letters = 0;\\n        for(auto word:words){\\n            if(cur_letters + word.length() + line.size() > maxWidth){   \\n                if(line.size()==1){\\n                    res.push_back(line[0]+string(maxWidth-cur_letters,\\' \\'));  //corner case\\n                }\\n                else\\n                   res.push_back(fillSpaces(line,cur_letters,maxWidth)); \\n                cur_letters=0;\\n                line.clear();\\n                \\n            }\\n            line.push_back(word);\\n            cur_letters+=word.length();\\n        }      \\n        string last;      //For the last line Left Justification\\n        for(int i=0;i<line.size()-1;i++){\\n            last+=line[i]+\" \";\\n            \\n        }\\n        last+=line.back()+string(maxWidth-(cur_letters+line.size()-1),\\' \\');\\n        res.push_back(last);\\n        return res;\\n        \\n    }\\n```\\nDo a Dry run ,u will get to know.\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nwords = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\\nmaxWidth = 16\\n```\n```\\nresult=[]                //To store the justified lines\\ncur_line=[]             //this is store the words in current line\\nnum_of_letters=0       // number of letters in current line  \\nIterate each word in input:\\n\\tcheck if we add word to cur_line exceeds maxWidth:\\n\\t\\tif it exceeds : \\n\\t\\t\\tadd spaces evenly to current line and add it result\\n\\t\\t\\tSince we are done with cur_line we empty it and set num_of_letters to 0\\n\\t\\tadd the word to cur_line                          //if the word exceeds maxWidth this word will be added to a newline beacuse we reset cur_line in previous step\\n\\t\\tadd num_of_letters with length of word\\nafter iterating all words check if cur_line is empty      // we add line to result only when it exceeds maxWidth,but when we finish all words some words might be left in cur_line\\nif not empty :\\n\\tadd spaces and add to result \\n\\nreturn result\\n```\n```\\nstring fillSpaces(vector<string> line,int num_letters, int maxWidth){\\n        string res;\\n        int spaces_to_add=maxWidth-num_letters;\\n        int between_space=spaces_to_add/(line.size()-1);\\n        int extra_spaces=spaces_to_add%(line.size()-1);\\n        for(int i=0;i<line.size()-1;i++){\\n            res+=line[i] + string(between_space,\\' \\')+ string(extra_spaces?1:0,\\' \\');\\n            if(extra_spaces>0) extra_spaces--;\\n        }\\n        res+=line.back();\\n        \\n        return res;\\n    }\\n    \\n    \\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> res;\\n        vector<string> line;\\n        int cur_letters = 0;\\n        for(auto word:words){\\n            if(cur_letters + word.length() + line.size() > maxWidth){   \\n                if(line.size()==1){\\n                    res.push_back(line[0]+string(maxWidth-cur_letters,\\' \\'));  //corner case\\n                }\\n                else\\n                   res.push_back(fillSpaces(line,cur_letters,maxWidth)); \\n                cur_letters=0;\\n                line.clear();\\n                \\n            }\\n            line.push_back(word);\\n            cur_letters+=word.length();\\n        }      \\n        string last;      //For the last line Left Justification\\n        for(int i=0;i<line.size()-1;i++){\\n            last+=line[i]+\" \";\\n            \\n        }\\n        last+=line.back()+string(maxWidth-(cur_letters+line.size()-1),\\' \\');\\n        res.push_back(last);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821052,
                "title": "thanks-to-michael-for-step-by-step-explanation-code-added-c-java",
                "content": "[Awesome Expalantion](https://youtu.be/GqXlEbFVTXY)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int i= 0;\\n        int n= words.size();\\n        vector<string> result;\\n        while(i<n){\\n            int j= i+1;\\n            int lineLength= words[i].length();\\n            \\n            while(j < n && (lineLength + words[j].length() + (j-i-1))  < maxWidth){\\n                lineLength= lineLength + words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth - lineLength;\\n            int numberOfwords= j-i;\\n            //Chcek if the line needs to be left justified o r not\\n            if(numberOfwords == 1  ||  j>=n){ \\n                result.push_back(leftJustify(words, diff, i, j));\\n            }else{\\n                result.push_back(middleJustify(words, diff, i, j));\\n            }\\n            \\n            i = j;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string middleJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        result = words[i];\\n        int sections= j-i-1;\\n        int spaces= diff/sections;\\n        int extraSpaces= diff % sections;\\n        for(int k= i+1; k<j; ++k){\\n            int spacesToApply= spaces + (extraSpaces-- > 0? 1:0);\\n            while(spacesToApply){\\n                result= result + \" \";\\n                spacesToApply--;\\n            }\\n            result= result + words[k];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string leftJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        int spacesInRight= diff - (j-i-1);\\n        result = words[i];\\n        for(int k= i+1; k<j; ++k){\\n            result += \" \" + words[k];\\n        }\\n        while(spacesInRight>0){\\n            result= result + \" \";\\n            spacesInRight--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int i= 0;\\n        int n= words.size();\\n        vector<string> result;\\n        while(i<n){\\n            int j= i+1;\\n            int lineLength= words[i].length();\\n            \\n            while(j < n && (lineLength + words[j].length() + (j-i-1))  < maxWidth){\\n                lineLength= lineLength + words[j].length();\\n                j++;\\n            }\\n            \\n            int diff= maxWidth - lineLength;\\n            int numberOfwords= j-i;\\n            //Chcek if the line needs to be left justified o r not\\n            if(numberOfwords == 1  ||  j>=n){ \\n                result.push_back(leftJustify(words, diff, i, j));\\n            }else{\\n                result.push_back(middleJustify(words, diff, i, j));\\n            }\\n            \\n            i = j;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string middleJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        result = words[i];\\n        int sections= j-i-1;\\n        int spaces= diff/sections;\\n        int extraSpaces= diff % sections;\\n        for(int k= i+1; k<j; ++k){\\n            int spacesToApply= spaces + (extraSpaces-- > 0? 1:0);\\n            while(spacesToApply){\\n                result= result + \" \";\\n                spacesToApply--;\\n            }\\n            result= result + words[k];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    string leftJustify(vector<string>& words, int diff, int i, int j){\\n        string result;\\n        int spacesInRight= diff - (j-i-1);\\n        result = words[i];\\n        for(int k= i+1; k<j; ++k){\\n            result += \" \" + words[k];\\n        }\\n        while(spacesInRight>0){\\n            result= result + \" \";\\n            spacesInRight--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756745,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int n = words.length;\\n        List<String> result = new ArrayList<>();\\n        int left = 0;\\n        while(left < n) {\\n            int right = findRight(left, words, maxWidth);\\n            String str = justify(left, right, words, maxWidth);\\n            result.add(str); //add the justified line to result\\n            left = right + 1; // we have justified the words till left.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //return the right index till which the words can fit on current line\\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right].length();\\n        int n = words.length;\\n        right++;\\n        while(right < n && (sum + 1 + words[right].length()) <= maxWidth) {\\n            sum += 1 + words[right].length(); // add space and new word\\n            right++;\\n        }\\n        \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        int n = words.length;\\n        \\n        //if only one word\\n        if (left == right) {\\n            return words[left] + blanks(maxWidth - words[left].length());\\n        }\\n        \\n        if (isLastLine(right, n)) {\\n            String line = getLine(left, right, words);\\n            return line + blanks(maxWidth - line.length());\\n        }\\n        \\n        int len = getLineLength(left, right, words);\\n        int gaps = right - left;\\n        int spaces = maxWidth - len;\\n        String fixedSpace = blanks(spaces / gaps);\\n        int odd = 0;\\n        if (spaces % gaps != 0) {\\n            odd = spaces % gaps;\\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(fixedSpace);\\n            if (odd > 0) {\\n                sb.append(\" \");\\n                odd--;\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n        \\n    \\n    private String getLine(int left, int right, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n    \\n    private int getLineLength(int left, int right, String[] words) {\\n        int len = 0;\\n        for (int i = left; i <= right; i++) {\\n            len += words[i].length();\\n        }\\n        return len;\\n    }\\n\\n    \\n    \\n    private String blanks(int length) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < length; i++) {\\n            sb.append(\\' \\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n    private boolean isLastLine(int index, int n) {\\n        return index == n-1;\\n    }\\n}\\n\\n/*\\nLoop over the words array.\\nkeep on adding the words to current line until the width is less than max\\nCount the number of spaces required bw words.\\nEvenly append the spaces between each word. so n-1 places for spaces.\\nMake the current line string and add it to the sol\\nIn case all the words fit in one line and there are no more words, left justify\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        \\n        int n = words.length;\\n        List<String> result = new ArrayList<>();\\n        int left = 0;\\n        while(left < n) {\\n            int right = findRight(left, words, maxWidth);\\n            String str = justify(left, right, words, maxWidth);\\n            result.add(str); //add the justified line to result\\n            left = right + 1; // we have justified the words till left.\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //return the right index till which the words can fit on current line\\n    private int findRight(int left, String[] words, int maxWidth) {\\n        int right = left;\\n        int sum = words[right].length();\\n        int n = words.length;\\n        right++;\\n        while(right < n && (sum + 1 + words[right].length()) <= maxWidth) {\\n            sum += 1 + words[right].length(); // add space and new word\\n            right++;\\n        }\\n        \\n        return right - 1;\\n    }\\n    \\n    private String justify(int left, int right, String[] words, int maxWidth) {\\n        int n = words.length;\\n        \\n        //if only one word\\n        if (left == right) {\\n            return words[left] + blanks(maxWidth - words[left].length());\\n        }\\n        \\n        if (isLastLine(right, n)) {\\n            String line = getLine(left, right, words);\\n            return line + blanks(maxWidth - line.length());\\n        }\\n        \\n        int len = getLineLength(left, right, words);\\n        int gaps = right - left;\\n        int spaces = maxWidth - len;\\n        String fixedSpace = blanks(spaces / gaps);\\n        int odd = 0;\\n        if (spaces % gaps != 0) {\\n            odd = spaces % gaps;\\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(fixedSpace);\\n            if (odd > 0) {\\n                sb.append(\" \");\\n                odd--;\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n        \\n    \\n    private String getLine(int left, int right, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = left; i <= right; i++) {\\n            sb.append(words[i]).append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n    \\n    private int getLineLength(int left, int right, String[] words) {\\n        int len = 0;\\n        for (int i = left; i <= right; i++) {\\n            len += words[i].length();\\n        }\\n        return len;\\n    }\\n\\n    \\n    \\n    private String blanks(int length) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < length; i++) {\\n            sb.append(\\' \\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n    private boolean isLastLine(int index, int n) {\\n        return index == n-1;\\n    }\\n}\\n\\n/*\\nLoop over the words array.\\nkeep on adding the words to current line until the width is less than max\\nCount the number of spaces required bw words.\\nEvenly append the spaces between each word. so n-1 places for spaces.\\nMake the current line string and add it to the sol\\nIn case all the words fit in one line and there are no more words, left justify\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534511,
                "title": "my-ac-c-codes-with-comments",
                "content": "Although it is a bit long, time and space complexity beat 100% C++ submission.\\nI think it is very straight forward with the help of comments.\\n\\nWithout comments:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0;\\n        vector<string> res{};\\n        string cur = \"\"; \\n        while (i < n) {\\n            int l = i;\\n            int sum = 0;\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else {\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                cur += words[i - 1];\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n \\nWith comments:\\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0; // index goes through the words vector\\n        vector<string> res{}; // return results\\n        string cur = \"\"; // string of each result row \\n        while (i < n) {\\n            int l = i; // l is the leftmost index of each row\\n            int sum = 0;\\n            // through this while loop, I wnat to find the end index of each row\\n            // for example, for row \"This    is    an\", after the wihle loop the \\n            // index will be 3\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            // if i == n, it is the last row, we need only one space between each word\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                // add the last word of each row and add the remain space to the end\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else { // if i != n\\n                // count counts if the spaces do not divide evenly, then we need to count\\n                // number of remainder words to add one more space than others\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    // for example, \"This    is    an\"\\n                    // maxWidth == 16;\\n                    // sum == (5 + 3 + 3 = 11); each word has one more white space to be counted\\n                    // i == 3;\\n                    // l == 0;\\n                    // then (maxWidth - sum + i - l) == (16 - 11 + 3 - 0 = 8) how many white spaces\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    // those words that need one more space than others\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                // add the last word of each row\\n                cur += words[i - 1];\\n                // in case of only one word in a row like \"acknowledgment  \"\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                // reset cur\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0;\\n        vector<string> res{};\\n        string cur = \"\"; \\n        while (i < n) {\\n            int l = i;\\n            int sum = 0;\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else {\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                cur += words[i - 1];\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        int n = words.size();\\n        int i = 0; // index goes through the words vector\\n        vector<string> res{}; // return results\\n        string cur = \"\"; // string of each result row \\n        while (i < n) {\\n            int l = i; // l is the leftmost index of each row\\n            int sum = 0;\\n            // through this while loop, I wnat to find the end index of each row\\n            // for example, for row \"This    is    an\", after the wihle loop the \\n            // index will be 3\\n            while (i < n && sum + words[i].size() <= maxWidth) {\\n                sum += words[i].size() + 1;\\n                ++i;\\n            }\\n            // if i == n, it is the last row, we need only one space between each word\\n            if (i == n) {\\n                for (int j = l; j < i - 1; ++j) {\\n                    cur += words[j] + \\' \\';\\n                }\\n                // add the last word of each row and add the remain space to the end\\n                cur += words[n - 1] + string(maxWidth - sum + 1, \\' \\');\\n                res.push_back(cur);\\n            } else { // if i != n\\n                // count counts if the spaces do not divide evenly, then we need to count\\n                // number of remainder words to add one more space than others\\n                int count = 0;\\n                for (int j = l; j < i - 1; ++j) {\\n                    // for example, \"This    is    an\"\\n                    // maxWidth == 16;\\n                    // sum == (5 + 3 + 3 = 11); each word has one more white space to be counted\\n                    // i == 3;\\n                    // l == 0;\\n                    // then (maxWidth - sum + i - l) == (16 - 11 + 3 - 0 = 8) how many white spaces\\n                    int remainder = (maxWidth - sum + i - l) % (i - l - 1);\\n                    int quotient = (maxWidth - sum + i - l) / (i - l - 1);\\n                    // those words that need one more space than others\\n                    if (count < remainder) {\\n                        cur += words[j] + string(quotient + 1, \\' \\');\\n                        ++count;\\n                    } else {\\n                        cur += words[j] + string(quotient, \\' \\');\\n                    }\\n                }\\n                // add the last word of each row\\n                cur += words[i - 1];\\n                // in case of only one word in a row like \"acknowledgment  \"\\n                cur += string(maxWidth - cur.size(), \\' \\');\\n                res.push_back(cur);\\n                // reset cur\\n                cur = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529464,
                "title": "java-modularized-suitable-for-an-interview",
                "content": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList();\\n        int lo = 0;\\n        while (lo < words.length) { // while we still have next line\\n            int hi = nextHiIndex(words, lo, maxWidth);\\n            formatLine(words, lo, hi, maxWidth, res);\\n            lo = hi;\\n        }\\n        return res;\\n    }\\n    \\n    private int nextHiIndex(String[] words, int lo, int maxWidth) {\\n        int hi = lo;\\n        // while next word could fit in\\n        while (hi < words.length && words[hi].length() <= maxWidth) {\\n            maxWidth -= words[hi].length(); // reduce word len\\n            maxWidth--; // reduce one space\\n            hi++;\\n        }\\n        return hi;\\n    }\\n    \\n    private void formatLine(String[] words, int lo, int hi, int maxWidth, List<String> res) {\\n        // compute signals needed for format\\n        List<String> wordsList = Arrays.asList(words).subList(lo, hi);\\n        int size = hi - lo;\\n        boolean isLastLine = (hi == words.length);\\n        boolean isSingleWordLine = (size == 1);\\n        // format\\n        if (isSingleWordLine || isLastLine) {\\n            // \"%-30s\"\\n            res.add(String.format(\"%-\" + maxWidth + \"s\", String.join(\" \", wordsList)));\\n        } else {\\n            StringBuilder sb = new StringBuilder();\\n            int wordsLen  = wordsList.stream().map(w -> w.length()).reduce(0, (a, b) -> a + b);\\n            int spacesLen = maxWidth - wordsLen;\\n            int avgSpaces = spacesLen / (size - 1);\\n            int extraSpaces = spacesLen % (size - 1);\\n            for (int i = lo; i < hi; i++) {\\n                sb.append(words[i] + String.format(\"%\" + avgSpaces + \"s\", \"\"));\\n                if (extraSpaces-- > 0) sb.append(\" \");\\n            }\\n            res.add(sb.toString().trim());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> fullJustify(String[] words, int maxWidth) {\\n        List<String> res = new ArrayList();\\n        int lo = 0;\\n        while (lo < words.length) { // while we still have next line\\n            int hi = nextHiIndex(words, lo, maxWidth);\\n            formatLine(words, lo, hi, maxWidth, res);\\n            lo = hi;\\n        }\\n        return res;\\n    }\\n    \\n    private int nextHiIndex(String[] words, int lo, int maxWidth) {\\n        int hi = lo;\\n        // while next word could fit in\\n        while (hi < words.length && words[hi].length() <= maxWidth) {\\n            maxWidth -= words[hi].length(); // reduce word len\\n            maxWidth--; // reduce one space\\n            hi++;\\n        }\\n        return hi;\\n    }\\n    \\n    private void formatLine(String[] words, int lo, int hi, int maxWidth, List<String> res) {\\n        // compute signals needed for format\\n        List<String> wordsList = Arrays.asList(words).subList(lo, hi);\\n        int size = hi - lo;\\n        boolean isLastLine = (hi == words.length);\\n        boolean isSingleWordLine = (size == 1);\\n        // format\\n        if (isSingleWordLine || isLastLine) {\\n            // \"%-30s\"\\n            res.add(String.format(\"%-\" + maxWidth + \"s\", String.join(\" \", wordsList)));\\n        } else {\\n            StringBuilder sb = new StringBuilder();\\n            int wordsLen  = wordsList.stream().map(w -> w.length()).reduce(0, (a, b) -> a + b);\\n            int spacesLen = maxWidth - wordsLen;\\n            int avgSpaces = spacesLen / (size - 1);\\n            int extraSpaces = spacesLen % (size - 1);\\n            for (int i = lo; i < hi; i++) {\\n                sb.append(words[i] + String.format(\"%\" + avgSpaces + \"s\", \"\"));\\n                if (extraSpaces-- > 0) sb.append(\" \");\\n            }\\n            res.add(sb.toString().trim());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491150,
                "title": "o-n-solution-using-queue",
                "content": "```\\n/*\\n * add the queue if words not exceed the maxWidth. if exceed the maxWidth we pop all out to form the string\\n * when we reach the end we handle the special case \\n * see comments below on the conditions applied.\\n */\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        int curr = 0;\\n        Queue<String> queue = new LinkedList<>();\\n        List<String> res =new ArrayList<>();\\n        int size = 0;\\n        int space = 0;\\n        int extraleft = 0;\\n        \\n        for(int i=0; i<words.length; i++){\\n            size = queue.size();\\n            //if the current string addition plus the single space in between is still with in the maxWidth\\n            //the queue size here can be used to represent the single space between each word including the \\n            //addition of the words[i]\\n            if(curr + words[i].length() + size <= maxWidth){\\n                queue.offer(words[i]);\\n                curr+=words[i].length();\\n            }else{\\n            \\t//calculating the base space in between \\n                space = size == 1? maxWidth-curr : (maxWidth-curr)/(size-1);\\n                //if not even, I grab the reminder as the space to distribute across the words in queue starting from beginning \\n                //one at a time\\n                //of course special case handle if the current queue has only one word. all spaces added from left to right\\n                extraleft = size == 1? 0 : (maxWidth-curr)%(size-1);\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    //dont add the spaces to the last word\\n                    if(sb.length() < maxWidth){ \\n                        for(int j=0; j<space; j++) sb.append(\" \");\\n                        //now we add the extra space calculated above one per word from the starting until the extraleft reaches 0\\n                        if(extraleft-- > 0) sb.append(\" \");\\n                    }\\n                }\\n                //adding the builded string and reset curr and queue\\n                res.add(sb.toString());\\n                curr = words[i].length();\\n                queue.offer(words[i]);\\n            }\\n            \\n            //when i reaches the last word we build the last row as the special case\\n            if(i == words.length-1){\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    if(!queue.isEmpty()) sb.append(\" \");\\n                }\\n                while(sb.length() < maxWidth){\\n                    sb.append(\" \");\\n                }\\n                   res.add(sb.toString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * add the queue if words not exceed the maxWidth. if exceed the maxWidth we pop all out to form the string\\n * when we reach the end we handle the special case \\n * see comments below on the conditions applied.\\n */\\n public List<String> fullJustify(String[] words, int maxWidth) {\\n        int curr = 0;\\n        Queue<String> queue = new LinkedList<>();\\n        List<String> res =new ArrayList<>();\\n        int size = 0;\\n        int space = 0;\\n        int extraleft = 0;\\n        \\n        for(int i=0; i<words.length; i++){\\n            size = queue.size();\\n            //if the current string addition plus the single space in between is still with in the maxWidth\\n            //the queue size here can be used to represent the single space between each word including the \\n            //addition of the words[i]\\n            if(curr + words[i].length() + size <= maxWidth){\\n                queue.offer(words[i]);\\n                curr+=words[i].length();\\n            }else{\\n            \\t//calculating the base space in between \\n                space = size == 1? maxWidth-curr : (maxWidth-curr)/(size-1);\\n                //if not even, I grab the reminder as the space to distribute across the words in queue starting from beginning \\n                //one at a time\\n                //of course special case handle if the current queue has only one word. all spaces added from left to right\\n                extraleft = size == 1? 0 : (maxWidth-curr)%(size-1);\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    //dont add the spaces to the last word\\n                    if(sb.length() < maxWidth){ \\n                        for(int j=0; j<space; j++) sb.append(\" \");\\n                        //now we add the extra space calculated above one per word from the starting until the extraleft reaches 0\\n                        if(extraleft-- > 0) sb.append(\" \");\\n                    }\\n                }\\n                //adding the builded string and reset curr and queue\\n                res.add(sb.toString());\\n                curr = words[i].length();\\n                queue.offer(words[i]);\\n            }\\n            \\n            //when i reaches the last word we build the last row as the special case\\n            if(i == words.length-1){\\n                StringBuilder sb = new StringBuilder();\\n                while(!queue.isEmpty()){\\n                    sb.append(queue.poll());\\n                    if(!queue.isEmpty()) sb.append(\" \");\\n                }\\n                while(sb.length() < maxWidth){\\n                    sb.append(\" \");\\n                }\\n                   res.add(sb.toString());\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2027769,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1564657,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1848509,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1568133,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027716,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1565739,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567183,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2028196,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1717407,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567836,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027769,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1564657,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1848509,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1568133,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027716,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1565739,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567183,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2028196,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1717407,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 1567836,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "First let me justify my Life :("
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "graham2181",
                        "content": "In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. \\n\\nAs far as I understand the \"idea\" of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. \\n\\nIn this question's description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. \\n\\nDo you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Why are there so many downvotes? Is it because the question is easier than its label?\\nOtherwise, I find it somewhat interesting. There\\'s not much thinking involved, ok, it\\'s mostly just carefully writing code following a very simple logic, but I feel that reflects what 99% of actual coding is. So, a bit different from other problems but not uninteresting to me"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Yeah, I quite enjoyed this problem. I never complain about a hard that is on the easier side, and solving this problem was a good amount of work, but nice, relaxing non stresfull work. "
                    },
                    {
                        "username": "niralittle",
                        "content": "Is it because you need to carefully design your code? this does not seem to be a hard something to figure out, don\\'t even have to use a specific algorithm. Why \\'hard\\'?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "It should be medium at most"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "It doesn\\'t require any special algorithms or data structures, but it combines several basic techniques with regards to handling different edge cases."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Yeah it\\'s an easy question"
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes lots of edge cases basically."
                    },
                    {
                        "username": "anwendeng",
                        "content": "this question is marked as hard, very annoying for debugging until to get right answer \n```\n[\"My\",\"momma\",\"always\",\"said,\",\"\"Life\",\"was\",\"like\",\"a\",\"box\",\"of\",\"chocolates.\",\"You\",\"never\",\"know\",\"what\",\"you're\",\"gonna\",\"get.\"]\n20\n```\nAnalyze for this testcase\n```\n|My    momma   always| numWords=3 numSpaces=3 remainingSpaces=1\n|said, \"Life was like| numWords=4 numSpaces=1 remainingSpaces=0\n|a box of chocolates.| numWords=4 numSpaces=1 remainingSpaces=0\n|You  never know what| numWords=4 numSpaces=1 remainingSpaces=1\n|you're gonna get.   | no need for extra space\n```"
                    },
                    {
                        "username": "unters",
                        "content": "Thanks for the testcase, but it is recognized by a testing system as an invalid one. I guess, that's  because of extra double quotes in `\"\"Life\"`."
                    },
                    {
                        "username": "chaman",
                        "content": "Input:\\t[\"\"], 2<br/>\\nOutput:\\t[\"\"]<br/>\\nExpected:\\t[\"  \"]<br/>\\nAs described ,the last line of text should be left justified and no extra space is inserted between words.Can anyone explain this?"
                    },
                    {
                        "username": "jerryy147",
                        "content": "has this been changed? in the notes it says that array words has at least 1 word"
                    },
                    {
                        "username": "cgsv",
                        "content": "Just read more words until it exceeds the maxWidth and justify them."
                    },
                    {
                        "username": "user5490Gj",
                        "content": "exactly, but very annoying to debug"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Dudes, this is clearly not that easy. Although the logic is simple it still feels good to solve it. And the problem itself is practical and interesting. I\\'d upvote it."
                    },
                    {
                        "username": "likeabbas",
                        "content": "IMO this is a medium question "
                    },
                    {
                        "username": "skhan75",
                        "content": "I think easy"
                    },
                    {
                        "username": "akelux",
                        "content": "    Input:\\t[\"What\",\"must\",\"be\",\"shall\",\"be.\"], 12\\n    MyOutput:\\t[\"What must be\",\"shall    be.\"] \\n    Expected:\\t[\"What must be\",\"shall be.   \"]\\n\\n\\n**(I think my output is expected according to the spec)**"
                    },
                    {
                        "username": "arynmi02",
                        "content": "Bro the last line should be left justified not fully justifies"
                    },
                    {
                        "username": "user4969X",
                        "content": "The expected result is in accordance with the problem statement.\\n\\n> For the last line of text, it should be left-justified, and no extra space is inserted between words."
                    }
                ]
            },
            {
                "id": 2027997,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027824,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1576360,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1568889,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1567184,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 1571160,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2028958,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2028293,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027872,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027795,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "the most humane hard ever"
                    },
                    {
                        "username": "ZongyuWu",
                        "content": "This question is not worth my time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I hear that"
                    },
                    {
                        "username": "Aussie24",
                        "content": "This is at most a medium level question."
                    },
                    {
                        "username": "Joy4fun",
                        "content": "For the test case:\\n\\nInput:\\n[\"a\",\"b\",\"c\",\"d\"]\\n3\\nOutput:\\n[\"a b\",\"c d\"]\\n\\nThe output is generated by all those accepted solutions described here.\\n\\nI think it violates the following description:\\n\\nFor the **last line of text**, it should be left justified and **no extra space is inserted between words**. \\n\\nWe notes that t**he last line \"c d\" has a space inserted!**\\n\\nIf the last line means the last line of input, what do you mean by **no extra space is inserted between words** , given that every line of input String[] words has only one word?    \\n\\nWhat's the right answer for this test case?"
                    },
                    {
                        "username": "chaosxlive",
                        "content": "In the very last line, between words it should still insert a space to split each word. EXTRA SPACE means justify that contains more than 1 space between words."
                    },
                    {
                        "username": "newborn",
                        "content": "guess the assumption is this scenario won't happen?"
                    },
                    {
                        "username": "codemyway",
                        "content": "For the text justification, I noticed one test case is like: \\n\\nInput: \\n[\"a\"]\\n2\\n\\nExpected output: \\n[\"a \"]\\n\\nHowever, in the original question, it says \"For the last line of text, it should be left justified and no extra space is inserted between words\", which means the last line is a special one - it does not need to be exactly the said length (that's what left justified means). I think the answer should simply be [\"a\"]. \\n\\nComments?\\nThanks."
                    },
                    {
                        "username": "2nishantthakur",
                        "content": "The last line is supposed to be left justified, however the width of every line should be equal to the maxWidth. So you got to add blank spaces in the end to make the length of each line equal to maxWidth."
                    },
                    {
                        "username": "neil_paul",
                        "content": "I think that ought to be right. Maybe gotta hard-code for that test case."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I have no idea what this has to do with programming. \\n\\nThis doesn\\'t even require to use specific algos or to implement interesting logic, just a for loop with tracking that needs some time to solve. That\\'s all. \\n\\nIn real life, you can easily do this task just with decomposition, however, as you don\\'t want to lose a lot of time on leetcode, you can\\'t afford writting modular code.\\n\\nMeh, it\\'s not worth your time."
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeap, couldn\\'t agree more."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode: my way or hard way. Too much fun "
                    },
                    {
                        "username": "andykimchris",
                        "content": "I haven\\'t solved this question yet, but the many downvotes are making me a skeptic. What\\'s frustrating about this problem? On the surface it doesn\\'t sound too hard."
                    },
                    {
                        "username": "asmithey",
                        "content": "[@wafsinc](/wafsinc) A well thought out solution should be able to solve all edge cases without any errors during the first submission. So in a way, developing a clean solution that accounts for all edge cases makes the problem more interesting then it appears on the surface."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I Think maybe the problem was updated in the last year or so with new testcases as part of the description. I\\'m not sure, but this was a very nice problem to solve. It isn\\'t really hard but takes some work. "
                    },
                    {
                        "username": "codelixir",
                        "content": "It\\'s really not, if you read the problem carefully."
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@wafsinc](/wafsinc) Yeah I noticed that once I attempted it. Useless problem"
                    },
                    {
                        "username": "wafsinc",
                        "content": "It\\'s not. It is just boring, annoying, and lonnnnng with a million edge cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Was avoiding this problem, till today \\uD83E\\uDEE3"
                    }
                ]
            },
            {
                "id": 2027755,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1721898,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571161,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571162,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571164,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571167,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1888329,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1570416,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 2027770,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571163,
                "content": [
                    {
                        "username": "kylecrowley",
                        "content": "I loathe when people say \"this wasn't hard\" (especially when they haven't even solved the problem yet), but I actually have to agree here. This problem is fairly doable, but is **incredibly** tedious.\n\nI don't think my solution is very good (very brute force), but it passed. Still, I needed to go through multiple rounds of debugging to get a working solution."
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Why TF they want an extra space to be put after the last word on the last line? This is stupid. No real-life editor adds an extra space at the end!"
                    },
                    {
                        "username": "Samba",
                        "content": "Input \\n\\n[\"Here\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"]\\n14\\n\\nExpected output is : \\n\\n[ 'Here   is   an',  = (4 addl. spaces)\\n  'example     of', = (4 addl. spaces)\\n  'text          ',      =  (9 addl. spaces)\\n  'justification.' ]  =  (0 addl. spaces)\\n\\nA more optimal output is as below because the additional spaces are properly  distributed\\nacross lines \\n\\n[ 'Here   is   an',  (4 addl. spaces)\\n  'example       ',  (6 addl. spaces)\\n  'of        text',     (7 addl. spaces)\\n  'justification.' ]  (0 addl. spaces)   \\n\\nI have  used dynamic programming to solve the minimize badness across lines where badness is defined as follows = \\n     (line width - space occupied by words ) ^3 \\n     Infinity if a given range of words does not fit the line\\n\\nDid anyone else hit the same issue ?"
                    },
                    {
                        "username": "hamilton",
                        "content": "Input:\\n[\"What\",\"must\",\"be\",\"shall\",\"be.\"]\\n12\\nOutput:\\n[\"What must be\",\"shall(4 spaces)be.\"]\\nExpected:\\n[\"What must be\",\"shall be.(3 spaces)\"]\\n\\nI feel my output is the desired one than the expected solution."
                    },
                    {
                        "username": "neil_paul",
                        "content": "The last line does shouldn\\'t be justified. Spaces should be inserted just to separate words, but none extra to justify the text to maxWidth."
                    },
                    {
                        "username": "weimamarvin",
                        "content": "![0_1477400317114_Screen Shot 2016-10-25 at 14.56.07.png](/uploads/files/1477400318618-screen-shot-2016-10-25-at-14.56.07.png) \\nI find a solution that looks brilliant in the discussion. I tried it but get the result as the figure 1. I think according to \"If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\". it should be that the spaces between \"a\" and \"b\" should be more and b is in the end. \\n![0_1477400474699_Screen Shot 2016-10-25 at 14.56.22.png](/uploads/files/1477400475794-screen-shot-2016-10-25-at-14.56.22.png) \\n Figure 2 shows the case in the description of the problem. In the result set, the second line \"example  of  text\" put two space between \"example\" and \"of\" and one space between \"of\" and \"text\"."
                    },
                    {
                        "username": "turbocv",
                        "content": "For any two words, there is at least one space between them.\\nThis is true for any lines, including the last line."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "![image](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgvqeBYXFzg0VYFOTvZHXFbthRt0cpcET9D0VQ45E0UJy-88L5Z4TxRkHRFLbiorNwsndDD-NGr6Oy3w4ob0RwjthZr24qXcJGFDfJeEPOrZwb1Q-Qpk0gZZyEd_HzEbl6d_5KsyPgjMBySGgd3CQewh0bZ3fRknyMIZLp5XGLvaveb8hkzJ2CvTYM3/s1051/Screenshot%202023-05-09%20at%208.21.16%20PM.png)\n\n# Can anyone show me the difference here?\nEven the differentiator can't find it out."
                    },
                    {
                        "username": "tomekb",
                        "content": "spaces on the first line"
                    },
                    {
                        "username": "sannu2613",
                        "content": "https://whitegreyhorse.wordpress.com/2021/04/24/68-text-justification/"
                    },
                    {
                        "username": "calvinle360",
                        "content": "Wasn\\'t that hard"
                    },
                    {
                        "username": "ayuanx",
                        "content": "<pre>Run Code Result:\\nYour input\\n[\"\", \"\", \"\", \"\",\"a\"]\\n4\\n\\nYour answer\\n[\"a   \"]\\n\\nExpected answer\\n[\"    \",\"a   \"]</pre>"
                    },
                    {
                        "username": "Bardamusi",
                        "content": "[@codelixir](/codelixir) They no longer allow empty words I think, so presumably the question changed over time"
                    },
                    {
                        "username": "codelixir",
                        "content": "This is because there should be at least one space between any two \"words\"."
                    }
                ]
            },
            {
                "id": 1571166,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2069885,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2037564,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2036310,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2030690,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2029117,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028898,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028892,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028874,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028814,
                "content": [
                    {
                        "username": "zhao.chen.758",
                        "content": "There are multiple possibilities for input array that contains any amount of space like \"\", \"  \", \"    \"; also it may even include other kind of white spaces such as a tab '\\\\t' or '\\\\r'\\nThe problem does not specified if we treat those \"words\" the same way as valid phrases or we simply get rid of them. This brings significant difference in implementation."
                    },
                    {
                        "username": "samueljuliup",
                        "content": "good question imo,\\nstraight forward, no tricks\\na bit long though, hopefully I don\\'t face this one in an interview"
                    },
                    {
                        "username": "lovely08",
                        "content": "I think it is not easy one lots of edge cases are there and many inbuilt string operations have been used which was unknown to me earlier."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "Is this the most hated problem on leetcode?"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "[@andykimchris](/andykimchris) Its a great question. Its actually a real world problem unlike the countless made up DP/sliding window problems."
                    },
                    {
                        "username": "andykimchris",
                        "content": "I think there\\'s one with 7k dislikes, but it\\'s certainly up there."
                    },
                    {
                        "username": "anuraxx",
                        "content": "For this input\\n[\"a\",\"b\",\"c\"] maxWidth =4\\n\\nExpected\\n[\"a  b\",\"c   \"]\\n\\nMy o/p:\\n[\"a   \", \"b   \", \"c   \"]\\n\\nwhy my o/p is wrong, why can\\'t have I take one word for each line ?"
                    },
                    {
                        "username": "andykimchris",
                        "content": "The maxWidth dictates the length of your justified strings. It\\'s 4 here, which means every string should have at most that maxWidth. Your output has \"a \" as first string. That\\'s only length of 2. It\\'s still possible to update the string since there\\'s extra space. Which makes sense why expected is the result it is. "
                    },
                    {
                        "username": "HaoTLee",
                        "content": "It\\'d apparently not a hard question because there is no data structure or algorithm, just straightforward brute force. There are only two edge cases to deal with. Even most mediums are harder than this one. However, this question is quite annoying and time-consuming.  I don\\'t think I can solve it in a 30-45mins interview. "
                    },
                    {
                        "username": "andykimchris",
                        "content": "Yeah I second that, there\\'s no point in solving this, I only did it for the monthly streak :)"
                    },
                    {
                        "username": "SG-C",
                        "content": "ok this is too hard for me !"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Your C++ compiler is broken, it \"swallows\" extra spaces\\n\\n```cpp\\n  std::string s1(4, \\' \\');  // \" \"\\n  std::string s2(4, \\'=\\');  // \"====\"\\n```"
                    },
                    {
                        "username": "user2418K",
                        "content": "If I can solve it, then it\\'s not hard :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "It was a long question.."
                    }
                ]
            },
            {
                "id": 2028481,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028372,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028302,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028285,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028223,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028206,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028175,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028152,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028123,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028121,
                "content": [
                    {
                        "username": "arturyeganyan42",
                        "content": "A question: what times are good to solve this problem. I needed for mine an hour because I had some debugging to do. So I am asking myself, what times would mean a good engineer, mediocre, FAANG level and so on.. Thanks"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Simulation + string in leetcode is an absolute nightmare.\nsomehow I mange to get out of it\nAnd let's talk about the *pointlessness* level here. Seriously, it's off the charts  I'd rather debate a *pineapple's place on a pizza*! I swear, if I see this question again, I might just start communicating exclusively in emojis and Morse code.\nNever gonna see this question again(too pointless)\nThat's why there is more dislikes than likes"
                    },
                    {
                        "username": "codez93",
                        "content": "Medium"
                    },
                    {
                        "username": "quan_mai",
                        "content": "I was like: Okay let\\'s try prefix sum\\n5 mins later: direct to the Editorial tab lol"
                    },
                    {
                        "username": "Nibaron_RUET",
                        "content": "C++ Code from the Editorial--\\n```\\nclass Solution {\\nprivate:\\n    vector<string> getWords(int i, vector<string>& words, int maxWidth) {\\n        vector<string> currentLine;\\n        int currLength = 0;\\n\\n        while (i < words.size() && currLength + words[i].size() <= maxWidth) \\n        {\\n            currentLine.push_back(words[i]);\\n            currLength += words[i].size() + 1;\\n            i++;\\n        }\\n\\n        return currentLine;\\n    }\\n    \\n    string createLine(vector<string>& line, int i, vector<string>& words, int maxWidth, bool isLastLine) {\\n        int baseLength = 0; // Initialize with 0, not -1\\n        for (string& word : line) {\\n            baseLength += word.size();\\n        }\\n\\n        int extraSpaces = maxWidth - baseLength;\\n\\n        if (line.size() == 1 || i == words.size() || isLastLine) {\\n            return joinWordsWithSpaces(line, extraSpaces, true);\\n        }\\n\\n        int wordCount = line.size() - 1;\\n        int spacesPerWord = extraSpaces / wordCount;\\n        int needsExtraSpace = extraSpaces % wordCount;\\n\\n        for (int j = 0; j < needsExtraSpace; j++) {\\n            line[j] += \" \";\\n        }\\n\\n        for (int j = 0; j < wordCount; j++) {\\n            line[j] += string(spacesPerWord, \\' \\');\\n        }\\n\\n        return joinWordsWithSpaces(line, 0, false);\\n    }\\n    \\n    string joinWordsWithSpaces(vector<string>& words, int extraSpaces, bool isLastLine) {\\n        string result = words[0];\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isLastLine) {\\n                result += \" \"; // Add a single space between words in the last line\\n                extraSpaces--;\\n            } else {\\n                result += string(extraSpaces > 0 ? 1 : 0, \\' \\');\\n                if (extraSpaces > 0) {\\n                    extraSpaces--;\\n                }\\n            }\\n            result += words[i];\\n        }\\n        return result + string(extraSpaces, \\' \\');\\n    }\\npublic:\\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\\n        vector<string> ans;\\n        int i = 0;\\n        \\n        while (i < words.size()) \\n        {\\n            vector<string> currentLine = getWords(i, words, maxWidth);\\n            i += currentLine.size();\\n            bool isLastLine = (i == words.size());\\n            ans.push_back(createLine(currentLine, i, words, maxWidth, isLastLine));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lsfhv",
                        "content": "Easy but takes some time to implement "
                    },
                    {
                        "username": "DavidLindon",
                        "content": "I\\'m think this is a great question and can\\'t understand the number of downvotes. Its nice to see a real world problem rather than the same variations on DP problems."
                    },
                    {
                        "username": "nkrishk",
                        "content": "I usually struggle with hard problem. This one i was able to solve in few mins..\\uD83D\\uDE32. \\nThough this problem is good one, difficulty level is <= medium."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "The question feels hard to me and description of the problem statement is not clear"
                    },
                    {
                        "username": "swnsma",
                        "content": "The \"Hard\" part of this question is number of conditions you need to follow.\\nOverall, problem is pretty straightforward: try to collect as much words as possible for each row (don\\'t forget about at least one space between words!) and then start adding missing spaces to meet maxWidth. Exceptions are only rows with one word and the last row (in these cases, extra spaces should be added only after word(s))\\n    "
                    }
                ]
            },
            {
                "id": 2028119,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028081,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028041,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2028030,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027904,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027898,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027847,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027797,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027792,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027783,
                "content": [
                    {
                        "username": "kaushikosu",
                        "content": "The test cases do not guarantee an even distribution of spaces across the lines\n\nAccepted solution:\n```\nbadness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currBadness:\n                        badness = currBadness\n                        pi[index] = i + 1\n```\nWhat the solution should be:\n ```  \n badness = math.inf\n            for i in range(index, len(words)):\n                totalSize += len(words[i])\n                if i > index and totalSize + (i - index) > maxWidth:\n                    break\n                else:\n                    currBadness = (maxWidth - (totalSize + (i-index)))**2\n                    currTotalBadness = currBadness + self.calculateMinBadness(i+1, words, maxWidth, pi, memo)\n                    if badness >= currTotalBadness:\n                        badness = currTotalBadness\n                        pi[index] = i + 1\n```"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "The Problem Statement is a bit off  and there is nothing fancy I suppose just writing a lot of code and debugging, it should be medium imo, but looking at the positives a lot of companies ask these kind of long questions which requires a lot of debugging so not a worthless question overall, I recommend not skipping it.  "
                    },
                    {
                        "username": "sandeep_pasula",
                        "content": "Consider, there should be atleast 1 space between any 2 words in a text and think of greedy approach.\\n\\nIf interested, check my solutions in c++ and python.\\n[Python Solution](https://leetcode.com/problems/text-justification/solutions/3953174/greedy-solution-python/)\\n\\n[C++ Solution](https://leetcode.com/problems/text-justification/solutions/3953208/greedy-c/)"
                    },
                    {
                        "username": "bhati25",
                        "content": "<strong>Seems a bit difficult to figure out at  first glance.</strong>"
                    },
                    {
                        "username": "Sukhwindersingh0007",
                        "content": "Alrgt ! this is hard\\n"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "This question is mediumish (with lots of debugging and edge cases).\nI wrote a 100 line solution (full of if and else conditions).\nRecommended to solve :)\nMy Solution:\nhttps://leetcode.com/problems/text-justification/solutions/3952664/beats-100-in-speed/"
                    },
                    {
                        "username": "iloabachie",
                        "content": "This is a real head scratcher"
                    },
                    {
                        "username": "ProtoDot",
                        "content": "compiler decided that words can\\'t be subscripted for some reason. neat."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Felt like was doing office work, no application of algorithm, but writing modular code.\\nJust follow what the question asks, write functions to avoid rework."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am tired"
                    }
                ]
            },
            {
                "id": 2027726,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027709,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027702,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2027694,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 2016549,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1967098,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1955090,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1754120,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1734806,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            },
            {
                "id": 1575777,
                "content": [
                    {
                        "username": "Cocamo1337",
                        "content": "To get the number of spaces (excluding the special case for last line) you need to:\\n1. Get the number of words on the line.\\n2. Total number of spaces will be maxWidth minus the combined length of words on the line. \\n3. We will set numWords as the number of words on the line minus 1.\\n4. For each word, if numSpaces / numWords does not evenly divide into a whole number, then we will append (numSpaces / numWords) + 1  spaces where numSpaces and numWords are both integers (they wont store decimal values). After adding the spaces we subtract that same amount from numSpaces and decrement numWords by 1.\\n5. Alternatively if numSpaces / numWords does actually divide evenly, then it\\'s easy and we can just append that number of spaces (numSpaces / numWords), subtract that value from numSpaces, and decrement numWords by 1."
                    },
                    {
                        "username": "shahinul",
                        "content": "midweek madness?"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "Logic is easy to figure out but a little difficult to type it out \\uD83D\\uDE10"
                    },
                    {
                        "username": "dnox",
                        "content": "ughh... painful but doable"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "The question taught me nothing\\nA senseless question"
                    },
                    {
                        "username": "jwlv",
                        "content": "Nothing in the problem statement indicates what should be returned via the returnSize integer pointer when implementing with C.  Looks like it should be the number of lines but the problem statement should be thorough about stating the requirements."
                    },
                    {
                        "username": "YaBhiThikHai",
                        "content": "if we have maxWidth = 9 and \\nwords = [\"a\",\"b\",\"c\",\"d\", \"asdfghjkl\"]\\nthen we have ans as \\n[\"a  b  c d\",\\n\"asdfghjkl\"]\\n#### Note:\\n- spacing in first item is 2,2,1 not 3,1,1\\n- we have to provide spacing in decreasing order with minimum difference in constitutive spacing\\n- space must 1 less then number of elements"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the result array and the current line in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the words once to build up the lines of text.\\n\\nTherefore, this solution is efficient in terms of both space and time complexity."
                    },
                    {
                        "username": "lusitian1995",
                        "content": "Am I missing anything here? This seems to be a standard simulation problem. No specific algorithm or complex data structure involved. Yes, there are edge cases but not like something impossible to come up with."
                    }
                ]
            }
        ]
    },
    {
        "title": "Excel Sheet Column Title",
        "question_content": "<p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 28\n<strong>Output:</strong> &quot;AB&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 701\n<strong>Output:</strong> &quot;ZY&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnNumber &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 441430,
                "title": "detailed-explanation-here-s-why-we-need-n-at-first-of-every-loop-java-python-c",
                "content": "The problem originates from here:\\nIt is a 26-nary system, but without the \\'0\\'.\\nA typical 26-nary system would be:\\n```\\n0 -> A\\n25 -> Z\\n26 -> BA\\n```\\nHowever, the excel system actually behaves differently:\\n```\\n1 -> A\\n26 -> Z\\n27 -> AA\\n```\\nYou could think it for a while and then get the idea why this excel system is actually behaving quite strangly. It is like in a number system in which after 9 it is 00 instead of 10; or like a system without zero: starting with 1, 2.. and after 9 it is 11. \\nAlthough the code is quite short and simple, I DO think it is hard to fully understand how this system behaves.\\n\\n\\nNow, how to solve it:\\n\\nEquation relationships will help us through the process, and It it not very difficult to derive them. With equations we can understand how to get the n-1 at first of the loop.\\nThe relationship between the string and number is:\\n```\\nfor String ABZ and its corresponding number n:\\nn = (A+1) * 26^2 + (B+1) * 26^1 + (Z+1) * 26^0\\n```\\nWhy (A+1)? Because in char system \\'A\\' is 0, but in excel system \\'A\\' is one. Every char get an extra one.\\n\\nInorder to get Z, or whatever char is at Z, we will first do a minus 1 on both sides:\\n```\\nboth sides -1\\nn-1 = (A+1) * 26^2 + (B+1) * 26^1 + Z\\n```\\nThen do a %26 we will get Z.\\n```\\n(n-1)%26 =  Z                                                  (1)\\n(n-1)/26 = (A+1) * 26^1 + (B+1) * 26^0                         (2)\\n```\\n\\nWith the above equations, we can understand why we need the n-- at first of every loop:\\nFor each loop, we use (1) to obtain what the current char is.\\nAnd we divide n-1 by 26 to get (2), in preparation for the next loop.\\n\\nJava:\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while(n > 0){\\n            n--;\\n            int curr = n%26;\\n            n /= 26;\\n            sb.append((char)(curr+\\'A\\'));\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n```\\n\\nPython:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while(n > 0) {\\n            n--;\\n            int curr = n % 26;\\n            n = n / 26;\\n            ans.push_back(curr + \\'A\\');\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n0 -> A\\n25 -> Z\\n26 -> BA\\n```\n```\\n1 -> A\\n26 -> Z\\n27 -> AA\\n```\n```\\nfor String ABZ and its corresponding number n:\\nn = (A+1) * 26^2 + (B+1) * 26^1 + (Z+1) * 26^0\\n```\n```\\nboth sides -1\\nn-1 = (A+1) * 26^2 + (B+1) * 26^1 + Z\\n```\n```\\n(n-1)%26 =  Z                                                  (1)\\n(n-1)/26 = (A+1) * 26^1 + (B+1) * 26^0                         (2)\\n```\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while(n > 0){\\n            n--;\\n            int curr = n%26;\\n            n /= 26;\\n            sb.append((char)(curr+\\'A\\'));\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while(n > 0) {\\n            n--;\\n            int curr = n % 26;\\n            n = n / 26;\\n            ans.push_back(curr + \\'A\\');\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51398,
                "title": "my-1-lines-code-in-java-c-and-python",
                "content": "Java:\\n\\n    return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)('A' + (n % 26));\\n\\nC++:\\n\\n    return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + 'A');\\n\\nupdate: because the behavior of different compilers, the safe version should be:\\n\\n    return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + 'A');\\n\\nPython:\\n\\n    return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord('A'))",
                "solutionTags": [
                    "Java"
                ],
                "code": "Java:\\n\\n    return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)('A' + (n % 26));\\n\\nC++:\\n\\n    return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + 'A');\\n\\nupdate: because the behavior of different compilers, the safe version should be:\\n\\n    return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + 'A');\\n\\nPython:\\n\\n    return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord('A'))",
                "codeTag": "Unknown"
            },
            {
                "id": 51404,
                "title": "python-solution-with-explanation",
                "content": "Let's see the relationship between the Excel sheet column title and the number:\\n\\n    A   1     AA    26+ 1     BA  2\\xd726+ 1     ...     ZA  26\\xd726+ 1     AAA  1\\xd726\\xb2+1\\xd726+ 1\\n    B   2     AB    26+ 2     BB  2\\xd726+ 2     ...     ZB  26\\xd726+ 2     AAB  1\\xd726\\xb2+1\\xd726+ 2\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............   \\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    Z  26     AZ    26+26     BZ  2\\xd726+26     ...     ZZ  26\\xd726+26     AAZ  1\\xd726\\xb2+1\\xd726+26\\n\\nNow we can see that ABCD\\uff1dA\\xd726\\xb3\\uff0bB\\xd726\\xb2\\uff0bC\\xd726\\xb9\\uff0bD\\uff1d1\\xd726\\xb3\\uff0b2\\xd726\\xb2\\uff0b3\\xd726\\xb9\\uff0b4\\n\\nBut how to get the column title from the number? We can't simply use the n%26 method because:\\n\\nZZZZ\\uff1dZ\\xd726\\xb3\\uff0bZ\\xd726\\xb2\\uff0bZ\\xd726\\xb9\\uff0bZ\\uff1d26\\xd726\\xb3\\uff0b26\\xd726\\xb2\\uff0b26\\xd726\\xb9\\uff0b26\\n\\nWe can use (n-1)%26 instead, then we get a number range from 0 to 25.\\n\\n    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\\n            result = []\\n            while num > 0:\\n                result.append(capitals[(num-1)%26])\\n                num = (num-1) // 26\\n            result.reverse()\\n            return ''.join(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Let's see the relationship between the Excel sheet column title and the number:\\n\\n    A   1     AA    26+ 1     BA  2\\xd726+ 1     ...     ZA  26\\xd726+ 1     AAA  1\\xd726\\xb2+1\\xd726+ 1\\n    B   2     AB    26+ 2     BB  2\\xd726+ 2     ...     ZB  26\\xd726+ 2     AAB  1\\xd726\\xb2+1\\xd726+ 2\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............   \\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    .   .     ..    .....     ..  .......     ...     ..  ........     ...  .............\\n    Z  26     AZ    26+26     BZ  2\\xd726+26     ...     ZZ  26\\xd726+26     AAZ  1\\xd726\\xb2+1\\xd726+26\\n\\nNow we can see that ABCD\\uff1dA\\xd726\\xb3\\uff0bB\\xd726\\xb2\\uff0bC\\xd726\\xb9\\uff0bD\\uff1d1\\xd726\\xb3\\uff0b2\\xd726\\xb2\\uff0b3\\xd726\\xb9\\uff0b4\\n\\nBut how to get the column title from the number? We can't simply use the n%26 method because:\\n\\nZZZZ\\uff1dZ\\xd726\\xb3\\uff0bZ\\xd726\\xb2\\uff0bZ\\xd726\\xb9\\uff0bZ\\uff1d26\\xd726\\xb3\\uff0b26\\xd726\\xb2\\uff0b26\\xd726\\xb9\\uff0b26\\n\\nWe can use (n-1)%26 instead, then we get a number range from 0 to 25.\\n\\n    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            capitals = [chr(x) for x in range(ord('A'), ord('Z')+1)]\\n            result = []\\n            while num > 0:\\n                result.append(capitals[(num-1)%26])\\n                num = (num-1) // 26\\n            result.reverse()\\n            return ''.join(result)",
                "codeTag": "Java"
            },
            {
                "id": 51399,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\n            while(n>0){\\n                n--;\\n                result.insert(0, (char)('A' + n % 26));\\n                n /= 26;\\n            }\\n    \\n            return result.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\n            while(n>0){\\n                n--;\\n                result.insert(0, (char)('A' + n % 26));\\n                n /= 26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51541,
                "title": "readable-c-code-within-1ms",
                "content": "class Solution {\\n\\npublic:\\n\\n    string convertToTitle(int n) {\\n\\n        string res;\\n\\n        char tmp;\\n\\n        while(n){\\n\\n            n -= 1;\\n\\n            tmp = 'A' + n % 26;\\n\\n            res = tmp + res;\\n\\n            n /= 26;\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    string convertToTitle(int n) {\\n\\n        string res;\\n\\n        char tmp;\\n\\n        while(n){\\n\\n            n -= 1;\\n\\n            tmp = 'A' + n % 26;\\n\\n            res = tmp + res;\\n\\n            n /= 26;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2448578,
                "title": "easy-0-ms-100-fully-explained-java-c-python-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Excel Sheet Column Title.\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        StringBuilder output = new StringBuilder();\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            char c = (char) (columnNumber % 26 + \\'A\\');\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            // Append the character into output...\\n            output.append(c);\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        output.reverse();\\n        // Return the reversed string.\\n        return output.toString();\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        string output;\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            int m = columnNumber % 26;\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            output += \\'A\\' + m;\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        reverse(output.begin(),output.end());\\n        // Return the reversed string.\\n        return output;\\n    }\\n};\\n```\\n\\n# **Python / Python3 Solution:**\\n```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        # Create an empty string for storing the characters...\\n        output = \"\"\\n        # Run a while loop while columnNumber is positive...\\n        while columnNumber > 0:\\n            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...\\n            output = chr(ord(\\'A\\') + (columnNumber - 1) % 26) + output\\n            # Divide columnNumber by 26...\\n            columnNumber = (columnNumber - 1) // 26\\n        # Return the output string.\\n        return output\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        StringBuilder output = new StringBuilder();\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            char c = (char) (columnNumber % 26 + \\'A\\');\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            // Append the character into output...\\n            output.append(c);\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        output.reverse();\\n        // Return the reversed string.\\n        return output.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Create an empty string for storing the characters...\\n        string output;\\n        // Run a while loop while columnNumber is positive...\\n        while(columnNumber > 0){\\n            // Subtract 1 from columnNumber...\\n            columnNumber--;\\n            // Get current character by doing modulo of columnNumber by 26...\\n            int m = columnNumber % 26;\\n            // Divide columnNumber by 26...\\n            columnNumber /= 26;\\n            output += \\'A\\' + m;\\n        }\\n        // Reverse the output string...\\n        // Bcause we have found characters from right to left...\\n        reverse(output.begin(),output.end());\\n        // Return the reversed string.\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        # Create an empty string for storing the characters...\\n        output = \"\"\\n        # Run a while loop while columnNumber is positive...\\n        while columnNumber > 0:\\n            # Subtract 1 from columnNumber and get current character by doing modulo of columnNumber by 26...\\n            output = chr(ord(\\'A\\') + (columnNumber - 1) % 26) + output\\n            # Divide columnNumber by 26...\\n            columnNumber = (columnNumber - 1) // 26\\n        # Return the output string.\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51401,
                "title": "my-easy-to-understand-java-solution",
                "content": "Instead of 1 -> A, 26 -> Z, we can assume that 0 -> A, 25 -> Z, and then here comes the base 26 representation, it's similar when you convert a number from base 10 to base 2\\n\\n    public class Solution {\\n    public String convertToTitle(int n) {\\n        String res = \"\";\\n        while(n != 0) {\\n            char ch = (char)((n - 1) % 26 + 65);\\n            n = (n - 1) / 26;\\n            res = ch + res;\\n        }\\n        return res;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String convertToTitle(int n) {\\n        String res = \"\";\\n        while(n != 0) {\\n            char ch = (char)((n - 1) % 26 + 65);\\n            n = (n - 1) / 26;\\n            res = ch + res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51421,
                "title": "share-my-simple-solution-just-a-little-trick-to-handle-corner-case-26",
                "content": "    string convertToTitle(int n) {\\n            string ans;\\n            while (n) {\\n                ans = char ((n - 1) % 26 + 'A') + ans;\\n                n = (n - 1) / 26;\\n            }\\n            return ans;\\n        }",
                "solutionTags": [],
                "code": "    string convertToTitle(int n) {\\n            string ans;\\n            while (n) {\\n                ans = char ((n - 1) % 26 + 'A') + ans;\\n                n = (n - 1) / 26;\\n            }\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3943071,
                "title": "100-recursive-iterative-2-approaches",
                "content": "# Problem Understanding\\n\\nIn the \"Excel Sheet Column Title\" problem, we are given an integer representing a column number. The task is to return its corresponding column title as it appears in an Excel sheet, where the letters range from A to Z for the numbers 1 to 26, and then AA to AZ, BA to BZ, and so on.\\n\\nFor instance, given the input 28, the output should be \"AB\".\\n\\n**Input**: columnNumber = 28\\n**Output**: \"AB\"\\n\\n---\\n\\n# Live Coding Iterative & Recursive:\\nhttps://youtu.be/Vlu300w6HbY\\n\\n- [Coding in Python \\uD83D\\uDC0D](https://youtu.be/Vlu300w6HbY)\\n- [Coding in Rust \\uD83E\\uDD80](https://youtu.be/nutdEPmd3kM)\\n\\n---\\n\\n# Approach 1: Iterative\\n\\nTo solve the \"Excel Sheet Column Title\" problem using the iterative approach, we continuously divide the given number by 26 and determine the remainder. This remainder gives us the current character of the Excel title, starting from the least significant character.\\n\\n## Key Data Structures:\\n- **List (result)**: Used to store the characters of the Excel title.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Create an empty list named `result`.\\n   \\n2. **Processing Each Number**:\\n   - While `columnNumber` is not zero:\\n     - Use the `divmod` function to get the quotient and remainder of `columnNumber` when divided by 26.\\n     - Decrement the `columnNumber` by 1 and append the corresponding character to the `result` list.\\n     \\n3. **Wrap-up**:\\n   - Reverse the `result` list and join the characters to form the final Excel title.\\n\\n## Example:\\n\\nGiven the input 701:\\n\\n**Iterative Approach:**\\n\\n- First iteration: remainder = 24, quotient = 26; result = [\"Y\"]\\n- Second iteration: remainder = 25, quotient = 0; result = [\"Y\", \"Z\"]\\n- No further iterations since quotient is now 0; final result = \"ZY\"\\n\\n---\\n\\n# Approach 2: Recursive\\n\\nTo tackle this problem recursively, we adopt a top-down approach, determining the most significant character first and then recursively determining the rest.\\n\\n## Key Data Structures:\\n- **String**: As this is a recursive approach, we construct the Excel title directly as a string.\\n\\n## Enhanced Breakdown:\\n\\n1. **Base Case**:\\n   - If `columnNumber` is zero, return an empty string.\\n   \\n2. **Recursive Call**:\\n   - Use the `divmod` function to determine the quotient and remainder of `columnNumber` divided by 26.\\n   - Construct the current character of the Excel title using the remainder.\\n   - Recursively call the function with the quotient to determine the preceding characters of the Excel title.\\n\\n3. **Wrap-up**:\\n   - Concatenate the result of the recursive call with the current character to form the current state of the Excel title.\\n\\n## Example:\\n\\nGiven the input 701:\\n\\n**Recursive Approach:**\\n\\n- First call: remainder = 24, quotient = 26; current character = \"Y\"\\n- Second call: remainder = 25, quotient = 0; current character = \"Z\"\\n- No further recursive calls as quotient is now 0; final result = \"ZY\"\\n\\n(Note: The order of the recursive approach\\'s results is due to the nature of recursion, where the deeper levels of recursion resolve first.)\\n\\n---\\n\\n# Complexity:\\n\\n**Time Complexity for Both Approaches:** \\n- The time complexity is $$O(\\\\log_{26} n)$$ for both methods, where $$n$$ is the given `columnNumber`. This is because we\\'re continuously dividing the number by 26 until it becomes zero.\\n\\n**Space Complexity for Iterative Approach:** \\n- The space complexity is $$O(\\\\log_{26} n)$$ due to the list we use to store the Excel title characters.\\n\\n**Space Complexity for Recursive Approach:** \\n- The space complexity is also $$O(\\\\log_{26} n)$$ due to the recursive call stack.\\n\\n---\\n\\n# Performance:\\n\\n**Iterative Approach:**\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 0 ms         | 100%             | 2 MB        | 86.84%          |\\n| Java       | 0 ms         | 100%             | 39.7 MB     | 61.65%          |\\n| Go         | 1 ms         | 74.84%           | 1.9 MB      | 94.34%          |\\n| C++        | 2 ms         | 49.78%           | 6 MB        | 37.93%          |\\n| Python3    | 32 ms        | 93.98%           | 16.3 MB     | 23.11%          |\\n| JavaScript | 44 ms        | 93.13%           | 42.1 MB     | 11.16%          |\\n| C#         | 55 ms        | 97.28%           | 36.8 MB     | 15.65%          |\\n\\n![it1.png](https://assets.leetcode.com/users/images/a1229abf-72de-4d98-a48d-4c280de56bd0_1692666229.2393072.png)\\n\\n\\n**Recursive Approach:**\\n\\n| Language   | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|------------|--------------|------------------|-------------|-----------------|\\n| Rust       | 0 ms         | 100%             | 2.2 MB      | 23.68%          |\\n| C++        | 0 ms         | 100%             | 5.9 MB      | 37.93%          |\\n| Go         | 1 ms         | 74.84%           | 1.9 MB      | 94.34%          |\\n| Java       | 6 ms         | 34.8%            | 40.6 MB     | 5.65%           |\\n| Python3    | 34 ms        | 88.27%           | 16.4 MB     | 23.11%          |\\n| JavaScript | 42 ms        | 96.14%           | 41.3 MB     | 86.70%          |\\n| C#         | 69 ms        | 51.2%            | 36.8 MB     | 15.65%          |\\n\\n![r2.png](https://assets.leetcode.com/users/images/eaebd8ab-c1ac-42e6-8722-afe3fe167c8c_1692666240.177567.png)\\n\\n\\n---\\n\\n# Code Iterative\\n``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        result = []\\n        while columnNumber:\\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\\n            result.append(chr(65 + remainder))\\n        return \\'\\'.join(reversed(result))\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber) {\\n            columnNumber--;\\n            char c = \\'A\\' + columnNumber % 26;\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        let mut result = String::new();\\n        let mut number = column_number;\\n        while number > 0 {\\n            number -= 1;\\n            let char_code = ((number % 26) as u8) + b\\'A\\';\\n            result.insert(0, char_code as char);\\n            number /= 26;\\n        }\\n        result\\n    }\\n}\\n```\\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    var result string\\n    for columnNumber > 0 {\\n        columnNumber--\\n        charCode := \\'A\\' + rune(columnNumber % 26)\\n        result = string(charCode) + result\\n        columnNumber /= 26\\n    }\\n    return result\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder result = new StringBuilder();\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result.insert(0, c);\\n            columnNumber /= 26;\\n        }\\n        return result.toString();\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let result = \"\";\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n        result = String.fromCharCode(charCode) + result;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    return result;\\n};\\n```\\n\\n# Code Recusrive\\n``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        if not columnNumber:\\n            return \"\"\\n        columnNumber, remainder = divmod(columnNumber - 1, 26)\\n        return self.convertToTitle(columnNumber) + chr(65 + remainder)\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = \\'A\\' + columnNumber % 26;\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n};\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        if column_number == 0 {\\n            return String::new();\\n        }\\n        let mut number = column_number;\\n        number -= 1;\\n        let char_code = ((number % 26) as u8) + b\\'A\\';\\n        let prev = Self::convert_to_title(number / 26);\\n        return format!(\"{}{}\", prev, char_code as char);\\n    }\\n}\\n```\\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    if columnNumber == 0 {\\n        return \"\"\\n    }\\n    columnNumber--\\n    charCode := \\'A\\' + rune(columnNumber%26)\\n    return convertToTitle(columnNumber/26) + string(charCode)\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return ConvertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    if (columnNumber === 0) return \"\";\\n    columnNumber--;\\n    let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n    return convertToTitle(Math.floor(columnNumber / 26)) + String.fromCharCode(charCode);\\n};\\n```\\n\\n# Live Coding in Rust:\\nhttps://youtu.be/nutdEPmd3kM\\n\\nThis problem provides an elegant demonstration of how to convert base-10 numbers to another base, in this case, base-26. It\\'s a great reminder that sometimes algorithmic problems can be rooted in simple number base conversions. \\uD83D\\uDCA1\\uD83C\\uDF20\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "Go",
                    "Rust",
                    "Math",
                    "String"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        result = []\\n        while columnNumber:\\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\\n            result.append(chr(65 + remainder))\\n        return \\'\\'.join(reversed(result))\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber) {\\n            columnNumber--;\\n            char c = \\'A\\' + columnNumber % 26;\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        let mut result = String::new();\\n        let mut number = column_number;\\n        while number > 0 {\\n            number -= 1;\\n            let char_code = ((number % 26) as u8) + b\\'A\\';\\n            result.insert(0, char_code as char);\\n            number /= 26;\\n        }\\n        result\\n    }\\n}\\n```\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    var result string\\n    for columnNumber > 0 {\\n        columnNumber--\\n        charCode := \\'A\\' + rune(columnNumber % 26)\\n        result = string(charCode) + result\\n        columnNumber /= 26\\n    }\\n    return result\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder result = new StringBuilder();\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result.insert(0, c);\\n            columnNumber /= 26;\\n        }\\n        return result.toString();\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        string result = \"\";\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            char c = (char) (\\'A\\' + columnNumber % 26);\\n            result = c + result;\\n            columnNumber /= 26;\\n        }\\n        return result;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let result = \"\";\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n        result = String.fromCharCode(charCode) + result;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    return result;\\n};\\n```\n``` Python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        if not columnNumber:\\n            return \"\"\\n        columnNumber, remainder = divmod(columnNumber - 1, 26)\\n        return self.convertToTitle(columnNumber) + chr(65 + remainder)\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = \\'A\\' + columnNumber % 26;\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n};\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn convert_to_title(column_number: i32) -> String {\\n        if column_number == 0 {\\n            return String::new();\\n        }\\n        let mut number = column_number;\\n        number -= 1;\\n        let char_code = ((number % 26) as u8) + b\\'A\\';\\n        let prev = Self::convert_to_title(number / 26);\\n        return format!(\"{}{}\", prev, char_code as char);\\n    }\\n}\\n```\n``` Go []\\nfunc convertToTitle(columnNumber int) string {\\n    if columnNumber == 0 {\\n        return \"\"\\n    }\\n    columnNumber--\\n    charCode := \\'A\\' + rune(columnNumber%26)\\n    return convertToTitle(columnNumber/26) + string(charCode)\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public String convertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return convertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        if (columnNumber == 0) return \"\";\\n        columnNumber--;\\n        char c = (char) (\\'A\\' + columnNumber % 26);\\n        return ConvertToTitle(columnNumber / 26) + c;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    if (columnNumber === 0) return \"\";\\n    columnNumber--;\\n    let charCode = \\'A\\'.charCodeAt(0) + columnNumber % 26;\\n    return convertToTitle(Math.floor(columnNumber / 26)) + String.fromCharCode(charCode);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51465,
                "title": "solution-with-explanation",
                "content": "The idea behind this problem is as follows: \\n\\nConsider getting the characters for 28: It's 26^1 * (first Character) + 26^0 * (second Character), which in this case is 26*'A' + 1*'B' . Therefore to get the last character mod by 26. Then to get the character prior to that divide by 26 then mod by 26 and so on till what remains is zero.\\n\\n    string convertToTitle(int n) {\\n    \\tstring res=\"\";\\n        while(n>0){\\n    \\t\\tres=char('A'+(n-1)%26)+res;\\n    \\t\\tn=(n-1)/26;\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "The idea behind this problem is as follows: \\n\\nConsider getting the characters for 28: It's 26^1 * (first Character) + 26^0 * (second Character), which in this case is 26*'A' + 1*'B' . Therefore to get the last character mod by 26. Then to get the character prior to that divide by 26 then mod by 26 and so on till what remains is zero.\\n\\n    string convertToTitle(int n) {\\n    \\tstring res=\"\";\\n        while(n>0){\\n    \\t\\tres=char('A'+(n-1)%26)+res;\\n    \\t\\tn=(n-1)/26;\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51532,
                "title": "share-my-java-solusion",
                "content": "    public String convertToTitle(int n) {\\n            String res = \"\";\\n            while(n != 0) {\\n                res = (char)('A' + (n - 1) % 26) + res;\\n                n = (n - 1) / 26;\\n            }\\n            return res;\\n    }",
                "solutionTags": [],
                "code": "    public String convertToTitle(int n) {\\n            String res = \"\";\\n            while(n != 0) {\\n                res = (char)('A' + (n - 1) % 26) + res;\\n                n = (n - 1) / 26;\\n            }\\n            return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 338842,
                "title": "clear-python3-solution",
                "content": "There no concept of \"zero\" in excel numeral system. So every time we get a new \"digit\" we decrease n-number by 1, so we wouldn\\'t treat \"A\" as zero. Usually you\\'d consider 1, 01, 001 and 0001 as the same numbers. But in such zero-less system you can\\'t treat E, AE, AAE and AAAE as the same numbers - so we are building a number view without zero-symbol.\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        abc=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        ans=\"\"\\n        while n:\\n            n=n-1\\n            ans=abc[n%26]+ans\\n            n=n//26\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        abc=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        ans=\"\"\\n        while n:\\n            n=n-1\\n            ans=abc[n%26]+ans\\n            n=n//26\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970322,
                "title": "very-easy-3-line-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        String ans = \"\";\\n        while (columnNumber>0){\\n            columnNumber--;\\n            ans = (char) (\\'A\\'+ (columnNumber%26)) + ans;\\n            columnNumber = columnNumber/26;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Please Upvote if it was helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        String ans = \"\";\\n        while (columnNumber>0){\\n            columnNumber--;\\n            ans = (char) (\\'A\\'+ (columnNumber%26)) + ans;\\n            columnNumber = columnNumber/26;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674844,
                "title": "java-easy-solution-without-stringbuilder",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n      String result = \"\";\\n       \\n       while(n > 0) {\\n           n --;\\n           result = (char)(\\'A\\' + (n % 26)) + result;\\n           n = n / 26;\\n       }\\n       return result;\\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n      String result = \"\";\\n       \\n       while(n > 0) {\\n           n --;\\n           result = (char)(\\'A\\' + (n % 26)) + result;\\n           n = n / 26;\\n       }\\n       return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51561,
                "title": "straightforward-python-solution",
                "content": "Conversion from 10-ary numbers to 26-ary numbers. The tricky part is the lack of the equivalent number '0' in the 26-ary system.\\n\\n    def convertToTitle(self, n):\\n        r = ''\\n        while(n>0):\\n            n -= 1\\n            r = chr(n%26+65) + r\\n            n /= 26\\n        return r",
                "solutionTags": [
                    "Python"
                ],
                "code": "Conversion from 10-ary numbers to 26-ary numbers. The tricky part is the lack of the equivalent number '0' in the 26-ary system.\\n\\n    def convertToTitle(self, n):\\n        r = ''\\n        while(n>0):\\n            n -= 1\\n            r = chr(n%26+65) + r\\n            n /= 26\\n        return r",
                "codeTag": "Python3"
            },
            {
                "id": 3035652,
                "title": "c-solution-with-detailed-explanation",
                "content": "# Intuition\\n- This problem requires a number system conversion.\\n- We need to convert the base(10) input to base(26).\\n- But there\\'s a catch. Excel system has range: [1, 26], whereas base(26) has range: [0, 25].\\n\\n# Approach\\n- If we try to represent ```columnNumber``` using **base(26)**, then they can be represented like this:\\n```\\n// target: AXY\\ncolumnNumber = (26^2)*(A) + (26^1)*(X) + (26^0)*(Y)\\n```\\n- **base(26)**\\n    - *A -> 0*\\n    - *B -> 1*\\n    - *C -> 2*\\n    - *and so on till, Z -> 25*\\n- But according to **Excel**:\\n    - *A -> 1*\\n    - *B -> 2*\\n    - *C -> 3*\\n    - *and so on till, Z -> 26*\\n- If we observe the pattern here, numeric representation of every corresponding alphabet in **Excel** is one more than that of **base(26)**, *right*?\\n- So, any ```columnNumber``` can be represented using **Excel** format like this:\\n```\\n// target: AXY\\ncolumnNumber: (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)\\n```\\n- Why **+1**? Because, as explained above, each corresponding letter is one more than its corresponding representation in base(26).\\n\\n### Now, how do we retrieve the letters?\\n```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\\n\\n# Complexity\\n- Time complexity:\\n    O(log(N))\\n\\n- Space complexity:\\n    O(log(N))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // base(10) -> base(26)   \\n        string column = \"\";\\n        int rem;\\n\\n        while(columnNumber){\\n            rem = (--columnNumber)%26;  // similar to subtracting 1 from both sides and obtaining the remainder\\n            columnNumber /= 26;\\n\\n            column = char(\\'A\\' + rem) + column;\\n        }\\n\\n        return column;\\n    }\\n};\\n```\\n\\n#### Consider upvoting, if it helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```columnNumber```\n```\\n// target: AXY\\ncolumnNumber = (26^2)*(A) + (26^1)*(X) + (26^0)*(Y)\\n```\n```columnNumber```\n```\\n// target: AXY\\ncolumnNumber: (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)\\n```\n```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // base(10) -> base(26)   \\n        string column = \"\";\\n        int rem;\\n\\n        while(columnNumber){\\n            rem = (--columnNumber)%26;  // similar to subtracting 1 from both sides and obtaining the remainder\\n            columnNumber /= 26;\\n\\n            column = char(\\'A\\' + rem) + column;\\n        }\\n\\n        return column;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067071,
                "title": "7lines-of-code-with-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/17995446-4274-499b-9c70-ef840963152a_1613408567.810666.png)\\n![Uploading file...]()\\n```\\n    string s=\"\";\\n    n--;\\n    while(n>=0){\\n        s+=(\\'A\\'+n%26);\\n        n/=26;\\n        n--;\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n```\\n\\n\\n***IF you found it helpfull don\\'t forget to upvote and if query then ask i\\'ll try my best to make you understand Thank you so much ***\\nCoding is all about logic building and thinking just think before solve happy codding folks:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    string s=\"\";\\n    n--;\\n    while(n>=0){\\n        s+=(\\'A\\'+n%26);\\n        n/=26;\\n        n--;\\n    }\\n    reverse(s.begin(),s.end());\\n    return s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943090,
                "title": "c-c-solutions-theorem-for-length-of-string-vs-deque-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReal Math is done in this post. Think of this problem as a problem of expressing numbers without 0 in this number system. Simply perform the conversion using a base-26 system and manipulate the resulting string. Some related questions:\\n\\n[171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/description/)\\n[2194. Cells in a Range on an Excel Sheet](https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/)\\n[13. Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3692505/python-c-using-hash-table-w-explanation/)\\n[12. Integer to Roman](https://leetcode.com/problems/integer-to-roman/)\\n[273. Integer to English Words](https://leetcode.com/problems/integer-to-english-words/)\\n\\nHow to express n as a 26-radix number? Consider the following\\n$$\\nn=\\\\sum_i a_i26^i\\n$$\\nwhere $0\\\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs a modification, i.e.\\n$$\\nn=\\\\sum_i (a_i+1)26^i\\n$$\\nThe process is shown in following pseudo code:\\n```\\nwhile (n > 0) {\\n    n--;\\n    q, r = div(n, 26);\\n    ans=(r+\\'A\\')+ans;\\n    n = q;\\n}\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe push_back takes O(1) running time for C++ string for appending a character. Then use reverse function to get the correct answer.\\n\\nI don\\'t use something like push_front (C++ string doesn\\'t have it, can use insert or operator+) because it takes properly O(len(string)) of of elapsed time.\\n\\n2nd solution does not use reverse function. Use  the formula (borrowed from number system with 0)\\n```\\nint len=floor(log(n)/log(26))+1;\\n```\\nto estimate the the length for string. There could be some better formula.  Before returning answer, check whether ans has whitespace, especially when \\'Z\\' is obtained at the last division. \\n\\n3rd solution uses deque, O(1) push_front is therefore possible!!! \\n\\nThe following theorem can be proved by using geometric sequence:\\n$$\\na+a^2+\\\\cdots+a^d=a\\\\frac{a^d-1}{a-1}\\n$$\\n # Theorem for length of the desired string\\nIf n>26 then  len(ans)=d $\\\\iff$\\n$\\n26(\\\\frac{26^{d-1}-1}{25})<n\\\\leq 26(\\\\frac{26^{d}-1}{25})=(ZZ\\\\cdots Z)\\n$\\nwhere $(ZZ\\\\cdots Z)$ denotes the number consisting of d \\'Z\\'s. After some standard manipulations for inequalities, the exact string length formula is obtained as follows\\n```\\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n```\\nNo need for adjustment. Cheers!!!! With this correct formula, C solution is also done.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(\\\\log n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans;\\n        while (n > 0) {\\n            n--;\\n            auto [q, r] = div(n, 26);\\n            ans.push_back(char(\\'A\\'+r));\\n            n = q;\\n        }\\n        reverse(ans.begin(), ans.end()); // Reverse the ans string\\n        return ans; // Return the reversed ans string\\n    }\\n};\\n```\\n# 2nd Solution beats 100% in 0 ms also in C\\n\\n```C []\\nchar *convertToTitle(int columnNumber) {\\n    int n = columnNumber;\\n    // Compute the length for the string\\n    int len = (n <= 26) ? 1 : ceil(log(n * 25.0 / 26 + 1) / log(26));    \\n    // Allocate memory for the string including the null-terminator\\n    char *ans = (char *)malloc((len + 1) * sizeof(char));\\n    ans[len] = \\'\\\\0\\'; // Null-terminate the string\\n    \\n    while (n > 0) {\\n        n--;\\n        div_t x = div(n, 26);\\n        ans[--len] = (char)(\\'A\\' + x.rem);\\n        n = x.quot;\\n    }\\n    return ans;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        //Compute the length for string\\n        int len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n        string ans(len, \\' \\');// fill with whitespace\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            ans[--len]=char(\\'A\\'+x.rem);\\n            n = x.quot;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n# 3rd Solution uses deque\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        deque<char> q;\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            q.push_front(char(\\'A\\'+x.rem));\\n            n = x.quot;\\n        }       \\n        return string(q.begin(), q.end()); \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String",
                    "Queue"
                ],
                "code": "```\\nwhile (n > 0) {\\n    n--;\\n    q, r = div(n, 26);\\n    ans=(r+\\'A\\')+ans;\\n    n = q;\\n}\\n```\n```\\nint len=floor(log(n)/log(26))+1;\\n```\n```\\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans;\\n        while (n > 0) {\\n            n--;\\n            auto [q, r] = div(n, 26);\\n            ans.push_back(char(\\'A\\'+r));\\n            n = q;\\n        }\\n        reverse(ans.begin(), ans.end()); // Reverse the ans string\\n        return ans; // Return the reversed ans string\\n    }\\n};\\n```\n```C []\\nchar *convertToTitle(int columnNumber) {\\n    int n = columnNumber;\\n    // Compute the length for the string\\n    int len = (n <= 26) ? 1 : ceil(log(n * 25.0 / 26 + 1) / log(26));    \\n    // Allocate memory for the string including the null-terminator\\n    char *ans = (char *)malloc((len + 1) * sizeof(char));\\n    ans[len] = \\'\\\\0\\'; // Null-terminate the string\\n    \\n    while (n > 0) {\\n        n--;\\n        div_t x = div(n, 26);\\n        ans[--len] = (char)(\\'A\\' + x.rem);\\n        n = x.quot;\\n    }\\n    return ans;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        //Compute the length for string\\n        int len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\\n        string ans(len, \\' \\');// fill with whitespace\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            ans[--len]=char(\\'A\\'+x.rem);\\n            n = x.quot;\\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        deque<char> q;\\n        while (n > 0) {\\n            n--;\\n            auto x = div(n, 26);\\n            q.push_front(char(\\'A\\'+x.rem));\\n            n = x.quot;\\n        }       \\n        return string(q.begin(), q.end()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51585,
                "title": "the-way-i-come-up-with-my-solution",
                "content": "    1 -> A\\n    2 -> B\\n    3 -> C\\n    ...\\n    26 -> Z\\n    27 -> AA\\n    28 -> AB \\n\\nThe last character repeats from A to Z. The period is 26, which is similar to remainder when divided by 26. But remainder is from 0 to 25, so we need to subtract 1 on left and right side.\\n\\nLet n be the input number, r be the integer representation of the last character (1<=r<=26), we have\\n\\n> \\xa0\\xa0 n= 26x+r \\n>\\n> n-1=26x+(r-1)\\n>\\n> r-1=(n-1) % 26  and x=(n-1) / 26\\n\\n\\n\\tpublic String convertToTitle2(int n)\\n\\t{\\n\\t\\tint index = (int) Math.ceil(Math.log(1 + (26d - 1) * n / 26) / Math.log(26)) - 1;\\n\\t\\tStringBuilder result = new StringBuilder(index + 1);\\n\\t\\tresult.setLength(result.capacity());\\n\\t\\twhile (n > 0)\\n\\t\\t{\\n\\t\\t\\tint r = (n - 1) % 26 + 1;\\n\\t\\t\\tresult.setCharAt(index--, (char) (r - 1 + (int) 'A'));\\n\\t\\t\\tn = (n - 1) / 26;\\n\\t\\t}\\n\\t\\treturn result.toString();\\n\\t}\\n\\nI also calculate the length of title.\\n\\nThe maximum number of *l*-character title is ZZ...Z, ie.\\n![enter image description here][1]\\n\\n\\n  [1]: http://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20n%20&=%2026%5Ccdot%2026%5El+26%5Ccdot%2026%5E%7Bl-1%7D%20+%5Ccdots%20+26%5Ccdot%2026%5E0%5C%5C%20&=%20%5Cfrac%7B26-26%5Ccdot%2026%5El%7D%7B1-26%7D%20%5Cend%7Balign*%7D",
                "solutionTags": [
                    "Java"
                ],
                "code": "    1 -> A\\n    2 -> B\\n    3 -> C\\n    ...\\n    26 -> Z\\n    27 -> AA\\n    28 -> AB \\n\\nThe last character repeats from A to Z. The period is 26, which is similar to remainder when divided by 26. But remainder is from 0 to 25, so we need to subtract 1 on left and right side.\\n\\nLet n be the input number, r be the integer representation of the last character (1<=r<=26), we have\\n\\n> \\xa0\\xa0 n= 26x+r \\n>\\n> n-1=26x+(r-1)\\n>\\n> r-1=(n-1) % 26  and x=(n-1) / 26\\n\\n\\n\\tpublic String convertToTitle2(int n)\\n\\t{\\n\\t\\tint index = (int) Math.ceil(Math.log(1 + (26d - 1) * n / 26) / Math.log(26)) - 1;\\n\\t\\tStringBuilder result = new StringBuilder(index + 1);\\n\\t\\tresult.setLength(result.capacity());\\n\\t\\twhile (n > 0)\\n\\t\\t{\\n\\t\\t\\tint r = (n - 1) % 26 + 1;\\n\\t\\t\\tresult.setCharAt(index--, (char) (r - 1 + (int) 'A'));\\n\\t\\t\\tn = (n - 1) / 26;\\n\\t\\t}\\n\\t\\treturn result.toString();\\n\\t}\\n\\nI also calculate the length of title.\\n\\nThe maximum number of *l*-character title is ZZ...Z, ie.\\n![enter image description here][1]\\n\\n\\n  [1]: http://latex.codecogs.com/gif.latex?%5Cbegin%7Balign*%7D%20n%20&=%2026%5Ccdot%2026%5El+26%5Ccdot%2026%5E%7Bl-1%7D%20+%5Ccdots%20+26%5Ccdot%2026%5E0%5C%5C%20&=%20%5Cfrac%7B26-26%5Ccdot%2026%5El%7D%7B1-26%7D%20%5Cend%7Balign*%7D",
                "codeTag": "Unknown"
            },
            {
                "id": 3944445,
                "title": "c-string-day-22",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string s = \"\";\\n        while(c>0){\\n            c = c - 1;\\n            char ch = \\'A\\' + c % 26;\\n            s += ch;\\n            c /= 26;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d45b76a3-fafd-4782-9ac2-fe95633c8785_1692692402.437327.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string s = \"\";\\n        while(c>0){\\n            c = c - 1;\\n            char ch = \\'A\\' + c % 26;\\n            s += ch;\\n            c /= 26;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943321,
                "title": "c-beats100-step-by-step-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you look at **Excel column titles**, they are essentially a **base-26 numbering system** where the digits are represented by letters from A to Z. In other words, **A** represents **1**, **B** represents **2**, ...,**Z** represents **26**, **AA** represents **27**, **AB** represents **28**, and so on.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo convert a column number to its corresponding Excel column title, you can think of it as a **conversion from base-10 (decimal) to base-26**. Here\\'s the step-by-step approach:\\n\\n**1**. Initialize an **empty string to store the result**.\\n\\n**2**. In each iteration, **perform the following steps**:\\n-  Subtract 1 from the given columnNumber (to convert it to a 0-based index), and calculate the remainder of dividing it by 26.\\n-  Add \\'A\\' to the remainder to get the corresponding character.\\n-  Append the character to the beginning of the result string.\\n-  Update columnNumber by dividing it by 26 (integer division).\\n\\n**3**.**Repeat** the above steps until columnNumber becomes 0.\\n\\n**4**.Return the **resulting string**.\\n\\nThis approach converts the column number to its corresponding base-26 representation using characters A to Z. By continuously dividing the column number by 26 and calculating the remainders, you\\'re essentially converting the number into its corresponding digits in the Excel column title.\\n\\n**For example, let\\'s take columnNumber = 701:**\\n\\n- In the first iteration, remainder = (701 - 1) % 26 = 24, which corresponds to the character \\'Y\\'.\\n- In the second iteration, columnNumber = (701 - 1) / 26 = 26.\\n- In the third iteration, remainder = (26 - 1) % 26 = 25, which corresponds to the character \\'Z\\'.\\n- In the fourth iteration, columnNumber = (26 - 1) / 26 = 0.\\n\\n**So, the result is \"ZY\", which is the corresponding Excel column title for columnNumber 701.**\\n\\nI hope this explanation helps you understand the approach behind the solution! \\n\\n# **PLEASE UPVOTE ME IF IT IS HELPFUL TO YOU.IT WILLL MOTIVATE ME A LOT\\uD83D\\uDE0A**\\n\\n# Complexity\\n- Time complexity: **O(log(columnNumber))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(log(columnNumber))**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n\\n        while (columnNumber > 0) {\\n            // Convert the column number to 0-based index\\n            columnNumber--;\\n\\n            // Calculate the remainder to determine the character\\n            char character = \\'A\\' + (columnNumber % 26);\\n\\n            // Append the character to the result\\n            result = character + result;\\n\\n            // Update the column number for the next iteration\\n            columnNumber /= 26;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n# **PLEASE UPVOTE ME IF IT IS HELPFUL TO YOU. IT WILLL MOTIVATE ME A LOT\\uD83D\\uDE0A.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string result = \"\";\\n\\n        while (columnNumber > 0) {\\n            // Convert the column number to 0-based index\\n            columnNumber--;\\n\\n            // Calculate the remainder to determine the character\\n            char character = \\'A\\' + (columnNumber % 26);\\n\\n            // Append the character to the result\\n            result = character + result;\\n\\n            // Update the column number for the next iteration\\n            columnNumber /= 26;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 51568,
                "title": "1-ms-easy-to-understand-c-solution-with-explanation",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            /*\\n            Consider n as a three-char string;\\n            n = a * 26^2 + b * 26 + c; 1 <= (a,b,c) <= 26\\n            */\\n            string s;\\n            while(n>0){\\n                int tail = n % 26; // tail represents c;\\n                if(tail == 0){\\n                    tail = 26;  //c must be 26, thus last char mush be 'Z'; \\n                    s = 'Z' + s;\\n                }else{\\n                    char c = 'A' + tail - 1;\\n                    s = c + s;\\n                }\\n            \\n                n = n - tail;   // Remove last number and divided by 26;\\n                n = n / 26;     // In this way, b will be the last number for next iteration.\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            /*\\n            Consider n as a three-char string;\\n            n = a * 26^2 + b * 26 + c; 1 <= (a,b,c) <= 26\\n            */\\n            string s;\\n            while(n>0){\\n                int tail = n % 26; // tail represents c;\\n                if(tail == 0){\\n                    tail = 26;  //c must be 26, thus last char mush be 'Z'; \\n                    s = 'Z' + s;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 402247,
                "title": "javascript-easiest-and-cleanest-solution",
                "content": "```\\nvar convertToTitle = function(n) {\\n    if (n == 0) return null;\\n    let result = \\'\\';\\n    while (n > 0) {\\n        let r = n % 26;\\n        let d = parseInt(n / 26);\\n        if (r == 0) {\\n            r = 26;\\n            d = d - 1;\\n        }\\n        result += String.fromCharCode (64 + r);\\n        n = d;\\n    }\\n    return result.split(\\'\\').reverse().join(\"\");\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertToTitle = function(n) {\\n    if (n == 0) return null;\\n    let result = \\'\\';\\n    while (n > 0) {\\n        let r = n % 26;\\n        let d = parseInt(n / 26);\\n        if (r == 0) {\\n            r = 26;\\n            d = d - 1;\\n        }\\n        result += String.fromCharCode (64 + r);\\n        n = d;\\n    }\\n    return result.split(\\'\\').reverse().join(\"\");\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169793,
                "title": "c-readable-code",
                "content": "Sept. 13, 2018\\nIt is an easy level math algorithm. I failed my first five submission. And then I finally came out the idea to map the range from integer 1 to 26 to a smaller range from 0 to 25, deal with n - 1 in three places in the function. In other words, [0, 25] is the range to work on.\\n\\nIt took me over 15 minutes to solve the problem. I like to share my C# code here.  \\n\\n```\\npublic class Solution {\\n    const string maps = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    public string ConvertToTitle(int n)\\n        {\\n            if (n < 27)\\n            {\\n                return maps[n - 1].ToString();\\n            }\\n\\n            // 27 - AA\\n            return ConvertToTitle((n - 1 )/ 26) + maps[(n - 1)% 26].ToString();\\n    }\\n}\\n```\\nOct. 2, 2018\\nAnother problem is to define string maps with 26 characters, it is easy to make a mistake in those 26 characters. Actually it is not necessary to write down all 26 characters. \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    const string maps = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    public string ConvertToTitle(int n)\\n        {\\n            if (n < 27)\\n            {\\n                return maps[n - 1].ToString();\\n            }\\n\\n            // 27 - AA\\n            return ConvertToTitle((n - 1 )/ 26) + maps[(n - 1)% 26].ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712859,
                "title": "java-100-faster-with-explanation",
                "content": "First of all, If you tried the problem <a href=\"https://leetcode.com/problems/excel-sheet-column-number/\">Excel Sheet Column Number</a> then this problem will be easy to solve. You can find solution of that problem <a href=\"https://leetcode.com/problems/excel-sheet-column-number/discuss/712836/Java-100-faster-with-easy-explanation\">Here.</a>\\n\\nConcept: Every time, we have to find reminder of number after divide by 26 so then we can find the character according to that with reference of A.\\n\\nEx. Input : 731\\n\\n\\t   n = 731;\\n\\t\\n\\t1)  --n = 730;\\n\\t    n % 26 = 730 % 26 = 2\\n\\t\\tsb.append( (char)(2 + \\'A\\') = \\'C\\');\\n\\t\\t\\n\\t\\tn = n / 26 ( 730 / 26 = 28 )\\n\\t\\t// sb = C\\n\\t\\n\\t2) --n = 27\\n\\t   n % 26 = 27 % 26 = 1\\n\\t   sb.append( (char)(1 + \\'A\\') = \\'B\\');\\n\\t   \\n\\t   n = n /26 ( 27 / 26 = 1 )\\n\\t   // sb = \\'CB\\'\\n\\t   \\n    2) --n = 0\\n\\t   n % 26 = 0 % 26 = 0\\n\\t   sb.append( (char)(0 + \\'A\\') = \\'A\\');\\n\\t   \\n\\t   n = n /26 ( 0 / 26 = 0 )\\n\\t   // sb = \\'CBA\\'\\n\\t   \\n\\t   sb.reverse() = \\'ABC\\'\\n\\t\\n\\treturn \"ABC\"\\n\\n<br />\\n\\nSolution :\\n\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while( n > 0) {\\n            --n;\\n            sb.append((char)(n % 26 + \\'A\\'));\\n            n = n / 26;\\n        }\\n                \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while( n > 0) {\\n            --n;\\n            sb.append((char)(n % 26 + \\'A\\'));\\n            n = n / 26;\\n        }\\n                \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336155,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n    \\ts = \\'\\'\\n    \\twhile n > 0:\\n    \\t\\tr = n%26\\n    \\t\\tif r == 0: r = 26\\n    \\t\\ts = chr(64+r)+s\\n    \\t\\tn = int((n-r)/26)\\n    \\treturn(s)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n    \\ts = \\'\\'\\n    \\twhile n > 0:\\n    \\t\\tr = n%26\\n    \\t\\tif r == 0: r = 26\\n    \\t\\ts = chr(64+r)+s\\n    \\t\\tn = int((n-r)/26)\\n    \\treturn(s)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 51539,
                "title": "short-0ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string result;\\n            while (n) {\\n                result.push_back('A' + (n - 1) % 26), n = (n - 1) / 26;    \\n            }\\n            reverse(result.begin(), result.end());\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string result;\\n            while (n) {\\n                result.push_back('A' + (n - 1) % 26), n = (n - 1) / 26;    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1385535,
                "title": "python-simple-solution-with-explanation",
                "content": "We need to recursively divide by 26 till we reach 0, as the number of times we need to divide the column number by 26 determines the length of the column name (in letters).\\nWe subtract num by 1 so that the remainders range from (0,25) giving us the 26 alphabets we require.\\nThe ASCII value of \\'A\\' (capital letter A) is 65, so if remainder is 0, we need to return the character that corresponds with ASCII of 65, if remainder is 1, we need \\'B\\' which has ASCII value 66, and so on.\\nThe chr method returns the character corresponding to the given integral ASCII value.\\nAs we keep appending each new letter we encounter, the correct column name should be in the reverse order.\\n```\\ndef convertToTitle(self, num: int) -> str:\\n        s = \"\"\\n        \\n        while num > 0:\\n            num,rem = divmod(num-1,26)\\n            s += chr(65+rem)\\n        \\n        return s[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef convertToTitle(self, num: int) -> str:\\n        s = \"\"\\n        \\n        while num > 0:\\n            num,rem = divmod(num-1,26)\\n            s += chr(65+rem)\\n        \\n        return s[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1305525,
                "title": "python-3-simple-with-easy-explaination",
                "content": "```\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n        \\n\\t\\t\\t\\tres = \"\"\\n\\t\\t\\t\\tn = columnNumber\\n\\n\\t\\t\\t\\twhile n > 0 :   \\n\\n\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\tres += chr( (n % 26) + 65 )\\n\\t\\t\\t\\t\\tn //= 26\\n\\n\\t\\t\\t\\treturn res[::-1]  \\n        \\n```\\n```  \\n  \\'\\'\\'\\n        ABCD = [(A)*26^3] + [(B)*26^2] + [(C)*26^1] + [(D)] \\n        \\n        (A) = 1,(B) = 2 ......(AA) = 27....\\n        \\n        step1: ( n = n - 1 )\\n        \\n        step2: By n % 26 we get the columnuber of (alphabet)\\n        \\n        step3: Then we Add 65 (ord(A) == 65 ASCII) so that we can use it to get chr(columnuber) , \\n                but if add 65 to (n % 26) ,then we get the next element , for eg :\\n                \\n                n = 701 then 701 % 26 = 25 --> chr(25+65) == Z , but we need Y (as columnuber = Y ) \\n                therefore :\\n                we are n = n - 1 in step 1 ,\\n                n -> 700 , 700 % 26 = 24 --> chr(24+65) == Y\\n                \\n        step4: we divide it with 26 to jump to the next columnumber(B) (as it varies through 26^n) \\n        \\n        step5 : repeat while n > 0 \\n        \\n        step 6 : return the reverse eg : we are jumping from A to D in (ABCD)\\n        \\n       \\'\\'\\'\\n```\\n```\\n\\'\\'\\'\\n\\t    n = 701\\n        n-1 = 700\\n        700 % 26 = 24\\n        res += chr(24+65) == Y\\n        n = 700 // 26 == 26\\n        \\n        n = 26\\n        n-1 = 25\\n        25 % 26 = 25 -> if a > b and a % b then (a % b = a) always\\n        res += chr(25+65) == Z\\n        n = 25 // 26 ==> 0\\n\\t\\t\\n\\t\\t\\'\\'\\'\\n```\\n\\n**please upvote if u like : )**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n        \\n\\t\\t\\t\\tres = \"\"\\n\\t\\t\\t\\tn = columnNumber\\n\\n\\t\\t\\t\\twhile n > 0 :   \\n\\n\\t\\t\\t\\t\\tn -= 1\\n\\t\\t\\t\\t\\tres += chr( (n % 26) + 65 )\\n\\t\\t\\t\\t\\tn //= 26\\n\\n\\t\\t\\t\\treturn res[::-1]  \\n        \\n```\n```  \\n  \\'\\'\\'\\n        ABCD = [(A)*26^3] + [(B)*26^2] + [(C)*26^1] + [(D)] \\n        \\n        (A) = 1,(B) = 2 ......(AA) = 27....\\n        \\n        step1: ( n = n - 1 )\\n        \\n        step2: By n % 26 we get the columnuber of (alphabet)\\n        \\n        step3: Then we Add 65 (ord(A) == 65 ASCII) so that we can use it to get chr(columnuber) , \\n                but if add 65 to (n % 26) ,then we get the next element , for eg :\\n                \\n                n = 701 then 701 % 26 = 25 --> chr(25+65) == Z , but we need Y (as columnuber = Y ) \\n                therefore :\\n                we are n = n - 1 in step 1 ,\\n                n -> 700 , 700 % 26 = 24 --> chr(24+65) == Y\\n                \\n        step4: we divide it with 26 to jump to the next columnumber(B) (as it varies through 26^n) \\n        \\n        step5 : repeat while n > 0 \\n        \\n        step 6 : return the reverse eg : we are jumping from A to D in (ABCD)\\n        \\n       \\'\\'\\'\\n```\n```\\n\\'\\'\\'\\n\\t    n = 701\\n        n-1 = 700\\n        700 % 26 = 24\\n        res += chr(24+65) == Y\\n        n = 700 // 26 == 26\\n        \\n        n = 26\\n        n-1 = 25\\n        25 % 26 = 25 -> if a > b and a % b then (a % b = a) always\\n        res += chr(25+65) == Z\\n        n = 25 // 26 ==> 0\\n\\t\\t\\n\\t\\t\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51522,
                "title": "0-ms-java-solution",
                "content": "    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            int r = n % 26;\\n            n = n/26;\\n            if (r != 0){\\n                sb.append((char)(r - 1 + 'A'));\\n            } else {\\n                sb.append('Z');\\n                n--;\\n            }\\n            \\n        }\\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            int r = n % 26;\\n            n = n/26;\\n            if (r != 0){\\n                sb.append((char)(r - 1 + 'A'));\\n            } else {\\n                sb.append('Z');\\n                n--;\\n            }\\n            \\n        }\\n        return sb.reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3946989,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nConvert to base 26 system.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 246 videos as of August 22nd.\\n\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/q8DkXSns3Xk\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n**Initialization:**\\n- Initialize an empty string `res` to store the resulting column title.\\n\\n**Conversion Loop:**\\n- Enter a loop while `columnNumber` is greater than 0.\\n    - Decrement `columnNumber` by 1 to account for 1-based indexing in column titles.\\n    - Calculate the remainder of `columnNumber` divided by 26. This remainder will represent the position of the current letter in the alphabet (0 to 25).\\n    - Convert the calculated remainder to its corresponding uppercase letter using `chr((columnNumber % 26) + ord(\"A\"))`.\\n    - Add the calculated letter to the beginning of the `res` string.\\n    - Update `columnNumber` by performing integer division (floor division) by 26. This shifts to the next position in the column title.\\n\\n**Return:**\\n- Return the final `res` string, which represents the column title in Excel sheet notation.\\n\\nThis algorithm processes a given column number and converts it into its corresponding column title using a base-26 numbering system.\\n\\n# Complexity\\n- Time complexity:O(log26 n)\\nn is a given column number.\\n\\n- Space complexity: O(log26 n)\\n\\n```python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res = \"\"\\n\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\"A\")) + res\\n            columnNumber //= 26\\n        \\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let res = \"\";\\n\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        res = String.fromCharCode((columnNumber % 26) + \"A\".charCodeAt(0)) + res;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    \\n    return res;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res.insert(0, (char) ((columnNumber % 26) + \\'A\\'));\\n            columnNumber /= 26;\\n        }\\n        \\n        return res.toString();        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res = char((columnNumber % 26) + \\'A\\') + res;\\n            columnNumber /= 26;\\n        }\\n        \\n        return res;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res = \"\"\\n\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\"A\")) + res\\n            columnNumber //= 26\\n        \\n        return res\\n```\n```javascript []\\n/**\\n * @param {number} columnNumber\\n * @return {string}\\n */\\nvar convertToTitle = function(columnNumber) {\\n    let res = \"\";\\n\\n    while (columnNumber > 0) {\\n        columnNumber--;\\n        res = String.fromCharCode((columnNumber % 26) + \"A\".charCodeAt(0)) + res;\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n    \\n    return res;    \\n};\\n```\n```java []\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res.insert(0, (char) ((columnNumber % 26) + \\'A\\'));\\n            columnNumber /= 26;\\n        }\\n        \\n        return res.toString();        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n\\n        while (columnNumber > 0) {\\n            columnNumber--;\\n            res = char((columnNumber % 26) + \\'A\\') + res;\\n            columnNumber /= 26;\\n        }\\n        \\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945233,
                "title": "one-line-simple-c-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code converts an Excel column number to its corresponding title. It iteratively derives characters by mapping values to letters, then appends them to the title.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere are the two key points of the approach:\\n\\n1. **Recursive Conversion:**\\n   - The base case of the recursion is when `columnNumber` is 0, in which case an empty string is returned.\\n   - For non-zero `columnNumber`, it is decremented by 1 (`--columnNumber`) before performing further calculations. This adjustment aligns the numbering to be 0-based, making calculations easier.\\n\\n2. **Mapping to Characters:**\\n   - The function recursively calls itself with the adjusted `columnNumber/26` value, which represents the quotient of dividing the current column number by 26.\\n   - The `(char)(columnNumber%26+\\'A\\')` expression calculates the corresponding letter for the remainder of the division by 26. Adding `\\'A\\'` ensures that the remainder values map to ASCII characters \\'A\\' to \\'Z\\'.\\n   - The calculated letter is appended to the result of the recursive call, effectively building the column title from right to left.\\n\\nIn summary, the code cleverly utilizes recursion to convert the column number into its corresponding title by iteratively dividing and calculating remainder values to map them to characters \\'A\\' to \\'Z\\'. This approach allows for an elegant solution to the problem.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        return (columnNumber==0)?\"\":convertToTitle(--columnNumber/26)+(char)(columnNumber%26+\\'A\\');\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4806dbc5-f4c6-425e-8926-6686940dd2af_1692707036.9495242.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        return (columnNumber==0)?\"\":convertToTitle(--columnNumber/26)+(char)(columnNumber%26+\\'A\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791402,
                "title": "100-faster-solution-in-cpp-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber > 0){\\n            int tmp = columnNumber % 26;\\n\\t\\t\\tif(tmp == 0){    // if tmp is zero this value is (tmp + \\'A\\' - 1) is out of Ascii Captial letters, which is \\'Z\\' (desired value)\\n                ans += \\'Z\\';\\n                columnNumber--;   // If its is a multiple of 26 we need to decrement 1 from it to get desired o/p\\n            }\\n            else{\\n                ans += tmp + \\'A\\' - 1;\\n            }\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Find Helpful Upvote it**\\n**For Detailed DSA Solutions and Applications refer to Respective README files**\\nhttps://github.com/teja963/Advanced-DSA\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber > 0){\\n            int tmp = columnNumber % 26;\\n\\t\\t\\tif(tmp == 0){    // if tmp is zero this value is (tmp + \\'A\\' - 1) is out of Ascii Captial letters, which is \\'Z\\' (desired value)\\n                ans += \\'Z\\';\\n                columnNumber--;   // If its is a multiple of 26 we need to decrement 1 from it to get desired o/p\\n            }\\n            else{\\n                ans += tmp + \\'A\\' - 1;\\n            }\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51477,
                "title": "my-short-java-solution-without-using-string-buffer-and-string-builder",
                "content": "    public class Solution {\\n    public static String convertToTitle(int n) {\\n      int fac=26;String s=\"\";\\n        while(n>0){\\n            n--;\\n            s=(char)(n%26+'A')+s;\\n            n/=fac;\\n        }\\n        return s;\\n    }    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static String convertToTitle(int n) {\\n      int fac=26;String s=\"\";\\n        while(n>0){\\n            n--;\\n            s=(char)(n%26+'A')+s;\\n            n/=fac;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3943544,
                "title": "0-ms-c-solution-clean-code",
                "content": "# Intuition: \\n**Prime Facorisation to find Binary number but here with a bit of twist , base is 26 insted of 2**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\nHere we run a while Loop.\\n\\nCase 1:**If the number is not exactly divisible by 2** : The remainder is converted to its corresponding character and push in the answer string(1-->A , 2-->B , 3-->C,.......) and the number is divided by 26 and then the loop is continued.\\n\\nCase 2: **If the number is exactly divisible by 26**: The number is changed to Quotient -1  and \\'Z\\' is pushed to the answer string.\\n\\nThe loop is run till columnNumber becomes 0\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn base 26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber){\\n           if(columnNumber%26!=0){\\n                int x = columnNumber%26;\\n            ans.push_back(x+64);\\n            columnNumber/=26;\\n           }\\n           else{\\n               ans.push_back(\\'Z\\');\\n               int x = columnNumber/26;\\n               columnNumber = x-1;\\n           }\\n        }\\n        reverse(ans.begin() ,ans.end());\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Please Upvote\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;\\n        while(columnNumber){\\n           if(columnNumber%26!=0){\\n                int x = columnNumber%26;\\n            ans.push_back(x+64);\\n            columnNumber/=26;\\n           }\\n           else{\\n               ans.push_back(\\'Z\\');\\n               int x = columnNumber/26;\\n               columnNumber = x-1;\\n           }\\n        }\\n        reverse(ans.begin() ,ans.end());\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810143,
                "title": "very-easy-c-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Consider this problem same as changing any_base number to base_10 number.\\n- This problem requires a number system conversion.\\n- We need to convert the base(10) input to base(26).\\n- But there\\'s a catch. Excel system has range: [1, 26], whereas base(26) has range: [0, 25].\\n# How to retrive letters\\n<!-- Describe your approach to solving the problem. -->\\n```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int colNum) {\\n        // Just convert colNum into the 26 base Alpabets\\n        string res =\"\";\\n        while(colNum > 0){\\n            colNum--;\\n            res = char(colNum % 26 + \\'A\\') + res;\\n            colNum /= 26;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\ncolumnNumber = (26^2)*(A+1) + (26^1)*(X+1) + (26^0)*(Y+1)  \\n// to retrieve Y\\n    // 26^0 is just 1, so there is (1)*(Y+1)\\n    // to retrieve Y, subtract 1 from both side, then divide both side by 26, the remainder will be Y\\n\\n// Subtracting 1 from both sides\\ncolumnNumber-1 = (26^2)*(A+1) + (26^1)*(X+1) + Y\\n\\n// dividing both sides by 26\\ncolumnNumber-1 = (26^1)*(A+1) + (26^0)*(X+1)\\nrem = Y\\n\\n// If you observe, we have just reduced our problem size, we have to continue this process until we run out of numbers(i.e: columnNumber becomes 0)\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int colNum) {\\n        // Just convert colNum into the 26 base Alpabets\\n        string res =\"\";\\n        while(colNum > 0){\\n            colNum--;\\n            res = char(colNum % 26 + \\'A\\') + res;\\n            colNum /= 26;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362699,
                "title": "java-no-excel",
                "content": "\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder row = new StringBuilder();\\n        while (columnNumber > 0)\\n        {\\n            columnNumber--;\\n            row.insert(0,(char)(\\'A\\' + columnNumber % 26));\\n            columnNumber = columnNumber / 26;\\n        }\\n        return row.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder row = new StringBuilder();\\n        while (columnNumber > 0)\\n        {\\n            columnNumber--;\\n            row.insert(0,(char)(\\'A\\' + columnNumber % 26));\\n            columnNumber = columnNumber / 26;\\n        }\\n        return row.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549843,
                "title": "java-0ms-100-while-loop",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(n > 0){\\n            int rem = (n-1)%26;\\n            sb.append((char)(\\'A\\' + rem));\\n            n = (n-1)/26;\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        while(n > 0){\\n            int rem = (n-1)%26;\\n            sb.append((char)(\\'A\\' + rem));\\n            n = (n-1)/26;\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267024,
                "title": "c-100-faster-easy-clean-recursive-2-lines-only",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if(columnNumber-- == 0) return \"\";\\n        return convertToTitle(columnNumber / 26) + (char)((columnNumber % 26) + \\'A\\');\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        if(columnNumber-- == 0) return \"\";\\n        return convertToTitle(columnNumber / 26) + (char)((columnNumber % 26) + \\'A\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875696,
                "title": "python3-simple-solution-faster-than-98",
                "content": "```\\nimport string\\n\\nalphabet = string.ascii_uppercase\\n\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        result = \"\"\\n\\n        while n > 0:\\n            n -= 1\\n\\n            n, i = divmod(n, 26)\\n            result += alphabet[i]\\n\\n        return result[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport string\\n\\nalphabet = string.ascii_uppercase\\n\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        result = \"\"\\n\\n        while n > 0:\\n            n -= 1\\n\\n            n, i = divmod(n, 26)\\n            result += alphabet[i]\\n\\n        return result[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 51510,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            int num;\\n            int number = n;\\n            string s, ss;\\n            while(number>0)\\n            {\\n                number = number-1;\\n                num = number%26;\\n                ss = 'A' + num;\\n                s = ss + s;\\n                number = number/26;\\n            }\\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            int num;\\n            int number = n;\\n            string s, ss;\\n            while(number>0)\\n            {\\n                number = number-1;\\n                num = number%26;\\n                ss = 'A' + num;\\n                s = ss + s;\\n                number = number/26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51607,
                "title": "c-just-a-problem-of-base-conversion",
                "content": "Convert base10/demical number n into \"base26\" string. \\n\\n(Note that there is **no \"zero\"** in A~Z, thus we regard it base26 instead of base27).\\n\\n1~26 represent A~Z separately. 27 represents \"AA\". \\nWhile in common presentation of baseX(binary, octal, ...),  27 should represent \"A0\".\\n\\nThe peoblem can be easily solved by iteration of \"mod 26 and divided by 26\".\\n\\n    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if(n < 1)\\n                return \"\";\\n            else\\n            {\\n                string result = \"\";\\n                while(n)\\n                {//get every letter in n from right to left\\n                    n --;\\n                    char c = n%26 + 'A';\\n                    result += c;\\n                    n /= 26;\\n                }\\n                reverse(result.begin(), result.end());\\n                return result;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if(n < 1)\\n                return \"\";\\n            else\\n            {\\n                string result = \"\";\\n                while(n)\\n                {//get every letter in n from right to left\\n                    n --;\\n                    char c = n%26 + 'A';\\n                    result += c;\\n                    n /= 26;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3943414,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:       \\n        ans=\"\"        \\n        while columnNumber>0:\\n            c=chr(ord(\\'A\\')+(columnNumber-1)%26)\\n            ans=c+ans\\n            columnNumber=(columnNumber-1)//26            \\n        return ans         \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:       \\n        ans=\"\"        \\n        while columnNumber>0:\\n            c=chr(ord(\\'A\\')+(columnNumber-1)%26)\\n            ans=c+ans\\n            columnNumber=(columnNumber-1)//26            \\n        return ans         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270141,
                "title": "python-easy-to-understand-solution",
                "content": "Please upvote if you like it.\\n```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n        ans=\"\"\\n        while num > 0:\\n            num -= 1\\n            ans = chr(num % 26 + 65) + ans\\n            num //= 26\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Please upvote if you like it.\\n```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n        ans=\"\"\\n        while num > 0:\\n            num -= 1\\n            ans = chr(num % 26 + 65) + ans\\n            num //= 26\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3212735,
                "title": "168-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo get the title, we can use the integer value of the alphabet characters to get their corresponding value.\\n\\nWe can loop through the columnNumber to get the corresponding column title. If the columnNumber is zero, then we can break the loop.\\n\\nTo get the column title, we can use the ASCII code of the alphabet characters. The ASCII code for the letter \"A\" is 65. Therefore, we can subtract 1 from the columnNumber and take the modulus of 26. This will give us the corresponding letter in the title. We can then append the corresponding letter to the title string.\\n\\nWe can then update the columnNumber by dividing it by 26 and taking the floor division. This will give us the new columnNumber that we can use for the next iteration of the loop.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n90.36%\\n\\n- Space complexity:\\nBeats\\n46.90%\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            title = chr(columnNumber % 26 + 65) + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            title = chr(columnNumber % 26 + 65) + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091641,
                "title": "100-faster-95-74-less-memory-c",
                "content": "I decrement the columnNumber by 1 everytime just to make remainder work with the expression **(columnNumber%26 + \\'A\\')**.\\n**I match not 1 to \\'A\\' but 0 to \\'A\\'**, so that when I add the remainder to \\'A\\' (which has the value range 0-25), it **correctly matches the intended letter**.\\nDo comment down in case of any queries or remarks.\\n**Please upvote if you find the algorithm useful.\\n*Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309650,
                "title": "python-20-ms-faster-than-98",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        ans = \"\"\\n        \\n        while columnNumber:\\n            columnNumber -= 1\\n            ans = chr(65 + columnNumber % 26) + ans\\n            columnNumber //= 26\\n        \\n        return ans\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        ans = \"\"\\n        \\n        while columnNumber:\\n            columnNumber -= 1\\n            ans = chr(65 + columnNumber % 26) + ans\\n            columnNumber //= 26\\n        \\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 453496,
                "title": "javascript-solution-99-5-faster",
                "content": "Runtime: 40 ms, faster than 99.54% of JavaScript online submissions for Excel Sheet Column Title.\\nMemory Usage: 33.8 MB, less than 75.00% of JavaScript online submissions for Excel Sheet Column Title.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    \\n    let charMap = {\\n        0: \"Z\",\\n        1: \"A\",\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\"\\n    };\\n    \\n    \\n    let title = \"\";\\n    \\n    if (n <= 26) {\\n        return charMap[n%26]\\n    }\\n    \\n    while (n > 0) {\\n        let r = n%26;\\n       \\n        n = Math.floor(n/26);\\n        \\n        if (r == 0) {\\n            r = 0;\\n            n = n-1;\\n        }\\n        title = charMap[r] + title;\\n    }\\n    \\n    return title;\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    \\n    let charMap = {\\n        0: \"Z\",\\n        1: \"A\",\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\"\\n    };\\n    \\n    \\n    let title = \"\";\\n    \\n    if (n <= 26) {\\n        return charMap[n%26]\\n    }\\n    \\n    while (n > 0) {\\n        let r = n%26;\\n       \\n        n = Math.floor(n/26);\\n        \\n        if (r == 0) {\\n            r = 0;\\n            n = n-1;\\n        }\\n        title = charMap[r] + title;\\n    }\\n    \\n    return title;\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354651,
                "title": "javascript-100-faster-easy-to-understand-code",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    if (n < 27) return String.fromCharCode(n + 64);\\n    var s = \\'\\';\\n    while (n > 0) {\\n        var temp = n % 26;\\n        temp = temp == 0 ? 26 : temp;\\n        s = String.fromCharCode(temp + 64) + s;\\n        n -= temp;\\n        n /= 26;\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    if (n < 27) return String.fromCharCode(n + 64);\\n    var s = \\'\\';\\n    while (n > 0) {\\n        var temp = n % 26;\\n        temp = temp == 0 ? 26 : temp;\\n        s = String.fromCharCode(temp + 64) + s;\\n        n -= temp;\\n        n /= 26;\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326380,
                "title": "heavily-commented-long-division-javascript-solution",
                "content": "I wrote this one prior to lookig at all the short solutions, and though mine is quite a bit more code, I still thought it\\'d be interesting to share. It does run pretty fast, better than ~90%.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    // General idea: do long division with base 26\\n    // To do that, we need to build up a map of 26^0, 26^1, 26^2 etc\\n    // We do that in a while loop, until we reach a exp that\\'s bigger than n\\n    // Now we do long devision and store the numbers in an array\\n    \\n    // There\\'s a problem though: it\\'s not really base 26, as we can\\'t have zeroes\\n    // To fix that, there is a loop that turns zeroes into 26\\'s by borrowing 1 from 26^next\\n    \\n    // Then we can use fromCharCode(int) to turn numbers into letters    \\n    // String.fromCharCode() return will return A @ 65, Z @ 90 \\n    \\n    // Check for bad input\\n    if (!n) {\\n        return \\'\\';\\n    }\\n    \\n    // Fill up map to get the base 26 numbers\\n    let map = {\\n        0: 1,\\n        1: 26\\n    };\\n    let counter = 1;\\n    let result = 26;\\n      \\n    while (result < n) {\\n        result = result * 26;\\n        counter++;\\n        map[counter] = result;\\n    }\\n        \\n    // Long division part\\n    let i, l;\\n    let out = [];\\n    let remainder = n;\\n    for (i = counter - 1; i >= 0; i--) {\\n        \\n        // how many times can we take 26^i out of n ?\\n        let divisions = Math.floor(remainder / map[i]);\\n       \\n        // do that \\n        remainder = remainder - (divisions * map[i]);\\n        \\n        // record it\\n        out.push(divisions);\\n    }\\n    \\n    // Fix zeroes. Out can be something like [2,0,1], that should become [1,26,1]\\n    for (i = out.length - 1; i > 0; i--) {\\n        if (out[i] === 0) {\\n            out[i] = 26;\\n            out[i-1] = out[i-1] - 1;\\n        }   \\n    }\\n\\n    // Finally, convert the numbers to letters\\n    let title = \\'\\';\\n    for (i = 0, l = out.length; i < l; i++) {\\n        if (out[i] !== 0) {\\n            title += String.fromCharCode(out[i] + 64);\\n        }\\n    }\\n    \\n    return title;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar convertToTitle = function(n) {\\n    // General idea: do long division with base 26\\n    // To do that, we need to build up a map of 26^0, 26^1, 26^2 etc\\n    // We do that in a while loop, until we reach a exp that\\'s bigger than n\\n    // Now we do long devision and store the numbers in an array\\n    \\n    // There\\'s a problem though: it\\'s not really base 26, as we can\\'t have zeroes\\n    // To fix that, there is a loop that turns zeroes into 26\\'s by borrowing 1 from 26^next\\n    \\n    // Then we can use fromCharCode(int) to turn numbers into letters    \\n    // String.fromCharCode() return will return A @ 65, Z @ 90 \\n    \\n    // Check for bad input\\n    if (!n) {\\n        return \\'\\';\\n    }\\n    \\n    // Fill up map to get the base 26 numbers\\n    let map = {\\n        0: 1,\\n        1: 26\\n    };\\n    let counter = 1;\\n    let result = 26;\\n      \\n    while (result < n) {\\n        result = result * 26;\\n        counter++;\\n        map[counter] = result;\\n    }\\n        \\n    // Long division part\\n    let i, l;\\n    let out = [];\\n    let remainder = n;\\n    for (i = counter - 1; i >= 0; i--) {\\n        \\n        // how many times can we take 26^i out of n ?\\n        let divisions = Math.floor(remainder / map[i]);\\n       \\n        // do that \\n        remainder = remainder - (divisions * map[i]);\\n        \\n        // record it\\n        out.push(divisions);\\n    }\\n    \\n    // Fix zeroes. Out can be something like [2,0,1], that should become [1,26,1]\\n    for (i = out.length - 1; i > 0; i--) {\\n        if (out[i] === 0) {\\n            out[i] = 26;\\n            out[i-1] = out[i-1] - 1;\\n        }   \\n    }\\n\\n    // Finally, convert the numbers to letters\\n    let title = \\'\\';\\n    for (i = 0, l = out.length; i < l; i++) {\\n        if (out[i] !== 0) {\\n            title += String.fromCharCode(out[i] + 64);\\n        }\\n    }\\n    \\n    return title;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 319399,
                "title": "javascript-solution-using-recursion",
                "content": "```\\nvar convertToTitle = function(n) {\\n     n = n - 1;\\n    if(n>=0&&n<26){\\n        return String.fromCharCode(65+n);\\n    }\\n    return convertToTitle(parseInt(n/26)) + convertToTitle((n%26)+1);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar convertToTitle = function(n) {\\n     n = n - 1;\\n    if(n>=0&&n<26){\\n        return String.fromCharCode(65+n);\\n    }\\n    return convertToTitle(parseInt(n/26)) + convertToTitle((n%26)+1);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51400,
                "title": "python-recursion",
                "content": "Surprisingly low acceptance rate for this one, just share my super beginner code here.\\n```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n <= 26:\\n            return chr(n -1 + 65)\\n        \\n        return self.convertToTitle((n-1)//26) + chr((n-1)% 26 + 65)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n <= 26:\\n            return chr(n -1 + 65)\\n        \\n        return self.convertToTitle((n-1)//26) + chr((n-1)% 26 + 65)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51405,
                "title": "javascript-1-line-code",
                "content": "```\\nreturn n === 0 ? '' : convertToTitle(~~(--n / 26)) + String.fromCharCode('A'.charCodeAt() + (n % 26));\\n```",
                "solutionTags": [],
                "code": "```\\nreturn n === 0 ? '' : convertToTitle(~~(--n / 26)) + String.fromCharCode('A'.charCodeAt() + (n % 26));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51462,
                "title": "44-ms-python-solution-with-clear-explanations",
                "content": "let [\\u03b2n \\u03b2n-1 ... \\u03b21] be a n-char string, so the number it represents is \\u03b2n * 26^(n-1) + \\u03b2n-1 * 26^(n-1-1) + ... + \\u03b21 * 26^(1-1)\\n\\nfor example:\\nA B C = A * 26^2 + B * 26^1 + C * 26^0\\n        = 1 * 26^2 + 2 * 26^1 + 3\\n\\nZ Z Z = Z * 26^2 + Z * 26^1 + Z * 26^0\\n       = 26 * 26^2 + 26 * 26^1 + 26\\n\\nTo convert the number into string, we can always get the \"small part\" which is less or equal than 26.\\nWe can divide the number by 26 recursively, the tricky part here is that when the remainder is 0, it means that the \"small part\" is exactly 26, so you must subtract the current number by 1. Here is the code:\\n\\n```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        resStr = \"\"\\n        numMod = n # in  case that n is 0 or less\\n        while True:\\n            if numMod <= 0:\\n                break\\n            numMod, numRem = divmod(numMod, 26)\\n            if numRem == 0:\\n                numMod -= 1\\n                resStr = \"Z\"+resStr\\n            else:\\n                resStr = chr(64+numRem)+resStr #ord(A) = 65\\n                \\n        return resStr\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        resStr = \"\"\\n        numMod = n # in  case that n is 0 or less\\n        while True:\\n            if numMod <= 0:\\n                break\\n            numMod, numRem = divmod(numMod, 26)\\n            if numRem == 0:\\n                numMod -= 1\\n                resStr = \"Z\"+resStr\\n            else:\\n                resStr = chr(64+numRem)+resStr #ord(A) = 65\\n                \\n        return resStr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51488,
                "title": "simple-java-solution-with-stringbuilder",
                "content": "    public String convertToTitle(int n) {\\n            StringBuilder str = new StringBuilder();\\n            int remainder = 0;\\n            while(n > 0){\\n                remainder = (n-1) % 26;\\n                str.insert(0, (char)(remainder + 'A'));\\n                n = (n - remainder) / 26;\\n            }\\n            return str.toString();\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String convertToTitle(int n) {\\n            StringBuilder str = new StringBuilder();\\n            int remainder = 0;\\n            while(n > 0){\\n                remainder = (n-1) % 26;\\n                str.insert(0, (char)(remainder + 'A'));\\n                n = (n - remainder) / 26;\\n            }\\n            return str.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 51525,
                "title": "0-ms-5-lines-c",
                "content": "    string convertToTitle(int n) {\\n        string res;\\n        while(n>=1){\\n            res=(char)('A'+(n-1)%26)+res;\\n            n=(n-1)/26;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    string convertToTitle(int n) {\\n        string res;\\n        while(n>=1){\\n            res=(char)('A'+(n-1)%26)+res;\\n            n=(n-1)/26;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3944038,
                "title": "python-3-6-lines-rotated-string-t-m-100-100",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n\\n        alpha, ans = \\'Z\\'+ ascii_uppercase, \"\"\\n\\n        while n:\\n            n, r = divmod(n,26)\\n            ans = alpha[r] + ans\\n            if not r: n-= 1\\n        return ans\\n```\\n[https://leetcode.com/problems/excel-sheet-column-title/submissions/611614578/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(log*N*) and space complexity is *O*(1), in which *N* ~ `n`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n\\n        alpha, ans = \\'Z\\'+ ascii_uppercase, \"\"\\n\\n        while n:\\n            n, r = divmod(n,26)\\n            ans = alpha[r] + ans\\n            if not r: n-= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943044,
                "title": "daily-leetcoding-challenge-august-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-title/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-title/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3065850,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI knew I would have to use some kind algorithem like converting to binary, so I basically did that. TO convert from the decimal equivalents I took from the ASCII table where 65 is \\'A\\' and I added the corresponding amount to get the values.\\nThen I would add it to the end and go on to the next one.\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        std::string result {};\\n        while(columnNumber>0){\\n            columnNumber-=1;\\n            result.insert(result.begin(),65+columnNumber%26);\\n            columnNumber/=26;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        std::string result {};\\n        while(columnNumber>0){\\n            columnNumber-=1;\\n            result.insert(result.begin(),65+columnNumber%26);\\n            columnNumber/=26;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744123,
                "title": "easy-to-understand-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. We can think of the solution by just pure mathematical derivation which can be done once you get hold of the pattern through some examples.\\n\\n2. We can also think of it like a n-base number system where there\\'s no 0-based counting (as per the excel format), or you may eventually get to this through the above said calculations.\\n\\n# Approach (as per intuition 1 of mathematical derivation)\\n<!-- Describe your approach to solving the problem. -->\\n- For each character, we need to see if the columnNumber is divisible by 26 or not. So if we get any remainder rem, then curr will be rem - 1 + \\'A\\', otherwise if rem is 0 but columNumber / 26 is greater than 0 then it would mean that there is a \\'Z\\' there.\\n- So, in the while loop, we will be checking for the above and then update ans to be curr + ans so as to add the curr in front of the previously found character, till columnNumber is greater than 0.\\n\\n# Complexity\\n- Time complexity: O(1) [I don\\'t think it\\'s linear but correct me if I\\'m wrong.]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) [A single string is maintained(curr is calculated each time).]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans = \"\", curr = \"\";\\n        int rem = 0;\\n        \\n        while(columnNumber > 0){\\n            rem = columnNumber % 26 ? columnNumber % 26 - 1 : 25;\\n            curr = rem + 65;\\n            ans = curr + ans;\\n            columnNumber = (columnNumber - rem) / 26;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans = \"\", curr = \"\";\\n        int rem = 0;\\n        \\n        while(columnNumber > 0){\\n            rem = columnNumber % 26 ? columnNumber % 26 - 1 : 25;\\n            curr = rem + 65;\\n            ans = curr + ans;\\n            columnNumber = (columnNumber - rem) / 26;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661322,
                "title": "easy-and-efficient-solution-c",
                "content": "string convertToTitle(int num) {\\n        \\n        string s;\\n       num =num-1;\\n        \\n        while(num >= 26)\\n        {\\n            int temp = num % 26 ;\\n            s+=char(temp +65);\\n            num = num / 26-1;\\n        }\\n        \\n         if(num <= 26)\\n        s+=char(num+65);\\n         \\n        for(int i = 0 ; i < s.size()/2 ; i++)\\n           swap(s[i],s[s.size()-1-i]);\\n        \\n        return s;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "string convertToTitle(int num) {\\n        \\n        string s;\\n       num =num-1;\\n        \\n        while(num >= 26)\\n        {\\n            int temp = num % 26 ;\\n            s+=char(temp +65);\\n            num = num / 26-1;\\n        }\\n        \\n         if(num <= 26)\\n        s+=char(num+65);\\n         \\n        for(int i = 0 ; i < s.size()/2 ; i++)\\n           swap(s[i],s[s.size()-1-i]);\\n        \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2503369,
                "title": "simple-1-line-solution-java-c-python-0ms-solution",
                "content": "Java:\\n\\n```return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)(\\'A\\' + (n % 26));```\\nC++:\\n\\n```return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + \\'A\\');```\\nupdate: because the behavior of different compilers, the safe version should be:\\n\\n```return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + \\'A\\');```\\nPython:\\n\\n```return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord(\\'A\\'))```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```return n == 0 ? \"\" : convertToTitle(--n / 26) + (char)(\\'A\\' + (n % 26));```\n```return n == 0 ? \"\" : convertToTitle(n / 26) + (char) (--n % 26 + \\'A\\');```\n```return n == 0 ? \"\" : convertToTitle((n - 1) / 26) + (char) ((n - 1) % 26 + \\'A\\');```\n```return \"\" if num == 0 else self.convertToTitle((num - 1) / 26) + chr((num - 1) % 26 + ord(\\'A\\'))```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455909,
                "title": "a-simple-clear-solution",
                "content": "```\\nvar convertToTitle = function(columnNumber) {\\n    let ans = \\'\\'\\n\\n    while(columnNumber>0){\\n        let code = (--columnNumber)%26\\n        ans = String.fromCharCode(code+65) + ans\\n        columnNumber = (columnNumber-code)/26\\n    }\\n    \\n    return ans\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/db6b7b2f-1ed7-48ae-b777-4a4ba4d49c1d_1661030020.5921524.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertToTitle = function(columnNumber) {\\n    let ans = \\'\\'\\n\\n    while(columnNumber>0){\\n        let code = (--columnNumber)%26\\n        ans = String.fromCharCode(code+65) + ans\\n        columnNumber = (columnNumber-code)/26\\n    }\\n    \\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886303,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        res = \\'\\'\\n        \\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\\'A\\')) + res\\n            columnNumber //= 26\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        res = \\'\\'\\n        \\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            res = chr((columnNumber % 26) + ord(\\'A\\')) + res\\n            columnNumber //= 26\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790579,
                "title": "python-o-1-space",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        result = \\'\\'\\n            \\n        while(columnNumber):\\n            columnNumber -= 1\\n            charValue = (columnNumber % 26) \\n            columnNumber //= 26\\n            \\n            result = chr(charValue + ord(\\'A\\')) + result\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        \\n        result = \\'\\'\\n            \\n        while(columnNumber):\\n            columnNumber -= 1\\n            charValue = (columnNumber % 26) \\n            columnNumber //= 26\\n            \\n            result = chr(charValue + ord(\\'A\\')) + result\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628320,
                "title": "python-recursive-solution-faster-than-94-submissions",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str: \\n        \\n        if columnNumber==0:\\n            return \\'\\'\\n        \\n        q,r=divmod(columnNumber-1,26)\\n        \\n        return self.convertToTitle(q)+chr(r+ord(\\'A\\'))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str: \\n        \\n        if columnNumber==0:\\n            return \\'\\'\\n        \\n        q,r=divmod(columnNumber-1,26)\\n        \\n        return self.convertToTitle(q)+chr(r+ord(\\'A\\'))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339063,
                "title": "detailed-explanation",
                "content": "Only took me like five hours to *kinda* understand how this works.\\n\\n```ts\\n// N: column number\\n// Time: O(log N)\\n// Space: O(1) not including space reserved for output\\n\\nfunction convertToTitle(columnNumber: number): string {\\n    const CHAR_CODE_OFFSET = \"A\".charCodeAt(0);\\n    const letters: string[] = [];\\n\\n    let num = columnNumber;\\n    while (num > 0) {\\n        // Our conversion logic expects 0-based numbers, but Excel uses 1-based\\n        num--;\\n\\n        // Convert coefficient in 1s place to Excel column letter\\n        const leastSigBitCoeff = num % 26;\\n        const charCode = leastSigBitCoeff + CHAR_CODE_OFFSET;\\n        letters.unshift(String.fromCharCode(charCode));\\n\\n        // Shift coefficients right (10s place => 1s place)\\n        num = Math.floor(num / 26);\\n    }\\n\\n    return letters.join(\"\");\\n};\\n\\n/*\\nExplanation:\\nA normal base26 system maps A => 0, B => 1, ..., Z => 25\\nWith Excel, the mapping is A => 1, B => 2, ..., Z => 26\\n\\nEquation for a given number n in a normal base26 system, where coefficients range from [0, 25]:\\nn = (c2)26^2 + (c1)26^1 + (c0)26^0\\n\\nTo translate this to Excel\\'s system, we +1 all our coefficients, which now range from [1, 26]:\\nn = (c2+1)26^2 + (c1+1)26^1 + (c0+1)26^0\\n\\nOur conversion logic works by extracting the coefficient at the 1s place (c0), then shifting\\nthe coefficients to the right, where they will be extracted in future loop iterations.\\n\\nHere\\'s how to extract out the coefficient:\\n1. We start with our equation:\\n\\n    n = (c2+1)26^2 + (c1+1)26^1 + (c0+1)\\n\\n2. We then subtract 1 from each side. This is important otherwise c0+1 could be 26, which will\\n   throw off the modulo and division steps.\\n\\n    n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n3. We can then get c0 with modulo 26:\\n\\n    c0 = (n-1) % 26\\n\\nTo shift the coefficients to the right for the next iteration:\\n1. Start with our n-1 equation\\n\\n        n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n2. Divide by 26 then floor result to remove c0 and shift remaining terms\\n\\n    (n-1) / 26 = (c2+1)26^1 + (c1+1)\\n*/\\n```",
                "solutionTags": [],
                "code": "```ts\\n// N: column number\\n// Time: O(log N)\\n// Space: O(1) not including space reserved for output\\n\\nfunction convertToTitle(columnNumber: number): string {\\n    const CHAR_CODE_OFFSET = \"A\".charCodeAt(0);\\n    const letters: string[] = [];\\n\\n    let num = columnNumber;\\n    while (num > 0) {\\n        // Our conversion logic expects 0-based numbers, but Excel uses 1-based\\n        num--;\\n\\n        // Convert coefficient in 1s place to Excel column letter\\n        const leastSigBitCoeff = num % 26;\\n        const charCode = leastSigBitCoeff + CHAR_CODE_OFFSET;\\n        letters.unshift(String.fromCharCode(charCode));\\n\\n        // Shift coefficients right (10s place => 1s place)\\n        num = Math.floor(num / 26);\\n    }\\n\\n    return letters.join(\"\");\\n};\\n\\n/*\\nExplanation:\\nA normal base26 system maps A => 0, B => 1, ..., Z => 25\\nWith Excel, the mapping is A => 1, B => 2, ..., Z => 26\\n\\nEquation for a given number n in a normal base26 system, where coefficients range from [0, 25]:\\nn = (c2)26^2 + (c1)26^1 + (c0)26^0\\n\\nTo translate this to Excel\\'s system, we +1 all our coefficients, which now range from [1, 26]:\\nn = (c2+1)26^2 + (c1+1)26^1 + (c0+1)26^0\\n\\nOur conversion logic works by extracting the coefficient at the 1s place (c0), then shifting\\nthe coefficients to the right, where they will be extracted in future loop iterations.\\n\\nHere\\'s how to extract out the coefficient:\\n1. We start with our equation:\\n\\n    n = (c2+1)26^2 + (c1+1)26^1 + (c0+1)\\n\\n2. We then subtract 1 from each side. This is important otherwise c0+1 could be 26, which will\\n   throw off the modulo and division steps.\\n\\n    n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n3. We can then get c0 with modulo 26:\\n\\n    c0 = (n-1) % 26\\n\\nTo shift the coefficients to the right for the next iteration:\\n1. Start with our n-1 equation\\n\\n        n-1 = (c2+1)26^2 + (c1+1)26^1 + c0\\n\\n2. Divide by 26 then floor result to remove c0 and shift remaining terms\\n\\n    (n-1) / 26 = (c2+1)26^1 + (c1+1)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225914,
                "title": "java-recursion",
                "content": "Solution using recursion\\n\\n\\tclass Solution {\\n\\t\\tpublic String alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\t\\tString title=\"\";\\n\\t\\tpublic String convertToTitle(int columnNumber) {\\n\\t\\t\\tif(columnNumber <= 26){\\n\\t\\t\\t\\t return Character.toString(alphabet.charAt(columnNumber-1));\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tint rem =columnNumber%26;\\n\\t\\t\\t\\tint qu =columnNumber/26;\\n\\t\\t\\t\\tif(rem==0){\\n\\t\\t\\t\\t\\ttitle = convertToTitle(qu-1).concat(convertToTitle(26));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t title = convertToTitle(qu).concat(convertToTitle(rem));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn title;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic String alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n\\t\\tString title=\"\";\\n\\t\\tpublic String convertToTitle(int columnNumber) {\\n\\t\\t\\tif(columnNumber <= 26){\\n\\t\\t\\t\\t return Character.toString(alphabet.charAt(columnNumber-1));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 439343,
                "title": "clear-and-simple-solution-in-go-beat-100-and-100-with-a-hint",
                "content": "#### solution\\n```go\\nfunc convertToTitle(n int) string {\\n  chars := []byte{}\\n\\n  for n > 0 {\\n    n--\\n    chars = append(chars, byte(\\'A\\'+n%26))\\n    n /= 26\\n  }\\n\\n  // reverse order\\n  for h, t := 0, len(chars)-1; h < t; h, t = h+1, t-1 {\\n    chars[h], chars[t] = chars[t], chars[h]\\n  }\\n\\n  return string(chars)\\n}\\n```\\n\\n#### hint\\n```\\nA        1         1\\nAA       27        1 + 26\\nAAA      703       1 + 26 + 26*26\\nAAAA     18279     1 + 26 + 26*26 + 26*26*26\\nAAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26\\nBAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26*2\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc convertToTitle(n int) string {\\n  chars := []byte{}\\n\\n  for n > 0 {\\n    n--\\n    chars = append(chars, byte(\\'A\\'+n%26))\\n    n /= 26\\n  }\\n\\n  // reverse order\\n  for h, t := 0, len(chars)-1; h < t; h, t = h+1, t-1 {\\n    chars[h], chars[t] = chars[t], chars[h]\\n  }\\n\\n  return string(chars)\\n}\\n```\n```\\nA        1         1\\nAA       27        1 + 26\\nAAA      703       1 + 26 + 26*26\\nAAAA     18279     1 + 26 + 26*26 + 26*26*26\\nAAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26\\nBAAAA    475255    1 + 26 + 26*26 + 26*26*26 + 26*26*26*26*2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235117,
                "title": "javascript-solution",
                "content": "```\\nconst convertToTitle = n => {\\n  if (n < 27) {\\n    return String.fromCharCode(((n - 1) % 26) + 65);\\n  }\\n  return (\\n    convertToTitle(Math.floor((n - 1) / 26)) +\\n    String.fromCharCode(((n - 1) % 26) + 65)\\n  );\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst convertToTitle = n => {\\n  if (n < 27) {\\n    return String.fromCharCode(((n - 1) % 26) + 65);\\n  }\\n  return (\\n    convertToTitle(Math.floor((n - 1) / 26)) +\\n    String.fromCharCode(((n - 1) % 26) + 65)\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205987,
                "title": "python-solution-with-explanation",
                "content": "```\\n\\n```class Solution:\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        d=\\'0ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        res=\\'\\'\\n        if n<=26:\\n            return d[n]\\n        else:\\n            while n > 0:\\n                n,r=divmod(n,26)\\n\\t\\t\\t\\t# This is the catcha on this problem where when r==0 as a result of n%26. eg, n=52//26=2, r=52%26=0. \\n\\t\\t\\t\\t#To get \\'AZ\\' as known for 52, n-=1 and r+=26. Same goes to 702.\\n\\t\\t\\t\\tif r == 0:\\n                    n-=1\\n                    r+=26\\n                res = d[r] + res\\n        return res\\n\\t\\t\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51460,
                "title": "c-1ms-solution-in-6-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while (n-- != 0) {\\n            ans = char(int('A') + n % 26) + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;\\n        while (n-- != 0) {\\n            ans = char(int('A') + n % 26) + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51486,
                "title": "python-simple-solution",
                "content": "    class Solution(object):\\n        def convertToTitle(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: str\\n            \"\"\"\\n            res = ''\\n            base = ord('A')\\n            while n:\\n                n, r = divmod(n - 1, 26)\\n                res = '{}{}'.format(chr(base + r), res)\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n        def convertToTitle(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: str\\n            \"\"\"\\n            res = ''\\n            base = ord('A')\\n            while n:\\n                n, r = divmod(n - 1, 26)\\n                res = '{}",
                "codeTag": "Java"
            },
            {
                "id": 51544,
                "title": "one-line-in-java",
                "content": "    public String convertToTitle(int n) {\\n        return n<=0?\"\":convertToTitle((n-1)/26)+(char)('A'+(n-1)%26);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public String convertToTitle(int n) {\\n        return n<=0?\"\":convertToTitle((n-1)/26)+(char)('A'+(n-1)%26);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51604,
                "title": "short-and-non-recursive-c-solution-with-a-note-about-the-algorithm-trick",
                "content": "The solution is similar to converting a number to different base.  Only trick is when building the string the characters need to get inserted in the front rather that appended to the back.  Here's the code:\\n\\n    string convertToTitle(int n) {\\n        string r;\\n        for (; n > 0; n /= 26) r = (char)(--n % 26 + 'A') + r;\\n        return r;\\n    }",
                "solutionTags": [],
                "code": "The solution is similar to converting a number to different base.  Only trick is when building the string the characters need to get inserted in the front rather that appended to the back.  Here's the code:\\n\\n    string convertToTitle(int n) {\\n        string r;\\n        for (; n > 0; n /= 26) r = (char)(--n % 26 + 'A') + r;\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3944050,
                "title": "python-fastest-easy-to-understand-optimal-solution",
                "content": "# Python | Fastest | Easy to Understand | Optimal Solution\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = []\\n        while(n > 0):\\n            n -= 1\\n            curr = n % 26\\n            n = int(n / 26)\\n            ans.append(chr(curr + ord(\\'A\\')))\\n        \\n        return \\'\\'.join(ans[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943588,
                "title": "2-line-code-easy-100-accuracy-explanation",
                "content": "\\n# Approach\\n    Let given number = n\\n    Take remender of n, convert it into Alphabet and divide n by 26\\n    Do this untill your number become 0.\\n    One exception is when remender is 0 (It means we have to add alphabet \\'Z)\\n    In that case make remender to 26.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans = \"\";\\n        while(n){\\n            ans = (char)(--n % 26 + \\'A\\') + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/a47b6a99-0d7c-4040-90f5-6307284d244f_1692678224.2908423.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        string ans = \"\";\\n        while(n){\\n            ans = (char)(--n % 26 + \\'A\\') + ans;\\n            n /= 26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943126,
                "title": "simplest-python-solution-divide-by-26",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        res = \"\"\\n        while n > 0:\\n            r = (n-1) % 26\\n            n = (n-1)// 26\\n            res += chr(ord(\"A\")+r)\\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        res = \"\"\\n        while n > 0:\\n            r = (n-1) % 26\\n            n = (n-1)// 26\\n            res += chr(ord(\"A\")+r)\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406460,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log26 N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(log26 N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;    \\n        while(columnNumber) {\\n            columnNumber--;\\n            ans.push_back(columnNumber % 26 + \\'A\\');\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans;    \\n        while(columnNumber) {\\n            columnNumber--;\\n            ans.push_back(columnNumber % 26 + \\'A\\');\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360578,
                "title": "easy-explain-4-line-c-code-o-log-n-please-upvote",
                "content": "\\n# Approach \\nSuppose we want to convert the number 701 to its corresponding Excel column title. We can call the function convertToTitle(701) and it will return the string \"ZY\".\\n\\nHere\\'s how the code works:\\n\\nInitialize an empty string ans.\\n```\\nstring ans;\\n```\\nEnter the loop and iterate while n is greater than or equal to 1.\\n```\\nwhile (n--) {\\n    // code here\\n}\\n```\\nIn this example, n is initially 701.\\n\\nFor each iteration of the loop, take the modulo of n with 26 and append the corresponding uppercase letter to ans.\\n\\n```\\nans.push_back(n % 26 + \\'A\\');\\n```\\nIn the first iteration, n % 26 is 23 (since 701 is greater than or equal to 26*26, we need at least two letters), so we append the letter corresponding to the ASCII code 23 + \\'A\\', which is \\'X\\'. ans is now \"X\".\\n\\nIn the second iteration, n % 26 is 0 (since 676 is divisible by 26, the second letter is \\'Z\\'), so we append the letter corresponding to the ASCII code 0 + \\'A\\', which is \\'A\\'. ans is now \"XA\".\\n\\nDivide n by 26, rounding down if necessary.\\n```\\nn /= 26;\\n```\\nIn the first iteration, n becomes 26.\\n\\nIn the second iteration, n becomes 0 (since 26 is not greater than or equal to 26).\\n\\nContinue iterating until n is less than 1.\\n\\nReverse the order of the letters in ans.\\n```\\nreverse(ans.begin(), ans.end());\\n```\\nans is now \"ZY\".\\n\\nReturn ans.\\n\\n```\\nreturn ans;\\n```\\nThe function returns \"ZY\", which is the correct Excel column title for the number 701.\\n\\nSo the function takes an integer as input, and converts it to its corresponding Excel column title, where each column title is composed of one or more uppercase letters, with the rightmost letter representing the ones digit, the second-to-rightmost letter representing the 26s digit, the third-to-rightmost letter representing the 26^2 digit, and so on.\\n\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;    \\n        while(n--){\\n            ans.push_back(n % 26 + \\'A\\');\\n            n /= 26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring ans;\\n```\n```\\nwhile (n--) {\\n    // code here\\n}\\n```\n```\\nans.push_back(n % 26 + \\'A\\');\\n```\n```\\nn /= 26;\\n```\n```\\nreverse(ans.begin(), ans.end());\\n```\n```\\nreturn ans;\\n```\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans;    \\n        while(n--){\\n            ans.push_back(n % 26 + \\'A\\');\\n            n /= 26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815445,
                "title": "easy-c-solution-beats-100",
                "content": "# Code -->\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n       string al= \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        int n= columnNumber;\\n        string ans=\"\";\\n        while(n>0){\\n            n=n-1;\\n            int k= n%26;\\n            ans.push_back(al[k]);\\n            n=n/26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n       string al= \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        int n= columnNumber;\\n        string ans=\"\";\\n        while(n>0){\\n            n=n-1;\\n            int k= n%26;\\n            ans.push_back(al[k]);\\n            n=n/26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556971,
                "title": "c-faster-than-100-easy-solution",
                "content": "```\\n/*I decrement the columnNumber by 1 everytime just to make remainder work with the expression (columnNumber%26 + \\'A\\').\\nI match not 1 to \\'A\\' but 0 to \\'A\\', so that when I add the remainder to \\'A\\' (which has the value range 0-25), it correctly matches the intended letter.\\nDo comment down in case of any queries or remarks.\\nPlease upvote if you find the algorithm useful.\\nThank You!!\\n*/\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n/*I decrement the columnNumber by 1 everytime just to make remainder work with the expression (columnNumber%26 + \\'A\\').\\nI match not 1 to \\'A\\' but 0 to \\'A\\', so that when I add the remainder to \\'A\\' (which has the value range 0-25), it correctly matches the intended letter.\\nDo comment down in case of any queries or remarks.\\nPlease upvote if you find the algorithm useful.\\nThank You!!\\n*/\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string res = \"\";\\n        while(columnNumber) {\\n            columnNumber--;\\n            res.push_back(columnNumber%26 + \\'A\\');\\n            columnNumber/=26;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065662,
                "title": "c-100-fast-very-simple-7-lines-best-approach",
                "content": "**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        int reminder;\\n        while(columnNumber){\\n            reminder = columnNumber%26;\\n            if(reminder==0){\\n                reminder = 26;\\n            }\\n            char c = 64+reminder;\\n            ans =  c+ans;\\n            columnNumber = (columnNumber-reminder )/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        int reminder;\\n        while(columnNumber){\\n            reminder = columnNumber%26;\\n            if(reminder==0){\\n                reminder = 26;\\n            }\\n            char c = 64+reminder;\\n            ans =  c+ans;\\n            columnNumber = (columnNumber-reminder )/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792173,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string s=\"\";\\n        while(columnNumber){\\n            columnNumber--;\\n            int a=columnNumber%26;\\n            s+=(\\'A\\'+a);\\n            columnNumber/=26;\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string s=\"\";\\n        while(columnNumber){\\n            columnNumber--;\\n            int a=columnNumber%26;\\n            s+=(\\'A\\'+a);\\n            columnNumber/=26;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1515193,
                "title": "simple-to-understand-using-basic-loop-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        var result = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            // Get the alphabet position of the last character\\n            var pos = columnNumber % 26;\\n            if (pos == 0) {\\n                pos = 26;\\n            }\\n            \\n            // Convert the position to a uppercase character\\n            var letter = (char)(\\'A\\' + (pos - 1));    \\n            \\n            // Save the character at the beginning of the result\\n            result.Insert(0, letter);\\n            \\n            // Remove the current position from consideration\\n            columnNumber -= pos;\\n            \\n            // Advance to the next position\\n            columnNumber /= 26;\\n        }        \\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string ConvertToTitle(int columnNumber) {\\n        var result = new StringBuilder();\\n\\n        while (columnNumber > 0) {\\n            // Get the alphabet position of the last character\\n            var pos = columnNumber % 26;\\n            if (pos == 0) {\\n                pos = 26;\\n            }\\n            \\n            // Convert the position to a uppercase character\\n            var letter = (char)(\\'A\\' + (pos - 1));    \\n            \\n            // Save the character at the beginning of the result\\n            result.Insert(0, letter);\\n            \\n            // Remove the current position from consideration\\n            columnNumber -= pos;\\n            \\n            // Advance to the next position\\n            columnNumber /= 26;\\n        }        \\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402317,
                "title": "python-easy-to-understand",
                "content": "Do upvote if this helped you..\\nhappy learning :)\\n\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber>0:\\n            columnNumber-=1\\n            title = chr(65 + columnNumber%26) + title \\n            columnNumber //=26\\n        return title",
                "solutionTags": [],
                "code": "Do upvote if this helped you..\\nhappy learning :)\\n\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber>0:\\n            columnNumber-=1\\n            title = chr(65 + columnNumber%26) + title \\n            columnNumber //=26\\n        return title",
                "codeTag": "Java"
            },
            {
                "id": 1216846,
                "title": "java-solution-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n        while(columnNumber > 0){\\n            sb.append((char)((--columnNumber) % 26 + 65));\\n            columnNumber /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n        while(columnNumber > 0){\\n            sb.append((char)((--columnNumber) % 26 + 65));\\n            columnNumber /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157768,
                "title": "fast-python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        x = (columnNumber-1) % 26\\n        rest = (columnNumber-1) // 26\\n        \\n        if (rest == 0):\\n            return digits[x]\\n        return self.convertToTitle(rest) + digits[x]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        x = (columnNumber-1) % 26\\n        rest = (columnNumber-1) // 26\\n        \\n        if (rest == 0):\\n            return digits[x]\\n        return self.convertToTitle(rest) + digits[x]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110482,
                "title": "java-simple-solution-using-modulo",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            sb.append((char)((--n % 26) + 65));\\n            n = n / 26;\\n        }\\n            \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n = columnNumber;\\n        StringBuilder sb = new StringBuilder();\\n        while (n > 0){\\n            sb.append((char)((--n % 26) + 65));\\n            n = n / 26;\\n        }\\n            \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874807,
                "title": "c-solutions",
                "content": "**C++:**\\n\\n**(1)**\\n```\\nstring convertToTitle(int n) {\\n\\tstring ans;\\n\\twhile(n){\\n\\t\\tn-=1;\\n\\t\\tans=(char)(n%26+\\'A\\')+ ans;\\n\\t\\tn/=26;\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**(2)**\\n```\\nstring convertToTitle(int n) {\\n\\treturn n==0?\"\":convertToTitle((n-1)/26)+(char)(\\'A\\'+(n-1)%26);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring convertToTitle(int n) {\\n\\tstring ans;\\n\\twhile(n){\\n\\t\\tn-=1;\\n\\t\\tans=(char)(n%26+\\'A\\')+ ans;\\n\\t\\tn/=26;\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nstring convertToTitle(int n) {\\n\\treturn n==0?\"\":convertToTitle((n-1)/26)+(char)(\\'A\\'+(n-1)%26);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601363,
                "title": "c-solution-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans = \"\";\\n        while(n!=0){\\n            ans = (char)(\\'A\\'+ (n-1)%26) + ans;\\n            n = (n-1)/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string ans = \"\";\\n        while(n!=0){\\n            ans = (char)(\\'A\\'+ (n-1)%26) + ans;\\n            n = (n-1)/26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387958,
                "title": "easy-to-understand-c-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Excel Sheet Column Title.\\nMemory Usage: 8.3 MB, less than 36.36% of C++ online submissions for Excel Sheet Column Title.\\n\\n```\\nstring convertToTitle(int n) {\\n        \\n        string res;\\n        \\n        while(n-- > 0)\\n        {\\n            res = (char)(\\'A\\' + (n%26)) + res;\\n            n /= 26;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Excel Sheet Column Title.\\nMemory Usage: 8.3 MB, less than 36.36% of C++ online submissions for Excel Sheet Column Title.\\n\\n```\\nstring convertToTitle(int n) {\\n        \\n        string res;\\n        \\n        while(n-- > 0)\\n        {\\n            res = (char)(\\'A\\' + (n%26)) + res;\\n            n /= 26;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 281030,
                "title": "python-solution-beats-79-98-with-clear-explanation",
                "content": "Here is a explanation for the number:\\nFor decimal number, i.e., 1099? Why we express 1099 like this in decimal?\\nFrom the last digit, we make 1099 // (10 ^0) = 1099, then 1099 % 10 = 9, so the last digit is 9.\\nThen for the second last digit, first we should minus 9 * 10^0, so it would be 1099-9 = 1090, then 1090 // (10 ^1) = 109, then 109 % 10 = 9, so the last second digit is 9.\\nThen for the second digit, first we should minus 9 * 10^1, so it would be 1090 - 90 = 1000, then 1000 // (10^2) = 10, then 10 % 10 = 0, so the second digit is 0.\\nFinally, we should minus 0 * 10^2, so its still 1000, then 1000 // (10^3) = 1, then 1 % 10 = 1, so the first digit is 1, \\nand the loop condition should be the number still larger than 0.\\n\\nSame as base = 26.\\ni.e., 897.\\nFrom last digit, first we make 897 // (26^0), still 897, then 897 % 26 = 13, so the last digit is M;\\nThen for the second last digit, num = 897 - 13 * (26^0) = 884 >0 , so the loop will continue, and then we make 884 // (26^1) = 34, then 34 % 26 = 8, so the second last digit is H;\\nThen for the third last digit, num = 884 - 8*(26^1) = 676 >0, so the loop will continue, and then we make 676 // (26^2) = 1, then 1 % 26 = 1, so the third last digit is A;\\nThen we check the condition, 676 - 26^2 = 0 == 0, so the loop end. \\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:  \\n        if n <= 0:\\n            return \\'\\'\\n        ans = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        ret = \\'\\'\\n        base = 0    \\n        while n > 0:\\n            tmp = int(n / (26 ** base))    ## everytime first devided by 26^base\\n            val = tmp % 26\\n            if val == 0:\\n                char = \\'Z\\'\\n                n = n - 26*(26**base)\\n            else:\\n                char = ans[val-1]\\n                n = n - val*(26**base)\\n            ret = char + ret\\n            base += 1\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:  \\n        if n <= 0:\\n            return \\'\\'\\n        ans = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        ret = \\'\\'\\n        base = 0    \\n        while n > 0:\\n            tmp = int(n / (26 ** base))    ## everytime first devided by 26^base\\n            val = tmp % 26\\n            if val == 0:\\n                char = \\'Z\\'\\n                n = n - 26*(26**base)\\n            else:\\n                char = ans[val-1]\\n                n = n - val*(26**base)\\n            ret = char + ret\\n            base += 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249459,
                "title": "python3-beats-100",
                "content": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \\n        ref = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        s = \"\"\\n        while n > 0:\\n            n = n-1\\n            s = ref[n % 26] + s\\n            n = n // 26\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \\n        ref = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        s = \"\"\\n        while n > 0:\\n            n = n-1\\n            s = ref[n % 26] + s\\n            n = n // 26\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245803,
                "title": "java-solutions",
                "content": "**Solution 1: Iterative**\\n\\nTime complexity: `O(log n)` - the time complexity is log<sub>26</sub>(n)\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        StringBuilder sb = new StringBuilder();\\n\\n        while(n > 0)\\n\\t\\t{\\n            n--;\\n            char c = (char)(n % 26 + \\'A\\');\\n            sb.append(c);\\n            n /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n**Solution 2: Recursive**\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(log n)` - space required for the recursive function call stack\\n\\n```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        if(n == 0)\\n            return \"\";\\n        else\\n            return convertToTitle(--n / 26) + (char)(n % 26 + \\'A\\');\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        StringBuilder sb = new StringBuilder();\\n\\n        while(n > 0)\\n\\t\\t{\\n            n--;\\n            char c = (char)(n % 26 + \\'A\\');\\n            sb.append(c);\\n            n /= 26;\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public String convertToTitle(int n)\\n\\t{\\n        if(n == 0)\\n            return \"\";\\n        else\\n            return convertToTitle(--n / 26) + (char)(n % 26 + \\'A\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182520,
                "title": "easy-java-solution-0-ms-run-time",
                "content": "```\n String str = \"\";\n        while(n!=0){\n            int rem = (n-1)%26;\n            str = (char)(rem + 'A') + str ; \n            n=(n-1)/26;\n        }\n        return str;\n```",
                "solutionTags": [],
                "code": "```\n String str = \"\";\n        while(n!=0){\n            int rem = (n-1)%26;\n            str = (char)(rem + 'A') + str ; \n            n=(n-1)/26;\n        }\n        return str;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51479,
                "title": "0ms-golang-solution",
                "content": "    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n    \\n    func reverse(b []byte){\\n        for i, j := 0, len(b)-1 ; i < j ; i, j = i+1, j - 1{\\n            \\n            b[i] , b [j] = b[j], b[i]\\n        } \\n        \\n    }\\n    \\n    \\n    func convertToTitle(n int) string {\\n        var b []byte\\n        for ;n > 0; n = (n - 1)/26 {\\n            b = append(b, letters[(n-1) % 26])\\n        }\\n        reverse(b)\\n        return string(b)\\n    }",
                "solutionTags": [
                    "Go"
                ],
                "code": "    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n    \\n    func reverse(b []byte){\\n        for i, j := 0, len(b)-1 ; i < j ; i, j = i+1, j - 1{\\n            \\n            b[i] , b [j] = b[j], b[i]\\n        } \\n        \\n    }\\n    \\n    \\n    func convertToTitle(n int) string {\\n        var b []byte\\n        for ;n > 0; n = (n - 1)/26 {\\n            b = append(b, letters[(n-1) % 26])\\n        }\\n        reverse(b)\\n        return string(b)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51499,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "\\n>     1 -> A          0->A\\n>     2 -> B          1->B\\n>     3 -> C          2->C \\n>     ...             ...\\n>     26 -> Z         25->Z \\n>     27 -> AA        26->AA\\n>     28 -> AB        27->AB\\n\\n       class Solution {\\n        public:\\n            string convertToTitle(int n) {\\n                string ret = \"\";\\n                int r = 0;\\n                \\n                if (n <= 0) return ret;\\n                \\n                while (n > 0)\\n                {\\n                    r = (n - 1) % 26;\\n                    ret = (char)('A' + r) + ret;\\n                    n = (n - 1) / 26;\\n                }\\n                \\n                return ret;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            string convertToTitle(int n) {\\n                string ret = \"\";\\n                int r = 0;\\n                \\n                if (n <= 0) return ret;\\n                \\n                while (n > 0)\\n                {\\n                    r = (n - 1) % 26;\\n                    ret = (char)('A' + r) + ret;\\n                    n = (n - 1) / 26;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51552,
                "title": "my-solution-in-c-0ms",
                "content": "  \\n\\n      char* convertToTitle(int n) \\n    {\\n        char* ans =(char*)malloc(sizeof(char)* 10);\\n        char ans2[10];\\n        int i =0;int x;int j;\\n        while(n)\\n        {\\n            x=n%26;\\n            if(x==0) x=26;\\n            ans[i]= x+'A'-1;\\n            i++;\\n            if(n%26==0) n--;\\n            n/=26;\\n        }\\n        int dig=i;\\n        for(j=0;j<dig;j++)\\n        {\\n            ans2[j] = ans[i-1-j] ;\\n        }\\n        ans2[j]='\\\\0';\\n        \\n        return ans2;",
                "solutionTags": [],
                "code": "  \\n\\n      char* convertToTitle(int n) \\n    {\\n        char* ans =(char*)malloc(sizeof(char)* 10);\\n        char ans2[10];\\n        int i =0;int x;int j;\\n        while(n)\\n        {\\n            x=n%26;\\n            if(x==0) x=26;\\n            ans[i]= x+'A'-1;\\n            i++;\\n            if(n%26==0) n--;\\n            n/=26;\\n        }\\n        int dig=i;\\n        for(j=0;j<dig;j++)\\n        {\\n            ans2[j] = ans[i-1-j] ;\\n        }\\n        ans2[j]='\\\\0';\\n        \\n        return ans2;",
                "codeTag": "Unknown"
            },
            {
                "id": 51571,
                "title": "accepted-simple-java-solution-and-how-to-improve",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\t\\twhile(n > 0) {\\n    \\t\\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t\\tresult.append('Z');\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tresult.append((char) ('A' + n%26 - 1));\\n    \\t\\t\\t}\\n    \\t\\t\\tn = (n - 1) / 26;\\n    \\t\\t}\\n    \\t\\treturn result.reverse().toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            StringBuilder result = new StringBuilder();\\n    \\t\\twhile(n > 0) {\\n    \\t\\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t\\tresult.append('Z');\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 51569,
                "title": "shorter-c-solution-using-character-lookup-array",
                "content": "Use a char map to avoid character to integer calculation.\\n\\n        string convertToTitle(int n) {\\n            string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res;\\n        \\n            while (n) {\\n                res = map[n-- % 26] + res; \\n                n /= 26;\\n            }\\n        \\n            return res;\\n        }\\n\\n\\nThe idea behind this algorithm is coming from:\\n\\nSince we have the following numeric representation mapping to characters:\\n\\n       A       B             Z\\n    1+26*0, 2+26*0, ..., 26+26*0\\n      AA      AB            AZ\\n    1+26*1, 2+26*1, ..., 26+26*1\\n      BA      BB            BZ\\n    1+26*2, 2+26*2, ..., 26+26*2\\n\\n, and we have the char lookup array:\\n\\n    A B C ... Z\\n    0 1 2 ... 25\\n\\n, the index for the lookup array is always less than the numeric representation by 1. \\nThus, we need to decrement the number n by 1 in order to locate the character in lookup map.\\n\\nSo we can write:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[(n-1) % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }\\n\\n, which is equivalent to:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[n % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Use a char map to avoid character to integer calculation.\\n\\n        string convertToTitle(int n) {\\n            string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res;\\n        \\n            while (n) {\\n                res = map[n-- % 26] + res; \\n                n /= 26;\\n            }\\n        \\n            return res;\\n        }\\n\\n\\nThe idea behind this algorithm is coming from:\\n\\nSince we have the following numeric representation mapping to characters:\\n\\n       A       B             Z\\n    1+26*0, 2+26*0, ..., 26+26*0\\n      AA      AB            AZ\\n    1+26*1, 2+26*1, ..., 26+26*1\\n      BA      BB            BZ\\n    1+26*2, 2+26*2, ..., 26+26*2\\n\\n, and we have the char lookup array:\\n\\n    A B C ... Z\\n    0 1 2 ... 25\\n\\n, the index for the lookup array is always less than the numeric representation by 1. \\nThus, we need to decrement the number n by 1 in order to locate the character in lookup map.\\n\\nSo we can write:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[(n-1) % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }\\n\\n, which is equivalent to:\\n\\n    string convertToTitle(int n) {\\n        string map = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n        string res;\\n    \\n        while (n) {\\n            res = map[n % 26] + res; \\n            n = (n-1) / 26;\\n        }\\n    \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51605,
                "title": "simple-c-code",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if (n == 0) return \"\";\\n            int r = (n-1)%26;\\n            char c = r+'A';\\n            return convertToTitle((n-r)/26)+c;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            if (n == 0) return \"\";\\n            int r = (n-1)%26;\\n            char c = r+'A';\\n            return convertToTitle((n-r)/26)+c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3944867,
                "title": "excel-sheet-column-title-java-0-time-complexity",
                "content": "# Intuition\\n- The problem requires converting an integer into an Excel-style column title. Essentially, the task is to represent a number in base 26 where each digit corresponds to a letter in the alphabet.\\n\\n# Approach\\n- The approach taken here involves repeatedly dividing the given number by 26 (the base) while also calculating the remainder. The remainder is then mapped to a character (\\'A\\' to \\'Z\\') to form a part of the column title. The process continues until the number becomes 0. During each iteration, the remainder is calculated as (n - 1) % 26 to ensure the correct mapping to alphabet character\\n\\n# Complexity\\n- Time Complexity: The while loop iterates as many times as the number of digits in the column title, which is proportional to the logarithm of the input n in base 26. Hence, the time complexity is O(log_base_26(n)).\\n- Space Complexity: The space complexity is O(log_base_26(n)) as well, since the size of the columnTitle StringBuilder is proportional to the number of iterations in the loop.\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder columnTitle = new StringBuilder();\\n\\n        while (n > 0) {\\n            int remainder = (n - 1) % 26; // Calculate the remainder in the range [0, 25]\\n            char currentChar = (char) (\\'A\\' + remainder);\\n            columnTitle.insert(0, currentChar); // Insert at the beginning of the StringBuilder\\n            n = (n - 1) / 26; // Update n for the next iteration\\n        }\\n\\n        return columnTitle.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder columnTitle = new StringBuilder();\\n\\n        while (n > 0) {\\n            int remainder = (n - 1) % 26; // Calculate the remainder in the range [0, 25]\\n            char currentChar = (char) (\\'A\\' + remainder);\\n            columnTitle.insert(0, currentChar); // Insert at the beginning of the StringBuilder\\n            n = (n - 1) / 26; // Update n for the next iteration\\n        }\\n\\n        return columnTitle.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944229,
                "title": "c-thanks-aryabhatta-for-0-more-such-problems-solution",
                "content": "Here is the solution for the problem, you can also checkout other problems related to this!\\n[Leetcode 171 - excel sheet column number ](https://leetcode.com/problems/excel-sheet-column-number/description/)\\n[Leetcode 2194 - cells in a range on an excel sheet](https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/description/)\\n\\nPLEASE UPVOTE IF THIS HELPED YOU!\\nCHEERS!!\\n\\n# Complexity\\n- Time complexity:\\nEqual to number of cn=cn/26 operations until cn becomes 0.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int cn) { \\n\\n        //cn  =  column number\\n        string ans = \"\";\\n        char c;\\n\\n        while(cn!=0){\\n\\n            int rem = cn%26; //remainder\\n            if(rem==0) c = \\'Z\\'; //if remainder is zero, character is Z (as we\\'re in 26 based system)\\n            else c = char(\\'A\\' + rem - 1 ); //other char we calulate using this way\\n\\n            ans += c; //add your obtained char to ans string\\n\\n            //for further operation (if we have more characters to add):\\n            if(rem==0) cn = cn/26 - 1;\\n            else cn = cn / 26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end()); //as answer was stored in inverse manner\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int cn) { \\n\\n        //cn  =  column number\\n        string ans = \"\";\\n        char c;\\n\\n        while(cn!=0){\\n\\n            int rem = cn%26; //remainder\\n            if(rem==0) c = \\'Z\\'; //if remainder is zero, character is Z (as we\\'re in 26 based system)\\n            else c = char(\\'A\\' + rem - 1 ); //other char we calulate using this way\\n\\n            ans += c; //add your obtained char to ans string\\n\\n            //for further operation (if we have more characters to add):\\n            if(rem==0) cn = cn/26 - 1;\\n            else cn = cn / 26;\\n        }\\n        \\n        reverse(ans.begin(), ans.end()); //as answer was stored in inverse manner\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944215,
                "title": "striver-s-approach-simple-c-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        vector<char>v={\\'Z\\',\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\'};\\n        string ans = \"\";\\n        while(c){\\n            char x = v[c%26];\\n            ans += x;\\n            if(x==\\'Z\\') c-=1;\\n            c/=26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        vector<char>v={\\'Z\\',\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\'};\\n        string ans = \"\";\\n        while(c){\\n            char x = v[c%26];\\n            ans += x;\\n            if(x==\\'Z\\') c-=1;\\n            c/=26;\\n        }\\n        reverse(ans.begin() , ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943214,
                "title": "easiest-c-solution-5-line-code-beast-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber){\\n        string ans = \"\";\\n        while(columnNumber--){\\n            ans += columnNumber%26 + \\'A\\';\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber){\\n        string ans = \"\";\\n        while(columnNumber--){\\n            ans += columnNumber%26 + \\'A\\';\\n            columnNumber /= 26;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640228,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res=\"\"\\n        while(columnNumber>0):\\n            columnNumber-=1\\n            i=columnNumber%26\\n            res+=chr(65+i)\\n            columnNumber=columnNumber//26\\n        return res[::-1]\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        res=\"\"\\n        while(columnNumber>0):\\n            columnNumber-=1\\n            i=columnNumber%26\\n            res+=chr(65+i)\\n            columnNumber=columnNumber//26\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603555,
                "title": "hindi-version-c-commented-code-easiest-explanation",
                "content": "**This post is written in HINDI as there are very less post explaining approaches in HINDI.**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Sabse pehle ek observation zaroori hai ki jab sirf single character hai toh A to Z hi print hoga lekin jab multiple characters honge toh kya karenge?**\\n\\nMultiple characters ko observe karte hai like : **AA** , **AB** , **AC** . In teeno cases ko observe karte hai :\\n\\n**Sample-Case-1 :** **\\'AA\\'** iska columnNumber 27 hoga lekin kese : toh hume pata hai ki english mein total 26 characters hai jinhe counting ke base par 1 to 26 numbers dete hai but coding mein agar dhyaan ho toh hum jab bhi koyi character ko represent karte hai toh wahan par \\'a\\' or \\'A\\' ko 0 se represent karte hai and \\'z\\' or \\'Z\\' ko 25 par end karte hai. Bas issi cheez ka fayda uthana hai. Hum (27-1)%26 karenge toh hume jo remainder milega usse hum \\'A\\' mein add kardenge taaki hum woh number mile jo ki rightmost character hoga toh 26%26 = 0 hoga toh rightmost character hoga \\'A\\'+ 0  = A. Ab hum columnNumber=27 ko 26 se divide kardenge taaki previous character find kar paayen. columnNumber = (27-1)/26 = 1 hoga. Ab ColumnNumber=1 hai toh remainder = (1-1)%26 = 0 hoga and yahan se hume next character \\'A\\'+0 = \\'A\\' miljaayega. Toh final answer hoga : \\'AA\\'\\n\\n**Sample-Case-1 : \\'AA\\'**\\n\\n    // ColumnNumber | Remainder      | Character    | Title\\n    //     27       | (27-1)%26 = 0  | (\\'A\\'+0) = A  |  A\\n    //(27-1)/26 = 1 | (1-1)%26 = 0   | (\\'A\\'+0) = A  |  AA\\n\\n**Sample-Case-2 : \\'AB\\'**\\n\\n    // ColumnNumber | Remainder      | Character    | Title\\n    //     28       | (28-1)%26 = 1  | (\\'A\\'+1) = B  |  B\\n    //(28-1)/26 = 1 | (1-1)%26 = 0   | (\\'A\\'+0) = A  |  AB\\n\\n**Sample-Case-3 : \\'AC\\'**\\n\\n    // ColumnNumber | Remainder      | Character    | Title\\n    //     29       | (29-1)%26 = 2  | (\\'A\\'+2) = C  |  C\\n    //(29-1)/26 = 1 | (1-1)%26 = 0   | (\\'A\\'+0) = A  |  AC\\n\\n**Ek example se dry run karke samjhte hai : columnNumber = 701**\\n\\n    // ColumnNumber   | Remainder      | Character    | Title\\n    //    701         |(701-1)%26 = 24 | (\\'A\\'+24) = Y |  Y\\n    //(701-1)/26 = 26 | (26-1)%26 = 25 | (\\'A\\'+25) = Z |  ZY\\n\\n# Complexity\\n- **Time complexity :** O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity :** O(logN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int rem = 0;\\n        string title = \"\";\\n        while(columnNumber>0)\\n        {\\n            \\n            // 1 ko subtract karne ka reason hi yehi hai ki hum coding scenario mein \\'A\\' to \\'Z\\' ko 0 to 25 represent karte hai\\n            rem = ((columnNumber-1)%26);\\n            title += (\\'A\\'+rem);\\n            columnNumber = (columnNumber-1)/26;\\n        }\\n        // reverse isliye karna zaroori hai because hum backward append kar rahe hai loop mein characters ko. \\n        // Agar reverse nahi karna chahate toh loop mein jo title waali line hai usse remove karke front appending karlo like this : title = (\\'A\\'+rem) + title\\n        reverse(title.begin(),title.end());\\n        return title;\\n    }\\n};\\n```\\n\\n# Ek motivational quote ke saath khatam karte hai post :\\n![LeetcodeMotivation.PNG](https://assets.leetcode.com/users/images/57d186b9-b010-4f5c-acd4-d6e6c91320e2_1686032598.2052639.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        int rem = 0;\\n        string title = \"\";\\n        while(columnNumber>0)\\n        {\\n            \\n            // 1 ko subtract karne ka reason hi yehi hai ki hum coding scenario mein \\'A\\' to \\'Z\\' ko 0 to 25 represent karte hai\\n            rem = ((columnNumber-1)%26);\\n            title += (\\'A\\'+rem);\\n            columnNumber = (columnNumber-1)/26;\\n        }\\n        // reverse isliye karna zaroori hai because hum backward append kar rahe hai loop mein characters ko. \\n        // Agar reverse nahi karna chahate toh loop mein jo title waali line hai usse remove karke front appending karlo like this : title = (\\'A\\'+rem) + title\\n        reverse(title.begin(),title.end());\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200056,
                "title": "converting-column-number-to-column-title-in-excel-sheet-using-base-26-system",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to convert a given column number into the corresponding column title in an Excel sheet. We can use the ASCII codes of the capital letters to represent the column titles.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use the algorithm mentioned earlier to convert the column number to its corresponding title. We start by initializing an empty string to store the column title. We then use a while loop to iterate over the column number until it becomes zero. Within the loop, we subtract 1 from the column number to account for 0-based indexing, and then compute the remainder of the column number when divided by 26. We add this remainder to the ASCII code of \\'A\\' to get the corresponding capital letter, which we then append to the beginning of the column title string. Finally, we divide the column number by 26 and update its value for the next iteration. We continue this process until the column number becomes zero, and then return the column title string.\\n# Complexity\\n- Time complexity:The time complexity of the algorithm is $$O(log N)$$, where N is the given column number. This is because we divide the column number by 26 in each iteration of the loop, which reduces its value by a factor of 26. Since the number of digits in the base 26 representation of N is $$log(N)$$, the number of iterations required to reduce N to zero is $$log(N)$$ The time complexity of the chr() and ord() functions used to convert between ASCII codes and characters is $$O(1)$$, so they do not affect the overall time complexity of the algorithm.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is also $$O(log N$$), since the size of the column title string is proportional to the number of iterations of the loop.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n## Summary -\\nThis algorithm converts a given column number to its corresponding column title in an Excel sheet using the base-26 system and ASCII codes of capital letters. It works by iterating over the column number, computing the remainder when divided by 26, and adding the corresponding letter to the beginning of the column title. It then updates the column number and continues the process until the column number becomes zero. The time complexity of the algorithm is $$O(log N)$$, and the space complexity is also $$O(log N)$$ where N is the given column number.\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            letter = chr(columnNumber % 26 + ord(\\'A\\'))\\n            title = letter + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        title = \"\"\\n        while columnNumber > 0:\\n            columnNumber -= 1\\n            letter = chr(columnNumber % 26 + ord(\\'A\\'))\\n            title = letter + title\\n            columnNumber //= 26\\n        return title\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149334,
                "title": "excel-sheet-column-title-in-python",
                "content": "# Intuition\\nAssign characters as per unicode values, keeping in mind the values that go beyond the 26 letters of the alphabet.\\n\\n# Approach\\nAssign the value of `columnNumber` to a variable `n`. Initialize a blank string `res`. Initialize a while loop with the condition `n > 0`. \\nInside the `while loop`:\\nDecrement the value of `n` by 1, to fit the number system starting with `0` instead of `1`. Calculate the modulus of `n` when divided by `26`, to get the value by which the number is exceeding the 26 letters of the alphabet. Add this value to the unicode value of `A`, to get the unicode value of the letter. Apply the `chr` function with this value as the input, to get the letter. Concatenate this with the string `res`. Calculate the value of the floor division of `n` by 26, to move on to the next value for consideration in the loop.\\n\\n**Let us understand this with the help of an example:**\\n\\nSuppose, `columnNumber` is given as 27.\\nWe assign this value to `n`.\\nThen initialize the empty string `res`.\\nCheck the while loop codition, which is passed. So, we enter the loop. \\nDecrement `n` by 1, so we get 26. \\nNext, the modulus of `n` when divided by 26 is calculated as 0. We add this to the unicode value of `A`, which gives us 65. \\nThe `chr` function returns `A` for this value. \\nWe concatenate `A` with res, to get `A`.\\nFloor division of `n` by 26 gives 1.\\nThis value goes back into the loop. \\nThe condition is passed, so we wnter the loop and `n` is decremented to 0. \\nThe modulus is still 0, so the output of `chr` function is `A`, which is concatenated with the previous value of `res`, which is `A`.\\nFloor division of `n` by 26 now gives 0, which fails the loop condition, so we exit.\\nFinally, we return the value of `res` as `AA`.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        n = columnNumber\\n        res = \"\"\\n        while n > 0:\\n            n -= 1\\n            res = chr(n % 26 + ord(\\'A\\')) + res\\n            n //= 26\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        n = columnNumber\\n        res = \"\"\\n        while n > 0:\\n            n -= 1\\n            res = chr(n % 26 + ord(\\'A\\')) + res\\n            n //= 26\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035427,
                "title": "0ms-faster-than-100-easy-explained-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string res;\\n        while (n!=NULL) {\\n            res.push_back(\\'A\\' + (n - 1) % 26); //since n>=1 so we can have atleast one \\'A\\' \\n            n = (n - 1) / 26;   \\n        }\\n        reverse(res.begin(), res.end()); // coz when we pushing char. it was adding from behind so for getting in correct form we finally reversing\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string res;\\n        while (n!=NULL) {\\n            res.push_back(\\'A\\' + (n - 1) % 26); //since n>=1 so we can have atleast one \\'A\\' \\n            n = (n - 1) / 26;   \\n        }\\n        reverse(res.begin(), res.end()); // coz when we pushing char. it was adding from behind so for getting in correct form we finally reversing\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887082,
                "title": "100-mathematical",
                "content": "# Approach\\nSimple and mathematical approach\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string r = \"\";\\n\\n        while(c) {\\n            int  d = --c%26;\\n            c = c/26;\\n            r = (char)(d+\\'A\\') + r;            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int c) {\\n        string r = \"\";\\n\\n        while(c) {\\n            int  d = --c%26;\\n            c = c/26;\\n            r = (char)(d+\\'A\\') + r;            \\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747536,
                "title": "java-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder ans = new StringBuilder();\\n        while (columnNumber != 0) {\\n            int rem = columnNumber % 26;\\n            ans.append(getChar(rem));\\n            columnNumber /= 26;\\n            columnNumber = (rem == 0 ? columnNumber - 1 : columnNumber);\\n        }\\n        return ans.reverse().toString();\\n    }\\n    \\n    private String getChar(int num) {\\n        int base = 64;\\n        if (num == 0) {\\n            return \"Z\";\\n        }\\n        return String.valueOf((char)(base + num));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder ans = new StringBuilder();\\n        while (columnNumber != 0) {\\n            int rem = columnNumber % 26;\\n            ans.append(getChar(rem));\\n            columnNumber /= 26;\\n            columnNumber = (rem == 0 ? columnNumber - 1 : columnNumber);\\n        }\\n        return ans.reverse().toString();\\n    }\\n    \\n    private String getChar(int num) {\\n        int base = 64;\\n        if (num == 0) {\\n            return \"Z\";\\n        }\\n        return String.valueOf((char)(base + num));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403803,
                "title": "easy-to-understand-java-solution-using-stringbuilder-100-faster-than-others",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder str = new StringBuilder();\\n        while (columnNumber > 0) {\\n            int cid = (columnNumber - 1) % 26;\\n            str.append((char) (cid + \\'A\\'));\\n            columnNumber = (columnNumber - 1) / 26;\\n        }\\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder str = new StringBuilder();\\n        while (columnNumber > 0) {\\n            int cid = (columnNumber - 1) % 26;\\n            str.append((char) (cid + \\'A\\'));\\n            columnNumber = (columnNumber - 1) / 26;\\n        }\\n        return str.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377341,
                "title": "easy-python-explained",
                "content": "# Hello!\\uD83D\\uDC31\\u200D\\uD83D\\uDC64\\uD83D\\uDD75\\uFE0F\\u200D\\u2642\\uFE0F\\n```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n\\t\\t# We make this lookup list, having A-Z in ascending order\\n        alpha = [chr(x) for x in range(ord(\"A\"), ord(\"Z\")+1)]     # range(65, 90+1) -> 91-65 = 26\\n        res = \"\"\\n\\n        while num > 0:\\n            res += alpha[(num-1)%26]     # since 0 indexed list, num-1 % 26 gives the index of ch in alpha\\n            num = (num-1) // 26 \\n        return res[::-1]\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, num: int) -> str:\\n\\t\\t# We make this lookup list, having A-Z in ascending order\\n        alpha = [chr(x) for x in range(ord(\"A\"), ord(\"Z\")+1)]     # range(65, 90+1) -> 91-65 = 26\\n        res = \"\"\\n\\n        while num > 0:\\n            res += alpha[(num-1)%26]     # since 0 indexed list, num-1 % 26 gives the index of ch in alpha\\n            num = (num-1) // 26 \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322848,
                "title": "java-easy-commented-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int column) {\\n\\t\\t// StringBuilder to store the result\\n        StringBuilder result = new StringBuilder();\\n\\t\\t\\n        while (column > 0) {\\n            int letter = (column % 26); // get letter from the column number\\n            if (letter == 0) { // edge case for Z (26 % 26 == 0)\\n                result.append(\\'Z\\');\\n                column = (column / 26) - 1;\\n                continue;\\n            }\\n\\t\\t\\t// regular case\\n            result.append((char)(\\'A\\' + (letter - 1)));\\n            column /= 26;\\n        }\\n\\t\\t// reverse the result and return\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int column) {\\n\\t\\t// StringBuilder to store the result\\n        StringBuilder result = new StringBuilder();\\n\\t\\t\\n        while (column > 0) {\\n            int letter = (column % 26); // get letter from the column number\\n            if (letter == 0) { // edge case for Z (26 % 26 == 0)\\n                result.append(\\'Z\\');\\n                column = (column / 26) - 1;\\n                continue;\\n            }\\n\\t\\t\\t// regular case\\n            result.append((char)(\\'A\\' + (letter - 1)));\\n            column /= 26;\\n        }\\n\\t\\t// reverse the result and return\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176938,
                "title": "java-0ms-100-fatser",
                "content": "If the number is a multiple of 26 i.e. if remainder is 0, then definitely it is ending with \"Z\". Only if this condition is handled, rest others will fall in place.\\n```\\npublic String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\twhile (columnNumber > 26) {\\n\\t\\t\\tint rem = columnNumber % 26;\\n\\t\\t\\tif (rem == 0) {\\n\\t\\t\\t\\tsb.append(\"Z\");\\n\\t\\t\\t\\tcolumnNumber -= 26;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tsb.append((char) (rem + \\'A\\' - 1));\\n\\t\\t\\tcolumnNumber /= 26;\\n\\t\\t}\\n\\t\\tsb.append((char) (columnNumber + \\'A\\' - 1));\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String convertToTitle(int columnNumber) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\twhile (columnNumber > 26) {\\n\\t\\t\\tint rem = columnNumber % 26;\\n\\t\\t\\tif (rem == 0) {\\n\\t\\t\\t\\tsb.append(\"Z\");\\n\\t\\t\\t\\tcolumnNumber -= 26;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tsb.append((char) (rem + \\'A\\' - 1));\\n\\t\\t\\tcolumnNumber /= 26;\\n\\t\\t}\\n\\t\\tsb.append((char) (columnNumber + \\'A\\' - 1));\\n\\t\\treturn sb.reverse().toString();\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156221,
                "title": "java-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res=new StringBuilder();\\n        while(columnNumber>0){\\n            columnNumber--;\\n            res.append((char)(\\'A\\'+columnNumber%26));\\n            columnNumber/=26;\\n        }\\n        return res.reverse().toString();\\n    }   \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder res=new StringBuilder();\\n        while(columnNumber>0){\\n            columnNumber--;\\n            res.append((char)(\\'A\\'+columnNumber%26));\\n            columnNumber/=26;\\n        }\\n        return res.reverse().toString();\\n    }   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106021,
                "title": "java-simple-solution-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n=columnNumber;\\n        StringBuilder b=new StringBuilder(\"\");\\n        \\n        while(n>0){\\n           int r=n%26;\\n           if(r==0){\\n               b.append(\"Z\");\\n               n=(n-26)/26;\\n           } else{\\n               b.append((char)(64+r));\\n               n=(n-r)/26;\\n           }\\n            \\n        }\\n     return b.reverse().toString();   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        int n=columnNumber;\\n        StringBuilder b=new StringBuilder(\"\");\\n        \\n        while(n>0){\\n           int r=n%26;\\n           if(r==0){\\n               b.append(\"Z\");\\n               n=(n-26)/26;\\n           } else{\\n               b.append((char)(64+r));\\n               n=(n-r)/26;\\n           }\\n            \\n        }\\n     return b.reverse().toString();   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001736,
                "title": "just-6-lines-shortest-c-code-just-check-it",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber)\\n    {\\n        string res = \"\";\\n        while (columnNumber)\\n        {\\n            char ch =\\'A\\' + (columnNumber - 1) % 26;\\n            res = ch + res;\\n            columnNumber = (columnNumber-1)/26;  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber)\\n    {\\n        string res = \"\";\\n        while (columnNumber)\\n        {\\n            char ch =\\'A\\' + (columnNumber - 1) % 26;\\n            res = ch + res;\\n            columnNumber = (columnNumber-1)/26;  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962460,
                "title": "fastest-0-ms-and-simplest-10-eloc-solution-in-c",
                "content": "char * convertToTitle(int columnNumber)\\n{\\n\\n    char * ptr;\\n    ptr = malloc(8 * sizeof(char));\\n    ptr += 7;\\n    *ptr = 0;\\n    \\n    while(columnNumber)\\n    {\\n        ptr--;\\n        columnNumber = columnNumber - 1;\\n        *ptr = (columnNumber%26) + 65;\\n        columnNumber = columnNumber/26;\\n    }    \\n\\n    return ptr;\\n}\\n\\n**Please, upvode if you believe this is the simplest solution in C.**",
                "solutionTags": [
                    "C"
                ],
                "code": "char * convertToTitle(int columnNumber)\\n{\\n\\n    char * ptr;\\n    ptr = malloc(8 * sizeof(char));\\n    ptr += 7;\\n    *ptr = 0;\\n    \\n    while(columnNumber)\\n    {\\n        ptr--;\\n        columnNumber = columnNumber - 1;\\n        *ptr = (columnNumber%26) + 65;\\n        columnNumber = columnNumber/26;\\n    }    \\n\\n    return ptr;\\n}\\n\\n**Please, upvode if you believe this is the simplest solution in C.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1837466,
                "title": "python-simple-and-elegant",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = (n-1)//26, (n-1)%26\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\\n\\n**Using *divmod***:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\\n\\n**Using char map**:\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n\\n        c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```\\n\\n**Generating the charmap using *map***:\\n```\\nclass Solution:\\n    def convertToTitle(self, n):\\n        ans = \"\"\\n\\n        c = list(map(chr,range(ord(\"A\"),ord(\"Z\")+1)))\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = (n-1)//26, (n-1)%26\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = chr(ord(\"A\")+r) + ans\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans = \"\"\\n\\n        c = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def convertToTitle(self, n):\\n        ans = \"\"\\n\\n        c = list(map(chr,range(ord(\"A\"),ord(\"Z\")+1)))\\n        \\n        while n:\\n            n, r = divmod(n-1,26)\\n            ans = c[r] + ans\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588244,
                "title": "python-easy-approach-simple-maths",
                "content": "\\tclass Solution:\\n\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n\\t\\t\\t# AB = A\\xD726\\xB9\\uFF0BB \\uFF1D 1\\xD726\\xB9\\uFF0B2\\n\\t\\t\\t# ABCD\\uFF1DA\\xD726\\xB3\\uFF0BB\\xD726\\xB2\\uFF0BC\\xD726\\xB9\\uFF0BD\\uFF1D1\\xD726\\xB3\\uFF0B2\\xD726\\xB2\\uFF0B3\\xD726\\xB9\\uFF0B4\\n\\t\\t\\tsheet = [chr(i) for i in range(ord(\"A\"), ord(\"Z\")+1)]\\n\\t\\t\\tres = []\\n\\t\\t\\twhile columnNumber > 0:\\n\\t\\t\\t\\tres.append(sheet[(columnNumber-1) % 26])\\n\\t\\t\\t\\tcolumnNumber = (columnNumber-1)//26\\n\\t\\t\\treturn \"\".join(res[::-1])",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef convertToTitle(self, columnNumber: int) -> str:\\n\\t\\t\\t# AB = A\\xD726\\xB9\\uFF0BB \\uFF1D 1\\xD726\\xB9\\uFF0B2\\n\\t\\t\\t# ABCD\\uFF1DA\\xD726\\xB3\\uFF0BB\\xD726\\xB2\\uFF0BC\\xD726\\xB9\\uFF0BD\\uFF1D1\\xD726\\xB3\\uFF0B2\\xD726\\xB2\\uFF0B3\\xD726\\xB9\\uFF0B4\\n\\t\\t\\tsheet = [chr(i) for i in range(ord(\"A\"), ord(\"Z\")+1)]\\n\\t\\t\\tres = []\\n\\t\\t\\twhile columnNumber > 0:\\n\\t\\t\\t\\tres.append(sheet[(columnNumber-1) % 26])\\n\\t\\t\\t\\tcolumnNumber = (columnNumber-1)//26\\n\\t\\t\\treturn \"\".join(res[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 1473821,
                "title": "python-easy-to-understand-solution",
                "content": "1. Extract the ascii value of A and the module of columNumber, (caveat: columnNumber need to subtract itself by 1 in order to match the exact ascii value). \\n2. This process gives us the result in the reverse order, we still need to change it back to the normal order.\\n```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        \"\"\"\\n        :type columnNumber: int\\n        :rtype: str\\n        \"\"\"\\n        ans = \\'\\'\\n        while columnNumber > 0:\\n              columnNumber -= 1 \\n              ans += chr(ord(\\'A\\') + columnNumber % 26)\\n              columnNumber /= 26\\n            \\n        \\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, columnNumber):\\n        \"\"\"\\n        :type columnNumber: int\\n        :rtype: str\\n        \"\"\"\\n        ans = \\'\\'\\n        while columnNumber > 0:\\n              columnNumber -= 1 \\n              ans += chr(ord(\\'A\\') + columnNumber % 26)\\n              columnNumber /= 26\\n            \\n        \\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399078,
                "title": "c-7-lines-explanation",
                "content": "Let\\'s write down the first `26 + 26^2` excel titles.\\n\\n`A, B, C, ..., Z, AA, AB, ..., ZZ`\\n\\nNotice that the last digit always fluctuates between letters `A, B, C, ..., Z`. \\nSo the formula for the last digit is `x = (char) (\\'A\\' + (n-1) % 26)`\\n\\nNow, if we divide `n-1` by `26`, it is going to become 0 for the first 26 titles and `m` for everything else, \\nwhere `m` is the 1-based index of the second to last tittle letter in the alphabet.\\n\\nFor titles longer than 2 letters we can show by recursion that `m` is the number corresponding to the excel title \\n`s = convertToTitle(m) ` such that `s + x == convertToTitle(n)`.\\n\\nUsing this method, we can solve the problem by updating `n` until it reaches `0`, which means that there are no more letters left.\\n\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string s;\\n        while (n > 0) {\\n            n -= 1;\\n            s.push_back(\\'A\\' + n % 26);\\n            n /= 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string s;\\n        while (n > 0) {\\n            n -= 1;\\n            s.push_back(\\'A\\' + n % 26);\\n            n /= 26;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347481,
                "title": "0-ms-faster-than-100-java",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0){\\n            n--;\\n            s.append((char)(\\'A\\' + n % 26));\\n            n /= 26;\\n        }\\n    return s.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0){\\n            n--;\\n            s.append((char)(\\'A\\' + n % 26));\\n            n /= 26;\\n        }\\n    return s.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313492,
                "title": "100-faster-c",
                "content": "```class Solution {\\npublic:\\n    string convertToTitle(int n) {\\n      string result=\"\";\\n      while(n>0){\\n          char c=\\'A\\'+(n-1)%26;\\n          result=c+result;\\n          n=(n-1)/26;\\n      }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    string convertToTitle(int n) {\\n      string result=\"\";\\n      while(n>0){\\n          char c=\\'A\\'+(n-1)%26;\\n          result=c+result;\\n          n=(n-1)/26;\\n      }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256201,
                "title": "js-simple-and-easy-to-understand-o-n-only",
                "content": "Javascript beat 97%\\n```\\nvar convertToTitle = function(columnNumber) {\\n    let roundQuotient= 0;\\n    let result =\"\"\\n    while (columnNumber){\\n        result = String.fromCharCode(((columnNumber-1)%26)+97) + result\\n        columnNumber = Math.floor((columnNumber-1)/26);\\n        console.log(\"result in loop\", result, \"column#\", columnNumber)\\n    }\\n    console.log(\"final\",result)\\n    return result.toUpperCase()\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar convertToTitle = function(columnNumber) {\\n    let roundQuotient= 0;\\n    let result =\"\"\\n    while (columnNumber){\\n        result = String.fromCharCode(((columnNumber-1)%26)+97) + result\\n        columnNumber = Math.floor((columnNumber-1)/26);\\n        console.log(\"result in loop\", result, \"column#\", columnNumber)\\n    }\\n    console.log(\"final\",result)\\n    return result.toUpperCase()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252667,
                "title": "c-4-ms-100-faster",
                "content": "```\\nstring convertToTitle(int colNum) {\\n        string s;\\n        int x=0;\\n        while(colNum){\\n        x=colNum%26;colNum/=26;\\n        if(x<=0){ x+=26; colNum--;}\\n        s.push_back(\\'A\\'+x-1);\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring convertToTitle(int colNum) {\\n        string s;\\n        int x=0;\\n        while(colNum){\\n        x=colNum%26;colNum/=26;\\n        if(x<=0){ x+=26; colNum--;}\\n        s.push_back(\\'A\\'+x-1);\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024324,
                "title": "easy-to-read-c-code",
                "content": "char * convertToTitle(int n){\\n    \\n    int numberOfCharacters = 0;\\n    int input = n;\\n    while(input > 0){\\n        input -= 1;\\n        input /=26;\\n        numberOfCharacters++;\\n    }\\n    \\n    //+1 for the null terminator\\n    char * rv = calloc(numberOfCharacters+1, sizeof(char));\\n    \\n    //filling characters from the back\\n    int index = numberOfCharacters - 1;\\n    input = n;\\n    while(index >= 0){\\n        input -= 1;\\n        rv[index--] = (input % 26) + \\'A\\';\\n            \\n        input /=26;\\n    }\\n    \\n    return rv;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "char * convertToTitle(int n){\\n    \\n    int numberOfCharacters = 0;\\n    int input = n;\\n    while(input > 0){\\n        input -= 1;\\n        input /=26;\\n        numberOfCharacters++;\\n    }\\n    \\n    //+1 for the null terminator\\n    char * rv = calloc(numberOfCharacters+1, sizeof(char));\\n    \\n    //filling characters from the back\\n    int index = numberOfCharacters - 1;\\n    input = n;\\n    while(index >= 0){\\n        input -= 1;\\n        rv[index--] = (input % 26) + \\'A\\';\\n            \\n        input /=26;\\n    }\\n    \\n    return rv;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1003417,
                "title": "python3-faster-than-98-iterative-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans=\\'\\'\\n        while n:\\n            ans=chr(ord(\\'A\\')+((n-1)%26))+ans\\n            n=(n-1)//26\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        ans=\\'\\'\\n        while n:\\n            ans=chr(ord(\\'A\\')+((n-1)%26))+ans\\n            n=(n-1)//26\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761494,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder res = new StringBuilder();\\n        while(n>0){\\n            n--;\\n            res.insert(0,(char)(\\'A\\'+n%26));\\n            n/=26;\\n        }\\n      return res.toString();  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder res = new StringBuilder();\\n        while(n>0){\\n            n--;\\n            res.insert(0,(char)(\\'A\\'+n%26));\\n            n/=26;\\n        }\\n      return res.toString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732378,
                "title": "java-100-fast",
                "content": "If you found this solution helpful, kindly upvote. :)\\n\\n```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0)\\n        {\\n            n--;\\n            char ch=(char)(n%26+\\'A\\');\\n            n=n/26;\\n            s.append(ch);\\n        }\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int n) {\\n        StringBuffer s=new StringBuffer();\\n        while(n>0)\\n        {\\n            n--;\\n            char ch=(char)(n%26+\\'A\\');\\n            n=n/26;\\n            s.append(ch);\\n        }\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384223,
                "title": "swift-0ms-solution-without-unicodescalar",
                "content": "```\\n    func convertToTitle(_ n: Int) -> String {\\n        let chars = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\\n        var result = \"\"\\n        var current = n\\n        while current > 0 {\\n            result = chars[(current-1) % 26] + result\\n            current = (current-1) / 26\\n        }\\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func convertToTitle(_ n: Int) -> String {\\n        let chars = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\\n        var result = \"\"\\n        var current = n\\n        while current > 0 {\\n            result = chars[(current-1) % 26] + result\\n            current = (current-1) / 26\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275262,
                "title": "python-1-line-solution",
                "content": "```python\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        return \\'\\' if n == 0 else self.convertToTitle((n - 1) // 26) + chr(ord(\\'A\\') + (n - 1) % 26)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        return \\'\\' if n == 0 else self.convertToTitle((n - 1) // 26) + chr(ord(\\'A\\') + (n - 1) % 26)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227481,
                "title": "c-recursive-and-iterative",
                "content": "I once thought this problem was just something that I would encounter as an interview problem until I was populating data from numpy arrays to excel sheets for analysis. At that time I needed to transfrom an integer numpy array column index to a string excel column name, which is exactly what this problem asks us to do :-)\\n\\n**Recursive**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        return n ? convertToTitle((n - 1) / 26) + char(65 + (n - 1) % 26) : \"\";\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string title;\\n        while (n) {\\n            title += char(65 + --n % 26);\\n            n /= 26;\\n        }\\n        reverse(title.begin(), title.end());\\n        return title;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        return n ? convertToTitle((n - 1) / 26) + char(65 + (n - 1) % 26) : \"\";\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string convertToTitle(int n) {\\n        string title;\\n        while (n) {\\n            title += char(65 + --n % 26);\\n            n /= 26;\\n        }\\n        reverse(title.begin(), title.end());\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173559,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        while n > 26:\\n            n, r = divmod(n, 26)\\n            if r == 0:\\n                n -= 1\\n                r += 26\\n            res = chr(ord(\"A\") - 1 + r) + res\\n        res = chr(ord(\"A\") - 1 + n) + res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def convertToTitle(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        res = \"\"\\n        while n > 26:\\n            n, r = divmod(n, 26)\\n            if r == 0:\\n                n -= 1\\n                r += 26\\n            res = chr(ord(\"A\") - 1 + r) + res\\n        res = chr(ord(\"A\") - 1 + n) + res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51448,
                "title": "c-uff0cfirst-time-beats-100",
                "content": "```\\npublic string ConvertToTitle(int n) {\\n            string ss = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res = \"\";\\n            while(n>0)\\n            {\\n                res = ss[n % 26] + res;\\n                n = (n % 26 == 0) ? (n / 26 - 1) : (n / 26);\\n            }\\n            return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic string ConvertToTitle(int n) {\\n            string ss = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\";\\n            string res = \"\";\\n            while(n>0)\\n            {\\n                res = ss[n % 26] + res;\\n                n = (n % 26 == 0) ? (n / 26 - 1) : (n / 26);\\n            }\\n            return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51470,
                "title": "java-concise-solution",
                "content": "        \\n    public String convertToTitle(int n) {\\n        String ret = \"\";\\n        while (n != 0) {\\n            ret = (char)('A'+(--n)%26) + ret;\\n            n /= 26;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public String convertToTitle(int n) {\\n        String ret = \"\";\\n        while (n != 0) {\\n            ret = (char)('A'+(--n)%26) + ret;\\n            n /= 26;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51481,
                "title": "java-ac-solution",
                "content": "    public class Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n != 0) {\\n            sb.append((char)('A' + (n - 1) % 26)); \\n            n = (n - 1) / 26;\\n        }\\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public String convertToTitle(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        while (n != 0) {\\n            sb.append((char)('A' + (n - 1) % 26)); \\n            n = (n - 1) / 26;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51491,
                "title": "simple-solution-for-java",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            char[] alpha = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\".toCharArray();\\n            String s = \"\";\\n            while(n != 0){\\n                s = alpha[n % 26] + s;\\n                if(n % 26 == 0)\\n                    n -= 26;\\n                n /= 26;\\n            }\\n            return s;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            char[] alpha = \"ZABCDEFGHIJKLMNOPQRSTUVWXY\".toCharArray();\\n            String s = \"\";\\n            while(n != 0){\\n                s = alpha[n % 26] + s;\\n                if(n % 26 == 0)\\n                    n -= 26;\\n                n /= 26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51511,
                "title": "easy-c-solution",
                "content": "    class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string str =\"\";\\n            while(n>0)\\n            {\\n                char letter = 'A'+(n-1)%26;\\n                str = letter+str;\\n                n = (n-1)/26;\\n            }\\n            return str;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string convertToTitle(int n) {\\n            string str =\"\";\\n            while(n>0)\\n            {\\n                char letter = 'A'+(n-1)%26;\\n                str = letter+str;\\n                n = (n-1)/26;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51515,
                "title": "easy-recursive-solution-in-java-this-is-still-efficient-cause-log-by-26",
                "content": "    public class Solution {\\n        public String convertToTitle(int n) {\\n            // 0-25 -> A-Z, so n will dercrease by 1\\n            n = n-1;\\n            if(n<=25) \\n                return \"\"+(char)(n+65);\\n            else\\n                return convertToTitle(n/26)+\"\"+(char)(n%26+65);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String convertToTitle(int n) {\\n            // 0-25 -> A-Z, so n will dercrease by 1\\n            n = n-1;\\n            if(n<=25) \\n                return \"\"+(char)(n+65);\\n            else\\n                return convertToTitle(n/26)+\"\"+(char)(n%26+65);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51526,
                "title": "0ms-in-c-code-we-don-t-need-stl",
                "content": "    char* convertToTitle(int n) {\\n        char *res = (char *)calloc(8, sizeof(char));\\n        int i = 6;\\n        while(n){\\n            res[i--] = (char)((n-1) % 26) + 'A';\\n            n = (n - 1) / 26;\\n        }\\n        return res+i+1;\\n    }",
                "solutionTags": [],
                "code": "    char* convertToTitle(int n) {\\n        char *res = (char *)calloc(8, sizeof(char));\\n        int i = 6;\\n        while(n){\\n            res[i--] = (char)((n-1) % 26) + 'A';\\n            n = (n - 1) / 26;\\n        }\\n        return res+i+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51577,
                "title": "my-simple-recursive-python-solution",
                "content": "    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            alph = ''.join(map(chr, range(65, 91)))\\n            return (self.convertToTitle((num-1)/len(alph)) if num>len(alph) else '' )+alph[(num-1)%len(alph)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return a string\\n        def convertToTitle(self, num):\\n            alph = ''.join(map(chr, range(65, 91)))\\n            return (self.convertToTitle((num-1)/len(alph)) if num>len(alph) else '' )+alph[(num-1)%len(alph)]",
                "codeTag": "Java"
            },
            {
                "id": 51524,
                "title": "share-my-code-with-c-1ms",
                "content": "    char *convertToTitle(int n) {\\n        int char_size = 0, num = n, i = 1;\\n    \\tchar *result;\\n    \\twhile(num > 0) {\\n            num = (num - 1) / 26;\\n            char_size++;\\n        }\\n    \\tresult = (char *) malloc(char_size*sizeof(char));\\n        while(n > 0) {\\n    \\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t*(result + char_size - i) = 'Z';\\n    \\t\\t} else {\\n    \\t\\t\\t*(result+char_size-i) = (char)('A' + n%26 - 1);\\n    \\t\\t}\\n    \\t\\tn = (n - 1) / 26;\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn result;\\n    }",
                "solutionTags": [],
                "code": "    char *convertToTitle(int n) {\\n        int char_size = 0, num = n, i = 1;\\n    \\tchar *result;\\n    \\twhile(num > 0) {\\n            num = (num - 1) / 26;\\n            char_size++;\\n        }\\n    \\tresult = (char *) malloc(char_size*sizeof(char));\\n        while(n > 0) {\\n    \\t\\tif(n % 26 == 0) {\\n    \\t\\t\\t*(result + char_size - i) = 'Z';\\n    \\t\\t} else {\\n    \\t\\t\\t*(result+char_size-i) = (char)('A' + n%26 - 1);\\n    \\t\\t}\\n    \\t\\tn = (n - 1) / 26;\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3997394,
                "title": "excel-sheet-column-title",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        while(columnNumber)\\n        {\\n            columnNumber--;\\n            int digit=columnNumber%26+65;\\n             columnNumber=columnNumber/26;\\n            ans=(char)(digit)+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        string ans=\"\";\\n        while(columnNumber)\\n        {\\n            columnNumber--;\\n            int digit=columnNumber%26+65;\\n             columnNumber=columnNumber/26;\\n            ans=(char)(digit)+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947106,
                "title": "beats-100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(columnNumber!=0)\\n        {\\n            columnNumber-=1;\\n            int rem=columnNumber%26;\\n            sb.append((char)(rem+65));\\n            columnNumber/=26;\\n        }\\n        sb=sb.reverse();\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertToTitle(int columnNumber) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(columnNumber!=0)\\n        {\\n            columnNumber-=1;\\n            int rem=columnNumber%26;\\n            sb.append((char)(rem+65));\\n            columnNumber/=26;\\n        }\\n        sb=sb.reverse();\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946744,
                "title": "simple-solution-explained-with-examples-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is really simple.It just needs some observation skills. Let us just take an example .let the column number be **126**\\n\\nNow,Let us just calculate the **remainder and divisor of 126 when we divide it by 26**\\n\\n**Remainder = 126%26 = 22**\\n\\n**Divisor = 126/22 = 4**\\n\\nNow, 22nd alphabet is \"V\"\\nNow, 4th alphabet is \"D\"\\n\\nSO your string becomes **\"DV\"**\\n\\nNow, let us take a bigger example , Let the no be **2832355**\\n\\nNow, let us calculate the remainder and divisor \\n\\nRemainder = 2832355%26 = 19\\n\\nDivisor = 2832355/26 = 108936\\n\\nNow we know the 19th alphabet is \"S\" so we will add this in our answer string ,\\nNow our divisor (108936) is really big so again we will calculate the remiander and divisor for this..\\n\\nRemainder = 108936%26 = 22\\n\\nDivisor = 108936/26 = 4189\\n\\nNow, we know the 22nd alpahbet is \"V\", so we will add this in our answer string so our answer string becomes \"SV\"\\n\\nNow, 4189 is also really big, wo we will again repeat this step and keep on adding the remainder.\\n\\n**We need to make sure that when the divisor is less then or equal to 26, we will add that particular alphabet in our string ...**\\n\\nNow, just **reverse this string** and return the ans...\\n\\n# **SPECIAL CASE-**\\n\\nLet us say the no is \"52\", Now you see when we calculate the remiander and divisor it comes to be\\n\\nrem = 52 %26 = 0\\n\\ndiv = 52/26 = 2\\n\\nNow, In such case when the rem = 0, if you follow the above case , then your answer will become \"B\", but that is wrong..\\n\\nSO, **whenever you rem comes to be 0**, you will do **rem  =  rem +26** and **div = div-1**\\n\\nso , if you calculate the string now, so it will become **\"AZ\"**...so this is how you will handel such cases\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are continously dividing the number by 26..so it will be **log(n**), but the **base of that log will be 26**...\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**No extra space taken**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int col) {\\n        string ans = \"\";\\n        while(col>0)\\n        {\\n            int d = col/26;\\n            int rem = col%26;\\n            if(rem==0)\\n            {\\n                rem  =26;\\n                d--;\\n            }\\n            if(rem!=0)\\n            {\\n                char z= rem+64;\\n                ans+=z;\\n            }\\n            if(d<=26 && d!=0)\\n            {\\n                char z = d+64;\\n                ans+=z;\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n            }\\n            else\\n            {\\n                col = d;\\n            }\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```\\n**TIME FOR A MEME NOW**\\n![WhatsApp Image 2023-08-22 at 22.55.11.jpeg](https://assets.leetcode.com/users/images/3442240d-cc49-490a-aff8-afc1b9caf1f5_1692725600.1917834.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTE...**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int col) {\\n        string ans = \"\";\\n        while(col>0)\\n        {\\n            int d = col/26;\\n            int rem = col%26;\\n            if(rem==0)\\n            {\\n                rem  =26;\\n                d--;\\n            }\\n            if(rem!=0)\\n            {\\n                char z= rem+64;\\n                ans+=z;\\n            }\\n            if(d<=26 && d!=0)\\n            {\\n                char z = d+64;\\n                ans+=z;\\n                reverse(ans.begin(),ans.end());\\n                return ans;\\n            }\\n            else\\n            {\\n                col = d;\\n            }\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946669,
                "title": "c-easy-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Intution\\n        // The idea in here is really very simple. It is similar to base 2 with a base of 26. Here we will subract the value of 1 so that we will get the exact string.\\n\\n        string answer = \"\";\\n\\n        while(columnNumber > 0){\\n            columnNumber -= 1;\\n            answer = char(columnNumber % 26 + \\'A\\') + answer;\\n            columnNumber /= 26;\\n        }\\n        \\n        return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n        // Intution\\n        // The idea in here is really very simple. It is similar to base 2 with a base of 26. Here we will subract the value of 1 so that we will get the exact string.\\n\\n        string answer = \"\";\\n\\n        while(columnNumber > 0){\\n            columnNumber -= 1;\\n            answer = char(columnNumber % 26 + \\'A\\') + answer;\\n            columnNumber /= 26;\\n        }\\n        \\n        return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1721592,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2025000,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1564863,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024756,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1568035,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1566874,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1917390,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1576624,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024796,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1731930,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1721592,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2025000,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1564863,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024756,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1568035,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1566874,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1917390,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1576624,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2024796,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 1731930,
                "content": [
                    {
                        "username": "va_m",
                        "content": "I think the question is incomplete cos it doesn\\'t really give the full intuition behind the pattern. Not everyone is aware of the column naming practices of \"Excel\". I had to run it manually with multiple different custom test cases to find out the pattern. Was a huge waste of time.\\nIf the pattern / working of the pattern is described properly, it becomes a \"SIMPLE\" problem, since you only have to code the pattern. This must be a coding question, not finding out the secret pattern question. Cos if it is \"find the secret pattern\" question, then it should be tagged as such and annotated as a \"MEDIUM\" problem."
                    },
                    {
                        "username": "bangychiller",
                        "content": "how long did you take to verify all the custom cases\ni've got 2 solutions\n1 runs on random column titles\nand the other one works only on 26 power(1,2,3,4,5,6) or the Z,ZZ,ZZZ patterns\n\nanybody who can figure out the issue i'm facing if could comply it'd be really heplful.\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "Finally an Easy...?\\n`Acceptance Rate: 36.8%`\\nOh..."
                    },
                    {
                        "username": "Nemo-7777",
                        "content": "But still marked as \\'easy\\' task"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "consider the letter 'A' to have a value of 1, 'B'->2 ..... 'Z'->26\\nnote that in the above notation, values are 1-based\\n\\nhere our Radix (R) == 26\\n\\nthe final value of a number X Y Z = X * R^2 + Y * R + Z\\n\\nthis looks similar to base-10 decimal number but the biggest difference is that the numbers on every digit starts with 1, instead of 0., and the max on each digit goes up to R (Radix) instead of R-1\\n\\nfor example\\nZ== Radix\\nthen next number is AA = R + 1 = Z+1\\nZZ = R * R + R\\nnext number is  AAA = 1*R^2 + 1 * R + 1 = ZZ +1\\n\\nso from the AAA notation to their sequence number (decimal) it's easy, but the other way is a bit tricky due to the way % and / operates"
                    },
                    {
                        "username": "786_Rishabh",
                        "content": "[@adityashivhare7291](/adityashivhare7291)  AZ"
                    },
                    {
                        "username": "adityashivhare7291",
                        "content": "for 52 what is the answer\\n"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "This should be a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "100%"
                    },
                    {
                        "username": "hucraig",
                        "content": "The goal of this problem is to convert base10 system to base26 system.\\nExcel sheet base26 system is represented by the 26 capital letters. Note this system has no concept of 0. Similar to Roman numerals, where 0 does not exist. I.E. X = 10. XI = 11.\\n\\nIn a base10 system, 58 is \\n10 * 5 + 8.\\n58 is represented by the sixth digit, and the ninth digit in the base10 system where 0 does exist.\\n\\nIn base26 system, the number 58 is actually\\n26 * 2 + 6. \\nTherefore, it is represented by the second letter + the sixth letter, which is \\'BF\\' in this case.\\n\\nConclusively, we can keep modding/dividing to get the last character in the base26 system.\\n"
                    },
                    {
                        "username": "mayanksinghbohra",
                        "content": "this is not a number system of 26, because it starts from 1->A, for it to be a number system, it should start from 0->A."
                    },
                    {
                        "username": "rutujp78",
                        "content": "[@Uzumaki_123](/Uzumaki_123) In such cases, 0 indicates that it is 'Z' and 56 is 'AZ'. 'Z' value can also be 26 in base26 system."
                    },
                    {
                        "username": "JannisBK",
                        "content": "thanks for this pretty straightforward explanation\\n"
                    },
                    {
                        "username": "Uzumaki_123",
                        "content": "What about 52 bro that is 20 in base 26 how can we represent this one "
                    },
                    {
                        "username": "cipone",
                        "content": "Can anybody please explain the -1 step, it seems very unintuitive to me. Can anybody please explain why do we need to substract 1 before we do the modulo and division operations ?"
                    },
                    {
                        "username": "chirag019",
                        "content": "\n### Taking A as 1, B as 2, C as 3... Z as 26\n\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber:\n            # for Z, this will return 0\n            r = columnNumber % 26\n            char = \"Z\" if r == 0 else chr(r + ord(\"A\") - 1)\n\n            res = char + res\n\n            columnNumber //= 26\n\n            # In case the character was \"Z\", then we'll have to subtract 1\n            # Example: say columnNumber = 26, now columnNumber // 26 will give 1 and the loop will run again\n            columnNumber -= (r == 0)\n\n        return res\n\nMaybe this will make more sense?"
                    },
                    {
                        "username": "ILikesCaviar",
                        "content": "I\\'m not even sure this is right, but consider the number of symbols in each placement. It\\'s 26, and because of this we know that the modulus is going to be 26. The problem is squaring the counting system that starts at 0 with the counting system that starts at 1. If you consider the output of the modulus function: In the system that starts counting at 1, the 0th indexed symbol has a value of 1 not nil, therefore the actual value of the remainder is 1 greater then what it should be (in the system starting with nil symbol). Subtracting 1 beforehand just lines up the numbers as 1 is implicitly added back to the \"remainder\" from the conversion of counting systems."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "The tricky thing is that you can have a \\'Z\\' (i.e. 26) when it\\'s a 26-based number system. And also there\\'s no 0."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n \\n![image](https://assets.leetcode.com/users/images/78c52125-ce7d-4108-98e3-624aa7759e99_1649953209.2580774.png)\\n\\n\\n ![image](https://assets.leetcode.com/users/images/4c376817-8256-47d2-bb7c-3567c2212eb0_1649953678.67787.png)\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "How to express n as a 26-radix number? Consider the following\n$$\nn=\\sum_i a_i26^i\n$$\nwhere $0\\leq a_i<26$. This can be done by successive divisions by 26. But there is no 0 in excel, so it needs some modification, i.e.\n$$\nn=\\sum_i (a_i+1)26^i\n$$\n\nUse  the  exact formula\n```\nint len=(n<=26)?1:ceil(log(n*25.0/26+1)/log(26));\n```\nto compute the the length for the string.\nOther approach can use deque!"
                    },
                    {
                        "username": "Xephiare",
                        "content": "Can someone explain why we subtract columnNumber -= 1 if the modulo is 0?"
                    },
                    {
                        "username": "saddhu1005",
                        "content": "when mod is 0, it basically means that current char is \\'Z\\'.\\nthe value of \\'Z\\' is 26.\\n\\nconsider below sequence:\\n`AAA => 1*26*26 + 1*26 + 1`\\n\\nSo, when we get a column number, we want to break this into above sequence\\n`... c3 * 26*26 + c2 * 26 + c1`\\n\\nwe can see a pattern here:\\nstep 1: if we take modulo of 26, we can get the last Alphabet (c1).\\nstep 2: now after we divide the number with 26, we can repeat the steps and solve for next iteration. After dividing by 26, equation should become as below:\\n`... c3*26 + c2 + c1/26`\\n\\nhere, the only problem is `c1/26`, we want this value to become 0 to solve for next Alphabet c2, but c1 value can be at max 26 (character \\'Z\\').\\nSo, when modulo is 0, we decrement the value by one, so that  `(c1 - 1/26)` becomes 0."
                    },
                    {
                        "username": "sauravpaul",
                        "content": "may be this will make more sense,\\n```\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        results = \"\"\\n\\n        while columnNumber > 0:\\n            mod = columnNumber % 26\\n            mod = 26 if mod == 0 else mod\\n            columnNumber -= mod\\n            columnNumber //= 26\\n            results += chr( ord(\\'A\\') - 1 + mod)\\n            \\n        return results[::-1]\\n```"
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@johnnyboy1981](/johnnyboy1981)  please watch this https://youtu.be/UcTKk2y_3s4 , he  explain in very nice way "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "[@Serenity404](/Serenity404) brilliant explanation thank you!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "This is a base conversion problem from base10 to base26. The tricky part is the fact that base26 in this case does not have a 0 value. Imagine if the base10 did not start from 0 to 8,9 but instead went from 1 to 9,X. Nothing changed you still have 10 digits but instead of 0 which holds 0 value you have X which corresponds to 10. Writing 1 in this new system is still 1. 2->2 and 9->9 and 10->X and 11->11 and 18->18 and 19->19 and 21->21 so you get the idea. Values without any 0 digit works the exact same way since we did not change the base10 nor did we change the real value of the digits 1 to 9. Try to write 20 or 30 in this new format tho. You have no 0 now. \\n\\nThat\\'s where the -1 comes from. If a digit is 10 in base10 then the value to the left will have to be 1 smaller because that one carried over to the right digit which is X. So 30 in above paragraph is now 2X because 2 in the second place means 10^1 * 2 = 20 and X in last digit is 10^0 * X = 10 which makes 20+10 = 30  "
                    }
                ]
            },
            {
                "id": 2025196,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 2025045,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1861327,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1673025,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1570273,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 2025258,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1898457,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1824372,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1787935,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 1762523,
                "content": [
                    {
                        "username": "KingShuK17",
                        "content": "All thanks to ARYABHATTA for 0!\nElse life would've been weird.\nLike this question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think figuring out the logic/pattern for this problem is a bit difficult for an easy question...."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This problem made me thank the arabic mathematicians for discovering the 0. Bless you, math without a 0 is stupid af, turns out.\\nA bit more confusing than your average easy problem, this one. Had me counting on my fingers and drawing circles"
                    },
                    {
                        "username": "Swapnamoy45",
                        "content": "We INDIANS discovered the Zero \\uD83D\\uDE24"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "Zero was discovered by indian mathematics"
                    },
                    {
                        "username": "nikhilthengane700",
                        "content": "[@deepakmajhi22](/deepakmajhi22) exactly "
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "zero is discovered by Aryabhatta a Indian mathematician."
                    },
                    {
                        "username": "Warun_Sharma",
                        "content": "Do this problem first: [leetcode](Do this problem first: https://leetcode.com/problems/excel-sheet-column-number/description/)"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = \"\"\\n\\twhile n > 0:\\n\\t\\tn -= 1\\n\\t\\tresult = chr(n % 26 + ord(\\'A\\')) + result\\n\\t\\tn //= 26\\n\\treturn result"
                    },
                    {
                        "username": "andykimchris",
                        "content": "[@StacyAceIt](/StacyAceIt) Don\\'t thank him, he should send it to Solutions, not expose it here"
                    },
                    {
                        "username": "anjith",
                        "content": "[@StacyAceIt](/StacyAceIt) It should be shared in Solutions. Not in Discussions."
                    },
                    {
                        "username": "andresstawski",
                        "content": "[@StacyAceIt](/StacyAceIt) not working halp\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@StacyAceIt](/StacyAceIt) it just looks simple, but proving the n-=1 step is not so straight-forward"
                    },
                    {
                        "username": "geo1923",
                        "content": "Which part of \"don\\'t share solutions here\" is hard to get?"
                    },
                    {
                        "username": "StacyAceIt",
                        "content": "This is the simplest, most straightforward and best solution. Thanks for sharing!"
                    },
                    {
                        "username": "algoacer",
                        "content": "**The disappointment you get when you struggle to solve the easy question after solving mediums and then hards.**"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "that\\'s why I skip easy problems. or they are misleaded hard or full of edge cases "
                    },
                    {
                        "username": "strdos",
                        "content": "I think this problem deserves to be in the \\'Medium\\' group."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "bruhh!! its should not be easy i believe"
                    },
                    {
                        "username": "bumate90",
                        "content": "Wow, that is easily a medium."
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "for real"
                    },
                    {
                        "username": "eduard92",
                        "content": "Really annoying problem. Testcases are not great I didn't expect this \"FXSHRXW\" in an excel sheet but okay. I never created an excel sheet from scratch, maybe there is a logic behind that testcase. \nI am assuming each division has a remainder and I just keep concatenating, since my logic was fine for two characters.."
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "yes not able to solve testcase when columnNumber is divisible by 26 ;\\ni.e. when remainder becomes 0;"
                    }
                ]
            },
            {
                "id": 2025764,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2024933,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2012185,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 1661065,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 1575253,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 1919041,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2055348,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2038741,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2036224,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2030357,
                "content": [
                    {
                        "username": "anantverma711",
                        "content": "Decrement the number before taking the remainder instead of subtracting 1 while pushing to string."
                    },
                    {
                        "username": "psionl0",
                        "content": "*BLUSH*\\nI\\'ll admit I had to check the editorial to get the string conversion correct. The fact that each base 26 digit runs from 1 to 26 instead of 0 to 25 is a complicating factor."
                    },
                    {
                        "username": "user5921T",
                        "content": "Well, I spent way too long on this before I worked out that we\\'re not just looking for base 26 conversion. Because although 0 = 00 = 000, A != AA != AA. "
                    },
                    {
                        "username": "AmanSahani27",
                        "content": "Here I\\'m providing you a very simplest way of doing reverse solution i.e.  ( A->1) , (ZY-> 701)\\niTS PROVING TO SOLVE IN BOTH DIRECTION\\n\\n\\n\\n\\nimport java.util.*;\\n\\nimport java.util.Collection;\\npublic class excel_sheet_column_title2 {\\n\\n\\tpublic static void main(String[] args) {\\n\\t\\t// TODO Auto-generated method stub\\nMap<Integer,Character>map =new HashMap<>();\\nfor(int i=1;i<27;i++)\\n{\\n\\tmap.put(i,(char)(65+i-1 ));\\n}\\n\\n\\t\\tScanner sc= new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter sting alphabates to get it values.....\\\\n\");\\n\\t\\tString s= sc.nextLine().toUpperCase();\\n\\t\\tint sm=0,sum=0;\\n\\n\\t\\tint m=0,ans=0;\\n\\t\\tif(s.charAt(0)>=\\'A\\' && s.charAt(0)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsm=(s.charAt(0)-(64));\\n\\t\\t\\t//m++;\\n\\t\\t}\\n\\t\\tif(s.length()>1) {\\n\\t\\tfor(int i=1;i<s.length();i++) {\\n\\t\\t\\t\\n\\t\\t \\n\\t\\t if(s.charAt(i)>=\\'A\\' && s.charAt(i)<=\\'Z\\')\\n\\t\\t{\\n\\t\\t\\tsum=(s.charAt(i)-(64));\\n\\t\\t\\t    ans=26*sm;\\n\\t\\t\\t    int f=ans+sum;\\n\\t\\t\\t    int answer=f/26;\\n\\t\\t\\t    int answer2=f%26;\\n\\t\\t\\t  System.out.println(f);\\n\\t\\t\\t    \\tSystem.out.println(\"from map \"+ map.get(answer)+\"\"+map.get(answer2));\\n\\t\\t\\t    \\t\\n\\t\\t}\\n\\t\\t}\\n\\t\\t}\\n\\t\\telse\\t\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(map.get(sm));\\n\\t\\t\\t\\t//System.out.println(sm);\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t}\\n\\t\\t}\\n"
                    },
                    {
                        "username": "kindsword",
                        "content": "It\\'s the whole point of the answer, but no body seems to try to give an  explanation."
                    },
                    {
                        "username": "Gev87",
                        "content": "Say thank you :) \\n\\n    let Num = {\\n        1: `A`,\\n        2: \"B\",\\n        3: \"C\",\\n        4: \"D\",\\n        5: \"E\",\\n        6: \"F\",\\n        7: \"G\",\\n        8: \"H\",\\n        9: \"I\",\\n        10: \"J\",\\n        11: \"K\",\\n        12: \"L\",\\n        13: \"M\",\\n        14: \"N\",\\n        15: \"O\",\\n        16: \"P\",\\n        17: \"Q\",\\n        18: \"R\",\\n        19: \"S\",\\n        20: \"T\",\\n        21: \"U\",\\n        22: \"V\",\\n        23: \"W\",\\n        24: \"X\",\\n        25: \"Y\",\\n        26: \"Z\",\\n    }\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "Don\\'t hardcode, you can probably find a way to generate this in your language, zipping is common, or simply use ord and offset."
                    },
                    {
                        "username": "a8hi",
                        "content": "theres simpler ways to do this. Noone would want to write this in an interview."
                    },
                    {
                        "username": "rizqu",
                        "content": "Hint:  The problem pattern is Base26"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Easy.. they said"
                    },
                    {
                        "username": "rcon9494",
                        "content": "Before submitting, I recommend adding the below to testcases:\\n`26`,`53`"
                    },
                    {
                        "username": "AllDayCoder",
                        "content": "This is the hardest \\'Easy\\' I have ever done."
                    }
                ]
            },
            {
                "id": 2028871,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026300,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026169,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026137,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2026041,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025845,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025831,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025822,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025792,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025745,
                "content": [
                    {
                        "username": "htetminhlaing",
                        "content": "Why do I keep getting this error? \\nRuntime Error\\n3 / 19 testcases passed\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "samorV",
                        "content": "Easy, huh?\\nAfter wasting too much time trying to determine why regular radix conversions are inconsistent, I think I know what hint should be given for things to fall into place.\\nNormally you have:\\n (1)`ABC = A * radix^2 + B * radix + C`\\nwhere digits A, B, C are in range [0, radix - 1], and therefore\\n(2)`C = ABC % radix`\\n(3)`AB = ABC / radix`\\nIn the case of Excel column indexing you have the same logic (1), but for digits in range [1, radix]. Consider how this shift affects expressions (2) and (3). Think of how you can fix it."
                    },
                    {
                        "username": "khe1154",
                        "content": "it would be easy if A started at 0 instead of 1"
                    },
                    {
                        "username": "natitati",
                        "content": "Nightmare."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Looks like this week is challenging, regardless of the problem category."
                    },
                    {
                        "username": "tamalCodes",
                        "content": "I wonder why this question is marked as `easy` and not `medium`. TBH it\\'s not that easy when you look at the patterns."
                    },
                    {
                        "username": "ksvijayan06",
                        "content": "The question makes me depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "You should study strings first and if u have studied think string just like array then try to proceed your approach.\\n\\n"
                    },
                    {
                        "username": "Vanshika_25",
                        "content": "The simple approach is to make new empty string and thing the approach similar to number reversing when we reverse 123 to 321.If u don\\'t know the approach the I can give u the hint that we iterate until original no doesn\\'t become 0 and each time we insert value equal to the remainder of original number when divided by 10 and then reduce the digit by dividing it with 10.Here in place of 10 we use 26."
                    },
                    {
                        "username": "halfengineer",
                        "content": "How can this be easy\\uD83D\\uDE13"
                    },
                    {
                        "username": "iamrussell",
                        "content": "It's like decimal countdown, after 10, we write 11. Here, after 'Z' we write 'AA'.\n \nIt's not an easy question!"
                    }
                ]
            },
            {
                "id": 2025715,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025669,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025597,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025498,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025462,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025453,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025417,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025248,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025165,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025139,
                "content": [
                    {
                        "username": "mfrdbigolin",
                        "content": "This problem, in essence, asks you to convert a decimal number to a bijective base-26 number whose digits are the letters of the Latin alphabet."
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Definitely, a tricky problem to solve. \n\nTip for all the people solving this: When dealing with a column number higher than 26, find a number that number 26 evenly divides into. The difference between the column number and the number that 26 evenly divides into will give you the numeric value of the char value you need.  After that all you need is to figure out how to get int value into char value. \n\nYou'll have to deal with a few edge cases and string formatting at the end, but once you get the logic down, everything else will come easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "This problem proves why you need to skip easy problems. Or they are misleaded hard, or full of edge cases. Actually it doesn't matter anyways you're about wasting your time. \nAnyways if you will ever be asked this question on a real interview, it's gg, and the only thing you will remember is how you were swearing. "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who Went to learn Excel sheet before doing This question "
                    },
                    {
                        "username": "BogdanJava",
                        "content": "Definitely not an easy one"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Can we consider with ASCII value for this solution rather than pointing the letters with 1,2,3,4,5 etc...?"
                    },
                    {
                        "username": "ManishAgrahari",
                        "content": "Is there anyone who can think about binary search?\\n\\nI thought to make a array [26^0, 26^1, 26^2, ........26^x]; (26^x <= 2^31 -1);"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "without thinking of the equation, i figured out the rest. but for the life of me i couldn\\'t figure out `num--`"
                    },
                    {
                        "username": "andykimchris",
                        "content": "It's because the first letter \"A\" maps to 1 NOT 0. With Base 10, we think of a range existing from 0 to 9. LeetCode wants you to think of a new Base system in this case Base 26 from 1 - 26. But with modulo in math we only get the correct logic by reducing the num by 1. \nThis is really more of a math problem, and less of a DSA problem"
                    },
                    {
                        "username": "oops_moment",
                        "content": "heyyy\\nWhen tackling this question, think of it as similar to working with numbers in base 10 notation. Imagine I gave you the number 546 and asked you to convert it to base 10. You\\'d do calculations like 5 * 100 + 4 * 10 + 6, right? Essentially, it\\'s about using modulo by 10 and division by 10. Now, the twist here is that the base is 26.\\n\\nHere\\'s the algorithm: it\\'s the same as before, but there\\'s a little trick. Imagine LeetCode played a little prank by starting numbers from 1 to 26 instead of 0. So, whenever you\\'re dealing with a number, subtract 1 first. For example, if you have 28, subtract 1 to make it 27. Then, apply the modulo operation to get 1. Adding 65 (which represents \\'B\\' in ASCII) ."
                    },
                    {
                        "username": "dpmax11",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def convertToTitle(self, columnNumber: int) -> str:\\n        r=[]\\n        while columnNumber>0:\\n            remind=(columnNumber-1)%26\\n            l=chr(ord(\"A\")+remind)\\n            r.insert(0,l)\\n            columnNumber=(columnNumber-1)//26\\n        return \"\".join(r)\\n"
                    },
                    {
                        "username": "andykimchris",
                        "content": "What is so hard about sharing this in Solutions instead of exposing it to everyone?"
                    }
                ]
            },
            {
                "id": 2025133,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025075,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025062,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025034,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2025029,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024850,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024823,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024789,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024788,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2024782,
                "content": [
                    {
                        "username": "codeMonarch",
                        "content": "Seems like, Leetcode is coming up with some basic yet intuitive questions these days."
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "Medium problem it is, if it would have come in the interview, I wouldn\\'t be able to solve it as I tested multiple testcases on the compiler to see the results and to get the intuition."
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "This isn\\'t that easy. Its like base 26 except that you have to consider that you only have symbols for values of 1 to 26.\\n\\nThis takes a piece of paper to work out how the mathematics of it play out with respect to divmod. If you want a hint then basically if you got a 0 from the divmod remainder then you need to actually take away 1 from the quotient and add 26 to the remainder.\\n\\nFor a problem to be easy it shouldn\\'t take a piece of paper like this."
                    },
                    {
                        "username": "swo0sh",
                        "content": "For those wondering why we need to do the -1 step during the modulus. It is because of the 1-based indexing of the Excel Titles. For example, suppose we have just 1 as our number then 1 % 26 = 1, and adding \\'A\\' to it will result in \\'B\\' we we expect A. Now, this thing doesn\\'t stop here, the issue persists further down the line, you can check for the number 28 yourself to see it."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "The confusing part of this problem is the -1 from the columnNumber let me explain why we subtracting -1 from columnNumber:\n\n(1-based indexing)            \nIn question it is:                  \nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n(0-based indexing)\nwhile actually we know that\nA -> 0    \nB -> 1\nC -> 2\n ...                                         \nZ -> 25\n AA -> 26\n AB -> 27\n ...                                          \nwe know how to implement the 0-based indexing by using **(/ and % operator)**\nwhile implementing the same in 1-based indexing we gets wrong result why is that so it is because every character in 1-based indexing has sifted to +1 location like AA  is 27 in 1-based while it is 26 in 0-based indexing(so -1 from columnNumber makes little sence) but \n*why we are subtracting -1 from columnNumber in each iteration?* \nLet's understand it from an example:\n\nFor e.g.\n**INPUT : 27 **                                  **OUTPUT : \"AA\"**\n\nAs we understand that 27 in 1-based indexing is would give same result as 26 in 0-based indexing\nNow let's solve for 26 in 0-based indexing\n(In loop we were generating the output in reverse order)\nso for last character we do (26 % 26) == 0 -> \"A\"\nnow for other character we do (26 / 26) == 1 which represent not the digit but the number cycle of 26 has been completed \n     e.g.: \n      from \"A\" to \"Z\" is one cycle of 26\n      from \"AA\" to \"AZ\" is another cycle\n      from \"BA\" to \"BZ\" is another cycle\n\n   *which looks good what we can interpret from it is* leading characters are giving the number of cycle\n as \"A\" to \"Z\" has no leading character it says no cycle completed\n as \"AA\" to \"AZ\" has leading character A -> 1 cycle completed\n as \"BA\" to \"BZ\" has leading character B -> 2 cycle completed\n\nso we imagine that \"ZA\" to \"ZZ\" would be -> 26 cycle complete\n      \n**That seems familiar**: ohh yes that is same as question:\nA -> 1\nB -> 2\nC -> 3\n...\n but what about two or more leading character like for:\n   \"AAA\" to \"AAZ\" has leading character \"AA\" as you have guess it must represent the no. of completed cycle equivalent to \"AA\" in 1-based indexing i.e. 27\n\nso, Here we go(*we can say*)\nAA -> 27 cycle completed\nAB -> 28 cycle completed\n...\n\nAs you might have guessed after (columnNumber / 26) we get leading character of the output representing no. of completed cycle\n\nIt sounds like recursion yep!! (*it is*)\n \nFor [Recursion solution](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943830/easy-to-understand-recursive-solution-c/\n)\nSo after doing columnNumber / 26 we gets the leading character in 1-based indexing which is -1 in 0-based indexing.\n\nI hope you understand and let me know if there is any further confusion,\n\n**PLEASE UPVOTE IF YOU FOUND IT HELPFUL** "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "take care if mod=0"
                    },
                    {
                        "username": "bhati25",
                        "content": "Now this is called easy !! \njust use basic math and you can come up with the solution easily. Don't look for solutions you can do it.\n\nDo solve this question 171. Excel Sheet Column Number\nYou will get more clarity. \n\n [171. Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number/).\n"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "701/26 = 26 (meaning \\'Z\\')\\n26/26 = 1 (meaning \\'Z\\')\\nthen why it\\'s come \\'ZY\\' ??"
                    },
                    {
                        "username": "blackpanther_",
                        "content": "[@Anurag_mishra_08](/Anurag_mishra_08) thanks bro"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "because here we are using 26 based system i.e  701 = 26*26 + 25 ,  now 701/26 = 26 ( \\'Z\\' )  and 701%26 = 25 ( \\'Y\\' ) therefore the corresponding result is \\'ZY\\'.  I hope it helps : )"
                    },
                    {
                        "username": "abhinav-23",
                        "content": "Extra check for letter \\'Z\\' because it is the result for divisible number to 26.\\nJust divide number by 26 and then decrement number by 1 and go on.\\nAnd for others keep modding to get the last character in the base26 system.\\nExample - 52"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Follow up : Solve 171. Excel Sheet Column Number."
                    }
                ]
            },
            {
                "id": 2009577,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2006143,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2005428,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1958111,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1925812,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1902154,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1805512,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 1738319,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2025021,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            },
            {
                "id": 2024944,
                "content": [
                    {
                        "username": "AnkitModak",
                        "content": "I don\\'t know if this question will be asked in interviews or not, but as a beginner, it surely help you learn about following :\\n1. base 10 to base 26 conversion\\n2. how to convert a number to ASCII character\\n3. Of course python"
                    },
                    {
                        "username": "feindreh",
                        "content": "its 100% an easy question ... that feels at least like a hard one :D"
                    },
                    {
                        "username": "sukhrobabdullaev",
                        "content": "ASCII code is the important, only in capital alphat letters  to understand the problem. \\n"
                    },
                    {
                        "username": "kedarnayak1106",
                        "content": "Anyone finding issue with the 18th Test case?\\n\\nI have got the logic but I do not understand why test 18 is getting failed.\\n\\nInput : 943566\\nMy Output : BAQUZ\\nExpected   :  BAQTZ\\n\\nCan anyone please let me know if they are facing issue with this test case?\\n"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Share your code, I\\'ll take a look"
                    },
                    {
                        "username": "shekelboi",
                        "content": "Did anybody else try writing the solution for the exact opposite (letter to number)? It would be nice to have the example reversed."
                    },
                    {
                        "username": "user5400vw",
                        "content": "what a nasty little problem!  "
                    },
                    {
                        "username": "acearth",
                        "content": "It\\'s better to solve Q-171: from title to number  at first. Then we just do the reverse calculation is enough!"
                    },
                    {
                        "username": "Serenity404",
                        "content": "Java strange behavior??? \\nIn solutionA I used a size 26 char[] to hold A to Z digits. \\n `char[] baseVals = \\n        {\\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\'};`\\n\\nIn the other solutionB I used Map<Integer, Char> hashmap to hold all 26 so-called digits. \\n\\n ` Map<Integer, Character> baseVals = new HashMap<>(26);\\n        baseVals.put(1, \\'A\\');baseVals.put(2, \\'B\\');baseVals.put(3, \\'C\\');baseVals.put(4, \\'D\\');baseVals.put(5, \\'E\\');\\n        baseVals.put(6, \\'F\\');baseVals.put(7, \\'G\\');baseVals.put(8, \\'H\\');baseVals.put(9, \\'I\\');baseVals.put(10, \\'J\\');\\n        baseVals.put(11, \\'K\\');baseVals.put(12, \\'L\\');baseVals.put(13, \\'M\\');baseVals.put(14, \\'N\\');baseVals.put(15, \\'O\\');\\n        baseVals.put(16, \\'P\\');baseVals.put(17, \\'Q\\');baseVals.put(18, \\'R\\');baseVals.put(19, \\'S\\');baseVals.put(20, \\'T\\');\\n        baseVals.put(21, \\'U\\');baseVals.put(22, \\'V\\');baseVals.put(23, \\'W\\');baseVals.put(24, \\'X\\');baseVals.put(25, \\'Y\\');\\n        baseVals.put(26, \\'Z\\');`\\n\\nRather than Map.get(key) I used arr[key] to access to the corresponding digit.\\n`title.add(baseVals.get(rem));`\\nvs.\\n`title.add(baseVals[rem-1]);`\\n\\n\\n Rest of the code is practically the same. Here is the problem: SolutionB which was using a Map instead of a char array uses 500KB less memory so that solution is 99.24% better than everyone else while the one with the char array is at 83.71% which DOES NOT MAKE SENSE to me. How come Map uses less memory then a fixed size array?\\n\\nHeck, the array or the map they are fixed at size 26 anyway their size itself cannot create a 500 KB difference in size"
                    },
                    {
                        "username": "Rakesh123_",
                        "content": " `\\n\\nclass Solution {\\npublic:\\n    string convertToTitle(int columnNumber) {\\n\\n        string ans = \"\";\\n\\n        int n = columnNumber ;\\n\\n        while(n>26)\\n        {\\n            ans += char(\\'A\\'+n/26-1);\\n            n = n%26;\\n        }\\n\\n        if(n>0)\\n        ans += char(\\'A\\'+n-1);\\n\\n        return ans ;\\n\\n    }\\n};\\n\\n\\n\\n`\\nCan Anyone explain why above solution is giving wrong answer . \\nAbove Solution passed 10/19 TestCases . And the TestCase where it fails is n =  2147483647."
                    },
                    {
                        "username": "kongnakornna",
                        "content": "\\n \\n ``````\\n // typescript\\n function convertToTitle(columnNumber: number): string {\\n    let result = \\'\\';\\n\\n    while (columnNumber > 0) {\\n        // Convert the column number to a 0-based index\\n        columnNumber--;\\n\\n        // Get the remainder when dividing by 26\\n        const remainder = columnNumber % 26;\\n\\n        // Convert the remainder to a character and add it to the result\\n        result = String.fromCharCode(65 + remainder) + result;\\n\\n        // Update the column number by dividing by 26 (integer division)\\n        columnNumber = Math.floor(columnNumber / 26);\\n    }\\n\\n    return result;\\n}\\n\\n// Test cases\\nconsole.log(convertToTitle(1));   // Output: \"A\"\\nconsole.log(convertToTitle(28));  // Output: \"AB\"\\nconsole.log(convertToTitle(701)); // Output: \"ZY\"\\n``````"
                    }
                ]
            }
        ]
    },
    {
        "title": "Missing Number",
        "question_content": "<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,0,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?</p>\n",
        "solutions": [
            {
                "id": 69791,
                "title": "4-line-simple-java-bit-manipulate-solution-with-explaination",
                "content": "The basic idea is to use XOR operation. We all know that a^b^b =a, which means two xor operations with the same number will eliminate the number and reveal the original number.\\nIn this solution, I apply XOR operation to both the index and value of the array. In a complete array with no missing numbers, the index and value should be perfectly corresponding( nums[index] = index), so in a missing array, what left finally is the missing number.\\n\\n\\n\\n    public int missingNumber(int[] nums) {\\n\\n        int xor = 0, i = 0;\\n\\t\\tfor (i = 0; i < nums.length; i++) {\\n\\t\\t\\txor = xor ^ i ^ nums[i];\\n\\t\\t}\\n\\n\\t\\treturn xor ^ i;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is to use XOR operation. We all know that a^b^b =a, which means two xor operations with the same number will eliminate the number and reveal the original number.\\nIn this solution, I apply XOR operation to both the index and value of the array. In a complete array with no missing numbers, the index and value should be perfectly corresponding( nums[index] = index), so in a missing array, what left finally is the missing number.\\n\\n\\n\\n    public int missingNumber(int[] nums) {\\n\\n        int xor = 0, i = 0;\\n\\t\\tfor (i = 0; i < nums.length; i++) {\\n\\t\\t\\txor = xor ^ i ^ nums[i];\\n\\t\\t}\\n\\n\\t\\treturn xor ^ i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 69786,
                "title": "3-different-ideas-xor-sum-binary-search-java-code",
                "content": "1.XOR\\n-----\\n\\n    public int missingNumber(int[] nums) { //xor\\n        int res = nums.length;\\n        for(int i=0; i<nums.length; i++){\\n            res ^= i;\\n            res ^= nums[i];\\n        }\\n        return res;\\n    }\\n\\n2.SUM\\n-----\\n\\n    public int missingNumber(int[] nums) { //sum\\n        int len = nums.length;\\n        int sum = (0+len)*(len+1)/2;\\n        for(int i=0; i<len; i++)\\n            sum-=nums[i];\\n        return sum;\\n    }\\n\\n3.Binary Search\\n---------------\\n\\n    public int missingNumber(int[] nums) { //binary search\\n        Arrays.sort(nums);\\n        int left = 0, right = nums.length, mid= (left + right)/2;\\n        while(left<right){\\n            mid = (left + right)/2;\\n            if(nums[mid]>mid) right = mid;\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n\\nSummary:\\n--------\\n\\nIf the array is in order, I prefer `Binary Search` method. Otherwise, the `XOR` method is better.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Tree"
                ],
                "code": "1.XOR\\n-----\\n\\n    public int missingNumber(int[] nums) { //xor\\n        int res = nums.length;\\n        for(int i=0; i<nums.length; i++){\\n            res ^= i;\\n            res ^= nums[i];\\n        }\\n        return res;\\n    }\\n\\n2.SUM\\n-----\\n\\n    public int missingNumber(int[] nums) { //sum\\n        int len = nums.length;\\n        int sum = (0+len)*(len+1)/2;\\n        for(int i=0; i<len; i++)\\n            sum-=nums[i];\\n        return sum;\\n    }\\n\\n3.Binary Search\\n---------------\\n\\n    public int missingNumber(int[] nums) { //binary search\\n        Arrays.sort(nums);\\n        int left = 0, right = nums.length, mid= (left + right)/2;\\n        while(left<right){\\n            mid = (left + right)/2;\\n            if(nums[mid]>mid) right = mid;\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n\\nSummary:\\n--------\\n\\nIf the array is in order, I prefer `Binary Search` method. Otherwise, the `XOR` method is better.",
                "codeTag": "Unknown"
            },
            {
                "id": 69777,
                "title": "c-solution-using-bit-manipulation",
                "content": "    class Solution {\\n    public:\\n        int missingNumber(vector<int>& nums) {\\n            int result = nums.size();\\n            int i=0;\\n            \\n            for(int num:nums){\\n                result ^= num;\\n                result ^= i;\\n                i++;\\n            }\\n            \\n            return result;\\n        }\\n    };\\n\\nThere are several similar problems in the problem list.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int missingNumber(vector<int>& nums) {\\n            int result = nums.size();\\n            int i=0;\\n            \\n            for(int num:nums){\\n                result ^= num;\\n                result ^= i;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 69832,
                "title": "1-lines-ruby-python-java-c",
                "content": "Several different solutions, some with O(1) extra space, some with O(n).\n\n---\n\n**Sum of 0..n minus sum of the given numbers is the missing one.**\n\nThese only use O(1) extra space.\n\nRuby\n\n    def missing_number(nums)\n      (0..nums.size).sum - nums.sum\n    end\n\nPython\n\n    def missingNumber(self, nums):\n        n = len(nums)\n        return n * (n+1) / 2 - sum(nums)\n\nJava\n\n    public int missingNumber(int[] nums) {\n        long n = nums.length;\n        return (int) (n * (n+1) / 2 - IntStream.of(nums).sum());\n    }\n\nC++\n\n    int missingNumber(vector<int>& nums) {\n        long n = nums.size();\n        return n * (n+1) / 2 - accumulate(begin(nums), end(nums), 0);\n    }\n\nUsing `long` for Java and C++ to prevent overflow (the n*(n+1) overflows ints already for n=46341, and then the /2 causes an actual wrong result).\n\n---\n\n**Xor-ing the given numbers and 0..n.**\n\nThese use O(n) extra space, but I like them anyway.\n\nRuby\n\n    def missing_number(nums)\n      nums.zip(1.step).flatten.reduce(:^)\n    end\n\nPython\n\n    def missingNumber(self, nums):\n        return reduce(operator.xor, nums + range(len(nums)+1))\n\n---\n\n**Xor-ing with O(1) space**\n\nSaw this from ts before. Xoring 0..n results in [n, 1, n+1, 0][n % 4]. You can also spot the pattern by looking at xors of such ranges, and it's easy to explain as well.\n\nRuby\n\n    def missing_number(nums)\n      n = nums.size\n      nums.reduce(:^) ^ [n, 1, n+1, 0][n % 4]\n    end\n\nPython\n\n    def missingNumber(self, nums):\n        n = len(nums)\n        return reduce(operator.xor, nums) ^ [n, 1, n+1, 0][n % 4]\n\n---\n\n**Sum, without formula.**\n\nJava and C++:\n\n        int miss = 0, i = 0;\n        for (int num : nums)\n            miss += ++i - num;\n        return miss;\n\nIn Java I believe this is safe, overflow might happen but not cause a wrong result (because another overflow will fix it). In C++ I believe it's *probably safe* in the same way, except that that behavior isn't defined in the standard(s) but is a de-facto standard anyway. In any case, I could just use 64-bit ints again to be safe.\n\n---\n\n**Set/array difference**\n\nDon't know about Ruby's runtime, might not be linear. Python's sets are hash sets and the difference is linear time on average. Don't know about its worst case, and apparently neither does the [TimeComplexity page](https://wiki.python.org/moin/TimeComplexity).\n\nRuby\n\n    def missing_number(nums)\n      ((0..nums.size).to_a - nums)[0]\n    end\n\nPython\n\n    def missingNumber(self, nums):\n        return (set(range(len(nums)+1)) - set(nums)).pop()",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Several different solutions, some with O(1) extra space, some with O(n).\nThese only use O(1) extra space.\n    def missing_number(nums)\n      (0..nums.size).sum - nums.sum\n    def missingNumber(self, nums):\n        n = len(nums)\n        return n * (n+1) / 2 - sum(nums)\n    public int missingNumber(int[] nums) {\n        long n = nums.length;\n        return (int) (n * (n+1) / 2 - IntStream.of(nums).sum());\n    }\n    int missingNumber(vector<int>& nums) {\n        long n = nums.size();\n        return n * (n+1) / 2 - accumulate(begin(nums), end(nums), 0);\n    }\nUsing `long` for Java and C++ to prevent overflow (the n*(n+1) overflows ints already for n=46341, and then the /2 causes an actual wrong result).\nThese use O(n) extra space, but I like them anyway.\n    def missing_number(nums)\n      nums.zip(1.step).flatten.reduce(:^)\n    def missingNumber(self, nums):\n        return reduce(operator.xor, nums + range(len(nums)+1))\n**Xor-ing with O(1) space**\n    def missing_number(nums)\n      n = nums.size\n      nums.reduce(:^) ^ [n, 1, n+1, 0][n % 4]\n    def missingNumber(self, nums):\n        n = len(nums)\n        return reduce(operator.xor, nums) ^ [n, 1, n+1, 0][n % 4]\n        int miss = 0, i = 0;\n        for (int num : nums)\n            miss += ++i - num;\n        return miss;\nIn Java I believe this is safe, overflow might happen but not cause a wrong result (because another overflow will fix it). In C++ I believe it's *probably safe* in the same way, except that that behavior isn't defined in the standard(s) but is a de-facto standard anyway. In any case, I could just use 64-bit ints again to be safe.\nDon't know about Ruby's runtime, might not be linear. Python's sets are hash sets and the difference is linear time on average. Don't know about its worst case, and apparently neither does the [TimeComplexity page](https://wiki.python.org/moin/TimeComplexity).\n    def missing_number(nums)\n      ((0..nums.size).to_a - nums)[0]\n    def missingNumber(self, nums):\n        return (set(range(len(nums)+1)) - set(nums)).pop()",
                "codeTag": "Python3"
            },
            {
                "id": 1585333,
                "title": "python-the-best-explanation-bitwise-and-sum",
                "content": "**Solution 1:**\\nTime:    O(n)\\nSpace: O(1)\\nWe can use the total sum property to work out the missing number:\\n\\n```\\n\\ndef missingNumber(self, nums: List[int]) -> int:\\n  n = len(nums)\\n  return ((n * (n+1)) // 2 ) - sum(nums) # Get sum of complete series(Gaussian formula) and find the difference between sum of given series\\n       \\n```\\n\\nIntution: \\n\\nThe Gaussian formula(above) is used to work out the sum of a series given the length.\\n\\nThe reason we find the difference can be hightlighted by the following example\\n\\n```\\ncompleteSeries = [1,2,3,4,5,6] (sum = 21)\\ngivenNumsList =  [1,2,3, ,5,6] (sum = 17)\\n```\\n\\nPerform the subtraction\\n\\n```\\ncompleteSeries = [1,2,3,4,5,6] (sum = 21)\\n-\\ngivenNumsList  = [1,2,3, ,5,6] (sum = 17)\\n\\nsubtraction    = [0,0,0,4,0,0] (sum = 4)\\n\\n```\\n___\\n**Solution 2:**\\nTime:    O(n)\\nSpace: O(1)\\n\\nWe can use the XOR operator to work out the missing number:\\n\\n        \\n    def missingNumber(self, nums: List[int]) -> int:\\n        \\n        result = 0\\n        \\n        for counter,value in enumerate(nums):\\n            \\n            result ^= counter+1 # XOR result with numbers from the complete series\\n            result ^= value # XOR with the numbers given in num series\\n            \\n        return result\\n\\t\\t\\n\\t\\t\\nIntution: \\n\\n* XOR is a bitwise operation. \\n* The output is true when two values are not the same (exclusive) E.g 1^0 = 1 , 1^1 =0 , 2^0 = 2 , 2^2 = 0.\\n* Value that is XOR with itself is 0\\n\\nWith XOR, you can rearrange the numbers to get the following pattern\\n\\n1^1 = 0\\n1^0 = 1\\n\\n1^1 = 0\\n0^1 = 1\\n\\nFor the fun part, **XOR operations are commutative :**\\n\\n1^1^2 == (1^1)^2 == (2^1)^1 == 2\\n\\n**Order does not mater** when you use XOR, if there are **two instances of the same number,** the **XOR operations cancel each other out to get 0**\\n\\nresult = 3\\n\\nresult ^= 5\\n\\nresult ^= 6\\n\\nresult ^= 3\\n\\nresult ^= 6\\n\\nresult ^= 5\\n\\nThe result variable is 0 as 3^5^6^3^6^5 == (3^3) ^ (5^5) ^ (6^6) == 0\\n\\n\\n**Back to the code!**\\n\\nWe are essentially doing XOR of the complete sequence with the result variable. Then we XOR result with each number from the numList . \\nSame values from complete sequence and numList cancel each other and the missing number manifests iteself.\\n\\n```\\n# Simple break down of above XOR solution\\n\\nnumsList = [3,0,1] # Missing number is 2\\n\\nresult = 0 \\n\\n#XOR result with complete number sequence\\nfor number in range(len(numsList) + 1 ) : # 0, 1, 2 ,3\\n\\t\\tresult ^= number\\n\\t\\t\\n# Essentially now result = ( 0 ^ 0 ^ 1 ^ 2 ^ 3)\\n\\n#XOR result with values in nums\\nfor num in numsList : # 3,0,1\\n\\t\\tresult ^= num\\n\\t\\t\\n# result = ( 0 ^ 0 ^ 1 ^ 2 ^ 3) ^ ( 3 ^ 0 ^ 1)\\n\\n# XOR of same values cancel each other out \\n\\n# result = (0) ^ (0 ^ 0)  ^ (1^1) ^ (2) ^ (3^3)\\n# result =  0 ^ 0 ^ 0 ^ 2 ^ 0\\n# result = 2\\n\\nreturn result # 2\\n```\\n\\n\\n**Upvote if this helps!**",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\ndef missingNumber(self, nums: List[int]) -> int:\\n  n = len(nums)\\n  return ((n * (n+1)) // 2 ) - sum(nums) # Get sum of complete series(Gaussian formula) and find the difference between sum of given series\\n       \\n```\n```\\ncompleteSeries = [1,2,3,4,5,6] (sum = 21)\\ngivenNumsList =  [1,2,3, ,5,6] (sum = 17)\\n```\n```\\ncompleteSeries = [1,2,3,4,5,6] (sum = 21)\\n-\\ngivenNumsList  = [1,2,3, ,5,6] (sum = 17)\\n\\nsubtraction    = [0,0,0,4,0,0] (sum = 4)\\n\\n```\n```\\n# Simple break down of above XOR solution\\n\\nnumsList = [3,0,1] # Missing number is 2\\n\\nresult = 0 \\n\\n#XOR result with complete number sequence\\nfor number in range(len(numsList) + 1 ) : # 0, 1, 2 ,3\\n\\t\\tresult ^= number\\n\\t\\t\\n# Essentially now result = ( 0 ^ 0 ^ 1 ^ 2 ^ 3)\\n\\n#XOR result with values in nums\\nfor num in numsList : # 3,0,1\\n\\t\\tresult ^= num\\n\\t\\t\\n# result = ( 0 ^ 0 ^ 1 ^ 2 ^ 3) ^ ( 3 ^ 0 ^ 1)\\n\\n# XOR of same values cancel each other out \\n\\n# result = (0) ^ (0 ^ 0)  ^ (1^1) ^ (2) ^ (3^3)\\n# result =  0 ^ 0 ^ 0 ^ 2 ^ 0\\n# result = 2\\n\\nreturn result # 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2081201,
                "title": "c-short-w-3-approaches-o-1-space",
                "content": "##### Intuitive Approach\\n**Time Complexity: O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { // find the missing number in a array\\n        int sum = 0; // sum of all numbers initially 0\\n        int total = nums.size()*(nums.size() + 1)/2; // total is the sum of all numbers in the array\\n        for (auto number : nums) { // iterate through the array\\n            sum += number; // add the number to the sum\\n        }\\n        return total - sum; // return the difference between the sum and the total that is the missing number\\n    }\\n};\\n```\\n##### Using Bit- Manipulation\\n**Time Complexity: O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { // function to return missing number\\n        int result = nums.size(); // initialize result to size of vector\\n        int i=0; // initialize i to 0\\n        for(int num:nums){ // for each number in vector\\n            result ^= num; // XOR result with number\\n            result ^= i; // XOR result with i\\n            i++; // increment i\\n        }\\n        return result; // return result that is the missing number\\n    }\\n};\\n```\\n##### 1 Line Approach\\n**Time Complexity: O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size() * (nums.size() + 1) / 2 - accumulate(nums.begin(), nums.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { // find the missing number in a array\\n        int sum = 0; // sum of all numbers initially 0\\n        int total = nums.size()*(nums.size() + 1)/2; // total is the sum of all numbers in the array\\n        for (auto number : nums) { // iterate through the array\\n            sum += number; // add the number to the sum\\n        }\\n        return total - sum; // return the difference between the sum and the total that is the missing number\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { // function to return missing number\\n        int result = nums.size(); // initialize result to size of vector\\n        int i=0; // initialize i to 0\\n        for(int num:nums){ // for each number in vector\\n            result ^= num; // XOR result with number\\n            result ^= i; // XOR result with i\\n            i++; // increment i\\n        }\\n        return result; // return result that is the missing number\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size() * (nums.size() + 1) / 2 - accumulate(nums.begin(), nums.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223002,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-c-javascript-java",
                "content": "# Intuition\\n  Gaussian summation formula **(n * (n + 1)) / 2**\\n\\n# Approach\\nThe **missingNumber** function takes an array of consecutive numbers as its argument. It first calculates the expected sum of the sequence using the Gaussian summation formula.\\n\\nIt then calculates the sum of the numbers in the array using the **reduce** method or by **for** **Loop**, which adds up all the numbers in the array starting from an initial value of 0. \\n\\nFinally, it subtracts the sum of array from the **total** sum to get the missing number, and returns it. Both solutions are same time complexity and solution.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar missingNumber = function (nums) {\\n  const n = nums.length;\\n  const expectedSum = (n * (n + 1)) / 2;\\n  let actualSum = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    actualSum = actualSum + nums[i]\\n  }\\n  \\n  return expectedSum-actualSum\\n};\\n```\\n#### By Using Reduce Method\\n```\\nvar missingNumber = function(nums) {\\n  const n = nums.length;\\n\\n  const expectedSum = (n * (n + 1)) / 2;\\n  const actualSum = nums.reduce((sum, num) => sum + num, 0);\\n\\n  return expectedSum - actualSum;\\n}\\n```\\n\\n###### I am working hard for you guys...\\n###### Please upvote if you found any help with this code...\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar missingNumber = function (nums) {\\n  const n = nums.length;\\n  const expectedSum = (n * (n + 1)) / 2;\\n  let actualSum = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    actualSum = actualSum + nums[i]\\n  }\\n  \\n  return expectedSum-actualSum\\n};\\n```\n```\\nvar missingNumber = function(nums) {\\n  const n = nums.length;\\n\\n  const expectedSum = (n * (n + 1)) / 2;\\n  const actualSum = nums.reduce((sum, num) => sum + num, 0);\\n\\n  return expectedSum - actualSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69795,
                "title": "java-solution-o-1-space-and-o-n-in-time",
                "content": "Pretty simple since we are  told that we are missing only one number in [1,n], we just need to look at the difference between the sum([1,n]) = n * (n+1) / 2 and the sum of nums in our array.  \\n\\n    public class Solution {\\n        public int missingNumber(int[] nums) {\\n            int sum = 0;\\n            for(int num: nums)\\n                sum += num;\\n                \\n            return (nums.length * (nums.length + 1) )/ 2 - sum;\\n        }\\n    }\\n\\n\\nWith a slight mod to the return statement the situation for large n is taken care of.  The needed modification is \\n\\n    return ( (nums.length * (nums.length + 1) ) - 2 * sum ) / 2;",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int missingNumber(int[] nums) {\\n            int sum = 0;\\n            for(int num: nums)\\n                sum += num;\\n                \\n            return (nums.length * (nums.length + 1) )/ 2 - sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69808,
                "title": "java-solution-time-o-n-space-o-1-no-xor-no-gauss-math-method",
                "content": "This solution is easy for understanding. Suppose the input is [0,1,3,4], the numbers in the array have indices [0,1,2,3], so the difference of each number between its corresponding index is [0,0,1,1], add up the differences, subtract it from the length of the array, we can get the missing number from which the difference occurs.  Please leave any comments for discussing the solution.\\n\\n    public int missingNumber(int[] nums) {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++)\\n            sum += nums[i] - i;\\n        return nums.length - sum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "This solution is easy for understanding. Suppose the input is [0,1,3,4], the numbers in the array have indices [0,1,2,3], so the difference of each number between its corresponding index is [0,0,1,1], add up the differences, subtract it from the length of the array, we can get the missing number from which the difference occurs.  Please leave any comments for discussing the solution.\\n\\n    public int missingNumber(int[] nums) {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++)\\n            sum += nums[i] - i;\\n        return nums.length - sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 69943,
                "title": "java-o-n-o-1-solution-using-math-knowledge",
                "content": "From elementary school math, we have a popular math trick which is the sum of 1+2+...+n = n*(n+1)/2, it can be used here.  Since we are finding the missing number, just get the sum of all the n number first using the formula, and the minus it to the sum of all the numbers in the array, we get the missing number.\\n\\n    public class Solution {\\n        public int missingNumber(int[] nums) {\\n            int n = nums.length;\\n            int total = n * (n + 1) / 2;\\n            int sum = 0;\\n            for(int num : nums) {\\n                sum += num;\\n            }\\n            return total - sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int missingNumber(int[] nums) {\\n            int n = nums.length;\\n            int total = n * (n + 1) / 2;\\n            int sum = 0;\\n            for(int num : nums) {\\n                sum += num;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 480793,
                "title": "javascript-simple-solution-faster-than-99-08-submissions",
                "content": "```\\nvar missingNumber = function(nums) {\\n    // construct array of size n+1, to leave a spot for the missing element.\\n\\t// Assign each val to -1 so we can see which position was not filled\\n    // O(n)\\n    const res = new Array(nums.length+1).fill(-1);\\n\\t\\n\\t// \"sort\" the elements by assigning to the array based on val\\n    // O(n)\\n    for(const num of nums) {\\n        res[num] = num;\\n    }\\n    \\n\\t// the remaining -1 index is the missing value\\n    // O(n-1)\\n    return res.indexOf(-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingNumber = function(nums) {\\n    // construct array of size n+1, to leave a spot for the missing element.\\n\\t// Assign each val to -1 so we can see which position was not filled\\n    // O(n)\\n    const res = new Array(nums.length+1).fill(-1);\\n\\t\\n\\t// \"sort\" the elements by assigning to the array based on val\\n    // O(n)\\n    for(const num of nums) {\\n        res[num] = num;\\n    }\\n    \\n\\t// the remaining -1 index is the missing value\\n    // O(n-1)\\n    return res.indexOf(-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69891,
                "title": "1-line-python-solution",
                "content": "    class Solution(object):\\n        def missingNumber(self, nums):\\n            return sum(range(len(nums)+1)) - sum(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def missingNumber(self, nums):\\n            return sum(range(len(nums)+1)) - sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 2081185,
                "title": "python-easy-one-liners-with-explanation",
                "content": "1. #### Gaus Formula\\n\\nWe can find the sum of first `n` numbers using [Gaus formula](https://nrich.maths.org/2478).\\n```\\n(n * (n+1))/2 where `n` is the length of input `nums`.\\n```\\nThen just subtract this with the sum of input `nums` to find the missing number.\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return (len(nums) * (len(nums) + 1))//2 - sum(nums)\\n```\\n\\n---\\n\\n2. #### Bit Manipulation\\n\\nIn this approach, we will concat the input `nums` with the sequence of numbers from `[0, n]`. Then we would perform the reduce operation using an `xor` operator. The `xor` operation cancels the same elements in the list. So after the reduce operation,  we would be left only with the missing number \\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x,y: x ^ y, list(range(len(nums)+1)) + nums)\\n```\\n\\n**Time - O(n)\\nSpace - O(1)**\\n\\n---\\n\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n(n * (n+1))/2 where `n` is the length of input `nums`.\\n```\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return (len(nums) * (len(nums) + 1))//2 - sum(nums)\\n```\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x,y: x ^ y, list(range(len(nums)+1)) + nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798483,
                "title": "easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int x1=0;int x2=0;\\n        for(int i=0;i<n;i++){\\n            x1=x1^nums[i]; // let say array is 3,0,1 then x1 will store  3^0^1 \\n            x2=x2^(i+1);     // here x2 will store 1^2^3\\n        }\\n        return x1^x2;//  a^a=0 ,so the number present both in x1 and x2 will cancel out(become zero ) and the element which is not present in x1 . i.e 2 will be returned by the function.\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int x1=0;int x2=0;\\n        for(int i=0;i<n;i++){\\n            x1=x1^nums[i]; // let say array is 3,0,1 then x1 will store  3^0^1 \\n            x2=x2^(i+1);     // here x2 will store 1^2^3\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3047789,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans^=nums[i];\\n            ans^=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans^=nums[i];\\n            ans^=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388832,
                "title": "javascript-easy-one",
                "content": "Sum up the numbers in the array and substract the numbers from 1 to nums.length in the same step \\n```\\nvar missingNumber = function (nums) {\\n  var sum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    sum += i + 1 - nums[i];\\n  }\\n\\n  return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingNumber = function (nums) {\\n  var sum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    sum += i + 1 - nums[i];\\n  }\\n\\n  return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081377,
                "title": "java-math-approach-0ms-faster-than-100-easy-understanding-solution",
                "content": "**Upvote if you find the solution helpful**\\n\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n     int sum=0;\\n        int n = nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        return n*(n+1)/2 - sum ; //sum of n natural numbers = n*(n+1)/2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n     int sum=0;\\n        int n = nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n        return n*(n+1)/2 - sum ; //sum of n natural numbers = n*(n+1)/2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70020,
                "title": "clear-c-solution-that-can-avoid-overflow",
                "content": "    class Solution {\\n    public:\\n        int missingNumber(vector<int>& nums) {\\n            int result = 0;\\n            for (int i = 0; i < nums.size(); i++)\\n                result ^= nums[i]^(i+1);\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int missingNumber(vector<int>& nums) {\\n            int result = 0;\\n            for (int i = 0; i < nums.size(); i++)\\n                result ^= nums[i]^(i+1);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3572649,
                "title": "shortest-and-fastest-solution-beats-100",
                "content": "# Intuition\\nThe code uses the concept of the sum of an arithmetic series to find the missing number. It assumes that the array nums contains numbers from 0 to n (inclusive) with one missing number.\\n\\n# Approach\\n- Initialize a variable n as the length of the array nums plus 1, assuming that the missing number is the last number in the sequence.\\n\\n- Calculate the expected sum of the sequence from 0 to n (inclusive) using the formula (n * (n - 1)) / 2.\\n\\n- Iterate over each number in nums and subtract it from the total variable, which represents the expected sum.\\n\\n- After the loop, the total will contain the missing number.\\n\\n- Return the value of total.\\n\\n# Complexity\\n- Time complexity:\\n  - O(n), where n is the length of the input array nums. The code iterates over all the elements once.\\n\\n\\n- Space complexity:\\n  - O(1). The code uses a constant amount of extra space to store the variables n and total, regardless of the input size.\\n\\n<!-- # JAVA -->\\n```Java []\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n     int n = nums.length + 1;\\n        int total = (n * (n-1 )) / 2; \\n        \\n        for (int num : nums) {\\n            total -= num;\\n        }\\n        \\n        return total;   \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size() + 1;\\n        int total = (n * (n-1)) / 2;\\n        \\n        for (int num : nums) {\\n            total -= num;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums) + 1\\n        total = (n * (n-1)) // 2\\n        \\n        for num in nums:\\n            total -= num\\n        \\n        return total\\n```\\n```Javascript []\\nvar missingNumber = function(nums) {\\n     let n = nums.length + 1;\\n        let total = (n * (n-1)) / 2;\\n        \\n        for (let num of nums) {\\n            total -= num;\\n        }\\n        \\n        return total;\\n};\\n```\\n\\n#    PLEASE UPVOTE IF YOU FIND THIS HELPFUL \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n     int n = nums.length + 1;\\n        int total = (n * (n-1 )) / 2; \\n        \\n        for (int num : nums) {\\n            total -= num;\\n        }\\n        \\n        return total;   \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size() + 1;\\n        int total = (n * (n-1)) / 2;\\n        \\n        for (int num : nums) {\\n            total -= num;\\n        }\\n        \\n        return total;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums) + 1\\n        total = (n * (n-1)) // 2\\n        \\n        for num in nums:\\n            total -= num\\n        \\n        return total\\n```\n```Javascript []\\nvar missingNumber = function(nums) {\\n     let n = nums.length + 1;\\n        let total = (n * (n-1)) / 2;\\n        \\n        for (let num of nums) {\\n            total -= num;\\n        }\\n        \\n        return total;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70031,
                "title": "java-bit-manipulation-solution-o-n-time-o-1-space",
                "content": "Same idea as the Single Number question, for any integer a, a xor a = 0 and a xor 0 = a. If we xor all numbers in the array and then xor all numbers from 1 to n, effectively all non-missing numbers xor against themselves, generating zero, and this zero is finally xor against the missing number, yielding the result:\\n\\n    public int missingNumber(int[] nums) {\\n        int sum = 0;\\n        for (int i = 0; i <= nums.length; ++i) sum ^= i;\\n        for (int i = 0; i < nums.length; ++i) sum ^= nums[i];\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "Same idea as the Single Number question, for any integer a, a xor a = 0 and a xor 0 = a. If we xor all numbers in the array and then xor all numbers from 1 to n, effectively all non-missing numbers xor against themselves, generating zero, and this zero is finally xor against the missing number, yielding the result:\\n\\n    public int missingNumber(int[] nums) {\\n        int sum = 0;\\n        for (int i = 0; i <= nums.length; ++i) sum ^= i;\\n        for (int i = 0; i < nums.length; ++i) sum ^= nums[i];\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2082522,
                "title": "c-5-approaches-clean-code",
                "content": "**1. Sorting**\\n\\n**TC : O(NlogN), SC : O(1)**\\n\\n\\n```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int ans = n;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(nums[i] != i){\\n                ans = i;\\n                break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\\n\\n**2. Binary Search**  \\n\\t\\n**TC : O(NlogN), SC : O(1)**\\n\\n```\\nint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int ans;\\n        \\n        for(int i = 0 ; i <= n ; i++){\\n            \\n            if(!binary_search(nums.begin(), nums.end(), i)){\\n                ans = i;\\n                break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\\n\\n**3. Replacing in new Vector** \\n\\n**TC : O(N), SC : O(N)**\\n\\n\\n```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> arr(n+1, -1);\\n        int ans;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[nums[i]] = nums[i];\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(arr[i] == -1){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n```\\n\\n**4. Inplace replacing**\\n\\n**TC : O(N), SC : O(1)**\\n\\n\\n```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ans = n;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            while(nums[i] != n and nums[i] != i){\\n                swap(nums[i], nums[nums[i]]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i] != i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\\n\\n**5. Bit Manipulation**\\n\\n**TC : O(N), SC : O(1)**\\n\\n```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ans = n, mask = 0;\\n        \\n        for(int i = 0 ; i < n; i++){\\n            \\n            ans ^= nums[i];\\n            mask ^= i;\\n        }\\n        \\n        ans = (ans^mask);\\n        \\n        return ans;\\n        \\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int ans = n;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(nums[i] != i){\\n                ans = i;\\n                break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\n```\\nint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int ans;\\n        \\n        for(int i = 0 ; i <= n ; i++){\\n            \\n            if(!binary_search(nums.begin(), nums.end(), i)){\\n                ans = i;\\n                break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\n```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> arr(n+1, -1);\\n        int ans;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[nums[i]] = nums[i];\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(arr[i] == -1){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n```\n```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ans = n;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            while(nums[i] != n and nums[i] != i){\\n                swap(nums[i], nums[nums[i]]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i] != i){\\n                ans = i;\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```\n```\\n\\tint missingNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ans = n, mask = 0;\\n        \\n        for(int i = 0 ; i < n; i++){\\n            \\n            ans ^= nums[i];\\n            mask ^= i;\\n        }\\n        \\n        ans = (ans^mask);\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502189,
                "title": "c-96-faster-and-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum = 0;\\n        int total = nums.size()*(nums.size() + 1)/2;\\n        for (auto number : nums) {\\n            sum += number;\\n        }\\n        return total - sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum = 0;\\n        int total = nums.size()*(nums.size() + 1)/2;\\n        for (auto number : nums) {\\n            sum += number;\\n        }\\n        return total - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70058,
                "title": "swapping-numbers-to-the-same-index-cell",
                "content": "1.swapping number solution\\n\\n    public int MissingNumber(int[] nums) {\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            while(i < nums.Length && nums[i] == i) i++;\\n            while(i < nums.Length && nums[i] != i)\\n            {\\n                if(nums[i] >= nums.Length || nums[i] < 0) break;\\n                nums[i] = nums[i] ^ nums[nums[i]] ^ (nums[nums[i]] = nums[i]);\\n            }\\n        }\\n        for(int i = 0; i < nums.Length; i++)\\n            if(nums[i] != i) return i;\\n        return nums.Length;\\n    }\\n\\n1.2 Another swapping solution by avoiding the 2nd loop. Idea from novostary.\\n\\n    public int MissingNumber(int[] nums) {\\n        int lastIndex = nums.Length;\\n        for(int i = 0; i < nums.Length; )\\n            if(nums[i] == i) i++;\\n            else if(nums[i] < nums.Length)\\n                nums[i] = nums[i] ^ nums[nums[i]] ^ (nums[nums[i]] = nums[i]);\\n            else lastIndex = i++;\\n        return lastIndex;\\n    }\\n\\n2.Bitwise operation solution\\n\\n    public int MissingNumber(int[] nums) {\\n        int xorResult = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n            xorResult ^= nums[i] ^ i;\\n        xorResult ^= nums.Length;\\n        return xorResult;\\n    }\\n\\n3.Math solution by sum total\\n\\n    public int MissingNumber(int[] nums) {\\n        int result = nums.Length * (nums.Length + 1) / 2;\\n        for(int i = 0; i < nums.Length; i++)\\n            result -= nums[i];\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "1.swapping number solution\\n\\n    public int MissingNumber(int[] nums) {\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            while(i < nums.Length && nums[i] == i) i++;\\n            while(i < nums.Length && nums[i] != i)\\n            {\\n                if(nums[i] >= nums.Length || nums[i] < 0) break;\\n                nums[i] = nums[i] ^ nums[nums[i]] ^ (nums[nums[i]] = nums[i]);\\n            }\\n        }\\n        for(int i = 0; i < nums.Length; i++)\\n            if(nums[i] != i) return i;\\n        return nums.Length;\\n    }\\n\\n1.2 Another swapping solution by avoiding the 2nd loop. Idea from novostary.\\n\\n    public int MissingNumber(int[] nums) {\\n        int lastIndex = nums.Length;\\n        for(int i = 0; i < nums.Length; )\\n            if(nums[i] == i) i++;\\n            else if(nums[i] < nums.Length)\\n                nums[i] = nums[i] ^ nums[nums[i]] ^ (nums[nums[i]] = nums[i]);\\n            else lastIndex = i++;\\n        return lastIndex;\\n    }\\n\\n2.Bitwise operation solution\\n\\n    public int MissingNumber(int[] nums) {\\n        int xorResult = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n            xorResult ^= nums[i] ^ i;\\n        xorResult ^= nums.Length;\\n        return xorResult;\\n    }\\n\\n3.Math solution by sum total\\n\\n    public int MissingNumber(int[] nums) {\\n        int result = nums.Length * (nums.Length + 1) / 2;\\n        for(int i = 0; i < nums.Length; i++)\\n            result -= nums[i];\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 69940,
                "title": "1ms-java-solution-without-bit-manipulation",
                "content": "    public class Solution {\\n    public int missingNumber(int[] nums) {\\n        int sum = 0, i = 0;\\n\\n        for (; i < nums.length; i++)\\n            sum = sum + i - nums[i];\\n        \\n        return (sum + i);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int sum = 0, i = 0;\\n\\n        for (; i < nums.length; i++)\\n            sum = sum + i - nums[i];\\n        \\n        return (sum + i);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 70056,
                "title": "simple-c-codes",
                "content": "Using bit XOR operatons, just like the \"find missing number (all elements except one occur twice, find the one that occurs once)\" one \\nThe reason I didn't use sum[1..n] - sum(nums) is that calculating sum has potential to cause overflow. XOR bit operation is much safer.\\n\\n    class Solution {\\n    public:\\n        int missingNumber(vector<int>& nums) {\\n            int missing =0;\\n            for(int i=0; i<nums.size();++i) \\n                missing ^= ((i+1)^nums[i]);\\n            return missing;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int missingNumber(vector<int>& nums) {\\n            int missing =0;\\n            for(int i=0; i<nums.size();++i) \\n                missing ^= ((i+1)^nums[i]);\\n            return missing;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4014621,
                "title": "java-shortest-ans-optimised-explained",
                "content": "# Intuition\\nWe know that the summation of the first N numbers is (N*(N+1))/2. We can say this S1. Now, in the given array, every number between 1 to N except one number is present. So, if we add the numbers of the array (say S2), the difference between S1 and S2 will be the missing number. Because, while adding all the numbers of the array, we did not add that particular number that is missing.\\nex-\\n\\n    Sum of first N numbers(S1) = (N*(N+1))/2\\n    Sum of all array elements(S2) = i = 0n-2a[i]\\n    The missing number = S1-S2\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe steps are as follows:\\n\\n1)  We will first calculate the summation of first N natural numbers(i.e. 1 to N) using the specified formula.\\n2) Then we will add all the array elements using a loop.\\n3) Finally, we will consider the difference between the summation of the first N natural numbers and the sum of the array elements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)  - as we are not using any extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n       int totalSum = n*(n+1)/2;\\n        int sum = 0;\\n        for(int i =0;i<n;i++){\\n            sum = sum+nums[i]; \\n        }\\n        return totalSum - sum;\\n    }\\n}\\n```\\n\\n![one-piece-3-231072.png](https://assets.leetcode.com/users/images/6fe56615-acad-4517-9c60-ef0e80a097b1_1694098486.5896962.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n       int totalSum = n*(n+1)/2;\\n        int sum = 0;\\n        for(int i =0;i<n;i++){\\n            sum = sum+nums[i]; \\n        }\\n        return totalSum - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609881,
                "title": "5-approaches-xor-binary-search-sorting-hashtable-sum-easy-solution-in-c",
                "content": "\\n# XOR - Bit Manipulation\\n\\nThis code finds the unique number in the given array by applying a clever XOR operation. It iterates through the array and XORs each number with the current result. XORing a number with itself results in 0, so the pairs of repeating numbers cancel out each other. The remaining XOR result is the unique number we\\'re looking for, which is returned as the answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      int ans =0;\\n      for(int i = 0; i < nums.size(); i++){\\n          ans = ans^nums[i]^i;\\n      } \\n      ans ^= nums.size(); \\n      return ans;\\n    }\\n};\\n```\\n\\n## Analysis\\n- **Time complexity:** O(n)\\n\\n- **Space complexity:** O(1)\\n\\n---\\n\\n# Sum of Array\\n\\nIt calculates the sum of all numbers from 0 to n using a loop and stores it in the variable sum1. It also calculates the sum of the given array nums using another loop and stores it in the variable sum2.\\n\\nThe missing number can be found by subtracting sum2 (sum of the given array) from sum1 (expected sum of all numbers from 0 to n). The difference between these two sums will be the missing number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum1=0;\\n        int sum2=0;\\n\\n        for(int i=0; i<=nums.size(); i++){\\n            sum1=sum1+i;\\n        }\\n\\n        for(int i=0; i<nums.size(); i++){\\n            sum2=sum2+nums[i];\\n        }\\n\\n        return sum1-sum2;\\n\\n    }\\n};\\n```\\n\\n## Analysis\\n- **Time complexity:** O(n)\\n\\n- **Space complexity:** O(1)\\n---\\n\\n\\n# Binary Search\\n\\nStarts with a search range covering the entire array and checks if the number at the middle index matches its expected value. Based on this comparison, it determines whether the missing number lies in the first half or the second half of the range. By iteratively narrowing down the search range, it ultimately identifies the missing number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      int s = 0, e = nums.size()-1;\\n      \\n      while(s<=e){\\n        int mid = s + (e - s)/2;\\n        if(nums[mid] == mid){\\n          s = mid + 1;\\n        }\\n        else{\\n          e = mid - 1;\\n        }\\n      }\\n      return s;\\n    }\\n};\\n```\\n\\n## Analysis\\n- **Time complexity:** O(nlogn)\\nThe time complexity of this approach is O(nlogn) because of the sorting operation performed on the input array. \\nThe binary search itself has a time complexity of O(logn), but the overall time complexity is dominated by the sorting step.\\n\\n- **Space complexity:** O(1)\\n\\n---\\n\\n# Sorting + Array Operation\\n\\nThe code sorts the input array and then iterates through it to find the missing number. It compares each element with its index, and if a mismatch is found, it returns the index as the missing number. If no mismatch is found, it means that the missing number is the last index of the array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      for(int i = 0; i < nums.size(); i++){\\n        if(nums[i]!= i){\\n          return i;\\n        }\\n      }\\n      return nums.size();\\n    }\\n};\\n```\\n\\n## Analysis\\n- **Time complexity:** O(nlogn)\\n\\n- **Space complexity:** O(1)\\n\\n---\\n\\n# HashTable\\n\\nThe code uses an unordered map to count the occurrences of each number in the input array and its corresponding index. Then, it checks for the number that has an occurrence of 1, indicating the missing number. If no such number is found, it returns the maximum possible number. The approach relies on counting occurrences and checking for uniqueness.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      unordered_map<int,int> m;\\n      for(int i = 0; i < nums.size(); i++){\\n        m[nums[i]]++;\\n        m[i]++;\\n      }\\n      m[nums.size()]++;\\n\\n      for(auto i:m){\\n        if(i.second == 1){\\n          return i.first;\\n        }\\n      }\\n      return nums.size();\\n    }\\n};\\n```\\n\\n## Analysis\\n- **Time complexity:** O(n)\\n\\n- **Space complexity:** O(n)\\n\\n---\\n\\n**UPVOTE :)**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      int ans =0;\\n      for(int i = 0; i < nums.size(); i++){\\n          ans = ans^nums[i]^i;\\n      } \\n      ans ^= nums.size(); \\n      return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum1=0;\\n        int sum2=0;\\n\\n        for(int i=0; i<=nums.size(); i++){\\n            sum1=sum1+i;\\n        }\\n\\n        for(int i=0; i<nums.size(); i++){\\n            sum2=sum2+nums[i];\\n        }\\n\\n        return sum1-sum2;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      int s = 0, e = nums.size()-1;\\n      \\n      while(s<=e){\\n        int mid = s + (e - s)/2;\\n        if(nums[mid] == mid){\\n          s = mid + 1;\\n        }\\n        else{\\n          e = mid - 1;\\n        }\\n      }\\n      return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      sort(nums.begin(),nums.end());\\n      for(int i = 0; i < nums.size(); i++){\\n        if(nums[i]!= i){\\n          return i;\\n        }\\n      }\\n      return nums.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n      unordered_map<int,int> m;\\n      for(int i = 0; i < nums.size(); i++){\\n        m[nums[i]]++;\\n        m[i]++;\\n      }\\n      m[nums.size()]++;\\n\\n      for(auto i:m){\\n        if(i.second == 1){\\n          return i.first;\\n        }\\n      }\\n      return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092210,
                "title": "python-python3-2-one-liner-solutions",
                "content": "***Shameless-Self-Promotion***: My other leetcode [solutions](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts) to various questions can be found [here](https://leetcode.com/discuss/general-discussion/1112952/Collection-of-my-leetcode-solution-posts)\\n\\n\\n\\nAlgorithm1:\\n1. here we know that only one number that must be in range but isnt.\\n2. So, we calculate the sum that should be and the sum we have.\\n3. Their difference will give us the answer.\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return sum(range(len(nums)+1)) - sum(nums)\\n```\\nTime: ```O(N)```\\nSpace:```O(1)```\\n\\nAlgorithm2:\\n1. We have to only find one number that must be in the range but isnt\\n2. So we make a set of range and take the difference of it with the nums array that is given.\\n3. Convert that to list and return the first element\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return list(set(range(0,len(nums)+1)).difference(set(nums)))[0]\\n```\\n\\nTime: ```O(N)```\\nSpace:```O(N)``` worst case can be because we are creating set and list\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return sum(range(len(nums)+1)) - sum(nums)\\n```\n```O(N)```\n```O(1)```\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return list(set(range(0,len(nums)+1)).difference(set(nums)))[0]\\n```\n```O(N)```\n```O(N)```",
                "codeTag": "Java"
            },
            {
                "id": 1091153,
                "title": "js-python-java-c-easy-1-line-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe sum of the numbers from **1** to **N** is the **N**th **triangular number**, defined as **N * (N + 1) / 2**. It stands to reason, then, that we can simply find the difference between the **N**th triangular number and the sum of **nums**, which should be our missing number.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n```javascript\\nconst missingNumber = nums =>\\n    nums.length * (nums.length + 1) / 2 - nums.reduce((a,c) => a + c)\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n```python\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return len(nums) * (len(nums) + 1) // 2 - sum(nums)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n```java\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        return nums.length * (nums.length + 1) / 2 - Arrays.stream(nums).sum();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n```c++\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size() * (nums.size() + 1) / 2 - accumulate(nums.begin(), nums.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst missingNumber = nums =>\\n    nums.length * (nums.length + 1) / 2 - nums.reduce((a,c) => a + c)\\n```\n```python\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return len(nums) * (len(nums) + 1) // 2 - sum(nums)\\n```\n```java\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        return nums.length * (nums.length + 1) / 2 - Arrays.stream(nums).sum();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size() * (nums.size() + 1) / 2 - accumulate(nums.begin(), nums.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255115,
                "title": "90-faster-javascript",
                "content": "```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;//length of array.\\n    let sum = (len*(len+1))/2; // sum of all nos from 0 to n by series formula\\n    let sum2 = nums.reduce((a,c)=> a+c); //sum of array elements.\\n    return sum-sum2; //difference is the answer\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;//length of array.\\n    let sum = (len*(len+1))/2; // sum of all nos from 0 to n by series formula\\n    let sum2 = nums.reduce((a,c)=> a+c); //sum of array elements.\\n    return sum-sum2; //difference is the answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2771008,
                "title": "java-easy-o-1-space-intuitive",
                "content": "```\\n    public int missingNumber(int[] nums) {\\n    \\n        int n=nums.length,totalsum=n*(n+1)/2; //sum of first n natural numbers\\n        for(int i:nums)\\n            totalsum-=i;\\n        return totalsum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    public int missingNumber(int[] nums) {\\n    \\n        int n=nums.length,totalsum=n*(n+1)/2; //sum of first n natural numbers\\n        for(int i:nums)\\n            totalsum-=i;\\n        return totalsum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2375385,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution (Binary Search Approach):**\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int beg = 0, end = nums.length;\\n        while(beg < end){\\n            int mid = (beg + end)/2;\\n            if(nums[mid] > mid){\\n                end = mid;\\n            }else{\\n                beg = mid + 1;\\n            }\\n        }\\n        return end;\\n    }\\n}\\n```\\n\\n# **C++ Solution (Bit Manipulation):**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        // Initialize res as zero...\\n        int res = 0;\\n        // Traverse all the element through the loop...\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // Calculation process by helping of Bit Manipulation...\\n            res ^= nums[i] ^ (i + 1);\\n        }\\n        return res;     // Return the result\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        lenth = len(nums)\\n        # Calculate the sum of the first N natural numbers as (1 + lenth) * lenth/2...\\n        sum = (1 + lenth) * lenth/2\\n        # Traverse the array from start to end...\\n        for i in nums:\\n            # Find the sum of all the array elements...\\n            sum -= i\\n        return sum\\n```\\n\\n# **JavaScript Solution (Bit Manipulation):**\\n```\\nvar missingNumber = function(nums) {\\n    // Initialize res as zero...\\n    let res = 0;\\n    // Traverse all the element through the loop...\\n    for (let i = 0; i < nums.length; ++i) {\\n        // Calculation process by helping of Bit Manipulation...\\n        res ^= nums[i] ^ (i + 1);\\n    }\\n    return res;     // Return the result\\n};\\n```\\n\\n# **C Language:**\\n```\\nint missingNumber(int* nums, int numsSize){\\n    int res = numsSize;\\n    for(int i=0; i!=numsSize; i++){\\n        res = res + i - nums[i];\\n    }\\n    return res;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        lenth = len(nums)\\n        # Calculate the sum of the first N natural numbers as (1 + lenth) * lenth/2...\\n        sum = (1 + lenth) * lenth/2\\n        # Traverse the array from start to end...\\n        for i in nums:\\n            # Find the sum of all the array elements...\\n            sum -= i\\n        return sum\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int beg = 0, end = nums.length;\\n        while(beg < end){\\n            int mid = (beg + end)/2;\\n            if(nums[mid] > mid){\\n                end = mid;\\n            }else{\\n                beg = mid + 1;\\n            }\\n        }\\n        return end;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        // Initialize res as zero...\\n        int res = 0;\\n        // Traverse all the element through the loop...\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // Calculation process by helping of Bit Manipulation...\\n            res ^= nums[i] ^ (i + 1);\\n        }\\n        return res;     // Return the result\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        lenth = len(nums)\\n        # Calculate the sum of the first N natural numbers as (1 + lenth) * lenth/2...\\n        sum = (1 + lenth) * lenth/2\\n        # Traverse the array from start to end...\\n        for i in nums:\\n            # Find the sum of all the array elements...\\n            sum -= i\\n        return sum\\n```\n```\\nvar missingNumber = function(nums) {\\n    // Initialize res as zero...\\n    let res = 0;\\n    // Traverse all the element through the loop...\\n    for (let i = 0; i < nums.length; ++i) {\\n        // Calculation process by helping of Bit Manipulation...\\n        res ^= nums[i] ^ (i + 1);\\n    }\\n    return res;     // Return the result\\n};\\n```\n```\\nint missingNumber(int* nums, int numsSize){\\n    int res = numsSize;\\n    for(int i=0; i!=numsSize; i++){\\n        res = res + i - nums[i];\\n    }\\n    return res;\\n}\\n```\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        lenth = len(nums)\\n        # Calculate the sum of the first N natural numbers as (1 + lenth) * lenth/2...\\n        sum = (1 + lenth) * lenth/2\\n        # Traverse the array from start to end...\\n        for i in nums:\\n            # Find the sum of all the array elements...\\n            sum -= i\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210878,
                "title": "javascript",
                "content": "```\\nvar missingNumber = function(nums) {\\n    let sum = 0, total = 0\\n    for(let i = 0; i < nums.length; i++) {\\n        sum += nums[i]\\n        total += i + 1\\n    }\\n    return total - sum\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar missingNumber = function(nums) {\\n    let sum = 0, total = 0\\n    for(let i = 0; i < nums.length; i++) {\\n        sum += nums[i]\\n        total += i + 1\\n    }\\n    return total - sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445140,
                "title": "python-xor-explanation",
                "content": "Explaination: \\n\\nProperty of XOR :  2^2 = 0  , 1^1^2^2 = 0  , a^a^b^b^c^c = (a^a)^(b^b)^(c^c) = 0^0^0 = 0\\nOnce the property of xor is clear , then the solution is fairly simple to understand because of the property of the array given.\\n\\nNote : Problem states that elements in the array basically contains all the indices from 0 to n (with one missing) which makes the question simple and by letting us use xor .\\n\\narr = [ 0, 3, 1 ] // as length is three , it should have 4 elements starting from 0 to 3 .\\n\\nindices =[ 0,1,2,3 ]\\n\\nBasically you have to cancel out the same elements in both the arrays and the element remaining is the required element . (Now how can i cancel out - do xor , as both the elements are same, it will end up with 0 )\\n\\nconsider indices array value as indVal = ( 0^1^2^3 )\\n\\nconsider input array value as arrVal = ( 0^1^3 )\\n\\nNow , indVal ^ arrVal = ( 0^1^2^3 ) ^ ( 0^1^3 ) =  (0^0) ^ (1^1) ^ (2) ^ (3^3)  = 2\\n\\nNote: You dont have to create an array of indexes , you can use them while iterating through the array \\n\\n\\n\\n```\\n    def missingNumber(self, nums: List[int]) -> int:\\n        s=0\\n        for i in nums:\\n            s=s^i\\n        for i in range(len(nums)):\\n            s=s^i\\n        s=s^(i+1)\\n        return s\\n\\t\\t\\n\\t\\t#s=0\\n        #for i , v in enumerate(nums):\\n        #    s^=(i^v)\\n        #return s^(i+1)\\n\\t\\t\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def missingNumber(self, nums: List[int]) -> int:\\n        s=0\\n        for i in nums:\\n            s=s^i\\n        for i in range(len(nums)):\\n            s=s^i\\n        s=s^(i+1)\\n        return s\\n\\t\\t\\n\\t\\t#s=0\\n        #for i , v in enumerate(nums):\\n        #    s^=(i^v)\\n        #return s^(i+1)\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2082716,
                "title": "bitwise-solution-with-xor-and-no-summing-explained",
                "content": "**Solution**\\n```csharp\\npublic int MissingNumber(int[] nums)\\n{\\n\\tint x = nums.Length;\\n\\t\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tx ^= i ^ nums[i];\\n\\t}\\n\\t\\n\\treturn x;\\n}\\n```\\n\\nSame logic, but with LINQ:\\n```csharp\\npublic int MissingNumber(int[] nums)\\n\\t=> Enumerable.Range(0, nums.Length).Aggregate(nums.Length, (x, i) => x ^ i ^ nums[i]);\\n```\\n\\n**Explanation**\\n1. XOR (designated by `^`) has a nice property: `(a ^ b) ^ b = a`. Moreover, the order of xoring does not matter: `(a ^ c) ^ b = (a ^ b) ^ c`. Also, `a ^ a = 0` and `0 ^ a = a`.\\n2. We know that `nums` contains all numbers between `0` and `n` except the one that we want to find. Now, let\\'s xor `x` with each number in `nums` and at the same time \"de-xor\" `x` with the loop variable `i`. Again, we don\\'t care about the order of xoring. After the loop, we have `x` xored by every number in `[0, n]` and by every number in `nums`. Thus, `x` is equal to the missing number.\\n\\n**Example**\\nLet\\'s say, `n = 5`, and the missing number is `3`.\\nThe array `nums` contains `{0, 1, 2, 4, 5}`\\nThe iteration variable will run through these values: `{0, 1, 2, 3, 4}` plus we initialized `x` with `5`.\\nThe matching numbers cancel each other out and we return the one number that has no match, i.e. `3`.",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```csharp\\npublic int MissingNumber(int[] nums)\\n{\\n\\tint x = nums.Length;\\n\\t\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tx ^= i ^ nums[i];\\n\\t}\\n\\t\\n\\treturn x;\\n}\\n```\n```csharp\\npublic int MissingNumber(int[] nums)\\n\\t=> Enumerable.Range(0, nums.Length).Aggregate(nums.Length, (x, i) => x ^ i ^ nums[i]);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035724,
                "title": "easy-python-solution",
                "content": "\\n# Approach\\nUsing the property that the missing number must be in the range [0, n], and the sum of the numbers in the range [0, n] is (n * (n + 1)) / 2. By subtracting the sum of the array elements from this value, you can find the missing number.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        total_sum = (n * (n + 1)) // 2\\n        array_sum = sum(nums)\\n        return total_sum - array_sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        total_sum = (n * (n + 1)) // 2\\n        array_sum = sum(nums)\\n        return total_sum - array_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824330,
                "title": "very-easy-c-solution-using-bitwise-operator-100-explained",
                "content": "As we know that we have an array from range ```[0, n]``` means it contains the\\nall the values including 0 and n.\\ni.e.,```[0,1,2,3,4,5,6,7,8,..........,n]```\\nAs we know in the XOR operation ``` the same element will result from 0``` for example:\\n2^2 = 0\\n3^3 =0\\nn^n = 0\\n\\nLogic-\\nWe iterate over from 0 to the size of the given vector (including).\\nAnd perform XOR operation between ```answer^nums[i] ^ i``` untile the i is less than size.(answer is an variable)\\nThere is an condition where i == size in this case as we have not nums[i] present we perform ```answer ^ i``` \\n\\n![image](https://assets.leetcode.com/users/images/8bf42eb2-0b28-4cab-92be-372041b68e9a_1668698125.7797072.jpeg)\\n\\n```IF YOU UNDERSTAND UPVOTE```\\n\\nPseudoCode\\n```\\nIterate over the size of the nums\\nif (i < size)\\n    // Perform XOR operation with variable to ^nums[i] ^ i\\nelse\\n    //  Perform XOR operation with variable to ^ i\\nReturn the answer\\n```\\n\\nCode \\n```\\nclass Solution{\\npublic:\\n    int missingNumber(vector<int>& nums){\\n        int answer = 0;\\n        for(int i = 0; i <= nums.size(); i++)\\n        {\\n            if(i < nums.size())\\n            {\\n                answer = answer ^ nums[i] ^ i;\\n            }else{\\n                answer = answer ^ i;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```[0, n]```\n```[0,1,2,3,4,5,6,7,8,..........,n]```\n``` the same element will result from 0```\n```answer^nums[i] ^ i```\n```answer ^ i```\n```IF YOU UNDERSTAND UPVOTE```\n```\\nIterate over the size of the nums\\nif (i < size)\\n    // Perform XOR operation with variable to ^nums[i] ^ i\\nelse\\n    //  Perform XOR operation with variable to ^ i\\nReturn the answer\\n```\n```\\nclass Solution{\\npublic:\\n    int missingNumber(vector<int>& nums){\\n        int answer = 0;\\n        for(int i = 0; i <= nums.size(); i++)\\n        {\\n            if(i < nums.size())\\n            {\\n                answer = answer ^ nums[i] ^ i;\\n            }else{\\n                answer = answer ^ i;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555805,
                "title": "java-three-simple-approaches-bit-manipulation-sum-binary-search-for-follow-up",
                "content": "**Bit Manipulation**\\n```\\n/**\\n * Bit Manipulation.\\n *\\n * XOR all numbers in the input array and then xor this with all numbers from 0\\n * to N. We will be left with the missing number.\\n *\\n * Time Complexity: O(N). N = Length of the input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int result = nums.length;\\n        for (int i = 0; i < nums.length; i++) {\\n            result ^= i ^ nums[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Subtract all numbers in input array from the sum of numbers from 0 to N**\\n```java\\n/**\\n * Subtract all numbers from n * (n+1) / 2\\n *\\n * Time Complexity: O(N). N = Length of the input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        int sum = len * (len + 1) / 2;\\n        for (int n : nums) {\\n            sum -= n;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n\\n---\\n**Following is a Follow-Up asked in interviews.**\\n*Follow-Up: If the input array is sorted, can we find the missing number in less than O(N) time.*\\n```java\\n/**\\n * Follow-Up: If the input array is sorted, can we find the missing number in\\n * less than O(N) time.\\n *\\n * Binary Search\\n *\\n * Time Complexity:\\n * - O(logN) --> Since array is already sorted.\\n *\\n * Space Complexity:\\n * - O(1) --> Since array is already sorted.\\n *\\n * N = Length of the input array.\\n */\\nclass Solution3 {\\n    public int missingNumber(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(nums);\\n        // Here search space is from 0 to len, as the missing number is in range 0 to len.\\n        int start = 0;\\n        int end = len;\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > mid) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Bit Manipulation.\\n *\\n * XOR all numbers in the input array and then xor this with all numbers from 0\\n * to N. We will be left with the missing number.\\n *\\n * Time Complexity: O(N). N = Length of the input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int result = nums.length;\\n        for (int i = 0; i < nums.length; i++) {\\n            result ^= i ^ nums[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Subtract all numbers from n * (n+1) / 2\\n *\\n * Time Complexity: O(N). N = Length of the input array.\\n *\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        int sum = len * (len + 1) / 2;\\n        for (int n : nums) {\\n            sum -= n;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up: If the input array is sorted, can we find the missing number in\\n * less than O(N) time.\\n *\\n * Binary Search\\n *\\n * Time Complexity:\\n * - O(logN) --> Since array is already sorted.\\n *\\n * Space Complexity:\\n * - O(1) --> Since array is already sorted.\\n *\\n * N = Length of the input array.\\n */\\nclass Solution3 {\\n    public int missingNumber(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 0) {\\n            return 0;\\n        }\\n\\n        Arrays.sort(nums);\\n        // Here search space is from 0 to len, as the missing number is in range 0 to len.\\n        int start = 0;\\n        int end = len;\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] > mid) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425189,
                "title": "o-n-time-complexity-o-1-space-16ms-faster-than-81-44",
                "content": "**Approach** :- We know that the sum of first N natural number is given by **S(N) = (N X (N+1))/2** .\\nA.T.Q, the numbers in array are distinct and lie in range [0,N]. So, to calculate the missing value, we must subract the **total sum of Array , A(N)** from above S(N), and **return S(N) - A(N)**.\\n\\n\\nCode -\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = (n*(n+1))/2;\\n        \\n        for(auto i: nums)\\n            sum -= i;\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Please upvote if this helps.**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = (n*(n+1))/2;\\n        \\n        for(auto i: nums)\\n            sum -= i;\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091150,
                "title": "c-python-simplest-4-line-bitwise-solutions-o-n-time-o-1-space",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int res = nums.size();\\n        for (int i = 0; i < nums.size(); i++)\\n            res ^= i ^ nums[i];\\n        return res;\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        res = len(nums)\\n        for i in range(len(nums)):\\n            res ^= i ^ nums[i]\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int res = nums.size();\\n        for (int i = 0; i < nums.size(); i++)\\n            res ^= i ^ nums[i];\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        res = len(nums)\\n        for i in range(len(nums)):\\n            res ^= i ^ nums[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69961,
                "title": "share-four-different-solutions",
                "content": "    // sort + binary seach \\n    // O(nlogn) time, O(1) space\\n    int missingNumber1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = 0;\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r) {\\n            m = (l + r ) / 2;\\n            if (nums[m] == m) l = m + 1;\\n            else r = m - 1;\\n        }\\n        \\n        return nums[l] == l ? l + 1 : l;\\n    }\\n    \\n    // arithmetic progression\\n    // O(n) time, O(1) space\\n    int missingNumber2(vector<int>& nums) {\\n        int sum1 = 0;\\n        for (int x : nums) sum1 += x;\\n        int minV = 0, maxV = nums.size();\\n        int sum2 =  (minV + maxV) * (nums.size() + 1) / 2;\\n        return sum2 - sum1;\\n    }\\n    \\n    // XOR \\n    // O(n) time, O(1) space\\n    int missingNumber3(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i <= nums.size(); ++i)\\n            ans ^= (i == nums.size()) ? i : i ^ nums[i];\\n        return ans;\\n    }\\n    \\n    // map table\\n    // O(n) time, O(1) space\\n    int missingNumber(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (nums[i] != i && nums[i] < nums.size() && nums[i] != nums[nums[i]]) \\n                swap(nums[i], nums[nums[i]]);\\n        }\\n        \\n        for (int i = 0; i < nums.size(); ++i)\\n            if (nums[i] != i) return i;\\n            \\n        return nums.size();\\n    }",
                "solutionTags": [],
                "code": "    // sort + binary seach \\n    // O(nlogn) time, O(1) space\\n    int missingNumber1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int m = 0;\\n        int l = 0, r = nums.size() - 1;\\n        while (l < r) {\\n            m = (l + r ) / 2;\\n            if (nums[m] == m) l = m + 1;\\n            else r = m - 1;\\n        }\\n        \\n        return nums[l] == l ? l + 1 : l;\\n    }\\n    \\n    // arithmetic progression\\n    // O(n) time, O(1) space\\n    int missingNumber2(vector<int>& nums) {\\n        int sum1 = 0;\\n        for (int x : nums) sum1 += x;\\n        int minV = 0, maxV = nums.size();\\n        int sum2 =  (minV + maxV) * (nums.size() + 1) / 2;\\n        return sum2 - sum1;\\n    }\\n    \\n    // XOR \\n    // O(n) time, O(1) space\\n    int missingNumber3(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i <= nums.size(); ++i)\\n            ans ^= (i == nums.size()) ? i : i ^ nums[i];\\n        return ans;\\n    }\\n    \\n    // map table\\n    // O(n) time, O(1) space\\n    int missingNumber(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (nums[i] != i && nums[i] < nums.size() && nums[i] != nums[nums[i]]) \\n                swap(nums[i], nums[nums[i]]);\\n        }\\n        \\n        for (int i = 0; i < nums.size(); ++i)\\n            if (nums[i] != i) return i;\\n            \\n        return nums.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 70028,
                "title": "java-sol-o-n-time-o-1-space",
                "content": "public class Solution {\\n    public int missingNumber(int[] nums) {\\n        int len = nums.length;\\n        \\n        int sum = (0+nums.length)*(nums.length+1)/2;\\n        for(int a:nums){\\n            sum-=a;\\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int len = nums.length;\\n        \\n        int sum = (0+nums.length)*(nums.length+1)/2;\\n        for(int a:nums){\\n            sum-=a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 70044,
                "title": "java-single-pass-without-additional-space",
                "content": "\\n    public class Solution {\\n        public int missingNumber(int[] nums) {\\n            int check = 0;\\n            for (int i=0; i<nums.length; i++) {\\n                check ^= nums[i] ^ i+1;\\n            }\\n            return check;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int missingNumber(int[] nums) {\\n            int check = 0;\\n            for (int i=0; i<nums.length; i++) {\\n                check ^= nums[i] ^ i+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 70094,
                "title": "python-o-n-time-o-1-space-solutions",
                "content": "        \\n    # bit manipulation\\n    def missingNumber1(self, nums):\\n        res = 0\\n        for i in xrange(len(nums)+1):\\n            res ^= i\\n        for num in nums:\\n            res ^= num\\n        return res\\n      \\n    # math  \\n    def missingNumber(self, nums):\\n        return len(nums)*(len(nums)+1)/2 - sum(nums)",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "        \\n    # bit manipulation\\n    def missingNumber1(self, nums):\\n        res = 0\\n        for i in xrange(len(nums)+1):\\n            res ^= i\\n        for num in nums:\\n            res ^= num\\n        return res\\n      \\n    # math  \\n    def missingNumber(self, nums):\\n        return len(nums)*(len(nums)+1)/2 - sum(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 1485017,
                "title": "python-time-o-n-space-o-1-compare-sum-of-nums-to-sum-of-total-series",
                "content": "Space: O(1) because we calculate the sum of integers from [0, ```len(nums)```] and assign it to ```totalsum```.\\nTime: O(N) because we iterate through ```nums``` and subtract each element from ```totalsum```. The remaining value must be the missing number.\\n```\\nn = len(nums)\\ntotalsum = n*(n+1)//2\\n\\nfor num in nums:\\n\\ttotalsum -= num\\n\\nreturn totalsum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```len(nums)```\n```totalsum```\n```nums```\n```totalsum```\n```\\nn = len(nums)\\ntotalsum = n*(n+1)//2\\n\\nfor num in nums:\\n\\ttotalsum -= num\\n\\nreturn totalsum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1279476,
                "title": "missing-number-running-sum-xor-bit-manipulation",
                "content": "There are two solutions to this problem,\\n\\t**1) Sum of first N natural Numbers upto `\\'n\\'` - Running Sum of array \\n\\t2) XOR of first N natural Numbers upto `\\'n\\'` and values of the array**\\n\\n**Approach1:** Running Sum\\n**Explanation:**\\n\\t\\t\\t\\t\\t\\t-> Sum of first n natural number = (n*(n+1))/2;\\n\\t\\t\\t\\t\\t\\t-> Also we can calculate this by adding the index values of the array upto \\'n\\' to avoid integer overflow!\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum = nums.size() , total = 0;\\n        for(int i=0;i<nums.size();i++) sum += i , total += nums[i] ;\\n        return sum - total;\\n    }\\n};\\n```\\nO/P:\\n![image](https://assets.leetcode.com/users/images/4681ca8d-b1d0-4dc2-b30e-1590865b3235_1623948134.8781388.png)\\n\\n**Time Complexity   : O(n) \\nSpace Complexity : O(1)**\\n\\n***-------------------------------------------------------------------------------------------------------------------***\\n\\n**Approach2:** XOR and Bit manipulation\\n**Explanation**:\\n\\t\\t\\t\\t\\t\\t\\t-> We know that 1 ^ 1 =0 , 0 ^ 0 =0 so, A ^ A =0 (where A is some number)\\n\\t\\t\\t\\t\\t\\t\\t-> Also XOR is associative and commutative i.e( a^(b^c) = (a^b)^c , a^b = b^c) respectively;\\n\\t\\t\\t\\t\\t\\t\\t-> So, if we do the XOR of the index (from 0 to n ) with values of the array we will getting the required answer, because the missing number wonn\\'t have its pair!\\n\\t\\t\\t\\t\\t\\t\\t\\n**For Example** Array nums[]={ 0 , 1 , 3 , 4 } O/P: 2\\n\\t\\t\\t\\t\\t\\t\\t![image](https://assets.leetcode.com/users/images/0bf8c064-4055-45ad-8604-2969a6af07ff_1623948424.6991563.png)\\n\\t\\t\\t\\t\\t\\t\\t\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans=nums.size();\\n        for(int i=0;i<nums.size();i++) ans ^= (nums[i]^i);\\n        return ans;\\n    }\\n};\\n```\\nO/P:\\n![image](https://assets.leetcode.com/users/images/010b7f8e-a65b-419e-ae1d-0f5ce9bff648_1623948610.6473758.png)\\n\\n**Time Complexity   : O(n) \\nSpace Complexity : O(1)**\\n\\n** If you find this post helpful, Do upvote!!\\n    If you any doubts feel free to comment!\\n\\tAlso correct me if anything wrong :)\\uD83D\\uDE4F\\uD83D\\uDE4F**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum = nums.size() , total = 0;\\n        for(int i=0;i<nums.size();i++) sum += i , total += nums[i] ;\\n        return sum - total;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans=nums.size();\\n        for(int i=0;i<nums.size();i++) ans ^= (nums[i]^i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69999,
                "title": "4-lines-o-1-space-o-n-time-c-solution-without-xor",
                "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        \\n        int sum=0, s=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        \\n        return (s*(s+1)/2)-sum;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        \\n        int sum=0, s=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3470377,
                "title": "java-0-ms-beats-100-math",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used simple maths to solve this question in order of n. I have used formula for sum of n numbers to calculate the sum of n(length of array) numbers and then stored the sum of all the elements in one variable and returned the difference between those two.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int res;\\n        int n = nums.length;\\n        res = n*(n+1)/2;\\n        int temp =0;\\n        for(int a:nums){\\n            temp+=a;\\n        }\\n        return res-temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int res;\\n        int n = nums.length;\\n        res = n*(n+1)/2;\\n        int temp =0;\\n        for(int a:nums){\\n            temp+=a;\\n        }\\n        return res-temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227521,
                "title": "c-2-solutions-sum-and-sort",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find sum of the first n numbers.\\n2. Keep subtracting elements of the array \\n3. The sum that you are left with in the end is the missing number \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - 1\\n```C++ []\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int sum = n * (n + 1)/2 ;\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            sum = sum - nums[i] ;\\n        }\\n        return sum ;\\n    }\\n};\\n```\\n---\\n# Approach\\n1. Sort the array \\n2. Iterate through the array for n times \\n3. If \\'i\\' is not equal to nums[i]. \\'i\\' is the missing number \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```C++ []\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int i ;\\n        sort (nums.begin(), nums.end());\\n        for (i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (nums[i] != i)\\n            {\\n                return i ;\\n            }\\n        }\\n        return i ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/0acb1d28-7f03-40cb-8e7c-1a2ddd980089_1677304202.3921719.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int sum = n * (n + 1)/2 ;\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            sum = sum - nums[i] ;\\n        }\\n        return sum ;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int i ;\\n        sort (nums.begin(), nums.end());\\n        for (i = 0 ; i < nums.size() ; i++)\\n        {\\n            if (nums[i] != i)\\n            {\\n                return i ;\\n            }\\n        }\\n        return i ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141067,
                "title": "4-line-c-bits-manipulation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince every element is unique ans is in range [0,n] \\nand we have to find unique element so if we XOR every element then there will xor of every element in range [nums[0],nums[n-1]] instead the mising element \\nand the property of XOR is that same element xor gives zero by utilizing this property and range of input we again do the XOR of our ans with every element from range [0,n];\\nfor eg\\n[0 2 3 4] here n=4 and mising element is 1\\nso by our approch we first xor all element so our ans will we\\nans=0^2^3^4 and when we again do xor from range [0,n]\\nthen every element will we twice instead of mising element\\ni.e. ans=(0^2^3^4)^(0^1^2^3^4);\\nso final ans=1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> see my approch done in O(n) instead of (2*n)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n= nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {   // doing xor of the number in nums and in range[0,n]\\n            // together \\n            ans=(ans^i^nums[i]);\\n        }\\n        // since n will we outofbound so handeled seperately\\n        ans=ans^n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n= nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {   // doing xor of the number in nums and in range[0,n]\\n            // together \\n            ans=(ans^i^nums[i]);\\n        }\\n        // since n will we outofbound so handeled seperately\\n        ans=ans^n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202995,
                "title": "c-one-liner-using-gauss-formula",
                "content": "## C++ | One-liner using Gauss Formula\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size()*(nums.size()+1)/2-accumulate(nums.begin(),nums.end(),0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size()*(nums.size()+1)/2-accumulate(nums.begin(),nums.end(),0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405834,
                "title": "easy-c-solution-using-hash-map-beats-60-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding all the missing postive numbers starting from 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI am using a hash map to keep track of given elements and finding the missing elements.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int arr[10000]={0};\\n        int i=0;\\n        std::vector<int>::iterator itr=nums.begin();\\n        while(itr!=nums.end())\\n        {\\n            arr[*itr]++;\\n            itr++;\\n            i++;\\n        }\\n        while(i>=0)\\n        {\\n            if(arr[i]==0)\\n                break;\\n            i--;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int arr[10000]={0};\\n        int i=0;\\n        std::vector<int>::iterator itr=nums.begin();\\n        while(itr!=nums.end())\\n        {\\n            arr[*itr]++;\\n            itr++;\\n            i++;\\n        }\\n        while(i>=0)\\n        {\\n            if(arr[i]==0)\\n                break;\\n            i--;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290608,
                "title": "java-in-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the numbers range from 0-n, we are creating a array with size of n+1, and iterate through the given array and flagging each, element in the created array\\'s index, and then iterating the created array to find which index have not been flagged and print the index, which is the number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstep1:create array of size n+1, i.e arr[n+1]\\nstep2:iterate through nums, make arr[nums[i]] = 1 (flagging the presented number)\\nstep3:iterate through arr, if arr[i]!=1, then return i, which is the missing number\\n\\n# Complexity\\n- Time complexity: O(n) , since it is will find by O(2n), as after removing constant, time complexity will be O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int arr[] = new int[nums.length + 1];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[nums[i]] = 1;\\n        }\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int arr[] = new int[nums.length + 1];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            arr[nums[i]] = 1;\\n        }\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165879,
                "title": "best-c-solutions-binary-search-xor-math-optimize-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using multiple approachs.\\n\\n1. Using Sorting + Binary Search.\\n2. Using Bit Manipulation.\\n2. Using Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] <= mid){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Since we are traversing the array only once.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Xor.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int res = 0, i;\\n        for(i=0; i<nums.size(); i++){\\n            res = res ^ nums[i] ^ i;\\n        }\\n        return res^i;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Since we are traversing the array only once.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sumOfNums = 0;\\n        for(int i=0; i<n; i++){\\n            sumOfNums += nums[i];\\n        }\\n        int sumOfNaturalNumber = (n*(n+1))/2;\\n        return sumOfNaturalNumber - sumOfNums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low+high) >> 1;\\n            if(nums[mid] <= mid){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Since we are traversing the array only once.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Xor.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int res = 0, i;\\n        for(i=0; i<nums.size(); i++){\\n            res = res ^ nums[i] ^ i;\\n        }\\n        return res^i;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Since we are traversing the array only once.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sumOfNums = 0;\\n        for(int i=0; i<n; i++){\\n            sumOfNums += nums[i];\\n        }\\n        int sumOfNaturalNumber = (n*(n+1))/2;\\n        return sumOfNaturalNumber - sumOfNums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222043,
                "title": "c-explanation-beats-100-optimized",
                "content": "# **PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Solution 1:**\\n**Time complexity: `O(nlogn)`**\\n**Space complexity: `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int answer;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i!=nums[i])\\n            {\\n                answer = i;\\n                break;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\n**Solution 2:**\\n**Time complexity: `O(n)`**\\n**Space complexity: `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = 0; \\n        \\n        int total_sum = (n*(n+1))/2; // Sum of n natural numbers\\n        \\n        for (auto number : nums)  \\n            sum += number; // add the number to the sum\\n        \\n        return total_sum - sum; // missing no. is the diff of total_sum and sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int answer;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i!=nums[i])\\n            {\\n                answer = i;\\n                break;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = 0; \\n        \\n        int total_sum = (n*(n+1))/2; // Sum of n natural numbers\\n        \\n        for (auto number : nums)  \\n            sum += number; // add the number to the sum\\n        \\n        return total_sum - sum; // missing no. is the diff of total_sum and sum\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082654,
                "title": "c-detailed-explanation-of-3-methods-o-n-time-complexity-o-1-space-complexity",
                "content": "![image](https://assets.leetcode.com/users/images/31bc3250-faa6-4596-876e-248236d9f400_1653725151.0072093.png)\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = n*(n+1)/2;\\n        for(int i = 0; i < n; i++){\\n            sum -= nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/9ddcb866-ca49-443d-823d-fe0fe81982b0_1653726850.884488.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums){\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n;){\\n            if(nums[i] != i && nums[i] < n)\\n                swap(nums[i], nums[nums[i]]);\\n            else{\\n                i++;   \\n            }\\n        }\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] != i) return i;\\n        \\n        return n;\\n    }\\n};\\n```\\nfor more details on swap sort refer: [https://leetcode.com/problems/missing-number/discuss/2081515/C%2B%2B-solution-using-%22Swap-Sort%22-(Detailed-Explaination)](http://)\\n\\n![image](https://assets.leetcode.com/users/images/201b6e5c-76be-4fca-adb9-40bd15376cef_1653728970.89119.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {  \\n        int res = nums.size();\\n        \\n        for(int i = 0; i < nums.size(); i++){ \\n            res ^= nums[i]; \\n            res ^= i; \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = n*(n+1)/2;\\n        for(int i = 0; i < n; i++){\\n            sum -= nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums){\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n;){\\n            if(nums[i] != i && nums[i] < n)\\n                swap(nums[i], nums[nums[i]]);\\n            else{\\n                i++;   \\n            }\\n        }\\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] != i) return i;\\n        \\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {  \\n        int res = nums.size();\\n        \\n        for(int i = 0; i < nums.size(); i++){ \\n            res ^= nums[i]; \\n            res ^= i; \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091191,
                "title": "python-math-oneliner-explained",
                "content": "This problem is a simple version of the problem **645. Set Mismatch**, so if you solved it previously, this one will be easy. Here you can look at my solution:\\n\\nhttps://leetcode.com/problems/set-mismatch/discuss/1089475/python-on-timeo1-space-math-solution-explained\\n\\nThe idea is the following: let us sum all numbers between `1` and `n` and then subtract sum of all `nums` and in the end we will have exaclty number we need.\\n\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums):\\n        return len(nums)*(len(nums)+1)//2 - sum(nums)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums):\\n        return len(nums)*(len(nums)+1)//2 - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 70082,
                "title": "java-simplest-solution-o-1-space-o-n-time",
                "content": "Knowing n ^ n = 0 and n ^ 0 = n this would be very simple. \\n\\n    public int missingNumber(int[] nums) {\\n        int result = 0;\\n        for (int i = 1; i <= nums.length; i++) {\\n            result ^= nums[i - 1];\\n            result ^= i;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "Knowing n ^ n = 0 and n ^ 0 = n this would be very simple. \\n\\n    public int missingNumber(int[] nums) {\\n        int result = 0;\\n        for (int i = 1; i <= nums.length; i++) {\\n            result ^= nums[i - 1];\\n            result ^= i;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3235187,
                "title": "268-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using various approaches, but one of the most efficient solutions is based on the concept of XOR operation.\\n\\nAlgorithm:\\n\\n1. Initialize the variable missing_num to n, where n is the length of the given array nums.\\n2. Loop through the array nums, and for each element, perform the XOR operation with the index of the element and the element itself. This step will help to cancel out the pairs of elements that exist in the array, leaving only the missing element.\\n3. Return the value of the missing_num variable.\\n\\nThis solution has a time complexity of O(n) and a space complexity of O(1), as it uses only constant extra space.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        # initialize missing_num to n\\n        missing_num = len(nums)\\n        \\n        # loop through the array nums\\n        for i, num in enumerate(nums):\\n            # perform XOR operation with index and element\\n            missing_num ^= i ^ num\\n        \\n        # return the missing number\\n        return missing_num\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        # initialize missing_num to n\\n        missing_num = len(nums)\\n        \\n        # loop through the array nums\\n        for i, num in enumerate(nums):\\n            # perform XOR operation with index and element\\n            missing_num ^= i ^ num\\n        \\n        # return the missing number\\n        return missing_num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158014,
                "title": "python-solution-using-sort",
                "content": "We have to traverse the list at least once to determine where the missing number is.  While we traverse the list, we keep track of the non-missing number i.  If i does not allign with the ith element in the list, we found the missing number.  Or rather in this case, the non-missing number i is the missing number from the list.  \\n\\nIf we get to the end, then the missing number must be len(nums) or max(nums)+1 like in Example 2 of the Description.\\n\\nThat really is my voice in the video.  I sound like an international robot.\\n\\n[@easyCodingSolutions](https://youtu.be/7wXDUu8cTfI)\\n\\nhttps://youtu.be/7wXDUu8cTfI\\n\\n# Code\\n```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        #sort the list nums\\n        nums.sort()\\n        #iterate through nums with i\\n        for i in range(len(nums)):\\n            #if i does not equal nums[i], return\\n            if i != nums[i]:\\n                return i\\n        #if the missing number is not in nums, it must be len(nums)\\n        return nums[-1]+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        #sort the list nums\\n        nums.sort()\\n        #iterate through nums with i\\n        for i in range(len(nums)):\\n            #if i does not equal nums[i], return\\n            if i != nums[i]:\\n                return i\\n        #if the missing number is not in nums, it must be len(nums)\\n        return nums[-1]+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082154,
                "title": "runtime-0-ms-faster-than-100-00-of-java-intution-explaination-easy-to-read-code",
                "content": "\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Missing Number.\\n\\nSo as per the input statement we need to find one missing number in the input array nums. What else is given in the question? \\n\\n* All the element present in the array are unique.\\n* n=nums.length\\n* total element are 0ton \\n* element missing 1 element between [0-n], rest of the element are present in the array.\\n\\n# Analysis : \\n\\nlets say given input arrays is =[3,0,1]\\n\\nn=3;\\nso element between 0,3 are 0,1,2,3\\n\\nsince all element present inside nums is unique and only one element is not present in the input array. Then we can do some mathmatical formulation.\\n\\nWhat is the sum of n natural nnumber? \\nit is expectedsum=(n*n+1))/2;\\n\\nsince [0-n] natural number are present in the input array, what is the  current sum?\\n\\nmissing element will be = expectedsum-currentsum;\\n\\nfor our input array = [3,0,1]\\nn=3;\\nexpectedsum=(3*(3+1))/2 = 6// sum of 3 natural number\\ncurrent sum=3+0+1=4\\nmissing number = 6-4=2;\\n\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int expectedsum = (n*(n+1))/2; \\n        int currentsum=0;\\n        for(int i=0;i<n;i++)\\n            currentsum+=nums[i];\\n\\n        return expectedsum-currentsum;\\n    }\\n}\\n```\\n\\n\\nT(n) = O(n)\\nS(n) = O(1)\\n\\ncheers!!!!\\n\\nPlease upvote if you like the solution.\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int expectedsum = (n*(n+1))/2; \\n        int currentsum=0;\\n        for(int i=0;i<n;i++)\\n            currentsum+=nums[i];\\n\\n        return expectedsum-currentsum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616623,
                "title": "binary-search-solution-explained-in-detail",
                "content": "There are a lot of good discussion posts here about the XOR approach and quite a few about Binary Search too but they lack the complete explanation that a beginner would need to grasp the concept :) \\n\\nWhy does binary search work? Let\\'s take a simple example where n = 5:\\n```\\n 0 1 2 4 5\\n```\\nIt is easy to see that the number 3 is missing in this input! Let us rewrite the array with indices \\n```\\nElements: 0 1 2 4 5\\nIndices : 0 1 2 3 4\\n```\\nWe know that binary search can be applied on a monotonic function, but how to convert this problem into that? \\n```\\nnums[index] > index\\n```\\nOn applying this to each index , what do we get?\\n```\\nf f f t t \\n```\\nOur goal is to find the first true! \\nSo \\n```\\nif nums[middle] <= middle, search in the right half with left = middle + 1\\notherwise middle is a viable answer, remember we need the first/smallest value so go find a lesser value in left half by right = middle - 1\\n```\\nThere is one case left though, \\nWhat if array is \\n```\\nElements : 0 1 2\\nIndices:   0 1 2\\n```\\nIn this case the missing value is 3 but by the above logic we keep getting to left = right + 1 case and end up going out of bounds, just handle that.\\n\\nFinal Code:\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n       sort(nums.begin(), nums.end()); \\n       int size = nums.size();\\n       int left =  0; \\n       int right = size-1;\\n       int middle = 0 ; \\n       int ans = -1 ; \\n       while(left <= right)\\n       {\\n           middle = left + (right - left)/2 ;\\n           if(nums[middle] <= middle)\\n           {\\n               //go right \\n               left = middle + 1 ; \\n           }\\n           else\\n           {\\n               ans = middle;\\n               right = middle - 1 ; //go to left half to see if smaller index exists\\n           }\\n       }\\n       if(ans == -1)\\n            return left;\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n 0 1 2 4 5\\n```\n```\\nElements: 0 1 2 4 5\\nIndices : 0 1 2 3 4\\n```\n```\\nnums[index] > index\\n```\n```\\nf f f t t \\n```\n```\\nif nums[middle] <= middle, search in the right half with left = middle + 1\\notherwise middle is a viable answer, remember we need the first/smallest value so go find a lesser value in left half by right = middle - 1\\n```\n```\\nElements : 0 1 2\\nIndices:   0 1 2\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n       sort(nums.begin(), nums.end()); \\n       int size = nums.size();\\n       int left =  0; \\n       int right = size-1;\\n       int middle = 0 ; \\n       int ans = -1 ; \\n       while(left <= right)\\n       {\\n           middle = left + (right - left)/2 ;\\n           if(nums[middle] <= middle)\\n           {\\n               //go right \\n               left = middle + 1 ; \\n           }\\n           else\\n           {\\n               ans = middle;\\n               right = middle - 1 ; //go to left half to see if smaller index exists\\n           }\\n       }\\n       if(ans == -1)\\n            return left;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450090,
                "title": "cyclic-sort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar missingNumber = function(nums) {\\n    const n = nums.length;\\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (nums[i] < n && nums[i] != i) {\\n            swap(nums, i, nums[i]);\\n        } else {\\n            i++;\\n        }\\n    }\\n    \\n    i = 0;\\n    while (i < n) {\\n        if (i != nums[i]) {\\n            return i;\\n        }\\n        i++;\\n    }\\n    \\n    return n;\\n};\\n\\nfunction swap(nums, a, b) {\\n    [nums[a], nums[b]] = [nums[b], nums[a]];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar missingNumber = function(nums) {\\n    const n = nums.length;\\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (nums[i] < n && nums[i] != i) {\\n            swap(nums, i, nums[i]);\\n        } else {\\n            i++;\\n        }\\n    }\\n    \\n    i = 0;\\n    while (i < n) {\\n        if (i != nums[i]) {\\n            return i;\\n        }\\n        i++;\\n    }\\n    \\n    return n;\\n};\\n\\nfunction swap(nums, a, b) {\\n    [nums[a], nums[b]] = [nums[b], nums[a]];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402153,
                "title": "my-golang-solution-16ms",
                "content": "```\\nfunc missingNumber(nums []int) int {\\n    var arrsum, allsum int\\n    for i:=0; i<len(nums); i++{\\n        arrsum+=nums[i]\\n        allsum+=i\\n    }\\n    return (allsum+len(nums))-arrsum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc missingNumber(nums []int) int {\\n    var arrsum, allsum int\\n    for i:=0; i<len(nums); i++{\\n        arrsum+=nums[i]\\n        allsum+=i\\n    }\\n    return (allsum+len(nums))-arrsum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387076,
                "title": "faster-than-100-00-of-java-online-submissio-0ms-o-1-time-java-solution",
                "content": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = (n*(n+1))/2;\\n        for(int i=0;i<n;i++) \\n            sum -=nums[i];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = (n*(n+1))/2;\\n        for(int i=0;i<n;i++) \\n            sum -=nums[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365050,
                "title": "python-one-liner-99-02-faster-solution",
                "content": "```\\ndef missingNumber(self, nums: List[int]) -> int:\\n        return ((len(nums)*(len(nums)+1))//2) - sum(nums)\\n```\\n\\nDo upvote if helpful :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef missingNumber(self, nums: List[int]) -> int:\\n        return ((len(nums)*(len(nums)+1))//2) - sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2230962,
                "title": "5-methods-c-0ms-beats-100-fast-easy",
                "content": "**METHOD 1: Intuitive Approach using SUM\\nTime Complexity: O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { \\n        int sum = 0;\\n        int total = nums.size()*(nums.size() + 1)/2;    // total is the sum of all numbers in the array\\n        for (auto number : nums) {   // iterate through the array\\n            sum += number;    // add the number to the sum\\n        }\\n        return total - sum;    // return the difference between the sum and the total that is the missing number\\n    }\\n};\\n```\\n\\n**METHOD 2: Using Bit- Manipulation\\nTime Complexity: O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int xor_val=0;\\n        for(auto x:nums){\\n            xor_val = xor_val ^ x;\\n        }\\n        for(int i=1;i<=nums.size();i++){\\n            xor_val = xor_val ^ i;\\n        }\\n        return xor_val;\\n    }\\n};\\n```\\n\\n\\n\\n\\n**METHOD 3: Using Bit- Manipulation BUT BETTER\\nTime Complexity: O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { \\n        int result = nums.size(); // initialize result to size of vector\\n        int i=0; // initialize i to 0\\n        for(int num:nums){ // for each number in vector\\n            result ^= num; // XOR result with number\\n            result ^= i; // XOR result with i\\n            i++; // increment i\\n        }\\n        return result; // return result that is the missing number\\n    }\\n};\\n\\n\\n```\\n***LIKE IT ?? PLEASE UPVOTE (^~^) .***\\n\\n\\n**METHOD 4: Binary Search\\nTime Complexity: O(NlogN)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\t\\t int left = 0, right = nums.size();\\n    while(left<right){\\n        int mid = (left + right)/2;\\n        if(nums[mid]>mid) right = mid;\\n        else left = mid+1;\\n    }\\n    return left;\\n    }\\n};\\n\\n```\\n\\n**METHOD 5: FOR 1 Liner FANS\\nTime Complexity: O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size() * (nums.size() + 1) / 2 - accumulate(nums.begin(), nums.end(), 0);\\n    }\\n};\\n```\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me (^~^)***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { \\n        int sum = 0;\\n        int total = nums.size()*(nums.size() + 1)/2;    // total is the sum of all numbers in the array\\n        for (auto number : nums) {   // iterate through the array\\n            sum += number;    // add the number to the sum\\n        }\\n        return total - sum;    // return the difference between the sum and the total that is the missing number\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int xor_val=0;\\n        for(auto x:nums){\\n            xor_val = xor_val ^ x;\\n        }\\n        for(int i=1;i<=nums.size();i++){\\n            xor_val = xor_val ^ i;\\n        }\\n        return xor_val;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) { \\n        int result = nums.size(); // initialize result to size of vector\\n        int i=0; // initialize i to 0\\n        for(int num:nums){ // for each number in vector\\n            result ^= num; // XOR result with number\\n            result ^= i; // XOR result with i\\n            i++; // increment i\\n        }\\n        return result; // return result that is the missing number\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\t\\t int left = 0, right = nums.size();\\n    while(left<right){\\n        int mid = (left + right)/2;\\n        if(nums[mid]>mid) right = mid;\\n        else left = mid+1;\\n    }\\n    return left;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        return nums.size() * (nums.size() + 1) / 2 - accumulate(nums.begin(), nums.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081757,
                "title": "one-line-c-solution-with-explanation",
                "content": "This is a C# solution with arithmetic series - the sum of the members of a finite arithmetic progression is called an arithmetic series (https://en.wikipedia.org/wiki/Arithmetic_progression).\\nLet\\'s assume that we have the full complete sequence (without the missed number) of n+1 numbers from 0 to n, total sum of this arithmetic series will be (0 + n) / 2 * (n+1), after that let\\'s subtract the sum of **nums** from the arithmetic series and we will find the missed number.\\n\\n```\\npublic class Solution {\\n    public int MissingNumber(int[] nums) {\\n        return nums.Length * (nums.Length + 1) / 2 - nums.Sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MissingNumber(int[] nums) {\\n        return nums.Length * (nums.Length + 1) / 2 - nums.Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081717,
                "title": "python-one-liner-with-examples",
                "content": "# **268. Missing Number**\\n**Example: **\\nnums = [0,1,2,4,5]\\nMissing number can be found out by multiplying the length of given array with its incremented value by one and doing integer division by two. For finding the missing number, we then subtract sum of all elements in the nums array from it.\\nResult=((len(nums)*len(num)+1)//2)-sum(nums)\\nResult=((5*6)//2)-12\\nResult=(30//2)-12\\nResult=15-12=3\\nAnd finally we have the missing number which is 3.\\n\\n**Python Code**\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return (len(nums)*(len(nums)+1)//2)-sum(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        return (len(nums)*(len(nums)+1)//2)-sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081619,
                "title": "explained-o-n-python-all-languages",
                "content": "# EXPLANATION\\n\\nGiven are n distinct numbers\\n\\nSum of those numbers = **( ( n * ( n + 1 ) ) // 2 )**\\n\\nwhich is equivalent to sum of first n positive natural numbers.\\n\\nThis will be equal to **( sum of array + missing number )**\\n\\n**Missing number = SUM OF FIRST N NUMBERS - SUM OF ARRAY**\\n\\n\\n\\n\\n# PYTHON CODE\\n```\\n\\nclass Solution:\\n\\n\\tdef missingNumber(self, n: List[int]) -> int:\\n\\n\\t\\treturn ( ( len(nums) * (len(nums)+1) ) // 2) - sum(nums)\\n\\n```\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/88b13431-cd40-47f4-9a05-498f099b9f7b_1653711201.2574031.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n\\nclass Solution:\\n\\n\\tdef missingNumber(self, n: List[int]) -> int:\\n\\n\\t\\treturn ( ( len(nums) * (len(nums)+1) ) // 2) - sum(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654586,
                "title": "javascript-simple-solution-faster-than-99-37-submissions",
                "content": "```\\nvar missingNumber = function(nums) {\\n    let n = nums.length\\n    let sum1 = (n * (n + 1)) / 2\\n    let sum2 = nums.reduce((prev,curr) => prev + curr)\\n    return sum1 - sum2\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingNumber = function(nums) {\\n    let n = nums.length\\n    let sum1 = (n * (n + 1)) / 2\\n    let sum2 = nums.reduce((prev,curr) => prev + curr)\\n    return sum1 - sum2\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770802,
                "title": "c-bitwise-solution",
                "content": "```\\nint missingNumber(int* nums, int numsSize)\\n{\\n    //we want to Xor all numbers from 0 to n twice so should be zero\\n    //because num^num = 0 \\n    //but number that is missing will appear only once in Xor, and that\\'s what will be left..\\n    \\n    int missing_number = numsSize;\\n    for(int i =0; i < numsSize; i++)\\n        missing_number ^= nums[i] ^ i;\\n    \\n    return missing_number;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint missingNumber(int* nums, int numsSize)\\n{\\n    //we want to Xor all numbers from 0 to n twice so should be zero\\n    //because num^num = 0 \\n    //but number that is missing will appear only once in Xor, and that\\'s what will be left..\\n    \\n    int missing_number = numsSize;\\n    for(int i =0; i < numsSize; i++)\\n        missing_number ^= nums[i] ^ i;\\n    \\n    return missing_number;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789952,
                "title": "easy-java-solution-3-lines-of-code-0ms-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Calculate sum from 1-N by using arithmetic sequence : \\nS = [(a1+ aN) * n] / 2 or you can use normal loop to calculate sum\\n2. Do the substraction between sum with all the element of nums\\n\\n# Code\\n```\\nclass Solution {\\n     public int missingNumber(int[] nums) {\\n        int n = nums.length, sum = n*(n+1)/2;\\n        for(int i : nums) sum -= i;\\n        return sum;\\n    }\\n}\\n```\\n\\n# Time Complexity\\n- Time complexity: O(n)\\n\\n# Space Complexity\\n- Time complexity: O(1)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int missingNumber(int[] nums) {\\n        int n = nums.length, sum = n*(n+1)/2;\\n        for(int i : nums) sum -= i;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480045,
                "title": "java-5-solutions",
                "content": "# Please upvote \\uD83D\\uDE07\\n---\\n### 1. By sorting:\\n``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums[0] != 0) {\\n            return 0;\\n        }\\n\\t\\t\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i + 1] > nums[i] + 1) {\\n                return nums[i] + 1;\\n            }\\n        }\\n\\t\\t\\n        return nums[nums.length - 1] + 1;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\\n---\\n\\n### 2. Math:\\n``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = n * (n + 1) / 2;\\n        for (int x : nums){\\n            sum -= x;\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n### 3. Bit Manipulation:\\n``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int ans = nums.length;\\n        for (int i = 0; i < nums.length; i++) {\\n            ans ^= (i ^ nums[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n### 4. Cycle sort:\\n``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length, i = 0;\\n        while (i < n) {\\n            int correctIdx = nums[i];\\n            if (nums[i] < n && nums[i] != nums[correctIdx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[correctIdx];\\n                nums[correctIdx] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if (j != nums[j]) {\\n                return j;\\n            }\\n        }\\n\\n        return n;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n--- \\n### 5. Binary Search:\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] == mid) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(logn) => O(n * logn)\\n// SC: O(1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums[0] != 0) {\\n            return 0;\\n        }\\n\\t\\t\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i + 1] > nums[i] + 1) {\\n                return nums[i] + 1;\\n            }\\n        }\\n\\t\\t\\n        return nums[nums.length - 1] + 1;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\n``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = n * (n + 1) / 2;\\n        for (int x : nums){\\n            sum -= x;\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int ans = nums.length;\\n        for (int i = 0; i < nums.length; i++) {\\n            ans ^= (i ^ nums[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` \\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length, i = 0;\\n        while (i < n) {\\n            int correctIdx = nums[i];\\n            if (nums[i] < n && nums[i] != nums[correctIdx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[correctIdx];\\n                nums[correctIdx] = temp;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if (j != nums[j]) {\\n                return j;\\n            }\\n        }\\n\\n        return n;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] == mid) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n}\\n\\n// TC: O(n * logn) + O(logn) => O(n * logn)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081515,
                "title": "c-solution-using-swap-sort-detailed-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ) {\\n            if(nums[i] != i && nums[i] < n)\\n                swap(nums[i], nums[nums[i]]);\\n            else\\n                ++i;\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] != i) return i;\\n        \\n        return n;\\n    }\\n};\\n```\\n\\nIf the array is sorted, we can simple iterate and check whether```nums[i] == i``` or not. But, the major task here is to sort the array in linear time and constant space. \\n\\nMerge Sort \\xA0 \\xA0  -> O(n*log n) time\\nCounting Sort  -> O(n) space\\n\\nSince elements lie in the range [0, n], \"swap sort\" comes to rescue.\\n\\nLet i = idx, n = size of array\\n\\n**Working**  : \\n1) If the current element is not on it\\'s correct position ```(nums[i] != i) && nums[i] < n```, \\n    then  ```swap(nums[i], nums[nums[i]])```.\\n2) Else increment the index ```i += 1```\\n\\n**Intuition**\\n1) The working is based on moving each element to its correct position. If the current element is not on its correct position, notice we  swap(nums[i], nums[nums[i]]). The advantage here is that, we atleast bring nums[i] to its correct position. If the current element == n, we can simply continue.\\n2) Notice, the time complexity here remains O(n) because in each step we are fixing atleast one element to its correct position.\\nSo, in the worst case for fixing one element, we may require ~n steps, but for others, it will be O(1) task.\\n\\ne.g. : \\n\\n[**4**, 3, 0, 1] (continue)\\n[4, **1**, 0, **3**] (we swap, notice how 3 came to its desired position)\\n[**0**, 1, **4**, 3] (we swap and 0 is fixed at its correct position)\\n...\\n\\nIn this way, you can intuitively think we won\\'t require more than O(2*n) steps. Thus,\\n**Time compleixty** : O(n)\\n**Space complexity** : O(1)\\n\\nWith little modifications, this approach can solve the problems given below : \\n\\nhttps://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/\\nhttps://leetcode.com/problems/find-all-duplicates-in-an-array/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/first-missing-positive/\\nhttps://leetcode.com/problems/missing-number/\\n\\nPlease **upvote** if you find it useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; ) {\\n            if(nums[i] != i && nums[i] < n)\\n                swap(nums[i], nums[nums[i]]);\\n            else\\n                ++i;\\n        }\\n        \\n        for(int i = 0; i < n; ++i)\\n            if(nums[i] != i) return i;\\n        \\n        return n;\\n    }\\n};\\n```\n```nums[i] == i```\n```(nums[i] != i) && nums[i] < n```\n```swap(nums[i], nums[nums[i]])```\n```i += 1```",
                "codeTag": "Java"
            },
            {
                "id": 1798558,
                "title": "3-different-type-answer-using-c-last-one-very-fast",
                "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        /* T1\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==nums[i])\\n                ;\\n            else\\n                return i;\\n            \\n        }\\n        return nums.size();\\n        \\n        */\\n       \\n        \\n        /*T2\\n        \\n        set<int>s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        int y=0;\\n        for(auto x:s)\\n        {\\n            if(y==x)\\n                y++;\\n            else\\n                return y;\\n        }\\n        return s.size();\\n        \\n        */\\n        \\n        //ptimized one\\n        \\n        int n=nums.size();\\n        int fin = (n*(n+1))/2;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        return (fin-sum);   \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        /* T1\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==nums[i])\\n                ;\\n            else\\n                return i;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 69926,
                "title": "c-two-solutions-math-and-bit-manipulation",
                "content": "1.bit manipulation. \\n\\nIt is like there are 2n+1 numbers from 0 to n. One number appears once, all the others appear twice. Then, find the one appears only once.\\n\\n    int missingNumber(vector<int>& nuts)\\n     {\\n        int res=0;\\n        for (int i=0;i<nums.size();i++){\\n            res^=nums[i]^i;\\n        }\\n        res^=nums.size();\\n        return res;\\n    }\\n\\n2.math \\n\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int total = n*(n+1)/2;\\n        for (auto &x:nums){\\n            total-=x;\\n        }\\n        return total;\\n    }",
                "solutionTags": [],
                "code": "1.bit manipulation. \\n\\nIt is like there are 2n+1 numbers from 0 to n. One number appears once, all the others appear twice. Then, find the one appears only once.\\n\\n    int missingNumber(vector<int>& nuts)\\n     {\\n        int res=0;\\n        for (int i=0;i<nums.size();i++){\\n            res^=nums[i]^i;\\n        }\\n        res^=nums.size();\\n        return res;\\n    }\\n\\n2.math \\n\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int total = n*(n+1)/2;\\n        for (auto &x:nums){\\n            total-=x;\\n        }\\n        return total;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3380700,
                "title": "short-and-clean-code-optimal-solution-using-xor",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  int missingNumber(vector<int> &nums)\\n  {\\n    int missing = nums.size(); // start with n\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n      missing ^= i ^ nums[i]; // XOR all numbers with 0 to n and the array\\n    }\\n    return missing;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int missingNumber(vector<int> &nums)\\n  {\\n    int missing = nums.size(); // start with n\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n      missing ^= i ^ nums[i]; // XOR all numbers with 0 to n and the array\\n    }\\n    return missing;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293943,
                "title": "c-easy-to-understand-simple-maths",
                "content": "**Please Upvote if you find this solution helpful**\\n\\nFind total sum of the range by using the size of the array, then subtract each value of the array from the total sum. The remaining sum would be the answer (The missing number itself).\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tint total = n*(n+1) / 2;                      // Sum of first n natural numbers\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            total -= nums[i];\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tint total = n*(n+1) / 2;                      // Sum of first n natural numbers\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            total -= nums[i];\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534891,
                "title": "c-simple-with-xor",
                "content": "With XOR.\\n2 rules:\\n1. a^a = 0\\n2. a^0 = a\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int miss_num = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            miss_num ^= i;\\n            miss_num ^= nums[i];\\n        }\\n        return miss_num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int miss_num = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            miss_num ^= i;\\n            miss_num ^= nums[i];\\n        }\\n        return miss_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629832,
                "title": "python-easy-3-lines-of-code-with-o-1-space-and-92-07-faster-runtime",
                "content": "class Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n\\t\\tl = len(nums)\\n        s = l*(l+1)//2\\n        return s-sum(nums)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n\\t\\tl = len(nums)\\n        s = l*(l+1)//2\\n        return s-sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 70000,
                "title": "4-line-o-1-in-space-and-o-n-in-time-c-solution",
                "content": "    int missingNumber(int* nums, int numsSize) {\\n        int n = 0;\\n        for (int i = 0; i < numsSize; i++) {\\n            n ^= i ^ nums[i];\\n        }\\n        return n ^ numsSize;\\n    }",
                "solutionTags": [],
                "code": "    int missingNumber(int* nums, int numsSize) {\\n        int n = 0;\\n        for (int i = 0; i < numsSize; i++) {\\n            n ^= i ^ nums[i];\\n        }\\n        return n ^ numsSize;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3859546,
                "title": "2-methods-explained-optimized-code-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Storing XOR of all natural numbers upto n in a variable.\\n- Now taking XOR of elements in another variable.\\n- Take XOR of these two stored variables and return it.\\n- It works because if same_number ^ same_number = 0 \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int num = 0, n=nums.size(), x=nums[0];\\n        for(int i=1; i<=n;i++)num^=i;\\n        for(int i=1; i<n; i++)x^=nums[i];\\n        return num^x;\\n    }\\n};\\n```\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Used the formula for sum of first n natural number.\\n- It might get integer overflow if n is large. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        int s2=n*(n+1)/2;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        return s2-sum;\\n    }\\n};\\n```\\n# More basic Methods:\\n- Use hash and then find which one is missing.\\n- Sort the array and use liner traversal.\\n- Or use binary search...\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int num = 0, n=nums.size(), x=nums[0];\\n        for(int i=1; i<=n;i++)num^=i;\\n        for(int i=1; i<n; i++)x^=nums[i];\\n        return num^x;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        int s2=n*(n+1)/2;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n        }\\n        return s2-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516810,
                "title": "math-based-solution-single-pass-c-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the range of numbers occuring in the array is given as [0, n], we know that if the array was complete, the sum of all the elements occuring in the array would be n*(n+1)/2;\\n\\nIf we were to take sum of all the elements currently occuring in the array and subtract it from the ideal sum of all the elements in the array, we will obtain the missing number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare a variable `sum` and initialize it to 0. Iterate through the array and add the elements to `sum` to take the cummulative sum of the array.\\n\\nFinally, return the difference between the ideal sum of the array (n*n+1/2, where `n` is the size of the array) and `sum`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        \\n        return n*(n+1)/2-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        \\n        return n*(n+1)/2-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389911,
                "title": "java-arithmetic-progression",
                "content": "# Intuition\\nSolution is made by means of an afrithmetic progression\\n\\n# Approach\\nFor instance: [3, 0, 1]. The ideal array should be [3, 0, 1, 2]. We sum 3 + 0 + 1 + 2 and divide 3 + 0 + 1. So, the answer is 2.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int sum = 0;\\n        int numsSize = nums.length;\\n\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n\\n        return (numsSize * (numsSize + 1)) / 2 - sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int sum = 0;\\n        int numsSize = nums.length;\\n\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n\\n        return (numsSize * (numsSize + 1)) / 2 - sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224166,
                "title": "using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int s=0;\\n       int e=nums.size()-1;\\n       int mid = s+(e-s)/2;\\n       while(s<=e)\\n       {\\n           if(nums[mid]<=mid)\\n                s=mid+1;\\n            else\\n                e=mid-1;\\n        mid = s+(e-s)/2;\\n       }\\n       return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int s=0;\\n       int e=nums.size()-1;\\n       int mid = s+(e-s)/2;\\n       while(s<=e)\\n       {\\n           if(nums[mid]<=mid)\\n                s=mid+1;\\n            else\\n                e=mid-1;\\n        mid = s+(e-s)/2;\\n       }\\n       return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039163,
                "title": "easy-approach-c",
                "content": "# Approach\\nwe can check difference between every two elements after sorting and also consider edge cases.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& a) {\\n        int n = a.size();\\n        sort(a.begin(),a.end());\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(a[i]-a[i-1] > 1)\\n            return a[i]-1;\\n        }\\n        if(a[0] != 0)\\n        return 0;\\n        \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& a) {\\n        int n = a.size();\\n        sort(a.begin(),a.end());\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(a[i]-a[i-1] > 1)\\n            return a[i]-1;\\n        }\\n        if(a[0] != 0)\\n        return 0;\\n        \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235492,
                "title": "python-cyclic-sort-time-o-n-space-o-1-explained",
                "content": "# Explaination:\\n**Understanding the Problem:**\\nThe problem itself is fairly straight forward. Lets do a breakdown.\\n- We are given an array of **unique numbers**\\n- The numbers will be in a range of 0 to N where N is the length of the input array\\n- There is a missing number in that range that is not in the input array.\\n**Example:**\\nInput = [0,4,2,1]\\nThe range is 0-N and N is the length of the array, the length of the array is 4.\\nSo the range is 0-4.\\nWe have 0, 1, 2, but we\\'re missing 3, and we have 4.\\nWe can assume there will always only one missing number in the range for this problem.\\n\\n**Possible Simple Solutions:**\\nSort the array and just search the array, if the number matches the index (since the index goes from 0-3) then the numbers 0-3 exist, but 4 is missing. \\n\\nAnother solution would be to create a set or hash and save all the numbers from the input array in it. Then just use a `for` loop to count through the range 0-4 including 4. Each iteration you\\'ll check the if current number is in the set, if it isn\\'t return that number because that is our missing number.\\n\\n**Optimal Solution Explaination:**\\n**Cyclic Sort** works by mapping numbers to the indexes in an array. So 0 goes in index 0, 1 goes in index 1, 2 goes in index 2, 3 goes in index 3, and 4 goes in index 4.\\nBut as we know, in an array of length 4, we only go up to index 3.\\nSo what happens with this input?: [0,4,2,1]\\nWell we know we\\'re only going to be missing 1 number from the array, so we map every number we can to their correct index and at the end there will be 1 number in the wrong index. You return the number that SHOULD be there, that is your solution.\\n\\nSo it becomes [0,1,2,4]. Notice how index 3 has a 4? But every other index has the matching value. Index 0 has value 0, index 1 has value 1, index 2 has value 2. But index 3 doesn\\'t have value 3, it has a different non-matching value. So we know we need to return the index, since the value at that index should be matching the index, in this case it should be 3.\\n\\nBut what happens if we\\'re given this input? [1,0,3,2]\\nIf we do cyclic sort it becomes [0,1,2,3]\\nBut notice, everything is in the correct index, so there is no missing number right? Wrong.\\nRemember the range is 0 - N and N is the length of the array, the length of the array is 4.\\nSo in the case where all numbers match their respective indexes, then we return the length of the array, since that is the last number in the range and is our missing number, in this case its 4.\\n\\n**Code Explaination:**\\n1. Initialize \\'i\\' which will keep track of the current index we are on\\n2. Standard `while` loop to iterate through the array\\n3. `j` will hold the value of `nums[i]`. So if `nums[i]` is value 2, we will save 2 to `j`, then we can do `nums[j]` to swap the values of `i` and `j`, so 2 would go to index 2 and whatever is at index 2 will go to `nums[i]`\\n4. In our `if` conditional statement we check if `nums[i] < len(nums)` because arrays are 0 based index, so if `nums[i]` is 4, we can\\'t map that to any index, because our last index would be 3. So we ignore that number and map everything else. After everything else is mapped in the correct place, wherever 4 ends up will be where the missing number should be.\\n5. We also check if the value at `nums[i]` is NOT EQUAL to its current index `i`, if they\\'re equal then we do nothing because this is in the correct spot.\\n6. If the current value is `len(arr)` or if the value at `nums[i]` is at its correct index, then we just increment our index.\\n7. Now we just iterate through the array with a `for` loop and compare every index to its value, if the index number doesn\\'t match the value number, then we found our missing numberr. We just return the index, because the index number is what value number SHOULD be there.\\n8. If all the values match their index, then the only missing number can be `len(nums)` which is the last number in our range, so we return that.\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        i = 0 # This will keep track of the current index as we iterate through the array\\n        while i < len(nums):\\n            j = nums[i] # This will hold the value at our current index and that value will be the index we swap values with\\n            if nums[i] < len(nums) and nums[i] != i:\\n                nums[i], nums[j] = nums[j], nums[i] # Swap\\n            else:\\n                i += 1\\n        \\n\\t\\t# Now we just iterate through the array and look for the value that doesn\\'t match its index\\n        for idx in range(len(nums)):\\n            if nums[idx] != idx:\\n                return idx\\n\\t\\t\\t\\t\\n\\t\\t# If all values match their index, then the only missing number is the end the the range\\n\\t\\t# So we return len(nums)\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        i = 0 # This will keep track of the current index as we iterate through the array\\n        while i < len(nums):\\n            j = nums[i] # This will hold the value at our current index and that value will be the index we swap values with\\n            if nums[i] < len(nums) and nums[i] != i:\\n                nums[i], nums[j] = nums[j], nums[i] # Swap\\n            else:\\n                i += 1\\n        \\n\\t\\t# Now we just iterate through the array and look for the value that doesn\\'t match its index\\n        for idx in range(len(nums)):\\n            if nums[idx] != idx:\\n                return idx\\n\\t\\t\\t\\t\\n\\t\\t# If all values match their index, then the only missing number is the end the the range\\n\\t\\t# So we return len(nums)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081529,
                "title": "o-n-solution-in-cpp-with-constant-space",
                "content": "The idea here is that the numbers are from range 0 to n, and we know that the sum of numbers from 0 to n is given by n*(n+1)/2....\\nNow we find the sum of all the elements in our vector and subtract the result by this sum to get missing number...\\n\\nEx-->\\narray --> 0,1,3,4\\nsum of first 4 natural numbers = 4*(4+1)/2 = 10\\nsum of elements in array          = 8\\nMissing element                       = 10-8 = 2\\n\\n**Pls upvote this thread if you found the solution helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0, n=nums.size();\\n        //Sum of first n numbers\\n\\t\\tint act = (n*(n+1))/2;\\n        \\n\\t\\t//Sum of elements of our vector\\n        for(int i=0;i<n;i++) sum+=nums[i];\\n        \\n        return act-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0, n=nums.size();\\n        //Sum of first n numbers\\n\\t\\tint act = (n*(n+1))/2;\\n        \\n\\t\\t//Sum of elements of our vector\\n        for(int i=0;i<n;i++) sum+=nums[i];\\n        \\n        return act-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069345,
                "title": "c-o-1-extra-space-complexity-and-o-n-runtime-complexity-solution",
                "content": "Input is arithmetic progression with one missing element. Difference between expected sum and actual sum will be missing number:\\n\\n```\\npublic class Solution\\n{\\n    public int MissingNumber(int[] nums)\\n    {\\n        return nums.Length * (nums.Length + 1) / 2 - nums.Sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MissingNumber(int[] nums)\\n    {\\n        return nums.Length * (nums.Length + 1) / 2 - nums.Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037080,
                "title": "python-xor-method-explained-beats-99",
                "content": "XOR attributes that can help us with this question:\\n1. for any number n -> n^n = 0\\n2. for any number n -> n^0 = n\\n\\nWith that in mind, in order to find the missing number in the range of [0, n]:\\n1. We\\'ll calculate to XOR operation for values in the given range:\\nres = 0^1^2^3^...^n\\n\\n2. We\\'ll XOR the result with every value in the actual nums list. XOR operation is associative (we can change the order without affecting the end result), therefore we can look at result like that:\\nres = 0^0^1^1^2^2^....^n^n\\n\\n3. XOR of the same number cancels out. we know that only one number, let\\'s call it X, is missing from the nums list, which means it would only appear once in our end result equation:\\nres = 0^X = X\\n\\nnow we can just return the result.\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(len(nums) + 1):\\n            res ^= i\\n        \\n        for n in nums:\\n            res ^= n\\n        \\n        return res\\n```\\n\\nUpvote if this solution helped you :)",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in range(len(nums) + 1):\\n            res ^= i\\n        \\n        for n in nums:\\n            res ^= n\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859342,
                "title": "o-1-space-solution-not-xor-with-explanation",
                "content": "We know that we have `n` numbers in the `nums` input array. What if we compare the sum of the numbers in the input array with sum of numbers of a \"perfect\" array, where no elements are missing?\\nIn other words, if we have `n` elements in nums, we can do this:\\n1. Count all numbers from 1 to `n` - 0+1+2+3+ ... + n\\n2. Count all of the numbers in the input array - 0+1+3+4 ... + n (2 is missing)\\n3. Compare the results - the difference between them will be the missing number.\\n\\nHow do we get the sum of numbers from 0 to n? We can use a math formula to get the sum of first n natural numbers: sum = `n ( n + 1 ) / 2`\\n\\nPHP Solution: O(n) runtime, O(1) extra space\\n```php\\n    function missingNumber($nums) {\\n        // sum from 1 (or 0) through n is n(n+1)/2\\n        \\n        // Step 1. Get size of input (n)\\n        $n = count($nums);\\n        \\n        // Step 2. Count sum from 0 to n\\n        $targetSum = $n * ($n+1) / 2;\\n        \\n        // Step 3. Count actual sum in nums\\n        $actualSum = array_sum($nums);\\n        \\n        // step 4 - the diff is the answer\\n        return $targetSum - $actualSum;\\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```php\\n    function missingNumber($nums) {\\n        // sum from 1 (or 0) through n is n(n+1)/2\\n        \\n        // Step 1. Get size of input (n)\\n        $n = count($nums);\\n        \\n        // Step 2. Count sum from 0 to n\\n        $targetSum = $n * ($n+1) / 2;\\n        \\n        // Step 3. Count actual sum in nums\\n        $actualSum = array_sum($nums);\\n        \\n        // step 4 - the diff is the answer\\n        return $targetSum - $actualSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1771266,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int item = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i + item != nums[i]) {\\n                return i + item;\\n            }\\n        }\\n        return Arrays.stream(nums).anyMatch(i -> i == 0) ? nums[nums.length - 1] + 1 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int item = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i + item != nums[i]) {\\n                return i + item;\\n            }\\n        }\\n        return Arrays.stream(nums).anyMatch(i -> i == 0) ? nums[nums.length - 1] + 1 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707214,
                "title": "java-time-space",
                "content": "```\\n/**\\n * Use Sum\\n *  - Time O(n)\\n *  - Space O(1)\\n */\\nclass MissingNumberSum {\\n  public int missingNumber(int[] nums) {\\n    int sum = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < nums.length; i++) {\\n      sum += i;\\n      sum -= nums[i];\\n    }\\n    \\n    return sum + nums.length;\\n  }\\n}\\n\\n/**\\n * Use Binary (XOR)\\n *  - Time O(n)\\n *  - Space O(1)\\n */\\nclass MissingNumberBinary {\\n  public int missingNumber(int[] nums) {\\n    int sum = nums.length;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < nums.length; i++) {\\n      sum = sum ^ i ^ nums[i];\\n    }\\n    \\n    return sum;\\n  }\\n}\\n\\n/**\\n * Use Binary Search\\n *  - Time\\n *     - Array was sorted O(logn)\\n *     - Array was\\'t sorted O(nlogn)\\n *  - Space O(1)\\n */\\nclass MissingNumberBS {\\n  public int missingNumber(int[] nums) {\\n    int left = 0;\\n    int right = nums.length;\\n    int mid = (left + right) / 2;\\n    /**\\n     * Array was sorted O(logn)\\n     * Array wasn\\'t sorted O(nlogn)\\n     */\\n    Arrays.sort(nums);\\n\\n    /**\\n     * Binary Search\\n     *  - Time O(logn)\\n     */\\n    while (left < right) {\\n      mid = (left + right) / 2;\\n      if (nums[mid] > mid) right = mid;\\n      else left = mid + 1;\\n    }\\n    return left;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Use Sum\\n *  - Time O(n)\\n *  - Space O(1)\\n */\\nclass MissingNumberSum {\\n  public int missingNumber(int[] nums) {\\n    int sum = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < nums.length; i++) {\\n      sum += i;\\n      sum -= nums[i];\\n    }\\n    \\n    return sum + nums.length;\\n  }\\n}\\n\\n/**\\n * Use Binary (XOR)\\n *  - Time O(n)\\n *  - Space O(1)\\n */\\nclass MissingNumberBinary {\\n  public int missingNumber(int[] nums) {\\n    int sum = nums.length;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < nums.length; i++) {\\n      sum = sum ^ i ^ nums[i];\\n    }\\n    \\n    return sum;\\n  }\\n}\\n\\n/**\\n * Use Binary Search\\n *  - Time\\n *     - Array was sorted O(logn)\\n *     - Array was\\'t sorted O(nlogn)\\n *  - Space O(1)\\n */\\nclass MissingNumberBS {\\n  public int missingNumber(int[] nums) {\\n    int left = 0;\\n    int right = nums.length;\\n    int mid = (left + right) / 2;\\n    /**\\n     * Array was sorted O(logn)\\n     * Array wasn\\'t sorted O(nlogn)\\n     */\\n    Arrays.sort(nums);\\n\\n    /**\\n     * Binary Search\\n     *  - Time O(logn)\\n     */\\n    while (left < right) {\\n      mid = (left + right) / 2;\\n      if (nums[mid] > mid) right = mid;\\n      else left = mid + 1;\\n    }\\n    return left;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705446,
                "title": "easy-solution-in-c-c",
                "content": "**NOTE:** \\n1. We take n consecutive integers from 0 to n. \\n2. So sum of all can be given by **n(n+1)/2** {sum of natural numbers upto n}. \\n3. Now all that is left is to subtract every number we encounter and we get the left out number.\\n4. This remainder is our answer that we return.\\n\\n\\n**Pseudo Code:**\\n```\\nint sum=numsSize*(numsSize+1)/2;\\nfor(int i=0;i<numsSize;i++){\\nsum-=nums[i];}\\nreturn sum;\\n```\\n\\n*code will work for both c and c++. ensure to use appropriate size of input array/vector in place of numsSize.*\\n\\n**Although I Discourage the copy paste of code for passing question I am providing the Code below for both C and C++**\\n\\n**Code in C**\\n```\\nint missingNumber(int* nums, int numsSize){\\nint num=numsSize*(numsSize+1)/2;\\n\\nfor(int i=0;i<numsSize;i++){\\n    num-=nums[i];\\n}\\n    return num;\\n}\\n```\\n\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\nint missingNumber(vector<int>& nums) {\\n\\nint numsSize=nums.size();\\nint num=numsSize*(numsSize+1)/2;\\n\\nfor(int i=0;i<numsSize;i++){\\n      num-=nums[i];\\n}\\n    return num;  \\n}\\n};\\n```\\n\\nIf the code helped you or you have any doubt. please feel free to reply on the discussion. I will be happy to answer.\\nPress the upvote to let me know that it was useful. Thank you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint sum=numsSize*(numsSize+1)/2;\\nfor(int i=0;i<numsSize;i++){\\nsum-=nums[i];}\\nreturn sum;\\n```\n```\\nint missingNumber(int* nums, int numsSize){\\nint num=numsSize*(numsSize+1)/2;\\n\\nfor(int i=0;i<numsSize;i++){\\n    num-=nums[i];\\n}\\n    return num;\\n}\\n```\n```\\nclass Solution {\\npublic:\\nint missingNumber(vector<int>& nums) {\\n\\nint numsSize=nums.size();\\nint num=numsSize*(numsSize+1)/2;\\n\\nfor(int i=0;i<numsSize;i++){\\n      num-=nums[i];\\n}\\n    return num;  \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393158,
                "title": "3-javascript-solutions",
                "content": "**Approach 1:**\\n\\n```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;\\n    let sum = len;\\n    for(let i = 0; i < len; i++) {\\n        sum = sum + i - nums[i];\\n    }\\n    return sum;\\n};\\n```\\n\\n**Approach 2:**\\n```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;\\n    let xor = len;\\n    for(let i = 0; i < len; i++) {\\n        xor = xor ^ i ^ nums[i];\\n    }\\n    return xor;\\n};\\n```\\n\\n**Approach 3:**\\n\\n```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;\\n    let sum = 0;\\n    sum = nums.reduce((a, b) => {\\n        return a + b;\\n    }, 0)\\n    \\n    return Math.floor((len * (len + 1)) / 2) - sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;\\n    let sum = len;\\n    for(let i = 0; i < len; i++) {\\n        sum = sum + i - nums[i];\\n    }\\n    return sum;\\n};\\n```\n```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;\\n    let xor = len;\\n    for(let i = 0; i < len; i++) {\\n        xor = xor ^ i ^ nums[i];\\n    }\\n    return xor;\\n};\\n```\n```\\nvar missingNumber = function(nums) {\\n    let len = nums.length;\\n    let sum = 0;\\n    sum = nums.reduce((a, b) => {\\n        return a + b;\\n    }, 0)\\n    \\n    return Math.floor((len * (len + 1)) / 2) - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1091242,
                "title": "c-faster-than-99-21-3-lines-o-1-space-o-n-time",
                "content": "\\n```\\nint missingNumber(int* nums, int numsSize){\\n    int index = 0, res = 0;\\n    for (  ;index < numsSize; res += -nums[index] + ++index );\\n    return res;\\n}",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "\\n```\\nint missingNumber(int* nums, int numsSize){\\n    int index = 0, res = 0;\\n    for (  ;index < numsSize; res += -nums[index] + ++index );\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1043007,
                "title": "javascript-o-n-time-and-o-1-space",
                "content": "```\\nvar missingNumber = function(nums) {\\n    let expectedSum = 0;\\n    let actualSum = 0;\\n    for (let i = 0; i <= nums.length; i++) {\\n        expectedSum += i;\\n    }\\n    for (let num of nums) {\\n        actualSum += num;\\n    }\\n    return expectedSum - actualSum;\\n};\\n```\\n\\nHow to analyze time and space complexity : https://rohitdhatrak.netlify.app/time-space-complexity/\\nMy Ds-Algo Repo : https://github.com/RohitDhatrak/DS-Algo\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingNumber = function(nums) {\\n    let expectedSum = 0;\\n    let actualSum = 0;\\n    for (let i = 0; i <= nums.length; i++) {\\n        expectedSum += i;\\n    }\\n    for (let num of nums) {\\n        actualSum += num;\\n    }\\n    return expectedSum - actualSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859510,
                "title": "c-o-n-o-1-using-cyclic-sort",
                "content": "**The idea is to use cyclic sort since we have numbers from 0 to n we can place the number at their correct index . Once we have every number in its correct place, we can iterate the array to find the index which does not have the correct number, and that index will be our missing number. The only thing to remember that if we have number which is greater than last index  (nums.size()-1) then we move to the next index***\\n**for better understanding dry run the code for sample test cases**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans;\\n        for(int i = 0 ; i<nums.size() ; ){\\n            if(i == nums[i] || nums[i] >= nums.size()){\\n                i++;\\n                continue;\\n            }\\n            else{\\n                swap(nums[i] , nums[nums[i]]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size() ; i++){\\n            if(i != nums[i]){\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans;\\n        for(int i = 0 ; i<nums.size() ; ){\\n            if(i == nums[i] || nums[i] >= nums.size()){\\n                i++;\\n                continue;\\n            }\\n            else{\\n                swap(nums[i] , nums[nums[i]]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size() ; i++){\\n            if(i != nums[i]){\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641131,
                "title": "3-swift-implementations",
                "content": "I wrote a blog post on how to solve this problem in Swift: https://cocoaswiftly.com/leetcode-solutions/268-missing-number/\\n\\nImplementation 1:\\n\\n```\\nfunc missingNumber(_ nums: [Int]) -> Int {\\n    let numsSet = Set(nums)\\n    for i in 0 ... nums.count where !numsSet.contains(i) {\\n        return i\\n    }\\n\\n    fatalError(\"It\\'s impossible to get here\")\\n}\\n```\\n\\nImplementation 2:\\n\\n```\\nfunc missingNumber(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n\\n    for (index, num) in sortedNums.enumerated() where index != num {\\n        return index\\n    }\\n\\n    return sortedNums.endIndex\\n}\\n```\\n\\nImplementation 3:\\n\\n```\\nfunc missingNumber(_ nums: [Int]) -> Int {\\n    let n = nums.count\\n    let zeroToNSum = n * (n + 1) / 2\\n    let inputSum = nums.reduce(0, +)\\n    return zeroToNSum - inputSum\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc missingNumber(_ nums: [Int]) -> Int {\\n    let numsSet = Set(nums)\\n    for i in 0 ... nums.count where !numsSet.contains(i) {\\n        return i\\n    }\\n\\n    fatalError(\"It\\'s impossible to get here\")\\n}\\n```\n```\\nfunc missingNumber(_ nums: [Int]) -> Int {\\n    let sortedNums = nums.sorted()\\n\\n    for (index, num) in sortedNums.enumerated() where index != num {\\n        return index\\n    }\\n\\n    return sortedNums.endIndex\\n}\\n```\n```\\nfunc missingNumber(_ nums: [Int]) -> Int {\\n    let n = nums.count\\n    let zeroToNSum = n * (n + 1) / 2\\n    let inputSum = nums.reduce(0, +)\\n    return zeroToNSum - inputSum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140744,
                "title": "simple-javascript-solution",
                "content": "```\\nvar missingNumber = function(nums) {\\n    let sum = 0;\\n    let expectedSum = nums.length;\\n    for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        expectedSum += i;\\n    }\\n    \\n    return expectedSum - sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar missingNumber = function(nums) {\\n    let sum = 0;\\n    let expectedSum = nums.length;\\n    for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        expectedSum += i;\\n    }\\n    \\n    return expectedSum - sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 69823,
                "title": "o-n-solution-only-using-a-sum-of-array-in-c",
                "content": "    int missingNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int sum = 0;\\n            for (int i=0;i < nums.size();i++) {\\n                sum += nums[i];\\n            }\\n            // For numbers 0, 1, 2, ..., n the sum should be n*(n+1)/2,\\n            // return what is left out\\n            return n*(n+1)/2 - sum;\\n        }\\n\\nSimply sum the array. If nothing is missing, the sum should be n*(n+1)/2, so just return the missing number.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int missingNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int sum = 0;\\n            for (int i=0;i < nums.size();i++) {\\n                sum += nums[i];\\n            }\\n            // For numbers 0, 1, 2, ..., n the sum should be n*(n+1)/2,\\n            // return what is left out\\n            return n*(n+1)/2 - sum;\\n        }\\n\\nSimply sum the array. If nothing is missing, the sum should be n*(n+1)/2, so just return the missing number.",
                "codeTag": "Unknown"
            },
            {
                "id": 70002,
                "title": "c-4-lines-xor-simple-solution",
                "content": "      int missingNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int i = 1; i <= nums.size(); i++) \\n              {  res ^= i ^ nums[i-1]; }\\n            return res;\\n        }",
                "solutionTags": [],
                "code": "      int missingNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int i = 1; i <= nums.size(); i++) \\n              {  res ^= i ^ nums[i-1]; }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 4072540,
                "title": "easy-approach-with-o-n-and-o-1-complexities",
                "content": "# Intuition\\n<!--  -->The numbers in array are unique and the range of numbers is between 0 to size of array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, a number is missing in range [0,n]\\n\\nMissing number is : (sum of all numbers [0 to n] ) - (sum of all numbers in array)\\n\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1) \\n\\n# Code\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        return ((n*(n+1))//2)-(sum(nums))\\n```\\n\\nplease Upvote if you like",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        return ((n*(n+1))//2)-(sum(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981546,
                "title": "math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        # nums.sort()\\n        # for i,x in enumerate(nums):\\n        #     if i != x:\\n        #         return i\\n        # return len(nums)\\n        n=sum(nums)\\n        m=sum(range(0,len(nums)+1))\\n        return m-n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        # nums.sort()\\n        # for i,x in enumerate(nums):\\n        #     if i != x:\\n        #         return i\\n        # return len(nums)\\n        n=sum(nums)\\n        m=sum(range(0,len(nums)+1))\\n        return m-n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729886,
                "title": "simple-math-solution-c-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        int ans = n*(n+1)/2 - sum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        int ans = n*(n+1)/2 - sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416441,
                "title": "3-line-java-code-easy-understandable-code",
                "content": "# Intuition\\n1) Simple mathematics approach can work here.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) First calculate sum of all numbers from 0 to n. To calculate this we will use a formula that can find sum of all natural numbers from 1 to N. the formula is call \"Sum of all natural numbers from 1 to N $$=\\\\frac{n(n\\\\dotplus{}1)}2$$\\n2) Calculate sum of all numbers in array. Using stream it can be done in single line.\\n3) substract `actualSum` to `arraySum`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int actualSum = n * (n + 1) / 2;\\n        int arraySum = IntStream.of(nums).sum();\\n        return actualSum - arraySum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Data Stream"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int actualSum = n * (n + 1) / 2;\\n        int arraySum = IntStream.of(nums).sum();\\n        return actualSum - arraySum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275571,
                "title": "without-binarysearch-in-java-well-explained-code",
                "content": "# Approach\\nThe problem statement asks you to find the missing number in an array of size n, which contains all numbers from 0 to n except for one.\\n\\nThe approach taken in this solution is to first sort the array using Arrays.sort(nums). This is done so that we can then iterate through the sorted array and compare each element with its index.\\n\\nIf we find an element whose value is not equal to its index, we know that the missing number is between the previous element and the current element. For example, if we have the array [0,1,3], when we reach index 2 we know that the missing number is 2 because the value at index 2 (3) is greater than the index itself.\\n\\nSo, in the loop, if the current index \\'i\\' is not equal to the current element \\'nums[i]\\' , we return the value of \\'nums[i]-1\\' , which is the missing number.\\n\\nIf we reach the end of the loop without finding a missing number, we know that the missing number is the last number in the sequence, so we return  \\'nums[n-1]+1\\' .\\n\\n\\n# Complexity\\nOverall, the time complexity of this solution is O(n log n) due to the sorting, but the space complexity is O(1) because we are only using constant extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<n;i++){\\n            if(i!=nums[i]){\\n                return nums[i]-1;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/92055b35-2502-4ee9-aac5-47ef0435d387_1678351516.69451.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<n;i++){\\n            if(i!=nums[i]){\\n                return nums[i]-1;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226491,
                "title": "java-6-lines-beats-100-o-n-o-1-time-space-complexity",
                "content": "# Intuition\\nThe missing number can be found by calculating the difference between the sum of the range and the sum of the array.\\n\\n# Approach\\nreturn the difference between the sum of range (inclusive) and sum of nums.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int rangeSum = 0, numsSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            numsSum += nums[i];\\n            rangeSum += i;\\n        }\\n        return (rangeSum + nums.length) - numsSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int rangeSum = 0, numsSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            numsSum += nums[i];\\n            rangeSum += i;\\n        }\\n        return (rangeSum + nums.length) - numsSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095127,
                "title": "c-solution-using-missing-number-require-sum-estimated-sum",
                "content": "# Intuition\\nlet sum of 3 number and missing number is 1\\n(require Sum-estimated sum)=Missing number\\n6-(0+2+3)=1\\n\\n\\n# Approach\\nMissing number=(require Sum-estimated sum)\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n{let last number is missing so for loop will reun till 0 to n-1 so time complexity is o(n) }\\n\\n\\nspace complexity\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int reqsum=(n*(n+1))/2;\\n        int astsum=0;\\n\\n        for(int i=0; i<n;i++)\\n        astsum=astsum+nums[i];\\n\\n    return reqsum-astsum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int reqsum=(n*(n+1))/2;\\n        int astsum=0;\\n\\n        for(int i=0; i<n;i++)\\n        astsum=astsum+nums[i];\\n\\n    return reqsum-astsum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814229,
                "title": "java-easy-bit-manipulation",
                "content": "Isolate the number that is not in the array, and it participates in the iteration because i++ and in this case, there will be a pair for each number, and there will be no pair for the one missing in the array such a number will be missing in the array\\n\\n\\nXOR of [0,n] is 0^1^2^3^4^5^6^7\\nXOR of input is 0^1^2^3^4^5^7\\n\\nans = (0^1^2^3^4^5^7) ^(0^1^2^3^4^5^6^7) = 0^0^1^1^2^2^ 3^3^4^4^5^5^6^7^7 = 6\\n\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int ans = nums.length;\\n        for (int i = 0; i < nums.length; i++) {\\n            // XOR of [0,n] is 0^1^2^3^4^5^6^7\\n            // XOR of input is 0^1^2^3^4^5^7\\n            // ans = (0^1^2^3^4^5^7) ^(0^1^2^3^4^5^6^7) = 0^0^1^1^2^2^3^3^4^4^5^5^6^7^7 = 6\\n            // \\u0432\\u044B\\u0447\\u043B\\u0435\\u043D\\u044F\\u0435\\u043C \\u0442\\u043E \\u0447\\u0438\\u0441\\u043B\\u043E, \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u043D\\u0435\\u0442 \\u0432 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435, \\u0430 \\u0432 \\u0438\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u0438 \\u043E\\u043D\\u043E \\u0443\\u0447\\u0430\\u0432\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442 \\u0442.\\u043A. i++\\n            // \\u0438 \\u0432 \\u0442\\u0430\\u043A\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u0430\\u0436\\u0434\\u043E\\u043C\\u0443 \\u0447\\u0438\\u0441\\u043B\\u0443 \\u043D\\u0430\\u0439\\u0434\\u0435\\u0442\\u0441\\u044F \\u043F\\u0430\\u0440\\u0430, \\u0430 \\u043E\\u0442\\u0441\\u0443\\u0442\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0435\\u043C\\u0443 \\u0432 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435 \\u043F\\u0430\\u0440\\u0430 \\u043D\\u0435 \\u043D\\u0430\\u0439\\u0434\\u0435\\u0442\\u0441\\u044F\\n            // \\u0442\\u0430\\u043A\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u0438 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0442\\u0441\\u0443\\u0442\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0438\\u043C \\u0432 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435\\n            ans = ans ^ i ^ nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int ans = nums.length;\\n        for (int i = 0; i < nums.length; i++) {\\n            // XOR of [0,n] is 0^1^2^3^4^5^6^7\\n            // XOR of input is 0^1^2^3^4^5^7\\n            // ans = (0^1^2^3^4^5^7) ^(0^1^2^3^4^5^6^7) = 0^0^1^1^2^2^3^3^4^4^5^5^6^7^7 = 6\\n            // \\u0432\\u044B\\u0447\\u043B\\u0435\\u043D\\u044F\\u0435\\u043C \\u0442\\u043E \\u0447\\u0438\\u0441\\u043B\\u043E, \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u043D\\u0435\\u0442 \\u0432 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435, \\u0430 \\u0432 \\u0438\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u0438 \\u043E\\u043D\\u043E \\u0443\\u0447\\u0430\\u0432\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442 \\u0442.\\u043A. i++\\n            // \\u0438 \\u0432 \\u0442\\u0430\\u043A\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u0430\\u0436\\u0434\\u043E\\u043C\\u0443 \\u0447\\u0438\\u0441\\u043B\\u0443 \\u043D\\u0430\\u0439\\u0434\\u0435\\u0442\\u0441\\u044F \\u043F\\u0430\\u0440\\u0430, \\u0430 \\u043E\\u0442\\u0441\\u0443\\u0442\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0435\\u043C\\u0443 \\u0432 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435 \\u043F\\u0430\\u0440\\u0430 \\u043D\\u0435 \\u043D\\u0430\\u0439\\u0434\\u0435\\u0442\\u0441\\u044F\\n            // \\u0442\\u0430\\u043A\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u0438 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0442\\u0441\\u0443\\u0442\\u0441\\u0442\\u0432\\u0443\\u044E\\u0449\\u0438\\u043C \\u0432 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435\\n            ans = ans ^ i ^ nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645174,
                "title": "easy-understanding-c",
                "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=(n*(n+1))/2;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        int ans=x-sum;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=(n*(n+1))/2;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2526840,
                "title": "java-solution-0ms-100-faster",
                "content": "\\t   int n = nums.length;\\n        int expectedtotal = (n*(n+1))/2;\\n        \\n        int total = 0;\\n        for(int num:nums){\\n            total+=num;\\n        }\\n        \\n        return expectedtotal - total;",
                "solutionTags": [],
                "code": "\\t   int n = nums.length;\\n        int expectedtotal = (n*(n+1))/2;\\n        \\n        int total = 0;\\n        for(int num:nums){\\n            total+=num;\\n        }\\n        \\n        return expectedtotal - total;",
                "codeTag": "Unknown"
            },
            {
                "id": 1752235,
                "title": "python-three-approaches-math-hash-table-bit-operations",
                "content": "I show three passing methods in the below solution\\n\\nMethod 1 uses the sum of the expected range of numbers in the array versus the actual sum of the input array.\\n```\\n[3,0,1] expects numbers in the range [0,3] = [0,1,2,3] \\nThe sum of the expected array is 6\\nThe sum of the input array is 4 \\nThe missing element is 6 - 4 = 2\\n```\\n\\nMethod 2 uses the bit operations clearly explained by[ buz_er here](https://leetcode.com/problems/missing-number/discuss/1445140/Python-XOR-Explanation)\\n```\\n[3,0,1] expects numbers in the range [0,3] = [0,1,2,3] \\nThe elements of the expected array [0,1,2,3]  \\nWhile the elements of the input array are [0,1,3] \\nThe XOR bit operator has a cool property -> x ^ x = 0\\nSo the concept is to use the elements in the input array to cancel out the elements in the index array  \\n```\\nWe keep XOR-ing the elements and indexes into one combined value that eventually sums up to the missing element from the index array\\n [~~0,1~~,2,~~3~~] ^ [~~0,1,3~~] \\n Leaving [2] -> missing element! :O  \\n  \\n \\n Method 3 is the pythonic hack to do this in one line without the bit operation\\n ```\\n range(len(nums)+1) -> [0,1,2,3]  --- (1)\\n set((1)) -> {0,1,2,3}                      --- (2) to get it into a subtract-able form \\n \\n set(nums) -> {0,1,3}                    --- (3)\\n \\n list( (2) - (3) ) -> [2]                     --- (4)\\n \\n return zeroth element of final result (4) \\n ```\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        \\n        #Method 3 - Hash Table\\n        return list(set(range(len(nums)+1)) - set(nums))[0]        \\n    \\n        \\n        #Method 2 - Bit Manipulation - https://leetcode.com/problems/missing-number/discuss/1445140/Python-XOR-Explanation\\n        numxor = 0\\n        for i,el in enumerate(nums):\\n            numxor ^= (i ^ el)\\n        return numxor ^ (i+1)\\n        \\n        #Method 1 - Math O(n) time O(1) space\\n        l = len(nums)\\n        # print(l)\\n        rsum = sum(range(l+1))\\n        # print(rsum)\\n        return rsum - sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n[3,0,1] expects numbers in the range [0,3] = [0,1,2,3] \\nThe sum of the expected array is 6\\nThe sum of the input array is 4 \\nThe missing element is 6 - 4 = 2\\n```\n```\\n[3,0,1] expects numbers in the range [0,3] = [0,1,2,3] \\nThe elements of the expected array [0,1,2,3]  \\nWhile the elements of the input array are [0,1,3] \\nThe XOR bit operator has a cool property -> x ^ x = 0\\nSo the concept is to use the elements in the input array to cancel out the elements in the index array  \\n```\n```\\n range(len(nums)+1) -> [0,1,2,3]  --- (1)\\n set((1)) -> {0,1,2,3}                      --- (2) to get it into a subtract-able form \\n \\n set(nums) -> {0,1,3}                    --- (3)\\n \\n list( (2) - (3) ) -> [2]                     --- (4)\\n \\n return zeroth element of final result (4) \\n ```\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        \\n        #Method 3 - Hash Table\\n        return list(set(range(len(nums)+1)) - set(nums))[0]        \\n    \\n        \\n        #Method 2 - Bit Manipulation - https://leetcode.com/problems/missing-number/discuss/1445140/Python-XOR-Explanation\\n        numxor = 0\\n        for i,el in enumerate(nums):\\n            numxor ^= (i ^ el)\\n        return numxor ^ (i+1)\\n        \\n        #Method 1 - Math O(n) time O(1) space\\n        l = len(nums)\\n        # print(l)\\n        rsum = sum(range(l+1))\\n        # print(rsum)\\n        return rsum - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448069,
                "title": "java-runtime-100-o-n-space-o-1-simple",
                "content": "Simple java solution.\\n\\n1. Calculate sum of first n numbers\\n2. Calculate sum of numbers in the array\\n3. Subtract first sum with second sum\\n\\n```\\npublic int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = (n * (n + 1)) / 2;\\n\\n        int calcSum = 0;\\n        for (int num : nums) {\\n            calcSum += num;\\n        }\\n\\n        return sum - calcSum;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = (n * (n + 1)) / 2;\\n\\n        int calcSum = 0;\\n        for (int num : nums) {\\n            calcSum += num;\\n        }\\n\\n        return sum - calcSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407899,
                "title": "java-easy-3line-solution-faster-than-100-t-o-n-s-o-1",
                "content": "We know the total sum of 0+1+2+3+4+.....+n = n*(n+1)/2, so here we will sum up all the array\\nelements and subtract it from the above n element sum to get the missing element.\\nUpvote if you find it helpful.\\n\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i=0 ; i<n ; i++)\\n            sum += nums[i];\\n        return ((n*(n+1))/2-sum);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i=0 ; i<n ; i++)\\n            sum += nums[i];\\n        return ((n*(n+1))/2-sum);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1091175,
                "title": "python-math-faster-than-96-69-o-1-space-o-n-time",
                "content": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        return l * (1 + l) // 2 - sum(nums)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        return l * (1 + l) // 2 - sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1033419,
                "title": "easy-python-solution-faster-than-90-sort",
                "content": "An easy solution using sort() function\\n---------------------------\\n\\nSort the nums then a brute force will do the work, and don\\'t forget that the index of the current element must be equal to the this element (exp: i = 0, nums[0] == 0) if not return i (exp : i = 2 nums[2] == 3 so missing number = i)\\n\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if i != nums[i]:\\n                return i\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if i != nums[i]:\\n                return i\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013913,
                "title": "kotlin-one-liner-with-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    fun missingNumber(nums: IntArray) =\\n        nums.size * (nums.size + 1) / 2 - nums.sum() \\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun missingNumber(nums: IntArray) =\\n        nums.size * (nums.size + 1) / 2 - nums.sum() \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836143,
                "title": "c-solution-using-ap-concepts",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        \\n        int sum_a;\\n        int n= nums.size();\\n        sum_a = n*(n+1)/2;\\n        \\n        int sum = 0;\\n        \\n        for(int i=0;i<nums.size();++i){\\n            sum+=nums[i];\\n        }\\n        \\n        return sum_a-sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        \\n        int sum_a;\\n        int n= nums.size();\\n        sum_a = n*(n+1)/2;\\n        \\n        int sum = 0;\\n        \\n        for(int i=0;i<nums.size();++i){\\n            sum+=nums[i];\\n        }\\n        \\n        return sum_a-sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 69874,
                "title": "c-short-solution-away-from-overflow-easy-to-understand",
                "content": "```\\nint missingNumber(vector<int>& nums) {\\n        int find = 0;\\n        for(int i=0; i<nums.size();i++)\\n            find += i-nums[i];\\n        return find+nums.size();\\n    }\\n```\\nEvery time plus i minus nums[i] to avoid overflow if the size of nums is large",
                "solutionTags": [],
                "code": "```\\nint missingNumber(vector<int>& nums) {\\n        int find = 0;\\n        for(int i=0; i<nums.size();i++)\\n            find += i-nums[i];\\n        return find+nums.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 70017,
                "title": "easy-to-follow-python-solution",
                "content": " def missingNumber(self, nums):\\n\\n        a=[]\\n        for k in range(0,len(nums)+1):\\n            a.append(k)\\n        return sum(a)-sum(nums)",
                "solutionTags": [],
                "code": " def missingNumber(self, nums):\\n\\n        a=[]\\n        for k in range(0,len(nums)+1):\\n            a.append(k)\\n        return sum(a)-sum(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 69800,
                "title": "simple-python-solution-2-lines",
                "content": "\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        return (n*(n+1)/2) - sum(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        return (n*(n+1)/2) - sum(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3865851,
                "title": "cycle-sort-runtime-10-ms-beats-98-17-very-very-detailed-explanation-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved using cycle sort. The intuition behind using cycle sort is the following statement: \\n> an array `nums` containing `n distinct numbers` in the range `[0, n]`\\n\\nWhenever we come across a problem where the statement involves an **array of size n** containing numbers upto n, **cycle sort** might be *applicable*.\\n\\n![image](https://is1-ssl.mzstatic.com/image/thumb/Purple123/v4/5d/7c/ef/5d7cef1b-1f29-d59c-f272-fad2e2521665/source/512x512bb.jpg)\\n\\n# Cycle Sort\\nCycle sort is a sorting technique that works when an array contains `n distinct numbers` in the range `[0, n]`. \\n\\nConsider the following array of `size 5` containing integers from `[0, 4]`:\\n\\n$$\\\\begin{array}{}\\n[3&0&4&2&1]\\\\\\\\\\\\\\\\\\n0&1&2&3&4\\n\\\\end{array}\\n$$\\n\\nThis is how the array will look like after sorting.\\n\\n$$\\\\begin{array}{}\\n[0&1&2&3&4]\\\\\\\\\\\\\\\\\\n0&1&2&3&4\\n\\\\end{array}\\n$$\\n\\nCarefully observe the relationship between elements and indices in the sorted array. The element at the **0th index** is **equal to the index itself**. The element at the **1st index** is **equal to the index itself.** Therefore, we can conclude that in the sorted array, the **array index** will always be equal to the element itself!\\n\\nIf we represent this observation in the form of an equation, we will get:\\n\\n$$nums[i]\\\\>=\\\\>i\\\\\\\\\\n=> i\\\\> = \\\\>nums[i]\\n$$\\n\\nSubstituting the value of i, we get:\\n\\n$$nums[i]\\\\> =\\\\> nums[nums[i]]$$\\u2705\\u2705\\n\\nWe have obtained our required equation.\\nFollowing this equation, we now have to swap every element.\\n```\\nwhile(nums[i] != i)\\n{\\n    swap(nums[i], nums[nums[i]]);\\n}\\n```\\nThis code block will send `nums[i]` to its **correct position** provided it was not **already** present in its correct position!\\n\\nLet\\'s use this code block on our example array:\\n\\n**Initial state**\\n\\n$$\\\\begin{array}{}\\n[3&0&4&2&1]\\\\\\\\\\\\\\\\\\n0&1&2&3&4\\n\\\\end{array}\\n$$\\n\\nnums[i] = 3, nums[nums[i]] = 2. Swap these elements.\\n\\n**First Iteration**\\n\\n$$\\\\begin{array}{}\\n[2&0&4&3&1]\\\\\\\\\\\\\\\\\\n0&1&2&3&4\\n\\\\end{array}\\n$$\\n\\nNotice that 3 is now in its **correct position.**\\nnums[i] = 2, nums[nums[i]] = 4. Swap these elements.\\n\\n**Second Iteration**\\n\\n$$\\\\begin{array}{}\\n[4&0&2&3&1]\\\\\\\\\\\\\\\\\\n0&1&2&3&4\\n\\\\end{array}\\n$$\\n\\nNotice that 2 is now in its **correct position.**\\nnums[i] = 4, nums[nums[i]] = 1. Swap these elements.\\n\\n**Third Iteration**\\n\\n$$\\\\begin{array}{}\\n[1&0&2&3&4]\\\\\\\\\\\\\\\\\\n0&1&2&3&4\\n\\\\end{array}\\n$$\\n\\nNotice that 4 is now in its **correct position.**\\nnums[i] = 1, nums[nums[i]] = 0. Swap these elements.\\n\\n**Fourth Iteration**\\n\\n$$\\\\begin{array}{}\\n[0&1&2&3&4]\\\\\\\\\\\\\\\\\\n0&1&2&3&4\\n\\\\end{array}\\n$$\\n\\nNow all the elements are in their correct position!\\uD83E\\uDD73\\uD83E\\uDD73\\n*Although this is a simple example, the working will remain same for more complicated examples. There can be other variations to this problem. It is essential to observe the relationship between elements and their indices in the sorted array to develop the correct equation.*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe apply cycle sort on this array. But we have to be careful of the following edge case:\\n\\nIf **nums[i] == n**, do not swap nums[i] as **nums[nums[i]] will now go out of bounds of the array**. After sorting, if there is any index for which the **array element is not equal** to the **index itself**, return the index as the missing element. \\n\\nIf we do not find any such index, return **n as the missing element.**\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(nums[i] != i && nums[i] < n)\\n            {\\n                swap(nums[i], nums[nums[i]]);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] != i)\\n            {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/6f69b1bc-2a39-44ae-ad40-5b9429c73150_1691218877.360817.png)\\n\\n\\nHere are some problems where we can use cycle sort:\\n\\n- [https://leetcode.com/problems/find-the-duplicate-number/description/]() $$\\\\textcolor{gold}{\\\\textbf{Medium}}$$\\n- [https://leetcode.com/problems/first-missing-positive/]() $$\\\\textcolor{red}{\\\\textbf{Hard}}$$",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nwhile(nums[i] != i)\\n{\\n    swap(nums[i], nums[nums[i]]);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            while(nums[i] != i && nums[i] < n)\\n            {\\n                swap(nums[i], nums[nums[i]]);\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] != i)\\n            {\\n                return i;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778121,
                "title": "god-s-message-drunk-code",
                "content": "# Intuition\\nI coded this a few months back. I just remember being drunk and doing leetcode problem and then discussing the prolem with god.\\n\\nI can\\'t understand what I have done. Please help me understand this piece of code.\\n\\nHere is the submission : https://leetcode.com/problems/missing-number/submissions/889426627/\\n\\n## What I Remember\\nI can recall god telling me that for a number `x` where `x` of the form `4n` where n is a non-negative integer, the xor of the four consecutive numbers is zero i.e. -\\n$$(4n)$$ ^ $$(4n +1)$$ ^ $$(4n+2)$$ ^ $$(4n+3) = 0$$\\n\\nI somehow used that property, but don\\'t know how.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ with a single unit of \"work\" being done on each element array.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int x = 0;\\n        int n = nums.size();\\n        short int p = n % 4;\\n        for(auto i: nums) x ^= i;\\n        if (p == 0)\\n            return x^n;\\n        if (p == 1)\\n            return x^1;\\n        if (p == 2)\\n            return x^(n + 1);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int x = 0;\\n        int n = nums.size();\\n        short int p = n % 4;\\n        for(auto i: nums) x ^= i;\\n        if (p == 0)\\n            return x^n;\\n        if (p == 1)\\n            return x^1;\\n        if (p == 2)\\n            return x^(n + 1);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657674,
                "title": "c-2-easy-solutions-with-explanation-using-o-n-time-complexity-and-o-1-space-complexity",
                "content": "**Please DO Upvote if found usefull!!!**\\n\\nAs the numbers are from *0* to *N* only, we can make a flag to the index of found number, i.e. if $$arr[i]=k$$ & $$(0<=k<n)$$, then we just mark index **k**, which means that we have the value **k** present in the array.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int k = 1e4+7;\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            int temp = nums[i]%k;\\n            if(temp<n)nums[temp] += k;\\n        }\\n\\n        int ans = n;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]<k){\\n                ans=i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# Method 2\\n\\n1. Find sum of first **N natural numbers** \\n2. Find Sum of all the numbers of arrays\\n3. Now **Subtract** the sum of **step1 and step2** \\n\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = (n*(n+1))/2;\\n\\n        for(int i = 0 ; i < n ;i++){\\n            sum-=nums[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int k = 1e4+7;\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++){\\n            int temp = nums[i]%k;\\n            if(temp<n)nums[temp] += k;\\n        }\\n\\n        int ans = n;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]<k){\\n                ans=i;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = (n*(n+1))/2;\\n\\n        for(int i = 0 ; i < n ;i++){\\n            sum-=nums[i];\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586273,
                "title": "my-easy-and-accepted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res += ((i + 1) - nums[i]);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res += ((i + 1) - nums[i]);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567457,
                "title": "best-o-n-solution",
                "content": "# Approach\\nUsing Maths\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int mySum = 0;\\n        for (int i = 0; i < n; i++)\\n            mySum += nums[i];\\n        int sum = n * (n + 1) / 2;\\n        int ans = sum - mySum;\\n\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int mySum = 0;\\n        for (int i = 0; i < n; i++)\\n            mySum += nums[i];\\n        int sum = n * (n + 1) / 2;\\n        int ans = sum - mySum;\\n\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283617,
                "title": "basic-math-solution",
                "content": "# Approach\\nIf an array contains n distinct numbers in the range 0-n, we can say that **the sum of array must be equal to the sum of n numbers**.\\n\\nBut here since there is a number missing in the given array,the sum of the elements in the array equals to the (sum of n numbers-missing number)\\n\\nWith that simple math,we can find the missing number by subtracting of sum of arrayelements from the sum of n numbers.\\n**i.e.,Missing num=sum of n numbers - sum of array elements**\\n\\nBy using the basic math formula, **n(n+1)/2** for calculating the sum of n natural numbers here we have the solution as follows.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nint missingNumber(int* nums, int numsSize)\\n{\\n   int n=numsSize;\\n   int sum=0;\\n   for(int i=0;i<numsSize;i++)\\n   {\\n       sum=sum+nums[i];\\n   }\\n   int res=(n*(n+1)/2)-sum ;\\n   return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint missingNumber(int* nums, int numsSize)\\n{\\n   int n=numsSize;\\n   int sum=0;\\n   for(int i=0;i<numsSize;i++)\\n   {\\n       sum=sum+nums[i];\\n   }\\n   int res=(n*(n+1)/2)-sum ;\\n   return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169297,
                "title": "python-beats-95-time-simple-5-line-soln",
                "content": "# Intuition\\nyou have to find the missing number, so lets just compare a list of numbers 1 to n with given list. The missing number is our answer\\n\\n# Approach\\nGet length of the list (you can also run while loop if you want to make it more efficient). Convert list into set so that the search operation is easy. We can do this bcz we dont have repeat elements. Now just run a loop from 1 to length of list and if i is not present in our set, we will break the loop and return i which is our missing element.\\n\\n# Complexity\\n- Time complexity:\\nworst case = O(n), average cases < O(n)\\n\\n- Space complexity:\\nconstant\\n\\n# Code\\n```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = set(nums)\\n        for i in range(1,len(nums)+1):\\n            if i not in nums:\\n                return i\\n                \\n        return 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = set(nums)\\n        for i in range(1,len(nums)+1):\\n            if i not in nums:\\n                return i\\n                \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954085,
                "title": "easy-way-to-find-missing-number",
                "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n    int n=nums.length;\\n    int totalsum=n*(n+1)/2;// sum of 1st n numbers \\n        for(int i:nums) // for each loop in java\\n        totalsum=totalsum-i;\\n        return totalsum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int missingNumber(int[] nums) {\\n    int n=nums.length;\\n    int totalsum=n*(n+1)/2;// sum of 1st n numbers \\n        for(int i:nums) // for each loop in java\\n        totalsum=totalsum-i;\\n        return totalsum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2736716,
                "title": "3-approaches-easy-bit-manipulation",
                "content": "# Intuition\\nGiven input contains [0,n] and 1 number is missing, it means it is of size n (including 0). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### Method 1\\nWe find sum of input i.e [0,n] - 1 missing number. \\nwe calculate the sum from 1 to n that includes the missing number too, by formula (n* (n+1))/2.\\n#### Method 2\\nWe know `(a XOR a)` is zero. So what we do is we find the XOR of inputs and XOR of [0,n] including missing\\n```\\nsay 0,1,2,3,4,5,7 is input,\\nthen XOR of input is 0^1^2^3^4^5^7\\nand XOR of [0,n] is 0^1^2^3^4^5^6^7\\nnow ans = (XOR of inpur) XOR (XOR of [0,n]) which gives the missing number \\n\\nans = (0^1^2^3^4^5^7) ^(0^1^2^3^4^5^6^7)\\n    = 0^0^1^1^2^2^3^3^4^4^5^5^6^7^\\n    = 6 \\n    which is the missing number\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nMethod 1 - `O(N)` for getting the sum of input\\nMethod 2 - `O(N)` for calculating XOR\\n\\n- Space complexity:\\nIn Both methods no extra space is used so Space Complexity is `O(1)`\\n\\n# Code\\n\\n#### Method 1\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int s = 0;\\n        int n = nums.size();\\n        int act = (n*(n+1))/2;\\n        for(int i:nums) s+= i;\\n        return act - s;\\n    }\\n};\\n```\\n\\n#### Method 2\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans = nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            ans = ans^ i^ nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWe can solve this by one more way, Sort and traverse through array check if nums[i+1] == nums[i]  if not nums[i]+1 is the missing number.Edge Case would be did it start with zero if not missing is zero and and we traverse array but didnt find any missing value then ans would be nums.size(). As input is 0 to n-1, missing is n\\nTC - O(NlogN) sorting \\nSC - O(1)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort",
                    "Bit Manipulation"
                ],
                "code": "```\\nsay 0,1,2,3,4,5,7 is input,\\nthen XOR of input is 0^1^2^3^4^5^7\\nand XOR of [0,n] is 0^1^2^3^4^5^6^7\\nnow ans = (XOR of inpur) XOR (XOR of [0,n]) which gives the missing number \\n\\nans = (0^1^2^3^4^5^7) ^(0^1^2^3^4^5^6^7)\\n    = 0^0^1^1^2^2^3^3^4^4^5^5^6^7^\\n    = 6 \\n    which is the missing number\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int s = 0;\\n        int n = nums.size();\\n        int act = (n*(n+1))/2;\\n        for(int i:nums) s+= i;\\n        return act - s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans = nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            ans = ans^ i^ nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623030,
                "title": "linear-complexity-in-python",
                "content": "Substracting the sum of `1..n` from the total sum of the elements in the array will give you the missing number. For getting the range sum, Gauss method can be used as below:\\n\\n![image](https://assets.leetcode.com/users/images/5b1366e5-2f32-4cc9-94b3-c2e6f90667fc_1664113118.0307124.png)\\n\\nFind the code below:\\n\\n```\\n    def missingNumber(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        \\n        natural_sum = (l * (l + 1)) // 2\\n        list_sum = sum(nums)\\n        \\n        return natural_sum - list_sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def missingNumber(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        \\n        natural_sum = (l * (l + 1)) // 2\\n        list_sum = sum(nums)\\n        \\n        return natural_sum - list_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2578422,
                "title": "map-o-n-solution-fun-idea",
                "content": "`Time complexity: O(N)`\\nThis solution is extremely simple, we\\'ll just make a map that has inside it every number from 0 to N, and we\\'ll delete every element in the map that\\'s already in the nums array, which will leave us with only the missing element.\\n\\n```\\nvar missingNumber = function(nums) {\\nlet map = new Map()\\n\\nfor (let i = 0; i < nums.length + 1; i++){\\n    map.set(i, 1)    \\n}\\n\\nfor(let i = 0; i < nums.length; i++){\\n    map.delete(nums[i])\\n}\\n\\nreturn map.keys().next().value\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar missingNumber = function(nums) {\\nlet map = new Map()\\n\\nfor (let i = 0; i < nums.length + 1; i++){\\n    map.set(i, 1)    \\n}\\n\\nfor(let i = 0; i < nums.length; i++){\\n    map.delete(nums[i])\\n}\\n\\nreturn map.keys().next().value\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493539,
                "title": "c-solution-xor-sum-binary-search",
                "content": "Hi , guys . This is a pretty simple problem. I am sure everybody would have thought of atleast 1 of the following approaches. Just for your reference , I am noting down all of them with explainations. Just give them a read . \\n\\n#### PROBLEM EXPLAINATION : \\nThe problem simply states that there is an array of \\'n\\' numbers in the range [0,n] . All the numbers in the ***array are distinct*** which means, that out of \"n+1\" numbers in [0,n] , the array consists of \\'n\\' numbers.\\nWe have to find that missing number.\\n\\n#### XOR APPROACH : \\nAll of us are well aware of this property of XOR operator : \\na^a^b=b , as (a^a=0 and 0^b=b)\\nNow we are going to use this to our advantage. **How??**\\n\\n\\tIf we apply the XOR of all the array elements and then apply the XOR of all numbers from [0,n] \\n\\ton the previous result. All the numbers will be XOR-ed twice except for the missing number.\\n\\n**NUMBERS FROM THE ARRAY :** 0 ^ 1 ^ 2 ^ 3 .......^ (X+1) ^ (X+2) ^ .....n =y\\n**NUMBERS FROM THE RANGE :** 0 ^ 1 ^ 2 ^ 3 ....X ^ (X+1) ^ (X+2) ^ ...n ^ y = y\\n\\nIf X is the missing value , you can see that X is the only value which will be XOR-ed once , rest of them will be XOR-ed twice and hence will result in 0.\\n\\n```\\nint missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n;\\n        for(int i=0;i<n;i++)\\n         x^=nums[i]^i;\\n        return x;\\n    }\\n```\\n\\n**TC : O(N)    SC : O(1)**\\n\\n\\n#### SUM APPROACH : \\nThis approach is even simpler than the previous one. \\nSince we are given \\'n\\' elements out of known \\'n+1\\' elements. We can simply find out the unknown element by finding the sum of \\'n+1\\' elements and subtracting the sum of given \\'n\\' elements.\\n\\n***Missing Number = Sum of (n+1) elements - Sum of given (n) elements***\\n\\n**Sum of (n+1) elements :** Well it is pretty simple to evaluate. Since we know we have to add all numbers from [0,n]. \\n***Sum of (n+1) elements = n(n+1)/2***\\n\\n**Sum of given (n) elements :** Well simply add all the elements of the array given to you.\\n\\n```\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0,n=nums.size();\\n        for(int i:nums)\\n            sum+=i;\\n        return (n*(n+1))/2 - sum;\\n    }\\n```\\n\\n**TC : O(N)    SC : O(1)**\\n\\n\\n#### BINARY SEARCH APPROACH : \\nThis approach is not something that comes immediately to mind. So don\\'t worry if you couldn\\'t get it in the first go. Neither could I. \\n\\nThe idea here is to realise the fact that when I sort the given array . The index and the value at that index would be same until the missing element. \\nIf the missing element is \\'x\\' , then for all indices >=x , nums[index]>index. \\n\\nMathematically , if \\'x\\' is the missing element then , \\n1) 0<=i<x , nums[i]=i.\\n2) i>=x , nums[i]>i.\\n\\nWe are going to make use of this fact.\\nApply binary search on the array. ( low=0,high=n-1,mid,ans=n (initial value) )\\n\\n1) Find mid.\\n2) If nums[mid]>mid . We realise that an element is missing . It might be the current index or an index before it. So we update ans=mid (this is the \\'ans\\' so far) and high=mid-1 (the  actual \\'ans\\' might lie before this index).\\n3) Else update low=mid+1 (we do so because we realise that nums[mid]==mid , which means that till this index , no element is missing and hence our search space should shorten to [mid+1,high].\\n\\n```\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int low=0,high=n-1,mid,ans=n;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(nums[mid]>mid)\\n                ans=mid,high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**TC : O(logN)    SC : O(1)**\\n\\n***HOPE YOU GUYS ENJOYED READING THIS POST !!***\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nint missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=n;\\n        for(int i=0;i<n;i++)\\n         x^=nums[i]^i;\\n        return x;\\n    }\\n```\n```\\n    int missingNumber(vector<int>& nums) {\\n        int sum=0,n=nums.size();\\n        for(int i:nums)\\n            sum+=i;\\n        return (n*(n+1))/2 - sum;\\n    }\\n```\n```\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int low=0,high=n-1,mid,ans=n;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(nums[mid]>mid)\\n                ans=mid,high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491052,
                "title": "python-easy-solution",
                "content": "```\\ndef missingNumber(self, nums: List[int]) -> int: # nums = [9,6,4,2,3,5,7,0,1]\\n        maxx = max(nums) # 9\\n        full_range = set([i for i in range(maxx+1)]) # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\\n        nums_set = set(nums) # {0, 1, 2, 3, 4, 5, 6, 7, 9}\\n        diff = full_range - nums_set # {8}\\n        if diff:\\n            return diff.pop() # 8\\n        return maxx+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef missingNumber(self, nums: List[int]) -> int: # nums = [9,6,4,2,3,5,7,0,1]\\n        maxx = max(nums) # 9\\n        full_range = set([i for i in range(maxx+1)]) # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\\n        nums_set = set(nums) # {0, 1, 2, 3, 4, 5, 6, 7, 9}\\n        diff = full_range - nums_set # {8}\\n        if diff:\\n            return diff.pop() # 8\\n        return maxx+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2376649,
                "title": "c-98-54",
                "content": "```\\nint missingNumber(int* nums, int numsSize){\\n    int ans = 0;\\n    for (int i=0; i < numsSize; i++){\\n        ans += i + 1 - nums[i];\\n    }\\n    return ans;\\n\\n}\\n```\\n**Please UPVOTE if you LIKE !!!**\\n![image](https://assets.leetcode.com/users/images/c2ac3089-23bf-4c32-a523-bfc3050a3bd0_1659586328.3059325.png)\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint missingNumber(int* nums, int numsSize){\\n    int ans = 0;\\n    for (int i=0; i < numsSize; i++){\\n        ans += i + 1 - nums[i];\\n    }\\n    return ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152838,
                "title": "python-solution-beats-98-75-in-runtime-o-n-o-1-space",
                "content": "This solution relies on the simple idea that the sum of numbers in a positive range is going to be equal to n(n+1) / 2. \\n\\nThis trick was (apocryphally) used by Gauss to stump his teacher: https://www.nctm.org/Publications/TCM-blog/Blog/The-Story-of-Gauss/\\n\\nAs we know what the sum SHOULD be, we can simply subtract the existing sum to find the result: \\n\\n```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return (len(nums)  * (len(nums) +1)) / 2 - sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        return (len(nums)  * (len(nums) +1)) / 2 - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087087,
                "title": "python-detailed-explanation-bit-manipulation-xor",
                "content": "# Intuition\\nSince we want to solve the problem in **O(1) space complexity** we know it involves some technique.\\nWhen you see missing number in an array (when number are sequential) or duplicate removal you should try to experiment with XOR manipulation. To have that intuition you just need to practice.\\n\\n# Background\\nThere are 2 important properties that will help us:\\n1. If `0` is applied to any number with `XOR` it returns that number => `x ^ 0 = x`\\n2. If the same number is applied with `XOR` operator on itself then the result is `0` => `x ^ x = 0`\\n3. XOR is commutative. i.e. `a ^ b = b ^ a`\\n\\n# Algorithm explanation\\nWe can iterate over the items and apply XOR on all the elements together. This will not give us much (YET) since there are no duplicates.\\nBut if we also iterate on all the possible values from `0..N` applying the XOR operator then the duplicate values will remove themselves and we will be left with only the missing number.\\nExample: `a ^ b ^ c ^ b ^ a => a ^ a ^ b ^ b ^ c => 0 ^ 0 ^ c => c`\\n\\n# Code\\n```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        missing_number = 0\\n        \\n        for i in nums:\\n            missing_number ^= i\\n        \\n        for i in range(n + 1):\\n            missing_number ^= i\\n        \\n        return missing_number\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        missing_number = 0\\n        \\n        for i in nums:\\n            missing_number ^= i\\n        \\n        for i in range(n + 1):\\n            missing_number ^= i\\n        \\n        return missing_number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081800,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> ans(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int el=nums[i];\\n            ans[el]=1;\\n        }\\n        for(int i=0;i<=n;i++)\\n        {   if(ans[i]==0)\\n                return i; \\n        }\\n            return 0;    \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> ans(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int el=nums[i];\\n            ans[el]=1;\\n        }\\n        for(int i=0;i<=n;i++)\\n        {   if(ans[i]==0)\\n                return i; \\n        }\\n            return 0;    \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772529,
                "title": "c-solution-o-n-time-o-1-space-using-xor",
                "content": "```\\nclass Solution {\\npublic:\\nint missingNumber(vector<int>& nums) {\\n    int res=nums[0], x=0;\\n    for(int i=1; i<nums.size(); i++) {\\n        res^=nums[i];\\n        x^=i;\\n    }\\n    x^=nums.size();\\n return res^x;\\n}\\n};\\n/*\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint missingNumber(vector<int>& nums) {\\n    int res=nums[0], x=0;\\n    for(int i=1; i<nums.size(); i++) {\\n        res^=nums[i];\\n        x^=i;\\n    }\\n    x^=nums.size();\\n return res^x;\\n}\\n};\\n/*\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625745,
                "title": "python-o-n-time-o-1-complexiy",
                "content": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n\\t\\t# range from 0 to n\\n        n = len(nums) + 1\\n\\t\\t# the sum of all numbers between 0 and n is equal to n*(n-1)/2\\n\\t\\t# we subtract the theoretical sum from the real sum and it returns the missing value\\n        return int(n * (n - 1) / 2 - sum(nums))\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n\\t\\t# range from 0 to n\\n        n = len(nums) + 1\\n\\t\\t# the sum of all numbers between 0 and n is equal to n*(n-1)/2\\n\\t\\t# we subtract the theoretical sum from the real sum and it returns the missing value\\n        return int(n * (n - 1) / 2 - sum(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603871,
                "title": "javascript-one-liner-using-reduce-and-bitwise-xor",
                "content": "```\\n/**\\n  One-liner.\\n  Init the accumulator to nums.length\\n  Then XOR (^) the current number with the index\\n  Then XOR equals (^=) with the accumulator\\n  \\n  Runtime: 80 ms, faster than 80.75%\\n  Memory Usage: 41.3 MB, less than 48.27%\\n*/\\nvar missingNumber = function(nums) {\\n    return nums.reduce((acc, cur, i) => acc ^= i ^ cur, nums.length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n  One-liner.\\n  Init the accumulator to nums.length\\n  Then XOR (^) the current number with the index\\n  Then XOR equals (^=) with the accumulator\\n  \\n  Runtime: 80 ms, faster than 80.75%\\n  Memory Usage: 41.3 MB, less than 48.27%\\n*/\\nvar missingNumber = function(nums) {\\n    return nums.reduce((acc, cur, i) => acc ^= i ^ cur, nums.length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529886,
                "title": "simple-efficient-two-line-python-solution",
                "content": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        return n * (n + 1) // 2 - sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        return n * (n + 1) // 2 - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328993,
                "title": "c-o-n-solution-with-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n+1))/2;\\n        int sum = 0;\\n        for(int i=0; i<n; i++) sum += nums[i];\\n        return expectedSum - sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n+1))/2;\\n        int sum = 0;\\n        for(int i=0; i<n; i++) sum += nums[i];\\n        return expectedSum - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304826,
                "title": "c-sum-xor-based-2-solution-simple-easy-solution",
                "content": "**Simple Brute Force ( Sum Based )**\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans = (nums.size()*(nums.size()+1))/2;\\n        for(auto i:nums)\\n            ans -= i;\\n        return ans;\\n    }\\n};\\n```\\n****\\n****\\n**Xor Based Solution**\\nHere fact that used is that XOR of any no. with same no. will give result as zero \\nlet ans = 1^2^3^...^n\\nso doing xor of thin ans with all given element we find out which one is not present in array\\n\\n**Example**\\nsuppose nums = [0,1,3]\\nso our ans = 1^2^3\\nnow with all array element\\nans = 1^2^3^0^1^3\\nhere 3^3 = 0\\n\\t\\t1^1 = 0\\nso ans = 0^1^0^0 = 1\\nans = 1\\nwhich is missing no. in given array\\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans = 0;\\n        int i = 0;\\n\\t\\t//here in code we didn\\'t pre calculate ans \\n\\t\\t//as we iterate over loop we simultaneously calculate this\\n\\t\\t//because order not matter in XOR operation\\n        for(i=0;i<nums.size();i++)\\n        {\\n            ans ^= nums[i];\\n            ans ^= (i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*If Find HelpFul then Please Upvote* **:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans = (nums.size()*(nums.size()+1))/2;\\n        for(auto i:nums)\\n            ans -= i;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int ans = 0;\\n        int i = 0;\\n\\t\\t//here in code we didn\\'t pre calculate ans \\n\\t\\t//as we iterate over loop we simultaneously calculate this\\n\\t\\t//because order not matter in XOR operation\\n        for(i=0;i<nums.size();i++)\\n        {\\n            ans ^= nums[i];\\n            ans ^= (i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091320,
                "title": "java-o-n-time-o-1-memory-no-mathematical-formula-no-bit-operation",
                "content": "The straightforward way to find out the result is: SUM(1 to N) - SUM(nums).\\nMathematically, SUM(1 to N) = N * (N + 1) / 2\\n\\nHowever, what if SUM(1 to N) overflows or you don\\'t memorize/know the mathematical formula? Turns out that, we can determine Sum(1 to N) while iterating through the array. It is nothing but the summation of all the 1-based indices. The code follows:\\n\\n```\\n\\tpublic int missingNumber(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            result += (i + 1 - nums[i]);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The straightforward way to find out the result is: SUM(1 to N) - SUM(nums).\\nMathematically, SUM(1 to N) = N * (N + 1) / 2\\n\\nHowever, what if SUM(1 to N) overflows or you don\\'t memorize/know the mathematical formula? Turns out that, we can determine Sum(1 to N) while iterating through the array. It is nothing but the summation of all the 1-based indices. The code follows:\\n\\n```\\n\\tpublic int missingNumber(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            result += (i + 1 - nums[i]);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1041714,
                "title": "super-easy-o-n-time-and-o-1-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n= nums.size();\\n        int sum_n = (n*(n+1))/2;\\n        int sum = accumulate(nums.begin(), nums.end(),0);\\n        int missing= sum_n - sum;\\n        return missing;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n= nums.size();\\n        int sum_n = (n*(n+1))/2;\\n        int sum = accumulate(nums.begin(), nums.end(),0);\\n        int missing= sum_n - sum;\\n        return missing;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796531,
                "title": "c-simplest-4-line-solution-using-bits-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.size(); i++)\\n            res^=i^nums[i];\\n        return res^nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.size(); i++)\\n            res^=i^nums[i];\\n        return res^nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396778,
                "title": "golang-solution-using-xor",
                "content": "```\\nfunc missingNumber(nums []int) int {\\n\\tres := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tres = res ^ (i + 1) ^ nums[i]\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc missingNumber(nums []int) int {\\n\\tres := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tres = res ^ (i + 1) ^ nums[i]\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576814,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1565605,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1566225,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1567471,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1568775,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1572797,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1569935,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1569506,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1567360,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1569817,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1576814,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1565605,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1566225,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1567471,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1568775,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1572797,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1569935,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1569506,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1567360,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1569817,
                "content": [
                    {
                        "username": "amsahil",
                        "content": "This problem can be solved by 3 methods:\\n1.Hashing\\n2.Sum Formula\\n3. Bit manupulation i.e using XOR.\\n\\nLets dicuss this method that which is more effiecient and why it has to be used:-\\n\\n1. **HASHING** :- In this Method, We can iterate over all the element upto the n and compare it with the present element by creating the hash map of (n+1).\\n*Time Complexity = O(n)\\nSpace complexity =O(n)*\\n * Issue :- Though it is taking the space complexity of N, So we move on to  the next Method.\\n\\n2. **Sum Formula** :- In this we us e the sum formula i.e;\\n    Sn = (N+1)/2 & Sum of all the array(Sa[]). \\n\\tAnd after this we subtract the (Sn-Sa[]) to find the Missing Number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\n* Issue :- It can cause the Overflow issue because in this we are adding the element, So if the array element is very large then it can cause Integer Overflow.\\n\\nTo handle out this Overflow we can use the Next Method which is XOR Bit Manipulation.\\n\\n3. **XOR Bit Manipulation** :- In this we take the XOR of given array and the first n natural number.\\n*Time Complexity = O(n)\\nSpace complexity =O(1)*\\nNo Overflow.\\n\\nHope you find this useful.\\n//Happy coding\\nSigning off ~Sahil Shah\\n\\n\\n"
                    },
                    {
                        "username": "PanaitCosmin",
                        "content": "For 2.Sum Formula you can use Gauss formula for sum which is n*(n+1) / 2 where n = nums.length (the last number in this consecutive series)"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Nicely writtern [@Sahil Kumar](/amsahil) Thanks well done !"
                    },
                    {
                        "username": "RedoUser",
                        "content": "[@vsc258srt125vc](/vsc258srt125vc) Pretty sure cyclic sort is not linear time."
                    },
                    {
                        "username": "heyyyankit",
                        "content": "[@i_gyanprakash](/i_gyanprakash) no, no need to sort because xor follow distributive property like 1^2^3^4==2^1^4^3==1^4^3^2 like that. Also xor of a no. with itself is 0 and xor of a no. with 0 is no. itself. "
                    },
                    {
                        "username": "vsc258srt125vc",
                        "content": "There is one more method cyclic sort "
                    },
                    {
                        "username": "sadhukhansubham588",
                        "content": "striverrr ki copoyyyyyyyy"
                    },
                    {
                        "username": "sharankarchella",
                        "content": "i.e..... N(N+1)//2  you wrote it wrong"
                    },
                    {
                        "username": "i_gyanprakash",
                        "content": "for the third method you need to sort the array first so Time Complexity would be O(n log n)"
                    },
                    {
                        "username": "avi_dey",
                        "content": "thank you"
                    },
                    {
                        "username": "david-graves",
                        "content": "[@ssuman6792](/ssuman6792) It doesn\\'t have to be sorted. Consider that this statement is true: `x ^ y == y ^ x` and so is: `x ^ y ^ z == z ^ y ^ x`. The XOR operation is commutative (like multiplication and addition), so order shouldn\\'t matter. "
                    },
                    {
                        "username": "ssuman6792",
                        "content": "3 Solution will work only if array is sorted"
                    },
                    {
                        "username": "vuduyquoc",
                        "content": "I don\\'t understand the requirements. Why the return result is 1 when the input is [0]. I think it should return -1"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Simply put question says the max element of range [0-n] is n where n is length of array. In your case n is 1 hence the array range is [0-1]."
                    },
                    {
                        "username": "Roktim",
                        "content": "Here the total number of item(s) in this array is 1. And 1 is missing in this array. So answer will be 1"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/missing-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sorting [Accepted]\n\n  \n**Approach 2:** HashSet [Accepted]\n\n  \n**Approach 3:** Bit Manipulation [Accepted]\n\n  \n**Approach 4:** Gauss' Formula [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "shammyraj",
                        "content": "this is error which I\\'m getting :\\ninput : [0]\\noutput:[1]\\n\\nshouldn\\'t the output be 0 ? what am I missing ?"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "they said the range is for natural numbers, so if 0 is the only element present, there has to be 1 instead of 0."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    },
                    {
                        "username": "sagarv19171",
                        "content": "\\'\\'\\'\\n\\n\\treturn sum(range(len(nums)+1))-sum(nums)\\n\\t\\n\\'\\'\\'"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Icarus2000",
                        "content": "Can someone explain why 1 is the missing number for [0]? I don\\'t think [0] is missing any number since 0 is at it\\'s correct position."
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "Kishan_K_Pathak",
                        "content": "because we have to check for all the elements from 0 to (inclusive) nums.size(), Read the question statement properly.  "
                    },
                    {
                        "username": "nikolatesla20",
                        "content": "How about some comments, or explanations"
                    },
                    {
                        "username": "astubbs50",
                        "content": "This doesn\\'t make sense to have test cases with less than 2 items.  You can\\'t have a range with less than 2 items."
                    },
                    {
                        "username": "xceinie",
                        "content": "The range is never less than 2. The only cases with a range of two are [1] and [0] test cases (range is 0-1), which would provide expected answers of 0 and 1 respectively. When n=1, the range is still 2 since 0 is included in that range."
                    },
                    {
                        "username": "Happy4892",
                        "content": "I don\\'t understand the input and output. For ex, if the given array is [0], then it should return nothing. Because nothing is missing between 0 to 0. Also if the given array is [3,9], then it could be anything from 4 to 8 or 0 to 2, howcome the answer is 9? 9 is not \"missing\" here! I\\'m so confused, please help......"
                    },
                    {
                        "username": "Chaitanya_49",
                        "content": " why [0] get output [0,1] ?\\nin the question they mentioned to find the number that is missing  . so it is clear that every testcase MUST miss ONLY ONE whole number till <=nums.size() .and every array MUST start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "sanmar96",
                        "content": "if the array has only one element [0] why should the array have [0,1] in final ?"
                    },
                    {
                        "username": "Noah492",
                        "content": "So all of the arrays start at 0 and you are looking for the next missing element.\\nIf you have [0,1,3], then your missing element is 2\\n\\nIn the case of [0], you have all of the elements you need already in the array already.\\nThe next missing one would be whatever would be next which is one.\\n\\nSimilarly, [0,1,2] would have 3 for the answer.\\nThere are 3 possible slots in the array and all are filled properly so the result would be the next number.\\nIn your code that can just be the length of the array."
                    }
                ]
            },
            {
                "id": 1569277,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1898729,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1571502,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 2066336,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1799812,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1791901,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1576812,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1575192,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1574239,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1574013,
                "content": [
                    {
                        "username": "moytri",
                        "content": "For [3] expected answer is 2, but for [4] expected answer is 5.\\nFor [1,2] expected answer is 0, but for [1,3] expected answer is 1.(Here 1 is not missing)\\nPlease leetcode mdify your testcases.\\n\"Question is: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\" so if the array[0] != 0, 0 will be missing. In case of [1,3], why 1 is missing.\\nThanks."
                    },
                    {
                        "username": "xceinie",
                        "content": "These are all invalid test cases. For [3] n would at minimum have to be 3, and the range of numbers would have to be [0,3]. 3/4 of the numbers in that range would have to be included in the test case to satisfy its conditions. The expected solutions are probably not working because they cannot provide a correct answer."
                    },
                    {
                        "username": "CaptainAlex",
                        "content": "Input: nums = [0,1]\\nOutput: 2\\nInput: nums = [1]\\nOutput: 0\\nWhy ?"
                    },
                    {
                        "username": "manandharnara",
                        "content": "Max length for [0,1] is 2 so total elements is 0,1,2 and 2 is missing  max length for [1] is 1 so  total elements is 0,1 and 0 is missing "
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Can you describe more details about this questions? What the hell the input looks like? Type one more sentence will make you exhausted?"
                    },
                    {
                        "username": "skydodle",
                        "content": "Here is an intuitive approach to solve the problem before thinking about how to code it:\\n\\nWe know that there are supposely n + 1 total numbers but one number is missing and we need to find that missing number. This is because we know the range is [0, n]. \\n\\nFor example,  Input: nums = [3,0,1]\\nWe know the range is 0, 1, 2, 3 and there are supposely 4 total numbers, but the given input only has 3 total numbers: 0, 1, 3. \\n\\nWithin this range 0 to n, each number should be unique and consecutive, so we can safely assume the sum of the suppose total numbers by iterating from 0 to n,  and then compare it with the current input sum.\\n\\nsuppose sum = 0 + 1 + 2+ 3 = 6\\ncurrent sum = 0 + 1 + 3 = 4\\n6 - 4 = 2 \\n\\n2 is the missing number in [0, 1, 3]\\n\\nNo sorting or hash map is required in this approach and you can achieve O(N) time and O(1) space.\\n\\n"
                    },
                    {
                        "username": "jainkunal2003",
                        "content": "int missingNumber(vector<int>& arr) {\n        int s=0;  // for total sum upto n digits\n        int c=0;  // for sum of array contents\n        int n=arr.size();\n\n        for(int i=0;i<=n;i++){\n            s+=i;\n        }\n        \n        \n        for(int i=0;i<n;i++){\n            c+=arr[i];\n        }\n        \n        return s-c;  // subtract array sum from total and we will get        required number \n\n    }"
                    },
                    {
                        "username": "azimjonazs12",
                        "content": " `int missingNumber(List<int> nums) {\\n    nums.sort();\\n    int result;\\n    if (nums.first != 0) {\\n      result = 0;\\n    } else {\\n      result = nums.last + 1;\\n    }\\n    for (int i = 0; i < nums.length - 1; i++) {\\n      if (nums[i] + 1 != nums[i + 1]) {\\n        result = nums[i] + 1;\\n        break;\\n      }\\n    }\\n    return result;\\n  }`\\n"
                    },
                    {
                        "username": "Phucnguyen99",
                        "content": "I like your idea.."
                    },
                    {
                        "username": "himanshuhere",
                        "content": "Minimum post lenght is 12 characters so yes."
                    },
                    {
                        "username": "hitvardhan19",
                        "content": "var missingNumber = (nums) => nums.reduce((acc, num)=>acc-=num, (nums.length * (nums.length + 1)) /2);"
                    },
                    {
                        "username": "sindhugarlapati27",
                        "content": "![image](https://assets.leetcode.com/users/images/6afc966f-4349-4670-b064-7023fa2c5b81_1597786106.5478876.png)\\n"
                    },
                    {
                        "username": "beczhaozmy",
                        "content": "The Solution given for input = [0] and input = [1] are 1 and 0 respectively. What is the logic behind these solutions?\\n\\nThanks."
                    }
                ]
            },
            {
                "id": 1572526,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 1572201,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 1571504,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 1571505,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 1571503,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 2076754,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 2068163,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 2061179,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 2061159,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 2055459,
                "content": [
                    {
                        "username": "xudongxiang",
                        "content": "return sum(range(len(nums)+1)) - sum(nums)"
                    },
                    {
                        "username": "sofs1",
                        "content": "Input     -->    Output\\n[0]         -->      1\\n[0,1]      -->      2\\n"
                    },
                    {
                        "username": "amirdon",
                        "content": "This is the question:\\n\\n>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\\n\\nSurely, based on the questions, if an array = [0], then there is no missing number!"
                    },
                    {
                        "username": "TalkLessCodeMore",
                        "content": "I used the (0+n)*(n+1)/2 - sum to calculate the missing number, and guess what, it passed! \\nBut on second thought, what if the summation overflows? Seems no such case is present."
                    },
                    {
                        "username": "srlrs20020",
                        "content": "For ruby your only given the array nums as input.  If nums is [1, 0], how are you supposed to know 2 is missing?  You are not told is 3, you are just given the array.  Seems like a bad question"
                    },
                    {
                        "username": "Hritik_Singh-1245",
                        "content": "Using  properties of bitwise operator XOR we can solve it very easily."
                    },
                    {
                        "username": "Parthkotwe",
                        "content": "// EASY C++ SOLUTION //\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int expectedSum = (n * (n + 1)) / 2;\\n        int actualSum = accumulate(nums.begin(), nums.end(), 0);\\n        return expectedSum - actualSum;\\n        }\\n};\\n @[leetcode](https://leetcode.com) `your inline code...your inline code...`#C++,"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Who sees discussions  ???"
                    },
                    {
                        "username": "acapantic21",
                        "content": "Python solution using sets:\\n\\n `return set(list(range(len(nums)+1))).difference(set(nums)).pop()`"
                    },
                    {
                        "username": "asil-tamu",
                        "content": "What if more than one numbers were missing? How should we approach then?"
                    }
                ]
            },
            {
                "id": 2046398,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 2032442,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 2012182,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 2008381,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 2007370,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1996302,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1985089,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1982916,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1976599,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1974209,
                "content": [
                    {
                        "username": "anilbillupati",
                        "content": "there are many ways to solve the problem \\n\\nsum method:\\n1.find the sum on n numbers using the formula N*N+1/2\\n2.initialize the sum to 0 i.e int sum =0;\\n3.now iterate through the entire array and add each value to the sum variable \\n4.for the result return the  sum of n numbers - sum of array elements gives  the answer "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tell me why its  showing error.............\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i!=nums[i])\\n            return i;\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "josialex",
                        "content": " `your inline code...your inline code...` @"
                    },
                    {
                        "username": "_Shushant",
                        "content": "Can anyone explain me this error \" error: no viable conversion from returned value of type 'vector<int>' to function return type 'int'\n        return ans;\n               ^~~ \" "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "It means you are returning the value of type vector when your function expects to return type int"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange error. Whenever I try to return my iterator it says I am returning None. I'm expecting a value of 2 and when I return 1000 - i, I get a value of 998, so the value of i is actually 2 and not None. My code works fine in other compilers, just not here. Can anyone help me with this? I'm using Python."
                    },
                    {
                        "username": "KarAnSiNghhh",
                        "content": "I am a beginner and i could only think of this approach through sorting can somebody help me : )\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=i){\\n               return i;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};"
                    },
                    {
                        "username": "himanshisingh7004",
                        "content": " function missingNumber(nums) {\\n    let minValue= Math.min(...nums);\\n    let maxValue= Math.max(...nums);\\n    let missNum= [];\\n    for(let n= 0; n<=3; n++)\\n    if(!nums.includes[n]){\\n        missNum.push[n];\\n    }\\n    return missNum;\\n};\\nnums =[ 3, 0, 1];\\n\\nlet res= missingNumber(nums);\\n  console.log(res);\\n\\nCAN SOMEONE EXPLAIN WHAT IS THE ISSUE WITH THIS CODE?? \\nI CANNOT RUN EX 1:("
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "Store sum of  `n` natural numbers in a variable. Traverse array and subtract each item in array from your variable. In the end, only the missing integer will be left in your variable. Return that. This is pretty straight-forward and quick for people who find bitwise operators or advanced coding concepts a little tough at the moment :) "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) All the best with that! I have less professional experience so my profile gets rejected way before I can get to interviews. Hopefully, soon I can also switch."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "[@ninfa_jeon](/ninfa_jeon)  Thanks. Although it is time for me to switch so started grinding leetcode again. Hoping to crack some companies soon. "
                    },
                    {
                        "username": "ninfa_jeon",
                        "content": "[@thesatiricwriter](/thesatiricwriter) You are right! That is why I mentioned that this was for people who found the bitwise approach a little difficult to follow at the moment. I hope you got into a good job later."
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "I had given an interview back in 2022 at Seimens. Interviewer asked me the same question and I gave same your approach. Was rejected because she insisted for the bitwise method, as a result I was rejected. So yeah these simple questions can screw big time."
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "using cyclic sort makes it so easy."
                    },
                    {
                        "username": "dvishal485",
                        "content": "Can someone help me understand this code which I wrote few months back?\n\nhttps://leetcode.com/problems/missing-number/solutions/3778121/god-s-message-drunk-code/\n\n```\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int x = 0;\n        int n = nums.size();\n        short int p = n % 4;\n        for(auto i: nums) x ^= i;\n        if (p == 0)\n            return x^n;\n        if (p == 1)\n            return x^1;\n        if (p == 2)\n            return x^(n + 1);\n        return x;\n    }\n};\n```"
                    }
                ]
            },
            {
                "id": 1970611,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1969955,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1962766,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1961855,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1961847,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1961843,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1936292,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1918804,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1910473,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1910146,
                "content": [
                    {
                        "username": "Chaitanya_49",
                        "content": "for people who are confusing why [0] get output [0,1].in the question they mentioned to find the number that is missing form . so it is clear that every testcase miss atleast one whole number till <=nums.size() .and every array must start with 0.here the array starts and end with 0 but size is 1 so it atleast have a number i.e<=1. so 1 will be the missing number .upvote if your doubt is cleared"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "One line Solution\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        return list(set(range(0, len(nums)+1)) - set(nums))[0]\n```"
                    },
                    {
                        "username": "DevKJobalia",
                        "content": "can use cycle sort"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Easy Approach\n\n\n\n\n\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        \n        int high = nums.length;\n        Arrays.sort(nums);\n        int total = high*(high+1)/2;\n        int sum = 0;\n        for(int i = 0; i < nums.length; i++) {\n            sum = sum + nums[i];\n        }\n        return total - sum;\n        \n    }\n}"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "If range is [0,1] then how it can be possible that missing number is 2?\\n"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "Defination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n"
                    },
                    {
                        "username": "hardikbansal1925",
                        "content": "Is Test case 2 is wrong here? And if it is then pls inform"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "No, \\n\\nDefination of n is: `nums containing n distinct numbers in the range [0, n]` So if we consider array with missing number then total range of new array will be length of nums + 1.\\n\\n\\nSo if we consifer [0, 1], So here all dictict numbers are 2 so value of n is 2. So range lies from [0..2] and that is [0, 1, 2]\\n\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This problem should have the number [033](https://the-scp.foundation/object/scp-033)"
                    },
                    {
                        "username": "aneri_sonani",
                        "content": "class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        int j=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            if(j==nums[i]){\\n                j++;\\n                num=j;\\n            }\\n        }\\n        return num;\\n    }\\n};"
                    },
                    {
                        "username": "andresstawski",
                        "content": "currently sorted the vector and found where i != nums[i] in a for loop.\\n\\nis there a solution with faster runtime using for loop?"
                    },
                    {
                        "username": "LikeMySoul",
                        "content": "Why my function cant work?\nI test this in Pycharm and its work correctly, but if i try to solve on site - TypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");"
                    }
                ]
            },
            {
                "id": 1907240,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1896798,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1894747,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1875980,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1865800,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1861292,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1833853,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1832020,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1827412,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1812418,
                "content": [
                    {
                        "username": "podalakurisuryaprakash",
                        "content": "class Solution {\n    public static int missingNumber(int[] nums) {\n                   int n=nums.length;\n            int missing=0;\n            int[] newarr=new int [n];\n            for(int i=0;i<n;i++){\n                newarr[i]=i;\n            }\n            for(int i=0;i<n;i++){\n               for(int j=0;j<n;j++){\n                   if(newarr[i]!=nums[j]){\n                       missing= newarr[i];\n                   }\n               }\n            }\n            return missing;\n    }\n\n}\n\n//  IN THIS LOGIC TEST CASE 2 IS FAILLED FOR INPUT OF {0,1} can any one sort this out"
                    },
                    {
                        "username": "am14",
                        "content": " `int missingNumber(vector<int>& nums) \\n    {\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        vector<int> natural;\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            natural.push_back(i);\\n        }\\n        for(int i = 0; i<natural.size(); i++)\\n        {\\n            if(natural[i]!=temp[i])\\n            {\\n                return natural[i];\\n            }\\n        }\\n        return 0;\\n    }`\\n\\nThis is not working for [num.size()<3]\\nCan anyone please point out the mistake?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I managed O(n) time complexity and O(1) space complexity but forgot about the triangular number formula. In a problem this easy, that represents a fail."
                    },
                    {
                        "username": "Jatin_Bisht",
                        "content": "class Solution {\\n    public int missingNumber(int[] A) {\\n         int[] hash = new int[A.length + 1];\\n         for(int i=0;i<A.length;i++)\\n         {\\n             hash[A[i]] = 1;\\n         }\\n        //  now check which has 0 \\n        for(int i=0;i<hash.length;i++)\\n        {\\n            if(hash[i]==0)\\n            {\\n                return i;\\n            }\\n        }\\n         return -1;\\n    }\\n} @"
                    },
                    {
                        "username": "shivamj11",
                        "content": "https://leetcode.com/problems/missing-number/solutions/3422672/python-code-using-binary-search-o-n-1-log-n-not-the-fastest-but-easy-to-understand/"
                    },
                    {
                        "username": "kamalkant2392",
                        "content": "I don\\'t understand this example. How come the answer is 2.\\n\\nInput: nums = [0,1]\\nOutput: 2\\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums."
                    },
                    {
                        "username": "singh_3662",
                        "content": "Remember that whenever the elements will be given in continous order then always try to solve it using cyclic sort. (Because cyclic sort sorts the continous elements)"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "My Solution is beating only 4% . Can anybody suggest me a optimized Approach for this problem."
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "        n = len(nums)+1\n        return n*(n-1)//2-sum(nums)"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "WHY THROWING ERROR ? (PYTHON3) anyone pls \\nclass Solution:\\n    def missingNumber(self, nums: List[int]) -> int:\\n  \\n        for i in range(min(nums), max(nums)):\\n            if i not in nums:\\n                return int(i)"
                    }
                ]
            },
            {
                "id": 1812180,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1811497,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1808108,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1804304,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1801007,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1800641,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1799904,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1798324,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1787129,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1776939,
                "content": [
                    {
                        "username": "SharmaAyush",
                        "content": "this is very easy consept to learn and find value\\n\\nO(N)\\n\\nclass Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n\\n        int result = nums.size();\\n        int i=0;\\n\\n\\n        for(auto num:nums){\\n            result ^=nums[i];\\n            result ^=i;\\n            i++;\\n        }\\n\\n        return result;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Arghyajyoti_Samui",
                        "content": "Sum of the ideal sequence of full length (n*(n+1)/2) - Sum of given sequence = result"
                    },
                    {
                        "username": "Hela1998",
                        "content": "This is an easy problem, don\\'t make it that complicated...\\n    `public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=i) return i; \\n        }\\n        return n;\\n    }`\\n"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "  int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "iam_avinash",
                        "content": "int n = nums.length;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n\\n        //sum of n natural number\\n        int sum1 = (n*(n+1))/2;\\n\\n        return (sum1-sum);"
                    },
                    {
                        "username": "fakeninja78",
                        "content": "do not try to overthink this question. It is given that the range for values is [0,n]. \\nTake a simple boolean array of length = size of nums array.\\nIterate the nums array and every time you encounter a new integer(value) set the value of the boolean array corresponding to that position as true;\\nIn the last step traverse the boolean array and if at any position you find a false value return that position as it is not present."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "Or you may just find the total sum upto size of the array, and then just store the sum of array integers given in the variable sum and finally just return \"total_sum - sum_of_array\"."
                    },
                    {
                        "username": "danishnawab555",
                        "content": "C++ solution easy:\\n `int missingNumber(vector<int>& nums) {\\n        int missing=0;\\n        unordered_map<int, int>count;\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0; i<nums.size(); i++)count[nums[i]]++;\\n\\n        for(int i=1; i<=nums.size(); i++){\\n            if(count[i]==0)missing=i;\\n        }\\n        return missing;\\n    }`"
                    },
                    {
                        "username": "bkochhar28",
                        "content": "Find Missing Element star_border\\nThere is an array of non-negative integers. A second array is formed by shuffling the elements of the first array and deleting a random element. Given these two arrays, find which element is missing in the second array.\\n\\nInput Format:\\n\\nFirst line of input will contain a positive integer T = number of test cases. \\nEach test case will contain 3 lines. \\nFirst line of each test case will contain two number m = size of the first array and n = size of the second array separated by space. \\nNext 2 lines will contain m and n space separated non-negative integers.\\nOutput Format:\\n\\nFor each test case, print the missing element in the second array.\\nConstraints:\\n\\n0 \\u2264 T \\u2264 10\\n2 \\u2264 m \\u2264 10^5\\nn = m - 1\\n0 \\u2264 A[i], B[i] \\u2264 10^4\\nSample Input\\n\\n1  // Test Cases\\n5 4\\n1 2 3 4 5\\n3 4 1 2\\nSample Output\\n\\n5\\n\\nPlease solve this Question.\\nint getMissingElement(std::vector<int> A, std::vector<int> B) {}"
                    },
                    {
                        "username": "pravesh2408",
                        "content": " int missingNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1;\\n        if(nums.size()==1)\\n            return abs(nums[0]-1);\\n        if(nums[0]!=0)\\n            return ans=0;\\n        for(int i=1;i<nums.size();i++)\\n           { \\n               if(nums[i]-nums[i-1]!=1)\\n                 ans=nums[i]-1;\\n           } \\n           if (ans==-1)\\n                return nums.size();\\n           else\\n                return ans;\\n    } `\\n\\n`"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Hey, wondering how this solution can be freed from errors. Help?\n1.\n\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        if nums==[]:\n            return 0\n        else:\n            n=len(nums)\n            nums.sort()\n            for i in range(n):\n                if nums[i]!=i:\n                    return i\n```\n\n2.\n```\nclass Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n\n        c=0\n        for i in range(1,n):\n            if (nums[i]!=nums[i-1]+1):\n                return nums[i-1]+1\n                c=c+1\n            \n            if c==n:\n                if nums[i]!=n:\n                    return n\n```"
                    }
                ]
            },
            {
                "id": 1771360,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1769780,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1767006,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1766471,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1752200,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1748076,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1745858,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1742953,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740882,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1738410,
                "content": [
                    {
                        "username": "amigaurav",
                        "content": "Tip for the answer is : try to think about commutative property of XOR operator .\\nthis will lead you to the solution."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "thesatiricwriter",
                        "content": "Why is this failing but the commented formula works ?????????\\nint missingNumber(vector<int>& nums) {\\n        int nsum;\\n        int n=nums.size();\\n        //sum of natural n numbers\\n        nsum = n*((n+1)/2);\\n        // nsum = nums.size()*(nums.size()+1)/2;\\n\\n        for(auto i: nums)\\n        {\\n            nsum = nsum-i;\\n        }\\n        return nsum;\\n    }"
                    },
                    {
                        "username": "Sagarkumar09",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int l=0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(l==nums[i]){\\n                l++;\\n            }\\n            else\\n            return l++;\\n\\n        }\\n         return l;        \\n    }\\n}"
                    },
                    {
                        "username": "Shivangpandey134",
                        "content": "There are 4 ways to approach given problem;\\n1. BITS MANUPULATION : XOR of two same numbers is zero and XOR of zero with any number is\\nsame number. we can use this fact to first take the XOR of  all array elements and then of all \\nnumbers from o to n.\\n2. Binary search (Only for sorted array):- If mid == index then our missing number will be right part else in the left part\\n3.LINEAR search(Only for sorted array)\\n4. Take the sum of all array elements and then subtract it from n(n+1)/2\\n   "
                    },
                    {
                        "username": "AlgorithmicSage",
                        "content": "SOLVING THIS PROBLEM USING BINARY SEARCH\\nSTEP 1-SORT NUMS\\nSTEP 2- INITIALIZE S=0,E=NUMS.SIZE()-1\\nMID=S+(E-S)/2\\nWHILE(S<=E)\\nIF NUMS[MID]=MID THEN S=MID+1\\nIF NUMS[MID]>MID THEN E=MID-1\\nMID=S+(E-S)/2\\nSTEP 3-RETURN S"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using XOR \\n\\n    int missingNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=ans^nums[i];\\n        }\\n        for(int i=0;i<=nums.size();i++){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "eitanweiss",
                        "content": "after writing the solution, I noticed that using different names for my variable changes the amount of space needed, which makes some sense(though not that much) but also the time it took.\\n\\nwhen I called it \"length\" I got the fastest result and X space.\\nWhen I called it \"n\" i saved a bit of space(0.2MB) but the run time was much slower.\\n\\nMy question is why would this happen?"
                    },
                    {
                        "username": "coolanky1994",
                        "content": "Java Solution using in place sorting\\n\\nclass Solution {\\n    public int missingNumber(int[] arr) {\\n        for(int i=0; i<arr.length;){\\n         if(arr[i] >= arr.length){\\n            i++;\\n         }\\n         else if(arr[i] != i){\\n            int temp = arr[arr[i]];\\n            arr[arr[i]]= arr[i];\\n            arr[i] = temp;\\n         }\\n         else {\\n            i++;\\n         }\\n      }\\n      for(int i=0; i<arr.length; i++){\\n         if(arr[i] != i)\\n           return i;\\n      }\\n      return arr.length;\\n    }\\n}"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n       int i;\\n       int N=nums.length;\\n        int temp[] = new int[N + 1];\\n        for (i = 0; i <= N; i++) {\\n            temp[i] = 0;\\n        }\\n \\n        for (i = 0; i < N; i++) {\\n            temp[nums[i] ] = 1;\\n        }\\n \\n        int ans = 0;\\n        for (i = 0; i <= N; i++) {\\n            if (temp[i] == 0)\\n                ans = i ;\\n        }\\n       return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734605,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1734169,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1733568,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1730223,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1729935,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1729696,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1725473,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1724378,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1723661,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1717404,
                "content": [
                    {
                        "username": "sitongye",
                        "content": "hashing: find the difference of two sets and unpack the set\n\n ```class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        diff = set(range(n+1)).difference(set(nums))\n        ans, = diff\n        return ans```\n"
                    },
                    {
                        "username": "prabhASSLA",
                        "content": "`var hashmap = []\n\nfunction missing(nums, l) {\n    for (let i = 0; i < l; ++i) {\n        if (hashmap[nums[i]] == -1)\n            hashmap[nums[i]] = 0\n    }\n\n    for (let i = 0; i < hashmap.length; ++i) {\n        if (hashmap[i] == -1)\n            return i\n    }\n\n}\n\nvar missingNumber = function (nums) {\n\n    for (let i = 0; i <= nums.length; ++i)\n        hashmap.push(-1)\n\n    return missing(nums, nums.length);\n};`\n\nmy answer for [0] is coming out to be 8. what is this issue? i even checked running using node. my offline answer was 1. why here it shows 8???"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Sum method is so easy to do .I have done int his and didn\\'t got any overflow ..It gives 100% beats and easily understandable. So don\\'t go away without learning it."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/268_missing_number.cpp"
                    },
                    {
                        "username": "tihamiqa",
                        "content": "//simple and easy java\\n\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=i){\\n                return i;\\n            }\\n        }\\n        return nums[n-1]+1;\\n    }\\n}"
                    },
                    {
                        "username": "Abhiraj_Mane",
                        "content": "try this:-\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n        int i = 0;\\n        while(i < nums.length){\\n            int correct = nums[i];\\n            if(nums[i]<nums.length && nums[i]!=nums[correct]){\\n                swap(nums,i,correct);\\n            }else{\\n                i++;\\n            }\\n        }\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]!=index){\\n                return index;\\n            }\\n        }return nums.length;\\n    }\\n    void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n}"
                    },
                    {
                        "username": "megha6890",
                        "content": " class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v(n+1);\\n        for(int i=0;i<n+1;i++)\\n        v[i]=0;\\n        for(int i=0;i<n;i++){\\n        v[nums[i]]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==0)\\n            ans=i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ankpandit",
                        "content": "public int missingNumber(int[] nums) {\\n        int i = 0;\\n        int sum =0 ;\\n        while(i < nums.length){\\n            sum =sum +nums[i] ;\\n            i++ ;\\n        }\\n        int miss = (nums.length*(nums.length+1))/2 - sum ;\\n        return miss ;\\n    }"
                    },
                    {
                        "username": "kevinkurian",
                        "content": "Why is this giving the following error?\\n\\n `class Solution(object):`\\n    `    def missingNumber(self, nums):`\\n      `       mina=min(nums)`\\n      `       maxa=max(nums)`\\n    `         numsr=[x for x in range(mina,maxa+1)]`\\n     `        a=list(set(numsr).difference(set(nums)))`\\n   `          return a[0]`\\n\\npls help it says index is out of range but prints fine when using print() to debug\\n\\nIndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)IndexError: list index out of range\\n    return a[0]\\nLine 7 in missingNumber (Solution.py)\\n    ret = Solution().missingNumber(param_1)\\nLine 26 in _driver (Solution.py)\\n    _driver()\\nLine 36 in <module> (Solution.py)"
                    }
                ]
            },
            {
                "id": 1717292,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1714474,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1711038,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1700713,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1690830,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1681799,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1670582,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1653331,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1652909,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            },
            {
                "id": 1652285,
                "content": [
                    {
                        "username": "priyanshu_ch18",
                        "content": "        n= len(nums)\\n        expectedsum =( n*(n+1))/2\\n        arrsum = sum(nums)\\n        missing = expectedsum - arrsum\\n        return missing\\n# Here is mine"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "This problem can be solved by using the Direct approach \\n1.Take the sum of n elements in the array\\n2.now delete the iterative element  from the sum\\n3.now return the t value  \\nthats the final answer\\n"
                    },
                    {
                        "username": "filizcamci",
                        "content": "This problem seems invalid. There should be n+1 numbers in the array if the range is [0,n]. "
                    },
                    {
                        "username": "aylinhosseinchi",
                        "content": "I am stuck in examples 2 and 3 C# code someone can help me?"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public int missingNumber(int[] nums) {\\n        int n=nums.length;\\n        int totalsum = n*(n+1)/2;\\n        for(int i=0;i<n;i++){\\n            totalsum-=nums[i];\\n            }\\n            return totalsum;\\n        }\\n    }\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCCCFAANG OPTIMISED CODE | O(n)\\uD83D\\uDE4C| Easy Beginner friendly Soln.\\n\\nhttps://leetcode.com/problems/missing-number/solutions/2225195/faang-optimised-code-o-n-easy-beginner-friendly-soln/"
                    },
                    {
                        "username": "Anuprash",
                        "content": "by how many approaches this problem can be solved??"
                    },
                    {
                        "username": "andrefontes",
                        "content": "Can someone explain to me why the answer for Case 2 is 2? In my mind, the list [0,1] is not missing any number. Not sure what I didn\\'t understand. My code worked fine for cases 1 and 3, but for case 2 my output in None where apparently it should be 2."
                    },
                    {
                        "username": "andrefontes",
                        "content": "Very beginner here and I am probably missing something, but can someone explain to me why example 2 has the number 2 missing? The list is 0,1, so in my head there is nothing missing, Im confused. My code worked for example 1 and , but for example 2 is not working, what am I missing here, please?\\n\\nHere is my code:\\n\\nclass Solution(object):\\n    def missingNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        for n in range(len(nums)-1):\\n            if nums[n] - nums[n+1] != -1:\\n                return nums[n] + 1\\n\\n"
                    },
                    {
                        "username": "imanishkumar7545",
                        "content": " ` int missingNumber(vector<int>& nums) {\\n\\n        // There is hint in question it self if element is present is array then we have to make an bool array of that size\\n        // And after this mark index to be true if that element is present and if not return false\\n       vector<bool>trueElment(nums.size()+1,0);\\n       for(auto val:nums){\\n           trueElment[val]=true;\\n       }\\n       int i=0;\\n       for ( auto val:trueElment){\\n           if (!val)\\n           return i;\\n           i++;\\n       }\\n       return i;\\n    }`\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest Divisible Subset",
        "question_content": "<p>Given a set of <strong>distinct</strong> positive integers <code>nums</code>, return the largest subset <code>answer</code> such that every pair <code>(answer[i], answer[j])</code> of elements in this subset satisfies:</p>\n\n<ul>\n\t<li><code>answer[i] % answer[j] == 0</code>, or</li>\n\t<li><code>answer[j] % answer[i] == 0</code></li>\n</ul>\n\n<p>If there are multiple solutions, return any of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> [1,3] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4,8]\n<strong>Output:</strong> [1,2,4,8]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 684677,
                "title": "3-steps-c-python-java-dp-pen-paper-diagram",
                "content": "***NOTE:- if you found anyone\\'s post helpful please upvote that post because some persons are downvoting unneccesarily, and you are the one guys that save our post from getting unvisible, upvote for remains visible for others so and other people can also get benefitted***\\n\\n**DESCRIPTION:-**\\n\\n**Given an array the task is to largest divisible subset in array. A subset is called divisible if for every pair (x, y) in subset, either x divides y or y divides x.**\\n\\n**Examples:**\\n\\nInput  : arr[] = {1, 16, 7, 8, 4}\\nOutput : 16 8 4 1 or 1 4 8 16\\n\\n**An efficient solution involves following steps.**\\n\\n**1.  Sort all array elements in increasing order. The purpose of sorting is to make sure that all divisors of an element appear before it.\\n2.  Create an array dp[] of same size as input array. dp[i] stores size of divisible subset ending with arr[i] (In sorted array). The minimum value of dp[i] would be 1.\\n3.  Traverse all array elements. For every element, find a divisor arr[j] with largest value of dp[j] and store the value of dp[i] as dp[j] + 1.**\\n\\n![image](https://assets.leetcode.com/users/amit_gupta10/image_1592042710.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n**c++ code**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return nums;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int flag=1;\\n        if(nums[0]==1){\\n            flag=0;\\n        }\\n        else{\\n            nums.push_back(1);\\n            flag=1;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int dp[nums.size()][2];\\n        for(i=nums.size()-1;i>=0;i--){\\n            dp[i][0]=0;\\n            dp[i][1]=i;\\n            for(j=i+1;j<nums.size();j++){\\n                if((nums[j]%nums[i])==0){\\n                    if(dp[j][0]>dp[i][0]){\\n                        dp[i][0]=dp[j][0];\\n                        dp[i][1]=j;\\n                    }  \\n                }\\n            }\\n            dp[i][0]++;\\n        }\\n        i=0;\\n        vector<int> t;\\n        t.push_back(nums[i]);\\n        while(dp[i][1]!=i){\\n            i=dp[i][1];\\n            t.push_back(nums[i]);\\n            \\n        }\\n        if(flag==1){\\n            t.erase(t.begin());\\n        }\\n        return t;\\n        \\n    }\\n};\\n```\\n\\n*Runtime: 52 ms, faster than 43.10% of C++ online submissions for Largest Divisible Subset.\\nMemory Usage: 8.6 MB, less than 52.64% of C++ online submissions for Largest Divisible Subset.*\\n\\n**python code**\\n\\n```\\nclass Solution(object):\\n     def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n <= 1:\\n            return nums\\n        nums.sort()\\n        dp = [(0, 0)] * n\\n        dp[0] = (1, 0)\\n        maxIndex, maxVal = 0, 1\\n        for i in range(1, n):\\n            dp[i] = max((dp[j][0] + 1, j) for j in range(i + 1) if nums[i] % nums[j] is 0)\\n            if dp[i] > maxVal:\\n                maxIndex, maxVal = i, dp[i]\\n        i, lds = maxIndex, [nums[maxIndex]]\\n        while i != dp[i][1]:\\n            i = dp[i][1]\\n            lds.append(nums[i])\\n        return lds\\n        \\n```\\n\\n*Runtime: 436 ms, faster than 26.39% of Python online submissions for Largest Divisible Subset.\\nMemory Usage: 13 MB, less than 24.36% of Python online submissions for Largest Divisible Subset.*\\n\\n\\n**java**\\n\\n```\\nclass Solution {\\n  // if we sort the array, every element in a divisibleSubset can be divisible by the element just before it.\\n// for any element k, its largestDivisibleSubset that ends with k can be formed in the following way: \\n// use element k after any one of the previous elements that is divisble \\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n    int[] l = new int[nums.length]; // the length of largestDivisibleSubset that ends with element i\\n    int[] prev = new int[nums.length]; // the previous index of element i in the largestDivisibleSubset ends with element i\\n    \\n    Arrays.sort(nums);\\n    \\n    int max = 0;\\n    int index = -1;\\n    for (int i = 0; i < nums.length; i++){\\n        l[i] = 1;\\n        prev[i] = -1;\\n        for (int j = i - 1; j >= 0; j--){\\n            if (nums[i] % nums[j] == 0 && l[j] + 1 > l[i]){\\n                l[i] = l[j] + 1;\\n                prev[i] = j;\\n            }\\n        }\\n        if (l[i] > max){\\n            max = l[i];\\n            index = i;\\n        }\\n    }\\n    List<Integer> res = new ArrayList<Integer>();\\n    while (index != -1){\\n        res.add(nums[index]);\\n        index = prev[index];\\n    }\\n    return res;\\n}\\n\\n}\\n```\\n\\n*Runtime: 16 ms, faster than 78.50% of Java online submissions for Largest Divisible Subset.\\nMemory Usage: 39.4 MB, less than 87.96% of Java online submissions for Largest Divisible Subset.*\\n\\nreferences:-  geeks\\n\\n**if it helps please upvote if you have any doubt comment it**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return nums;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int flag=1;\\n        if(nums[0]==1){\\n            flag=0;\\n        }\\n        else{\\n            nums.push_back(1);\\n            flag=1;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int dp[nums.size()][2];\\n        for(i=nums.size()-1;i>=0;i--){\\n            dp[i][0]=0;\\n            dp[i][1]=i;\\n            for(j=i+1;j<nums.size();j++){\\n                if((nums[j]%nums[i])==0){\\n                    if(dp[j][0]>dp[i][0]){\\n                        dp[i][0]=dp[j][0];\\n                        dp[i][1]=j;\\n                    }  \\n                }\\n            }\\n            dp[i][0]++;\\n        }\\n        i=0;\\n        vector<int> t;\\n        t.push_back(nums[i]);\\n        while(dp[i][1]!=i){\\n            i=dp[i][1];\\n            t.push_back(nums[i]);\\n            \\n        }\\n        if(flag==1){\\n            t.erase(t.begin());\\n        }\\n        return t;\\n        \\n    }\\n};\\n```\n```\\nclass Solution(object):\\n     def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n <= 1:\\n            return nums\\n        nums.sort()\\n        dp = [(0, 0)] * n\\n        dp[0] = (1, 0)\\n        maxIndex, maxVal = 0, 1\\n        for i in range(1, n):\\n            dp[i] = max((dp[j][0] + 1, j) for j in range(i + 1) if nums[i] % nums[j] is 0)\\n            if dp[i] > maxVal:\\n                maxIndex, maxVal = i, dp[i]\\n        i, lds = maxIndex, [nums[maxIndex]]\\n        while i != dp[i][1]:\\n            i = dp[i][1]\\n            lds.append(nums[i])\\n        return lds\\n        \\n```\n```\\nclass Solution {\\n  // if we sort the array, every element in a divisibleSubset can be divisible by the element just before it.\\n// for any element k, its largestDivisibleSubset that ends with k can be formed in the following way: \\n// use element k after any one of the previous elements that is divisble \\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n    int[] l = new int[nums.length]; // the length of largestDivisibleSubset that ends with element i\\n    int[] prev = new int[nums.length]; // the previous index of element i in the largestDivisibleSubset ends with element i\\n    \\n    Arrays.sort(nums);\\n    \\n    int max = 0;\\n    int index = -1;\\n    for (int i = 0; i < nums.length; i++){\\n        l[i] = 1;\\n        prev[i] = -1;\\n        for (int j = i - 1; j >= 0; j--){\\n            if (nums[i] % nums[j] == 0 && l[j] + 1 > l[i]){\\n                l[i] = l[j] + 1;\\n                prev[i] = j;\\n            }\\n        }\\n        if (l[i] > max){\\n            max = l[i];\\n            index = i;\\n        }\\n    }\\n    List<Integer> res = new ArrayList<Integer>();\\n    while (index != -1){\\n        res.add(nums[index]);\\n        index = prev[index];\\n    }\\n    return res;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84006,
                "title": "classic-dp-solution-similar-to-lis-o-n-2",
                "content": "Use DP to track max Set and pre index.\\n\\n    public class Solution {\\n        public List<Integer> largestDivisibleSubset(int[] nums) {\\n            int n = nums.length;\\n            int[] count = new int[n];\\n            int[] pre = new int[n];\\n            Arrays.sort(nums);\\n            int max = 0, index = -1;\\n            for (int i = 0; i < n; i++) {\\n                count[i] = 1;\\n                pre[i] = -1;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (nums[i] % nums[j] == 0) {\\n                        if (1 + count[j] > count[i]) {\\n                            count[i] = count[j] + 1;\\n                            pre[i] = j;\\n                        }\\n                    }\\n                }\\n                if (count[i] > max) {\\n                    max = count[i];\\n                    index = i;\\n                }\\n            }\\n            List<Integer> res = new ArrayList<>();\\n            while (index != -1) {\\n                res.add(nums[index]);\\n                index = pre[index];\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public List<Integer> largestDivisibleSubset(int[] nums) {\\n            int n = nums.length;\\n            int[] count = new int[n];\\n            int[] pre = new int[n];\\n            Arrays.sort(nums);\\n            int max = 0, index = -1;\\n            for (int i = 0; i < n; i++) {\\n                count[i] = 1;\\n                pre[i] = -1;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (nums[i] % nums[j] == 0) {\\n                        if (1 + count[j] > count[i]) {\\n                            count[i] = count[j] + 1;\\n                            pre[i] = j;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 84002,
                "title": "4-lines-in-python",
                "content": "    def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))\\n\\nMy `S[x]` is the largest subset with `x` as the largest element, i.e., the subset of all divisors of `x` in the input. With `S[-1] = emptyset` as useful base case. Since divisibility is transitive, a multiple `x` of some divisor `d` is also a multiple of all elements in `S[d]`, so it's not necessary to explicitly test divisibility of `x` by all elements in `S[d]`. Testing `x % d` suffices.\\n\\nWhile storing entire subsets isn't super efficient, it's also not that bad. To extend a subset, the new element must be divisible by all elements in it, meaning it must be at least twice as large as the largest element in it. So with the 31-bit integers we have here, the largest possible set has size 31 (containing all powers of 2).",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))\\n\\nMy `S[x]` is the largest subset with `x` as the largest element, i.e., the subset of all divisors of `x` in the input. With `S[-1] = emptyset` as useful base case. Since divisibility is transitive, a multiple `x` of some divisor `d` is also a multiple of all elements in `S[d]`, so it's not necessary to explicitly test divisibility of `x` by all elements in `S[d]`. Testing `x % d` suffices.\\n\\nWhile storing entire subsets isn't super efficient, it's also not that bad. To extend a subset, the new element must be divisible by all elements in it, meaning it must be at least twice as large as the largest element in it. So with the 31-bit integers we have here, the largest possible set has size 31 (containing all powers of 2).",
                "codeTag": "Python3"
            },
            {
                "id": 684738,
                "title": "python-short-dp-with-o-n-2-explained-update",
                "content": "First of all, notice, that if we need to find `3` numbers  given properties, than if we put then in decreasing order `a > b > c`, than it is sufficient and enough that `a%b = 0` and `b%c=0`, then it is automatically `a%c=0`. \\n\\nLet us now sort our numbers and in `sol[i]` list keep the best solution, where the biggest number is equal to `nums[i]`. How can we find it? Look at all smaller numbers and if `nums[i]` is divisible by this smaller number, we can update solution. Let us go through example: `nums = [4,5,8,12,16,20].`\\n1. `sol[0] = [4]`, the biggest divisible subset has size `1`.\\n2. `sol[1] = [5]`, because `5 % 4 != 0`.\\n3. `sol[2] = [4,8]`, because `8 % 4 = 0`.\\n4. `sol[3] = [4,12]`, because `12 % 4 = 0`. \\n5. `sol[4] = [4,8,16]`, because `16 % 8 = 0` and `16 % 4 = 0` and we choose `8`, because it has longer set.\\n6. `sol[5] = [4,20]` (or `[5,20]` in fact, but it does not matter). We take `[4,20]`, because it has the biggest length and when we see `5`, we do not update it.\\n7. Finally, answer is `[4,8,16]`.\\n\\n\\n**Complexity**: time complexity is `O(n^2)`, because we fist sort our numbers and then we have double loop. Space complexity also potentially `O(n^2)`, but for big `n`, length of the longest subset will not be more than `32`: (each time you new number will be at least twice bigger than previous, so there will be maximum 32 numbers in our set) so so we can say it is `O(32n)`.\\n\\n### Possible improvements\\nNote similarity of this problem with problem **300 Longest Increasing Subsequence**, however it is different, and we can not apply `O(n log n)` algorighm here directly, when we add new number we can not use binary search.\\nThere is idea by **@yanrucheng** with comlexity `O(nlogn + n*sqrt(V))`, where `V` is the biggest number. I am interested, if there is `O(n log n)` solution here? If you know such method please let me know!\\n\\n\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        if len(nums) == 0: return []\\n        nums.sort()\\n        sol = [[num] for num in nums]\\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0 and len(sol[i]) < len(sol[j]) + 1:\\n                    sol[i] = sol[j] + [nums[i]]\\n        return max(sol, key=len)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        if len(nums) == 0: return []\\n        nums.sort()\\n        sol = [[num] for num in nums]\\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0 and len(sol[i]) < len(sol[j]) + 1:\\n                    sol[i] = sol[j] + [nums[i]]\\n        return max(sol, key=len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 83998,
                "title": "c-solution-with-explanations",
                "content": "The key concept here is:\\n  Given a set of integers that satisfies the property that each pair of integers inside the set are mutually divisible, for a new integer S, S can be placed into the set as long as it can divide the smallest number of the set or is divisible by the largest number of the set.\\n\\t\\nFor example, let's say we have a set P = { 4, 8, 16 }, P satisfies the divisible condition. Now consider a new number 2, it can divide the smallest number 4, so it can be placed into the set; similarly, 32 can be divided by 16, the biggest number in P, it can also placed into P.\\n\\nNext, let's define:\\n\\n**EDIT: For clarification, the following definitions try to enlarge candidate solutions by appending a larger element at the end of each potential set, while my implementation below is prefixing a smaller element at the front of a set. Conceptually they are equivalent but by adding smaller elements at the front saves the trouble for keeping the correct increasing order for the final answer. Please refer to comments in code for more details.**\\n\\nFor an increasingly sorted array of integers a[1 .. n]\\n\\nT[n] = the length of the largest divisible subset whose largest number is a[n]\\n\\nT[n+1] = max{ 1 + T[i] if a[n+1] mod a[i] == 0 else 1 }\\n\\nNow, deducting T[n] becomes straight forward with a DP trick. For the final result we will need to maintain a backtrace array for the answer.\\n\\nImplementation in C++:\\n\\n    class Solution {\\n    public:\\n        vector<int> largestDivisibleSubset(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            \\n            vector<int> T(nums.size(), 0);\\n            vector<int> parent(nums.size(), 0);\\n            \\n            int m = 0;\\n            int mi = 0;\\n            \\n            // for(int i = 0; i < nums.size(); ++i) // if extending by larger elements\\n            for(int i = nums.size() - 1; i >= 0; --i) // iterate from end to start since it's easier to track the answer index\\n            {\\n                // for(int j = i; j >=0; --j) // if extending by larger elements\\n                for(int j = i; j < nums.size(); ++j)\\n                {\\n                    // if(nums[i] % nums[j] == 0 && T[i] < 1 + T[j]) // if extending by larger elements\\n                    // check every a[j] that is larger than a[i]\\n                    if(nums[j] % nums[i] == 0 && T[i] < 1 + T[j])\\n                    {\\n                        // if a[j] mod a[i] == 0, it means T[j] can form a larger subset by putting a[i] into T[j]\\n                        T[i] = 1 + T[j];\\n                        parent[i] = j;\\n                        \\n                        if(T[i] > m)\\n                        {\\n                            m = T[i];\\n                            mi = i;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            vector<int> ret;\\n            \\n            for(int i = 0; i < m; ++i)\\n            {\\n                ret.push_back(nums[mi]);\\n                mi = parent[mi];\\n            }\\n\\n            // sort(ret.begin(), ret.end()); // if we go by extending larger ends, the largest \"answer\" element will come first since the candidate element we observe will become larger and larger as i increases in the outermost \"for\" loop above.\\n           // alternatively, we can sort nums in decreasing order obviously. \\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> largestDivisibleSubset(vector<int>& nums) {\\n            sort(nums.begin(), nums.end());\\n            \\n            vector<int> T(nums.size(), 0);\\n            vector<int> parent(nums.size(), 0);\\n            \\n            int m = 0;\\n            int mi = 0;\\n            \\n            // for(int i = 0; i < nums.size(); ++i) // if extending by larger elements\\n            for(int i = nums.size() - 1; i >= 0; --i) // iterate from end to start since it's easier to track the answer index\\n            {\\n                // for(int j = i; j >=0; --j) // if extending by larger elements\\n                for(int j = i; j < nums.size(); ++j)\\n                {\\n                    // if(nums[i] % nums[j] == 0 && T[i] < 1 + T[j]) // if extending by larger elements\\n                    // check every a[j] that is larger than a[i]\\n                    if(nums[j] % nums[i] == 0 && T[i] < 1 + T[j])\\n                    {\\n                        // if a[j] mod a[i] == 0, it means T[j] can form a larger subset by putting a[i] into T[j]\\n                        T[i] = 1 + T[j];\\n                        parent[i] = j;\\n                        \\n                        if(T[i] > m)\\n                        {\\n                            m = T[i];\\n                            mi = i;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 1578991,
                "title": "c-4-simple-solutions-w-detailed-explanation-optimizations-from-brute-force-to-dp",
                "content": "We are given an array `nums` and we need to return the largest subset `ans` such that when we consider any pair of elements `(ans[i], ans[j])`, then \\n* `ans[i] % ans[j] == 0` or,\\n*  `ans[j] % ans[i] == 0`. \\n\\nThis just means that the larger number should divide the smaller in any pair.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nLet\\'s try to solve this using brute-force approach. For every element, we have the choice to either pick it or not pick it. An element can only be picked when it satisfies the above condition. So, before picking any element, we need to check if either of the above 2 conditions are satisfied or not with each of the element already present in current subset.\\n\\nBut there\\'s an **important observation** that allows us to optimize the above checking process. If the largest number in subset formed till now divides the next element to be chosen, then every other element in the subset will divide it as well (because subset formed till now follows above conditions). For eg. Consider our subset till now is `[1,2,6]` and next element is `12`. If 12 divides largest element of subset - 6, it will divide every other element as well. Try for other examples yourself.\\n\\nFirstly, for us to use the above observervation, it means the next element should be greater than all existing elements of subset. Then, we can just check if largest element in subset till now divides it completely. If yes, the required condition is satisfied and we can choose this element. \\n\\nSo, we will sort the `nums` and consider elements to be inserted into subset in increasing order. The process will be as follows -\\n* Initially, subset is empty, so any any element can be a valid starting point. Try for each and see which yield largest subset.\\n* If subset is not empty, let the last chosen element be `nums[start]`. Then we consider every element at index `next` where `start < next< n` to be chosen next. It will be chosen only if `nums[next] % nums[start] == 0`.\\n* We recursively repeat the above process considering `nums[next]` to be previous chosen element and this continues till we reach end of array.\\n* At every recursion step, we will return the largest susbet that\\'s possible when `nums[start]` was the previous chosen element.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 0; i < size(nums); i++) {         // any element is valid choice for 1st subset member\\n            auto res = solve(nums, i);                // try for each & obtain largest subset when nums[i] is starting element\\n            if(size(res) > size(ans)) ans = res;      // keep track of largest subset found\\n        }\\n        return ans;\\n    }\\n    vector<int> solve(vector<int>& nums, int start) {\\n        if(start >= size(nums)) return {};                      // no subset possible when start >= size(nums)\\n        vector<int> ans;\\n        for(int next = start+1; next < size(nums); next++) {    // try next elements \\n            if(nums[next] % nums[start]) continue;              // only those completely divided by nums[start] are valid choice\\n            auto res = solve(nums, next);                       // res = largest subset on choosing nums[next]\\n            if(size(res) >= size(ans)) ans = res;               // ans = largest subset till now when nums[start] is previous element\\n        }\\n        ans.push_back(nums[start]);                             // we didnt include nums[start] in ans. Add it as well\\n        return ans;                                             // return largest subset starting with num[start]\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** **<code>O(N*2<sup>N</sup>) </code>**, where `N` is the number of elements in `nums` array. The recurrence equation for `solve()` can be written as - \\n\\n```\\n                                       \\u2193 for making copies of subset array\\nT(N) = T(N-1)+T(N-2)+T(N-3)+...+T(1) + N = T(N-1)+T(N-1) + N => T(N) = 2T(N-1) + N\\n=> T(N) = 2T(N-1) + N\\n```\\n\\nSolving this using substitution method, we get time complexity as <code>O(2<sup>N</sup>) </code> and we make this call `N` times resulting in total of <code>O(N*2<sup>N</sup>) </code>.\\n***Space Complexity :*** **`O(N)`**, required by implicit recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nDrawing out the recursive tree diagram for above solution, we can find that there lots of repeated function calls and redundant calculations. We can avoid these unnecessary calculations by memoizing the results and reusing them in future calls.\\n\\nHere, we use `dp` to store the largest subset starting with `i`th index element. Once `dp[i]` is calculated, its result can be reused in future calls again instead of recalculating it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> dp;\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 0; i < size(nums); i++) {\\n            auto res = solve(nums, i);\\n            if(size(res) > size(ans)) ans = res;\\n        }\\n        return ans;\\n    }\\n    vector<int> solve(vector<int>& nums, int start) {\\n        if(start >= size(nums)) return {};\\n        if(dp.count(start)) return dp[start];\\n        for(int next = start+1; next < size(nums); next++) {\\n            if(nums[next] % nums[start]) continue;\\n            auto res = solve(nums, next);\\n            if(size(res) >= size(dp[start])) dp[start] = res;\\n        }\\n        dp[start].push_back(nums[start]);\\n        return dp[start];\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** **<code>O(N<sup>3</sup>) </code>**, \\n* For each `i` from `[0...N]`, the largest subset is calculated once. \\n* For each calculation, we make `O(N)` iterations from `j = [i...N]`. \\n* In each of those iteration, we are making a copy of array of largest subset that we get on picking `j`th element. This size of subset array is bounded by `O(N)` and thus requires additional `O(N)` time. \\n* Thus, combining all of this together, the overall time complexity becomes <code>O(N\\\\*N\\\\*N) = O(N<sup>3</sup>)</code>\\n***Space Complexity :*** **<code>O(N<sup>2</sup>)</code>**, required for memoizing all largest subset results in `dp`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Optimized Dynamic Programming - Memoization)***\\n\\nIn the above approach, we were memoizing largest subset starting at `i`th index and each time returning a copy of that subset back to top of recursion tree. This leads to higher time as well as space comeplexity. But there exists another approach that we could use here to do it efficiently.\\n\\nInstead of explicitly generating the largest subset for every index, we can find only the size of **largest subset starting at `i` (given by `dp[i]`) and then try to reconstruct it.** To reconstruct the largest subset, we can keep track of successor element that leads to largest subset starting at index `i`. This reconstruction is similar to the logic used in LIS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dp, succ, ans;\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t// initially dp[i]=1 since we can always form subset of size=1 starting at i. \\n\\t\\t// succ[i]= \\u221E  because we havent found any successors for any subset yet\\n        dp.resize(size(nums), 1), succ.resize(size(nums), INT_MAX);\\n        for(int i = 0; i < size(nums); i++)  solve(nums, i);\\n\\t\\t// reconstruct starting from index where largest subset starts till the end. succ[i] gives next element after each index\\n        for(int i = distance(begin(dp), max_element(begin(dp), end(dp))); i < size(nums); i = succ[i]) \\n            ans.push_back(nums[i]);\\n        return ans;\\n    }\\n    int solve(vector<int>& nums, int start) {\\n        if(start >= size(nums)) return 0;\\n        if(dp[start] != 1) return dp[start];   // initially all dp[i]=1. But if it\\'s updated to store largest subset size, just return it.\\n        for(int next = start+1; next < size(nums); next++) {\\n            if(nums[next] % nums[start]) continue;\\n            int size = solve(nums, next);\\n            if(dp[start] < size + 1) {   // if choosing subset start at nums[next] gives bigger subset at start, choose it\\n                dp[start] = size + 1;    // update dp[i] to store size of largest subset\\n                succ[start] = next;      // next element at dp[i] which yields largest subset\\n            }\\n        }\\n        return dp[start];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>) </code>**, we require `O(NlogN)` for sorting and then each `dp[i]` is computed once by calling `solve`. `solve` takes `O(N)` and is called `N` times. Thus <code>O(N<sup>2</sup>) </code> for computing the `dp` array. The reconstruction of largest subset is done in `O(N)`. Thus, the total time complexity is <code>O(NlogN + N<sup>2</sup> + N) ~ O(N<sup>2</sup>)</code>\\n***Space Complexity :*** **<code>O(N<sup></sup>)</code>**, required for maintaining `dp` and `succ` array\\n\\n---\\n\\n\\n\\n\\u2714\\uFE0F ***Solution - IV (Optimized Dynamic Programming - Tabulation)***\\n\\nThe logic is similar to what\\'s used in the previous approach with only change being that we are doing it from bottom-up iteratively.\\n\\nWe keep a `dp` array where `dp[i]` stores the size of **largest subset ending at `i`**. We also keep another array `pred` where `pred[i]` is used to track the predecessors or previous element of subset ending at `i`th index. This will help us in reconstructing the largest subset, just as `succ` did in above approach.\\n\\nOnce we fill up the dp array, we will start at the index `max_i` having maximum value of `dp[i]` and reconstruct our subset from that. `pred[max_i]` will give us the previous element in largest subset that ended at `max_i`. We can iteratively perform search till `max_i > 0` and push each element into `ans`, and finally return the `ans` array which would be the required largest subset.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = size(nums), max_i = 0;\\n\\t\\t// initially dp[i]=1 since we can always form subset of size=1 ending at i. \\n\\t\\t// pred[i]=-1 because we havent found any predecessors for any subset yet\\n        vector<int> dp(n, 1), pred(n, -1), ans;\\n        for(int i = 1; i < n; i++) {          \\n            for(int j = 0; j < i; j++)     \\n\\t\\t\\t\\t// nums[i] should divide nums[j] if it is to be included in its subset (i.e dp[j])\\n\\t\\t\\t\\t// only include nums[i] in subset ending at j if resultant subset size (dp[j]+1) is larger than already possible (dp[i])\\n                if(nums[i] % nums[j] == 0 && dp[i] < dp[j]+1)\\n                    dp[i] = dp[j]+1, pred[i] = j;  // jth element will be predecessor to subset ending at ith element\\n            if(dp[i] > dp[max_i]) max_i = i;       // keep track of index where largest subset ends\\n        }\\n\\t\\t// start with index where largest subset ended. Reconstruct from that point to the start\\n        for(; max_i >= 0; max_i = pred[max_i]) \\n            ans.push_back(nums[max_i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>) </code>**, we require `O(NlogN)` for sorting and then <code>O(N<sup>2</sup>) </code> for computing the `dp` array and then `O(N)` for reconstruction of subset giving total time complexity of <code>O(NlogN + N<sup>2</sup> + N) ~ O(N<sup>2</sup>)</code>\\n***Space Complexity :*** **<code>O(N<sup></sup>)</code>**, required for maintaining `dp` and `pred` array\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 0; i < size(nums); i++) {         // any element is valid choice for 1st subset member\\n            auto res = solve(nums, i);                // try for each & obtain largest subset when nums[i] is starting element\\n            if(size(res) > size(ans)) ans = res;      // keep track of largest subset found\\n        }\\n        return ans;\\n    }\\n    vector<int> solve(vector<int>& nums, int start) {\\n        if(start >= size(nums)) return {};                      // no subset possible when start >= size(nums)\\n        vector<int> ans;\\n        for(int next = start+1; next < size(nums); next++) {    // try next elements \\n            if(nums[next] % nums[start]) continue;              // only those completely divided by nums[start] are valid choice\\n            auto res = solve(nums, next);                       // res = largest subset on choosing nums[next]\\n            if(size(res) >= size(ans)) ans = res;               // ans = largest subset till now when nums[start] is previous element\\n        }\\n        ans.push_back(nums[start]);                             // we didnt include nums[start] in ans. Add it as well\\n        return ans;                                             // return largest subset starting with num[start]\\n    }\\n};\\n```\n```\\n                                       \\u2193 for making copies of subset array\\nT(N) = T(N-1)+T(N-2)+T(N-3)+...+T(1) + N = T(N-1)+T(N-1) + N => T(N) = 2T(N-1) + N\\n=> T(N) = 2T(N-1) + N\\n```\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> dp;\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        vector<int> ans;\\n        for(int i = 0; i < size(nums); i++) {\\n            auto res = solve(nums, i);\\n            if(size(res) > size(ans)) ans = res;\\n        }\\n        return ans;\\n    }\\n    vector<int> solve(vector<int>& nums, int start) {\\n        if(start >= size(nums)) return {};\\n        if(dp.count(start)) return dp[start];\\n        for(int next = start+1; next < size(nums); next++) {\\n            if(nums[next] % nums[start]) continue;\\n            auto res = solve(nums, next);\\n            if(size(res) >= size(dp[start])) dp[start] = res;\\n        }\\n        dp[start].push_back(nums[start]);\\n        return dp[start];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dp, succ, ans;\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t// initially dp[i]=1 since we can always form subset of size=1 starting at i. \\n\\t\\t// succ[i]= \\u221E  because we havent found any successors for any subset yet\\n        dp.resize(size(nums), 1), succ.resize(size(nums), INT_MAX);\\n        for(int i = 0; i < size(nums); i++)  solve(nums, i);\\n\\t\\t// reconstruct starting from index where largest subset starts till the end. succ[i] gives next element after each index\\n        for(int i = distance(begin(dp), max_element(begin(dp), end(dp))); i < size(nums); i = succ[i]) \\n            ans.push_back(nums[i]);\\n        return ans;\\n    }\\n    int solve(vector<int>& nums, int start) {\\n        if(start >= size(nums)) return 0;\\n        if(dp[start] != 1) return dp[start];   // initially all dp[i]=1. But if it\\'s updated to store largest subset size, just return it.\\n        for(int next = start+1; next < size(nums); next++) {\\n            if(nums[next] % nums[start]) continue;\\n            int size = solve(nums, next);\\n            if(dp[start] < size + 1) {   // if choosing subset start at nums[next] gives bigger subset at start, choose it\\n                dp[start] = size + 1;    // update dp[i] to store size of largest subset\\n                succ[start] = next;      // next element at dp[i] which yields largest subset\\n            }\\n        }\\n        return dp[start];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = size(nums), max_i = 0;\\n\\t\\t// initially dp[i]=1 since we can always form subset of size=1 ending at i. \\n\\t\\t// pred[i]=-1 because we havent found any predecessors for any subset yet\\n        vector<int> dp(n, 1), pred(n, -1), ans;\\n        for(int i = 1; i < n; i++) {          \\n            for(int j = 0; j < i; j++)     \\n\\t\\t\\t\\t// nums[i] should divide nums[j] if it is to be included in its subset (i.e dp[j])\\n\\t\\t\\t\\t// only include nums[i] in subset ending at j if resultant subset size (dp[j]+1) is larger than already possible (dp[i])\\n                if(nums[i] % nums[j] == 0 && dp[i] < dp[j]+1)\\n                    dp[i] = dp[j]+1, pred[i] = j;  // jth element will be predecessor to subset ending at ith element\\n            if(dp[i] > dp[max_i]) max_i = i;       // keep track of index where largest subset ends\\n        }\\n\\t\\t// start with index where largest subset ended. Reconstruct from that point to the start\\n        for(; max_i >= 0; max_i = pred[max_i]) \\n            ans.push_back(nums[max_i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578685,
                "title": "c-easy-solution-standard-lis-variation-intuitive-approach",
                "content": "***NOTE: If you found anyone\\'s post helpful please upvote that post because some persons are downvoting unneccesarily, and you are the one guys that save our post from disappearing.***\\n\\nNow, we have to find the largest divisible subset in a vector of unique integers. In a Divisible subset for all pairs (x, y), we have a propert of either x divides y or y divides x completely, i.e. `x%y==0 or y%x==0`\\n\\n**Idea of the problem:** This problem is a slight variation of a standard DP problem that is Longest Increasing Subsequence. (P.S. If you don\\'t know about LIS, then It would be better to learn LIS first then read this post).\\n\\n**My Approach:**\\n1. We will first sort our vector so that when we are traversing the array, we will always know that the divisor for current element (at index `i` )lies on the left side of the array i.e. `at position less that i`.\\n\\n2. So, we just need to change this one condition in LIS (Longest Increasing Subsequence) algorithm. We need to find the longest increasing subsequence keeping in mind that the current element is getting divided by the last element of previously longest increasing subsequence (I will give the proof of correctness at the end of the code if some people are eager to know more about it)\\n\\n3. I will keep the track of previous index for any current index in a LIS as it will help us in generating the sequence itself.\\n\\nHere goes the code for the approach I mentioned above:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\t\\t\\n\\t\\t// Sorting step\\n        sort(arr.begin(), arr.end());\\n        \\n        vector<int> lis(n, 1); // This will keep the length of LIS that obeys our property of divide\\n\\t\\tvector<int>prev_idx(n, -1); // previous index array to track for previous element in the lis before i\\n        int max{}, index{};\\n \\n        for(int i{}; i<n; ++i){\\n            \\n            for(int j{i-1}; j>=0; --j){\\n                \\n\\t\\t\\t\\t// Here we know arr[i] > arr[j] because of sorting so if arr[j] divides arr[i]\\n\\t\\t\\t\\t// and adding arr[j] to the LIS of arr[i] increases the size of LIS of arr[i],\\n\\t\\t\\t\\t// then we will update the LIS of arr[i] and we store j i.e. the prev index for i in our sequence\\n                if(lis[j]+1 > lis[i] && arr[i]%arr[j] == 0){\\n                    \\n                    lis[i] = lis[j] + 1;\\n                    prev_idx[i] = j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Compute the last index in our LIS that will be the maximum length LIS\\n\\t\\tfor(int i{}; i<n; ++i){\\n            \\n            if(max < lis[i]){\\n                max = lis[i];\\n                index = i;\\n            }\\n        }\\n        \\n        vector<int>divisible_subset{};\\n        \\n\\t\\t// Traverse from last index to the first index in our LIS\\n\\t\\t// and add elements to our result\\n        while(index != -1){\\n            \\n            divisible_subset.push_back(arr[index]);\\n            index = prev_idx[index];\\n        }\\n        \\n        return divisible_subset;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(N x log(N)) + O(N^2) ~ O(N^2)***\\n**Space Complexity:** ***O(2N) ~ O(N)***\\n\\n**Proof of correctness:**\\n\\nLet\\'s say till now we have `[b, c]` in our LIS that has been constructed so far and our current element is `x`.\\n\\nNow if `x%c == 0` (we know `c<=x` because vector is sorted) then it means `c divides x`\\n-> `x = c * k1`\\n-> since `b divides c`, we have `c = b * k2`\\n-> hence `x = c * k1 = (b * k2) * k1 = b * K`\\n-> hence `b also divides x`\\n\\nThis was the intuition behind the sorting and the checking part of our LIS algorithm\\n\\nHope I made it easy enough for you to understand!\\n**Please Upvote \\uD83D\\uDD3C if this post helped you!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\t\\t\\n\\t\\t// Sorting step\\n        sort(arr.begin(), arr.end());\\n        \\n        vector<int> lis(n, 1); // This will keep the length of LIS that obeys our property of divide\\n\\t\\tvector<int>prev_idx(n, -1); // previous index array to track for previous element in the lis before i\\n        int max{}, index{};\\n \\n        for(int i{}; i<n; ++i){\\n            \\n            for(int j{i-1}; j>=0; --j){\\n                \\n\\t\\t\\t\\t// Here we know arr[i] > arr[j] because of sorting so if arr[j] divides arr[i]\\n\\t\\t\\t\\t// and adding arr[j] to the LIS of arr[i] increases the size of LIS of arr[i],\\n\\t\\t\\t\\t// then we will update the LIS of arr[i] and we store j i.e. the prev index for i in our sequence\\n                if(lis[j]+1 > lis[i] && arr[i]%arr[j] == 0){\\n                    \\n                    lis[i] = lis[j] + 1;\\n                    prev_idx[i] = j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Compute the last index in our LIS that will be the maximum length LIS\\n\\t\\tfor(int i{}; i<n; ++i){\\n            \\n            if(max < lis[i]){\\n                max = lis[i];\\n                index = i;\\n            }\\n        }\\n        \\n        vector<int>divisible_subset{};\\n        \\n\\t\\t// Traverse from last index to the first index in our LIS\\n\\t\\t// and add elements to our result\\n        while(index != -1){\\n            \\n            divisible_subset.push_back(arr[index]);\\n            index = prev_idx[index];\\n        }\\n        \\n        return divisible_subset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684783,
                "title": "c-crystal-clear-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& A) {\\n      int n = A.size();\\n      \\n      if(n == 0)\\n          return {};\\n        \\n      //1. Sort A,\\n      //   so that we have to only check A[j]%A[i] and not A[i]%A[j], i < j\\n      \\n      sort(A.begin(), A.end());\\n        \\n      //2. Create a vector, dp,\\n      //    where dp[i] : longest subset, satisfying the required conditions and ending at index i\\n      //initial length of any subset is 1  \\n      vector<int> dp(n, 1);\\n      \\n      //3. Also create a vector, prev_index,\\n      //   because if longest subset ends at some index \\'t\\'\\n      //   we also want the indices of previously included elements in this subset, to form the subset\\n      vector<int> previous_index(n, -1);\\n       \\n      int max_ind = 0; //this keeps track of the index at which the longest subset ends\\n        \\n      //4. logic :\\n      //      for j<i<n,\\n      //      if A[i]%A[j] = 0, then,\\n      //       we can add A[i] to subset having last element as A[j], if and only if,\\n      //       length of subset ending at A[j] after adding A[i] becomes more than length of subset of which A[i] is already a part\\n      //       in other words, if dp[i] < dp[j] + 1   => dp[i] = dp[j]+1  \\n      // also in the process we keep track of previous indices of i, and also the max_ind  \\n      \\n       for(int i=1; i<n; i++) {\\n           for(int j=0; j<i; j++) {\\n               if(A[i]%A[j]==0 and dp[i] < dp[j] + 1) {\\n                   dp[i] = dp[j]+1;\\n                   previous_index[i] = j;\\n               }\\n           }\\n           if(dp[i] > dp[max_ind]) {\\n               max_ind = i;\\n           }\\n       }\\n        \\n      //5. Now we just use max_ind and previous_index to form the final subset  \\n        \\n      vector<int> answer;\\n      int t = max_ind;  \\n      while(t >= 0) {\\n          answer.push_back(A[t]);\\n          t = previous_index[t];\\n      }\\n       \\n      return answer;  \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& A) {\\n      int n = A.size();\\n      \\n      if(n == 0)\\n          return {}",
                "codeTag": "Java"
            },
            {
                "id": 83999,
                "title": "easy-understood-java-dp-solution-in-28ms-with-o-n-2-time",
                "content": "The basic idea is like:\\n\\n    1. Sort\\n    2. Find the length of longest subset\\n    3. Record the largest element of it.\\n    4. Do a loop from the largest element to nums[0], add every element belongs to the longest subset.\\n\\n\\nThe old version cant pass the test case [1,2,4,8,9,72] and [4,8,10,240], thanks for that @Yanning and @svc \\nHere comes the revised version: \\n\\n    public static List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (nums == null || nums.length == 0) return res;\\n        Arrays.sort(nums);\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n\\n        //for each element in nums, find the length of largest subset it has.\\n        for (int i = 1; i < nums.length; i++){\\n            for (int j = i-1; j >= 0; j--){\\n                if (nums[i] % nums[j] == 0){\\n                    dp[i] = Math.max(dp[i],dp[j] + 1);\\n                }\\n            }\\n        }\\n\\n        //pick the index of the largest element in dp.\\n        int maxIndex = 0;\\n        for (int i = 1; i < nums.length; i++){\\n            maxIndex = dp[i] > dp[maxIndex] ?  i :  maxIndex;\\n        }\\n\\n        //from nums[maxIndex] to 0, add every element belongs to the largest subset.\\n        int temp = nums[maxIndex];\\n        int curDp = dp[maxIndex];\\n        for (int i = maxIndex; i >= 0; i--){\\n            if (temp % nums[i] == 0 && dp[i] == curDp){\\n                res.add(nums[i]);\\n                temp = nums[i];\\n                curDp--;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is like:\\n\\n    1. Sort\\n    2. Find the length of longest subset\\n    3. Record the largest element of it.\\n    4. Do a loop from the largest element to nums[0], add every element belongs to the longest subset.\\n\\n\\nThe old version cant pass the test case [1,2,4,8,9,72] and [4,8,10,240], thanks for that @Yanning and @svc \\nHere comes the revised version: \\n\\n    public static List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (nums == null || nums.length == 0) return res;\\n        Arrays.sort(nums);\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n\\n        //for each element in nums, find the length of largest subset it has.\\n        for (int i = 1; i < nums.length; i++){\\n            for (int j = i-1; j >= 0; j--){\\n                if (nums[i] % nums[j] == 0){\\n                    dp[i] = Math.max(dp[i],dp[j] + 1);\\n                }\\n            }\\n        }\\n\\n        //pick the index of the largest element in dp.\\n        int maxIndex = 0;\\n        for (int i = 1; i < nums.length; i++){\\n            maxIndex = dp[i] > dp[maxIndex] ?  i :  maxIndex;\\n        }\\n\\n        //from nums[maxIndex] to 0, add every element belongs to the largest subset.\\n        int temp = nums[maxIndex];\\n        int curDp = dp[maxIndex];\\n        for (int i = maxIndex; i >= 0; i--){\\n            if (temp % nums[i] == 0 && dp[i] == curDp){\\n                res.add(nums[i]);\\n                temp = nums[i];\\n                curDp--;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1578674,
                "title": "c-standard-lis-variation-picture-detailed-explanation-comments-novemberchallenge",
                "content": "This might look like difficult problem but it actually is just a variation of the classic Dynamic Programming problem, Longest Increasing Subsequence. It\\'s all about perspective!\\n\\n**Intuition & Idea**\\n* *Transitivity:* If *z* is divisible by *y*, and *y* is divisible by *x*, then *z* will also be divisible by *x*. In other words, if `z % y == 0` and `y % z == 0`, then `z % x == 0`. Taking some examples will help understand why this works. For instance, take `x = 3, y = 6, z = 18`. \\n* *Sorting:* If we only focus on achieving transitivity for every three numbers in our subset, then also we will get the answer. And since the numbers are distinct, then `x < y < z`. Hence sorting the numbers before processing and then trying to achieve transitivity makes sense!\\n* *LIS:* Once we have sorted our array, then this problem becomes very similar to LIS. It\\'s just that instead of finding the Longest *Increasing* Subsequence, we want to look for the Longest *Divisible* Subsequence/Subset. Hence the algorithm will slightly vary, but the core idea will remain the same. So here, *dp[i]* will represent the length of the longest divisible subsequence which ends at the ith index. The state change would look something like this:\\n```\\nfor j in [0, i - 1]:\\n\\tif nums[j] divides nums[i]:\\n\\t\\tif dp[i] + 1 > dp[j]:\\n\\t\\t\\tdp[j] = dp[i] + 1\\n``` \\n* *Obtaining Subset:* Now that we have the length of the Longest Divisible Subset and know the index where it ends, how do be obtain the entire set? From the above mentioned pseudo code, it is clear that for every *dp[i]*, there will be one *dp[j]* which will preceed it. So we basically need to store this *jth* index which represents the predecessor of the *ith* index. For this, we can simply use another array which tracks predecessors of every index! \\n\\n**Example**\\nRefer to the following picture for better understanding!\\n![image](https://assets.leetcode.com/users/images/780c6367-489a-4466-a222-621416eabfa1_1636937464.6503174.png)\\nThe cells in red in the final row (1, 2, 4, 8) depict the Largest Divisible Subset!\\n\\n**Implementation**\\nThe code is very similar to the traditional LIS. I have used an extra array *child* to track predecessors of indices. Hence, *dp[i]* will tell the length of the Longest Divisible Subset ending at the *ith* index, and *child[i]* will tell the index which comes before the *ith* index in the subset which includes the *ith* index. *child[i]* will be -1, if the *ith* index is the first element in the subset.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        // Sorting: to leverage the transitive property!\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        // Initializing the DP and CHILD arrays\\n        vector<int> dp(n, 1), child(n, -1);\\n        \\n        int imax = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            \\n            // Considering ith element as the last element\\n            // and finding the largest subset it can \\n            // belong to\\n            for(int j = 0; j < i; j++) {\\n                \\n                // Using transitivity, if nums[i] % nums[j] == 0\\n                // then all numbers in the subset ending at j\\n                // will divide num[i] as well!\\n                if(nums[i] % nums[j] == 0) {\\n                    \\n                    // Inclusion of i will increase the size of \\n                    // the subset by 1\\n                    if(1 + dp[j] > dp[i]) {\\n                        dp[i] = 1 + dp[j];\\n                        \\n                        // Setting the predecessor of i\\n                        child[i] = j;\\n                    }\\n                }\\n            }\\n            \\n            // Determining the index where the largest subset ends\\n            if(dp[i] > dp[imax]) {\\n                imax = i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        // Backtracking to obtain the entire largest subset!\\n        // This condition makes sure that the loop stops\\n        // once the first element of the subset is traversed\\n        while(imax != -1) {\\n            ans.push_back(nums[imax]);\\n            imax = child[imax];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity: O(n)*\\n*Time Complexity: O(n^2)*",
                "solutionTags": [],
                "code": "```\\nfor j in [0, i - 1]:\\n\\tif nums[j] divides nums[i]:\\n\\t\\tif dp[i] + 1 > dp[j]:\\n\\t\\t\\tdp[j] = dp[i] + 1\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        // Sorting: to leverage the transitive property!\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        // Initializing the DP and CHILD arrays\\n        vector<int> dp(n, 1), child(n, -1);\\n        \\n        int imax = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            \\n            // Considering ith element as the last element\\n            // and finding the largest subset it can \\n            // belong to\\n            for(int j = 0; j < i; j++) {\\n                \\n                // Using transitivity, if nums[i] % nums[j] == 0\\n                // then all numbers in the subset ending at j\\n                // will divide num[i] as well!\\n                if(nums[i] % nums[j] == 0) {\\n                    \\n                    // Inclusion of i will increase the size of \\n                    // the subset by 1\\n                    if(1 + dp[j] > dp[i]) {\\n                        dp[i] = 1 + dp[j];\\n                        \\n                        // Setting the predecessor of i\\n                        child[i] = j;\\n                    }\\n                }\\n            }\\n            \\n            // Determining the index where the largest subset ends\\n            if(dp[i] > dp[imax]) {\\n                imax = i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        // Backtracking to obtain the entire largest subset!\\n        // This condition makes sure that the loop stops\\n        // once the first element of the subset is traversed\\n        while(imax != -1) {\\n            ans.push_back(nums[imax]);\\n            imax = child[imax];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84013,
                "title": "very-short-java-dfs-solution-using-memoization",
                "content": "The idea is straight-forward, just DFS look for the multiply of current number.\\ne.g. for 2,4,7,8,16,24, first check multiply of 2, found 4 is candidate, then search further for multiply of 4, and so on. There are duplicated calculations, so use memoization to cache the result.\\nThe tricky part is initially (i==0) I set div to be 1 so that every number can start.\\nCause every number is searched n times, so the time complexity is O(n^2)\\n```\\npublic class Solution {\\n    \\n    Map<Integer,List<Integer>> mem = new HashMap<>();\\n    \\n    private List<Integer> helper(int[] nums, int i) {\\n        if(mem.containsKey(i))\\n            return mem.get(i);\\n        List<Integer> maxLenLst = new ArrayList<>();\\n        int div = i==0 ? 1 : nums[i-1];\\n        for(int k=i; k<nums.length; k++) {\\n            if(nums[k] % div == 0) {\\n                // make a copy is crucial here, so that we won't modify the returned List reference\\n                List<Integer> lst = new ArrayList<>(helper(nums, k+1)); \\n                lst.add(nums[k]);\\n                if(lst.size() > maxLenLst.size())\\n                    maxLenLst = lst;\\n            }\\n        }\\n        mem.put(i, maxLenLst);\\n        return maxLenLst;\\n    }\\n    \\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        return helper(nums, 0);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    Map<Integer,List<Integer>> mem = new HashMap<>();\\n    \\n    private List<Integer> helper(int[] nums, int i) {\\n        if(mem.containsKey(i))\\n            return mem.get(i);\\n        List<Integer> maxLenLst = new ArrayList<>();\\n        int div = i==0 ? 1 : nums[i-1];\\n        for(int k=i; k<nums.length; k++) {\\n            if(nums[k] % div == 0) {\\n                // make a copy is crucial here, so that we won't modify the returned List reference\\n                List<Integer> lst = new ArrayList<>(helper(nums, k+1)); \\n                lst.add(nums[k]);\\n                if(lst.size() > maxLenLst.size())\\n                    maxLenLst = lst;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1579321,
                "title": "c-recursive-to-memoization",
                "content": "Recursion Code: This will give TLE.\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void lds(vector<int> temp,int i,int prev,vector<int>& nums){\\n        \\n        if(i>=nums.size()){\\n            if(temp.size()>ans.size())  ans=temp;\\n            return;\\n        }\\n        if(nums[i]%prev==0){  \\n            temp.push_back(nums[i]);\\n            lds(temp,i+1,nums[i],nums);\\n            temp.pop_back();\\n        }\\n        lds(temp,i+1,prev,nums);\\n    }\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> temp;\\n        lds(temp,0,1,nums);\\n        return ans;\\n    }\\n};\\n```\\n\\nFrom Recursion to Memoziation : Accepted\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> dp;\\n    void lds(vector<int> temp,int i,int prev,vector<int>& nums){\\n        if(i>=nums.size()){\\n            if(temp.size()>ans.size()) ans=temp;\\n            return;\\n        }\\n        //We can\\'t directly use temp.size() without typecasting because it will return an unsigned int and hence if() will not work.\\n        if((int)temp.size()>dp[i] && (nums[i]%prev==0)){ \\n            dp[i]=temp.size();\\n            temp.push_back(nums[i]);\\n            lds(temp,i+1,nums[i],nums);\\n            temp.pop_back();\\n        }\\n        lds(temp,i+1,prev,nums);\\n    }\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=nums.size();i++) dp.push_back(-1);\\n        vector<int> temp;\\n        lds(temp,0,1,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void lds(vector<int> temp,int i,int prev,vector<int>& nums){\\n        \\n        if(i>=nums.size()){\\n            if(temp.size()>ans.size())  ans=temp;\\n            return;\\n        }\\n        if(nums[i]%prev==0){  \\n            temp.push_back(nums[i]);\\n            lds(temp,i+1,nums[i],nums);\\n            temp.pop_back();\\n        }\\n        lds(temp,i+1,prev,nums);\\n    }\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> temp;\\n        lds(temp,0,1,nums);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> dp;\\n    void lds(vector<int> temp,int i,int prev,vector<int>& nums){\\n        if(i>=nums.size()){\\n            if(temp.size()>ans.size()) ans=temp;\\n            return;\\n        }\\n        //We can\\'t directly use temp.size() without typecasting because it will return an unsigned int and hence if() will not work.\\n        if((int)temp.size()>dp[i] && (nums[i]%prev==0)){ \\n            dp[i]=temp.size();\\n            temp.push_back(nums[i]);\\n            lds(temp,i+1,nums[i],nums);\\n            temp.pop_back();\\n        }\\n        lds(temp,i+1,prev,nums);\\n    }\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<=nums.size();i++) dp.push_back(-1);\\n        vector<int> temp;\\n        lds(temp,0,1,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578933,
                "title": "java-reuse-longest-increasing-subsequence",
                "content": "**Idea:** Reuse [LC 300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/discuss/333005/Java-or-2-methods-or-DP-and-Patience-Sort)\\n* Sort nums\\n* Find size of longest divisible subset through the same approach as in LIS\\n* Construct LDS by iterating through dp from right to left\\n> **T/S:** O(n\\xB2)/O(n) \\n```\\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n\\tvar dp = new int[nums.length];\\n\\treturn constructLDS(nums, dp, getLDSSize(nums, dp));\\n}\\n\\nprivate int getLDSSize(int[] nums, int[] dp) {\\n\\tArrays.sort(nums);\\n\\tArrays.fill(dp, 1);\\n\\tvar ldsSize = 1;\\n\\n\\tfor (var i = 1; i < nums.length; i++)\\n\\t\\tfor (var j = 0; j < i; j++)\\n\\t\\t\\tif (nums[i] % nums[j] == 0) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j] + 1);\\n\\t\\t\\t\\tldsSize = Math.max(ldsSize, dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\treturn ldsSize;\\n}\\n\\nprivate List<Integer> constructLDS(int[] nums, int[] dp, int ldsSize) {\\n\\tvar prev = -1;\\n\\tvar lds = new LinkedList<Integer>();\\n\\n\\tfor (var i = dp.length - 1; i >= 0; i--)\\n\\t\\tif (dp[i] == ldsSize && (prev == -1 || prev % nums[i] == 0)) {\\n\\t\\t\\tlds.addFirst(nums[i]);\\n\\t\\t\\tldsSize--;\\n\\t\\t\\tprev = nums[i];\\n\\t\\t}\\n\\n\\treturn lds;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n\\tvar dp = new int[nums.length];\\n\\treturn constructLDS(nums, dp, getLDSSize(nums, dp));\\n}\\n\\nprivate int getLDSSize(int[] nums, int[] dp) {\\n\\tArrays.sort(nums);\\n\\tArrays.fill(dp, 1);\\n\\tvar ldsSize = 1;\\n\\n\\tfor (var i = 1; i < nums.length; i++)\\n\\t\\tfor (var j = 0; j < i; j++)\\n\\t\\t\\tif (nums[i] % nums[j] == 0) {\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], dp[j] + 1);\\n\\t\\t\\t\\tldsSize = Math.max(ldsSize, dp[i]);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\treturn ldsSize;\\n}\\n\\nprivate List<Integer> constructLDS(int[] nums, int[] dp, int ldsSize) {\\n\\tvar prev = -1;\\n\\tvar lds = new LinkedList<Integer>();\\n\\n\\tfor (var i = dp.length - 1; i >= 0; i--)\\n\\t\\tif (dp[i] == ldsSize && (prev == -1 || prev % nums[i] == 0)) {\\n\\t\\t\\tlds.addFirst(nums[i]);\\n\\t\\t\\tldsSize--;\\n\\t\\t\\tprev = nums[i];\\n\\t\\t}\\n\\n\\treturn lds;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84093,
                "title": "python-dp-n-2-solution",
                "content": "We first do some math work.  For two numbers, A and B, if A < B, A % B  must > 0 (A != 0).  The only chance A % B == 0 must be A >= B.\\n\\nWith this idea, we sort the list.  Then, the question turns similar to no.300 longest increasing subsequence.  For ith number, its largest divisible subset is the max of subset of any j from 0 - i-1 in which nums[i] % nums[j] == 0.\\n\\n    class Solution(object):\\n        def largestDivisibleSubset(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[int]\\n            \"\"\"\\n            from copy import copy\\n            nums.sort()\\n            n = len(nums)\\n            if n == 0: return []\\n            dp = [0] * n\\n            dp[0] = [nums[0]]\\n            #print(dp)\\n            for i in xrange(1, n):\\n                curNum = nums[i]\\n                maxSet = []\\n                for j in xrange(i):\\n                    if curNum % nums[j] == 0:\\n                        localSet = copy(dp[j])\\n                        if len(localSet) > len(maxSet):\\n                            maxSet = localSet\\n                \\n                maxSet.append(nums[i])\\n                dp[i] = maxSet\\n                #print(dp)\\n            \\n            #print(dp)\\n            res = []\\n            for localSet in dp:\\n                if len(localSet) > len(res):\\n                    res = localSet\\n            return res",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "We first do some math work.  For two numbers, A and B, if A < B, A % B  must > 0 (A != 0).  The only chance A % B == 0 must be A >= B.\\n\\nWith this idea, we sort the list.  Then, the question turns similar to no.300 longest increasing subsequence.  For ith number, its largest divisible subset is the max of subset of any j from 0 - i-1 in which nums[i] % nums[j] == 0.\\n\\n    class Solution(object):\\n        def largestDivisibleSubset(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: List[int]\\n            \"\"\"\\n            from copy import copy\\n            nums.sort()\\n            n = len(nums)\\n            if n == 0: return []\\n            dp = [0] * n\\n            dp[0] = [nums[0]]\\n            #print(dp)\\n            for i in xrange(1, n):\\n                curNum = nums[i]\\n                maxSet = []\\n                for j in xrange(i):\\n                    if curNum % nums[j] == 0:\\n                        localSet = copy(dp[j])\\n                        if len(localSet) > len(maxSet):\\n                            maxSet = localSet\\n                \\n                maxSet.append(nums[i])\\n                dp[i] = maxSet\\n                #print(dp)\\n            \\n            #print(dp)\\n            res = []\\n            for localSet in dp:\\n                if len(localSet) > len(res):\\n                    res = localSet\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 684795,
                "title": "python-o-nlogn-n-sqrt-v-beats-100",
                "content": "**Idea**\\nFirst, sort the array `O(nlogn)`.\\nWe maintain a dictionary `d` where `d[v]` records the longest subsequence **ending with v**.\\nWhen encountering a new value `v`, `v` can only be appended to those subsequence ending with `v`\\'s factors. Thus, we only needs to iterate through `v`\\'s factors, which is `O(sqrt(V))`\\n\\n**Complexity**\\n- time: `O(nlogn + n*sqrt(V)), where V is the size of number`\\n- space: `O(VN)`\\n\\n**Python3**\\n```\\n# factors, O(nlogn + nlogV), V is the size of num in nums\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        def factors(n):\\n            yield 1\\n            for i in range(2, int(math.sqrt(n)) + 1):\\n                if not n % i:\\n                    yield i\\n                    if i * i != n:\\n                        yield n // i\\n                        \\n        nums.sort()                        \\n        d = {}            \\n        for n in nums:\\n            for f in factors(n):\\n                tmp = d.get(f, []) + [n]\\n                d[n] = tmp if len(d.get(n, [])) < len(tmp) else d.get(n, [])\\n        return nums and max(d.values(), key=len)\\n        # AC: 100 ms, beats 100.00%, 13.9 MB\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# factors, O(nlogn + nlogV), V is the size of num in nums\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        def factors(n):\\n            yield 1\\n            for i in range(2, int(math.sqrt(n)) + 1):\\n                if not n % i:\\n                    yield i\\n                    if i * i != n:\\n                        yield n // i\\n                        \\n        nums.sort()                        \\n        d = {}            \\n        for n in nums:\\n            for f in factors(n):\\n                tmp = d.get(f, []) + [n]\\n                d[n] = tmp if len(d.get(n, [])) < len(tmp) else d.get(n, [])\\n        return nums and max(d.values(), key=len)\\n        # AC: 100 ms, beats 100.00%, 13.9 MB\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569449,
                "title": "c-o-n-2-creative-solution-with-explanation-using-graph",
                "content": "We essentially build a divisibility based [poset](https://en.wikipedia.org/wiki/Partially_ordered_set) with nums. This means we consider a >> b if a % b == 0 (if b divides a). ( >> just means \"greater than\", but l needed to differentiate between this new ordering at the standard ordering, which will be denoted by >). \\nFor each new num a we add the poset, we insert it as a \"child\" to any node b such that a >> b and **that a is not >> any of b\\'s children**. Note that this structure is not a tree, since a node can have more than 1 parent. Also note that it is easiest to build it correctly if we go in order from smallest to largest element, since if a is >> b, a is also > b.\\n\\n1. First we insert 1, 2, 3. 1 is the root. Both 2 and 3 are divisible by 1, so they are \"children\" of 1. \\n![image](https://assets.leetcode.com/users/apluscs/image_1586357429.png)\\n2. Next we insert 4 and 5. 4 is divisible by 1, yes, but it is also divisible by 2, which is a child of 1. That means we should not insert it as a child of 1 but actually as a child of 2. \\n![image](https://assets.leetcode.com/users/apluscs/image_1586357647.png)\\n3. Finally, let\\'s insert the rest of the elements. 6 has two parents, since it can be divided by both 2 and 3. Same goes for 10 and 12.\\n![image](https://assets.leetcode.com/users/apluscs/image_1586357935.png)\\n\\nNow once this diagram is built, how can it be used to answer the problem? Notice the problem basically asks for one of the longest \"lines\" from root to any leaf. In this example, we have potential answers [1,2,4,8], [1,2,4,12], [1,2,6,12], [1,3,6,12]. This makes sense, since whenever you add an element to the \"end\" of a preexisting line, you know it is divisible by every element in that line.\\n\\nMy code:\\n\\n```\\nclass Solution {\\npublic:\\n    struct Node{\\n        unordered_set<Node*> kids;\\n        int val;\\n        Node(int val) : val(val){}\\n    };\\n    \\n    vector<int> res;\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        res.clear();\\n        if(nums.empty()) return res;\\n        Node* root = new Node(1);   // \\'assume\\' we have a 1 in nums\\n        for(int num : nums){\\n            Node* curr = new Node(num);\\n            update(root, curr);\\n        }\\n        vector<int> subset;\\n        dfs(root, subset);\\n        if(nums[0] == 1) return res;    // assumption is valid\\n        for(int i = 0; i != res.size(); ++i){    // else we know nums doesn\\'t have a 1\\n            if(res[i] == 1){\\n                res.erase(res.begin() + i); // erase from answer\\n                break;\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    void dfs(Node* root, vector<int>& subset){\\n        subset.push_back(root->val);\\n        if(root->kids.empty()){ // reached the end of the line\\n            if(subset.size() > res.size()) res = subset;    // compare line sizes\\n        }\\n        for(auto kid : root->kids)\\n            dfs(kid, subset);\\n        subset.pop_back();\\n    }\\n    \\n    bool update(Node* root, Node* curr){    // update the poset\\n        int num = curr->val, rum = root->val;\\n        if(num % rum != 0 || num == rum) return false;    // cannot be a member of root\\'s descendants\\n        bool found = false; \\n        for(auto kid : root->kids)\\n            if(update(kid, curr))\\n                found = true;   // curr is divisible by at least one of root\\'s kids\\n        if(!found) root->kids.insert(curr); // only insert if root is the \\'last\\' node that divides curr\\n            \\n        return true;\\n    }\\n};\\n```\\n\\nTime complexity: N log N from sorting, N^2 worst case for updating :/ = O(N^2)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n        unordered_set<Node*> kids;\\n        int val;\\n        Node(int val) : val(val){}\\n    };\\n    \\n    vector<int> res;\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        res.clear();\\n        if(nums.empty()) return res;\\n        Node* root = new Node(1);   // \\'assume\\' we have a 1 in nums\\n        for(int num : nums){\\n            Node* curr = new Node(num);\\n            update(root, curr);\\n        }\\n        vector<int> subset;\\n        dfs(root, subset);\\n        if(nums[0] == 1) return res;    // assumption is valid\\n        for(int i = 0; i != res.size(); ++i){    // else we know nums doesn\\'t have a 1\\n            if(res[i] == 1){\\n                res.erase(res.begin() + i); // erase from answer\\n                break;\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    void dfs(Node* root, vector<int>& subset){\\n        subset.push_back(root->val);\\n        if(root->kids.empty()){ // reached the end of the line\\n            if(subset.size() > res.size()) res = subset;    // compare line sizes\\n        }\\n        for(auto kid : root->kids)\\n            dfs(kid, subset);\\n        subset.pop_back();\\n    }\\n    \\n    bool update(Node* root, Node* curr){    // update the poset\\n        int num = curr->val, rum = root->val;\\n        if(num % rum != 0 || num == rum) return false;    // cannot be a member of root\\'s descendants\\n        bool found = false; \\n        for(auto kid : root->kids)\\n            if(update(kid, curr))\\n                found = true;   // curr is divisible by at least one of root\\'s kids\\n        if(!found) root->kids.insert(curr); // only insert if root is the \\'last\\' node that divides curr\\n            \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84031,
                "title": "java-solution-in-32ms-o-n-2-time-o-n-space",
                "content": "    public class Solution {\\n        public int[] largestDivisibleSubset(int[] nums) {\\n            if(nums.length < 2)\\n                return nums;\\n            else{\\n                Arrays.sort(nums);\\n                int[] parent = new int[nums.length];\\n                int[] count = new int[nums.length];\\n                int max = 0, maxind = -1;\\n                for(int i = nums.length - 1; i >= 0; i--){\\n                    for(int j = i; j < nums.length; j++){\\n                        if(nums[j] % nums[i] == 0 && count[i] < 1 + count[j] ){\\n                            count[i] = 1 + count[j];\\n                            parent[i] = j;\\n                            if(count[i] > max){\\n                                max = count[i];\\n                                maxind = i;\\n                            }\\n                        }\\n                    }\\n                }\\n                int[] res = new int[max];\\n                for(int i = 0; i < max; i++){\\n                    res[i] = nums[maxind];\\n                    maxind = parent[maxind];\\n                }\\n                return res;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int[] largestDivisibleSubset(int[] nums) {\\n            if(nums.length < 2)\\n                return nums;\\n            else{\\n                Arrays.sort(nums);\\n                int[] parent = new int[nums.length];\\n                int[] count = new int[nums.length];\\n                int max = 0, maxind = -1;\\n                for(int i = nums.length - 1; i >= 0; i--){\\n                    for(int j = i; j < nums.length; j++){\\n                        if(nums[j] % nums[i] == 0 && count[i] < 1 + count[j] ){\\n                            count[i] = 1 + count[j];\\n                            parent[i] = j;\\n                            if(count[i] > max){\\n                                max = count[i];\\n                                maxind = i;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 1580106,
                "title": "python-simple-solution-with-detailed-explanation",
                "content": "## Logic\\nSince we have to find the largest subset for which every pair must satisfy either of the following-\\n1. subset[i] % subset[j] == 0 OR\\n2. subset[j] % subset[i] == 0\\n\\nSo if we sort our given array **nums** then we just need to find the laregest subset of **nums** for which every pair(i, j) must satisfy **subset[j] % subset[i] == 0** as subset[i] % subset[j] == 0 will always be false for sorted array.\\n\\nNow, once the given array is sorted, we will iterate it for every index and store the previous elements which satisfies the above modulo condition in divisibleSubset dp array.\\nAt the end we will return the longest divisibleSubset.\\n\\nNow the question arises as how to efficiently fill the divisibleSubset dp array.\\nTo solve the above question we will check for each index how many previous elements satisfy the above modulo equation and whether the divisibleSubset of current index is less than the divisibleSubset of previous indexes.\\nIf any previous index satisfies the above condition then we will update the divisibleSubset of currentIndex by merging the the divisibleSubset of previous index with current item.\\n\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        divisibleSubset = [[num] for num in nums]\\n        \\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if (nums[i] % nums[j]) == 0 and len(divisibleSubset[i]) < len(divisibleSubset[j]) + 1:\\n                    divisibleSubset[i] = divisibleSubset[j] + [nums[i]]\\n                    \\n        return max(divisibleSubset, key=len)\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        divisibleSubset = [[num] for num in nums]\\n        \\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if (nums[i] % nums[j]) == 0 and len(divisibleSubset[i]) < len(divisibleSubset[j]) + 1:\\n                    divisibleSubset[i] = divisibleSubset[j] + [nums[i]]\\n                    \\n        return max(divisibleSubset, key=len)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579386,
                "title": "c-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        vector<int> dp(n, 1), prev_idx(n, -1), res;\\n        int max_idx = 0;\\n        \\n        for (int i=1; i<n; i++) {\\n\\n            for (int j=0; j<i; j++) {\\n                if ((nums[i] % nums[j] == 0) && (dp[i] < dp[j]+1)) {\\n                    dp[i] = dp[j]+1;\\n                    prev_idx[i] = j;\\n                }\\n            }\\n            max_idx = dp[i] > dp[max_idx] ? i : max_idx;\\n        }\\n        \\n        int i = max_idx;\\n        while (i >= 0) {\\n            res.push_back(nums[i]);\\n            i = prev_idx[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        \\n        vector<int> dp(n, 1), prev_idx(n, -1), res;\\n        int max_idx = 0;\\n        \\n        for (int i=1; i<n; i++) {\\n\\n            for (int j=0; j<i; j++) {\\n                if ((nums[i] % nums[j] == 0) && (dp[i] < dp[j]+1)) {\\n                    dp[i] = dp[j]+1;\\n                    prev_idx[i] = j;\\n                }\\n            }\\n            max_idx = dp[i] > dp[max_idx] ? i : max_idx;\\n        }\\n        \\n        int i = max_idx;\\n        while (i >= 0) {\\n            res.push_back(nums[i]);\\n            i = prev_idx[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84033,
                "title": "6ms-c-beats-100-w-explanations",
                "content": "**Solution #1 (TLE)**\\nThis solution builds upon the naive approach of building up a solution by either adding an element to the solution (if it passes the divisibility check) or by skipping the value as all nums are iterated over. Nums is first sorted so that it is easier to test if a new (larger) num satisfies the divisibility check of the current solution by only checking the last element of the solution (others, like @StefanPochmann, have talked about this). Speed is O(2^n), and Space is O(n).\\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz;\\n    vector<int> nums, sol, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        return ( (sPos==0) || ((v%sol[sPos-1])==0) );\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        //\\n        sort (nums.begin(), nums.end());\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```\\n**Solution #2 (Accepted 149ms)**\\nLike Dijkstra's shortest path algorithm, it can be observed that a num should only be considered if it contributes to a better solution (in this case a longer subset). Therefore the distance of a num contributing to any partial solution can be recorded in a 'furthest' vector (where it is found in the solution), of size n, and only be considered again if it has a further solution position. \\n```// don't consider the num 32 in a solution of [1,32,...] when a better solution [1,2,4,32,...] has already been found```\\nSomeone can correct me if I am wrong, but I believe the Speed is O(n^2) and the Space is still O(n). The reason it is no longer O(2^n) is because the the outer loop runs in O(n) while the inner recursive loop now only expands ~once per new divisible num, also O(n). In other words, the recursive portion is like a DFS that walks the remaining nodes once; then, later attempts to visit the same node are rejected for not having a further solution position.\\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz;\\n    vector<int> nums, sol, furthest, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        if ( sPos==0 ) return 1;\\n        if ( (sPos>furthest[i]) && ((v%sol[sPos-1])==0) ) {\\n            furthest[i]=sPos;\\n            return 1;       // mark the position\\n        }\\n        return 0;\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        furthest = vector<int>(nSz,0);\\n        //\\n        sort (nums.begin(), nums.end());\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```\\n**Solution #3 (Accepted 6ms)**\\nAdditional pruning can be added for early rejection of numbers that will not contribute to a better solution than what has already been found, with the below check:\\n```// given input [1...1000] and a current best solution of [1,2,4,8...512], don't proceed with a solution like [1,3,99] or [1,400] because the optimal way to expand these solutions would be to multiply the last number by 2 repeatedly, but a larger best-subset would require a final number > 1000. ```\\nSo a check is added to our iterative loop to see if there remains a large enough num to satisfy this constraint with: largest > num * 2^(difference in solution size to the best known solution size). This check requires O(1) additional complexity leaving the Speed at O(n^2) and the Space O(n).\\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz, largest;\\n    vector<int> nums, sol, furthest, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        if ( sPos==0 ) return 1;\\n        if ( (sPos>furthest[i]) && ((v%sol[sPos-1])==0) ) {\\n            furthest[i]=sPos;\\n            return 1;       // mark the position\\n        }\\n        return 0;\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( bSz>sPos && ((((long)1)<<(bSz-sPos))*nums[i])>largest ) break;\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        furthest = vector<int>(nSz,0);\\n        //\\n        sort (nums.begin(), nums.end());\\n        largest = nums.back();\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz;\\n    vector<int> nums, sol, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        return ( (sPos==0) || ((v%sol[sPos-1])==0) );\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        //\\n        sort (nums.begin(), nums.end());\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```\n```// don't consider the num 32 in a solution of [1,32,...] when a better solution [1,2,4,32,...] has already been found```\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz;\\n    vector<int> nums, sol, furthest, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        if ( sPos==0 ) return 1;\\n        if ( (sPos>furthest[i]) && ((v%sol[sPos-1])==0) ) {\\n            furthest[i]=sPos;\\n            return 1;       // mark the position\\n        }\\n        return 0;\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        furthest = vector<int>(nSz,0);\\n        //\\n        sort (nums.begin(), nums.end());\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```\n```// given input [1...1000] and a current best solution of [1,2,4,8...512], don't proceed with a solution like [1,3,99] or [1,400] because the optimal way to expand these solutions would be to multiply the last number by 2 repeatedly, but a larger best-subset would require a final number > 1000. ```\n```\\nclass Solution {\\n    int bSz=0, sPos=0, nSz, largest;\\n    vector<int> nums, sol, furthest, best=vector<int>(0);\\n    \\n    int passes(int v, int i) {\\n        if ( sPos==0 ) return 1;\\n        if ( (sPos>furthest[i]) && ((v%sol[sPos-1])==0) ) {\\n            furthest[i]=sPos;\\n            return 1;       // mark the position\\n        }\\n        return 0;\\n    }\\n    void rec(int i) {\\n        for ( ; i<nSz; ++i ) {\\n            if ( bSz>sPos && ((((long)1)<<(bSz-sPos))*nums[i])>largest ) break;\\n            if ( passes(nums[i],i) ) {\\n                sol[sPos++]=nums[i];\\n                rec(i+1);   // w/ num[i] in solution\\n                --sPos;\\n            }               // else, w/o num[i] in solution\\n        }\\n        if ( bSz < sPos ) {\\n            bSz = sPos;     // store best\\n            best = vector<int>(sol.begin(), sol.begin()+sPos);\\n        }\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& numsOrig) {\\n        if ( (nSz=numsOrig.size())<=1 ) return numsOrig; \\n        nums = numsOrig;\\n        sol = vector<int>(nSz);\\n        furthest = vector<int>(nSz,0);\\n        //\\n        sort (nums.begin(), nums.end());\\n        largest = nums.back();\\n        //\\n        rec(0);\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579055,
                "title": "similar-to-print-lis-java-code-intutive-and-visualization",
                "content": "This problem is similar to restoring longest subsequence  or print longest subsequence \\nref here : https://cp-algorithms.com/sequences/longest_increasing_subsequence.html\\n\\n\\n\\n**visualize our problem by dp**\\n\\n#### steps:\\n*  **store prevIndex to know index of previous element of subset , help in retrive back subset**\\n*  **len is used to know maxlen subset ending at current index** \\n\\n\\n```\\n[2,3,4,8,9]  ans:[2,4,8]\\n\\nidx               0   1    2     3      4    5     6    7\\n               ---------------------------------------------\\narr              [1 , 2  ,  3  ,  6  ,  36 , 64 , 128 , 256 ]\\nlength/dp         1  | 2  |  2  |  3  |  4  |  3 | 4   | 5\\n            ----------------------------------------------\\nprevIndex         -1 |  0 |  -1  | 1  |  3  |  1 |  5  | 6\\n\\nans: [256,128,64,2,1]\\n```\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int dp[] =   new int[nums.length];\\n        int prev[] =  new int[nums.length];\\n        Arrays.sort(nums);\\n        int maxlen = 0,end = 0, n =  nums.length;\\n        for(int i=0;i<n;i++){\\n            int count  =  1;\\n            int previdx = -1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0 && dp[j]+1>count ){\\n                    count =  dp[j]+1;\\n                    previdx = j;                    \\n                }\\n            }\\n            dp[i] = count;\\n            prev[i] = previdx;\\n            \\n            if(dp[i]>maxlen){\\n                maxlen =  dp[i];\\n                end =  i;\\n            }                        \\n        }\\n        ArrayList<Integer> ans =  new ArrayList<Integer>();\\n        while(end!=-1){\\n            ans.add(nums[end]);\\n            end =  prev[end];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```\\n\\n## comment below if any doubt left \\n### Upvote if find helpful\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n[2,3,4,8,9]  ans:[2,4,8]\\n\\nidx               0   1    2     3      4    5     6    7\\n               ---------------------------------------------\\narr              [1 , 2  ,  3  ,  6  ,  36 , 64 , 128 , 256 ]\\nlength/dp         1  | 2  |  2  |  3  |  4  |  3 | 4   | 5\\n            ----------------------------------------------\\nprevIndex         -1 |  0 |  -1  | 1  |  3  |  1 |  5  | 6\\n\\nans: [256,128,64,2,1]\\n```\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int dp[] =   new int[nums.length];\\n        int prev[] =  new int[nums.length];\\n        Arrays.sort(nums);\\n        int maxlen = 0,end = 0, n =  nums.length;\\n        for(int i=0;i<n;i++){\\n            int count  =  1;\\n            int previdx = -1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0 && dp[j]+1>count ){\\n                    count =  dp[j]+1;\\n                    previdx = j;                    \\n                }\\n            }\\n            dp[i] = count;\\n            prev[i] = previdx;\\n            \\n            if(dp[i]>maxlen){\\n                maxlen =  dp[i];\\n                end =  i;\\n            }                        \\n        }\\n        ArrayList<Integer> ans =  new ArrayList<Integer>();\\n        while(end!=-1){\\n            ans.add(nums[end]);\\n            end =  prev[end];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579111,
                "title": "simple-java-solution-using-recursion-and-memoization-both",
                "content": "```\\n//...APPROCH...\\n\\n//Lets first see the Recursive solution which will help you to understand the memoization one.\\n//like the knapsack every time we had two choices weather to take or not. but here you can compare this with LIS that is we can conclude an element in our list only if it is divisible by previous elelement.\\n\\n//WHY SORTING ?\\n//and why i am sorting the array just to maintain the pairwise possible answer,\\n\\n//Recursive code\\nclass Solution {\\n    static List<Integer> res;\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();\\n        res=new ArrayList<>();\\n\\n        solve(nums,0,1,ans);\\n        return res;\\n    }\\n    static void solve(int nums[], int i, int prev,List<Integer> ans){\\n        \\n        if(i>=nums.length) {\\n            if(ans.size()>res.size()){\\n                res.clear();\\n                res.addAll(ans);\\n            }\\n            return;\\n        }\\n\\t\\t // conisdering into our list ...\\n\\t\\t \\n        if(nums[i]%prev==0 || prev%nums[i]==0){\\n            ans.add(nums[i]);\\n            solve(nums,i+1,nums[i],ans);\\n            ans.remove(ans.size()-1);\\n        }\\n\\t\\t//not considering into list......\\n\\t\\t\\n        solve(nums,i+1,prev,ans);\\n        \\n    }\\n}\\n```\\n\\n```\\n// you might get confused while seeing use of dp array, just remove that dp array then it will be\\n//more clear ans consize for you//\\n\\nclass Solution {\\n    static List<Integer> res;\\n    static int dp[];\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        dp=new int[nums.length+1];\\n        List<Integer> ans=new ArrayList<>();\\n        res=new ArrayList<>();\\n        Arrays.fill(dp,-1);\\n        solve(nums,0,1,ans);\\n        return res;\\n    }\\n    //we have two condtions for every element weather to tkae the eleemnt or not,\\n    //takini=g or adding into my list will happen only if the no. is divisible\\n    \\n    static void solve(int nums[], int i, int prev,List<Integer> ans){\\n        \\n        if(i>=nums.length) {\\n            if(ans.size()>res.size()){\\n                res.clear();\\n                res.addAll(ans);\\n            }\\n            return;\\n        }\\n        // taking condition.....\\n        \\n        if(ans.size()>dp[i] && (nums[i]%prev==0 || prev%nums[i]==0)){\\n            dp[i]=ans.size();\\n            ans.add(nums[i]);\\n            solve(nums,i+1,nums[i],ans);\\n            ans.remove(ans.size()-1);\\n        }\\n        //not taking condition.....\\n        \\n        solve(nums,i+1,prev,ans);  \\n    }\\n}\\n```\\n//DO UPVOTE IF YOU GET THIS, IF YOU NOT DO PING ME!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//...APPROCH...\\n\\n//Lets first see the Recursive solution which will help you to understand the memoization one.\\n//like the knapsack every time we had two choices weather to take or not. but here you can compare this with LIS that is we can conclude an element in our list only if it is divisible by previous elelement.\\n\\n//WHY SORTING ?\\n//and why i am sorting the array just to maintain the pairwise possible answer,\\n\\n//Recursive code\\nclass Solution {\\n    static List<Integer> res;\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> ans=new ArrayList<>();\\n        res=new ArrayList<>();\\n\\n        solve(nums,0,1,ans);\\n        return res;\\n    }\\n    static void solve(int nums[], int i, int prev,List<Integer> ans){\\n        \\n        if(i>=nums.length) {\\n            if(ans.size()>res.size()){\\n                res.clear();\\n                res.addAll(ans);\\n            }\\n            return;\\n        }\\n\\t\\t // conisdering into our list ...\\n\\t\\t \\n        if(nums[i]%prev==0 || prev%nums[i]==0){\\n            ans.add(nums[i]);\\n            solve(nums,i+1,nums[i],ans);\\n            ans.remove(ans.size()-1);\\n        }\\n\\t\\t//not considering into list......\\n\\t\\t\\n        solve(nums,i+1,prev,ans);\\n        \\n    }\\n}\\n```\n```\\n// you might get confused while seeing use of dp array, just remove that dp array then it will be\\n//more clear ans consize for you//\\n\\nclass Solution {\\n    static List<Integer> res;\\n    static int dp[];\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        dp=new int[nums.length+1];\\n        List<Integer> ans=new ArrayList<>();\\n        res=new ArrayList<>();\\n        Arrays.fill(dp,-1);\\n        solve(nums,0,1,ans);\\n        return res;\\n    }\\n    //we have two condtions for every element weather to tkae the eleemnt or not,\\n    //takini=g or adding into my list will happen only if the no. is divisible\\n    \\n    static void solve(int nums[], int i, int prev,List<Integer> ans){\\n        \\n        if(i>=nums.length) {\\n            if(ans.size()>res.size()){\\n                res.clear();\\n                res.addAll(ans);\\n            }\\n            return;\\n        }\\n        // taking condition.....\\n        \\n        if(ans.size()>dp[i] && (nums[i]%prev==0 || prev%nums[i]==0)){\\n            dp[i]=ans.size();\\n            ans.add(nums[i]);\\n            solve(nums,i+1,nums[i],ans);\\n            ans.remove(ans.size()-1);\\n        }\\n        //not taking condition.....\\n        \\n        solve(nums,i+1,prev,ans);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84040,
                "title": "c-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> result(nums.size());\\n        vector<int> ret;\\n        for (int i = 0;i < nums.size();++i) {\\n            for (int j = 0;j < i;++j) {\\n                if (nums[i] % nums[j] == 0 && result[j].size() > result[i].size()) {\\n                    result[i] = result[j];\\n                }\\n            }\\n            result[i].push_back(nums[i]);\\n            if (ret.size() < result[i].size()) ret = result[i];\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nThe total runtime is O(n^2). If any more efficient algorithm, welcome to discuss.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> result(nums.size());\\n        vector<int> ret;\\n        for (int i = 0;i < nums.size();++i) {\\n            for (int j = 0;j < i;++j) {\\n                if (nums[i] % nums[j] == 0 && result[j].size() > result[i].size()) {\\n                    result[i] = result[j];\\n                }\\n            }\\n            result[i].push_back(nums[i]);\\n            if (ret.size() < result[i].size()) ret = result[i];\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714538,
                "title": "classical-dp-similar-to-longest-increasing-subsequence-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector <int> dp(nums.size(), 1);\\n        int maxLen = 1;\\n        for (int i=0; i<nums.size(); i++) {\\n            for (int j=0; j<i; j++) {\\n                if (nums[i] % nums[j] == 0)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        vector <int> ans;\\n        int prev = -1;\\n        for (int i=nums.size() - 1; i>=0; i--) {\\n            if (maxLen == dp[i] && (prev == -1 || prev % nums[i] == 0)) {\\n                ans.emplace_back(nums[i]);\\n                maxLen--;\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector <int> dp(nums.size(), 1);\\n        int maxLen = 1;\\n        for (int i=0; i<nums.size(); i++) {\\n            for (int j=0; j<i; j++) {\\n                if (nums[i] % nums[j] == 0)\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n            }\\n            maxLen = max(maxLen, dp[i]);\\n        }\\n        vector <int> ans;\\n        int prev = -1;\\n        for (int i=nums.size() - 1; i>=0; i--) {\\n            if (maxLen == dp[i] && (prev == -1 || prev % nums[i] == 0)) {\\n                ans.emplace_back(nums[i]);\\n                maxLen--;\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494672,
                "title": "python-longest-increasing-subsequence-idea-clean-concise",
                "content": "```python\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n = len(nums)\\n        dp = [1] * n\\n        path = [-1] * n\\n        iMax = 0\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\\n                    dp[i] = dp[j] + 1\\n                    path[i] = j\\n                    \\n            if dp[iMax] < dp[i]:\\n                iMax = i\\n                \\n        ans = []\\n        while iMax >= 0:\\n            ans.append(nums[iMax])\\n            iMax = path[iMax]\\n        return ans[::-1]\\n```\\nComplexity:\\n- Time: `O(N^2)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n = len(nums)\\n        dp = [1] * n\\n        path = [-1] * n\\n        iMax = 0\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\\n                    dp[i] = dp[j] + 1\\n                    path[i] = j\\n                    \\n            if dp[iMax] < dp[i]:\\n                iMax = i\\n                \\n        ans = []\\n        while iMax >= 0:\\n            ans.append(nums[iMax])\\n            iMax = path[iMax]\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133897,
                "title": "easy-c-dp-lis-solution",
                "content": "```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), maxIndex = 0, ans = INT_MIN;\\n        vector<int> dp(n, 1), parent(n, -1), sol; //dp[i] = maxLength of subset till ith index & parent[i] is used to store the index of element included before we include ith element\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if((nums[j] % nums[i] == 0 || nums[i] % nums[j] == 0) && dp[i] < dp[j] + 1) {\\n                    dp[i] = dp[j] + 1;\\n                    parent[i] = j;\\n                }\\n            }\\n            if(dp[i] > ans) { //update ans and index of last element included when larger subset found\\n                ans = dp[i];\\n                maxIndex = i;\\n            }\\n        }\\n        while(maxIndex != -1) { //push the subset element one by one\\n            sol.push_back(nums[maxIndex]);\\n            maxIndex = parent[maxIndex];\\n        }\\n        return sol;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), maxIndex = 0, ans = INT_MIN;\\n        vector<int> dp(n, 1), parent(n, -1), sol; //dp[i] = maxLength of subset till ith index & parent[i] is used to store the index of element included before we include ith element\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if((nums[j] % nums[i] == 0 || nums[i] % nums[j] == 0) && dp[i] < dp[j] + 1) {\\n                    dp[i] = dp[j] + 1;\\n                    parent[i] = j;\\n                }\\n            }\\n            if(dp[i] > ans) { //update ans and index of last element included when larger subset found\\n                ans = dp[i];\\n                maxIndex = i;\\n            }\\n        }\\n        while(maxIndex != -1) { //push the subset element one by one\\n            sol.push_back(nums[maxIndex]);\\n            maxIndex = parent[maxIndex];\\n        }\\n        return sol;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193011,
                "title": "easily-understandable-python-solution-with-explanation",
                "content": "Basic idea: \\nopt[i] = largest divisible subset that contains nums[i] from elements from 0 to i\\n\\nSteps:\\n1.) sort nums\\n2.) to find opt[i], we need to traverse through nums looking for nums[j] such that nums[i] is divisible nums[j] and that opt[j] is the biggest in size. We can be sure that all the elements in opt[j] can divide nums[i] because of transitive property as nums is sorted\\n3.) traverse through opt array and return the subset with max size\\n\\n```class Solution:\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums.sort()\\n        opt = [[nums[i]] for i in range(len(nums))]\\n        for i in range(1, len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if nums[i] % nums[j] == 0:\\n                    if len(opt[j])+1 > len(opt[i]): \\n                        opt[i] = list(opt[j]) \\n                        opt[i].append(nums[i])\\n        maxcount = 0\\n        ans = []\\n        for temp in opt:\\n            if len(temp) > maxcount:\\n                ans = temp\\n                maxcount = len(temp)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums.sort()\\n        opt = [[nums[i]] for i in range(len(nums))]\\n        for i in range(1, len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if nums[i] % nums[j] == 0:\\n                    if len(opt[j])+1 > len(opt[i]): \\n                        opt[i] = list(opt[j]) \\n                        opt[i].append(nums[i])\\n        maxcount = 0\\n        ans = []\\n        for temp in opt:\\n            if len(temp) > maxcount:\\n                ans = temp\\n                maxcount = len(temp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351834,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        \\n     \\n        n= len(nums)\\n        \\n        if n==0:return []\\n        \\n        nums.sort()\\n        \\n        dp=[ [i] for i in nums]\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                \\n                if nums[i]%nums[j]==0 and len(dp[j])+1 > len(dp[i]):\\n                    \\n                    dp[i] = dp[j]+[nums[i]]\\n        \\n        return max(dp, key=len)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        \\n     \\n        n= len(nums)\\n        \\n        if n==0:return []\\n        \\n        nums.sort()\\n        \\n        dp=[ [i] for i in nums]\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                \\n                if nums[i]%nums[j]==0 and len(dp[j])+1 > len(dp[i]):\\n                    \\n                    dp[i] = dp[j]+[nums[i]]\\n        \\n        return max(dp, key=len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685715,
                "title": "heavily-commented-javascript-optimized-recursive-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar largestDivisibleSubset = function(nums) {\\n    /* Toughy, as there is no hints and nothing mentioned about input size \\n    \\n    First thought is how would sort help us?\\n    And should I start from the back? \\n    Can I avoid doing double work?\\n    \\n    If 8 % 4 === 0 and 8 % 2 === 0, then I shouldn\\'t be calculating 4 % 2 later on maybe\\n    and if 8 4 2, should I even start a new series with 4 and 2?\\n    \\n    Another thought I had was to do the \"include and don\\'t include approach\"\\n    \\n    Let\\'s consider [2,3,4,5,6,7,8]\\n    \\n    I start from the beginning with: use 2 -> [2] and don\\'t use 2 -> []  \\n    Take those 2 arrays recursively to the next stage. \\n    A) [2] can\\'t use 3 so it stays the same\\n    \\n    b) [] can use 3 and can skip 3, so [3] and [] are now in memory\\n    \\n    We\\'d split into many sequences, so there again we should think about: double work?\\n    \\n    Could we use a dp table? dp[i,sequence] = something?\\n    \\n    Something like that? maybe not, since we have distinct numbers. we shouldn\\'t run into\\n    the same sequence twice.\\n    \\n    # Step 1 \\n    Ill try the recursive solution, see how it runs \\n    before I look at other peoples solutions\\n    \\n    ... codeing ....\\n    \\n    Most of the coding was done, and it works but my console.logs show inefficiency.\\n    On to \\n    \\n    # Step 2    \\n    For example, when I\\'ve discovered [ 1, 2, 4 ]\\n    Who would want to be seeing where [1,4] and [2,4] go? \\n    They\\'ll never do better than [1,2,4]\\n    \\n    So im thinking of adding a map that has a count of the best length for my last number\\n    so when I have {\\'4\\': 3} and if I come acrros something that would be \\n    {\\'4\\': 2} I should just kill that strain.\\n    \\n    # Step 3\\n    \\n    My one cheat that I allow myself is go to discuss and search for \"test case\" to find\\n    a nice long one. This post has one: \\n    https://leetcode.com/explore/featured/card/june-leetcoding-challenge/540/week-2-june-8th-june-14th/3359/discuss/591798/Why-is-this-test-case-wrong\\n    \\n    That runs! Cleaned up my console logs, hit submit and it worked on the first go!\\n    \\n    \\n    */\\n    \\n    // sort is necessary. tbh, I am not sure if this is more or less work than the \\n    // DP-ish recursion below.\\n    \\n    nums.sort(function (a,b) {\\n        return a-b;\\n    });\\n    \\n    // keep track of our best array\\n    var max = [];\\n    // Added this for #step 2 look up efficiency\\n    var map = {};\\n    \\n    \\n    var grow = function (arr, index) {\\n        let pushed = false;\\n        \\n       // This line gave me the insight for the optimization of step 2 \\n       // console.log(arr,nums[index]);\\n        \\n        // Test for better lengths\\n        if (arr.length > max.length) {\\n            max = arr;\\n        }\\n        \\n        // End condition\\n        if (index >= nums.length) {\\n            return;\\n        }\\n        \\n        // Use the next number, if we can\\n        if (arr.length === 0) {\\n            grow([nums[index]], index + 1);\\n        } else {\\n            // The test is, does it mod zero with the last added number\\n            if (nums[index] % arr[arr.length-1] === 0) {\\n                \\n                // #Step 2 interject: check if we want to continue this charade\\n                if (map[nums[index]] && map[nums[index]] > (arr.length + 1)) {\\n                    // if i\\'ve already added the current number and that array\\n                    // is longer than what we would be making here, just cut it off\\n                    // In version 1 I did not have this check, just straight up \"use\"\\n                } else {\\n                    // classic clone and add\\n                    let nextarr = [...arr];\\n                    nextarr.push(nums[index]);\\n                    \\n                    // record length for step 2\\n                    map[nums[index]] = nextarr.length;\\n                    \\n                    grow(nextarr, index + 1);\\n                }\\n                \\n                \\n                \\n            }\\n        }\\n        \\n        // Don\\'t use the next number and see where that leads.\\n        grow([...arr], index + 1);     \\n    }\\n    \\n    grow([],0);\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar largestDivisibleSubset = function(nums) {\\n    /* Toughy, as there is no hints and nothing mentioned about input size \\n    \\n    First thought is how would sort help us?\\n    And should I start from the back? \\n    Can I avoid doing double work?\\n    \\n    If 8 % 4 === 0 and 8 % 2 === 0, then I shouldn\\'t be calculating 4 % 2 later on maybe\\n    and if 8 4 2, should I even start a new series with 4 and 2?\\n    \\n    Another thought I had was to do the \"include and don\\'t include approach\"\\n    \\n    Let\\'s consider [2,3,4,5,6,7,8]\\n    \\n    I start from the beginning with: use 2 -> [2] and don\\'t use 2 -> []  \\n    Take those 2 arrays recursively to the next stage. \\n    A) [2] can\\'t use 3 so it stays the same\\n    \\n    b) [] can use 3 and can skip 3, so [3] and [] are now in memory\\n    \\n    We\\'d split into many sequences, so there again we should think about: double work?\\n    \\n    Could we use a dp table? dp[i,sequence] = something?\\n    \\n    Something like that? maybe not, since we have distinct numbers. we shouldn\\'t run into\\n    the same sequence twice.\\n    \\n    # Step 1 \\n    Ill try the recursive solution, see how it runs \\n    before I look at other peoples solutions\\n    \\n    ... codeing ....\\n    \\n    Most of the coding was done, and it works but my console.logs show inefficiency.\\n    On to \\n    \\n    # Step 2    \\n    For example, when I\\'ve discovered [ 1, 2, 4 ]\\n    Who would want to be seeing where [1,4] and [2,4] go? \\n    They\\'ll never do better than [1,2,4]\\n    \\n    So im thinking of adding a map that has a count of the best length for my last number\\n    so when I have {\\'4\\': 3} and if I come acrros something that would be \\n    {\\'4\\': 2} I should just kill that strain.\\n    \\n    # Step 3\\n    \\n    My one cheat that I allow myself is go to discuss and search for \"test case\" to find\\n    a nice long one. This post has one: \\n    https://leetcode.com/explore/featured/card/june-leetcoding-challenge/540/week-2-june-8th-june-14th/3359/discuss/591798/Why-is-this-test-case-wrong\\n    \\n    That runs! Cleaned up my console logs, hit submit and it worked on the first go!\\n    \\n    \\n    */\\n    \\n    // sort is necessary. tbh, I am not sure if this is more or less work than the \\n    // DP-ish recursion below.\\n    \\n    nums.sort(function (a,b) {\\n        return a-b;\\n    });\\n    \\n    // keep track of our best array\\n    var max = [];\\n    // Added this for #step 2 look up efficiency\\n    var map = {};\\n    \\n    \\n    var grow = function (arr, index) {\\n        let pushed = false;\\n        \\n       // This line gave me the insight for the optimization of step 2 \\n       // console.log(arr,nums[index]);\\n        \\n        // Test for better lengths\\n        if (arr.length > max.length) {\\n            max = arr;\\n        }\\n        \\n        // End condition\\n        if (index >= nums.length) {\\n            return;\\n        }\\n        \\n        // Use the next number, if we can\\n        if (arr.length === 0) {\\n            grow([nums[index]], index + 1);\\n        } else {\\n            // The test is, does it mod zero with the last added number\\n            if (nums[index] % arr[arr.length-1] === 0) {\\n                \\n                // #Step 2 interject: check if we want to continue this charade\\n                if (map[nums[index]] && map[nums[index]] > (arr.length + 1)) {\\n                    // if i\\'ve already added the current number and that array\\n                    // is longer than what we would be making here, just cut it off\\n                    // In version 1 I did not have this check, just straight up \"use\"\\n                } else {\\n                    // classic clone and add\\n                    let nextarr = [...arr];\\n                    nextarr.push(nums[index]);\\n                    \\n                    // record length for step 2\\n                    map[nums[index]] = nextarr.length;\\n                    \\n                    grow(nextarr, index + 1);\\n                }\\n                \\n                \\n                \\n            }\\n        }\\n        \\n        // Don\\'t use the next number and see where that leads.\\n        grow([...arr], index + 1);     \\n    }\\n    \\n    grow([],0);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84081,
                "title": "java-dfs-solution-86-ms-with-explanation",
                "content": " My solution uses DFS on the array after it is sorted in ascending order. Why sort in ascending order?\\nLet's pretend our input had the following values {1,6,2,3,4,8,24,9,48} in this order . Suppose we are looking at the pair 6 and 3. We know that 6%3=0 but that doesn't mean every multiple of 3 in 3s longest subset  is also a multiple of 6. For example, 9 is a multiple of 3 but not 6. However, we do know that every multiple of 6 is also a multiple of 3, hence by ordering the array such that 6 occurs after 3 we can recursively get the largest subsets of multiples of 6 (that will be comprised of values >=6) BEFORE forming longest subset of multiples of 3. . Repeat the same process for 9 (another multiple of 3) and so on and keep track of the largest subset that we can add 3 to. Cache the results so as to avoid repeated computation. For example, the subset {24,48} contains multiples of 1,2,3,4 and 6.By caching we avoid recomputing this subset for each of the aforementioned values.\\n\\n\\n\\n \\n\\n    public class Solution {\\n            public List<Integer> largestDivisibleSubset(int[] nums) {\\n                \\n                if(nums==null||nums.length==0)\\n                {\\n                    return Collections.<Integer>emptyList();\\n                }\\n                if(nums.length==1)\\n                {\\n                    List<Integer> ls=new ArrayList<Integer>(1);\\n                    ls.add(nums[0]);\\n                    return ls;\\n                }\\n               Arrays.sort(nums);\\n        \\n             HashMap<Integer,List<Integer>> mp=new HashMap<Integer,List<Integer>>();\\n             List<Integer> maxSubset=null;\\n             for(int i=0;i<nums.length;i++)\\n             {\\n                 List<Integer> ls=null;\\n                    if(!mp.containsKey(i))\\n                    {\\n                        ls=dfs(i,nums,mp);\\n                        \\n                        \\n                    }else\\n                    {\\n                        ls=mp.get(i);\\n                    }\\n                    \\n                    if(maxSubset==null||ls.size()>maxSubset.size())\\n                    {\\n                        maxSubset=ls;\\n                    }\\n            }\\n            return maxSubset;\\n        }\\n        \\n         private List<Integer> dfs(int idx, int[] arr,HashMap<Integer,List<Integer>> mp)\\n         {\\n             if(mp.containsKey(idx))\\n             {\\n                 return mp.get(idx);\\n             }\\n             List<Integer> ls=new ArrayList<Integer>();\\n             \\n             for(int i=idx+1;i<arr.length;i++)\\n             {\\n                 if((arr[i]%arr[idx])==0)\\n                 {\\n                    List<Integer> r=dfs(i,arr,mp);\\n                    if(r.size()>ls.size())\\n                    {\\n                        ls=r;\\n                    }\\n                    \\n                 }\\n             }\\n            \\n             ls=new ArrayList<Integer>(ls);\\n             ls.add(0,arr[idx]);\\n             mp.put(idx,ls);\\n             return ls;\\n            \\n         }\\n        }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n            public List<Integer> largestDivisibleSubset(int[] nums) {\\n                \\n                if(nums==null||nums.length==0)\\n                {\\n                    return Collections.<Integer>emptyList();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 84083,
                "title": "java-dfs-solution-62ms-by-considering-the-problem-as-finding-the-longest-path-in-a-dag",
                "content": "By considering each number as a node and its multiples as connected nodes. We can obtain a DAG. For example, [1,3,4,6] can form a DAG with edges of 1->3, 1->4, 1->6, 3->6. So, the answer is the longest path of 1->3->6. \\n\\nThis is very similar to the [Topological sorting][1] question which should be solved in O(|E|+|V|), linear running time. However, the bottleneck is that the edges are not given and we need to find those edges using O(|V|^2). Therefore, we need to find a better way to find the edges from a current node to all its connected nodes.\\n\\nThe idea is that we store all numbers in a TreeSet so they can be searched by order instead of going  from small to large one by one. The advantage is that we can jump through the numbers that are not a multiple of the current node. i.e. use above example, when stop at 3, we can jump to 6 directly without visiting 4 by knowing the next  multiple of 3 is 3X2=6. And, the next multiple is 3X3 and so on. \\n\\nHowever, this is not enough when we have the case of the big gap, ie, [2, 10000, 10000001]. If we adding factor by one each time, it will take long long time. Therefore, here is the TreeSet coming handy. We find the ceiling of 4 to obtain 10000. In addition, we increase the factor to 10000/2 +1 for next round.\\n\\nOn the side node, this implementation use O(logN) to search the next multiple. A better implementation is to search only the TreeSet which only has numbers greater than the current number by cutting down the TreeSet. Or, using a sorted array and call Arrays.binarySearch(start, end, value).\\n\\n\\n[1]: https://en.wikipedia.org/wiki/Topological_sorting\\n\\n\\n\\n    public class Solution {\\n        TreeSet<Long> mem = new TreeSet<Long>();\\n        long max = 0;\\n        List<Integer> ret = new ArrayList();\\n        Map<Long, List<Integer> > visited = new HashMap<>();\\n       \\n        public List<Integer> helper(long cur) {\\n            if (cur > max || ! mem.contains(cur) ) return null;\\n            if (visited.containsKey(cur)) return visited.get(cur);\\n            List<Integer> list = new ArrayList<>();\\n            long i=2; // the factor for the next multiple of current value\\n            while ( mem.ceiling(cur*i) != null ) { // no more multiple\\n                // use O(log N) to find next multiple\\n                long next = mem.ceiling(cur*i);\\n                if ( next % cur == 0 ) {\\n                    List<Integer> temp = helper(next);\\n                    if (temp != null  && temp.size() > list.size() )\\n                        list = new ArrayList(temp);\\n                }\\n                i=(next/cur)+1; // increase the factor based on the gap. \\n            }\\n            list.add((int)cur);\\n            visited.put(cur, list);\\n            return list;\\n        }\\n        \\n        public List<Integer> largestDivisibleSubset(int[] nums) {\\n            if (nums==null || nums.length ==0) return ret;\\n            int len = nums.length;\\n            if (len == 1) { \\n                ret.add(nums[0]);\\n                return ret;\\n            }\\n            for (int num : nums) {\\n                mem.add((long)num);\\n            }\\n            max = mem.last();\\n            for (int num : nums) { \\n                List<Integer> temp = helper((long)num);\\n                if (temp != null  && temp.size() > ret.size() )\\n                    ret = new ArrayList(temp);\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n        TreeSet<Long> mem = new TreeSet<Long>();\\n        long max = 0;\\n        List<Integer> ret = new ArrayList();\\n        Map<Long, List<Integer> > visited = new HashMap<>();\\n       \\n        public List<Integer> helper(long cur) {\\n            if (cur > max || ! mem.contains(cur) ) return null;\\n            if (visited.containsKey(cur)) return visited.get(cur);\\n            List<Integer> list = new ArrayList<>();\\n            long i=2; // the factor for the next multiple of current value\\n            while ( mem.ceiling(cur*i) != null ) { // no more multiple\\n                // use O(log N) to find next multiple\\n                long next = mem.ceiling(cur*i);\\n                if ( next % cur == 0 ) {\\n                    List<Integer> temp = helper(next);\\n                    if (temp != null  && temp.size() > list.size() )\\n                        list = new ArrayList(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 84099,
                "title": "concise-java-solution-o-n-2-time-o-n-space",
                "content": "    // if we sort the array, every element in a divisibleSubset can be divisible by the element just before it.\\n    // for any element k, its largestDivisibleSubset that ends with k can be formed in the following way: \\n    // use element k after any one of the previous elements that is divisble \\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int[] l = new int[nums.length]; // the length of largestDivisibleSubset that ends with element i\\n        int[] prev = new int[nums.length]; // the previous index of element i in the largestDivisibleSubset ends with element i\\n        \\n        Arrays.sort(nums);\\n        \\n        int max = 0;\\n        int index = -1;\\n        for (int i = 0; i < nums.length; i++){\\n            l[i] = 1;\\n            prev[i] = -1;\\n            for (int j = i - 1; j >= 0; j--){\\n                if (nums[i] % nums[j] == 0 && l[j] + 1 > l[i]){\\n                    l[i] = l[j] + 1;\\n                    prev[i] = j;\\n                }\\n            }\\n            if (l[i] > max){\\n                max = l[i];\\n                index = i;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<Integer>();\\n        while (index != -1){\\n            res.add(nums[index]);\\n            index = prev[index];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    // if we sort the array, every element in a divisibleSubset can be divisible by the element just before it.\\n    // for any element k, its largestDivisibleSubset that ends with k can be formed in the following way: \\n    // use element k after any one of the previous elements that is divisble \\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int[] l = new int[nums.length]; // the length of largestDivisibleSubset that ends with element i\\n        int[] prev = new int[nums.length]; // the previous index of element i in the largestDivisibleSubset ends with element i\\n        \\n        Arrays.sort(nums);\\n        \\n        int max = 0;\\n        int index = -1;\\n        for (int i = 0; i < nums.length; i++){\\n            l[i] = 1;\\n            prev[i] = -1;\\n            for (int j = i - 1; j >= 0; j--){\\n                if (nums[i] % nums[j] == 0 && l[j] + 1 > l[i]){\\n                    l[i] = l[j] + 1;\\n                    prev[i] = j;\\n                }\\n            }\\n            if (l[i] > max){\\n                max = l[i];\\n                index = i;\\n            }\\n        }\\n        List<Integer> res = new ArrayList<Integer>();\\n        while (index != -1){\\n            res.add(nums[index]);\\n            index = prev[index];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3001824,
                "title": "best-solution-in-c-dp-memoization",
                "content": "# Code\\n**PLease Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(int i,vector<int>& nums,vector<int>& vec,vector<int>& dp){\\n        if(i==nums.size()){\\n            if(vec.size()>ans.size())\\n                ans=vec;\\n            return;\\n        }\\n        if(vec.size()==0){\\n            vec.push_back(nums[i]);\\n            helper(i+1,nums,vec,dp);\\n            vec.pop_back();\\n        }\\n        else if((int)vec.size()>dp[i] && nums[i]%vec.back()==0){\\n            dp[i]=vec.size();\\n            vec.push_back(nums[i]);\\n            helper(i+1,nums,vec,dp);\\n            vec.pop_back();\\n        }\\n        helper(i+1,nums,vec,dp);\\n    }\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int> vec;\\n        vector<int> dp(nums.size()+1,-1);\\n        sort(nums.begin(),nums.end());\\n        helper(0,nums,vec,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(int i,vector<int>& nums,vector<int>& vec,vector<int>& dp){\\n        if(i==nums.size()){\\n            if(vec.size()>ans.size())\\n                ans=vec;\\n            return;\\n        }\\n        if(vec.size()==0){\\n            vec.push_back(nums[i]);\\n            helper(i+1,nums,vec,dp);\\n            vec.pop_back();\\n        }\\n        else if((int)vec.size()>dp[i] && nums[i]%vec.back()==0){\\n            dp[i]=vec.size();\\n            vec.push_back(nums[i]);\\n            helper(i+1,nums,vec,dp);\\n            vec.pop_back();\\n        }\\n        helper(i+1,nums,vec,dp);\\n    }\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int> vec;\\n        vector<int> dp(nums.size()+1,-1);\\n        sort(nums.begin(),nums.end());\\n        helper(0,nums,vec,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579885,
                "title": "easiest-java-code-using-memoization-recursion-dynamic-programming",
                "content": "**Here I am using dp Array for storing sizes of all subsets which satisfies the given condition**\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] dp = new int[nums.length+1];\\n        Arrays.fill(dp,-1);\\n        solve(1,0,nums,new ArrayList<>(),res,dp);\\n        return res;\\n    }\\n    void solve(int prev,int curr,int[] nums,ArrayList<Integer> currAns,ArrayList<Integer> res,int[] dp) {\\n        if(curr >= nums.length) {\\n            if(currAns.size() > res.size()) {\\n                res.clear();\\n                res.addAll(currAns);\\n            }\\n            return;\\n        }    \\n        if(dp[curr] < currAns.size() && (prev%nums[curr] ==0 || nums[curr]%prev == 0)) {\\n            dp[curr] = currAns.size();\\n            currAns.add(nums[curr]);\\n            solve(nums[curr],curr+1,nums,currAns,res,dp);\\n            currAns.remove(currAns.size()-1);\\n        }\\n        solve(prev,curr+1,nums,currAns,res,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] dp = new int[nums.length+1];\\n        Arrays.fill(dp,-1);\\n        solve(1,0,nums,new ArrayList<>(),res,dp);\\n        return res;\\n    }\\n    void solve(int prev,int curr,int[] nums,ArrayList<Integer> currAns,ArrayList<Integer> res,int[] dp) {\\n        if(curr >= nums.length) {\\n            if(currAns.size() > res.size()) {\\n                res.clear();\\n                res.addAll(currAns);\\n            }\\n            return;\\n        }    \\n        if(dp[curr] < currAns.size() && (prev%nums[curr] ==0 || nums[curr]%prev == 0)) {\\n            dp[curr] = currAns.size();\\n            currAns.add(nums[curr]);\\n            solve(nums[curr],curr+1,nums,currAns,res,dp);\\n            currAns.remove(currAns.size()-1);\\n        }\\n        solve(prev,curr+1,nums,currAns,res,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579128,
                "title": "java-very-understandable-sol-o-n-2-dp-similar-to-lis-problem-inline-comments",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] v) {\\n        \\n        //first of all we will sort the input array so that we will have to check only one conition i.e v[i]%v[j] such that i>j.\\n        Arrays.sort(v);\\n        int n=v.length;\\n        int [] dp=new int[n];\\n        \\n        //we will initialize the dp array with 1, because there is always a possible set with a single element.\\n        Arrays.fill(dp,1);\\n        \\n        //this step is pretty simple, it is almost exactly as same as Longest Increasing Sequence.\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            // for every v[i] we will check every v[j] before it and if it satisfies our condition i.e v[i]%v[j], we will update our dp[i].\\n            for(int j=0;j<i;j++)\\n            {\\n                if(v[i]%v[j]==0)\\n                {\\n                    dp[i]=Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        \\n        //this step is just for finding the end position(max(dp[i])) of the required set and the size of that set.\\n        int ind=0;\\n        int m=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(m<dp[i])\\n            {\\n                m=dp[i];\\n                ind=i;\\n            }\\n        }\\n        \\n        \\n        //Now we need m elements in our ans list, obviously the element  v[ind] will be our first element.\\n        \\n        List<Integer> ans=new ArrayList();\\n        ans.add(v[ind]);\\n        \\n        int last=v[ind];\\n        int left=m-1;\\n        ind--;\\n        //last is actually the last inserted element in the ans list.Because we have sorted the array in ascending order, the next coming           element should divide last inserted one.(we are iterating the array in reverse order) and dp[i] at that position should be equal to         left\\n        \\n        \\n        // Now we need m-1 more elements so we iterate the array from ind-1 and whenever we find and index with dp[i]=left and the last inserted element , last is divisible by v[i] we will insert v[i] into ans list and update last element and elements left to be inserted.\\n        for(int i=ind;i>=0;i--)\\n        {\\n            if(left==0)break;\\n            if(dp[i]==left&&last%v[i]==0)\\n            {\\n                ans.add(v[i]);\\n                last=v[i];\\n                left--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nOverall time complexity of the Solution is O(n^2).\\n\\nPlease **Upvote** if you liked it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] v) {\\n        \\n        //first of all we will sort the input array so that we will have to check only one conition i.e v[i]%v[j] such that i>j.\\n        Arrays.sort(v);\\n        int n=v.length;\\n        int [] dp=new int[n];\\n        \\n        //we will initialize the dp array with 1, because there is always a possible set with a single element.\\n        Arrays.fill(dp,1);\\n        \\n        //this step is pretty simple, it is almost exactly as same as Longest Increasing Sequence.\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            // for every v[i] we will check every v[j] before it and if it satisfies our condition i.e v[i]%v[j], we will update our dp[i].\\n            for(int j=0;j<i;j++)\\n            {\\n                if(v[i]%v[j]==0)\\n                {\\n                    dp[i]=Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n        }\\n        \\n        //this step is just for finding the end position(max(dp[i])) of the required set and the size of that set.\\n        int ind=0;\\n        int m=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(m<dp[i])\\n            {\\n                m=dp[i];\\n                ind=i;\\n            }\\n        }\\n        \\n        \\n        //Now we need m elements in our ans list, obviously the element  v[ind] will be our first element.\\n        \\n        List<Integer> ans=new ArrayList();\\n        ans.add(v[ind]);\\n        \\n        int last=v[ind];\\n        int left=m-1;\\n        ind--;\\n        //last is actually the last inserted element in the ans list.Because we have sorted the array in ascending order, the next coming           element should divide last inserted one.(we are iterating the array in reverse order) and dp[i] at that position should be equal to         left\\n        \\n        \\n        // Now we need m-1 more elements so we iterate the array from ind-1 and whenever we find and index with dp[i]=left and the last inserted element , last is divisible by v[i] we will insert v[i] into ans list and update last element and elements left to be inserted.\\n        for(int i=ind;i>=0;i--)\\n        {\\n            if(left==0)break;\\n            if(dp[i]==left&&last%v[i]==0)\\n            {\\n                ans.add(v[i]);\\n                last=v[i];\\n                left--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682598,
                "title": "slow-js-dp",
                "content": "```\\nvar largestDivisibleSubset = function(nums) {\\n    if ( ! nums.length ) return []\\n    nums.sort((a,b)=>a-b)\\n    var dp = Array.from({length:nums.length},(_,i)=>[nums[i]])\\n\\n    for(let i=nums.length-1;i>=0;i--){\\n        for ( let j = i + 1; j < nums.length; j++ ){\\n            if ( dp[i].length <= dp[j].length && dp[j][0] % nums[i] === 0 ) {\\n                dp[i] = [ nums[i], ...dp[j] ]\\n            }\\n        }\\n    }\\n\\n    return dp.reduce( (a,x) => a.length > x.length ? a : x )\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestDivisibleSubset = function(nums) {\\n    if ( ! nums.length ) return []\\n    nums.sort((a,b)=>a-b)\\n    var dp = Array.from({length:nums.length},(_,i)=>[nums[i]])\\n\\n    for(let i=nums.length-1;i>=0;i--){\\n        for ( let j = i + 1; j < nums.length; j++ ){\\n            if ( dp[i].length <= dp[j].length && dp[j][0] % nums[i] === 0 ) {\\n                dp[i] = [ nums[i], ...dp[j] ]\\n            }\\n        }\\n    }\\n\\n    return dp.reduce( (a,x) => a.length > x.length ? a : x )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603058,
                "title": "longest-increasing-subsequence-variant-with-explaination",
                "content": "# Intuition\\nThe problem asks us to find the largest subset of distinct positive integers where each pair of elements satisfies a specific condition. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Approach\\n1. Sort the given input array nums in ascending order. Sorting the array ensures that if nums[i] is divisible by nums[j], then nums[j] will always appear before nums[i] in the sorted array.\\n2. Create a 2D vector dp of size nums.size(). Each element of dp will be a vector that stores the largest subset of elements ending at index i.\\n3. Iterate through each element in nums using the outer loop. For each element at index i, iterate through all the previous elements using the inner loop (from 0 to i-1).\\n4. Check if nums[i] is divisible by nums[j] using the condition nums[i] % nums[j] == 0.\\n    - If the condition is satisfied, update dp[i] with the larger subset among dp[i] and dp[j], where dp[j] represents the largest subset ending at index j.\\n5. After the inner loop, add the current element nums[i] to dp[i] to include it in the subset.\\n6. Compare the size of the current subset dp[i] with the size of the current largest subset ans. If dp[i] is larger, update ans with dp[i].\\n7. After the outer loop, ans will contain the largest subset of distinct positive integers satisfying the given conditions. Return ans.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the size of the input array nums. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n^2) as well. The dp vector has a size of n, and each element of dp is a vector that can have a maximum size of n in the worst case (when all elements of nums form a valid subset).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans;\\n        vector<vector<int>> dp(nums.size());\\n        \\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = 0;j<i;j++){\\n                if(nums[i]%nums[j] == 0 && dp[j].size()>dp[i].size()){\\n                    dp[i] = dp[j];\\n                }\\n            }\\n            dp[i].push_back(nums[i]);\\n            if(ans.size()<dp[i].size())ans = dp[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> ans;\\n        vector<vector<int>> dp(nums.size());\\n        \\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = 0;j<i;j++){\\n                if(nums[i]%nums[j] == 0 && dp[j].size()>dp[i].size()){\\n                    dp[i] = dp[j];\\n                }\\n            }\\n            dp[i].push_back(nums[i]);\\n            if(ans.size()<dp[i].size())ans = dp[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171885,
                "title": "simple-intuitive-approach-c-dp-storing-max-length-for-current-from-any-prev-element",
                "content": "I got a very simple and intutitve approach to solve this problem . The logic that clicked me as soon as I read the problem was that if a[i]%a[j]==0 && a[j]&a[k]==0 , then definetly a[i]%a[k]==0 . So , to find the max length subset i just want an a[i]%a[j]==0 such that a[j] already has max length among all a[i]%a[j]==0.\\n\\nSo, firstly i sort the array , the iterate through the array . I keep track of score of each index (i.e. max length of subset it can form) . So , if for any i , we find any j<i , such that a[i]%a[j]==0 and score[j] is max among all j that satisfy this condition, we make current score[i]=score[j]+1, as we now add just one element to the subset .\\n\\nFor ex , we have  4,8,10,2400 . so if we are at 2400 , we find 2400%10==0, but Score->10 calculated earlier is 0, so we take 8 , as it satisfies 2400%8==0 and also has a better than than 10 . Now score->2400 becomes score->8+1.\\n\\nWe store both the maximum score and the index that has maximum score . Now we just keep adding elements from last element that has max score and decrease our score and check whether current a[i] satisfies (last%a[i]==0 \\n&& score[i]==maxcur).\\n\\nHere , we used dp technique as we use score of previous items to calculate score of current item\\n\\n```\\n    vector<int> largestDivisibleSubset(vector<int>& a) {\\n        int n=a.size();\\n        sort(a.begin(),a.end());\\n        vector<int> score(n,0);\\n        int mx=0,mxi=0;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(a[i]%a[j]==0 && score[j]+1>score[i]){score[i]=score[j]+1;}\\n            }\\n            if(score[i]>mx){mx=score[i];mxi=i;}\\n        }\\n        vector<int> ans;\\n        ans.push_back(a[mxi]);mx--;\\n        int last=a[mxi];\\n        for(int i=mxi-1;i>=0;i--){\\n            if(last%a[i]==0 && score[i]==mx){\\n                ans.push_back(a[i]);mx--;last=a[i];\\n            }\\n        }\\n        if(ans.size()==0){ans.push_back(a[0]);}\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\tPlease like and comment your approach for this problem!!!\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "I got a very simple and intutitve approach to solve this problem . The logic that clicked me as soon as I read the problem was that if a[i]%a[j]==0 && a[j]&a[k]==0 , then definetly a[i]%a[k]==0 . So , to find the max length subset i just want an a[i]%a[j]==0 such that a[j] already has max length among all a[i]%a[j]==0.\\n\\nSo, firstly i sort the array , the iterate through the array . I keep track of score of each index (i.e. max length of subset it can form) . So , if for any i , we find any j<i , such that a[i]%a[j]==0 and score[j] is max among all j that satisfy this condition, we make current score[i]=score[j]+1, as we now add just one element to the subset .\\n\\nFor ex , we have  4,8,10,2400 . so if we are at 2400 , we find 2400%10==0, but Score->10 calculated earlier is 0, so we take 8 , as it satisfies 2400%8==0 and also has a better than than 10 . Now score->2400 becomes score->8+1.\\n\\nWe store both the maximum score and the index that has maximum score . Now we just keep adding elements from last element that has max score and decrease our score and check whether current a[i] satisfies (last%a[i]==0 \\n&& score[i]==maxcur).\\n\\nHere , we used dp technique as we use score of previous items to calculate score of current item\\n\\n```\\n    vector<int> largestDivisibleSubset(vector<int>& a) {\\n        int n=a.size();\\n        sort(a.begin(),a.end());\\n        vector<int> score(n,0);\\n        int mx=0,mxi=0;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(a[i]%a[j]==0 && score[j]+1>score[i]){score[i]=score[j]+1;}\\n            }\\n            if(score[i]>mx){mx=score[i];mxi=i;}\\n        }\\n        vector<int> ans;\\n        ans.push_back(a[mxi]);mx--;\\n        int last=a[mxi];\\n        for(int i=mxi-1;i>=0;i--){\\n            if(last%a[i]==0 && score[i]==mx){\\n                ans.push_back(a[i]);mx--;last=a[i];\\n            }\\n        }\\n        if(ans.size()==0){ans.push_back(a[0]);}\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\tPlease like and comment your approach for this problem!!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2978224,
                "title": "c-easy-and-shorter-solution-standard-lis-variation-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\nReason: There are two nested loops.\\n\\n- Space complexity:\\nSpace Complexity: O(N)\\nReason: We are only using two rows of size n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size() ,ans = -1 ,  lastIndex =-1;\\n        vector<int> dp(n, 1);\\n        vector<int> trace(n, -1);\\n        sort(nums.begin() , nums.end());\\n\\n     for(int i = 0; i < n; i++){\\n          for(int j = 0; j < i; j++){\\n\\n             if((nums[i]%nums[j] == 0) && dp[j] >= dp[i]){ dp[i] = dp[j] + 1;   trace[i] = j;}             \\n         }\\n           if(dp[i] > ans){ans = dp[i];  lastIndex = i;} \\n    }\\n\\n        vector<int>path;\\n        while(lastIndex != -1){\\n            path.push_back(nums[lastIndex]);\\n            lastIndex = trace[lastIndex];\\n        }\\n        reverse(path.begin(), path.end());       \\n          return path;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size() ,ans = -1 ,  lastIndex =-1;\\n        vector<int> dp(n, 1);\\n        vector<int> trace(n, -1);\\n        sort(nums.begin() , nums.end());\\n\\n     for(int i = 0; i < n; i++){\\n          for(int j = 0; j < i; j++){\\n\\n             if((nums[i]%nums[j] == 0) && dp[j] >= dp[i]){ dp[i] = dp[j] + 1;   trace[i] = j;}             \\n         }\\n           if(dp[i] > ans){ans = dp[i];  lastIndex = i;} \\n    }\\n\\n        vector<int>path;\\n        while(lastIndex != -1){\\n            path.push_back(nums[lastIndex]);\\n            lastIndex = trace[lastIndex];\\n        }\\n        reverse(path.begin(), path.end());       \\n          return path;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900583,
                "title": "c-100-faster-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> dp[nums.size()];\\n        int idx=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j <= i; j++){\\n                if(nums[i]%nums[j] == 0) {\\n                    if(dp[i].size() <= dp[j].size())\\n                    {\\n                        dp[i] = dp[j];\\n                    }\\n                }\\n            }\\n            dp[i].push_back(nums[i]);\\n            if(dp[i].size() >= dp[idx].size()) idx = i;\\n        }     \\n        return dp[idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> dp[nums.size()];\\n        int idx=0;\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j <= i; j++){\\n                if(nums[i]%nums[j] == 0) {\\n                    if(dp[i].size() <= dp[j].size())\\n                    {\\n                        dp[i] = dp[j];\\n                    }\\n                }\\n            }\\n            dp[i].push_back(nums[i]);\\n            if(dp[i].size() >= dp[idx].size()) idx = i;\\n        }     \\n        return dp[idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579246,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        nums.sort()\\n        res = [[num] for num in nums]  #contains sets starting with that number\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                if (nums[i] % nums[j]) == 0 and len(res[i]) < len(res[j]) + 1:  #to ensure the length of the set is maximal \\n                    res[i] = res[j] + [nums[i]]\\n                    \\n        return max(res, key=len)  #return max length set\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        nums.sort()\\n        res = [[num] for num in nums]  #contains sets starting with that number\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                if (nums[i] % nums[j]) == 0 and len(res[i]) < len(res[j]) + 1:  #to ensure the length of the set is maximal \\n                    res[i] = res[j] + [nums[i]]\\n                    \\n        return max(res, key=len)  #return max length set\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579057,
                "title": "java-solution-withough-math-using-directecd-graph-dfs-memoization-runtime-o-n-2",
                "content": "Idea for this solution is to build a directed graph  where an edge `i -> j` means `nums[i] % nums[j] == 0`.\\nsince the numbers in `nums` are unique, the built graph will not have any cycle i.e we will end up with Directed Acyclic Graph.\\nNow the answer is simply the nodes in longest path in this graph.\\nWe cas use DFS to find this. While running the DFS we will mainting pointer to next Id which gives the maximum length.\\nAfter we run the DFS, we can simply use the next pointer to build the answer list.\\n\\nHowever, as we are using DFS, we might calculate the length for same node again and again.\\nTo prevent this we can use memoisation to keep track of maximum length we have seen from the node and return it directly without running DFS if we had calculated the length for this node earlier.\\n\\nTo build the graph, it will take `O(n ^2)` time.\\nSince it it Acyclic graph, there will be at most `n ^ 2` edges and the  DFS will take `O(V + E) = O(n + n ^ 2) = O(n ^ 2)`\\nThus over all runtime will be `O(n ^ 2)`\\n\\nCode:\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer>[] graph = buildGraph(nums);\\n        \\n        int longest = Integer.MIN_VALUE;\\n        int nextId = 0;\\n        \\n        int[] length = new int[nums.length];\\n        int[] next = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            int len = runDFS(graph, length, next, nums, i);\\n            if (len > longest) {\\n                longest = len;\\n                nextId = i;\\n            }\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        while(nextId != -1) {\\n            ans.add(nums[nextId]);\\n            nextId = next[nextId];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int runDFS(List<Integer>[] graph, int[] length, int[] next, int[] nums, int id) {\\n        if (length[id] != 0) {\\n            return length[id];\\n        }\\n        \\n        int idMaxLen = 1;\\n        int nextId = -1;\\n        for(int child : graph[id]) {\\n            int tempLen = 1 + runDFS(graph, length, next, nums, child);\\n            if (tempLen > idMaxLen) {\\n                idMaxLen = tempLen;\\n                nextId = child;\\n            }\\n        }\\n        \\n        length[id] = idMaxLen;\\n        next[id] = nextId;\\n        \\n        return idMaxLen;\\n    }\\n    \\n    private List<Integer>[] buildGraph(int[] nums) {\\n        List<Integer>[] graph = new ArrayList[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    graph[i].add(j);\\n                }\\n                \\n                if (nums[j] % nums[i] == 0) {\\n                    graph[j].add(i);\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer>[] graph = buildGraph(nums);\\n        \\n        int longest = Integer.MIN_VALUE;\\n        int nextId = 0;\\n        \\n        int[] length = new int[nums.length];\\n        int[] next = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            int len = runDFS(graph, length, next, nums, i);\\n            if (len > longest) {\\n                longest = len;\\n                nextId = i;\\n            }\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        while(nextId != -1) {\\n            ans.add(nums[nextId]);\\n            nextId = next[nextId];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int runDFS(List<Integer>[] graph, int[] length, int[] next, int[] nums, int id) {\\n        if (length[id] != 0) {\\n            return length[id];\\n        }\\n        \\n        int idMaxLen = 1;\\n        int nextId = -1;\\n        for(int child : graph[id]) {\\n            int tempLen = 1 + runDFS(graph, length, next, nums, child);\\n            if (tempLen > idMaxLen) {\\n                idMaxLen = tempLen;\\n                nextId = child;\\n            }\\n        }\\n        \\n        length[id] = idMaxLen;\\n        next[id] = nextId;\\n        \\n        return idMaxLen;\\n    }\\n    \\n    private List<Integer>[] buildGraph(int[] nums) {\\n        List<Integer>[] graph = new ArrayList[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    graph[i].add(j);\\n                }\\n                \\n                if (nums[j] % nums[i] == 0) {\\n                    graph[j].add(i);\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264967,
                "title": "c-solution-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int index=0;\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        vector<int>parent(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]%nums[j]==0&&dp[i]<dp[j]+1)\\n                {\\n                    dp[i]=dp[j]+1;\\n                    parent[i]=j;\\n                }\\n            }\\n            if(dp[i]>dp[index])\\n            {\\n                index=i;\\n            }\\n        }\\n        vector<int>ans;\\n        while(index>=0)\\n        {\\n            ans.push_back(nums[index]);\\n            index=parent[index];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int index=0;\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        vector<int>parent(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]%nums[j]==0&&dp[i]<dp[j]+1)\\n                {\\n                    dp[i]=dp[j]+1;\\n                    parent[i]=j;\\n                }\\n            }\\n            if(dp[i]>dp[index])\\n            {\\n                index=i;\\n            }\\n        }\\n        vector<int>ans;\\n        while(index>=0)\\n        {\\n            ans.push_back(nums[index]);\\n            index=parent[index];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685850,
                "title": "python-3-solution-using-tree-approach-faster-than-99-with-comments",
                "content": "**Idea**\\nGiven a sorted list of numbers, build a tree where each child node value is divisible by its parent node value. Compared to DP, you do not need to process all previous nodes.\\n\\nFor example:\\n```\\nnums = [1,2,3,4,5,6,7,8,9,18,20]\\n```\\nWhen you process 7, you do not check against 4 and 6, since it stops at nodes 2 and 3 that would get to 4 and 6.\\nWhen you process 20, you do not check against 9 and 18, since it will stop at nodes 3 and 6, which would get to nodes 9 and 18.\\n\\n**Implementation**\\n```\\nclass Node:\\n    def __init__(self, val, depth, subset):\\n        self.val = val\\n        self.depth = depth\\n        self.children = []\\n        self.subset = subset\\n\\n\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        def traverse(node, val):\\n            add_child = True\\n            for child in node.children:\\n                if not val % child.val:\\n                    # current value is divisible by value of child node\\n                    traverse(child, val)\\n                    # if we found a child node, then we do not want to add a node\\n                    # since it will have a lower depth\\n                    add_child = False\\n\\t\\t\\t\\t\\t\\n            if add_child:\\n                # add as child to current node since current value is not divisible by any child\\n                new_node = Node(val, node.depth + 1, node.subset + [val])\\n                node.children.append(new_node)\\n\\t\\t\\t\\t\\n                # check if new node has biggest subset\\n                if new_node.depth > max_depth[0]:\\n                    max_depth[0] = new_node.depth\\n                    max_depth_node[0] = new_node\\n\\t\\t\\t\\t\\t\\n\\t\\t# handle trivial cases of empty input and single value\\n        if len(nums) < 2:\\n            return nums\\n\\n        # we require a sorted list for processing\\n        nums = sorted(nums)\\n\\n        # create root node with value 1 since all other values are divisible by 1\\n        # check if 1 is in nums, if not, add it but with depth 0 instead of 1 (and empty subset)\\n        if nums[0] != 1:\\n            root = Node(val=1, depth=0, subset=[])\\n        else:\\n            root = Node(val=1, depth=1, subset=[1])\\n\\n        # track node with maximum depth\\n        max_depth_node = [root]\\n        # track maximum depth (= length of subset) to not recalculate from subset length\\n        max_depth = [0]\\n\\n        for num in nums[root.depth:]:\\n            traverse(root, num)\\n\\n\\t\\t# return largest subset\\n        return max_depth_node[0].subset\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nnums = [1,2,3,4,5,6,7,8,9,18,20]\\n```\n```\\nclass Node:\\n    def __init__(self, val, depth, subset):\\n        self.val = val\\n        self.depth = depth\\n        self.children = []\\n        self.subset = subset\\n\\n\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        def traverse(node, val):\\n            add_child = True\\n            for child in node.children:\\n                if not val % child.val:\\n                    # current value is divisible by value of child node\\n                    traverse(child, val)\\n                    # if we found a child node, then we do not want to add a node\\n                    # since it will have a lower depth\\n                    add_child = False\\n\\t\\t\\t\\t\\t\\n            if add_child:\\n                # add as child to current node since current value is not divisible by any child\\n                new_node = Node(val, node.depth + 1, node.subset + [val])\\n                node.children.append(new_node)\\n\\t\\t\\t\\t\\n                # check if new node has biggest subset\\n                if new_node.depth > max_depth[0]:\\n                    max_depth[0] = new_node.depth\\n                    max_depth_node[0] = new_node\\n\\t\\t\\t\\t\\t\\n\\t\\t# handle trivial cases of empty input and single value\\n        if len(nums) < 2:\\n            return nums\\n\\n        # we require a sorted list for processing\\n        nums = sorted(nums)\\n\\n        # create root node with value 1 since all other values are divisible by 1\\n        # check if 1 is in nums, if not, add it but with depth 0 instead of 1 (and empty subset)\\n        if nums[0] != 1:\\n            root = Node(val=1, depth=0, subset=[])\\n        else:\\n            root = Node(val=1, depth=1, subset=[1])\\n\\n        # track node with maximum depth\\n        max_depth_node = [root]\\n        # track maximum depth (= length of subset) to not recalculate from subset length\\n        max_depth = [0]\\n\\n        for num in nums[root.depth:]:\\n            traverse(root, num)\\n\\n\\t\\t# return largest subset\\n        return max_depth_node[0].subset\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685034,
                "title": "beginner-friendly-video-tutorial-intuitive-dp-solution-javascript",
                "content": "video explaination \\n\\nhttps://www.youtube.com/watch?v=pHm5M4vpF34\\n\\n\\nparent reference code mentioned in video\\n\\n```javascript\\nvar largestDivisibleSubset = function(nums) {\\n    if(nums.length < 2) return nums;\\n    let n = nums.length;\\n    nums.sort((a,b) => a - b)\\n    let dp = Array(n).fill(1);\\n    let parent = Array(n);\\n    \\n    for(let i = 0; i < n; i++) parent[i] = i;\\n    \\n    for(let i = 0; i < n; i++) {\\n        for(let j = 0; j < i; j++) {\\n            if(nums[i] % nums[j] === 0) {\\n                if(dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    parent[i] = j;\\n                }\\n            } \\n        }\\n    }\\n    \\n    let max = Math.max(...dp)\\n    let maxIndex = -1;\\n    \\n    for(let i = 0; i < n; i++ ) {\\n        if(dp[i] == max) {\\n            maxIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    \\n    let ans = [];\\n    let member = maxIndex;\\n    while(true) {\\n        ans.push(member)\\n        \\n        if(parent[member] == member) {\\n            break;\\n        }\\n        member = parent[member];\\n    }\\n    return ans.reverse().map(i => nums[i])\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar largestDivisibleSubset = function(nums) {\\n    if(nums.length < 2) return nums;\\n    let n = nums.length;\\n    nums.sort((a,b) => a - b)\\n    let dp = Array(n).fill(1);\\n    let parent = Array(n);\\n    \\n    for(let i = 0; i < n; i++) parent[i] = i;\\n    \\n    for(let i = 0; i < n; i++) {\\n        for(let j = 0; j < i; j++) {\\n            if(nums[i] % nums[j] === 0) {\\n                if(dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    parent[i] = j;\\n                }\\n            } \\n        }\\n    }\\n    \\n    let max = Math.max(...dp)\\n    let maxIndex = -1;\\n    \\n    for(let i = 0; i < n; i++ ) {\\n        if(dp[i] == max) {\\n            maxIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    \\n    let ans = [];\\n    let member = maxIndex;\\n    while(true) {\\n        ans.push(member)\\n        \\n        if(parent[member] == member) {\\n            break;\\n        }\\n        member = parent[member];\\n    }\\n    return ans.reverse().map(i => nums[i])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684909,
                "title": "java-15ms-dp-solution-beats-97",
                "content": "The basic idea is as given below,\\n1. if input is empty return empty list\\n2. sort the array so that you can identify elements with values less than them and we need to check modulo(%) only upto the current element.\\n3. For each item **`a`** in the array, identify the item **`b`** less than the current item with max number of items in the set . This data need to be stored in an array and in below code array **c** contains this data and along with this keep track of **b** for all **a** by using another array **dp**.  \\n4. If the current **c[i]** value found in above step is the maximum we found so far, update the **max** variable to point to **c[i]** \\n5. Backtrack **dp** array from **max** index and create the list for the calculated number of items\\n\\n```\\n\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        if(nums.length == 0){\\n            return Collections.emptyList();\\n        }\\n        Arrays.sort(nums);\\n        int length = nums.length;\\n        int[] c = new int[length];\\n        int[] dp = new int[length];\\n        Arrays.fill(c, 1);\\n        int max = 0;\\n        for (int i = 1; i < length; i++) {\\n            int e = nums[i];\\n            for (int j = 0; j < i; j++) {\\n                if (e%nums[j] == 0) {\\n                    if(c[i] < c[j]+1){\\n                        dp[i] = j;\\n                        c[i] = c[j]+1;\\n                    }\\n                }\\n            }\\n            if(c[i] > c[max]){\\n                max = i;\\n            }\\n        }\\n        List<Integer> r = new ArrayList<>();\\n        int k =max;\\n        for (int i = c[max]; i > 0; i--) {\\n            r.add(nums[k]);\\n            k = dp[k];\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        if(nums.length == 0){\\n            return Collections.emptyList();\\n        }\\n        Arrays.sort(nums);\\n        int length = nums.length;\\n        int[] c = new int[length];\\n        int[] dp = new int[length];\\n        Arrays.fill(c, 1);\\n        int max = 0;\\n        for (int i = 1; i < length; i++) {\\n            int e = nums[i];\\n            for (int j = 0; j < i; j++) {\\n                if (e%nums[j] == 0) {\\n                    if(c[i] < c[j]+1){\\n                        dp[i] = j;\\n                        c[i] = c[j]+1;\\n                    }\\n                }\\n            }\\n            if(c[i] > c[max]){\\n                max = i;\\n            }\\n        }\\n        List<Integer> r = new ArrayList<>();\\n        int k =max;\\n        for (int i = c[max]; i > 0; i--) {\\n            r.add(nums[k]);\\n            k = dp[k];\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515007,
                "title": "java-simple-dynammic-programming-beats-57-40-java-online-submission",
                "content": "# Runtime: 18 ms, faster than 57.40% of Java online submissions for Largest Divisible Subset.\\n# Memory Usage: 38.9 MB, less than 9.09% of Java online submissions for Largest Divisible Subset.\\n\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        if(nums.length==0) return new ArrayList<>();\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,1);\\n        int index =0,max=1;\\n        for(int i = 1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                dp[i] = nums[i]%nums[j]==0?Math.max(dp[i],dp[j]+1):dp[i];\\n                if(dp[i]>max){\\n                    index = i;\\n                    max = dp[i];\\n                }\\n            }\\n        }\\n        List<Integer> a = new ArrayList<>();\\n        int last = nums[index];a.add(last);max--;\\n        for(int i=index-1;i>=0;i--){\\n            if(last%nums[i]==0&&dp[i]==max){\\n                a.add(nums[i]);\\n                max--;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        if(nums.length==0) return new ArrayList<>();\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,1);\\n        int index =0,max=1;\\n        for(int i = 1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                dp[i] = nums[i]%nums[j]==0?Math.max(dp[i],dp[j]+1):dp[i];\\n                if(dp[i]>max){\\n                    index = i;\\n                    max = dp[i];\\n                }\\n            }\\n        }\\n        List<Integer> a = new ArrayList<>();\\n        int last = nums[index];a.add(last);max--;\\n        for(int i=index-1;i>=0;i--){\\n            if(last%nums[i]==0&&dp[i]==max){\\n                a.add(nums[i]);\\n                max--;\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84005,
                "title": "java-20ms-beats-99-28",
                "content": "Use binary search to locate the next multiple of nums[i].\\n```\\n/*\\n * Process nums increasingly.\\n * lens[i] denotes the max length of the subset constructed so far containing nums[i].\\n * If nums[j] (j > i) is multiple of nums[i], then lens[j] = max(lens[j], lens[i] + 1)\\n */\\npublic class Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length, maxIdx = 0;\\n        List<Integer> ans = new LinkedList<>();\\n        if (n == 0) return ans;\\n        Arrays.sort(nums);\\n        int[] lens = new int[n], prevs = new int[n];\\n        Arrays.fill(prevs, -1);\\n        for (int i = 0; nums[i] <= nums[n-1]/2; ++i) {\\n            for (int j = i + 1, f = 2; nums[i] <= nums[n-1]/f; f = (nums[j] + nums[i] - 1)/nums[i]) {\\n                int idx = Arrays.binarySearch(nums, j, n, f*nums[i]);\\n                if (idx > 0 && lens[idx] <= lens[i]) {\\n                    prevs[idx] = i;\\n                    lens[idx] = lens[i] + 1;\\n                    if (lens[idx] > lens[maxIdx]) maxIdx = idx;\\n                }\\n                j = idx >= 0 ? idx + 1 : -(idx + 1);\\n                if (j >= n) break;\\n            }\\n        }\\n        for (int i = maxIdx; i >= 0; i = prevs[i]) ans.add(0, nums[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Process nums increasingly.\\n * lens[i] denotes the max length of the subset constructed so far containing nums[i].\\n * If nums[j] (j > i) is multiple of nums[i], then lens[j] = max(lens[j], lens[i] + 1)\\n */\\npublic class Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length, maxIdx = 0;\\n        List<Integer> ans = new LinkedList<>();\\n        if (n == 0) return ans;\\n        Arrays.sort(nums);\\n        int[] lens = new int[n], prevs = new int[n];\\n        Arrays.fill(prevs, -1);\\n        for (int i = 0; nums[i] <= nums[n-1]/2; ++i) {\\n            for (int j = i + 1, f = 2; nums[i] <= nums[n-1]/f; f = (nums[j] + nums[i] - 1)/nums[i]) {\\n                int idx = Arrays.binarySearch(nums, j, n, f*nums[i]);\\n                if (idx > 0 && lens[idx] <= lens[i]) {\\n                    prevs[idx] = i;\\n                    lens[idx] = lens[i] + 1;\\n                    if (lens[idx] > lens[maxIdx]) maxIdx = idx;\\n                }\\n                j = idx >= 0 ? idx + 1 : -(idx + 1);\\n                if (j >= n) break;\\n            }\\n        }\\n        for (int i = maxIdx; i >= 0; i = prevs[i]) ans.add(0, nums[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84079,
                "title": "java-61ms-solution-dfs-pruning-with-comments",
                "content": "    public class Solution {\\n    List<Integer> res;\\n    int[] mem;\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        mem = new int[nums.length];\\n        Arrays.fill(mem, -1);\\n        res = new ArrayList<>();\\n        helper(nums, 0, new ArrayList<>(), 1);\\n        return res;\\n    }\\n    \\n    private void helper(int[] nums, int index, List<Integer> curr, int prev) {\\n        if (curr.size() > res.size()) {\\n            res = new ArrayList<>(curr);\\n        }\\n        for (int i = index; i < nums.length; i++) {\\n            // prune: for the current value, if it has been visited with a larger\\n            // set, then skip it\\n            if (curr.size() > mem[i] && nums[i] % prev == 0) {\\n                mem[i] = curr.size();\\n                curr.add(nums[i]);\\n                helper(nums, i + 1, curr, nums[i]);\\n                curr.remove(curr.size() - 1); // backtrack\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    List<Integer> res;\\n    int[] mem;\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        mem = new int[nums.length];\\n        Arrays.fill(mem, -1);\\n        res = new ArrayList<>();\\n        helper(nums, 0, new ArrayList<>(), 1);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 84103,
                "title": "easy-dp-with-path-record-c-code-o-n-2-time-on-worst-case-o-n-space",
                "content": "the idea is using a bucket to record which nums can be the current longest sequence,\\nand meantime using pair record the pre-num's id in its bucket, so we can get the result using it.\\n\\nsee this case [1,2,3,4,5,6,7,24]\\n\\nat last it runs like this:\\n\\n     1 | 2 | 4 | 24\\n       | 3 | 6 |\\n       | 5 |    \\n       | 7 |    \\ncode:\\n\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int> ret;\\n        int n = nums.size();\\n        if (!n) return ret;\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, int>> dp[n];\\n        int maxi = 0;\\n        dp[maxi].push_back(make_pair(nums[0], -1));\\n        for (int i = 1; i < n; ++i) {\\n            int j = maxi;\\n            while (j >= 0) {\\n                for (int id = 0; id < dp[j].size(); ++id) {\\n                    if (nums[i] % dp[j][id].first == 0) {\\n                        dp[j + 1].emplace_back(nums[i], id);\\n                        maxi = max(maxi, j + 1);\\n                        goto out_of_while;\\n                    }\\n                }\\n                --j;\\n            }\\n            dp[j + 1].emplace_back(nums[i], -1);\\n            out_of_while:;\\n        }\\n        int i = maxi, id = 0;\\n        while (i >= 0) {\\n            ret.push_back(dp[i][id].first);\\n            id = dp[i][id].second;\\n            --i;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "the idea is using a bucket to record which nums can be the current longest sequence,\\nand meantime using pair record the pre-num's id in its bucket, so we can get the result using it.\\n\\nsee this case [1,2,3,4,5,6,7,24]\\n\\nat last it runs like this:\\n\\n     1 | 2 | 4 | 24\\n       | 3 | 6 |\\n       | 5 |    \\n       | 7 |    \\ncode:\\n\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int> ret;\\n        int n = nums.size();\\n        if (!n) return ret;\\n        sort(nums.begin(), nums.end());\\n        vector<pair<int, int>> dp[n];\\n        int maxi = 0;\\n        dp[maxi].push_back(make_pair(nums[0], -1));\\n        for (int i = 1; i < n; ++i) {\\n            int j = maxi;\\n            while (j >= 0) {\\n                for (int id = 0; id < dp[j].size(); ++id) {\\n                    if (nums[i] % dp[j][id].first == 0) {\\n                        dp[j + 1].emplace_back(nums[i], id);\\n                        maxi = max(maxi, j + 1);\\n                        goto out_of_while;\\n                    }\\n                }\\n                --j;\\n            }\\n            dp[j + 1].emplace_back(nums[i], -1);\\n            out_of_while:;\\n        }\\n        int i = maxi, id = 0;\\n        while (i >= 0) {\\n            ret.push_back(dp[i][id].first);\\n            id = dp[i][id].second;\\n            --i;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2991380,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n*n)+O(nlogn)+O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size(), maxi=1, num=-1;\\n        vector<int>v;\\n        sort(nums.begin(), nums.end());\\n        vector<int>dp(n, 1);\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(!(nums[i]%nums[j]) && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                    if(maxi<dp[i]){\\n                        maxi=dp[i];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(maxi==dp[i] && (num==-1 || !(num%nums[i]))){\\n                v.push_back(nums[i]);\\n                maxi--;\\n                num=nums[i];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size(), maxi=1, num=-1;\\n        vector<int>v;\\n        sort(nums.begin(), nums.end());\\n        vector<int>dp(n, 1);\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(!(nums[i]%nums[j]) && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                    if(maxi<dp[i]){\\n                        maxi=dp[i];\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(maxi==dp[i] && (num==-1 || !(num%nums[i]))){\\n                v.push_back(nums[i]);\\n                maxi--;\\n                num=nums[i];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824204,
                "title": "easy-fast-lis-variation-simple-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int > dp(n,1);    // create a dp vector for storing the longest subset till the index i which satisfies the divisibility condition  initially dp vector is filled with 1 (since every element itself is a subset with length 1 )\\n\\t\\t\\n\\t\\t\\n        int ans = 0;\\n        vector<int > store(n,0);      // vector store is used to store the index of the previously included elements\\n\\t\\t\\n        int lastId = 0;\\n\\t\\t\\n        // 1) sort the given array  so that we need to check only in for A[i] % A[j] not A[j] % A[i] provided  i > j\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            store[i] = i;           \\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i] % nums[j] == 0 && dp[i] < 1 + dp[j])\\n                {\\n                    dp[i] = 1 + dp[j];\\n                    store[i] = j;\\n                }\\n            }\\n\\n            if(ans < dp[i])\\n            {\\n                ans = dp[i];\\n                lastId = i;         // stores the index where we got max length of the subset  \\n            }\\n        }\\n\\n\\n        vector<int > printAns;      // vector for storing the answer \\n\\n        printAns.push_back(nums[lastId]);\\n\\n\\n        while(store[lastId] != lastId)\\n        {\\n            lastId = store[lastId];\\n            printAns.push_back(nums[lastId]);\\n        }\\n\\t\\t\\n\\t\\t  // since we have our answer in reverse order, so just reversed it -> \\n\\t\\t   \\n        reverse(printAns.begin(), printAns.end());    \\n\\n        return printAns;\\n\\n    }\\n};\\n\\n// Please upvote if it helps you \\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int > dp(n,1);    // create a dp vector for storing the longest subset till the index i which satisfies the divisibility condition  initially dp vector is filled with 1 (since every element itself is a subset with length 1 )\\n\\t\\t\\n\\t\\t\\n        int ans = 0;\\n        vector<int > store(n,0);      // vector store is used to store the index of the previously included elements\\n\\t\\t\\n        int lastId = 0;\\n\\t\\t\\n        // 1) sort the given array  so that we need to check only in for A[i] % A[j] not A[j] % A[i] provided  i > j\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            store[i] = i;           \\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i] % nums[j] == 0 && dp[i] < 1 + dp[j])\\n                {\\n                    dp[i] = 1 + dp[j];\\n                    store[i] = j;\\n                }\\n            }\\n\\n            if(ans < dp[i])\\n            {\\n                ans = dp[i];\\n                lastId = i;         // stores the index where we got max length of the subset  \\n            }\\n        }\\n\\n\\n        vector<int > printAns;      // vector for storing the answer \\n\\n        printAns.push_back(nums[lastId]);\\n\\n\\n        while(store[lastId] != lastId)\\n        {\\n            lastId = store[lastId];\\n            printAns.push_back(nums[lastId]);\\n        }\\n\\t\\t\\n\\t\\t  // since we have our answer in reverse order, so just reversed it -> \\n\\t\\t   \\n        reverse(printAns.begin(), printAns.end());    \\n\\n        return printAns;\\n\\n    }\\n};\\n\\n// Please upvote if it helps you \\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579871,
                "title": "python-brute-force-using-backtrack-time-complexity-o-2-n",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        # backtrack\\n        # time complexity O(2^n)\\n        N = len(nums)\\n        \\n        # O(nlogn)\\n        nums.sort()\\n        self.ans = []\\n        \\n        # use adjusted memoization\\n        score = defaultdict(int)\\n        \\n        # O(2^n)\\n        def backtrack(curr, i):\\n            if len(curr) > len(self.ans):\\n                self.ans = curr[:]\\n            for j in range(i+1, N):\\n                # if current length + 1 is bigger than previos length\\n                # try this number\\n                if nums[j] % curr[-1] == 0 and len(curr) + 1 >= score[nums[j]]:\\n                    curr.append(nums[j])\\n                    score[nums[j]] = len(curr)\\n                    backtrack(curr, j)\\n                    curr.pop()\\n        backtrack([1],-1)\\n        \\n        # O(n)\\n        return self.ans[1:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        \\n        \\n        # backtrack\\n        # time complexity O(2^n)\\n        N = len(nums)\\n        \\n        # O(nlogn)\\n        nums.sort()\\n        self.ans = []\\n        \\n        # use adjusted memoization\\n        score = defaultdict(int)\\n        \\n        # O(2^n)\\n        def backtrack(curr, i):\\n            if len(curr) > len(self.ans):\\n                self.ans = curr[:]\\n            for j in range(i+1, N):\\n                # if current length + 1 is bigger than previos length\\n                # try this number\\n                if nums[j] % curr[-1] == 0 and len(curr) + 1 >= score[nums[j]]:\\n                    curr.append(nums[j])\\n                    score[nums[j]] = len(curr)\\n                    backtrack(curr, j)\\n                    curr.pop()\\n        backtrack([1],-1)\\n        \\n        # O(n)\\n        return self.ans[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579534,
                "title": "c-o-n-2-solution-97-faster-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int>dp(nums.size(),1);\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0) dp[i]=max(dp[i],1+dp[j]);\\n            }\\n        }\\n        int val=0;\\n        for(int i=0;i<dp.size();i++) if(val<dp[i]) val=dp[i];\\n        vector<int>v;\\n        for(int i=dp.size()-1;i>-1;i--){\\n            if(val==dp[i] and (!v.size() or v[v.size()-1]%nums[i]==0)){\\n                v.push_back(nums[i]);\\n                val--;\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int>dp(nums.size(),1);\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0) dp[i]=max(dp[i],1+dp[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1579449,
                "title": "c-dp-recursion-memoization",
                "content": "The recursion logic is basic\\n\\n1. if the last element in subset is not devisible then we have only 1 option of \\n\\t\\t\\t a)not including it  \\n2. if the last element int he subset is divisible by the present element , then there are two options,\\n\\t\\t\\t a) including it \\n\\t\\t\\t b) not including it \\n\\t\\t\\t \\nThe memoization logic includes three parts, \\n\\n\\t\\t\\ta) the present index\\n\\t\\t\\tb) the, answer till now vector size , and\\n\\t\\t\\tc) the last element placed in the subset\\n```\\nclass Solution {\\nprivate:\\n    vector<int>temp;\\npublic:\\n    void recur(vector<vector<int>>& dp, vector<int>& nums, vector<int>&ans, int x, int index)\\n    {\\n        if(ans.size()>temp.size())\\n            temp=ans;\\n        \\n        if( index>=nums.size() or x>=nums.size())\\n            return;\\n        \\n        if(dp[index][ans.size()]==x)\\n            return;\\n        \\n        dp[index][ans.size()]=x;\\n        \\n        if(nums[index]%nums[x]==0 and nums[index]!=nums[x])\\n        {\\n            ans.push_back(nums[index]);\\n            recur(dp,nums,ans, index, index+1);\\n            ans.pop_back();\\n        }\\n        \\n        recur(dp,nums, ans, x , index+1);\\n    }\\n    vector<int> largestDivisibleSubset(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        vector<vector<int>>dp(nums.size()+1, vector<int>(nums.size()+1, -1));\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {   \\n            vector<int> yo={nums[i]};\\n            recur(dp, nums, yo, i, 0);\\n        }\\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int>temp;\\npublic:\\n    void recur(vector<vector<int>>& dp, vector<int>& nums, vector<int>&ans, int x, int index)\\n    {\\n        if(ans.size()>temp.size())\\n            temp=ans;\\n        \\n        if( index>=nums.size() or x>=nums.size())\\n            return;\\n        \\n        if(dp[index][ans.size()]==x)\\n            return;\\n        \\n        dp[index][ans.size()]=x;\\n        \\n        if(nums[index]%nums[x]==0 and nums[index]!=nums[x])\\n        {\\n            ans.push_back(nums[index]);\\n            recur(dp,nums,ans, index, index+1);\\n            ans.pop_back();\\n        }\\n        \\n        recur(dp,nums, ans, x , index+1);\\n    }\\n    vector<int> largestDivisibleSubset(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        vector<vector<int>>dp(nums.size()+1, vector<int>(nums.size()+1, -1));\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {   \\n            vector<int> yo={nums[i]};\\n            recur(dp, nums, yo, i, 0);\\n        }\\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579410,
                "title": "python-short-simple-time-95-space-87-iterative",
                "content": "Please feel free to ask questions and give suggestions to improve. **Upvote** if you liked the solution.\\n**Main Idea**: \\n* If we traverse nums in ascending order and we need any 1 longest subset, we need to add exactly 1 new subset for each number. \\n\\t* If it\\'s an extension of a subset we saw before, only 1 of the longest extensions need to be added. (Only the last value added in a subset matters (Anything divisible by the largest value will be divisible by the previously added smaller values (which are all factors of the largest value))\\n\\t* If it\\'s not an extension, we build a new subset with just that value\\n```\\ndef largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n\\t# We\\'ll traverse values in nums in ascending order\\n\\tnums.sort()\\n\\t# Ordered (by length) list of valid subsets that are largest subset candidates\\n\\tsubsets = []\\n\\t\\n\\t# Add max-length subset for each value\\n\\tfor i, num in enumerate(nums):\\n\\t\\t# Find the biggest subset we can add num to, and add this new subset to subsets (maintaining order)\\n\\t\\tfor j in range(i-1, -1, -1):\\n\\t\\t\\t# If satisfies divisibility, insert into subsets (as per size, 1 bigger than previous subset)\\n\\t\\t\\tif not num%subsets[j][-1]:\\n\\t\\t\\t\\t# Location of where to insert new extended subset (Alt.: Could binary search for it)\\n\\t\\t\\t\\tk = next(filter(lambda k: len(subsets[j])!=len(subsets[k]), range(j+1, i)), i)\\n\\t\\t\\t\\tsubsets.insert(k, subsets[j]+[num])\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\t# num can\\'t be added as an extension to any subset, create a blank one for it\\n\\t\\t\\tsubsets.insert(0, [num])\\n\\n\\treturn subsets[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\ndef largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n\\t# We\\'ll traverse values in nums in ascending order\\n\\tnums.sort()\\n\\t# Ordered (by length) list of valid subsets that are largest subset candidates\\n\\tsubsets = []\\n\\t\\n\\t# Add max-length subset for each value\\n\\tfor i, num in enumerate(nums):\\n\\t\\t# Find the biggest subset we can add num to, and add this new subset to subsets (maintaining order)\\n\\t\\tfor j in range(i-1, -1, -1):\\n\\t\\t\\t# If satisfies divisibility, insert into subsets (as per size, 1 bigger than previous subset)\\n\\t\\t\\tif not num%subsets[j][-1]:\\n\\t\\t\\t\\t# Location of where to insert new extended subset (Alt.: Could binary search for it)\\n\\t\\t\\t\\tk = next(filter(lambda k: len(subsets[j])!=len(subsets[k]), range(j+1, i)), i)\\n\\t\\t\\t\\tsubsets.insert(k, subsets[j]+[num])\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\t# num can\\'t be added as an extension to any subset, create a blank one for it\\n\\t\\t\\tsubsets.insert(0, [num])\\n\\n\\treturn subsets[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1554089,
                "title": "c-solution-o-n-2-solution-similar-to-lis-with-complete-explanation",
                "content": "This question is similar to Longest Increasing Subsequence! The catch here is: if a num1 divides num2, then all the factors of num1 will also divide num2. Keeping this in mind, you can sort the array, and according simulate the LIS algorithm. \\n\\nBut later, you also have to present the elements of the divisible subset. For that, maintain a parent array and using it, trace back the whole subset! \\n\\nBelow is an implementation of the mentioned approach:\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return {nums[0]};\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans, parent(n,-1),dp(n,1);\\n        \\n        for(int i=0;i<n;i++) parent[i]=i;\\n        int max_sub=0, idx=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]%nums[j]==0) \\n                {\\n                    if(dp[i]<dp[j]+1)\\n                    {\\n                        parent[i]=j;\\n                        dp[i]=dp[j]+1;\\n                    }\\n                }\\n            }\\n            \\n            if(max_sub<dp[i]) max_sub=dp[i], idx=i;\\n        }\\n        \\n        int k=idx;\\n        \\n        while(parent[k]!=k)\\n        {\\n            ans.push_back(nums[k]);\\n            k=parent[k];\\n        }\\n        \\n        ans.push_back(nums[k]);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return {nums[0]};\\n        sort(nums.begin(),nums.end());\\n        vector<int> ans, parent(n,-1),dp(n,1);\\n        \\n        for(int i=0;i<n;i++) parent[i]=i;\\n        int max_sub=0, idx=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]%nums[j]==0) \\n                {\\n                    if(dp[i]<dp[j]+1)\\n                    {\\n                        parent[i]=j;\\n                        dp[i]=dp[j]+1;\\n                    }\\n                }\\n            }\\n            \\n            if(max_sub<dp[i]) max_sub=dp[i], idx=i;\\n        }\\n        \\n        int k=idx;\\n        \\n        while(parent[k]!=k)\\n        {\\n            ans.push_back(nums[k]);\\n            k=parent[k];\\n        }\\n        \\n        ans.push_back(nums[k]);\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127633,
                "title": "python-dynamic-programming-with-comments",
                "content": "Overall O(n^2)\\n\\n- sorting `nlogn`\\n- dp `n^2`\\n- extract result `n`\\n\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums or len(nums) == 0:\\n            return []\\n\\n        # since we are doing a \"subset\" question\\n        # sorting does not make any differences\\n        nums.sort()\\n        n = len(nums)\\n\\n        # initilization\\n        # f[i] represents the size of LDS ended with nums[i]\\n        f = [1 for _ in range(n)]\\n        for i in range(1, n):\\n            for j in range(i):\\n                # since we have already sorted,\\n                # then nums[j] % nums[i] will never equals zero\\n                # unless nums[i] == nums[j]\\n                if nums[i] % nums[j] == 0:\\n                    f[i] = max(f[i], f[j] + 1)\\n\\n        # extract result from dp array\\n        max_size = max(f)\\n        max_idx = f.index(max_size) # since we can return one of the largest\\n        prev_num, prev_size = nums[max_idx], f[max_idx]\\n        res = [prev_num]\\n        for curr_idx in range(max_idx, -1, -1):\\n            if prev_num % nums[curr_idx] == 0 and f[curr_idx] == prev_size - 1:\\n                # update\\n                res.append(nums[curr_idx])\\n                prev_num = nums[curr_idx]\\n                prev_size = f[curr_idx]\\n\\n        return res[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums or len(nums) == 0:\\n            return []\\n\\n        # since we are doing a \"subset\" question\\n        # sorting does not make any differences\\n        nums.sort()\\n        n = len(nums)\\n\\n        # initilization\\n        # f[i] represents the size of LDS ended with nums[i]\\n        f = [1 for _ in range(n)]\\n        for i in range(1, n):\\n            for j in range(i):\\n                # since we have already sorted,\\n                # then nums[j] % nums[i] will never equals zero\\n                # unless nums[i] == nums[j]\\n                if nums[i] % nums[j] == 0:\\n                    f[i] = max(f[i], f[j] + 1)\\n\\n        # extract result from dp array\\n        max_size = max(f)\\n        max_idx = f.index(max_size) # since we can return one of the largest\\n        prev_num, prev_size = nums[max_idx], f[max_idx]\\n        res = [prev_num]\\n        for curr_idx in range(max_idx, -1, -1):\\n            if prev_num % nums[curr_idx] == 0 and f[curr_idx] == prev_size - 1:\\n                # update\\n                res.append(nums[curr_idx])\\n                prev_num = nums[curr_idx]\\n                prev_size = f[curr_idx]\\n\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058068,
                "title": "c-dp-36-ms-faster-than-94-40",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n//sort the given vector to ensure that all factors comes before a number in the given vector\\n        sort(nums.begin(), nums.end()); \\n        vector<int> lis(n,1);//lis store the maximum length of subset such that given constrain hold\\n// we traverse for all position and check what is the longest length till index i holding the constrain\\n//NOTE: if(nums[i]%nums[j]==0 and nums[i]%nums[k]==0 then nums[j]%nums[k] ==0), this property is being used here\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0)\\n                    lis[i]= max(lis[i], 1+lis[j]);\\n            }\\n        int max_index=0; //variable to store the index of maximum value in lis vector\\n// Now traverse the lis vector to find index which has the maximum value \\n        for(int i=0;i<n;i++){\\n            if(lis[i]>lis[max_index])\\n                max_index = i;\\n        }\\n        vector<int> ans; //vector to store the result\\n        int temp_val = nums[max_index]; \\n        int count = lis[max_index];\\n //now we traverse from max_index obtained to index 0 and check if the constrain hold if yes push it to ans vector   \\n        for(int i= max_index;i>=0;){\\n            if(temp_val%nums[i]==0 && count==lis[i]){\\n                ans.push_back(nums[i]);\\n                temp_val = nums[i];\\n                count--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Do upvote explanation was useful and you liked the code :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n//sort the given vector to ensure that all factors comes before a number in the given vector\\n        sort(nums.begin(), nums.end()); \\n        vector<int> lis(n,1);//lis store the maximum length of subset such that given constrain hold\\n// we traverse for all position and check what is the longest length till index i holding the constrain\\n//NOTE: if(nums[i]%nums[j]==0 and nums[i]%nums[k]==0 then nums[j]%nums[k] ==0), this property is being used here\\n        for(int i=1;i<n;i++)\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0)\\n                    lis[i]= max(lis[i], 1+lis[j]);\\n            }\\n        int max_index=0; //variable to store the index of maximum value in lis vector\\n// Now traverse the lis vector to find index which has the maximum value \\n        for(int i=0;i<n;i++){\\n            if(lis[i]>lis[max_index])\\n                max_index = i;\\n        }\\n        vector<int> ans; //vector to store the result\\n        int temp_val = nums[max_index]; \\n        int count = lis[max_index];\\n //now we traverse from max_index obtained to index 0 and check if the constrain hold if yes push it to ans vector   \\n        for(int i= max_index;i>=0;){\\n            if(temp_val%nums[i]==0 && count==lis[i]){\\n                ans.push_back(nums[i]);\\n                temp_val = nums[i];\\n                count--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936142,
                "title": "java-no-bullshit-straight-and-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> res  = new ArrayList<>();\\n        if(n == 0) return res;\\n\\n        List<Integer>[] dp = new List[n];\\n        \\n        Arrays.sort(nums);\\n        \\n        // Each num at index i has its own value as initial subset.\\n        for(int i=0;i<dp.length;i++){\\n            dp[i] = new ArrayList<>(List.of(nums[i]));\\n        }\\n        \\n        int maxSize = res.size();\\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<=i;j++){\\n                if(nums[i] != nums[j] && nums[i] % nums[j] == 0 && dp[i].size() < dp[j].size() + 1){\\n                    dp[i] = new ArrayList<>(dp[j]);\\n                    dp[i].add(nums[i]);\\n                }\\n                if(dp[i].size() > maxSize){\\n                    maxSize = dp[i].size();\\n                    res = dp[i];\\n                }        \\n            }\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> res  = new ArrayList<>();\\n        if(n == 0) return res;\\n\\n        List<Integer>[] dp = new List[n];\\n        \\n        Arrays.sort(nums);\\n        \\n        // Each num at index i has its own value as initial subset.\\n        for(int i=0;i<dp.length;i++){\\n            dp[i] = new ArrayList<>(List.of(nums[i]));\\n        }\\n        \\n        int maxSize = res.size();\\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<=i;j++){\\n                if(nums[i] != nums[j] && nums[i] % nums[j] == 0 && dp[i].size() < dp[j].size() + 1){\\n                    dp[i] = new ArrayList<>(dp[j]);\\n                    dp[i].add(nums[i]);\\n                }\\n                if(dp[i].size() > maxSize){\\n                    maxSize = dp[i].size();\\n                    res = dp[i];\\n                }        \\n            }\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684977,
                "title": "best-c-solution-in-o-n-2-very-easy",
                "content": "@amit_gupta10 thanks for the approach\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        //time complexity of my approach is O(n^2)\\n        int n = nums.size();\\n        if(n == 0 || n == 1)    return nums;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        vector<int> dp(n,1);\\n        int maxEle = INT_MIN;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j] == 0){\\n                    int t = 1 + dp[j];\\n                    if(t > dp[i])   dp[i] = t;\\n                }\\n            }\\n            if(dp[i] > maxEle)  maxEle = dp[i];\\n        }\\n        \\n        vector<int> v;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(dp[i] == maxEle){\\n                v.push_back(nums[i]);\\n                maxEle--;\\n            }\\n        }\\n        \\n        \\n        \\n        return v;\\n    }\\n};\\n```\\nplease upvote if it helps!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        //time complexity of my approach is O(n^2)\\n        int n = nums.size();\\n        if(n == 0 || n == 1)    return nums;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        vector<int> dp(n,1);\\n        int maxEle = INT_MIN;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j] == 0){\\n                    int t = 1 + dp[j];\\n                    if(t > dp[i])   dp[i] = t;\\n                }\\n            }\\n            if(dp[i] > maxEle)  maxEle = dp[i];\\n        }\\n        \\n        vector<int> v;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(dp[i] == maxEle){\\n                v.push_back(nums[i]);\\n                maxEle--;\\n            }\\n        }\\n        \\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684698,
                "title": "c-dp-with-comments",
                "content": "```\\nclass Solution { //Leetcode 368:  DP;\\npublic:// Time/Space: O(N^2); O(N)\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        const int n = nums.size();\\n        vector<int> dp(n), parent(n), res; //dp[i]: max size of desired subset beginning with nums[i];\\n        int maxSize = 0;   // max size of the desired subset\\n        int beginIdx = -1; // index of the smallest element in the sorted nums to build the set\\n        for(int i = n - 1; i >=0; i--){\\n            for(int j = i; j < n; j++){ // i <= j;  // Note1\\n                if(nums[j] % nums[i] == 0 && dp[i] < dp[j] + 1){\\n                    dp[i] = dp[j] + 1;\\n                    parent[i] = j; // given that parent[i] is always updated with dp[i] together, \\n                                   // these two  can be packed to make the code more compact                    \\n                }                      \\n            }\\n            if(maxSize < dp[i]){\\n                maxSize = dp[i]; // redudant, but self-explained\\n                beginIdx= i;\\n            }\\n        }\\n        \\n        while(maxSize--){ //need collect #maxSize items \\n            res.push_back(nums[beginIdx]);\\n            beginIdx = parent[beginIdx];\\n        }            \\n        return res;\\n    }\\n};\\n//Note1: corner case, we need begin with j=i so that we can include 1st item into the set\\n```\\n\\nVersion 2:  In case you hate frequent collecting gobal maximal size, you can use max_element:\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.empty()) return {};\\n        sort(begin(nums), end(nums));\\n        const int n = nums.size();\\n        vector<int> dp(n), parents(n), res;\\n        int maxL = 0, beginIndex = -1;\\n        for(int i = n - 1; i >= 0; i--)\\n            for(int j = i; j < n; j++)\\n                if(nums[j] % nums[i] == 0 && dp[i] < dp[j] + 1){\\n                    dp[i] = dp[j] + 1;                    \\n                    parents[i] = j;\\n                }\\n            \\n        beginIndex = max_element(begin(dp),end(dp)) - begin(dp);\\n        maxL = dp[beginIndex];\\n        \\n        while(maxL--){\\n            res.push_back(nums[beginIndex]);\\n            beginIndex= parents[beginIndex];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { //Leetcode 368:  DP;\\npublic:// Time/Space: O(N^2); O(N)\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        const int n = nums.size();\\n        vector<int> dp(n), parent(n), res; //dp[i]: max size of desired subset beginning with nums[i];\\n        int maxSize = 0;   // max size of the desired subset\\n        int beginIdx = -1; // index of the smallest element in the sorted nums to build the set\\n        for(int i = n - 1; i >=0; i--){\\n            for(int j = i; j < n; j++){ // i <= j;  // Note1\\n                if(nums[j] % nums[i] == 0 && dp[i] < dp[j] + 1){\\n                    dp[i] = dp[j] + 1;\\n                    parent[i] = j; // given that parent[i] is always updated with dp[i] together, \\n                                   // these two  can be packed to make the code more compact                    \\n                }                      \\n            }\\n            if(maxSize < dp[i]){\\n                maxSize = dp[i]; // redudant, but self-explained\\n                beginIdx= i;\\n            }\\n        }\\n        \\n        while(maxSize--){ //need collect #maxSize items \\n            res.push_back(nums[beginIdx]);\\n            beginIdx = parent[beginIdx];\\n        }            \\n        return res;\\n    }\\n};\\n//Note1: corner case, we need begin with j=i so that we can include 1st item into the set\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.empty()) return {};\\n        sort(begin(nums), end(nums));\\n        const int n = nums.size();\\n        vector<int> dp(n), parents(n), res;\\n        int maxL = 0, beginIndex = -1;\\n        for(int i = n - 1; i >= 0; i--)\\n            for(int j = i; j < n; j++)\\n                if(nums[j] % nums[i] == 0 && dp[i] < dp[j] + 1){\\n                    dp[i] = dp[j] + 1;                    \\n                    parents[i] = j;\\n                }\\n            \\n        beginIndex = max_element(begin(dp),end(dp)) - begin(dp);\\n        maxL = dp[beginIndex];\\n        \\n        while(maxL--){\\n            res.push_back(nums[beginIndex]);\\n            beginIndex= parents[beginIndex];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512546,
                "title": "simple-clean-java-solution-dfs-backtrack",
                "content": "```\\nclass Solution {\\n    List<Integer> res;\\n    int max=-1;\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        help(nums,0,new ArrayList<>());\\n        return res;\\n    }\\n    void help(int[] nums,int s,List<Integer> temp)\\n    {\\n        if(temp.size()>max)\\n        {\\n            max=temp.size();\\n            res=new ArrayList<>(temp);\\n        }\\n        \\n        for(int i=s;i<nums.length;i++)\\n        {\\n            if(temp.isEmpty() || nums[i]%temp.get(temp.size()-1)==0)\\n            {\\n                temp.add(nums[i]);\\n                help(nums,i+1,temp);\\n                temp.remove(temp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> res;\\n    int max=-1;\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        help(nums,0,new ArrayList<>());\\n        return res;\\n    }\\n    void help(int[] nums,int s,List<Integer> temp)\\n    {\\n        if(temp.size()>max)\\n        {\\n            max=temp.size();\\n            res=new ArrayList<>(temp);\\n        }\\n        \\n        for(int i=s;i<nums.length;i++)\\n        {\\n            if(temp.isEmpty() || nums[i]%temp.get(temp.size()-1)==0)\\n            {\\n                temp.add(nums[i]);\\n                help(nums,i+1,temp);\\n                temp.remove(temp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84001,
                "title": "my-python-solution",
                "content": "```\\nclass Solution(object):\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n == 0:\\n            return []\\n        nums.sort()\\n        dp    = [[]]*n\\n        dp[0] = [nums[0]]\\n        maxdp = dp[0]\\n        \\n        for i in range(1,n):\\n            dp[i] = [nums[i]]\\n            for j in range(i):\\n                if nums[i]%dp[j][-1] == 0 and len(dp[i]) < len(dp[j]) + 1:\\n                    dp[i] = dp[j] + [ nums[i] ]\\n            if len(maxdp) < len(dp[i]):\\n                maxdp = dp[i]\\n\\n        return maxdp\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        if n == 0:\\n            return []\\n        nums.sort()\\n        dp    = [[]]*n\\n        dp[0] = [nums[0]]\\n        maxdp = dp[0]\\n        \\n        for i in range(1,n):\\n            dp[i] = [nums[i]]\\n            for j in range(i):\\n                if nums[i]%dp[j][-1] == 0 and len(dp[i]) < len(dp[j]) + 1:\\n                    dp[i] = dp[j] + [ nums[i] ]\\n            if len(maxdp) < len(dp[i]):\\n                maxdp = dp[i]\\n\\n        return maxdp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999416,
                "title": "easy-solution-well-explained-dp-java-clean-code",
                "content": "**Please give an upvote if you like the solution ^_^**\\n\\n*#6Companies30days #ReviseWithArsh Challenge 2023\\nDay1\\nQ5. Largest Divisible Subset.*\\n\\n![5.largest-divisible-subset.jpg](https://assets.leetcode.com/users/images/77e9f81c-68dc-4106-8649-927c226d4536_1672854594.2094185.jpeg)\\n# Code\\n**Java:**\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        if(n==0)return new ArrayList(); //check there is no  value in array\\n\\n        //Sort an array\\n        Arrays.sort(nums); //nlogn\\n\\n        //Generating count dp\\n        int[] count = new int[n];\\n        Arrays.fill(count, 1);\\n\\n        for(int i=1;i<n;i++){ //n^2\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0){\\n                    count[i]=Math.max(count[i], count[j]+1); // update count of i\\n                }\\n            }\\n        }\\n\\n        //m axIndex\\n        int maxIndex = 0;\\n        for(int i=1;i<n;i++){\\n            maxIndex=count[i]>count[maxIndex] ? i : maxIndex;\\n        }\\n\\n        //Construct the longest subset\\n        List<Integer> result = new ArrayList();\\n        int temp = nums[maxIndex];\\n        int currentCount = count[maxIndex];\\n        for(int i=maxIndex;i>=0;i--){\\n            if(temp%nums[i]==0 && currentCount==count[i]){\\n                result.add(nums[i]);\\n                temp = nums[i];\\n                currentCount--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        if(n==0)return new ArrayList(); //check there is no  value in array\\n\\n        //Sort an array\\n        Arrays.sort(nums); //nlogn\\n\\n        //Generating count dp\\n        int[] count = new int[n];\\n        Arrays.fill(count, 1);\\n\\n        for(int i=1;i<n;i++){ //n^2\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0){\\n                    count[i]=Math.max(count[i], count[j]+1); // update count of i\\n                }\\n            }\\n        }\\n\\n        //m axIndex\\n        int maxIndex = 0;\\n        for(int i=1;i<n;i++){\\n            maxIndex=count[i]>count[maxIndex] ? i : maxIndex;\\n        }\\n\\n        //Construct the longest subset\\n        List<Integer> result = new ArrayList();\\n        int temp = nums[maxIndex];\\n        int currentCount = count[maxIndex];\\n        for(int i=maxIndex;i>=0;i--){\\n            if(temp%nums[i]==0 && currentCount==count[i]){\\n                result.add(nums[i]);\\n                temp = nums[i];\\n                currentCount--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662993,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Dp***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // first off all sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // declare a dp array\\n        \\n        vector<int> dp(n, 1);\\n        \\n        // fill the dp table according to condition\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i - 1; j >= 0; j--)\\n            {\\n                if(nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1)\\n                {\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        // find the maximum legth from dp table\\n        \\n        int maxi = *max_element(dp.begin(), dp.end());\\n        \\n        // find the index of maximum length\\n        \\n        int max_idx = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dp[i] == maxi)\\n            {\\n                max_idx = i;\\n                \\n                break;\\n            }\\n        }\\n        \\n        // start taking the element from max_index\\n        \\n        vector<int> res;\\n        \\n        int i = max_idx;\\n        \\n        res.push_back(nums[i]);\\n        \\n        int prev = nums[i];\\n        \\n        maxi--;\\n        \\n        i--;\\n        \\n        while(i >= 0 && maxi)\\n        {\\n            if(dp[i] == maxi && prev % nums[i] == 0)\\n            {\\n                res.push_back(nums[i]);\\n                \\n                prev = nums[i];\\n                \\n                maxi--;\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // first off all sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // declare a dp array\\n        \\n        vector<int> dp(n, 1);\\n        \\n        // fill the dp table according to condition\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i - 1; j >= 0; j--)\\n            {\\n                if(nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1)\\n                {\\n                    dp[i] = dp[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        // find the maximum legth from dp table\\n        \\n        int maxi = *max_element(dp.begin(), dp.end());\\n        \\n        // find the index of maximum length\\n        \\n        int max_idx = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dp[i] == maxi)\\n            {\\n                max_idx = i;\\n                \\n                break;\\n            }\\n        }\\n        \\n        // start taking the element from max_index\\n        \\n        vector<int> res;\\n        \\n        int i = max_idx;\\n        \\n        res.push_back(nums[i]);\\n        \\n        int prev = nums[i];\\n        \\n        maxi--;\\n        \\n        i--;\\n        \\n        while(i >= 0 && maxi)\\n        {\\n            if(dp[i] == maxi && prev % nums[i] == 0)\\n            {\\n                res.push_back(nums[i]);\\n                \\n                prev = nums[i];\\n                \\n                maxi--;\\n            }\\n            \\n            i--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618883,
                "title": "java-97-80-faster-95-43-memory-efficient-longest-increasing-subsequence",
                "content": "![image](https://assets.leetcode.com/users/images/5ff9f8e5-6686-4701-a15f-5feb4334081b_1664035802.3454804.png)\\n\\n`Please upvote the solution if you like it`\\n\\n1. Sort the array as order doesn\\'t matter here.\\n2. Try to find longest increasing subsequence but just change increasing -> divisible. So change condition from arr[j]<arr[i] to arr[i]%arr[j] == 0\\n3. Generate the sequence.\\n\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int[] lis = new int[nums.length];\\n        int[] hash = new int[nums.length];\\n        Arrays.fill(hash, -1);\\n        Arrays.sort(nums);\\n        int maxIdx = 0;\\n        for(int i=1; i<nums.length; ++i){\\n            for(int j=0; j<i; ++j){\\n                if(nums[i]%nums[j] == 0 && lis[j]+1 > lis[i]){\\n                    lis[i] = lis[j]+1;\\n                    hash[i] = j;\\n                    if(lis[maxIdx] < lis[i])\\n                        maxIdx = i;\\n                }\\n            }\\n        }\\n        \\n        return buildSeq(nums, hash, maxIdx);\\n    }\\n    \\n    public List<Integer> buildSeq(int[] nums, int[] lis, int idx){\\n        List<Integer> seq = new ArrayList<>();\\n        while(idx >=0){\\n            seq.add(nums[idx]);\\n            idx = lis[idx];\\n        }\\n        return seq;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int[] lis = new int[nums.length];\\n        int[] hash = new int[nums.length];\\n        Arrays.fill(hash, -1);\\n        Arrays.sort(nums);\\n        int maxIdx = 0;\\n        for(int i=1; i<nums.length; ++i){\\n            for(int j=0; j<i; ++j){\\n                if(nums[i]%nums[j] == 0 && lis[j]+1 > lis[i]){\\n                    lis[i] = lis[j]+1;\\n                    hash[i] = j;\\n                    if(lis[maxIdx] < lis[i])\\n                        maxIdx = i;\\n                }\\n            }\\n        }\\n        \\n        return buildSeq(nums, hash, maxIdx);\\n    }\\n    \\n    public List<Integer> buildSeq(int[] nums, int[] lis, int idx){\\n        List<Integer> seq = new ArrayList<>();\\n        while(idx >=0){\\n            seq.add(nums[idx]);\\n            idx = lis[idx];\\n        }\\n        return seq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881791,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Dynamic Programming***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(nums[i] % nums[j] == 0 && dp[i] < 1 + dp[j])\\n                {\\n                    dp[i] = 1 + dp[j];\\n                }\\n            }\\n        }\\n        \\n        int maxi = *max_element(dp.begin(), dp.end());\\n        \\n        vector<int> res;\\n        \\n        int prev = -1;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(dp[i] == maxi && ((prev == -1) || prev % nums[i] == 0))\\n            {\\n                res.push_back(nums[i]);\\n                \\n                maxi--;\\n                \\n                prev = nums[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int> dp(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(nums[i] % nums[j] == 0 && dp[i] < 1 + dp[j])\\n                {\\n                    dp[i] = 1 + dp[j];\\n                }\\n            }\\n        }\\n        \\n        int maxi = *max_element(dp.begin(), dp.end());\\n        \\n        vector<int> res;\\n        \\n        int prev = -1;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(dp[i] == maxi && ((prev == -1) || prev % nums[i] == 0))\\n            {\\n                res.push_back(nums[i]);\\n                \\n                maxi--;\\n                \\n                prev = nums[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973733,
                "title": "similar-to-lis-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n       \\n        if(nums.size()==0){\\n            return {};\\n        }\\n       sort(nums.begin(),nums.end());\\n        \\n       vector<int> v(nums.size()+1,1);\\n       int n = nums.size();\\n       for(int i =1; i<n; i++){\\n           for(int j =0; j<i; j++){\\n               \\n               if(nums[i]%nums[j]==0){\\n                   v[i] = max(v[i],v[j]+1);\\n               }\\n           }\\n       }\\n        int mx =0;\\n        int indx =0;\\n        for(int i =0; i<v.size(); i++){\\n           \\n            if(v[i]>mx){\\n                mx = v[i];\\n                indx = i;\\n            }\\n        }\\n        //cout<<mx<<endl;\\n       vector<int> v1;\\n       v1.push_back(nums[indx]);\\n       for(int i = indx-1; i>=0; i--){\\n           \\n           if(v1.back()%nums[i]==0 && v[i]==mx-v1.size()){\\n               v1.push_back(nums[i]);\\n           }\\n       }\\n        \\n       reverse(v1.begin(),v1.end());  \\n       return v1; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n       \\n        if(nums.size()==0){\\n            return {};\\n        }\\n       sort(nums.begin(),nums.end());\\n        \\n       vector<int> v(nums.size()+1,1);\\n       int n = nums.size();\\n       for(int i =1; i<n; i++){\\n           for(int j =0; j<i; j++){\\n               \\n               if(nums[i]%nums[j]==0){\\n                   v[i] = max(v[i],v[j]+1);\\n               }\\n           }\\n       }\\n        int mx =0;\\n        int indx =0;\\n        for(int i =0; i<v.size(); i++){\\n           \\n            if(v[i]>mx){\\n                mx = v[i];\\n                indx = i;\\n            }\\n        }\\n        //cout<<mx<<endl;\\n       vector<int> v1;\\n       v1.push_back(nums[indx]);\\n       for(int i = indx-1; i>=0; i--){\\n           \\n           if(v1.back()%nums[i]==0 && v[i]==mx-v1.size()){\\n               v1.push_back(nums[i]);\\n           }\\n       }\\n        \\n       reverse(v1.begin(),v1.end());  \\n       return v1; \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 685886,
                "title": "python-graph-based-solution-beats-95-in-both-runtime-and-memory",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        nums = sorted(nums)\\n        level_dicts = [{1:None}] # level_dicts[i]={val:predecessor} \\n        for num in nums:\\n            for i in reversed(range(len(level_dicts))):\\n                found = False\\n                for val in level_dicts[i]:\\n                    if num % val == 0:\\n                        if len(level_dicts)-1 == i:\\n                            level_dicts.append({num:val})\\n                        else:\\n                            level_dicts[i+1][num] = val\\n                        found = True\\n                        break\\n                if found:\\n                    break\\n        curr_dict = level_dicts.pop()\\n        curr_val = list(curr_dict.keys())[0]\\n        pred = curr_dict[curr_val]\\n        output = [curr_val]\\n        while level_dicts:\\n            curr_val = pred\\n            curr_dict = level_dicts.pop()\\n            pred = curr_dict[curr_val]\\n            if pred:\\n                output.append(curr_val)\\n        return output\\n```\\n            \\n**Intuition (with example):**\\nSuppose the input is `[3,2,1,6,4,9,20]`. The idea is to\\n1. Sort the input list -> `[1,2,3,4,6,9,20]`\\n2. Iteratively build a directed tree in which each value in the input list has exactly one corresponding node, and each node has exactly one parent (with the root node being an exception).\\n   See illustration below; note: the dotted edge is not in the tree\\n   Before explaining how exactly to build the directed tree, I will first point out several properties of this directed tree:\\n   - The root of the tree is always `1`: if `1` is in the input list, it is the root; if it is not in the input list, we will add a dummy node with value `1`.\\n<img src=\"https://assets.leetcode.com/users/shatianwang/image_1592078958.png\" width=\"40%\">. \\n    - If there is a directed edge from `a` to `b` in the tree, then `b % a == 0`. \\n      The converse is not true: in the example above, although `20 % 2 == 0`, there is not an edge from `2` to `20`. \\n\\t- We say a node `a` is in level `k` of the tree if the directed path from `1` to `a` is of length `k`. In the example above, node `2` is in level 1 and node `20` is in level 3.\\n\\t- For any directed tree with the properties above, we have that a path from the root `1` to a leaf node `a` correspond to a divisible subset. If the level of leaf `a` is `k` and `1` is in the input list, then the divisible subset is of size `k+1`. If `1` is not in the input list, then the divisible subset is of size `k`.  As an example, the path `1->2->4->20` in the illustration corresponds to the divisible subset `[1,2,4,20]`.\\n\\nThe intuition is to build a directed tree with the above-mentioned properties, such that **the longest path from the root to a leaf will correspond to the largest divisible subset.**\\n\\nTo build such a tree, we start from the root and iterate over the values in the sorted input list exactly once. \\n\\nFor each value, we add a new node to current tree in the **largest possible level**.\\n  - For example, assume that we have built such a tree for input `[1,2,3,4,6,9]` with max level 2. Now we are at value `20` and we want to decide where in the tree to add it. We will first check the values in the biggest level one by one, i.e., level 2. If any value in level 2 is a diviser of `20`, we will add `20` as a child of that node, set its level to be 3, and break (in the illustration above, we have `4` as the parent node of `20`). \\n  - If no value in level 2 is a diviser of `20`, we will go one level up (to level 1) and see whether we can add `20` as a child of any node in this level (so that `20` will be in level 2). Note that since `1` is at level 0, a new node will in the worst case be added to level 1. \\n  - In each level, there can be multiple nodes that are divisers of the current value (for example, `2` and `3` in level 1 are both divisers of value `6`). But it doesn\\'t matter which one of them we choose at the parent of `6`. The only thing that matters is the level of each node.\\n\\nOnce we have such a directed tree, we can return the longest path from the root as the largest divisible subset.\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        nums = sorted(nums)\\n        level_dicts = [{1:None}] # level_dicts[i]={val:predecessor} \\n        for num in nums:\\n            for i in reversed(range(len(level_dicts))):\\n                found = False\\n                for val in level_dicts[i]:\\n                    if num % val == 0:\\n                        if len(level_dicts)-1 == i:\\n                            level_dicts.append({num:val})\\n                        else:\\n                            level_dicts[i+1][num] = val\\n                        found = True\\n                        break\\n                if found:\\n                    break\\n        curr_dict = level_dicts.pop()\\n        curr_val = list(curr_dict.keys())[0]\\n        pred = curr_dict[curr_val]\\n        output = [curr_val]\\n        while level_dicts:\\n            curr_val = pred\\n            curr_dict = level_dicts.pop()\\n            pred = curr_dict[curr_val]\\n            if pred:\\n                output.append(curr_val)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685301,
                "title": "backtracking-with-cache-i-don-t-understand-dp",
                "content": "```\\n\\t// steps\\n\\t// same as subsets problem except check for divisibility \\n\\t// you may have already checked for a larger subset starting at index i so maintain a cache to avoid duplication\\n\\t// eg. 1 2 3 4 9 \\n\\t// 1,2,4 of size 3 is your solution but 1,3,9 is also your solution no need to go down that recurrence tree \\n\\tpublic List<Integer> largestDivisibleSubset(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tint[] cache = new int[nums.length];\\n\\t\\tArrays.fill(cache, -1);\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\tList<Integer> tmpList = new ArrayList<>();\\n\\t\\tbacktrack(res, nums, 0, tmpList, 1, cache);\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate void backtrack(List<Integer> res, int[] nums, int start, List<Integer> tmpList, int prev, int[] cache) {\\n\\t\\tif (tmpList.size() > res.size()) {\\n\\t\\t\\tres.clear();\\n\\t\\t\\tres.addAll(tmpList);\\n\\t\\t}\\n\\n\\t\\tfor (int i = start; i < nums.length; i++) {\\t\\n\\t\\t\\tif (tmpList.size() <= cache[i] || nums[i] % prev != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcache[i] = tmpList.size();\\n\\t\\t\\ttmpList.add(nums[i]);\\n\\t\\t\\tbacktrack(res, nums, i + 1, tmpList, nums[i], cache);\\n\\t\\t\\ttmpList.remove(tmpList.size() - 1);\\n\\t\\t}\\n\\n\\t}\\n```\\n\\n#java #backtracking #memoization #dfs",
                "solutionTags": [],
                "code": "```\\n\\t// steps\\n\\t// same as subsets problem except check for divisibility \\n\\t// you may have already checked for a larger subset starting at index i so maintain a cache to avoid duplication\\n\\t// eg. 1 2 3 4 9 \\n\\t// 1,2,4 of size 3 is your solution but 1,3,9 is also your solution no need to go down that recurrence tree \\n\\tpublic List<Integer> largestDivisibleSubset(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tint[] cache = new int[nums.length];\\n\\t\\tArrays.fill(cache, -1);\\n\\t\\tList<Integer> res = new ArrayList<>();\\n\\t\\tList<Integer> tmpList = new ArrayList<>();\\n\\t\\tbacktrack(res, nums, 0, tmpList, 1, cache);\\n\\t\\treturn res;\\n\\t}\\n\\n\\tprivate void backtrack(List<Integer> res, int[] nums, int start, List<Integer> tmpList, int prev, int[] cache) {\\n\\t\\tif (tmpList.size() > res.size()) {\\n\\t\\t\\tres.clear();\\n\\t\\t\\tres.addAll(tmpList);\\n\\t\\t}\\n\\n\\t\\tfor (int i = start; i < nums.length; i++) {\\t\\n\\t\\t\\tif (tmpList.size() <= cache[i] || nums[i] % prev != 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcache[i] = tmpList.size();\\n\\t\\t\\ttmpList.add(nums[i]);\\n\\t\\t\\tbacktrack(res, nums, i + 1, tmpList, nums[i], cache);\\n\\t\\t\\ttmpList.remove(tmpList.size() - 1);\\n\\t\\t}\\n\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684778,
                "title": "c-easy-to-understand-bottom-up-dp-similar-to-lis",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n     if(nums.size()<=1) return nums;\\n     sort(nums.begin(),nums.end());\\n     vector<int>parent(nums.size(),-1);//To store the  parent index of current element. So we can trace back to the subset\\n     vector<int>dp(nums.size(),1);\\n     int maxlength=0;int pos=0;\\n     //Similar to LIS\\n     for(int i=1;i<nums.size();i++)\\n     {\\n         for(int j=0;j<i;j++)\\n         {\\n             if(nums[i]%nums[j]==0) dp[i]=max(dp[i],1+dp[j]);\\n             if(dp[i]==1+dp[j]) parent[i]=j;//means j is parent of i \\n         }\\n         if(dp[i]>maxlength)\\n         {\\n             maxlength=dp[i];\\n             pos=i;\\n         }\\n     }\\n     vector<int>result(maxlength);\\n     for(int i=maxlength-1;i>=0;i--)\\n     {\\n         result[i]=nums[pos];\\n         pos=parent[pos];\\n     }\\n    return result;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n     if(nums.size()<=1) return nums;\\n     sort(nums.begin(),nums.end());\\n     vector<int>parent(nums.size(),-1);//To store the  parent index of current element. So we can trace back to the subset\\n     vector<int>dp(nums.size(),1);\\n     int maxlength=0;int pos=0;\\n     //Similar to LIS\\n     for(int i=1;i<nums.size();i++)\\n     {\\n         for(int j=0;j<i;j++)\\n         {\\n             if(nums[i]%nums[j]==0) dp[i]=max(dp[i],1+dp[j]);\\n             if(dp[i]==1+dp[j]) parent[i]=j;//means j is parent of i \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 663396,
                "title": "c-simplest",
                "content": "```\\n**Please Upvote if you find this helpful!!!**\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int> LIS[nums.size()];\\n        if(nums.size()==0){\\n            vector<int> v;\\n            return v;\\n        }\\n        sort(nums.begin(),nums.end());\\n        LIS[0].push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && LIS[j].size()>LIS[i].size() && (nums[j]%nums[i]==0 || nums[i]%nums[j]==0)){\\n                    LIS[i]=LIS[j];\\n                }\\n            }\\n            LIS[i].push_back(nums[i]);\\n        }\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(LIS[j].size()<LIS[i].size()){\\n                j=i;\\n            }\\n        }\\n        return LIS[j];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n**Please Upvote if you find this helpful!!!**\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<int> LIS[nums.size()];\\n        if(nums.size()==0){\\n            vector<int> v;\\n            return v;\\n        }\\n        sort(nums.begin(),nums.end());\\n        LIS[0].push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && LIS[j].size()>LIS[i].size() && (nums[j]%nums[i]==0 || nums[i]%nums[j]==0)){\\n                    LIS[i]=LIS[j];\\n                }\\n            }\\n            LIS[i].push_back(nums[i]);\\n        }\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(LIS[j].size()<LIS[i].size()){\\n                j=i;\\n            }\\n        }\\n        return LIS[j];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646645,
                "title": "java-exactly-same-as-lis-dp-solution",
                "content": "```\\n// check my old post for LIS. This question is exactly same as LIS. Here we keep track of the index in parent arr which forms our largest sequence\\n// https://leetcode.com/problems/longest-increasing-subsequence/discuss/623923/Java-or-Binary-Search\\n\\n/*\\n * 1. Sort the arr\\n * 2. Keep track of largest Divisible subset seq indexes in a seperate (parent) arr\\n * 3. Record length of largest Divisible subset sequence and the index of max element in that sequence\\n */\\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n\\tList<Integer> res = new ArrayList<Integer>();\\n\\n\\tArrays.sort(nums);\\n\\tint parent[] = new int[nums.length]; // Tracking the predecessors/parents of elements of each subsequence.\\n\\tint cache[] = new int[nums.length]; // Tracking length of each increasing subsequence.\\n\\tint maxLength = 0, maxIdx = -1; // Length of longest subsequence and idx\\n\\n\\t/* Initialize LIS values for all indexes */\\n\\tArrays.fill(cache, 1);\\n\\tArrays.fill(parent, -1);\\n\\n\\tfor (int i = 0; i < nums.length; i++){\\n\\t\\tfor (int j = 0; j < i; j++){\\n\\t\\t\\tif (nums[i] % nums[j] == 0 && cache[i] < cache[j] + 1){\\n\\t\\t\\t\\tcache[i] = cache[j] + 1;\\n\\t\\t\\t\\tparent[i] = j; // track index of largest sequence \\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (cache[i] > maxLength){\\n\\t\\t\\tmaxLength = cache[i];\\n\\t\\t\\tmaxIdx = i;\\n\\t\\t}\\n\\t}\\n\\n\\twhile (maxIdx != -1){\\n\\t\\tres.add(nums[maxIdx]);\\n\\t\\tmaxIdx = parent[maxIdx];\\n\\t}\\n\\treturn res;\\n}\\n",
                "solutionTags": [],
                "code": "```\\n// check my old post for LIS. This question is exactly same as LIS. Here we keep track of the index in parent arr which forms our largest sequence\\n// https://leetcode.com/problems/longest-increasing-subsequence/discuss/623923/Java-or-Binary-Search\\n\\n/*\\n * 1. Sort the arr\\n * 2. Keep track of largest Divisible subset seq indexes in a seperate (parent) arr\\n * 3. Record length of largest Divisible subset sequence and the index of max element in that sequence\\n */\\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n\\tList<Integer> res = new ArrayList<Integer>();\\n\\n\\tArrays.sort(nums);\\n\\tint parent[] = new int[nums.length]; // Tracking the predecessors/parents of elements of each subsequence.\\n\\tint cache[] = new int[nums.length]; // Tracking length of each increasing subsequence.\\n\\tint maxLength = 0, maxIdx = -1; // Length of longest subsequence and idx\\n\\n\\t/* Initialize LIS values for all indexes */\\n\\tArrays.fill(cache, 1);\\n\\tArrays.fill(parent, -1);\\n\\n\\tfor (int i = 0; i < nums.length; i++){\\n\\t\\tfor (int j = 0; j < i; j++){\\n\\t\\t\\tif (nums[i] % nums[j] == 0 && cache[i] < cache[j] + 1){\\n\\t\\t\\t\\tcache[i] = cache[j] + 1;\\n\\t\\t\\t\\tparent[i] = j; // track index of largest sequence \\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (cache[i] > maxLength){\\n\\t\\t\\tmaxLength = cache[i];\\n\\t\\t\\tmaxIdx = i;\\n\\t\\t}\\n\\t}\\n\\n\\twhile (maxIdx != -1){\\n\\t\\tres.add(nums[maxIdx]);\\n\\t\\tmaxIdx = parent[maxIdx];\\n\\t}\\n\\treturn res;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 637367,
                "title": "c-dp-o-n-n-lis-type-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if (!n) return vector<int>();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int>LDS(n, 1);\\n        vector<int>parent(n, 0);\\n        int mxlen = 0, mxindex = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    if (LDS[i] < 1 + LDS[j]) {\\n                        LDS[i] = 1 + LDS[j];\\n                        parent[i] = j; \\n                    }\\n                }\\n            }\\n            if (LDS[i] > mxlen) {\\n                mxlen = LDS[i];\\n                mxindex = i;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        for (int i = 0; i < mxlen; i++) {\\n            res.push_back(nums[mxindex]);\\n            mxindex = parent[mxindex];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if (!n) return vector<int>();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        vector<int>LDS(n, 1);\\n        vector<int>parent(n, 0);\\n        int mxlen = 0, mxindex = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    if (LDS[i] < 1 + LDS[j]) {\\n                        LDS[i] = 1 + LDS[j];\\n                        parent[i] = j; \\n                    }\\n                }\\n            }\\n            if (LDS[i] > mxlen) {\\n                mxlen = LDS[i];\\n                mxindex = i;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        for (int i = 0; i < mxlen; i++) {\\n            res.push_back(nums[mxindex]);\\n            mxindex = parent[mxindex];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568167,
                "title": "java-solution-using-dp-o-n-2-faster-than-94",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> ret = new ArrayList<>();\\n        int n = nums.length;\\n        if (n == 0) return ret;\\n        if (n == 1) return Arrays.asList(nums[0]);\\n        Arrays.sort(nums);\\n        \\n        int[] dp = new int[n];\\n        int[] prev = new int[n];\\n        \\n        dp[0] = 1;\\n        prev[0] = -1;\\n        int max = 1;\\n        int maxInd = 0;\\n        \\n        for (int i = 1; i < n; i++) {\\n            dp[i] = 1;\\n            prev[i] = -1;\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (nums[i] % nums[j] == 0) {\\n                    if (1 + dp[j] > dp[i]) {\\n                        dp[i] = 1 + dp[j];\\n                        prev[i] = j;\\n                    }\\n                }\\n            }\\n            if (dp[i] > max) {\\n                max = dp[i];\\n                maxInd = i;\\n            }\\n        }\\n        \\n        int ind = prev[maxInd];\\n        ret.add(nums[maxInd]);\\n        while(ind >= 0) {\\n            ret.add(nums[ind]);\\n            ind = prev[ind];\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> ret = new ArrayList<>();\\n        int n = nums.length;\\n        if (n == 0) return ret;\\n        if (n == 1) return Arrays.asList(nums[0]);\\n        Arrays.sort(nums);\\n        \\n        int[] dp = new int[n];\\n        int[] prev = new int[n];\\n        \\n        dp[0] = 1;\\n        prev[0] = -1;\\n        int max = 1;\\n        int maxInd = 0;\\n        \\n        for (int i = 1; i < n; i++) {\\n            dp[i] = 1;\\n            prev[i] = -1;\\n            for (int j = i - 1; j >= 0; j--) {\\n                if (nums[i] % nums[j] == 0) {\\n                    if (1 + dp[j] > dp[i]) {\\n                        dp[i] = 1 + dp[j];\\n                        prev[i] = j;\\n                    }\\n                }\\n            }\\n            if (dp[i] > max) {\\n                max = dp[i];\\n                maxInd = i;\\n            }\\n        }\\n        \\n        int ind = prev[maxInd];\\n        ret.add(nums[maxInd]);\\n        while(ind >= 0) {\\n            ret.add(nums[ind]);\\n            ind = prev[ind];\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523159,
                "title": "java-one-loop-and-use-hashmap-to-link-result",
                "content": "```\\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] dp = new int[nums.length];  //dp[i], count of integers j,  that can make i % j == 0;\\n        int max = -1, idx = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    if (dp[i] < dp[j] + 1){\\n                        dp[i] = dp[j] + 1;  // if j % k == 0 && i % j == 0, then i % k == 0;\\n                        map.put(i, j);\\n                    }\\n                }\\n            }\\n            if (dp[i] > max){\\n                max = dp[i];\\n                idx = i;\\n            }\\n        }\\n        if (idx >= 0) res.add(nums[idx]);\\n        while(map.containsKey(idx)) {\\n            idx = map.get(idx);\\n            res.add(nums[idx]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] dp = new int[nums.length];  //dp[i], count of integers j,  that can make i % j == 0;\\n        int max = -1, idx = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    if (dp[i] < dp[j] + 1){\\n                        dp[i] = dp[j] + 1;  // if j % k == 0 && i % j == 0, then i % k == 0;\\n                        map.put(i, j);\\n                    }\\n                }\\n            }\\n            if (dp[i] > max){\\n                max = dp[i];\\n                idx = i;\\n            }\\n        }\\n        if (idx >= 0) res.add(nums[idx]);\\n        while(map.containsKey(idx)) {\\n            idx = map.get(idx);\\n            res.add(nums[idx]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173360,
                "title": "simple-7-line-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums = sorted(nums)\\n        result = [[i] for i in nums]\\n        for j in range(1, len(nums)):\\n            for i in reversed(range(0, j)):\\n                if nums[j]%nums[i] == 0 and len(result[i]) >= len(result[j]):\\n                        result[j] = result[i]+ [nums[j]]\\n\\n        return max(result, key=len) if len(result) != 0 else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums = sorted(nums)\\n        result = [[i] for i in nums]\\n        for j in range(1, len(nums)):\\n            for i in reversed(range(0, j)):\\n                if nums[j]%nums[i] == 0 and len(result[i]) >= len(result[j]):\\n                        result[j] = result[i]+ [nums[j]]\\n\\n        return max(result, key=len) if len(result) != 0 else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130276,
                "title": "java-clear-code-using-dp-with-explanations",
                "content": "dp[i] = largest divisible subset starting at nums[i]\\ndp[j + 1] = max( 1 + dp[i] )  for nums[j + 1] % nums[i] == 0 and i belongs to[0, j]\\ndp[] only stores length, so we add parent[] to restore the result in the end\\n```\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        if (nums.length == 1) {\\n            result.add(nums[0]);\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        int[] dp = new int[nums.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = 1;\\n        }\\n        int[] parent = new int[nums.length];\\n        Arrays.fill(parent, -1);\\n        int largest = 0, largestAt = 0;\\n        \\n        for (int j = 1; j < dp.length; j++) {\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (nums[j] % nums[i] == 0 && dp[i] + 1 > dp[j]) {\\n                    dp[j] = dp[i] + 1;\\n                    parent[j] = i;\\n                }\\n            }\\n            if(dp[j] > largest) {\\n                largest = dp[j];\\n                largestAt = j;\\n            }\\n        }\\n        \\n        for (int i = 0; i < largest; i++) {     \\n            result.add(0, nums[largestAt]);\\n            largestAt = parent[largestAt];\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        if (nums.length == 1) {\\n            result.add(nums[0]);\\n            return result;\\n        }\\n        Arrays.sort(nums);\\n        int[] dp = new int[nums.length];\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = 1;\\n        }\\n        int[] parent = new int[nums.length];\\n        Arrays.fill(parent, -1);\\n        int largest = 0, largestAt = 0;\\n        \\n        for (int j = 1; j < dp.length; j++) {\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (nums[j] % nums[i] == 0 && dp[i] + 1 > dp[j]) {\\n                    dp[j] = dp[i] + 1;\\n                    parent[j] = i;\\n                }\\n            }\\n            if(dp[j] > largest) {\\n                largest = dp[j];\\n                largestAt = j;\\n            }\\n        }\\n        \\n        for (int i = 0; i < largest; i++) {     \\n            result.add(0, nums[largestAt]);\\n            largestAt = parent[largestAt];\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736087,
                "title": "easy-c-solution-faster-than-83-7-beats-memory-99-83",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>vec(nums.size(),1);\\n        vector<int> ans;\\n\\n        int maxi=0;\\n        int maxx=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0)\\n                    vec[i]=max(vec[j]+1,vec[i]);\\n            }\\n            maxi=max(maxi,vec[i]);\\n            if(maxi==vec[i])\\n                maxx=i;\\n        }\\n        int k=vec[maxx];\\n        int i=nums.size()-1;\\n        int x=nums[maxx];\\n        while(k){\\n            if(vec[i]==k && x%nums[i]==0){\\n                ans.push_back(nums[i]);\\n                k--;\\n                x=nums[i];\\n            }\\n            i--; \\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>vec(nums.size(),1);\\n        vector<int> ans;\\n\\n        int maxi=0;\\n        int maxx=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0)\\n                    vec[i]=max(vec[j]+1,vec[i]);\\n            }\\n            maxi=max(maxi,vec[i]);\\n            if(maxi==vec[i])\\n                maxx=i;\\n        }\\n        int k=vec[maxx];\\n        int i=nums.size()-1;\\n        int x=nums[maxx];\\n        while(k){\\n            if(vec[i]==k && x%nums[i]==0){\\n                ans.push_back(nums[i]);\\n                k--;\\n                x=nums[i];\\n            }\\n            i--; \\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666219,
                "title": "python3-solution-4-lines-code-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums):\\n        S = {-1: set()}\\n        for x in sorted(nums):\\n            S[x] = max((S[d] for d in S if x % d == 0), key=len) | {x}\\n        return list(max(S.values(), key=len))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310701,
                "title": "c-dp-tabulation-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)+O(nlogn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n, 1), track(n, 1), ans;\\n        int maxi=1, pos=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            track[i]=i;\\n            for(int j=0; j<i; j++){\\n                if(nums[i]%nums[j]==0 && 1+dp[j]>dp[i]){\\n                    dp[i]=1+dp[j];\\n                    track[i]=j;\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n                pos=i;\\n            }\\n        }\\n        ans.push_back(nums[pos]);\\n        while(pos!=track[pos]){\\n            pos=track[pos];\\n            ans.push_back(nums[pos]);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n, 1), track(n, 1), ans;\\n        int maxi=1, pos=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n; i++){\\n            track[i]=i;\\n            for(int j=0; j<i; j++){\\n                if(nums[i]%nums[j]==0 && 1+dp[j]>dp[i]){\\n                    dp[i]=1+dp[j];\\n                    track[i]=j;\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n                pos=i;\\n            }\\n        }\\n        ans.push_back(nums[pos]);\\n        while(pos!=track[pos]){\\n            pos=track[pos];\\n            ans.push_back(nums[pos]);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303064,
                "title": "easy-c-solution-dp-solution-easy-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(begin(nums),end(nums));\\n        vector<int> dp(n),idx(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int maxx=0;\\n            int index=i;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]%nums[j]==0)\\n                {\\n                    if(maxx<dp[j])   \\n                    {\\n                        maxx=dp[j];\\n                        index=j;\\n                    }\\n                }\\n            }\\n            dp[i]=maxx+1;\\n             idx[i]=index;\\n        }\\n        int maxx=*max_element(begin(dp),end(dp));\\n        vector<int> ans;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dp[i]==maxx)\\n            {\\n                int prev=i;\\n                while(prev!=idx[prev])\\n                {\\n                    ans.push_back(nums[prev]);\\n                    prev=idx[prev];\\n                }\\n                ans.push_back(nums[prev]);\\n                break;\\n            }\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(begin(nums),end(nums));\\n        vector<int> dp(n),idx(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int maxx=0;\\n            int index=i;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]%nums[j]==0)\\n                {\\n                    if(maxx<dp[j])   \\n                    {\\n                        maxx=dp[j];\\n                        index=j;\\n                    }\\n                }\\n            }\\n            dp[i]=maxx+1;\\n             idx[i]=index;\\n        }\\n        int maxx=*max_element(begin(dp),end(dp));\\n        vector<int> ans;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dp[i]==maxx)\\n            {\\n                int prev=i;\\n                while(prev!=idx[prev])\\n                {\\n                    ans.push_back(nums[prev]);\\n                    prev=idx[prev];\\n                }\\n                ans.push_back(nums[prev]);\\n                break;\\n            }\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250303,
                "title": "368-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is a dynamic programming solution to find the largest divisible subset of a set of distinct positive integers.\\n\\nThe basic idea is to sort the input array so that we can process it in increasing order. We initialize two arrays: dp and prev. dp[i] stores the size of the largest divisible subset that ends with nums[i], while prev[i] stores the index of the previous element in the largest divisible subset that ends with nums[i].\\n\\nWe then iterate over the input array, and for each element nums[i], we check all previous elements nums[j] (j < i). If nums[i] is divisible by nums[j], and the size of the largest divisible subset that ends with nums[j] plus one is greater than the current size of dp[i], we update dp[i] and prev[i]. At the end of this process, we have computed the size of the largest divisible subset, which is stored in max_size, and the index of the last element in the largest divisible subset, which is stored in max_index.\\n\\nWe then use the prev array to backtrack from max_index to the first element in the largest divisible subset, appending each element to a result list. Finally, we return the result list in reverse order (since we built the list backwards during the backtracking process).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n    if not nums:\\n        return []\\n    # Sort the input array\\n    nums.sort()\\n    \\n    # Initialize a dynamic programming table\\n    # dp[i] stores the size of the largest divisible subset that ends with nums[i]\\n    dp = [1] * len(nums)\\n    \\n    # Initialize a backtracking table\\n    # prev[i] stores the index of the previous element in the largest divisible subset that ends with nums[i]\\n    prev = [-1] * len(nums)\\n    \\n    # Find the largest divisible subset and its size\\n    max_size = 1\\n    max_index = 0\\n    for i in range(1, len(nums)):\\n        for j in range(i):\\n            if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\\n                dp[i] = dp[j] + 1\\n                prev[i] = j\\n        if dp[i] > max_size:\\n            max_size = dp[i]\\n            max_index = i\\n    \\n    # Backtrack to find the largest divisible subset\\n    result = []\\n    while max_index != -1:\\n        result.append(nums[max_index])\\n        max_index = prev[max_index]\\n    \\n    return result[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n    if not nums:\\n        return []\\n    # Sort the input array\\n    nums.sort()\\n    \\n    # Initialize a dynamic programming table\\n    # dp[i] stores the size of the largest divisible subset that ends with nums[i]\\n    dp = [1] * len(nums)\\n    \\n    # Initialize a backtracking table\\n    # prev[i] stores the index of the previous element in the largest divisible subset that ends with nums[i]\\n    prev = [-1] * len(nums)\\n    \\n    # Find the largest divisible subset and its size\\n    max_size = 1\\n    max_index = 0\\n    for i in range(1, len(nums)):\\n        for j in range(i):\\n            if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\\n                dp[i] = dp[j] + 1\\n                prev[i] = j\\n        if dp[i] > max_size:\\n            max_size = dp[i]\\n            max_index = i\\n    \\n    # Backtrack to find the largest divisible subset\\n    result = []\\n    while max_index != -1:\\n        result.append(nums[max_index])\\n        max_index = prev[max_index]\\n    \\n    return result[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194573,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<int>dp(n,1) , hash(n);\\n        int maxi = 1;\\n        int lastindex = 0;\\n        for(int i=0;i<n;i++){\\n            hash[i] = i;\\n            for(int j=0;j<i;j++){\\n                if(( arr[i] % arr[j] == 0 ) && ( 1+dp[j] > dp[i] ) ){\\n                    dp[i] = dp[j] + 1;\\n                    hash[i] = j;\\n                }\\n            }\\n            if(dp[i] > maxi){\\n                maxi = dp[i];\\n                lastindex = i;\\n            }\\n            \\n        }\\n        \\n        vector<int>temp;\\n        temp.push_back(arr[lastindex]);\\n        while(  lastindex !=  hash[lastindex] ){\\n            lastindex = hash[lastindex];\\n            temp.push_back(arr[lastindex]);\\n        }\\n        \\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(),arr.end());\\n        vector<int>dp(n,1) , hash(n);\\n        int maxi = 1;\\n        int lastindex = 0;\\n        for(int i=0;i<n;i++){\\n            hash[i] = i;\\n            for(int j=0;j<i;j++){\\n                if(( arr[i] % arr[j] == 0 ) && ( 1+dp[j] > dp[i] ) ){\\n                    dp[i] = dp[j] + 1;\\n                    hash[i] = j;\\n                }\\n            }\\n            if(dp[i] > maxi){\\n                maxi = dp[i];\\n                lastindex = i;\\n            }\\n            \\n        }\\n        \\n        vector<int>temp;\\n        temp.push_back(arr[lastindex]);\\n        while(  lastindex !=  hash[lastindex] ){\\n            lastindex = hash[lastindex];\\n            temp.push_back(arr[lastindex]);\\n        }\\n        \\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065318,
                "title": "simple-python-solution-bottom-up-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NlogN + N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        prev=[[] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            curr=[[] for i in range(n+1)]\\n            for j in range(1,n+1):\\n                x=[]\\n                if (j-1)==0 or (nums[j-1]%nums[i-1]==0 or nums[i-1]%nums[j-1]==0):\\n                    x=prev[i]+[nums[i-1]]\\n                y=prev[j]\\n                if len(y)>len(x):\\n                    curr[j]=y[:]\\n                else:\\n                    curr[j]=x[:]\\n            prev=curr[:]\\n        return prev[1]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        prev=[[] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            curr=[[] for i in range(n+1)]\\n            for j in range(1,n+1):\\n                x=[]\\n                if (j-1)==0 or (nums[j-1]%nums[i-1]==0 or nums[i-1]%nums[j-1]==0):\\n                    x=prev[i]+[nums[i-1]]\\n                y=prev[j]\\n                if len(y)>len(x):\\n                    curr[j]=y[:]\\n                else:\\n                    curr[j]=x[:]\\n            prev=curr[:]\\n        return prev[1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483207,
                "title": "c-dp-memoization-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> dp(n,1);\\n        vector<int> hash(n,1);\\n        sort(arr.begin(),arr.end());\\n        for(int i=0; i<=n-1; i++){\\n\\n            hash[i] = i; \\n            for(int prev_index = 0; prev_index <=i-1; prev_index ++){\\n\\n                if(arr[i]%arr[prev_index]==0 && 1 + dp[prev_index] > dp[i]){\\n                    dp[i] = 1 + dp[prev_index];\\n                    hash[i] = prev_index;\\n                }\\n            }\\n        }\\n\\n        int ans = -1;\\n        int lastIndex =-1;\\n\\n        for(int i=0; i<=n-1; i++){\\n            if(dp[i]> ans){\\n                ans = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n\\n        vector<int> temp;\\n        temp.push_back(arr[lastIndex]);\\n\\n        while(hash[lastIndex] != lastIndex){ \\n            lastIndex = hash[lastIndex];\\n            temp.push_back(arr[lastIndex]);    \\n        }\\n\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> dp(n,1);\\n        vector<int> hash(n,1);\\n        sort(arr.begin(),arr.end());\\n        for(int i=0; i<=n-1; i++){\\n\\n            hash[i] = i; \\n            for(int prev_index = 0; prev_index <=i-1; prev_index ++){\\n\\n                if(arr[i]%arr[prev_index]==0 && 1 + dp[prev_index] > dp[i]){\\n                    dp[i] = 1 + dp[prev_index];\\n                    hash[i] = prev_index;\\n                }\\n            }\\n        }\\n\\n        int ans = -1;\\n        int lastIndex =-1;\\n\\n        for(int i=0; i<=n-1; i++){\\n            if(dp[i]> ans){\\n                ans = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n\\n        vector<int> temp;\\n        temp.push_back(arr[lastIndex]);\\n\\n        while(hash[lastIndex] != lastIndex){ \\n            lastIndex = hash[lastIndex];\\n            temp.push_back(arr[lastIndex]);    \\n        }\\n\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268162,
                "title": "c-sorting-greedy-dp",
                "content": "We are starting from first index and updating the max Subset in the 2d vector.\\n\\nTime complexity -> O(N^2)\\nSpace complexity ->O(N^2)\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<vector<int>>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i].push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]%nums[i]==0)    \\n                {\\n                    if(ans[j].size()<=ans[i].size())\\n                    {\\n                        ans[j]=ans[i];\\n                        ans[j].push_back(nums[j]);\\n                    }\\n                }\\n            }            \\n        }\\n        int maxAns=0;\\n        vector<int> last={};\\n        for(auto i:ans)\\n        {\\n            if(i.size()>maxAns)\\n            {\\n                maxAns=i.size();\\n                last=i;\\n            }\\n        }\\n        return last;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        vector<vector<int>>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[i].push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[j]%nums[i]==0)    \\n                {\\n                    if(ans[j].size()<=ans[i].size())\\n                    {\\n                        ans[j]=ans[i];\\n                        ans[j].push_back(nums[j]);\\n                    }\\n                }\\n            }            \\n        }\\n        int maxAns=0;\\n        vector<int> last={};\\n        for(auto i:ans)\\n        {\\n            if(i.size()>maxAns)\\n            {\\n                maxAns=i.size();\\n                last=i;\\n            }\\n        }\\n        return last;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265043,
                "title": "c-both-recursive-and-tabulation-method-clean-code",
                "content": "####  ***Recursive code will give TLE as of Exponential complexity!!***\\n```\\nclass Solution {\\n    \\n    vector<int> global;\\n    void dfs(vector<int> &nums, int curr, int prev, vector<int> res)\\n    {\\n        if(curr==nums.size()) \\n        {\\n            if(res.size()>global.size()) global = res;\\n            return;\\n        }\\n        \\n        dfs(nums,curr+1,prev,res); //not take\\n        \\n        if(prev == -1 || nums[curr]%nums[prev]==0)\\n        {\\n            res.push_back(nums[curr]);\\n            dfs(nums,curr+1,curr,res); // take\\n        }\\n        return;\\n    }\\n    \\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        global = {};\\n        sort(nums.begin(),nums.end());\\n        dfs(nums,0,-1,{});\\n        return global;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n####  ***Tabulation method O(n * n) time and O(n) space!!***\\n``` \\nclass Solution {    \\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int n = nums.size();\\n        int max_len = 1;\\n        vector<int> dp(n,1), prev(n);\\n        int lastIndex = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            prev[i] = i;\\n            for(int j =0; j<i; j++)\\n            {\\n                if(nums[i]%nums[j]==0)\\n                {\\n                    if(dp[j]+1 > dp[i])\\n                    {\\n                        prev[i] = j;\\n                        dp[i] =  dp[j] + 1;\\n                    }\\n                }\\n            }\\n            \\n            if(dp[i]>max_len)\\n            {\\n                max_len = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        vector<int> ans(max_len);\\n        ans[max_len-1] = nums[lastIndex];\\n        int ind = max_len -2;\\n            while(prev[lastIndex]!=lastIndex)\\n            {\\n                lastIndex = prev[lastIndex];\\n                ans[ind] = nums[lastIndex];\\n                ind--;\\n            }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<int> global;\\n    void dfs(vector<int> &nums, int curr, int prev, vector<int> res)\\n    {\\n        if(curr==nums.size()) \\n        {\\n            if(res.size()>global.size()) global = res;\\n            return;\\n        }\\n        \\n        dfs(nums,curr+1,prev,res); //not take\\n        \\n        if(prev == -1 || nums[curr]%nums[prev]==0)\\n        {\\n            res.push_back(nums[curr]);\\n            dfs(nums,curr+1,curr,res); // take\\n        }\\n        return;\\n    }\\n    \\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        global = {};\\n        sort(nums.begin(),nums.end());\\n        dfs(nums,0,-1,{});\\n        return global;\\n    }\\n};\\n```\n``` \\nclass Solution {    \\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int n = nums.size();\\n        int max_len = 1;\\n        vector<int> dp(n,1), prev(n);\\n        int lastIndex = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            prev[i] = i;\\n            for(int j =0; j<i; j++)\\n            {\\n                if(nums[i]%nums[j]==0)\\n                {\\n                    if(dp[j]+1 > dp[i])\\n                    {\\n                        prev[i] = j;\\n                        dp[i] =  dp[j] + 1;\\n                    }\\n                }\\n            }\\n            \\n            if(dp[i]>max_len)\\n            {\\n                max_len = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n        \\n        vector<int> ans(max_len);\\n        ans[max_len-1] = nums[lastIndex];\\n        int ind = max_len -2;\\n            while(prev[lastIndex]!=lastIndex)\\n            {\\n                lastIndex = prev[lastIndex];\\n                ans[ind] = nums[lastIndex];\\n                ind--;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194778,
                "title": "java-solution-similar-to-lis-pattern-simple-explanation",
                "content": "\\n\\t\\n\\tclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        int lds[] = new int[nums.length]; //fill the lds array with 1 because the minimum length subset we create is 1\\n        Arrays.fill(lds,1);\\n        int max=1;\\n        int prev=nums[0]; //prev tracks the last element of the longest subset\\n        for(int i=1;i<nums.length;i++){\\n            for(int j=0;j<i;j++){\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//if we find a pair(a,b) at (i,j) where a % b gives 0 and the length of the subset till \\'a\\' (index \\'i\\')\\n\\t\\t\\t//is less then or equal to \\'b\\'(index \\'j\\') ,we update the length of the largest divisible subset found till  \\'a\\' at lds[i]\\n\\t\\t\\t\\n                if(nums[i]%nums[j]==0 && lds[i]<=lds[j]){  \\n                    lds[i]=lds[j]+1;\\n\\t\\t\\t\\t\\t\\n                    // max=Math.max(max,lds[i]);\\n\\t\\t\\t\\t\\t//track the maximum length of divisible subset found and store the last element of the subset in prev\\n                  \\n\\t\\t\\t\\t        if(max<lds[i]){\\n                        max=lds[i];\\n                        prev=nums[i];\\n                    }\\n                }\\n            }\\n        }\\n        List<Integer> list = new ArrayList();\\n        for(int i=nums.length-1;i>=0;i--){\\n\\t\\t\\n\\t\\t//now we iterate the lds array and pick elements one by one if their lds ends with \\'max\\' length\\n\\t\\t//and also check if it is divisible by the previous element\\n\\t\\t\\n            if(max==lds[i]  && prev%nums[i]==0){\\n                list.add(nums[i]);\\n                    max-=1;\\n                prev=nums[i];\\n            }\\n                \\n        }\\n        return list;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        int lds[] = new int[nums.length]; //fill the lds array with 1 because the minimum length subset we create is 1\\n        Arrays.fill(lds,1);\\n        int max=1;\\n        int prev=nums[0]; //prev tracks the last element of the longest subset\\n        for(int i=1;i<nums.length;i++){\\n            for(int j=0;j<i;j++){\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//if we find a pair(a,b) at (i,j) where a % b gives 0 and the length of the subset till \\'a\\' (index \\'i\\')\\n\\t\\t\\t//is less then or equal to \\'b\\'(index \\'j\\') ,we update the length of the largest divisible subset found till  \\'a\\' at lds[i]\\n\\t\\t\\t\\n                if(nums[i]%nums[j]==0 && lds[i]<=lds[j]){  \\n                    lds[i]=lds[j]+1;\\n\\t\\t\\t\\t\\t\\n                    // max=Math.max(max,lds[i]);\\n\\t\\t\\t\\t\\t//track the maximum length of divisible subset found and store the last element of the subset in prev\\n                  \\n\\t\\t\\t\\t        if(max<lds[i]){\\n                        max=lds[i];\\n                        prev=nums[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1653520,
                "title": "c-commented-c-solution-o-n-2-time-o-n-space-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<pair<int, int>> dp(nums.size(), {1, -1}); // set size, previous tracing index\\n        vector<int> res;\\n        \\n        int maxIndex = 0;\\n        int maxSize = 1;\\n        \\n        // sort the array because of element with common divisor does not\\n        // mean that ther are divisible\\n        sort(nums.begin(), nums.end());\\n        \\n        // for each element in nums\\n        for (int i = 1; i < nums.size(); i++) {\\n            \\n            // for each element before i, check if it is divisible\\n            for (int j = 0; j < i; j++) {\\n                \\n                // divisible with a larger subset size, dp it\\n                if (nums[i] % nums[j] == 0 && dp[j].first + 1 > dp[i].first) {\\n                    dp[i].first = dp[j].first + 1;\\n                    dp[i].second = j;\\n                }\\n            }\\n            \\n            // mark down the starting point of the current largest subset\\n            if (dp[i].first > maxSize) {\\n                maxSize = dp[i].first;\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        // Rebuild one of the subsets, order is not important\\n        while (maxIndex >= 0) {\\n            res.push_back(nums[maxIndex]);\\n            maxIndex = dp[maxIndex].second;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        vector<pair<int, int>> dp(nums.size(), {1, -1}); // set size, previous tracing index\\n        vector<int> res;\\n        \\n        int maxIndex = 0;\\n        int maxSize = 1;\\n        \\n        // sort the array because of element with common divisor does not\\n        // mean that ther are divisible\\n        sort(nums.begin(), nums.end());\\n        \\n        // for each element in nums\\n        for (int i = 1; i < nums.size(); i++) {\\n            \\n            // for each element before i, check if it is divisible\\n            for (int j = 0; j < i; j++) {\\n                \\n                // divisible with a larger subset size, dp it\\n                if (nums[i] % nums[j] == 0 && dp[j].first + 1 > dp[i].first) {\\n                    dp[i].first = dp[j].first + 1;\\n                    dp[i].second = j;\\n                }\\n            }\\n            \\n            // mark down the starting point of the current largest subset\\n            if (dp[i].first > maxSize) {\\n                maxSize = dp[i].first;\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        // Rebuild one of the subsets, order is not important\\n        while (maxIndex >= 0) {\\n            res.push_back(nums[maxIndex]);\\n            maxIndex = dp[maxIndex].second;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579684,
                "title": "c-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = size(nums), max_i = 0;\\n\\t\\t// initially dp[i]=1 since we can always form subset of size=1 ending at i. \\n\\t\\t// pred[i]=-1 because we havent found any predecessors for any subset yet\\n        vector<int> dp(n, 1), pred(n, -1), ans;\\n        for(int i = 1; i < n; i++) {          \\n            for(int j = 0; j < i; j++)     \\n\\t\\t\\t\\t// nums[i] should divide nums[j] if it is to be included in its subset (i.e dp[j])\\n\\t\\t\\t\\t// only include nums[i] in subset ending at j if resultant subset size (dp[j]+1) is larger than already possible (dp[i])\\n                if(nums[i] % nums[j] == 0 && dp[i] < dp[j]+1)\\n                    dp[i] = dp[j]+1, pred[i] = j;  // jth element will be predecessor to subset ending at ith element\\n            if(dp[i] > dp[max_i]) max_i = i;       // keep track of index where largest subset ends\\n        }\\n\\t\\t// start with index where largest subset ended. Reconstruct from that point to the start\\n        for(; max_i >= 0; max_i = pred[max_i]) \\n            ans.push_back(nums[max_i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int n = size(nums), max_i = 0;\\n\\t\\t// initially dp[i]=1 since we can always form subset of size=1 ending at i. \\n\\t\\t// pred[i]=-1 because we havent found any predecessors for any subset yet\\n        vector<int> dp(n, 1), pred(n, -1), ans;\\n        for(int i = 1; i < n; i++) {          \\n            for(int j = 0; j < i; j++)     \\n\\t\\t\\t\\t// nums[i] should divide nums[j] if it is to be included in its subset (i.e dp[j])\\n\\t\\t\\t\\t// only include nums[i] in subset ending at j if resultant subset size (dp[j]+1) is larger than already possible (dp[i])\\n                if(nums[i] % nums[j] == 0 && dp[i] < dp[j]+1)\\n                    dp[i] = dp[j]+1, pred[i] = j;  // jth element will be predecessor to subset ending at ith element\\n            if(dp[i] > dp[max_i]) max_i = i;       // keep track of index where largest subset ends\\n        }\\n\\t\\t// start with index where largest subset ended. Reconstruct from that point to the start\\n        for(; max_i >= 0; max_i = pred[max_i]) \\n            ans.push_back(nums[max_i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579088,
                "title": "c-clean-and-concise-code-with-proper-explanation",
                "content": "class Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        /* PREREQUISITES : DYNAMIC PROGRAMMING + GREEDY SORTING \\n        \\n        Time Complexity  : O(N^2) + O(N*logN)\\n\\t\\tSpace Complexity : O(N)\\n        \\n        *** We have to sort the array in ascending order , as we wanna discard the second condition from our calculation , i.e [answer[j]%answer[i]==0]\\n        \\n        If j<i , it implies  answer[j] < answer[i] . That\\'s why we assert the fact that (answer[j] % answer[i]!=0)\\n        \\n        \\n        *** Now another condition is that we have to return the LARGEST DIVISIBLE SUBSET....\\n        \\n        For these we have to store the result , that is what is the maximum length subset possible till index i from index 0. \\n        \\n        And DP can easily fulfil these requirement.\\n        \\n        *** But there is another obstacle , by using dp we can store the length of the largest divisible subset , but how can we process them or restore them to return thr result.\\n        \\n        Using a \"prev\" array , we can easilt store the prev Index of the index i(i.e current index) which is the part of the Largest divisible subset ending at index i.\\n        \\n        \\n        \\n        */\\n        \\n        \\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        vector<int>prev(n,-1);\\n        \\n        vector<int>dp(n,1);\\n        \\n        int maxIndex=0;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if(nums[i]%nums[j]==0){\\n                    \\n                    if(dp[i]<dp[j]+1){\\n                        \\n                        dp[i]=dp[j]+1;\\n                        prev[i]=j;\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            if(dp[maxIndex]<dp[i]){\\n                maxIndex=i;\\n            }\\n            \\n        }\\n        \\n        \\n        vector<int>result;\\n        \\n        int k=maxIndex;\\n        \\n        while(k!=-1){\\n            \\n            result.push_back(nums[k]);\\n            \\n            k=prev[k];\\n            \\n        }\\n        \\n        reverse(result.begin(),result.end());\\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        /* PREREQUISITES : DYNAMIC PROGRAMMING + GREEDY SORTING \\n        \\n        Time Complexity  : O(N^2) + O(N*logN)\\n\\t\\tSpace Complexity : O(N)\\n        \\n        *** We have to sort the array in ascending order , as we wanna discard the second condition from our calculation , i.e [answer[j]%answer[i]==0]\\n        \\n        If j<i , it implies  answer[j] < answer[i] . That\\'s why we assert the fact that (answer[j] % answer[i]!=0)\\n        \\n        \\n        *** Now another condition is that we have to return the LARGEST DIVISIBLE SUBSET....\\n        \\n        For these we have to store the result , that is what is the maximum length subset possible till index i from index 0. \\n        \\n        And DP can easily fulfil these requirement.\\n        \\n        *** But there is another obstacle , by using dp we can store the length of the largest divisible subset , but how can we process them or restore them to return thr result.\\n        \\n        Using a \"prev\" array , we can easilt store the prev Index of the index i(i.e current index) which is the part of the Largest divisible subset ending at index i.\\n        \\n        \\n        \\n        */\\n        \\n        \\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        vector<int>prev(n,-1);\\n        \\n        vector<int>dp(n,1);\\n        \\n        int maxIndex=0;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=0;j<i;j++){\\n                \\n                if(nums[i]%nums[j]==0){\\n                    \\n                    if(dp[i]<dp[j]+1){\\n                        \\n                        dp[i]=dp[j]+1;\\n                        prev[i]=j;\\n                        \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1579070,
                "title": "largest-divisible-subset-c-apply-lis-method",
                "content": "class Solution {\\npublic:\\n   \\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());  // O(NlogN)\\n        \\n        vector<int> dp(n+1, 1);\\n        int max = 1;\\n        \\n        // LIS subsequence  // O(N^2)\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]%nums[j] == 0 && 1+dp[j] > dp[i]){\\n                    dp[i] = 1+dp[j];\\n                    if(max < dp[i])   \\n                        max = dp[i];\\n                }\\n            }\\n        }\\n        \\n        // Subsets \\n        vector<int> ans;\\n        \\n        int prev = -1;\\n        for(int i=n-1; i>=0; i--){   // O(N)\\n            if(dp[i] == max && (prev == -1 || prev%nums[i] == 0)){\\n                ans.push_back(nums[i]);\\n                max -= 1;\\n                prev = nums[i];\\n            }\\n        }\\n        \\n        // sort(ans.begin(), ans.end()); // This is just to make a increasing wise order\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n// Time Complexity :- O(NlogN)+O(N^2)+O(N)\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());  // O(NlogN)\\n        \\n        vector<int> dp(n+1, 1);\\n        int max = 1;\\n        \\n        // LIS subsequence  // O(N^2)\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[i]%nums[j] == 0 && 1+dp[j] > dp[i]){\\n                    dp[i] = 1+dp[j];\\n                    if(max < dp[i])   \\n                        max = dp[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1579023,
                "title": "java-easy-solution-dp-sorting",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> dp[]=new ArrayList[nums.length];\\n        dp[0]=new ArrayList<Integer>();\\n        dp[0].add(nums[0]);\\n        List<Integer> result=dp[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            dp[i]=new ArrayList<>();\\n            dp[i].add(nums[i]);\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0){\\n                    if(dp[i].size()<dp[j].size()+1)\\n                    {\\n                        dp[i]=(ArrayList<Integer>)dp[j].clone();\\n                        dp[i].add(nums[i]);\\n                    }\\n                }\\n            }\\n            if(max<dp[i].size())\\n            {   result=dp[i];\\n                max=dp[i].size();\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        ArrayList<Integer> dp[]=new ArrayList[nums.length];\\n        dp[0]=new ArrayList<Integer>();\\n        dp[0].add(nums[0]);\\n        List<Integer> result=dp[0];\\n        int max=Integer.MIN_VALUE;\\n        for(int i=1;i<nums.length;i++){\\n            dp[i]=new ArrayList<>();\\n            dp[i].add(nums[i]);\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[i]%nums[j]==0){\\n                    if(dp[i].size()<dp[j].size()+1)\\n                    {\\n                        dp[i]=(ArrayList<Integer>)dp[j].clone();\\n                        dp[i].add(nums[i]);\\n                    }\\n                }\\n            }\\n            if(max<dp[i].size())\\n            {   result=dp[i];\\n                max=dp[i].size();\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578854,
                "title": "python-readable-dp-solution",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        # Empty set to start the smallest subset.\\n        # `-1` since anything is divisible by it.\\n        divisors = {-1: set()}\\n        for x in nums:\\n            divisible = []\\n            for d, subset in divisors.items():\\n                # Only need to check the key since every\\n                # other number in the value will be a divisor\\n                # of the key.\\n                if x % d == 0:\\n                    divisible.append(subset)\\n            # Need to use `.union()` because it will return a new set.\\n            # Compared to `.add(), which will mutate the set and return `None`.\\n            divisors[x] = max(divisible, key=len).union({x})\\n        largest = max(list(divisors.values()), key=len)\\n        return largest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        # Empty set to start the smallest subset.\\n        # `-1` since anything is divisible by it.\\n        divisors = {-1: set()}\\n        for x in nums:\\n            divisible = []\\n            for d, subset in divisors.items():\\n                # Only need to check the key since every\\n                # other number in the value will be a divisor\\n                # of the key.\\n                if x % d == 0:\\n                    divisible.append(subset)\\n            # Need to use `.union()` because it will return a new set.\\n            # Compared to `.add(), which will mutate the set and return `None`.\\n            divisors[x] = max(divisible, key=len).union({x})\\n        largest = max(list(divisors.values()), key=len)\\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578837,
                "title": "straightforward-dp-approach-with-comments",
                "content": "```\\npublic class Solution {\\n    public IList<int> LargestDivisibleSubset(int[] nums) {        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // List array of size n\\n        var dp = new List<int>[nums.Length];\\n        \\n        // Go through numbers\\n        var resultIndex = 0;        \\n        for (int i = 0; i < nums.Length; ++i) {\\n            dp[i] = new List<int>();\\n            \\n            // Go through numbers that come before i and determine the maximum subset for i\\n            var currentMaxIndex = i;            \\n            for (int j = 0; j < i; ++j) {\\n                // Check if the two numbers satisfies the condition\\n                if ((nums[i] % nums[j] == 0 || nums[j] % nums[i] == 0) && dp[currentMaxIndex].Count < dp[j].Count) {\\n                    currentMaxIndex = j;\\n                }  \\n            }\\n            // Save items from max index to current dp index\\n            if (currentMaxIndex != i) {\\n                dp[i] = new List<int>(dp[currentMaxIndex]);\\n            }\\n            \\n            // Add current number to current dp index\\n            dp[i].Add(nums[i]);\\n            \\n            // Keep track of the largest subset \\n            if (dp[i].Count > dp[resultIndex].Count) {\\n                resultIndex = i;\\n            }   \\n        }\\n        return dp[resultIndex];        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> LargestDivisibleSubset(int[] nums) {        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // List array of size n\\n        var dp = new List<int>[nums.Length];\\n        \\n        // Go through numbers\\n        var resultIndex = 0;        \\n        for (int i = 0; i < nums.Length; ++i) {\\n            dp[i] = new List<int>();\\n            \\n            // Go through numbers that come before i and determine the maximum subset for i\\n            var currentMaxIndex = i;            \\n            for (int j = 0; j < i; ++j) {\\n                // Check if the two numbers satisfies the condition\\n                if ((nums[i] % nums[j] == 0 || nums[j] % nums[i] == 0) && dp[currentMaxIndex].Count < dp[j].Count) {\\n                    currentMaxIndex = j;\\n                }  \\n            }\\n            // Save items from max index to current dp index\\n            if (currentMaxIndex != i) {\\n                dp[i] = new List<int>(dp[currentMaxIndex]);\\n            }\\n            \\n            // Add current number to current dp index\\n            dp[i].Add(nums[i]);\\n            \\n            // Keep track of the largest subset \\n            if (dp[i].Count > dp[resultIndex].Count) {\\n                resultIndex = i;\\n            }   \\n        }\\n        return dp[resultIndex];        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578774,
                "title": "python-bfs-solution-804-ms-beats-5-78-o-n-2",
                "content": "This algorithm uses BFS.\\n(0)Think of each number as nodes\\n(1)Connect nodes if they are valid pair. (nums[j] % nums[i] = 0, i < j)\\n(2)all edges are always small -> large, so that there is no loop.\\nFor example,\\nnums = [1,2,3]\\n1 -> 2\\n1 -> 3\\n[Combined]\\n1 -> 2\\n   |\\n   -> 3\\n \\nnums = [1,2,4,8]\\n1 -> 2\\n1 -> 4\\n1 -> 8\\n2 -> 4\\n2 -> 8\\n4 -> 8\\n[Combined]\\n1 -> 2 -> 4 -> 8\\n  |\\n  -> 4 -> 8\\n  |\\n  -> 8\\n  \\n(3)Then, find the longest chain in the graph. In this case, 1 -> 2 (or 1 -> 3) and 1 -> 2 -> 4 -> 8 is the longest.\\n(4)With memoization technique by storing distances, it avoids calculating the non-best path.\\n\\nRuntime is O(N^2) for constructing the graph.\\n\\n```\\nfrom queue import Queue\\nimport math\\n\\nclass Graph:\\n    def __init__(self, nums):\\n        self.V = nums\\n        self.graph = [[] for _ in range(nums)]\\n        self.non_start_nodes = set()\\n        self.dist = [-math.inf for _ in range(nums)]\\n    \\n    def add_edge(self, a, b):\\n        self.graph[a].append(b)\\n        self.non_start_nodes.add(b)\\n    \\n    def bfs(self):\\n        queue = Queue()\\n        longest_so_far = 0\\n        best_pair_so_far = None\\n        \\n        for i in range(self.V):\\n            if i not in self.non_start_nodes:\\n                queue.put((i, [i]))\\n        \\n        while not queue.empty():\\n            u, cur_list = queue.get()\\n            dist = len(cur_list)\\n            if self.dist[u] >= dist:\\n                continue\\n            self.dist[u] = dist\\n                \\n            if len(cur_list) > longest_so_far:\\n                longest_so_far = len(cur_list)\\n                best_pair_so_far = cur_list[:]\\n            \\n            for ad in self.graph[u]:\\n                queue.put((ad, cur_list + [ad]))\\n            \\n        return best_pair_so_far\\n\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        #construct graph\\n        N = len(nums)\\n        g = Graph(N)\\n        nums.sort()\\n        for i in range(N):\\n            for j in range(i + 1, N):\\n                if nums[j] % nums[i] == 0:\\n                    g.add_edge(i, j)\\n        \\n\\t\\t#do bfs\\n        pair = g.bfs()\\n        return [nums[idx] for idx in pair]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nfrom queue import Queue\\nimport math\\n\\nclass Graph:\\n    def __init__(self, nums):\\n        self.V = nums\\n        self.graph = [[] for _ in range(nums)]\\n        self.non_start_nodes = set()\\n        self.dist = [-math.inf for _ in range(nums)]\\n    \\n    def add_edge(self, a, b):\\n        self.graph[a].append(b)\\n        self.non_start_nodes.add(b)\\n    \\n    def bfs(self):\\n        queue = Queue()\\n        longest_so_far = 0\\n        best_pair_so_far = None\\n        \\n        for i in range(self.V):\\n            if i not in self.non_start_nodes:\\n                queue.put((i, [i]))\\n        \\n        while not queue.empty():\\n            u, cur_list = queue.get()\\n            dist = len(cur_list)\\n            if self.dist[u] >= dist:\\n                continue\\n            self.dist[u] = dist\\n                \\n            if len(cur_list) > longest_so_far:\\n                longest_so_far = len(cur_list)\\n                best_pair_so_far = cur_list[:]\\n            \\n            for ad in self.graph[u]:\\n                queue.put((ad, cur_list + [ad]))\\n            \\n        return best_pair_so_far\\n\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        #construct graph\\n        N = len(nums)\\n        g = Graph(N)\\n        nums.sort()\\n        for i in range(N):\\n            for j in range(i + 1, N):\\n                if nums[j] % nums[i] == 0:\\n                    g.add_edge(i, j)\\n        \\n\\t\\t#do bfs\\n        pair = g.bfs()\\n        return [nums[idx] for idx in pair]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523223,
                "title": "c-easy-solution",
                "content": "\\t// Solution 1 : Memoization\\n\\tpublic class Solution\\n\\t{\\n\\t\\tpublic IList<int> LargestDivisibleSubset(int[] nums)\\n\\t\\t{\\n\\t\\t\\tArray.Sort(nums);\\n\\t\\t\\treturn Solve(nums, -1, new List<int>[nums.Length]);\\n\\t\\t}\\n\\n\\t\\tpublic List<int> Solve(int[] nums, int idx, List<int>[] dp)\\n\\t\\t{\\n\\t\\t\\tif (idx >= nums.Length)\\n\\t\\t\\t\\treturn new List<int>();\\n\\n\\t\\t\\tif (idx != -1 && dp[idx] != null)\\n\\t\\t\\t\\treturn dp[idx].ToList();\\n\\n\\t\\t\\tList<int> ans = new List<int>();\\n\\n\\t\\t\\tfor (int i = idx + 1; i < nums.Length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (idx == -1 || nums[i] % nums[idx] == 0 || nums[idx] % nums[i] == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tList<int> res = Solve(nums, i, dp);\\n\\t\\t\\t\\t\\tif (res.Count + 1 > ans.Count)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(res.Count == 0 || res[0] != nums[i])\\n\\t\\t\\t\\t\\t\\t\\tres.Insert(0, nums[i]);\\n\\t\\t\\t\\t\\t\\tans = res.ToList();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (idx != -1)\\n\\t\\t\\t\\tdp[idx] = ans;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Solution 2 : Tabulation\\n\\tpublic class Solution\\n    {\\n        public IList<int> LargestDivisibleSubset(int[] nums)\\n        {\\n            Array.Sort(nums);\\n\\n            List<int> ans = new List<int>();\\n            List<int>[] dp = new List<int>[nums.Length];\\n\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                dp[i] = new List<int>();\\n\\n                for(int j = 0; j < i; j++)\\n                {\\n                    if ((nums[i] % nums[j] == 0 || nums[j] % nums[i] == 0) && dp[i].Count < dp[j].Count)\\n                        dp[i] = dp[j].ToList();\\n                }\\n\\n                dp[i].Add(nums[i]);\\n\\n                if (dp[i].Count > ans.Count)\\n                    ans = dp[i];\\n            }\\n\\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n\\t{\\n\\t\\tpublic IList<int> LargestDivisibleSubset(int[] nums)\\n\\t\\t{\\n\\t\\t\\tArray.Sort(nums);\\n\\t\\t\\treturn Solve(nums, -1, new List<int>[nums.Length]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1444758,
                "title": "java-bfs-topological-sort-with-comment-easier-understandable-solution-at-least-for-myself",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        // Sort it in order to build a directed graph as nums[i+1] > nums[i]\\n        Arrays.sort(nums);\\n        \\n        // Build directed graph\\n        int[] indegree = new int[nums.length];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(i, new ArrayList<>());\\n            for (int j = i+1; j < nums.length; j++) {\\n                if (nums[j] % nums[i] == 0) {\\n                    map.get(i).add(j);\\n                    indegree[j]++;\\n                }    \\n            }\\n        }\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < indegree.length; i++) {\\n            if (indegree[i] == 0)\\n                q.add(i);\\n        }\\n        \\n        // Do bfs and save the path\\n        // keep updating the last element in candidate set because bfs is used here\\n        // so that the last processed element must be one of the answer\\n        int[] prev = new int[nums.length];\\n        for (int i = 0; i < prev.length; i++)\\n            prev[i] = i;\\n        int candidate = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                for (int child : map.get(cur)) {\\n\\t\\t\\t\\t    // Note the element to update indegree[child] to zero is the largest element in the set,\\n\\t\\t\\t\\t\\t// which is smaller than child, so that we can always get the path.\\n                    if (--indegree[child] == 0) {\\n                        q.add(child);\\n                        prev[child] = cur; \\n                    }     \\n                }\\n                candidate = cur;\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        while (prev[candidate] != candidate) {\\n            res.add(nums[candidate]);\\n            candidate = prev[candidate];\\n        }\\n        // add the smallest number into set\\n        res.add(nums[candidate]);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        // Sort it in order to build a directed graph as nums[i+1] > nums[i]\\n        Arrays.sort(nums);\\n        \\n        // Build directed graph\\n        int[] indegree = new int[nums.length];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            map.put(i, new ArrayList<>());\\n            for (int j = i+1; j < nums.length; j++) {\\n                if (nums[j] % nums[i] == 0) {\\n                    map.get(i).add(j);\\n                    indegree[j]++;\\n                }    \\n            }\\n        }\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < indegree.length; i++) {\\n            if (indegree[i] == 0)\\n                q.add(i);\\n        }\\n        \\n        // Do bfs and save the path\\n        // keep updating the last element in candidate set because bfs is used here\\n        // so that the last processed element must be one of the answer\\n        int[] prev = new int[nums.length];\\n        for (int i = 0; i < prev.length; i++)\\n            prev[i] = i;\\n        int candidate = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                for (int child : map.get(cur)) {\\n\\t\\t\\t\\t    // Note the element to update indegree[child] to zero is the largest element in the set,\\n\\t\\t\\t\\t\\t// which is smaller than child, so that we can always get the path.\\n                    if (--indegree[child] == 0) {\\n                        q.add(child);\\n                        prev[child] = cur; \\n                    }     \\n                }\\n                candidate = cur;\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        while (prev[candidate] != candidate) {\\n            res.add(nums[candidate]);\\n            candidate = prev[candidate];\\n        }\\n        // add the smallest number into set\\n        res.add(nums[candidate]);\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442159,
                "title": "o-n-2-dp-with-complete-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,1); // every number is divisible by itself\\n        sort(nums.begin(),nums.end()); // divisor of a number will have to be less than or equal to the number\\n        vector<int> divisors[n]; // vector of divisors of every element at pos 0..n-1\\n        for(int i=0; i<n; i++) {\\n            pair<int,int> pos={INT_MIN,-1};  \\n            for(int j=i-1; j>=0; j--) {\\n\\t\\t\\t     // get the previous maximum dp state {contains  maximum divisors } \\n                  if(nums[i]%nums[j]==0 && pos.first<dp[j]) pos={dp[j],j}; \\n            }\\n            if(pos.second!=-1) {              \\n\\t\\t\\t    // if there is a previous state , add all the divisors + number itself\\n                divisors[i]=divisors[pos.second];\\n                dp[i]+=dp[pos.second];\\n            }\\n            divisors[i].push_back(nums[i]);\\n        }\\n        return divisors[max_element(dp.begin(),dp.end())-dp.begin()]; // dp state of pos of element with most divisors \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,1); // every number is divisible by itself\\n        sort(nums.begin(),nums.end()); // divisor of a number will have to be less than or equal to the number\\n        vector<int> divisors[n]; // vector of divisors of every element at pos 0..n-1\\n        for(int i=0; i<n; i++) {\\n            pair<int,int> pos={INT_MIN,-1};  \\n            for(int j=i-1; j>=0; j--) {\\n\\t\\t\\t     // get the previous maximum dp state {contains  maximum divisors } \\n                  if(nums[i]%nums[j]==0 && pos.first<dp[j]) pos={dp[j],j}; \\n            }\\n            if(pos.second!=-1) {              \\n\\t\\t\\t    // if there is a previous state , add all the divisors + number itself\\n                divisors[i]=divisors[pos.second];\\n                dp[i]+=dp[pos.second];\\n            }\\n            divisors[i].push_back(nums[i]);\\n        }\\n        return divisors[max_element(dp.begin(),dp.end())-dp.begin()]; // dp state of pos of element with most divisors \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304215,
                "title": "c-lis-96-faster-explanation",
                "content": "\\nSimple lis - instead of a[i]<a[j] condition is a[i]%a[j]==0 and also print the subsequence\\n\\na[] => input array\\ndp[] => this array stores longest length of valid sequence we got till now\\n          ie dp[i] = longest valid sequence ending at index i\\n\\t\\t  \\n**How to print the final longest subsequence we got ?**\\n-> Make a array to store previous index and backtrack using it.\\n\\nlis[i] => stores if a[i] qualifies for a particular subsequce then its previous element will be situated at index lis[i] so we can bactrack and will print it.\\n  ie   \\n  lis[i] = index_of_element_occuring_just_before_a[i]_in_a_subsequence\\n \\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define all(c) c.begin(),c.end()\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& a) {\\n        \\n        int i,j,n=a.size(),mx=-1,ind=0;\\n        sort(all(a));\\n       \\n        int dp[1005]={0};\\n        int lis[1005];\\n        \\n        memset(lis,-1,sizeof(lis));\\n        \\n        \\n        for(i=1;i<n;i++){\\n            \\n            for(j=0;j<i;j++){\\n                \\n                if(a[i]%a[j]==0 and dp[j]+1>=dp[i]){\\n                    \\n                    dp[i] = dp[j]+1;\\n                    lis[i] = j;\\n                }\\n                \\n            }\\n            \\n            if(mx<dp[i]){\\n                mx=dp[i];\\n                ind=i; // index with longest subsequence till now\\n            }\\n        }\\n        \\n      /*   ---- Uncomment to understand the flow ---\\n        for(i=0;i<n;i++){\\n            cout<<a[i]<<\" \";\\n        }\\n        cout<<endl;\\n        \\n        for(i=0;i<n;i++){\\n            cout<<dp[i]<<\" \";\\n        }\\n        cout<<endl;\\n        \\n        for(i=0;i<n;i++){\\n            cout<<lis[i]<<\" \";\\n        }\\n        cout<<endl;\\n        */\\n        \\n        \\n        vector<int>ans;\\n       \\n        \\n      //  Print the longest subsequence \\n        \\n        int g=0;\\n        while(1){\\n            ans.push_back(a[ind]);\\n            ind=lis[ind];\\n       \\n            if(ind==-1)break;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\n**plz upvote if found useful**\\n\\n/*\\n[1,2,3,4,6,8,9,12,15,18,21,24,27]\\n[1,2,7,14,28,56]\\n[1,2,7,49,343,2401]\\n*/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define all(c) c.begin(),c.end()\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& a) {\\n        \\n        int i,j,n=a.size(),mx=-1,ind=0;\\n        sort(all(a));\\n       \\n        int dp[1005]={0};\\n        int lis[1005];\\n        \\n        memset(lis,-1,sizeof(lis));\\n        \\n        \\n        for(i=1;i<n;i++){\\n            \\n            for(j=0;j<i;j++){\\n                \\n                if(a[i]%a[j]==0 and dp[j]+1>=dp[i]){\\n                    \\n                    dp[i] = dp[j]+1;\\n                    lis[i] = j;\\n                }\\n                \\n            }\\n            \\n            if(mx<dp[i]){\\n                mx=dp[i];\\n                ind=i; // index with longest subsequence till now\\n            }\\n        }\\n        \\n      /*   ---- Uncomment to understand the flow ---\\n        for(i=0;i<n;i++){\\n            cout<<a[i]<<\" \";\\n        }\\n        cout<<endl;\\n        \\n        for(i=0;i<n;i++){\\n            cout<<dp[i]<<\" \";\\n        }\\n        cout<<endl;\\n        \\n        for(i=0;i<n;i++){\\n            cout<<lis[i]<<\" \";\\n        }\\n        cout<<endl;\\n        */\\n        \\n        \\n        vector<int>ans;\\n       \\n        \\n      //  Print the longest subsequence \\n        \\n        int g=0;\\n        while(1){\\n            ans.push_back(a[ind]);\\n            ind=lis[ind];\\n       \\n            if(ind==-1)break;\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1153682,
                "title": "o-n-2-convert-to-a-graph-then-topological-sort",
                "content": "Code first\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n\\t\\t# O(NlogN) to sort, so that when we loop later, we always have nums[i] < nums[j]\\n        nums.sort()\\n        graph = defaultdict(set)\\n        deg = defaultdict(int)\\n\\t\\t# O(N^2) build the graph, and set in-degree count for every vertex.\\n        for i in range(len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] % nums[i] == 0:\\n                    graph[nums[i]].add(nums[j])\\n                    deg[nums[j]] += 1\\n                    \\n        \\n        qu = deque([])\\n        for n in nums:\\n            if deg.get(n, 0) == 0:\\n                qu.append(n)\\n        \\n        parent = defaultdict(int)\\n        max_d = float(\\'-inf\\')\\n        start = None\\n\\t\\t# Worst case: O(N^2) topolotical sort\\n        while qu:\\n            top = qu.popleft()\\n            start = top\\n            \\n            for peer in graph.get(top, set()):\\n                deg[peer] -= 1\\n                \\n                if deg[peer] == 0:\\n                    parent[peer] = top\\n                    qu.append(peer)\\n        \\n        ans = deque([])\\n\\t\\t# O(N) to trace back from last element in topological sequence back to its start\\n\\t\\t# Use a deque + appendleft, so we don\\'t need to reverse.\\n        while start:\\n            ans.appendleft(start)\\n            start = parent.get(start, None)\\n            \\n        return list(ans)\\n```\\n\\nYou can convert the problem into a **directed** graph. \\n\\nEvery number in the `nums` array is a `Vertex`. \\n\\nFor any 2 numbers `a1, a2 (a1 < a2) && a2 % a1 == 0`, we put a directed edge  `a1 -> a2`.\\n\\nThen the problem is equavilent to finding the longest path in a Directed Graph. You can either use DP or topolotical sort to do it.\\n\\nAfter the graph conversion, it is much like - https://leetcode.com/problems/course-schedule-ii/\\n\\nOh wait, different from `course schedule ii`, this problem needs to find out the longest path in a topolotical sequence. What you can do is to maintain a `child-to-parent` mapping during the topolotical sort. And you just need to get the **last element** in the topolotical sort search as the end point of the longest sequence. Then use the `child-to-parent` mapping to trace back. \\n\\nBut if you really want to use dp, you can\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        graph = defaultdict(set)   \\n        for i in range(len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] % nums[i] == 0:\\n                    graph[j].add(i)\\n        \\n        dp = (len(nums)) * [0]\\n        \\n        end = None\\n        maxd = float(\\'-inf\\')\\n        parent = defaultdict(int)\\n        for i in range(len(nums)):\\n            if i not in graph:\\n                dp[i] = 1\\n            else:\\n                for prev in graph[i]:\\n                    if 1 + dp[prev] > dp[i]:\\n                        dp[i] = 1 + dp[prev]\\n                        parent[i] = prev\\n\\n            if dp[i] > maxd:\\n                maxd = dp[i]\\n                end = i\\n\\n        qu = deque([])\\n        \\n        while end is not None:\\n            qu.appendleft(nums[end])\\n            end = parent.get(end, None)\\n\\n        return list(qu)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n\\t\\t# O(NlogN) to sort, so that when we loop later, we always have nums[i] < nums[j]\\n        nums.sort()\\n        graph = defaultdict(set)\\n        deg = defaultdict(int)\\n\\t\\t# O(N^2) build the graph, and set in-degree count for every vertex.\\n        for i in range(len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] % nums[i] == 0:\\n                    graph[nums[i]].add(nums[j])\\n                    deg[nums[j]] += 1\\n                    \\n        \\n        qu = deque([])\\n        for n in nums:\\n            if deg.get(n, 0) == 0:\\n                qu.append(n)\\n        \\n        parent = defaultdict(int)\\n        max_d = float(\\'-inf\\')\\n        start = None\\n\\t\\t# Worst case: O(N^2) topolotical sort\\n        while qu:\\n            top = qu.popleft()\\n            start = top\\n            \\n            for peer in graph.get(top, set()):\\n                deg[peer] -= 1\\n                \\n                if deg[peer] == 0:\\n                    parent[peer] = top\\n                    qu.append(peer)\\n        \\n        ans = deque([])\\n\\t\\t# O(N) to trace back from last element in topological sequence back to its start\\n\\t\\t# Use a deque + appendleft, so we don\\'t need to reverse.\\n        while start:\\n            ans.appendleft(start)\\n            start = parent.get(start, None)\\n            \\n        return list(ans)\\n```\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        graph = defaultdict(set)   \\n        for i in range(len(nums)-1):\\n            for j in range(i+1, len(nums)):\\n                if nums[j] % nums[i] == 0:\\n                    graph[j].add(i)\\n        \\n        dp = (len(nums)) * [0]\\n        \\n        end = None\\n        maxd = float(\\'-inf\\')\\n        parent = defaultdict(int)\\n        for i in range(len(nums)):\\n            if i not in graph:\\n                dp[i] = 1\\n            else:\\n                for prev in graph[i]:\\n                    if 1 + dp[prev] > dp[i]:\\n                        dp[i] = 1 + dp[prev]\\n                        parent[i] = prev\\n\\n            if dp[i] > maxd:\\n                maxd = dp[i]\\n                end = i\\n\\n        qu = deque([])\\n        \\n        while end is not None:\\n            qu.appendleft(nums[end])\\n            end = parent.get(end, None)\\n\\n        return list(qu)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893841,
                "title": "c-o-n-2-dp-solution",
                "content": "Runtime: 36 ms, faster than 97.50% of C++ online submissions for Largest Divisible Subset.\\nMemory Usage: 8.9 MB, less than 5.38% of C++ online submissions for Largest Divisible Subset.\\n\\n```\\nThe problem is a version of LIS. Here we have to find longest subset or subsequence where\\nevery pair (a,b) element has a%b==0 or b%a==0 property.\\n\\nIf a%b==0 then a>=b, also there is a transitive relation between the pairs which follow this property\\nsuch as if a%b==0 and b%c==0 then a>=b>=c must be true. Also if b%c==0 and a%b==0 then a%c==0 must be true.\\n\\nSo we can sort the array in ascending order and find the longest subsequence which follows\\na%b==0 property for b<=a using similar dp solution approach for LIS.\\n\\nExample: [720,270,180,90,18,9]\\n\\nSorted: [9,18,90,180,270,720]\\n\\ninitial dp: [1,1,1,1,1,1]\\n\\ni = 1 => dp : [1,2,1,1,1,1]\\ni = 2 => dp : [1,2,3,1,1,1]\\ni = 3 => dp : [1,2,3,4,1,1]\\ni = 4 => dp : [1,2,3,4,4,1]\\ni = 5 => dp : [1,2,3,4,4,5]\\n\\nresult : [9,18,90,180,720] or [9,18,90,270,720]\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> result;\\n        if(n==0) return result;\\n        if(n==1)return nums;\\n        \\n        // dp vector holds the longest divisible subset (LDS) length including ith index element\\n        vector<int>dp(n,1);\\n        \\n        // sort array in ascending order\\n        sort(nums.begin(),nums.end());\\n             \\n        // max LDS length  \\n        int maxl = 1;\\n        \\n        // loop through array from second element \\n        for(int i=1;i<n;i++)\\n        {             \\n            // compare ith index element with all previous jth element to find LDS including ith element \\n            for(int j=0;j<i;j++)\\n            {\\n                // If ith element is divisible by previous jth element and dp[j]>= dp[i] we update dp[i] \\n                if((nums[i]%nums[j]==0) && dp[j]>=dp[i])\\n                    dp[i] = dp[j]+1;                  \\n            }\\n\\n            // update maxl with dp[i]\\n            maxl = max(maxl,dp[i]);\\n        }\\n        \\n        // populate result vector from dp vector\\n        int k = n-1;\\n        while(maxl!=0)\\n        {\\n            if(dp[k]==maxl && (result.empty() || result.back()%nums[k]==0))\\n            {\\n                maxl--;\\n                result.push_back(nums[k]);\\n            }\\n            \\n            k--;\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nThe problem is a version of LIS. Here we have to find longest subset or subsequence where\\nevery pair (a,b) element has a%b==0 or b%a==0 property.\\n\\nIf a%b==0 then a>=b, also there is a transitive relation between the pairs which follow this property\\nsuch as if a%b==0 and b%c==0 then a>=b>=c must be true. Also if b%c==0 and a%b==0 then a%c==0 must be true.\\n\\nSo we can sort the array in ascending order and find the longest subsequence which follows\\na%b==0 property for b<=a using similar dp solution approach for LIS.\\n\\nExample: [720,270,180,90,18,9]\\n\\nSorted: [9,18,90,180,270,720]\\n\\ninitial dp: [1,1,1,1,1,1]\\n\\ni = 1 => dp : [1,2,1,1,1,1]\\ni = 2 => dp : [1,2,3,1,1,1]\\ni = 3 => dp : [1,2,3,4,1,1]\\ni = 4 => dp : [1,2,3,4,4,1]\\ni = 5 => dp : [1,2,3,4,4,5]\\n\\nresult : [9,18,90,180,720] or [9,18,90,270,720]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> result;\\n        if(n==0) return result;\\n        if(n==1)return nums;\\n        \\n        // dp vector holds the longest divisible subset (LDS) length including ith index element\\n        vector<int>dp(n,1);\\n        \\n        // sort array in ascending order\\n        sort(nums.begin(),nums.end());\\n             \\n        // max LDS length  \\n        int maxl = 1;\\n        \\n        // loop through array from second element \\n        for(int i=1;i<n;i++)\\n        {             \\n            // compare ith index element with all previous jth element to find LDS including ith element \\n            for(int j=0;j<i;j++)\\n            {\\n                // If ith element is divisible by previous jth element and dp[j]>= dp[i] we update dp[i] \\n                if((nums[i]%nums[j]==0) && dp[j]>=dp[i])\\n                    dp[i] = dp[j]+1;                  \\n            }\\n\\n            // update maxl with dp[i]\\n            maxl = max(maxl,dp[i]);\\n        }\\n        \\n        // populate result vector from dp vector\\n        int k = n-1;\\n        while(maxl!=0)\\n        {\\n            if(dp[k]==maxl && (result.empty() || result.back()%nums[k]==0))\\n            {\\n                maxl--;\\n                result.push_back(nums[k]);\\n            }\\n            \\n            k--;\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891903,
                "title": "dfs-dp-progression",
                "content": "First I will explain how to solve this problem with DFS (times out), and how I used that to progress to a DP solution (41%/15%).  To begin, notice that if we sort the input array, there is an interesting property we can uncover when looking for divisible sets.  Let\\'s look at an example.\\n```\\nnums = [1,2,4,8], nextElement = 16\\n```\\nIf we want to add see if `16` fits into this divisible set, the naive way would be to iterate through all elements and check if `16 & 1 == 0, 16 % 2 == 0, ...,16 % 8 == 0`.  However, notice that the largest element, `8`, is divisible by all smaller elements `[1,2,4]`.  Similar is true for `16`, which is divisible by `[1,2,4,8]`.  Therefore, we only need to ensure that the number we are trying to add to a set is divisible by the largest element in that set!\\n\\nTherefore, DFS would be:\\n```\\ndef dfs(nums, soFar):\\n\\tif not nums:\\n\\t\\treturn soFar\\n\\tlongest = soFar\\n\\tfor i in range(len(nums)):\\n\\t\\tif not soFar or soFar[-1] % nums[i] == 0:  \\n\\t\\t\\tsubset = dfs(nums[i + 1:], soFar + [nums[i]])\\n\\t\\t\\tif len(subset) > len(longest):\\n\\t\\t\\t\\tlongest = subset\\n\\treturn longest\\n\\t\\nnums.sort(reverse=True)\\nreturn dfs(nums, [])\\n```\\nThe DFS solution times out because it recalculates the same recursive calls over and over. Going to the example above, once we know that `8` has a divisible subset `[1,2,4]`, we want to save this result, so we don\\'t need to spend time calculating it again.  This leads to the DP solution:\\n```\\ndef dp(nums):\\n\\tA = [[nums[i]] for i in range(len(nums))]\\n\\tfor j in range(len(nums)):\\n\\t\\tfor i in range(j):\\n\\t\\t\\tif nums[j] % nums[i] == 0:           # If this can be included in the divisible set\\n\\t\\t\\t\\tif len(A[i]) + 1 > len(A[j]):    # Include it if this is the largest divisble set we have seen thus far for nums[j]\\n\\t\\t\\t\\t\\tA[j] = A[i] + [nums[j]]\\n\\tlongest = []\\n\\tfor i in range(len(A)):\\n\\t\\tif len(A[i]) > len(longest):\\n\\t\\t\\tlongest = A[i]\\n\\treturn longest\\n\\t\\nnums.sort()\\nreturn dp(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nnums = [1,2,4,8], nextElement = 16\\n```\n```\\ndef dfs(nums, soFar):\\n\\tif not nums:\\n\\t\\treturn soFar\\n\\tlongest = soFar\\n\\tfor i in range(len(nums)):\\n\\t\\tif not soFar or soFar[-1] % nums[i] == 0:  \\n\\t\\t\\tsubset = dfs(nums[i + 1:], soFar + [nums[i]])\\n\\t\\t\\tif len(subset) > len(longest):\\n\\t\\t\\t\\tlongest = subset\\n\\treturn longest\\n\\t\\nnums.sort(reverse=True)\\nreturn dfs(nums, [])\\n```\n```\\ndef dp(nums):\\n\\tA = [[nums[i]] for i in range(len(nums))]\\n\\tfor j in range(len(nums)):\\n\\t\\tfor i in range(j):\\n\\t\\t\\tif nums[j] % nums[i] == 0:           # If this can be included in the divisible set\\n\\t\\t\\t\\tif len(A[i]) + 1 > len(A[j]):    # Include it if this is the largest divisble set we have seen thus far for nums[j]\\n\\t\\t\\t\\t\\tA[j] = A[i] + [nums[j]]\\n\\tlongest = []\\n\\tfor i in range(len(A)):\\n\\t\\tif len(A[i]) > len(longest):\\n\\t\\t\\tlongest = A[i]\\n\\treturn longest\\n\\t\\nnums.sort()\\nreturn dp(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 868819,
                "title": "c-solution-with-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int,vector<int>> memo;\\n        \\n        int n=nums.size(), size=0, idx=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            auto result=dfs(nums,i,memo);\\n            if(result.size() > size)\\n            {\\n                idx=i;\\n                size=result.size();\\n            }\\n        }\\n        \\n        return memo[idx];\\n    }\\n    \\n    vector<int> dfs(vector<int>& nums, int i, unordered_map<int,vector<int>>& memo)\\n    {\\n        if(i==nums.size())\\n        {\\n            return vector<int>();\\n        }\\n        \\n        if(memo.find(i) != memo.end())\\n        {\\n            return memo[i];\\n        }\\n        \\n        int n=nums.size(), size=0, idx=-1;\\n        for(int j=i+1; j<n; j++)\\n        {\\n            if(nums[j] % nums[i] == 0)\\n            {\\n                auto result=dfs(nums,j,memo);\\n                if(result.size() > size)\\n                {\\n                    size=result.size();\\n                    idx=j;\\n                }\\n            }\\n        }\\n        \\n        vector<int> result={nums[i]};\\n        if(idx>-1)\\n        {\\n            for(auto& num:memo[idx]) \\n                result.push_back(num);\\n        }\\n        \\n        memo[i]=result;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int,vector<int>> memo;\\n        \\n        int n=nums.size(), size=0, idx=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            auto result=dfs(nums,i,memo);\\n            if(result.size() > size)\\n            {\\n                idx=i;\\n                size=result.size();\\n            }\\n        }\\n        \\n        return memo[idx];\\n    }\\n    \\n    vector<int> dfs(vector<int>& nums, int i, unordered_map<int,vector<int>>& memo)\\n    {\\n        if(i==nums.size())\\n        {\\n            return vector<int>();\\n        }\\n        \\n        if(memo.find(i) != memo.end())\\n        {\\n            return memo[i];\\n        }\\n        \\n        int n=nums.size(), size=0, idx=-1;\\n        for(int j=i+1; j<n; j++)\\n        {\\n            if(nums[j] % nums[i] == 0)\\n            {\\n                auto result=dfs(nums,j,memo);\\n                if(result.size() > size)\\n                {\\n                    size=result.size();\\n                    idx=j;\\n                }\\n            }\\n        }\\n        \\n        vector<int> result={nums[i]};\\n        if(idx>-1)\\n        {\\n            for(auto& num:memo[idx]) \\n                result.push_back(num);\\n        }\\n        \\n        memo[i]=result;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859012,
                "title": "simple-dp-solution-c-using-the-concept-of-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return {};\\n        vector<int> dp(n,1);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 1; i < n ; i++){\\n            dp[i] = 0;\\n            for(int j = 0 ; j < i; j++){\\n                if(nums[i] % nums[j] == 0){\\n                    dp[i]  = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        int mx = 0,in;\\n        for(int i = 0; i < n; i++){\\n            if(dp[i] >= mx){\\n                mx = dp[i];\\n                in = i;\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(nums[in]);\\n        int j = 0;\\n        for(int i = in-1; i>=0 ; i--){\\n            if(ans[j] % nums[i] == 0 and dp[i] == mx - ans.size()) {\\n                ans.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return {};\\n        vector<int> dp(n,1);\\n        sort(nums.begin(),nums.end());\\n        for(int i = 1; i < n ; i++){\\n            dp[i] = 0;\\n            for(int j = 0 ; j < i; j++){\\n                if(nums[i] % nums[j] == 0){\\n                    dp[i]  = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        int mx = 0,in;\\n        for(int i = 0; i < n; i++){\\n            if(dp[i] >= mx){\\n                mx = dp[i];\\n                in = i;\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(nums[in]);\\n        int j = 0;\\n        for(int i = in-1; i>=0 ; i--){\\n            if(ans[j] % nums[i] == 0 and dp[i] == mx - ans.size()) {\\n                ans.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788092,
                "title": "java-dp",
                "content": "```\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n\\n        List<Integer> res = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        int n  = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,1);\\n        \\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    dp[i] = Math.max(dp[i], dp[j]+1);\\n                    max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        \\n        \\n        int prev = -1;\\n        for (int i = n-1; i >=0; i--) {\\n            if (dp[i] == max && (prev == -1 || prev % nums[i] == 0)) {\\n                res.add(nums[i]);\\n                prev = nums[i];\\n                max--;\\n            }\\n        }    \\n        \\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n\\n        List<Integer> res = new ArrayList<>();\\n        Arrays.sort(nums);\\n        \\n        int n  = nums.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,1);\\n        \\n        int max = 1;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[i] % nums[j] == 0) {\\n                    dp[i] = Math.max(dp[i], dp[j]+1);\\n                    max = Math.max(dp[i],max);\\n                }\\n            }\\n        }\\n        \\n        \\n        int prev = -1;\\n        for (int i = n-1; i >=0; i--) {\\n            if (dp[i] == max && (prev == -1 || prev % nums[i] == 0)) {\\n                res.add(nums[i]);\\n                prev = nums[i];\\n                max--;\\n            }\\n        }    \\n        \\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 782557,
                "title": "python-one-array-dp-with-explaination-and-comment",
                "content": "It is a combination problem, usally sorting the array first can reduce the computation.\\nOne obersvation: if the array is a sorting number,  than for every legel subset, let\\'s say S1 = [1, 2, 4], when we meet a number (a1), if it can add into this subset it must satisfy:  a1%s1[-1]==0. So, we find a recursion relationship.\\n\\nwe can used an dp array to record the largest subset length and construct array to record the path to achieve largest subset:\\ndp[i] means the largest length of the subsets that end with nums[i] (every subset is in ascending order),\\nconstruct[i] indicates for the index of last number before nums[i], to achieve its largest subsets\\n\\ninitialize:\\ndp = [0] * len(nums)\\nconstruct = [-1] * len(nums)\\n\\ne.g. given array [1, 2, 4, 8, 10, 24]\\ndp = [1, 2, 3, 4, 3, 5] \\nconstruct = [-1, 0, 1, 2, 1, 3] \\n\\n```\\n\\n# myclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n            \\n        nums.sort()\\n        dp = [0]*len(nums)\\n        \\n        # used to construct the subset after we find the largest size\\n        construct = [-1]*len(nums)\\n        best, best_i = -1, -1\\n        \\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if nums[i]%nums[j]==0 and dp[i]<dp[j]:\\n                    construct[i], dp[i] = j, dp[j]\\n            dp[i] += 1\\n            if dp[i] > best:\\n                best, best_i = dp[i],i\\n        #print(dp, construct)\\n\\n        # construct the result    \\n        result = [nums[best_i]]\\n        while(construct[best_i] >-1 ):\\n            best_i = construct[best_i]\\n            result.append(nums[best_i])\\n            \\n        \\n        return result[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n# myclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n            \\n        nums.sort()\\n        dp = [0]*len(nums)\\n        \\n        # used to construct the subset after we find the largest size\\n        construct = [-1]*len(nums)\\n        best, best_i = -1, -1\\n        \\n        for i in range(len(nums)):\\n            for j in range(i):\\n                if nums[i]%nums[j]==0 and dp[i]<dp[j]:\\n                    construct[i], dp[i] = j, dp[j]\\n            dp[i] += 1\\n            if dp[i] > best:\\n                best, best_i = dp[i],i\\n        #print(dp, construct)\\n\\n        # construct the result    \\n        result = [nums[best_i]]\\n        while(construct[best_i] >-1 ):\\n            best_i = construct[best_i]\\n            result.append(nums[best_i])\\n            \\n        \\n        return result[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686171,
                "title": "java-backtrack-with-memorization",
                "content": "I know that backtrack might not be a good idea for this question. But this is just some alternatives to think about.\\n```\\nclass Solution {\\n    \\n    List<Integer> res = new ArrayList<>();\\n    int maxLen = 0;\\n    \\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        backtrack(nums, new ArrayList<>(), 0, new HashSet<>());\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, List<Integer> currList, int start, Set<Set<Integer>> visited) {\\n        if(start >= nums.length) return;\\n        if(currList.size() > 0 && currList.get(currList.size() - 1) > nums[nums.length - 1] / 2) return;\\n        for(Set<Integer> set : visited) {\\n            if(set.size() <= currList.size()) continue;\\n            if(set.containsAll(currList) && set.size() > currList.size()) return;\\n        }\\n        visited.add(new HashSet<>(currList));\\n        List<Integer> list = new ArrayList<>(currList);\\n        for(int i = start; i < nums.length; i++) {\\n            if(list.size() == 0 || nums[i] % list.get(list.size() - 1) == 0) {\\n                list.add(nums[i]);\\n                if(list.size() > maxLen) {\\n                    res = new ArrayList<>(list);\\n                    maxLen = list.size();\\n                }\\n                backtrack(nums, list, i + 1, visited);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<Integer> res = new ArrayList<>();\\n    int maxLen = 0;\\n    \\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        Arrays.sort(nums);\\n        backtrack(nums, new ArrayList<>(), 0, new HashSet<>());\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, List<Integer> currList, int start, Set<Set<Integer>> visited) {\\n        if(start >= nums.length) return;\\n        if(currList.size() > 0 && currList.get(currList.size() - 1) > nums[nums.length - 1] / 2) return;\\n        for(Set<Integer> set : visited) {\\n            if(set.size() <= currList.size()) continue;\\n            if(set.containsAll(currList) && set.size() > currList.size()) return;\\n        }\\n        visited.add(new HashSet<>(currList));\\n        List<Integer> list = new ArrayList<>(currList);\\n        for(int i = start; i < nums.length; i++) {\\n            if(list.size() == 0 || nums[i] % list.get(list.size() - 1) == 0) {\\n                list.add(nums[i]);\\n                if(list.size() > maxLen) {\\n                    res = new ArrayList<>(list);\\n                    maxLen = list.size();\\n                }\\n                backtrack(nums, list, i + 1, visited);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685279,
                "title": "c-similar-to-lis",
                "content": "```\\nclass Solution {\\n    vector<int> res;\\n    void trace(vector<int>& prev, vector<int>& nums, int idx) {\\n        if (prev[idx] != -1) trace(prev, nums, prev[idx]);\\n        res.push_back(nums[idx]);\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if (nums.empty()) return {};\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0, idx;\\n        vector<int> dp(n), prev(n);\\n        for (int i = 0; i < n; ++i) {\\n            dp[i] = 1;\\n            prev[i] = -1;\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] % nums[j] == 0 && dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    prev[i] = j;\\n                }\\n            }\\n            if (dp[i] > ans) {\\n                ans = dp[i];\\n                idx = i;\\n            }\\n        }\\n        trace(prev, nums, idx);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> res;\\n    void trace(vector<int>& prev, vector<int>& nums, int idx) {\\n        if (prev[idx] != -1) trace(prev, nums, prev[idx]);\\n        res.push_back(nums[idx]);\\n    }\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if (nums.empty()) return {};\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0, idx;\\n        vector<int> dp(n), prev(n);\\n        for (int i = 0; i < n; ++i) {\\n            dp[i] = 1;\\n            prev[i] = -1;\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] % nums[j] == 0 && dp[j] + 1 > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    prev[i] = j;\\n                }\\n            }\\n            if (dp[i] > ans) {\\n                ans = dp[i];\\n                idx = i;\\n            }\\n        }\\n        trace(prev, nums, idx);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684803,
                "title": "c-simple-dynamic-programming-solution-similar-to-lis",
                "content": "```csharp\\npublic IList<int> LargestDivisibleSubset(int[] nums)\\n{\\n\\tif (nums == null || nums.Length == 0)\\n\\t{\\n\\t\\treturn nums;\\n\\t}\\n\\n\\tArray.Sort(nums);\\n\\tint max = 0, index = -1;\\n\\tint[] d = new int[nums.Length];\\n\\tint[] pre = new int[nums.Length];\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\td[i] = 1;\\n\\t\\tpre[i] = -1;\\n\\n\\t\\tfor (int j = 0; j < i; j++)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] % nums[j] == 0 && d[i] < (1 + d[j]))\\n\\t\\t\\t{\\n\\t\\t\\t\\td[i] = 1 + d[j];\\n\\t\\t\\t\\tpre[i] = j;                                            \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (d[i] > max)\\n\\t\\t{\\n\\t\\t\\tmax = d[i];\\n\\t\\t\\tindex = i;\\n\\t\\t}\\n\\t}\\n\\n\\tList<int> result = new List<int>();\\n\\twhile (index >= 0)\\n\\t{\\n\\t\\tresult.Add(nums[index]);\\n\\t\\tindex = pre[index];\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic IList<int> LargestDivisibleSubset(int[] nums)\\n{\\n\\tif (nums == null || nums.Length == 0)\\n\\t{\\n\\t\\treturn nums;\\n\\t}\\n\\n\\tArray.Sort(nums);\\n\\tint max = 0, index = -1;\\n\\tint[] d = new int[nums.Length];\\n\\tint[] pre = new int[nums.Length];\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\td[i] = 1;\\n\\t\\tpre[i] = -1;\\n\\n\\t\\tfor (int j = 0; j < i; j++)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] % nums[j] == 0 && d[i] < (1 + d[j]))\\n\\t\\t\\t{\\n\\t\\t\\t\\td[i] = 1 + d[j];\\n\\t\\t\\t\\tpre[i] = j;                                            \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (d[i] > max)\\n\\t\\t{\\n\\t\\t\\tmax = d[i];\\n\\t\\t\\tindex = i;\\n\\t\\t}\\n\\t}\\n\\n\\tList<int> result = new List<int>();\\n\\twhile (index >= 0)\\n\\t{\\n\\t\\tresult.Add(nums[index]);\\n\\t\\tindex = pre[index];\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684693,
                "title": "java-15-ms-minor-variant-of-longest-increasing-subsequence-dp-problem",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> subset = new ArrayList<Integer>();\\n        if(nums != null && nums.length != 0)\\n        {\\n            Arrays.sort(nums);\\n            int N = nums.length, i, j;\\n            int[] DP = new int[N];\\n            int[] parent = new int[N];\\n            \\n            Arrays.fill(DP, 1);\\n            Arrays.fill(parent, -1);\\n            int max = 0, maxIndex = -1;\\n            \\n            for(i = 0; i < N; i++){\\n                for(j = 0; j < i; j++){\\n                    if(nums[i] % nums[j] == 0 && DP[i] < DP[j] + 1){\\n                        DP[i] = DP[j]  + 1;\\n                        parent[i] = j;\\n                    }\\n                }\\n                \\n                if(DP[i] > max){\\n                    maxIndex = i;\\n                    max = DP[i];\\n                }\\n            }\\n            \\n            while(maxIndex != -1){\\n                subset.add(nums[maxIndex]);\\n                maxIndex = parent[maxIndex];\\n            }\\n        }\\n        \\n        return subset;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        List<Integer> subset = new ArrayList<Integer>();\\n        if(nums != null && nums.length != 0)\\n        {\\n            Arrays.sort(nums);\\n            int N = nums.length, i, j;\\n            int[] DP = new int[N];\\n            int[] parent = new int[N];\\n            \\n            Arrays.fill(DP, 1);\\n            Arrays.fill(parent, -1);\\n            int max = 0, maxIndex = -1;\\n            \\n            for(i = 0; i < N; i++){\\n                for(j = 0; j < i; j++){\\n                    if(nums[i] % nums[j] == 0 && DP[i] < DP[j] + 1){\\n                        DP[i] = DP[j]  + 1;\\n                        parent[i] = j;\\n                    }\\n                }\\n                \\n                if(DP[i] > max){\\n                    maxIndex = i;\\n                    max = DP[i];\\n                }\\n            }\\n            \\n            while(maxIndex != -1){\\n                subset.add(nums[maxIndex]);\\n                maxIndex = parent[maxIndex];\\n            }\\n        }\\n        \\n        return subset;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542937,
                "title": "java-dp-solutiion",
                "content": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)  return new LinkedList<>();\\n        int[][] dp = new int[n][2];\\n        Arrays.sort(nums);\\n        for(int i = 0; i < dp.length; i++) {\\n            dp[i][0] = 1;\\n            dp[i][1] = -1;\\n        }\\n        \\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] % nums[j] == 0) {\\n                    if(dp[j][0] + 1 > dp[i][0]) {\\n                        dp[i][0] = dp[j][0] + 1;\\n                        dp[i][1] = j;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int max = 0;\\n        int idx = 0;\\n        for(int i = 0; i < dp.length; i++) {\\n            if(dp[i][0] > max) {\\n                max = dp[i][0];\\n                idx = i;\\n            }\\n        }\\n        LinkedList<Integer> res = new LinkedList<>();\\n        while(idx != -1) {\\n            res.addFirst(nums[idx]);\\n            idx = dp[idx][1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)  return new LinkedList<>();\\n        int[][] dp = new int[n][2];\\n        Arrays.sort(nums);\\n        for(int i = 0; i < dp.length; i++) {\\n            dp[i][0] = 1;\\n            dp[i][1] = -1;\\n        }\\n        \\n        for(int i = 1; i < dp.length; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] % nums[j] == 0) {\\n                    if(dp[j][0] + 1 > dp[i][0]) {\\n                        dp[i][0] = dp[j][0] + 1;\\n                        dp[i][1] = j;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int max = 0;\\n        int idx = 0;\\n        for(int i = 0; i < dp.length; i++) {\\n            if(dp[i][0] > max) {\\n                max = dp[i][0];\\n                idx = i;\\n            }\\n        }\\n        LinkedList<Integer> res = new LinkedList<>();\\n        while(idx != -1) {\\n            res.addFirst(nums[idx]);\\n            idx = dp[idx][1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534251,
                "title": "go-40ms-solution",
                "content": "```go\\nfunc largestDivisibleSubset(nums []int) []int {\\n\\tsort.Ints(nums)\\n\\tdp := make([]int, len(nums))\\n\\tfor i := range dp {\\n\\t\\tdp[i] = 1\\n\\t}\\n\\tmaxSubsetLength, maxSubsetLastIndex := 0, 0\\n\\tfor i := range nums {\\n\\t\\tif curLength := divisibleSubsetLength(nums, dp, i); curLength > maxSubsetLength {\\n\\t\\t\\tmaxSubsetLength, maxSubsetLastIndex = curLength, i\\n\\t\\t}\\n\\t}\\n\\tif maxSubsetLength == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\tsubset := make([]int, maxSubsetLength)\\n\\tindexOfSubset := maxSubsetLength - 1\\n\\tsubset[indexOfSubset] = nums[maxSubsetLastIndex]\\n\\tindexOfSubset--\\n\\tfor i := maxSubsetLastIndex - 1; i >= 0 && indexOfSubset >= 0; i-- {\\n\\t\\tif subset[indexOfSubset+1]%nums[i] == 0 && dp[i] == indexOfSubset+1 {\\n\\t\\t\\tsubset[indexOfSubset] = nums[i]\\n\\t\\t\\tindexOfSubset--\\n\\t\\t}\\n\\t}\\n\\treturn subset\\n}\\n\\nfunc divisibleSubsetLength(nums []int, dp []int, index int) int {\\n\\tfor i := 0; i < index; i++ {\\n\\t\\tif nums[index]%nums[i] == 0 {\\n\\t\\t\\tdp[index] = max(dp[index], dp[i]+1)\\n\\t\\t}\\n\\t}\\n\\treturn dp[index]\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt32\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc largestDivisibleSubset(nums []int) []int {\\n\\tsort.Ints(nums)\\n\\tdp := make([]int, len(nums))\\n\\tfor i := range dp {\\n\\t\\tdp[i] = 1\\n\\t}\\n\\tmaxSubsetLength, maxSubsetLastIndex := 0, 0\\n\\tfor i := range nums {\\n\\t\\tif curLength := divisibleSubsetLength(nums, dp, i); curLength > maxSubsetLength {\\n\\t\\t\\tmaxSubsetLength, maxSubsetLastIndex = curLength, i\\n\\t\\t}\\n\\t}\\n\\tif maxSubsetLength == 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\tsubset := make([]int, maxSubsetLength)\\n\\tindexOfSubset := maxSubsetLength - 1\\n\\tsubset[indexOfSubset] = nums[maxSubsetLastIndex]\\n\\tindexOfSubset--\\n\\tfor i := maxSubsetLastIndex - 1; i >= 0 && indexOfSubset >= 0; i-- {\\n\\t\\tif subset[indexOfSubset+1]%nums[i] == 0 && dp[i] == indexOfSubset+1 {\\n\\t\\t\\tsubset[indexOfSubset] = nums[i]\\n\\t\\t\\tindexOfSubset--\\n\\t\\t}\\n\\t}\\n\\treturn subset\\n}\\n\\nfunc divisibleSubsetLength(nums []int, dp []int, index int) int {\\n\\tfor i := 0; i < index; i++ {\\n\\t\\tif nums[index]%nums[i] == 0 {\\n\\t\\t\\tdp[index] = max(dp[index], dp[i]+1)\\n\\t\\t}\\n\\t}\\n\\treturn dp[index]\\n}\\n\\nfunc max(values ...int) int {\\n\\tmaxValue := math.MinInt32\\n\\tfor _, v := range values {\\n\\t\\tif v > maxValue {\\n\\t\\t\\tmaxValue = v\\n\\t\\t}\\n\\t}\\n\\treturn maxValue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 367855,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        nums.sort()\\n        n = len(nums)\\n\\t\\t# (previous divisible index, length of divisible subset)\\n        dp = [(-1, 1)] * n\\n\\t\\t# (last divisible index, maximum length of divisible subsets)\\n        maxl = (0, 1)\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0:\\n                    if dp[i][1] < dp[j][1] + 1:\\n                        dp[i] = (j, dp[j][1] + 1)\\n                        if maxl[1] < dp[i][1]:\\n                            maxl = (i, dp[i][1])\\n        ret = []\\n        x = maxl[0]\\n        while x > -1:\\n            ret.append(nums[x])\\n            x = dp[x][0]\\n        return ret[::-1]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return []\\n        nums.sort()\\n        n = len(nums)\\n\\t\\t# (previous divisible index, length of divisible subset)\\n        dp = [(-1, 1)] * n\\n\\t\\t# (last divisible index, maximum length of divisible subsets)\\n        maxl = (0, 1)\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0:\\n                    if dp[i][1] < dp[j][1] + 1:\\n                        dp[i] = (j, dp[j][1] + 1)\\n                        if maxl[1] < dp[i][1]:\\n                            maxl = (i, dp[i][1])\\n        ret = []\\n        x = maxl[0]\\n        while x > -1:\\n            ret.append(nums[x])\\n            x = dp[x][0]\\n        return ret[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 367594,
                "title": "c-easy-solution-using-dp-91-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return nums;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int flag=1;\\n        if(nums[0]==1){\\n            flag=0;\\n        }\\n        else{\\n            nums.push_back(1);\\n            flag=1;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int dp[nums.size()][2];\\n        for(i=nums.size()-1;i>=0;i--){\\n            dp[i][0]=0;\\n            dp[i][1]=i;\\n            for(j=i+1;j<nums.size();j++){\\n                if((nums[j]%nums[i])==0){\\n                    if(dp[j][0]>dp[i][0]){\\n                        dp[i][0]=dp[j][0];\\n                        dp[i][1]=j;\\n                    }  \\n                }\\n            }\\n            dp[i][0]++;\\n        }\\n        i=0;\\n        vector<int> t;\\n        t.push_back(nums[i]);\\n        while(dp[i][1]!=i){\\n            i=dp[i][1];\\n            t.push_back(nums[i]);\\n            \\n        }\\n        if(flag==1){\\n            t.erase(t.begin());\\n        }\\n        return t;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.size()==0){\\n            return nums;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int flag=1;\\n        if(nums[0]==1){\\n            flag=0;\\n        }\\n        else{\\n            nums.push_back(1);\\n            flag=1;\\n        }\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int dp[nums.size()][2];\\n        for(i=nums.size()-1;i>=0;i--){\\n            dp[i][0]=0;\\n            dp[i][1]=i;\\n            for(j=i+1;j<nums.size();j++){\\n                if((nums[j]%nums[i])==0){\\n                    if(dp[j][0]>dp[i][0]){\\n                        dp[i][0]=dp[j][0];\\n                        dp[i][1]=j;\\n                    }  \\n                }\\n            }\\n            dp[i][0]++;\\n        }\\n        i=0;\\n        vector<int> t;\\n        t.push_back(nums[i]);\\n        while(dp[i][1]!=i){\\n            i=dp[i][1];\\n            t.push_back(nums[i]);\\n            \\n        }\\n        if(flag==1){\\n            t.erase(t.begin());\\n        }\\n        return t;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279945,
                "title": "0-n-2-solution-in-js-they-tell-me-it-s-fast",
                "content": "Speed was 97% - 100% range, memory at 50%. Instead of saving multiple arrays, instead this method is using an object to store each number with the count of how many other numbers it cleanly divides (the length of the subset), including itself. I\\'d love to hear any advice on how to drive the memory use down!\\n\\nLike a lot of solutions here, the most important step is to sort the array into descending order. Logically, the largest number will only have a remainder of 0 when it is divided by a smaller number of the set. Also, any number that can divide the current number will also be able to divde previous numbers; if 12 can divide 24, 48, and 144 evenly, then so can 6, 4, 3, and 2. 12 only needs to \"remember\" that it can divide 4 numbers.\\n\\nIn this method, whenever we come across a value, we compare only to the preceding numbers. If a valid numerator is found and it has the greatest subset for this value, the length of the total set and the numertor are saved. Furthermore, if it has the greatest subset for all numbers thus far, we stop checking, and move onto the next value in the array. Otherwise, we proceed through the rest of the proceeding numbers, then save the best possible path and length achieved.\\n\\nOnce the optimal path is achieved, we construct the result array by following the values in the pointers object. Any questions or improvements are welcome!\\n\\n```\\nvar largestDivisibleSubset = function(nums) {\\n  if (nums.length < 2) {\\n    return nums;\\n  }\\n  \\n  nums.sort((a,b) => b - a);\\n  let pointer = [nums[0]], pointers = {},\\n      length = 0, lengths = {};\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    let index = i;\\n    let n = nums[i];\\n    let maxKey;\\n    let maxLength = 1;\\n    while (index) {\\n      index--;\\n      let m = nums[index];\\n      if (m % n === 0) {\\n        if (lengths[m] >= maxLength) {\\n          maxKey = m;\\n          maxLength = lengths[m] + 1;\\n          if (maxLength > length) {\\n            index = 0;\\n            pointer = n;\\n            length = maxLength;\\n          }\\n        }\\n      }\\n    }\\n    pointers[n] = maxKey;\\n    lengths[n] = maxLength;\\n  }\\n  let result = [];\\n  while (pointer) {\\n    result.push(pointer);\\n    pointer = pointers[pointer];\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestDivisibleSubset = function(nums) {\\n  if (nums.length < 2) {\\n    return nums;\\n  }\\n  \\n  nums.sort((a,b) => b - a);\\n  let pointer = [nums[0]], pointers = {},\\n      length = 0, lengths = {};\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    let index = i;\\n    let n = nums[i];\\n    let maxKey;\\n    let maxLength = 1;\\n    while (index) {\\n      index--;\\n      let m = nums[index];\\n      if (m % n === 0) {\\n        if (lengths[m] >= maxLength) {\\n          maxKey = m;\\n          maxLength = lengths[m] + 1;\\n          if (maxLength > length) {\\n            index = 0;\\n            pointer = n;\\n            length = maxLength;\\n          }\\n        }\\n      }\\n    }\\n    pointers[n] = maxKey;\\n    lengths[n] = maxLength;\\n  }\\n  let result = [];\\n  while (pointer) {\\n    result.push(pointer);\\n    pointer = pointers[pointer];\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 84053,
                "title": "44-ms-c-solution-beats-97-5-of-submissions-explanations-included-very-thorough",
                "content": "```\\nclass Solution {\\npublic:\\n/* ALGORITHM\\nSome facts:\\nIf we choose in [1,2,6,4,8], [1,2,6], then we are NOT getting the optimal answer.\\nStep 1: Sort the array.\\nStep 2: Create an array of ints, each containing the # of elements(1) at the i-th idx of the array.\\nCreate another array of ints, each pointing to a previous value in the array. It initializes as all -1's.\\nAlso, create the global max, global set.\\nStep 3: Iterate:\\n\\nfor i = 0; i < nums.size(); i++\\n    for j = 0; j < i; j++\\n        if nums[i] % nums[j] == 0\\n            cur_max = max(cur_max, nums[j].size()+1)\\n    Change nums[j]'s pointer to cur_max's idx\\n    if cur_set.size() > global_max\\n        global_max = cur_set.size()\\n        global_set = cur_set\\nreturn global_set\\n*/\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return vector<int>();\\n        }\\n        // Step 1: Sort the array\\n        std::sort(nums.begin(), nums.end());\\n        // Step 2: Create an array of ints, each containing the # of elements(1) at the i-th idx of the array.\\n        // Create another array of ints, each pointing to a previous value in the array. It initializes as all -1's.\\n        // Also, create the global max, global set.\\n        int n = nums.size();\\n        int num_elements[nums.size()];\\n        int prev_pointers[nums.size()];\\n        for(int i = 0; i < n; i++){\\n            num_elements[i] = 1;\\n            prev_pointers[i] = -1;\\n        }\\n        int global_max = -1, global_idx = 0;\\n        vector<int> global_set;\\n        // Step 3: Iterate. Include some local maes\\n        for(int i = 0; i < n; i++){\\n            int nums_i = nums[i];\\n            int cur_max = -1, cur_idx = -1;\\n            for(int j = 0; j < i; j++){\\n                int nums_j = nums[j];\\n                if(nums_i % nums_j == 0){\\n                    if(cur_max < num_elements[j] + 1){\\n                        cur_max = num_elements[j] + 1;\\n                        cur_idx = j;\\n                    }\\n                }\\n            }\\n            prev_pointers[i] = cur_idx;\\n            num_elements[i] = cur_max;\\n            if(cur_max > global_max){\\n                global_max = cur_max;\\n                global_idx = i;\\n            }\\n        }\\n        // Step 4: We have the answer. Backtrack and find all the numbers we need.\\n        vector<int> answer;\\n        for(; global_idx != -1; global_idx = prev_pointers[global_idx]){\\n            answer.push_back(nums[global_idx]);\\n        }\\n        std::reverse(answer.begin(), answer.end());\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n/* ALGORITHM\\nSome facts:\\nIf we choose in [1,2,6,4,8], [1,2,6], then we are NOT getting the optimal answer.\\nStep 1: Sort the array.\\nStep 2: Create an array of ints, each containing the # of elements(1) at the i-th idx of the array.\\nCreate another array of ints, each pointing to a previous value in the array. It initializes as all -1's.\\nAlso, create the global max, global set.\\nStep 3: Iterate:\\n\\nfor i = 0; i < nums.size(); i++\\n    for j = 0; j < i; j++\\n        if nums[i] % nums[j] == 0\\n            cur_max = max(cur_max, nums[j].size()+1)\\n    Change nums[j]'s pointer to cur_max's idx\\n    if cur_set.size() > global_max\\n        global_max = cur_set.size()\\n        global_set = cur_set\\nreturn global_set\\n*/\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return vector<int>();\\n        }\\n        // Step 1: Sort the array\\n        std::sort(nums.begin(), nums.end());\\n        // Step 2: Create an array of ints, each containing the # of elements(1) at the i-th idx of the array.\\n        // Create another array of ints, each pointing to a previous value in the array. It initializes as all -1's.\\n        // Also, create the global max, global set.\\n        int n = nums.size();\\n        int num_elements[nums.size()];\\n        int prev_pointers[nums.size()];\\n        for(int i = 0; i < n; i++){\\n            num_elements[i] = 1;\\n            prev_pointers[i] = -1;\\n        }\\n        int global_max = -1, global_idx = 0;\\n        vector<int> global_set;\\n        // Step 3: Iterate. Include some local maes\\n        for(int i = 0; i < n; i++){\\n            int nums_i = nums[i];\\n            int cur_max = -1, cur_idx = -1;\\n            for(int j = 0; j < i; j++){\\n                int nums_j = nums[j];\\n                if(nums_i % nums_j == 0){\\n                    if(cur_max < num_elements[j] + 1){\\n                        cur_max = num_elements[j] + 1;\\n                        cur_idx = j;\\n                    }\\n                }\\n            }\\n            prev_pointers[i] = cur_idx;\\n            num_elements[i] = cur_max;\\n            if(cur_max > global_max){\\n                global_max = cur_max;\\n                global_idx = i;\\n            }\\n        }\\n        // Step 4: We have the answer. Backtrack and find all the numbers we need.\\n        vector<int> answer;\\n        for(; global_idx != -1; global_idx = prev_pointers[global_idx]){\\n            answer.push_back(nums[global_idx]);\\n        }\\n        std::reverse(answer.begin(), answer.end());\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84058,
                "title": "292-ms-python-solution",
                "content": "The idea is to put the (sorted) numbers into buckets one by one and make sure each number is divisible by one number in previous buckets. So the index of the bucket is the max size of a set.\\n```\\nNum      1, 2, 3, 4, 6, 8, 9, 12, 24, 36\\n\\nbucket   1  2  3  4  5 \\n-----------------------\\n         1  2  4  8 24\\n            3  6 12 36\\n               9\\n```\\nAfter doing this, all I need to do is find a path between the first bucket and the last. We can do this using DFS but I choose to put a tuple *(d, p)* into buckets instead of a number where f is the divider and p is the number. \\n```\\nclass Solution(object):\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums = sorted(nums)\\n        buckets = [None, []]\\n        if len(nums) < 2:\\n            return nums\\n        max_len = 0\\n        for n in nums:\\n            atemp = max_len + 1\\n            placed = False\\n            while atemp > 0 and not placed:\\n                if atemp == 1:\\n                    buckets[1].append((None, n))\\n                    max_len = max(max_len, atemp)\\n                    placed = True\\n                else:\\n                    for _, p in buckets[atemp-1]:\\n                        if n % p == 0:\\n                            while len(buckets) - 1 < atemp:\\n                                buckets.append([])\\n                            buckets[atemp].append((p, n))\\n                            max_len = max(max_len, atemp)\\n                            placed = True\\n                            break\\n                atemp -= 1\\n        ans = [buckets[-1][0][1]]\\n        target = buckets[-1][0][0]\\n        for i in xrange(max_len-1, 0, -1):\\n            for d, p in buckets[i]:\\n                if p == target:\\n                    ans.insert(0, p)\\n                    target = d\\n                    break\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nNum      1, 2, 3, 4, 6, 8, 9, 12, 24, 36\\n\\nbucket   1  2  3  4  5 \\n-----------------------\\n         1  2  4  8 24\\n            3  6 12 36\\n               9\\n```\n```\\nclass Solution(object):\\n    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        nums = sorted(nums)\\n        buckets = [None, []]\\n        if len(nums) < 2:\\n            return nums\\n        max_len = 0\\n        for n in nums:\\n            atemp = max_len + 1\\n            placed = False\\n            while atemp > 0 and not placed:\\n                if atemp == 1:\\n                    buckets[1].append((None, n))\\n                    max_len = max(max_len, atemp)\\n                    placed = True\\n                else:\\n                    for _, p in buckets[atemp-1]:\\n                        if n % p == 0:\\n                            while len(buckets) - 1 < atemp:\\n                                buckets.append([])\\n                            buckets[atemp].append((p, n))\\n                            max_len = max(max_len, atemp)\\n                            placed = True\\n                            break\\n                atemp -= 1\\n        ans = [buckets[-1][0][1]]\\n        target = buckets[-1][0][0]\\n        for i in xrange(max_len-1, 0, -1):\\n            for d, p in buckets[i]:\\n                if p == target:\\n                    ans.insert(0, p)\\n                    target = d\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 84059,
                "title": "python-dp-solution-similar-to-lis-problem",
                "content": "    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # divisibility is transitive, a multiple x of some divisor d is also a multiple of all elements in s[d]\\n        \\n        nums.sort()\\n        \\n        dp = [1] * len(nums)\\n        prev_index = [-1] * len(nums)\\n        max_len = 0\\n        max_index = -1\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if nums[i]%nums[j] == 0 and dp[j]+1 > dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    prev_index[i] = j\\n            \\n            if dp[i] > max_len:\\n                max_len = dp[i]\\n                max_index = i\\n        \\n        res = []\\n        while max_index != -1:\\n            res.append(nums[max_index])\\n            max_index = prev_index[max_index]\\n        return res",
                "solutionTags": [],
                "code": "    def largestDivisibleSubset(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        # divisibility is transitive, a multiple x of some divisor d is also a multiple of all elements in s[d]\\n        \\n        nums.sort()\\n        \\n        dp = [1] * len(nums)\\n        prev_index = [-1] * len(nums)\\n        max_len = 0\\n        max_index = -1\\n        \\n        for i in range(len(nums)):\\n            for j in range(i-1, -1, -1):\\n                if nums[i]%nums[j] == 0 and dp[j]+1 > dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    prev_index[i] = j\\n            \\n            if dp[i] > max_len:\\n                max_len = dp[i]\\n                max_index = i\\n        \\n        res = []\\n        while max_index != -1:\\n            res.append(nums[max_index])\\n            max_index = prev_index[max_index]\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3983534,
                "title": "easily-find-largest-divisible-subset-using-dynamic-programming-approach",
                "content": "\\n### Intuition:\\nThe problem involves finding the largest divisible subset from a given array of integers. The subset should satisfy the property that every element is divisible by the previous element. \\n\\n### Approach:\\n1. Sort the input array `nums` in ascending order. Sorting helps us in simplifying the problem.\\n2. Initialize two arrays: `dp` to keep track of the size of the largest divisible subset ending at each index, and `hash` to keep track of the previous index that contributed to the current index\\'s largest divisible subset length.\\n3. Iterate through the array to fill the `dp` and `hash` arrays.\\n4. Find the index of the last element with the maximum value in the `dp` array. This index will help reconstruct the largest divisible subset.\\n5. Reconstruct the largest divisible subset using the `hash` array by backtracking from the index found in the previous step.\\n6. Reverse the subset to get it in the correct order.\\n\\n### Complexity:\\n- Time complexity: O(n^2), where n is the number of elements in the array.\\n- Space complexity: O(n) for the `dp` and `hash` arrays.\\n\\nHere\\'s the code with detailed explanations for each section:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        // Step 1: Sort the input array in ascending order\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        vector<int> dp(n, 1); // Step 2: Initialize the dp array\\n        vector<int> hash(n, 1); // Step 2: Initialize the hash array\\n\\n        // Step 3: Fill the dp and hash arrays\\n        for (int i = 0; i < n; i++) {\\n            hash[i] = i; // Initialize with current index\\n            for (int prev = 0; prev < i; prev++) {\\n                if (nums[i] % nums[prev] == 0 && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    hash[i] = prev;\\n                }\\n            }\\n        }\\n\\n        int ans = -1;\\n        int last_index = -1;\\n\\n        // Step 4: Find the index with the maximum subset size\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > ans) {\\n                ans = dp[i];\\n                last_index = i;\\n            }\\n        }\\n\\n        vector<int> temp; // Step 5: Initialize the vector to store the subset\\n        temp.push_back(nums[last_index]); // Add the last element to the subset\\n\\n        // Step 5: Reconstruct the subset by backtracking through hash\\n        while (hash[last_index] != last_index) {\\n            last_index = hash[last_index];\\n            temp.push_back(nums[last_index]);\\n        }\\n\\n        reverse(temp.begin(), temp.end()); // Step 6: Reverse the subset to correct order\\n        return temp;\\n    }\\n};\\n```\\n\\nThis code finds the largest divisible subset using dynamic programming and backtracking. It ensures that each element in the subset is divisible by the previous element and constructs the subset according to the explanations provided earlier.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        // Step 1: Sort the input array in ascending order\\n        sort(nums.begin(), nums.end());\\n\\n        int n = nums.size();\\n        vector<int> dp(n, 1); // Step 2: Initialize the dp array\\n        vector<int> hash(n, 1); // Step 2: Initialize the hash array\\n\\n        // Step 3: Fill the dp and hash arrays\\n        for (int i = 0; i < n; i++) {\\n            hash[i] = i; // Initialize with current index\\n            for (int prev = 0; prev < i; prev++) {\\n                if (nums[i] % nums[prev] == 0 && 1 + dp[prev] > dp[i]) {\\n                    dp[i] = 1 + dp[prev];\\n                    hash[i] = prev;\\n                }\\n            }\\n        }\\n\\n        int ans = -1;\\n        int last_index = -1;\\n\\n        // Step 4: Find the index with the maximum subset size\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > ans) {\\n                ans = dp[i];\\n                last_index = i;\\n            }\\n        }\\n\\n        vector<int> temp; // Step 5: Initialize the vector to store the subset\\n        temp.push_back(nums[last_index]); // Add the last element to the subset\\n\\n        // Step 5: Reconstruct the subset by backtracking through hash\\n        while (hash[last_index] != last_index) {\\n            last_index = hash[last_index];\\n            temp.push_back(nums[last_index]);\\n        }\\n\\n        reverse(temp.begin(), temp.end()); // Step 6: Reverse the subset to correct order\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938304,
                "title": "python-94-02-faster-lis-approach",
                "content": "**Since the list is sorted so if a element is divisible by previous element it means it also divisible by all the elements before that previous element because the list is sorted and it become similar to Longest Increasing Subsequence: https://leetcode.com/problems/longest-increasing-subsequence/**\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort() \\n        n=len(nums)\\n        dp=[1]*n\\n        dic=[i for i in range(n)]\\n        maxi=last_index=0\\n        for i in range(1,n):\\n            for prev in range(i):\\n                if nums[i]%nums[prev]==0 and dp[prev]+1>dp[i]:\\n                    dp[i]=dp[prev]+1\\n                    dic[i]=prev\\n            if maxi<dp[i]:\\n                maxi=dp[i]\\n                last_index=i\\n        ans=[nums[last_index]]\\n        while dic[last_index]!=last_index:\\n            last_index=dic[last_index]\\n            ans.append(nums[last_index])\\n        return ans[-1::-1]\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort() \\n        n=len(nums)\\n        dp=[1]*n\\n        dic=[i for i in range(n)]\\n        maxi=last_index=0\\n        for i in range(1,n):\\n            for prev in range(i):\\n                if nums[i]%nums[prev]==0 and dp[prev]+1>dp[i]:\\n                    dp[i]=dp[prev]+1\\n                    dic[i]=prev\\n            if maxi<dp[i]:\\n                maxi=dp[i]\\n                last_index=i\\n        ans=[nums[last_index]]\\n        while dic[last_index]!=last_index:\\n            last_index=dic[last_index]\\n            ans.append(nums[last_index])\\n        return ans[-1::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791684,
                "title": "python-sorting-dp-hashing-with-explanation",
                "content": "Intuition: Add an element to an array only if it is divisible by the last element of the array\\nSince the order of longest subset does not matter we can simply sort the array, thereby eleminating the need for checking if all the elements divide each other.\\nOnce the elements are sorted, the problem is similar to that of Longest Increasing Subsequence.\\n```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n = len(nums)\\n        dp = [1]*n\\n        hsh = [i for i in range(n)]\\n        max_i, max_v = 0, 1\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                if nums[i]%nums[j] == 0 and dp[j]+1>dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    hsh[i] = j\\n                    max_i = i if max_v<dp[i] else max_i\\n                    max_v = max(max_v, dp[i])\\n        \\n        seq = []\\n        while True:\\n            seq.append(nums[max_i])\\n            if max_i == hsh[max_i]:\\n                break\\n            max_i = hsh[max_i]\\n        return seq[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n = len(nums)\\n        dp = [1]*n\\n        hsh = [i for i in range(n)]\\n        max_i, max_v = 0, 1\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                if nums[i]%nums[j] == 0 and dp[j]+1>dp[i]:\\n                    dp[i] = dp[j] + 1\\n                    hsh[i] = j\\n                    max_i = i if max_v<dp[i] else max_i\\n                    max_v = max(max_v, dp[i])\\n        \\n        seq = []\\n        while True:\\n            seq.append(nums[max_i])\\n            if max_i == hsh[max_i]:\\n                break\\n            max_i = hsh[max_i]\\n        return seq[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284567,
                "title": "c-simplest-solution-dynamic-programming-backtrack",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1), hash(n, 0);\\n        int ans = INT_MIN;\\n        int lastIndex = 0;\\n        vector<int> res;\\n        sort(begin(nums), end(nums));\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (nums[ind] % nums[prev] == 0 && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                    hash[ind] = prev;\\n                }\\n            }\\n            if (dp[ind] > ans) {\\n                ans = dp[ind];\\n                lastIndex = ind;\\n            }\\n        }\\n        res.emplace_back(nums[lastIndex]);\\n        for (int i=0; i<ans-1; i++) {\\n            res.emplace_back(nums[hash[lastIndex]]);\\n            lastIndex = hash[lastIndex];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n, 1), hash(n, 0);\\n        int ans = INT_MIN;\\n        int lastIndex = 0;\\n        vector<int> res;\\n        sort(begin(nums), end(nums));\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (nums[ind] % nums[prev] == 0 && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                    hash[ind] = prev;\\n                }\\n            }\\n            if (dp[ind] > ans) {\\n                ans = dp[ind];\\n                lastIndex = ind;\\n            }\\n        }\\n        res.emplace_back(nums[lastIndex]);\\n        for (int i=0; i<ans-1; i++) {\\n            res.emplace_back(nums[hash[lastIndex]]);\\n            lastIndex = hash[lastIndex];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204794,
                "title": "dp-c-solution",
                "content": "Similar to LIS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        vector<int> prev(n);\\n        vector<int> dp(n,1);\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<n;i++){\\n            prev[i]=i;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0 && 1+dp[j]>dp[i]){\\n                    dp[i]=1+dp[j];\\n                    prev[i]=j;\\n                }\\n            }\\n        }\\n        int len=*max_element(dp.begin(),dp.end());\\n        int idx=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]>dp[idx]){\\n                idx=i;\\n            }\\n        }\\n        ans.push_back(nums[idx]);\\n        idx=prev[idx];\\n        while(len!=1){\\n            \\n            ans.push_back(nums[idx]);\\n            idx=prev[idx];\\n            len--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        vector<int> prev(n);\\n        vector<int> dp(n,1);\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=1;i<n;i++){\\n            prev[i]=i;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0 && 1+dp[j]>dp[i]){\\n                    dp[i]=1+dp[j];\\n                    prev[i]=j;\\n                }\\n            }\\n        }\\n        int len=*max_element(dp.begin(),dp.end());\\n        int idx=0;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]>dp[idx]){\\n                idx=i;\\n            }\\n        }\\n        ans.push_back(nums[idx]);\\n        idx=prev[idx];\\n        while(len!=1){\\n            \\n            ans.push_back(nums[idx]);\\n            idx=prev[idx];\\n            len--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200494,
                "title": "java-striver-dp-45-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the intution is quite easy and clear it is just like LIS.\\nWe just need to do the LIS but since here the subset is required so we can sort the array and remove the condition to check instead of it we check if it is divisible or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo LIS with the condition `if(arr[i]%arr[pre] == 0 && dp[i]<1+dp[pre])`\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] arr) \\n    {\\n        int n = arr.length;\\n\\t\\tint dp[] = new int[n];\\n        Arrays.fill(dp, 1);\\n\\t\\tint track[] = new int[n];\\n\\t\\tArrays.fill(track, -1);\\n\\t\\t//track[0] = 0;\\n        Arrays.sort(arr);\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n           for(int pre = 0;pre<i;pre++)\\n\\t\\t   {\\n\\t\\t\\t   if(arr[i]%arr[pre] == 0 && dp[i]<1+dp[pre])\\n\\t\\t\\t   {\\n\\t\\t\\t\\t   dp[i] = 1+dp[pre];\\n\\t\\t\\t\\t   track[i] = pre;\\n\\t\\t\\t   }\\n\\t\\t   }\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tint pos = -1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n           if(max<dp[i])\\n\\t\\t   {\\n\\t\\t\\t   max = dp[i];\\n\\t\\t\\t   pos = i;\\n\\t\\t   }\\n\\t\\t}\\n\\t\\tArrayList<Integer> ans = new ArrayList<>();\\n\\t\\tans.add(arr[pos]);\\n\\t\\twhile(true)\\n\\t\\t{\\n\\t\\t\\tpos=track[pos];\\n\\t\\t\\tif(pos==-1)\\n\\t\\t\\tbreak;\\n            ans.add(arr[pos]);\\n\\t\\t}\\n\\t\\tCollections.reverse(ans);\\n\\t\\t/*for(int x : ans)\\n\\t\\tSystem.out.print(x+\" \");*/\\n\\t\\t//System.out.println();\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] arr) \\n    {\\n        int n = arr.length;\\n\\t\\tint dp[] = new int[n];\\n        Arrays.fill(dp, 1);\\n\\t\\tint track[] = new int[n];\\n\\t\\tArrays.fill(track, -1);\\n\\t\\t//track[0] = 0;\\n        Arrays.sort(arr);\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n           for(int pre = 0;pre<i;pre++)\\n\\t\\t   {\\n\\t\\t\\t   if(arr[i]%arr[pre] == 0 && dp[i]<1+dp[pre])\\n\\t\\t\\t   {\\n\\t\\t\\t\\t   dp[i] = 1+dp[pre];\\n\\t\\t\\t\\t   track[i] = pre;\\n\\t\\t\\t   }\\n\\t\\t   }\\n\\t\\t}\\n\\t\\tint max = 0;\\n\\t\\tint pos = -1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n           if(max<dp[i])\\n\\t\\t   {\\n\\t\\t\\t   max = dp[i];\\n\\t\\t\\t   pos = i;\\n\\t\\t   }\\n\\t\\t}\\n\\t\\tArrayList<Integer> ans = new ArrayList<>();\\n\\t\\tans.add(arr[pos]);\\n\\t\\twhile(true)\\n\\t\\t{\\n\\t\\t\\tpos=track[pos];\\n\\t\\t\\tif(pos==-1)\\n\\t\\t\\tbreak;\\n            ans.add(arr[pos]);\\n\\t\\t}\\n\\t\\tCollections.reverse(ans);\\n\\t\\t/*for(int x : ans)\\n\\t\\tSystem.out.print(x+\" \");*/\\n\\t\\t//System.out.println();\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186646,
                "title": "top-to-bottom-dp",
                "content": "# Intuition\\nFirst observation.\\nIt looks like a pick/skip problem\\n```\\nexample: 18,54,90,180\\n          ^ ^          <- if we pick 18,54 we can not pick 90 and 180\\n          ^    ^   ^   <- but we better pick 18 and skip 54, cause later we can pick 90 AND 180\\n``` \\nWe create a DFS function that will return the longest array starting from i then iterate over the nums and spin up DFS from every i as a starter point and keep tracking of the longest result returned by DFS\\n\\nHow we can tell that all numbers picked during DFS are divisible to each other in constant time?\\n```\\nexample:         [9,18,54,108,540,90]\\nDFS(next, prev): 9->18->54->108->540->90\\n```\\nthe problem is that 90 is not divisible by 54\\nbut if we sort an array 9,18,54,90,108,540\\nand if curr%prev===0 would mean all subset is valid\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n\\nvar largestDivisibleSubset = function(nums) {\\n    const dfs=(i,prev,dp)=>{\\n        const key=prev+\\'_\\'+i;\\n        if(dp.has(key)) return dp.get(key);\\n\\n        if(i===nums.length) return [];\\n        let pick=[];\\n        if(nums[i]%nums[prev]===0 || nums[prev]%nums[i]===0){\\n            pick = [...dfs(i+1,i,dp)];\\n            pick.push(nums[i]);\\n        }\\n        const skip = [...dfs(i+1,prev,dp)];\\n        return dp.set(key, pick.length>skip.length?pick:skip).get(key);\\n    };\\n\\n    let maxResult = [], dp=new Map();\\n    nums=nums.sort((a,b)=>a-b);\\n\\n    for(let start=0; start<nums.length;start++){\\n        const ans = dfs(start,start,dp);\\n        if(ans.length>maxResult.length)\\n            maxResult=ans;\\n    }\\n    return maxResult;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nexample: 18,54,90,180\\n          ^ ^          <- if we pick 18,54 we can not pick 90 and 180\\n          ^    ^   ^   <- but we better pick 18 and skip 54, cause later we can pick 90 AND 180\\n```\n```\\nexample:         [9,18,54,108,540,90]\\nDFS(next, prev): 9->18->54->108->540->90\\n```\n```\\n\\nvar largestDivisibleSubset = function(nums) {\\n    const dfs=(i,prev,dp)=>{\\n        const key=prev+\\'_\\'+i;\\n        if(dp.has(key)) return dp.get(key);\\n\\n        if(i===nums.length) return [];\\n        let pick=[];\\n        if(nums[i]%nums[prev]===0 || nums[prev]%nums[i]===0){\\n            pick = [...dfs(i+1,i,dp)];\\n            pick.push(nums[i]);\\n        }\\n        const skip = [...dfs(i+1,prev,dp)];\\n        return dp.set(key, pick.length>skip.length?pick:skip).get(key);\\n    };\\n\\n    let maxResult = [], dp=new Map();\\n    nums=nums.sort((a,b)=>a-b);\\n\\n    for(let start=0; start<nums.length;start++){\\n        const ans = dfs(start,start,dp);\\n        if(ans.length>maxResult.length)\\n            maxResult=ans;\\n    }\\n    return maxResult;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3180816,
                "title": "c-easy-solution-dp-programing-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSame as Longest Increasing subsequence\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n,1),hash(n);\\n        int li=0;\\n        int maxi=1;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            hash[i]=i;\\n            for(int prev=0;prev<i;prev++){\\n                if(arr[i]%arr[prev]==0 && 1+dp[prev]>dp[i]){\\n                    dp[i]=1+dp[prev];\\n                    hash[i]=prev;\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n                li=i;\\n            }\\n        }\\n        vector<int>res(maxi);\\n        int i=1;\\n        res[0]=arr[li];\\n        while(hash[li]!=li){\\n            li=hash[li];\\n            res[i]=arr[li];\\n            i++;\\n        }\\n        // return hash;\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp(n,1),hash(n);\\n        int li=0;\\n        int maxi=1;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<n;i++){\\n            hash[i]=i;\\n            for(int prev=0;prev<i;prev++){\\n                if(arr[i]%arr[prev]==0 && 1+dp[prev]>dp[i]){\\n                    dp[i]=1+dp[prev];\\n                    hash[i]=prev;\\n                }\\n            }\\n            if(dp[i]>maxi){\\n                maxi=dp[i];\\n                li=i;\\n            }\\n        }\\n        vector<int>res(maxi);\\n        int i=1;\\n        res[0]=arr[li];\\n        while(hash[li]!=li){\\n            li=hash[li];\\n            res[i]=arr[li];\\n            i++;\\n        }\\n        // return hash;\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989020,
                "title": "easy-java-solution-lds",
                "content": "\\n\\n# Code\\n```\\n/* \\n * Sort nums\\n * Find size of longest divisible subset through the same approach as in LIS\\n * Construct LDS by iterating through dp from right to left\\n */\\n\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        return constructLDS(dp , nums , getLDSSize(nums , dp));\\n    }\\n\\n    private int getLDSSize(int[] nums , int[] dp) {\\n      Arrays.sort(nums);  \\n      Arrays.fill(dp,1);\\n\\n      int ldsSize = 1 ;\\n      for(int i = 1; i < nums.length; i++){\\n        for(int j = 0; j < i; j++){\\n           if(nums[i] % nums[j] == 0){\\n               dp[i] = Math.max(dp[i] , dp[j] + 1);\\n               ldsSize = Math.max(ldsSize , dp[i]);\\n           }\\n        }\\n      }\\n      return ldsSize;\\n    } \\n\\n    private List<Integer> constructLDS(int[] dp , int[] nums , int ldsSize){\\n        int prev = -1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for(int i = dp.length - 1; i >= 0; i--){\\n            if(dp[i] == ldsSize && (prev == -1 || prev % nums[i] == 0)){\\n              list.addFirst(nums[i]);\\n              ldsSize--;\\n              prev = nums[i];\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* \\n * Sort nums\\n * Find size of longest divisible subset through the same approach as in LIS\\n * Construct LDS by iterating through dp from right to left\\n */\\n\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        return constructLDS(dp , nums , getLDSSize(nums , dp));\\n    }\\n\\n    private int getLDSSize(int[] nums , int[] dp) {\\n      Arrays.sort(nums);  \\n      Arrays.fill(dp,1);\\n\\n      int ldsSize = 1 ;\\n      for(int i = 1; i < nums.length; i++){\\n        for(int j = 0; j < i; j++){\\n           if(nums[i] % nums[j] == 0){\\n               dp[i] = Math.max(dp[i] , dp[j] + 1);\\n               ldsSize = Math.max(ldsSize , dp[i]);\\n           }\\n        }\\n      }\\n      return ldsSize;\\n    } \\n\\n    private List<Integer> constructLDS(int[] dp , int[] nums , int ldsSize){\\n        int prev = -1;\\n        LinkedList<Integer> list = new LinkedList<>();\\n        for(int i = dp.length - 1; i >= 0; i--){\\n            if(dp[i] == ldsSize && (prev == -1 || prev % nums[i] == 0)){\\n              list.addFirst(nums[i]);\\n              ldsSize--;\\n              prev = nums[i];\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798438,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\t\\t\\n        sort(arr.begin(), arr.end());\\n        \\n        vector<int> lis(n, 1); \\n\\t\\tvector<int>prev_idx(n, -1); \\n        int max{}, index{};\\n \\n        for(int i{}; i<n; ++i){\\n            \\n            for(int j{i-1}; j>=0; --j){\\n                \\n                if(lis[j]+1 > lis[i] && arr[i]%arr[j] == 0){\\n                    \\n                    lis[i] = lis[j] + 1;\\n                    prev_idx[i] = j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\tfor(int i{}; i<n; ++i){\\n            \\n            if(max < lis[i]){\\n                max = lis[i];\\n                index = i;\\n            }\\n        }\\n        \\n        vector<int>divisible_subset{};\\n        \\n        while(index != -1){\\n            \\n            divisible_subset.push_back(arr[index]);\\n            index = prev_idx[index];\\n        }\\n        \\n        return divisible_subset;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n\\t\\t\\n        sort(arr.begin(), arr.end());\\n        \\n        vector<int> lis(n, 1); \\n\\t\\tvector<int>prev_idx(n, -1); \\n        int max{}, index{};\\n \\n        for(int i{}; i<n; ++i){\\n            \\n            for(int j{i-1}; j>=0; --j){\\n                \\n                if(lis[j]+1 > lis[i] && arr[i]%arr[j] == 0){\\n                    \\n                    lis[i] = lis[j] + 1;\\n                    prev_idx[i] = j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\tfor(int i{}; i<n; ++i){\\n            \\n            if(max < lis[i]){\\n                max = lis[i];\\n                index = i;\\n            }\\n        }\\n        \\n        vector<int>divisible_subset{};\\n        \\n        while(index != -1){\\n            \\n            divisible_subset.push_back(arr[index]);\\n            index = prev_idx[index];\\n        }\\n        \\n        return divisible_subset;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662783,
                "title": "c-similar-to-lis-problem-dp-store-index-in-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> index(n , -1) , dp(n+1 , 1);\\n        \\n        sort(nums.begin() , nums.end());\\n        \\n        int max_len=1;\\n        \\n        int idx=0;\\n          \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]%nums[j]==0)\\n                {\\n                    if(dp[i]<1+dp[j])\\n                    {\\n                        dp[i]=1+dp[j];\\n                        index[i]=j;\\n                        \\n                        if(max_len<dp[i])\\n                        {\\n                            idx=i;\\n                            max_len=dp[i];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> res;\\n        \\n        int j=idx;\\n        \\n        while(j>=0)\\n        {\\n            res.push_back(nums[j]);\\n            j=index[j];\\n        }\\n        \\n        reverse(res.begin() , res.end());\\n        \\n        return res;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> index(n , -1) , dp(n+1 , 1);\\n        \\n        sort(nums.begin() , nums.end());\\n        \\n        int max_len=1;\\n        \\n        int idx=0;\\n          \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]%nums[j]==0)\\n                {\\n                    if(dp[i]<1+dp[j])\\n                    {\\n                        dp[i]=1+dp[j];\\n                        index[i]=j;\\n                        \\n                        if(max_len<dp[i])\\n                        {\\n                            idx=i;\\n                            max_len=dp[i];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> res;\\n        \\n        int j=idx;\\n        \\n        while(j>=0)\\n        {\\n            res.push_back(nums[j]);\\n            j=index[j];\\n        }\\n        \\n        reverse(res.begin() , res.end());\\n        \\n        return res;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617155,
                "title": "lds",
                "content": "```\\nrecursion memoisation in python\\n```class Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n=len(nums)\\n        tmp=[]\\n        ans=[]\\n        dp=[-1]*n\\n        def lds(i,prev,tmp,ans):\\n            if i>=n:\\n                if len(tmp)>len(ans):\\n                    ans.append(tmp[:])\\n                return \\n            if len(tmp)>dp[i] and nums[i]%prev==0:\\n                dp[i]=len(tmp)\\n                tmp.append(nums[i])\\n                lds(i+1,nums[i],tmp,ans)\\n                tmp.pop()\\n            lds(i+1,prev,tmp,ans)\\n        lds(0,1,tmp,ans)\\n        p=[]\\n        res=0\\n        for i in ans:\\n            if len(i)>res:\\n                res=len(i)\\n                p=i\\n        return p\\n\\n                \\n                \\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nrecursion memoisation in python\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575810,
                "title": "java-solution-lis",
                "content": "\\nHi Family,\\n\\nI put the proper comment for your help!!!\\nPlease upvote this,if you liked\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] arr) {\\n        Arrays.sort(arr);\\n        int n = arr.length;\\n        int dp[] = new int[n];\\n        //put all the index of dp with 1\\n        Arrays.fill(dp,1);\\n        int hash[] = new int[n];\\n        \\n        int max = 0;\\n        int last_index = 0;\\n        \\n        for (int cur=1;cur<n;cur++){\\n            /*\\n                if n=5\\n                hash[] = [0,1,2,3,4,5]\\n                \\n            */\\n            \\n            hash[cur] = cur;\\n            for (int prev=0;prev<cur;prev++){\\n                \\n                // if cur element is divible by prev then we add the dp value\\n                if (arr[cur] % arr[prev] == 0 && (1+dp[prev] > dp[cur])){\\n                    dp[cur] = dp[prev] + 1;\\n                    hash[cur] = prev;\\n                }\\n                \\n            }\\n            // track the index who has maximum value on the dp array\\n            // this for printing the list\\n            if (dp[cur] > max){\\n                max = dp[cur];\\n                last_index = cur;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        \\n        List<Integer> list = new ArrayList<>();\\n        // add the element in list\\n        list.add(arr[last_index]);\\n        \\n        while (hash[last_index] != last_index){\\n            last_index = hash[last_index];\\n            list.add(arr[last_index]);\\n        }\\n        \\n        Collections.reverse(list);\\n        return list;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] arr) {\\n        Arrays.sort(arr);\\n        int n = arr.length;\\n        int dp[] = new int[n];\\n        //put all the index of dp with 1\\n        Arrays.fill(dp,1);\\n        int hash[] = new int[n];\\n        \\n        int max = 0;\\n        int last_index = 0;\\n        \\n        for (int cur=1;cur<n;cur++){\\n            /*\\n                if n=5\\n                hash[] = [0,1,2,3,4,5]\\n                \\n            */\\n            \\n            hash[cur] = cur;\\n            for (int prev=0;prev<cur;prev++){\\n                \\n                // if cur element is divible by prev then we add the dp value\\n                if (arr[cur] % arr[prev] == 0 && (1+dp[prev] > dp[cur])){\\n                    dp[cur] = dp[prev] + 1;\\n                    hash[cur] = prev;\\n                }\\n                \\n            }\\n            // track the index who has maximum value on the dp array\\n            // this for printing the list\\n            if (dp[cur] > max){\\n                max = dp[cur];\\n                last_index = cur;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        \\n        List<Integer> list = new ArrayList<>();\\n        // add the element in list\\n        list.add(arr[last_index]);\\n        \\n        while (hash[last_index] != last_index){\\n            last_index = hash[last_index];\\n            list.add(arr[last_index]);\\n        }\\n        \\n        Collections.reverse(list);\\n        return list;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505563,
                "title": "c-iteratiive-logic-explained",
                "content": "![image](https://assets.leetcode.com/users/images/328771ac-0d5f-4c8f-a3ac-a41f93778d4b_1661872741.848528.png)\\n\\n**T->O(n^2) && S->O(n)**\\n\\n***The approach of this question is same as LIS in that question we use to compare the greater element and in this question we will check the divisibility. If the element is divisible with the previous element of the subsequence then we will pick that element else will leave it.\\nIn this question sorting the array nums is Important as we are checking the divisibility so it the array is sorted then we can run a divisibility check between nums[i] and nums[prev] only. This is suffecient as the array is increasing then we can conclude that is nums[i]%nums[prev]==0 then all the other element of the formed subsequence will be divisible with it/by it too. ***\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> largestDivisibleSubset(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tvector<int>dp(n,1),hash(n);\\n\\t\\t\\tint maxi=1;\\n\\t\\t\\tint lastind=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\thash[i]=i;\\n\\t\\t\\t\\tfor(int prev=0;prev<i;prev++){\\n\\t\\t\\t\\t\\tif(nums[i]%nums[prev]==0 && 1+dp[prev]>dp[i]){\\n\\t\\t\\t\\t\\t\\tdp[i]=1+dp[prev];\\n\\t\\t\\t\\t\\t\\thash[i]=prev;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}          \\n\\t\\t\\t\\tif(dp[i]>maxi){\\n\\t\\t\\t\\t\\tmaxi=dp[i];\\n\\t\\t\\t\\t\\tlastind=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<int>temp;\\n\\t\\t\\ttemp.push_back(nums[lastind]);\\n\\t\\t\\twhile(hash[lastind]!=lastind){\\n\\t\\t\\t\\tlastind=hash[lastind];\\n\\t\\t\\t\\ttemp.push_back(nums[lastind]);\\n\\t\\t\\t}\\n\\t\\t\\treturn temp;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> largestDivisibleSubset(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tvector<int>dp(n,1),hash(n);\\n\\t\\t\\tint maxi=1;\\n\\t\\t\\tint lastind=0;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\thash[i]=i;\\n\\t\\t\\t\\tfor(int prev=0;prev<i;prev++){\\n\\t\\t\\t\\t\\tif(nums[i]%nums[prev]==0 && 1+dp[prev]>dp[i]){\\n\\t\\t\\t\\t\\t\\tdp[i]=1+dp[prev];\\n\\t\\t\\t\\t\\t\\thash[i]=prev;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2478859,
                "title": "c-easy-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n = arr.size();\\n    \\n        //sort the array\\n\\n        sort(arr.begin(), arr.end());\\n\\n        vector<int> dp(n,1);\\n        vector<int> hash(n,1);\\n\\n        for(int i=0; i<=n-1; i++){\\n\\n            hash[i] = i; // initializing with current index\\n            for(int prev_index = 0; prev_index <=i-1; prev_index ++){\\n\\n                if(arr[i]%arr[prev_index] == 0 && 1 + dp[prev_index] > dp[i]){\\n                    dp[i] = 1 + dp[prev_index];\\n                    hash[i] = prev_index;\\n                }\\n            }\\n        }\\n\\n        int ans = -1;\\n        int lastIndex =-1;\\n\\n        for(int i=0; i<=n-1; i++){\\n            if(dp[i]> ans){\\n                ans = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n\\n        vector<int> temp;\\n        temp.push_back(arr[lastIndex]);\\n\\n        while(hash[lastIndex] != lastIndex){ // till not reach the initialization value\\n            lastIndex = hash[lastIndex];\\n            temp.push_back(arr[lastIndex]);    \\n        }\\n\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& arr) {\\n        int n = arr.size();\\n    \\n        //sort the array\\n\\n        sort(arr.begin(), arr.end());\\n\\n        vector<int> dp(n,1);\\n        vector<int> hash(n,1);\\n\\n        for(int i=0; i<=n-1; i++){\\n\\n            hash[i] = i; // initializing with current index\\n            for(int prev_index = 0; prev_index <=i-1; prev_index ++){\\n\\n                if(arr[i]%arr[prev_index] == 0 && 1 + dp[prev_index] > dp[i]){\\n                    dp[i] = 1 + dp[prev_index];\\n                    hash[i] = prev_index;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2477214,
                "title": "clean-o-n-2-solution-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int n = v.size();\\n        vector<int> dp(n, 1);\\n        int ans = 1;\\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(v[i] % v[j] == 0) dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n            ans = max(ans, dp[i]);\\n        }\\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i] == ans) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        vector<int> res;\\n        int x = index;\\n        int a = ans;\\n        res.push_back(v[index]);\\n        for(int i = index - 1; i >= 0; i--) {\\n            if(dp[i] == a - 1 && v[x] % v[i] == 0) {\\n                res.push_back(v[i]);\\n                a--;\\n                x = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n***Kindly Share and Upvote!!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& v) {\\n        sort(v.begin(), v.end());\\n        int n = v.size();\\n        vector<int> dp(n, 1);\\n        int ans = 1;\\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(v[i] % v[j] == 0) dp[i] = max(dp[i], 1 + dp[j]);\\n            }\\n            ans = max(ans, dp[i]);\\n        }\\n        int index = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i] == ans) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        vector<int> res;\\n        int x = index;\\n        int a = ans;\\n        res.push_back(v[index]);\\n        for(int i = index - 1; i >= 0; i--) {\\n            if(dp[i] == a - 1 && v[x] % v[i] == 0) {\\n                res.push_back(v[i]);\\n                a--;\\n                x = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462819,
                "title": "c-iterative-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        \\n        vector<pair<int,int>> dp(n,{-1,-1});\\n        \\n        dp[n-1].first=1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i].first=1;\\n            int nextidx=-1;\\n            int mx=-1;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(dp[j].first>mx && nums[j]%nums[i]==0)\\n                {\\n                    mx=dp[j].first;\\n                    nextidx=j;\\n                }\\n            }\\n            if(nextidx!=-1)\\n            {\\n                dp[i].first+=mx;\\n                dp[i].second=nextidx;\\n            }\\n        }\\n        \\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     cout<<dp[i].first<<\" \";\\n        // }\\n        // cout<<endl;\\n        \\n        int idx=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i].first>dp[idx].first)\\n            {\\n                idx=i;\\n            }\\n        }\\n        \\n        vector<int> res;\\n        \\n        while(idx!=-1)\\n        {\\n            res.push_back(nums[idx]);\\n            idx=dp[idx].second;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        \\n        vector<pair<int,int>> dp(n,{-1,-1});\\n        \\n        dp[n-1].first=1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i].first=1;\\n            int nextidx=-1;\\n            int mx=-1;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(dp[j].first>mx && nums[j]%nums[i]==0)\\n                {\\n                    mx=dp[j].first;\\n                    nextidx=j;\\n                }\\n            }\\n            if(nextidx!=-1)\\n            {\\n                dp[i].first+=mx;\\n                dp[i].second=nextidx;\\n            }\\n        }\\n        \\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     cout<<dp[i].first<<\" \";\\n        // }\\n        // cout<<endl;\\n        \\n        int idx=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp[i].first>dp[idx].first)\\n            {\\n                idx=i;\\n            }\\n        }\\n        \\n        vector<int> res;\\n        \\n        while(idx!=-1)\\n        {\\n            res.push_back(nums[idx]);\\n            idx=dp[idx].second;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2443707,
                "title": "c-easy-to-understand-beginner-friendly-easy-logic",
                "content": "\\t// Do Dry Run of The Code in Case you don\\'t understand\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> largestDivisibleSubset(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int>dp(n,1);\\n\\t\\t\\tvector<int>hash(n); // to track back the path after you got the maximum length of subset\\n\\t\\t\\tfor(int i=0;i<n;i++)hash[i] = i;\\n\\t\\t\\tsort(nums.begin(),nums.end()); // as the order doesn\\'t matter it seems logical to sort the array first\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint maxi = -1;\\n\\t\\t\\t\\tfor(int j=0;j<i;j++) // if you are at index i, then check at that index before that how many elements are there that divide the element at index i //\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[i]%nums[j]==0) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(dp[j]>maxi) \\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tmaxi = max(maxi,dp[j]);\\n\\t\\t\\t\\t\\t\\t\\thash[i] = j;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(maxi!=-1)dp[i]+= maxi; // if an element at index j divides the element at index i, then that means nums[j] must be a factor of nums[i] and that means that every element that was dividing nums[j] will also divide nums[i]//\\n\\t\\t\\t}\\n\\t\\t\\tvector<int>x;\\n\\t\\t\\tint maxi = -1;\\n\\t\\t\\tint idx = -1;\\n\\t\\t\\tfor(int i=n-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dp[i]>maxi)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmaxi = dp[i];\\n\\t\\t\\t\\t\\tidx = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(idx!=hash[idx]) // track back the path and store it in a vector //\\n\\t\\t\\t{\\n\\t\\t\\t\\tx.push_back(nums[idx]);\\n\\t\\t\\t\\tidx = hash[idx];\\n\\t\\t\\t}\\n\\t\\t\\tx.push_back(nums[idx]);\\n\\t\\t\\treverse(x.begin(),x.end());\\n\\t\\t\\treturn x; \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> largestDivisibleSubset(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int>dp(n,1);\\n\\t\\t\\tvector<int>hash(n); // to track back the path after you got the maximum length of subset\\n\\t\\t\\tfor(int i=0;i<n;i++)hash[i] = i;\\n\\t\\t\\tsort(nums.begin(),nums.end()); // as the order doesn\\'t matter it seems logical to sort the array first\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint maxi = -1;\\n\\t\\t\\t\\tfor(int j=0;j<i;j++) // if you are at index i, then check at that index before that how many elements are there that divide the element at index i //\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(nums[i]%nums[j]==0) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(dp[j]>maxi) \\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tmaxi = max(maxi,dp[j]);\\n\\t\\t\\t\\t\\t\\t\\thash[i] = j;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2436333,
                "title": "python-dp-solution-memoization",
                "content": "```\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        nums = sorted(nums)\\n        def r(index, previousIndex):\\n            if index == len(nums):\\n                return []\\n            take = []\\n            if previousIndex == -1 or nums[index] % nums[previousIndex] == 0 or nums[previousIndex] % nums[index] == 0:\\n                if (index+1, index) not in d:\\n                    take = [nums[index]] + r(index+1, index)\\n                else:\\n                    take = [nums[index]] + d[(index+1, index)]\\n            if (index+1, previousIndex) not in d:\\n                notTake = r(index+1, previousIndex)\\n            else:\\n                notTake = dp[(index+1, previousIndex)]\\n            if len(take) >= len(notTake):\\n                d[(index, previousIndex)] = take\\n                return d[(index, previousIndex)]\\n            else:\\n                d[(index, previousIndex)] = notTake\\n                return d[(index, previousIndex)]\\n        return(r(0,-1))\\n            \\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 2384332,
                "title": "c-solution-memoization-dp-backtrack-using-dp-table",
                "content": "class Solution {\\npublic:\\n    \\n    int solve(vector<int>& nums,int prevIdx,int idx,vector<vector<int>>& dp){\\n        if(idx>=nums.size()){\\n            return dp[prevIdx+1][idx] = 0;\\n        }\\n        if(dp[prevIdx+1][idx]!=-1) return dp[prevIdx+1][idx];\\n        if(prevIdx==-1 || nums[idx]%nums[prevIdx]==0){\\n            return dp[prevIdx+1][idx] = max(1+solve(nums,idx,idx+1,dp),solve(nums,prevIdx,idx+1,dp));\\n        }\\n        return dp[prevIdx+1][idx] = solve(nums,prevIdx,idx+1,dp);\\n    }\\n    \\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        sort(nums.begin(),nums.end());\\n        solve(nums,-1,0,dp);\\n        vector<int> ans;\\n        int i = 0;    //prevIdx+1--->i\\n        int j = 0;    //idx--->j\\n        while(i<n && j<n){\\n            if(i-1==-1 || nums[j]%nums[i-1]==0){\\n                if(1+dp[j+1][j+1]>dp[i][j+1]){\\n                    ans.push_back(nums[j]);\\n                    i = j+1;\\n                    j = j+1;\\n                }\\n                else{\\n                    j = j+1;\\n                }\\n            }\\n            else{\\n                j = j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(vector<int>& nums,int prevIdx,int idx,vector<vector<int>>& dp){\\n        if(idx>=nums.size()){\\n            return dp[prevIdx+1][idx] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2337653,
                "title": "c-easy-dp-tabulation-lis-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size ();\\n        sort (nums.begin (), nums.end ());\\n        vector<int> dp (n, 1);\\n        vector<int> cnt (n, -1);\\n        int index, maxi = 0;\\n        \\n        for (int i = 0; i < n; i ++) {\\n            for (int j = 0; j < i; j ++) {\\n                if ((nums[i] % nums[j] == 0) && 1 + dp[j] > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    cnt[i] = j;\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n                index = i;\\n            }\\n        }\\n        vector<int> ans;\\n        while (cnt[index] != -1) {\\n            ans.push_back (nums[index]);\\n            index = cnt[index];\\n        }\\n        ans.push_back(nums[index]);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if you found my post helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size ();\\n        sort (nums.begin (), nums.end ());\\n        vector<int> dp (n, 1);\\n        vector<int> cnt (n, -1);\\n        int index, maxi = 0;\\n        \\n        for (int i = 0; i < n; i ++) {\\n            for (int j = 0; j < i; j ++) {\\n                if ((nums[i] % nums[j] == 0) && 1 + dp[j] > dp[i]) {\\n                    dp[i] = dp[j] + 1;\\n                    cnt[i] = j;\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n                index = i;\\n            }\\n        }\\n        vector<int> ans;\\n        while (cnt[index] != -1) {\\n            ans.push_back (nums[index]);\\n            index = cnt[index];\\n        }\\n        ans.push_back(nums[index]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256086,
                "title": "c-dp-tabulation-method",
                "content": "Just see this problem as **Longest Divisible Subsequence**. \\nSimple & Clean code.\\n```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1);\\n        vector<int> prev(n,-1);\\n        int maxIdx = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i]%nums[j]==0 && dp[i] < 1+dp[j])\\n                {\\n                    dp[i] = 1+dp[j];\\n                    prev[i] = j;\\n                }\\n            }\\n            if(dp[i] > dp[maxIdx])\\n                maxIdx = i;\\n        }\\n        \\n        vector<int> res;\\n        while(maxIdx != -1)\\n        {\\n            res.push_back(nums[maxIdx]);\\n            maxIdx = prev[maxIdx];\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1);\\n        vector<int> prev(n,-1);\\n        int maxIdx = 0;\\n        \\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i]%nums[j]==0 && dp[i] < 1+dp[j])\\n                {\\n                    dp[i] = 1+dp[j];\\n                    prev[i] = j;\\n                }\\n            }\\n            if(dp[i] > dp[maxIdx])\\n                maxIdx = i;\\n        }\\n        \\n        vector<int> res;\\n        while(maxIdx != -1)\\n        {\\n            res.push_back(nums[maxIdx]);\\n            maxIdx = prev[maxIdx];\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245702,
                "title": "c-lis-pattern-problem-printing-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,1);\\n        vector<int> hash(n,0);\\n        vector<int> res;\\n        \\n        sort(nums.begin(), nums.end());\\n        int mx=1;\\n        int mx_idx=0;\\n        for(int i=1;i<n;i++){\\n            hash[i]=i;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0 && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                    hash[i]=j;\\n                }\\n            }\\n            \\n            if(mx<dp[i]){\\n                mx=dp[i];\\n                mx_idx=i;\\n            }\\n        }\\n\\n        while(hash[mx_idx]!=mx_idx){\\n            res.push_back(nums[mx_idx]);\\n            mx_idx=hash[mx_idx];\\n        }\\n        \\n        res.push_back(nums[mx_idx]);\\n    \\n        return res;\\n    }\\n};\\n```\\n\\n**TIME - O(N^2)\\nSPACE - O(N)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp(n,1);\\n        vector<int> hash(n,0);\\n        vector<int> res;\\n        \\n        sort(nums.begin(), nums.end());\\n        int mx=1;\\n        int mx_idx=0;\\n        for(int i=1;i<n;i++){\\n            hash[i]=i;\\n            for(int j=0;j<i;j++){\\n                if(nums[i]%nums[j]==0 && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                    hash[i]=j;\\n                }\\n            }\\n            \\n            if(mx<dp[i]){\\n                mx=dp[i];\\n                mx_idx=i;\\n            }\\n        }\\n\\n        while(hash[mx_idx]!=mx_idx){\\n            res.push_back(nums[mx_idx]);\\n            mx_idx=hash[mx_idx];\\n        }\\n        \\n        res.push_back(nums[mx_idx]);\\n    \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204260,
                "title": "dp-solution",
                "content": "**Tabulation:**\\n\\n\\tTime Complexity: O(N x N) + O(N)\\n\\tSpace Complexity: O(N)\\n\\t\\n```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        \\n        int[] dp = new int[n];\\n        int[] hash = new int[n];\\n        \\n        Arrays.fill(dp, 1);\\n        int max = 1;\\n        int lastIndex = 0;\\n        \\n        for (int ind = 0; ind < n; ind++) {\\n            hash[ind] = ind;\\n            \\n            for (int prev = 0; prev < ind; prev++) {\\n                if (nums[ind] % nums[prev] == 0 && 1 + dp[prev] > dp[ind]) {\\n                    \\n                    dp[ind] = 1 + dp[prev];\\n                    hash[ind] = prev;\\n                }\\n            }\\n            if (dp[ind] > max) {\\n                max = dp[ind];\\n                lastIndex = ind;\\n            }\\n        }\\n        \\n        List<Integer> lis = new ArrayList<>(max);\\n        lis.add(0, nums[lastIndex]);\\n        \\n        while (hash[lastIndex] != lastIndex) {\\n            lastIndex = hash[lastIndex];\\n            lis.add(0, nums[lastIndex]);\\n        }\\n      \\n        return lis;\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        \\n        int[] dp = new int[n];\\n        int[] hash = new int[n];\\n        \\n        Arrays.fill(dp, 1);\\n        int max = 1;\\n        int lastIndex = 0;\\n        \\n        for (int ind = 0; ind < n; ind++) {\\n            hash[ind] = ind;\\n            \\n            for (int prev = 0; prev < ind; prev++) {\\n                if (nums[ind] % nums[prev] == 0 && 1 + dp[prev] > dp[ind]) {\\n                    \\n                    dp[ind] = 1 + dp[prev];\\n                    hash[ind] = prev;\\n                }\\n            }\\n            if (dp[ind] > max) {\\n                max = dp[ind];\\n                lastIndex = ind;\\n            }\\n        }\\n        \\n        List<Integer> lis = new ArrayList<>(max);\\n        lis.add(0, nums[lastIndex]);\\n        \\n        while (hash[lastIndex] != lastIndex) {\\n            lastIndex = hash[lastIndex];\\n            lis.add(0, nums[lastIndex]);\\n        }\\n      \\n        return lis;\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174953,
                "title": "c-dp-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int>v(n, 1);\\n        vector<int>ch(n, -1);\\n        v[0] = 1;\\n        int numi = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] % nums[j] == 0 && v[i] < v[j] + 1) {\\n                    v[i] = v[j] + 1;\\n                    ch[i] = j;\\n                }\\n            }\\n            if(v[i] > v[numi]) { numi = i; }\\n        }\\n        vector<int> ans;\\n        while(numi != -1) {\\n            ans.push_back(nums[numi]);\\n            numi = ch[numi];\\n        }\\n        return ans;\\n    }\\n};\\n// please upvote if you like\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int>v(n, 1);\\n        vector<int>ch(n, -1);\\n        v[0] = 1;\\n        int numi = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] % nums[j] == 0 && v[i] < v[j] + 1) {\\n                    v[i] = v[j] + 1;\\n                    ch[i] = j;\\n                }\\n            }\\n            if(v[i] > v[numi]) { numi = i; }\\n        }\\n        vector<int> ans;\\n        while(numi != -1) {\\n            ans.push_back(nums[numi]);\\n            numi = ch[numi];\\n        }\\n        return ans;\\n    }\\n};\\n// please upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159976,
                "title": "c-fast-and-easy-to-understand",
                "content": "Question is based on concept of LIS \\nFor printing the LIS, we maintain a vector named hash where we store the prev index of the sequence we are forming and then trace back to form the answer vector.\\n```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int n = nums.size();\\n        \\n        if(n<2) return nums;\\n        \\n        vector<int> dp(n, 1);\\n        vector<int> hash(n, -1);\\n        \\n        int sz=0; int id = -1;\\n        \\n        for(int i=1; i<n; i++){\\n            \\n            for(int prev=0; prev<i; prev++){\\n                \\n                if(nums[i]%nums[prev] == 0 and dp[prev]+1 > dp[i]){\\n                    dp[i] = 1+dp[prev];\\n                    hash[i] = prev;\\n                }\\n                \\n            }\\n            if(dp[i] > sz){\\n               sz = dp[i];\\n               id = i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(id != -1){\\n            ans.push_back(nums[id]);\\n            id = hash[id];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int n = nums.size();\\n        \\n        if(n<2) return nums;\\n        \\n        vector<int> dp(n, 1);\\n        vector<int> hash(n, -1);\\n        \\n        int sz=0; int id = -1;\\n        \\n        for(int i=1; i<n; i++){\\n            \\n            for(int prev=0; prev<i; prev++){\\n                \\n                if(nums[i]%nums[prev] == 0 and dp[prev]+1 > dp[i]){\\n                    dp[i] = 1+dp[prev];\\n                    hash[i] = prev;\\n                }\\n                \\n            }\\n            if(dp[i] > sz){\\n               sz = dp[i];\\n               id = i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        while(id != -1){\\n            ans.push_back(nums[id]);\\n            id = hash[id];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077057,
                "title": "c-lis-print",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& a) {\\n        int n = a.size();\\n        \\n        vector<int> dp(n,1);\\n        vector<int> hash(n);\\n        int maxx=1;\\n        int lastidx=0;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        for(int i=1;i<n;i++){\\n            hash[i] = i;\\n            for(int j=0;j<i;j++){\\n                if(a[i]%a[j]==0 && dp[i] < dp[j]+1){\\n                    dp[i] = dp[j]+1;\\n                    hash[i] = j;\\n                }\\n            }\\n            if(maxx<dp[i]){\\n                maxx = dp[i];\\n                lastidx = i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        ans.push_back(a[lastidx]);\\n        while(hash[lastidx] != lastidx){\\n            lastidx = hash[lastidx];\\n            ans.push_back(a[lastidx]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& a) {\\n        int n = a.size();\\n        \\n        vector<int> dp(n,1);\\n        vector<int> hash(n);\\n        int maxx=1;\\n        int lastidx=0;\\n        \\n        sort(a.begin(),a.end());\\n        \\n        for(int i=1;i<n;i++){\\n            hash[i] = i;\\n            for(int j=0;j<i;j++){\\n                if(a[i]%a[j]==0 && dp[i] < dp[j]+1){\\n                    dp[i] = dp[j]+1;\\n                    hash[i] = j;\\n                }\\n            }\\n            if(maxx<dp[i]){\\n                maxx = dp[i];\\n                lastidx = i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        ans.push_back(a[lastidx]);\\n        while(hash[lastidx] != lastidx){\\n            lastidx = hash[lastidx];\\n            ans.push_back(a[lastidx]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064789,
                "title": "c-tabulation",
                "content": "```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 1), prev(n, -1), ans;\\n\\tsort(nums.begin(), nums.end());\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tint maxi = 1;\\n\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\tif(nums[i] % nums[j] == 0)\\n\\t\\t\\t\\tif(dp[i] + dp[j] > maxi)\\n\\t\\t\\t\\t\\tmaxi = dp[i] + dp[j], prev[i] = j;\\n\\t\\t}\\n\\t\\tdp[i] = maxi;\\n\\t}\\n\\tint maxLen = 0, idx;\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tif(dp[i] > maxLen)\\n\\t\\t\\tmaxLen = dp[i], idx = i;\\n\\twhile(idx != -1)\\n\\t\\tans.push_back(nums[idx]), idx = prev[idx];\\n\\treverse(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> largestDivisibleSubset(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> dp(n, 1), prev(n, -1), ans;\\n\\tsort(nums.begin(), nums.end());\\n\\tfor(int i = 1; i < n; i++) {\\n\\t\\tint maxi = 1;\\n\\t\\tfor(int j = 0; j < i; j++) {\\n\\t\\t\\tif(nums[i] % nums[j] == 0)\\n\\t\\t\\t\\tif(dp[i] + dp[j] > maxi)\\n\\t\\t\\t\\t\\tmaxi = dp[i] + dp[j], prev[i] = j;\\n\\t\\t}\\n\\t\\tdp[i] = maxi;\\n\\t}\\n\\tint maxLen = 0, idx;\\n\\tfor(int i = 0; i < n; i++)\\n\\t\\tif(dp[i] > maxLen)\\n\\t\\t\\tmaxLen = dp[i], idx = i;\\n\\twhile(idx != -1)\\n\\t\\tans.push_back(nums[idx]), idx = prev[idx];\\n\\treverse(ans.begin(), ans.end());\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994281,
                "title": "short-and-simple-lis-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int maxi = 1, lastIndex = 0;\\n        int n = nums.size();\\n        vector<int> dp(n, 1), path(n);\\n\\n        for (int i = 0; i < n; i++) {\\n            path[i] = i;\\n            for (int prev = 0; prev < i; prev++) {\\n                if ((nums[i] % nums[prev] == 0) && (1 + dp[prev] > dp[i])) {\\n                    dp[i] = 1 + dp[prev];\\n                    path[i] = prev;\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n\\n        vector<int> lds;\\n        lds.push_back(nums[lastIndex]);\\n        while (path[lastIndex] != lastIndex) {\\n            lastIndex = path[lastIndex];\\n            lds.push_back(nums[lastIndex]);\\n        }\\n\\n        return lds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int maxi = 1, lastIndex = 0;\\n        int n = nums.size();\\n        vector<int> dp(n, 1), path(n);\\n\\n        for (int i = 0; i < n; i++) {\\n            path[i] = i;\\n            for (int prev = 0; prev < i; prev++) {\\n                if ((nums[i] % nums[prev] == 0) && (1 + dp[prev] > dp[i])) {\\n                    dp[i] = 1 + dp[prev];\\n                    path[i] = prev;\\n                }\\n            }\\n            if (dp[i] > maxi) {\\n                maxi = dp[i];\\n                lastIndex = i;\\n            }\\n        }\\n\\n        vector<int> lds;\\n        lds.push_back(nums[lastIndex]);\\n        while (path[lastIndex] != lastIndex) {\\n            lastIndex = path[lastIndex];\\n            lds.push_back(nums[lastIndex]);\\n        }\\n\\n        return lds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565346,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1565411,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569992,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1575969,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572844,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569098,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571640,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1975984,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2030719,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759631,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1565346,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1565411,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569992,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1575969,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572844,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569098,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571640,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1975984,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2030719,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759631,
                "content": [
                    {
                        "username": "kevin36",
                        "content": "**Update: The question has now been updated and is correct.**\\n\\nI have a major problem with this question it says `Given a set of distinct positive integers, find the largest subset such that **every pair** (Si, Sj) of elements in this subset satisfies: Si % Sj = 0.`\\n\\nThe key word here is every, lets look at one of the examples\\n\\n    input is nums = [1,2,3]\\n    \\n    then the result is [1,2]\\n\\nbut in the question is say  that for every pair in our solution we should have Si % Sj = 0. So lets look at every pair we have the first pair (2, 1) and we have 2%1 = 0, so that holds. Now lets look at the other pair (1,2) 1%2 = 1 this is not zero hence [1,2] cannot be the solution.\\n\\nIf we require **every pair** so that **Si % Sj = 0** then your subset will be a set of one item since we require both that **Sj% Si = 0**  and **Si % Sj = 0** which forces that **Si = Sj**.\\n\\nSo please fix the requirements of the question to reflect what the author intended."
                    },
                    {
                        "username": "raistar702614",
                        "content": "Find the larget subset such in every pair(a,b)\\neither a divides b || b divides a"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/largest-divisible-subset/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Dynamic Programming with Less Space\n\n  \n**Approach 3:** Recursion with Memoization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Mariana_c",
                        "content": "![image](https://assets.leetcode.com/users/mariana_c/image_1592178242.png)\\nThe problem reminded me the issue of finding the clique maximal. So this post is just for curiosity porpose.\\n\\nIn the example, an edge represents that one node of the pair can be divisible by the other.\\nWe can see that the clique maximal is the complete subgraph [3,6,12,24].\\n\\nThere are many possibilities to approach the clique maximal problem, this wiki link summarizes some of them, such as colouring greedy approach and decision tree:\\nhttps://en.wikipedia.org/wiki/Clique_problem\\n\\nAlso, the python library called networkX can give some insights on the matter:\\nhttps://networkx.github.io/documentation/stable/reference/algorithms/clique.html\\nhttps://networkx.github.io/documentation/networkx-1.9/reference/generated/networkx.algorithms.approximation.clique.max_clique.html"
                    },
                    {
                        "username": "selder02",
                        "content": "We can use dynamic programming. For each number n, we want to find the largest divisible subset whose largest element is n. Call the size of that set OPT(n), and call the set itself S(n).\\n\\nLet\\'s calculate OPT(n) in order of increasing n. (Sort the list first.) The crucial observation is that if n % m == 0 for some m < n, then all elements of S(m) will also divide n. Therefore, OPT(n) is the largest of 1 + OPT(m) among all m < n which divide n.\\n\\nThen the largest OPT(n) will be the size of the largest divisible subset.\\n\\nIf there are N elements, this procedure gives you the size of the largest divisible subset in O(N^2) time, since computing each OPT(n) requires finding the maximum of O(N) possibilities.\\n\\nTo find the set itself, we can slightly add to the procedure above. When you calculate OPT(n) = S(m) + 1, also store PREV(n) = m. Then at the end, we can build the answer by tracking through the list of indices, i.e. {n, PREV(n), PREV(PREV(n)), ...}."
                    },
                    {
                        "username": "afsf11",
                        "content": "Why must we sort prior to DP solution?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "i think we can solve it without sorting too by checking both conditions nums[j]%nums[i] == 0 || nums[i]%nums[j]==0.\\nBut my sol didn\\'t worked without sorting and reason for sorting is if a> b and b divides a then all the elements smaller than b which lies in same set i.e divides b will divide a too so we can just add the ans directly."
                    },
                    {
                        "username": "wad",
                        "content": "I have read some solution online and notice there are some bugs. However, their solutions can pass the test.\\nInput:\\n[1,2,4,8,9,72]\\nExpected:\\n[1,2,4,8,72]\\nWrong:\\n[1,2,4,72]\\nThe set up is the same, they use hashmaps to record with each number as the largest number in the set, what is largest divisible subset.\\n1:[1]\\n2:[1,2]\\n4:[1,2,4]\\n8:[1,2,4,8]\\n9:[1,9]\\nIn their solution, when they search to 72 and go backwards to search if there are divisor of 72 in previous numbers, they stop at the first divisor they come across, which is 9 in this case. That is not right. \\nso they got\\n72:[1,9,72]\\n\\nSo I think some test cases should be added here"
                    },
                    {
                        "username": "shawngao",
                        "content": "I submitted the same code several times. Get different runtime for each submission. There was even one runtime error w/o any useful information returned!\\n\\n![0_1472765982575_Screen Shot 2016-09-01 at 4.35.36 PM.png](/uploads/files/1472765983444-screen-shot-2016-09-01-at-4.35.36-pm.png)"
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "Yup same thing happened to me"
                    },
                    {
                        "username": "rahul_baradol",
                        "content": "One of the best dp problems out there!!!!"
                    },
                    {
                        "username": "felicity99",
                        "content": "What if the question asks given a list of positive integers (might have duplicated), and other thing\\'s the same. Anyone could provide hint/solution?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    }
]