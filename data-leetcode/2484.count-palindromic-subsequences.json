[
    {
        "title": "Count Palindromic Subsequences",
        "question_content": "Given a string of digits s, return the number of palindromic subsequences of s having length 5. Since the answer may be very large, return it modulo 109 + 7.\nNote:\n\n\tA string is palindromic if it reads the same forward and backward.\n\tA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\n&nbsp;\nExample 1:\n\nInput: s = \"103301\"\nOutput: 2\nExplanation: \nThere are 6 possible subsequences of length 5: \"10330\",\"10331\",\"10301\",\"10301\",\"13301\",\"03301\". \nTwo of them (both equal to \"10301\") are palindromic.\n\nExample 2:\n\nInput: s = \"0000000\"\nOutput: 21\nExplanation: All 21 subsequences are \"00000\", which is palindromic.\n\nExample 3:\n\nInput: s = \"9999900000\"\nOutput: 2\nExplanation: The only two palindromic subsequences are \"99999\" and \"00000\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\ts consists of digits.",
        "solutions": [
            {
                "id": 2850466,
                "title": "c-java-python3-counting-prefixes-and-suffixes",
                "content": "# Intuition\\nTo create a 5 digit palindrome we do not need to care about the middle element. We just need to find subsequence of pattern XY_YX. Calculate number of subsequences of type XY and subsequences of type YX around any given point `i` and multiply them to find number of subsequences of type XY_YX. Since string only has digits, the time complexity will be 100*n.\\n\\n# Approach\\n* We will be maintaing the counts of digit in the list `cnts`\\n* Keep 2 arrays pre and suf to store the number of prefixes of type XY and suffixes of type YX. `pre[i-1][1][2]` means prefixes of type `12` before index i. Similarly `suf[i+1][1][2]` means suffixes of type `21` after index i\\n* Remember given string is made of digits that is `0123456789`. That\\'s a total of 10 unique characters\\n* Once we have calculated the prefix and suffix lists we just need to multiply `pre[i - 1][j][k]` with `suf[i + 1][j][k]` to find number of palindromic subsequences\\n```\\n    for (int i = 0; i < n; i++) {\\n        int c = s[i] - \\'0\\';\\n        if (i) {\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        }\\n        cnts[c]++;\\n    }\\n```\\n* Explanation of above code:\\n    * Use `if (i)` to not step outside of array limits when accessing `pre[i-1]`\\n    * Let\\'s say `j = 5`, `k = 4` and `c = 4` which means we are looking at prefix `54`. `pre[i][j][k] = pre[i - 1][j][k]` will carry forward previous count of prefixes. Since `k == c` means the current character(s[i]) matches with last digit of prefix. To find total number of possibilites of prefixes of type `54` we need to know how many `5` exist before current index. This information is stored in `cnts[5]`. So we add `cnts[5]` to `pre[i][5][4]`.\\n    \\n![Screen Shot 2022-11-27 at 10.13.27 AM.png](https://assets.leetcode.com/users/images/aa300f55-d7b1-4f1f-a23f-d2d6fb7454a1_1669572828.8937273.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n\\n**Python 3**\\n```\\ndef countPalindromes(self, s: str) -> int:\\n    mod, n, ans = 10 ** 9 + 7, len(s), 0\\n    pre, cnts = [[[0] * 10 for _ in range(10)] for _ in range(n)], [0] * 10\\n    for i in range(n):\\n        c = ord(s[i]) - ord(\\'0\\')\\n        if i:\\n            for j in range(10):\\n                for k in range(10):\\n                    pre[i][j][k] = pre[i - 1][j][k] \\n                    if k == c: pre[i][j][k] += cnts[j]\\n        cnts[c] += 1\\n    suf, cnts = [[[0] * 10 for _ in range(10)] for _ in range(n)], [0] * 10\\n    for i in range(n - 1, -1, -1):\\n        c = ord(s[i]) - ord(\\'0\\')\\n        if i < n - 1:\\n            for j in range(10):\\n                for k in range(10):\\n                    suf[i][j][k] = suf[i + 1][j][k]\\n                    if k == c: suf[i][j][k] += cnts[j]\\n        cnts[c] += 1\\n    for i in range(2, n - 2):\\n        for j in range(10):\\n            for k in range(10):\\n                ans += pre[i - 1][j][k] * suf[i + 1][j][k]\\n    return ans % mod\\n```\\n\\n**C++**\\n```\\nint pre[10000][10][10], suf[10000][10][10], cnts[10] = {};\\nint countPalindromes(string s) {\\n    int mod = 1e9 + 7, n = s.size(), ans = 0;\\n    for (int i = 0; i < n; i++) {\\n        int c = s[i] - \\'0\\';\\n        if (i)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    memset(cnts, 0, sizeof(cnts));\\n    for (int i = n - 1; i >= 0; i--) {\\n        int c = s[i] - \\'0\\';\\n        if (i < n - 1)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    suf[i][j][k] = suf[i + 1][j][k];\\n                    if (k == c) suf[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    for (int i = 2; i < n - 2; i++)\\n        for (int j = 0; j < 10; j++)\\n            for (int k = 0; k < 10; k++)\\n                ans = (ans + 1LL * pre[i - 1][j][k] * suf[i + 1][j][k]) % mod;\\n    return ans;\\n}\\n```\\n\\n**Java**\\n```\\npublic int countPalindromes(String s) {\\n    int mod = 1000_000_007, n = s.length(), ans = 0, cnts[] = new int[10],\\n    pre[][][] = new int[n][10][10], suf[][][] = new int[n][10][10];\\n    for (int i = 0; i < n; i++) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i > 0)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    Arrays.fill(cnts, 0);\\n    for (int i = n - 1; i >= 0; i--) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i < n - 1)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    suf[i][j][k] = suf[i + 1][j][k];\\n                    if (k == c) suf[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    for (int i = 2; i < n - 2; i++)\\n        for (int j = 0; j < 10; j++)\\n            for (int k = 0; k < 10; k++)\\n                ans = (int)((ans + 1L * pre[i - 1][j][k] * suf[i + 1][j][k]) % mod);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n    for (int i = 0; i < n; i++) {\\n        int c = s[i] - \\'0\\';\\n        if (i) {\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        }\\n        cnts[c]++;\\n    }\\n```\n```\\ndef countPalindromes(self, s: str) -> int:\\n    mod, n, ans = 10 ** 9 + 7, len(s), 0\\n    pre, cnts = [[[0] * 10 for _ in range(10)] for _ in range(n)], [0] * 10\\n    for i in range(n):\\n        c = ord(s[i]) - ord(\\'0\\')\\n        if i:\\n            for j in range(10):\\n                for k in range(10):\\n                    pre[i][j][k] = pre[i - 1][j][k] \\n                    if k == c: pre[i][j][k] += cnts[j]\\n        cnts[c] += 1\\n    suf, cnts = [[[0] * 10 for _ in range(10)] for _ in range(n)], [0] * 10\\n    for i in range(n - 1, -1, -1):\\n        c = ord(s[i]) - ord(\\'0\\')\\n        if i < n - 1:\\n            for j in range(10):\\n                for k in range(10):\\n                    suf[i][j][k] = suf[i + 1][j][k]\\n                    if k == c: suf[i][j][k] += cnts[j]\\n        cnts[c] += 1\\n    for i in range(2, n - 2):\\n        for j in range(10):\\n            for k in range(10):\\n                ans += pre[i - 1][j][k] * suf[i + 1][j][k]\\n    return ans % mod\\n```\n```\\nint pre[10000][10][10], suf[10000][10][10], cnts[10] = {};\\nint countPalindromes(string s) {\\n    int mod = 1e9 + 7, n = s.size(), ans = 0;\\n    for (int i = 0; i < n; i++) {\\n        int c = s[i] - \\'0\\';\\n        if (i)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    memset(cnts, 0, sizeof(cnts));\\n    for (int i = n - 1; i >= 0; i--) {\\n        int c = s[i] - \\'0\\';\\n        if (i < n - 1)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    suf[i][j][k] = suf[i + 1][j][k];\\n                    if (k == c) suf[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    for (int i = 2; i < n - 2; i++)\\n        for (int j = 0; j < 10; j++)\\n            for (int k = 0; k < 10; k++)\\n                ans = (ans + 1LL * pre[i - 1][j][k] * suf[i + 1][j][k]) % mod;\\n    return ans;\\n}\\n```\n```\\npublic int countPalindromes(String s) {\\n    int mod = 1000_000_007, n = s.length(), ans = 0, cnts[] = new int[10],\\n    pre[][][] = new int[n][10][10], suf[][][] = new int[n][10][10];\\n    for (int i = 0; i < n; i++) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i > 0)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    Arrays.fill(cnts, 0);\\n    for (int i = n - 1; i >= 0; i--) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i < n - 1)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    suf[i][j][k] = suf[i + 1][j][k];\\n                    if (k == c) suf[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    for (int i = 2; i < n - 2; i++)\\n        for (int j = 0; j < 10; j++)\\n            for (int k = 0; k < 10; k++)\\n                ans = (int)((ans + 1L * pre[i - 1][j][k] * suf[i + 1][j][k]) % mod);\\n    return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2850433,
                "title": "4d-dp-c-top-down",
                "content": "```\\n#define ll long long\\nll dp[10001][11][11][6];\\nclass Solution {\\npublic:\\n    ll mod;\\n    ll dfs(int ind, int first, int second, int i, string &s) {\\n        if(i == 5) return 1; //found a subsequence\\n        if(ind == s.length()) return 0;\\n        if(dp[ind][first][second][i] != -1) return dp[ind][first][second][i];\\n        \\n        //option of not choosing current digit\\n        ll res = dfs(ind + 1, first, second, i, s);\\n\\n        if(i == 0) {\\n            //option of choosing the first digit of the subsequence\\n            res += dfs(ind + 1, s[ind] - \\'0\\', second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 1) {\\n            //option of choosing the second digit of the subsequence\\n            res += dfs(ind + 1, first, s[ind] - \\'0\\', i + 1, s);\\n            res %= mod;\\n        } else if(i == 2) {\\n            //option of choosing the third digit of the subsequence\\n            res += dfs(ind + 1, first, second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 3) {\\n            //option of choosing the fourth digit of the subsequence if it matches with the second digit\\n            if(s[ind] - \\'0\\' == second) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        } else if(i == 4) {\\n            //option of choosing the fifth digit of the subsequence if it matches with the first digit\\n            if(s[ind] - \\'0\\' == first) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        }\\n        return dp[ind][first][second][i] = res;\\n    }\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof dp); \\n        mod = 1e9 + 7;\\n        return dfs(0, 10, 10, 0, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nll dp[10001][11][11][6];\\nclass Solution {\\npublic:\\n    ll mod;\\n    ll dfs(int ind, int first, int second, int i, string &s) {\\n        if(i == 5) return 1; //found a subsequence\\n        if(ind == s.length()) return 0;\\n        if(dp[ind][first][second][i] != -1) return dp[ind][first][second][i];\\n        \\n        //option of not choosing current digit\\n        ll res = dfs(ind + 1, first, second, i, s);\\n\\n        if(i == 0) {\\n            //option of choosing the first digit of the subsequence\\n            res += dfs(ind + 1, s[ind] - \\'0\\', second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 1) {\\n            //option of choosing the second digit of the subsequence\\n            res += dfs(ind + 1, first, s[ind] - \\'0\\', i + 1, s);\\n            res %= mod;\\n        } else if(i == 2) {\\n            //option of choosing the third digit of the subsequence\\n            res += dfs(ind + 1, first, second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 3) {\\n            //option of choosing the fourth digit of the subsequence if it matches with the second digit\\n            if(s[ind] - \\'0\\' == second) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        } else if(i == 4) {\\n            //option of choosing the fifth digit of the subsequence if it matches with the first digit\\n            if(s[ind] - \\'0\\' == first) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        }\\n        return dp[ind][first][second][i] = res;\\n    }\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof dp); \\n        mod = 1e9 + 7;\\n        return dfs(0, 10, 10, 0, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850557,
                "title": "c-java-python3-short-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/679b6a406693e67fb9637bbd1c8449f2372e76c5) for solutions of biweekly 92. \\n\\n**Intuition**\\nIf a size 5 palindromic subsequence is given, we can check how many of it appears in s in O(N) via DP. In total, there are 100 (not 1000) relevant subsequences to check. \\n\\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        const int mod = 1\\'000\\'000\\'007; \\n        int n = s.size(); \\n        long ans = 0; \\n        for (int x = 0; x <= 9; ++x) \\n            for (int y = 0; y <= 9; ++y) {\\n                vector<int> pattern = {x, y, 0, y, x}; \\n                vector<long> dp(6); \\n                dp[5] = 1; \\n                for (int i = 0; i < n; ++i) \\n                    for (int j = 0; j < 5; ++j) \\n                        if (s[i] == pattern[j] + \\'0\\' || j == 2) dp[j] = (dp[j] + dp[j+1]) % mod; \\n                ans = (ans + dp[0]) % mod; \\n            }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        final int mod = 1_000_000_007; \\n        long ans = 0; \\n        for (int x = 0; x <= 9; ++x) \\n            for (int y = 0; y <= 9; ++y) {\\n                int[] pattern = new int[] {x, y, 0, y, x};\\n                long [] dp = new long[6]; \\n                dp[5] = 1; \\n                for (int i = 0; i < s.length(); ++i) \\n                    for (int j = 0; j < 5; ++j) \\n                        if (s.charAt(i) == pattern[j] + \\'0\\' || j == 2) dp[j] = (dp[j] + dp[j+1]) % mod; \\n                ans = (ans + dp[0]) % mod; \\n            }\\n        return (int) ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        ans = 0 \\n        for x in range(10): \\n            for y in range(10): \\n                pattern = f\"{x}{y}|{y}{x}\" \\n                dp = [0]*6\\n                dp[-1] = 1 \\n                for i in range(len(s)): \\n                    for j in range(5): \\n                        if s[i] == pattern[j] or j == 2: dp[j] += dp[j+1]\\n                ans = (ans + dp[0]) % 1_000_000_007\\n        return ans \\n```\\n**Complexity**\\nTime O(N) \\nSpace O(1)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        const int mod = 1\\'000\\'000\\'007; \\n        int n = s.size(); \\n        long ans = 0; \\n        for (int x = 0; x <= 9; ++x) \\n            for (int y = 0; y <= 9; ++y) {\\n                vector<int> pattern = {x, y, 0, y, x}; \\n                vector<long> dp(6); \\n                dp[5] = 1; \\n                for (int i = 0; i < n; ++i) \\n                    for (int j = 0; j < 5; ++j) \\n                        if (s[i] == pattern[j] + \\'0\\' || j == 2) dp[j] = (dp[j] + dp[j+1]) % mod; \\n                ans = (ans + dp[0]) % mod; \\n            }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        final int mod = 1_000_000_007; \\n        long ans = 0; \\n        for (int x = 0; x <= 9; ++x) \\n            for (int y = 0; y <= 9; ++y) {\\n                int[] pattern = new int[] {x, y, 0, y, x};\\n                long [] dp = new long[6]; \\n                dp[5] = 1; \\n                for (int i = 0; i < s.length(); ++i) \\n                    for (int j = 0; j < 5; ++j) \\n                        if (s.charAt(i) == pattern[j] + \\'0\\' || j == 2) dp[j] = (dp[j] + dp[j+1]) % mod; \\n                ans = (ans + dp[0]) % mod; \\n            }\\n        return (int) ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        ans = 0 \\n        for x in range(10): \\n            for y in range(10): \\n                pattern = f\"{x}{y}|{y}{x}\" \\n                dp = [0]*6\\n                dp[-1] = 1 \\n                for i in range(len(s)): \\n                    for j in range(5): \\n                        if s[i] == pattern[j] or j == 2: dp[j] += dp[j+1]\\n                ans = (ans + dp[0]) % 1_000_000_007\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850667,
                "title": "simplify-to-classic-dp-2-d-recursive-solution-c",
                "content": "<h2>Approach</h2>\\nInstead of solving the actual problem, let us solve another one.\\n\\n<b>Given  two string S and  T. We want to count the number of times that string T occurs in string S as a subsequence.<b>\\n\\nA straight forward dp question. How do we solve it?\\nWe can create a recursive function with two state (i,j) where i indicates current position in string S and j is the length of prefix of T we matched so far. So if we find j==T.size() we found a subsequence that is equal to T.\\nThen the transitions are:<b>\\n\\t<p>(i,j) to (i+1,j) [ ignoring the ith character of S] </p> and (i,j) to (i+1,j+1) if(S[i]==T[j])\\n\\t</b>\\nWe will avoid overlapping calculation using memoization . You can find plenty of resource for this problem. I added a good resource in the comment section.\\n\\nNow let us come back to the original problem. How many palindromes are there that is of length 5.\\nWe can place 10 numbers in first,second and third digit. Fourth and fifth digit will be equal to second and first digit. So we can generate all these palindromic strings and check how many times they occur as a substring in S.\\n\\nAnother optimization is we don\\'t actually need to check third digit as it can be anything so we can just take any digit and match it with the third digit of our palindrome digit.\\n\\n<h3>Code</h3>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[10001][5];\\n\\t\\tstring digit;\\n\\t\\tstring s;\\n\\t\\tint mod = 1e9+7;\\n\\t\\t//Get a palindrome string when first two digit equals to x\\n\\t\\tstring getDigit(int x){\\n\\t\\t\\tstring s = to_string(x);\\n\\t\\t\\tif(s.size()==1)s = \\'0\\'+s; // if x<10 we add a 0 in front of it.\\n\\t\\t\\tstring t = s;\\n\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\treverse(t.begin(),t.end());\\n\\t\\t\\ts+=t;\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t\\tint call(int pos,int id){\\n\\t\\t\\tif(id==5) return 1;\\n\\t\\t\\tif(pos==s.size()) return 0;\\n\\t\\t\\tif(dp[pos][id]+1) return dp[pos][id];\\n\\t\\t\\tint ret = 0;\\n\\t\\t\\tret = call(pos+1,id);\\n\\t\\t\\t//if id==2 we can take any digit.\\n\\t\\t\\tif(id==2 || s[pos] == digit[id] ) ret = (ret+call(pos+1,id+1))%mod;\\n\\t\\t\\treturn dp[pos][id] = ret;\\n\\t\\t}\\n\\t\\tint countPalindromes(string t) {\\n\\t\\t\\ts = t;\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tfor(int i=0;i<100;i++){\\n\\t\\t\\t\\tmemset(dp,-1,sizeof dp);\\n\\t\\t\\t\\tdigit = getDigit(i);\\n\\t\\t\\t\\tans = ans+call(0,0);\\n\\t\\t\\t\\tans = (ans%mod);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[10001][5];\\n\\t\\tstring digit;\\n\\t\\tstring s;\\n\\t\\tint mod = 1e9+7;\\n\\t\\t//Get a palindrome string when first two digit equals to x\\n\\t\\tstring getDigit(int x){\\n\\t\\t\\tstring s = to_string(x);\\n\\t\\t\\tif(s.size()==1)s = \\'0\\'+s; // if x<10 we add a 0 in front of it.\\n\\t\\t\\tstring t = s;\\n\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\treverse(t.begin(),t.end());\\n\\t\\t\\ts+=t;\\n\\t\\t\\treturn s;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2851160,
                "title": "dp-vs-prefix-suffix",
                "content": "To make a palindrome, we fix two numbers at positions `i` and `j`, and count reverse pairs of these numbers starting from position `j + 2`.\\n\\n> `j + 1` is reserved to account for the middle position in a palindrome.\\n\\nA simple quartic solution can be improved to cubic and then to quadratic, but it wasn\\'t enough. We need a linear algorithm to solve this problem.\\n\\nThe DP solution is O(100 * n * m), or just O(n * m), where `m` is the number of characters in the pattern. The second solution is O(100 * n), or just O(n).\\n\\n#### DP\\n0/1 Knapsack with an extra dimension - position in a pattern (`[0..5)`) - would do.\\n\\nFor each combination of two numbers, we run `dfs` to count matching patterns.\\n\\nWith memoisation, the complexity of this approach is O(100 * m * n), where `m` is the number of characters in the pattern.\\n\\n**C++**\\n```cpp\\nint dp[10001][5];\\nint dfs(int i, int p, string &pat, string &s) {\\n    if (p == pat.size() || i >= s.size())\\n        return p == pat.size();\\n    if (dp[i][p] == 0) {\\n        dp[i][p] = 1 + dfs(i + 1, p, pat, s);\\n        if (pat[p] == \\'*\\' || pat[p] == s[i])\\n            dp[i][p] = (dp[i][p] + dfs(i + 1, p + 1, pat, s)) % 1000000007;\\n    }\\n    return dp[i][p] - 1;\\n}\\nint countPalindromes(string s) {\\n    long long res = 0;\\n    for (char n1 = \\'0\\'; n1 <= \\'9\\'; ++n1)\\n        for (char n2 = \\'0\\'; n2 <= \\'9\\'; ++n2) {\\n            memset(dp, 0, 5 * s.size() * sizeof(int));\\n            res = (res + dfs(0, 0, string() = {n1, n2, \\'*\\', n2, n1}, s)) % 1000000007;\\n        }\\n    return res; \\n}\\n```\\n\\n#### Prefix * Suffix\\n\\nWe compute prefix and suffix count of pairs (`n1, n2`) for each combination of `n1` and `n2`.\\n\\n`pref[m][n1][n2]` tells us how many (n1, n2) pairs we have in the `[0..m]` interval, and `suff[m][n1][n2]` - in the `[m..sz)` interval.\\n\\nTo compute pairs, we first count each number in `cnt_p`. `cnt_p[i][n]` tells how many `n` appears in interval `[0..i]`.\\n\\nThen, `pref[i][n1][n2] = pref[i - 1][n1][n2] + cnt_p[i - 1][n2]`. For `[1,1,2,1,2]` example:\\n- for position 2, `pref[2][1][2] == 2` (`cnt_p[1][2] == 2`), and we have two pairs - [0, 2] and [1, 2].\\n- same for position 3, `pref[3][1][2] == 2`.\\n- for position 4, `pref[4][1][2] == 2 + 3` (`cnt_p[3][2] == 3`), and we have total 5 pairs.\\n\\nFinally, we sum `pref[m - 1][n1][n2] * pref[m + 1][n2][n1]` for each `m`.\\n\\n> Note that we can pre-compute either `pref` or `suff`, and them compute the other on the fly when doing the sum.\\n\\n**C++**\\n```cpp\\nint cnt_p[10] = {}, cnt_s[10002][10] = {};\\nint pref[10][10] = {}, suff[10002][10][10] = {};\\nint countPalindromes(string s) {\\n    long long res = 0, sz = s.size();\\n    for (int i = 0, j = sz - 1; i < sz; ++i, --j)\\n        for (int n = 0; n < 10; ++n)\\n            cnt_s[j][n] = cnt_s[j + 1][n] + (s[j] == \\'0\\' + n);\\n    for(int i = sz - 2; i >= 0; --i) {\\n        memcpy(suff[i], suff[i + 1], 100 * sizeof(int));\\n        for(int n1 = 0; n1 < 10; ++n1)\\n            suff[i][(s[i] - \\'0\\')][n1] += cnt_s[i + 1][n1];\\n    }\\n    for (int m = 1; m < s.size() - 1; ++m)\\n        for(int n1 = 0; n1 < 10; ++n1) {\\n            for(int n2 = 0; n2 < 10; ++n2)\\n                res = (res + (long long)pref[n1][n2] * suff[m + 1][n2][n1]) % 1000000007;\\n            cnt_p[n1] += s[m - 1] == \\'0\\' + n1;\\n            pref[n1][s[m] - \\'0\\'] += cnt_p[n1];\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[10001][5];\\nint dfs(int i, int p, string &pat, string &s) {\\n    if (p == pat.size() || i >= s.size())\\n        return p == pat.size();\\n    if (dp[i][p] == 0) {\\n        dp[i][p] = 1 + dfs(i + 1, p, pat, s);\\n        if (pat[p] == \\'*\\' || pat[p] == s[i])\\n            dp[i][p] = (dp[i][p] + dfs(i + 1, p + 1, pat, s)) % 1000000007;\\n    }\\n    return dp[i][p] - 1;\\n}\\nint countPalindromes(string s) {\\n    long long res = 0;\\n    for (char n1 = \\'0\\'; n1 <= \\'9\\'; ++n1)\\n        for (char n2 = \\'0\\'; n2 <= \\'9\\'; ++n2) {\\n            memset(dp, 0, 5 * s.size() * sizeof(int));\\n            res = (res + dfs(0, 0, string() = {n1, n2, \\'*\\', n2, n1}, s)) % 1000000007;\\n        }\\n    return res; \\n}\\n```\n```cpp\\nint cnt_p[10] = {}, cnt_s[10002][10] = {};\\nint pref[10][10] = {}, suff[10002][10][10] = {};\\nint countPalindromes(string s) {\\n    long long res = 0, sz = s.size();\\n    for (int i = 0, j = sz - 1; i < sz; ++i, --j)\\n        for (int n = 0; n < 10; ++n)\\n            cnt_s[j][n] = cnt_s[j + 1][n] + (s[j] == \\'0\\' + n);\\n    for(int i = sz - 2; i >= 0; --i) {\\n        memcpy(suff[i], suff[i + 1], 100 * sizeof(int));\\n        for(int n1 = 0; n1 < 10; ++n1)\\n            suff[i][(s[i] - \\'0\\')][n1] += cnt_s[i + 1][n1];\\n    }\\n    for (int m = 1; m < s.size() - 1; ++m)\\n        for(int n1 = 0; n1 < 10; ++n1) {\\n            for(int n2 = 0; n2 < 10; ++n2)\\n                res = (res + (long long)pref[n1][n2] * suff[m + 1][n2][n1]) % 1000000007;\\n            cnt_p[n1] += s[m - 1] == \\'0\\' + n1;\\n            pref[n1][s[m] - \\'0\\'] += cnt_p[n1];\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850441,
                "title": "precomputations-o-n",
                "content": "* Record occurence of each possible pair before ith index and after ith index\\n* Add product to the answer. \\n\\n```\\n\\nclass Solution {\\n\\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long c[][] = new long[10][n];\\n\\n        for (int num = 0; num < 10; num++) {\\n            for (int i = 0; i < n; i++) {\\n                if (i > 0) c[num][i] += c[num][i - 1];\\n                if (s.charAt(i) - \\'0\\' == num) c[num][i]++;\\n            }\\n        }\\n\\n        long pc[][][] = new long[10][10][n]; // pairs count (prefix)\\n        long fc[][][] = new long[10][10][n]; // pairs count (suffix)\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                for (int num2 = 0; num2 < 10; num2++) {\\n                    long x[] = pc[num1][num2];\\n                    x[i] += x[i - 1];\\n                }\\n            }\\n            // for each possible number to pair with current number on ith index\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                int curr = s.charAt(i) - \\'0\\';\\n                long x[] = pc[num1][curr];\\n                x[i] += c[num1][i - 1];\\n            }\\n        }\\n\\n        c = new long[10][n];\\n\\n        for (int num = 0; num < 10; num++) {\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (i < n - 1) c[num][i] += c[num][i + 1];\\n                if (s.charAt(i) - \\'0\\' == num) c[num][i]++;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                for (int num2 = 0; num2 < 10; num2++) {\\n                    long x[] = fc[num1][num2];\\n                    x[i] += x[i + 1];\\n                }\\n            }\\n            // for each possible number to pair with current number on ith index\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                int curr = s.charAt(i) - \\'0\\';\\n                long x[] = fc[curr][num1];\\n                x[i] += c[num1][i + 1];\\n            }\\n        }\\n\\n        long ans = 0, mod = (long) (1e9 + 7);\\n        for (int i = 1; i < n - 1; i++) {\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                for (int num2 = 0; num2 < 10; num2++) {\\n                    long lc = pc[num1][num2][i - 1];\\n                    long rc = fc[num2][num1][i + 1];\\n                    if (lc > 0 && rc > 0) ans += (lc * rc) % mod;\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\n\\nclass Solution {\\n\\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long c[][] = new long[10][n];\\n\\n        for (int num = 0; num < 10; num++) {\\n            for (int i = 0; i < n; i++) {\\n                if (i > 0) c[num][i] += c[num][i - 1];\\n                if (s.charAt(i) - \\'0\\' == num) c[num][i]++;\\n            }\\n        }\\n\\n        long pc[][][] = new long[10][10][n]; // pairs count (prefix)\\n        long fc[][][] = new long[10][10][n]; // pairs count (suffix)\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                for (int num2 = 0; num2 < 10; num2++) {\\n                    long x[] = pc[num1][num2];\\n                    x[i] += x[i - 1];\\n                }\\n            }\\n            // for each possible number to pair with current number on ith index\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                int curr = s.charAt(i) - \\'0\\';\\n                long x[] = pc[num1][curr];\\n                x[i] += c[num1][i - 1];\\n            }\\n        }\\n\\n        c = new long[10][n];\\n\\n        for (int num = 0; num < 10; num++) {\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (i < n - 1) c[num][i] += c[num][i + 1];\\n                if (s.charAt(i) - \\'0\\' == num) c[num][i]++;\\n            }\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                for (int num2 = 0; num2 < 10; num2++) {\\n                    long x[] = fc[num1][num2];\\n                    x[i] += x[i + 1];\\n                }\\n            }\\n            // for each possible number to pair with current number on ith index\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                int curr = s.charAt(i) - \\'0\\';\\n                long x[] = fc[curr][num1];\\n                x[i] += c[num1][i + 1];\\n            }\\n        }\\n\\n        long ans = 0, mod = (long) (1e9 + 7);\\n        for (int i = 1; i < n - 1; i++) {\\n            for (int num1 = 0; num1 < 10; num1++) {\\n                for (int num2 = 0; num2 < 10; num2++) {\\n                    long lc = pc[num1][num2][i - 1];\\n                    long rc = fc[num2][num1][i + 1];\\n                    if (lc > 0 && rc > 0) ans += (lc * rc) % mod;\\n                    ans %= mod;\\n                }\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850446,
                "title": "c-rolling-dp-o-100n-short",
                "content": "`N` is the index of current DP, while `N^1` is the index of previous DP, which is used to construct the Rolling DP. ( `0 ^ 1 = 1`, `1 ^ 1 = 0` )\\n`dp1[N][j]` is the number of subsequence with `\"j\"`.\\n`dp2[N][j][k]` is the number of subsequence with `\"jk\"`.\\n`dp3[N][j][k]` is the number of subsequence with `\"jkx\"`, where x can be 0 to 9.\\n`dp4[N][j][k]` is the number of subsequence with `\"jkxk\"`, where x can be 0 to 9.\\n`res` is the number of subsequence with `\"jkxkj\"`, where x, j, k can be 0 to 9.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size(), res = 0, MOD = 1e9+7, N = 1;\\n        int dp1[2][10] = {}, dp2[2][10][10] = {}, dp3[2][10][10] = {}, dp4[2][10][10] = {};\\n        for(auto i : s){\\n            int id = i-\\'0\\';\\n            for(int j = 0; j < 10; j++){\\n                dp1[N][j] = (dp1[N^1][j]+(j==id))%MOD;\\n                for(int k = 0; k < 10; k++){\\n                    dp2[N][j][k] = (dp2[N^1][j][k]+(k==id?dp1[N^1][j]:0))%MOD;\\n                    dp3[N][j][k] = (dp3[N^1][j][k]+dp2[N^1][j][k])%MOD;\\n                    dp4[N][j][k] = (dp4[N^1][j][k]+(k==id?dp3[N^1][j][k]:0))%MOD;\\n                    res = (res+(j==id?dp4[N^1][j][k]:0))%MOD;\\n                }\\n            }\\n            N ^= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size(), res = 0, MOD = 1e9+7, N = 1;\\n        int dp1[2][10] = {}, dp2[2][10][10] = {}, dp3[2][10][10] = {}, dp4[2][10][10] = {};\\n        for(auto i : s){\\n            int id = i-\\'0\\';\\n            for(int j = 0; j < 10; j++){\\n                dp1[N][j] = (dp1[N^1][j]+(j==id))%MOD;\\n                for(int k = 0; k < 10; k++){\\n                    dp2[N][j][k] = (dp2[N^1][j][k]+(k==id?dp1[N^1][j]:0))%MOD;\\n                    dp3[N][j][k] = (dp3[N^1][j][k]+dp2[N^1][j][k])%MOD;\\n                    dp4[N][j][k] = (dp4[N^1][j][k]+(k==id?dp3[N^1][j][k]:0))%MOD;\\n                    res = (res+(j==id?dp4[N^1][j][k]:0))%MOD;\\n                }\\n            }\\n            N ^= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850627,
                "title": "c-pre-computation-dp-o-100n-explained",
                "content": "# Intuition\\n\\nThe goal is to find the number of palindromic subsequences having **length 5**, which is a constant.\\n\\nIt limits the number of combinations, and reduce the complexity to enumerate them.\\n\\n\\n# Approach\\n\\nWe can break down the problem into:\\nFor each index $i$, finding the number of palindromic subsequences whose center is $s[i]$.\\n\\nThe palindrome would be like: $[k, j, s[i], j, k]$, where $j$ and $k$ are digits.\\nSince there\\'is only $10$ different digits, the number of combinations of the palindrome is $10 \\\\times 10 = 100$.\\n\\nIf we can get the number of subsequence $[k, j]$ on the left side of $i$, and $[j, k]$ on the right side of $i$, then we get the number of palindromic subsequences whose center is $s[i]$.\\n\\nSo I pre-compute the following two lists, which can be done in $$O(n \\\\cdot 100)$$:\\n`dp_l[i][j][k]`: the number of subsequence $[j, k]$ on the left side of $i$.\\n`dp_r[i][j][k]`: the number of subsequence $[j, k]$ on the right side of $i$.\\n\\nand in my code I used `dp_l[i][j][10]` to store the number of `j` appear on the left side of $i$, which is useful to compute `dp_l[i][j][k]`, same as `dp_r`.\\n\\nFinally, we iterate all center $i$ to sum up the final answer.\\n\\n\\n# Complexity\\n\\n- Time complexity: $$O(n \\\\cdot 100)$$\\n- Space complexity: $$O(n \\\\cdot 100)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp_l[10005][10][11];\\n    long long dp_r[10005][10][11];\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        long long mod = 1000000007;\\n        if ( n < 5 ) return 0;\\n        // pre-compute dp_l[i][j][k] from left to right\\n        for ( int i=1; i<n; ++i ) {\\n            for ( int j=0; j<10; ++j ) {\\n                for ( int k=0; k<10; ++k ) {\\n                    dp_l[i][j][k] = dp_l[i-1][j][k];\\n                }\\n            }\\n            for ( int j=0; j<10; ++j ) dp_l[i][j][s[i-1]-\\'0\\'] += dp_l[i-1][j][10];\\n            for ( int j=0; j<10; ++j ) dp_l[i][j][10] = dp_l[i-1][j][10];\\n            dp_l[i][s[i-1]-\\'0\\'][10]++;\\n        }\\n        // pre-compute dp_r[i][j][k] from right to left\\n        for ( int i=n-2; i>=0; --i ) {\\n            for ( int j=0; j<10; ++j ) {\\n                for ( int k=0; k<10; ++k ) {\\n                    dp_r[i][j][k] = dp_r[i+1][j][k];\\n                }\\n            }\\n            for ( int j=0; j<10; ++j ) dp_r[i][s[i+1]-\\'0\\'][j] += dp_r[i+1][j][10];\\n            for ( int j=0; j<10; ++j ) dp_r[i][j][10] = dp_r[i+1][j][10];\\n            dp_r[i][s[i+1]-\\'0\\'][10]++;\\n        }\\n        // compute final answer\\n        long long ans = 0;\\n        for ( int i=2; i<n-2; ++i ) {\\n            for ( int j=0; j<10; ++j ) {\\n                for ( int k=0; k<10; ++k ) {\\n                    ans = (ans + dp_l[i][j][k]*dp_r[i][k][j]%mod) % mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp_l[10005][10][11];\\n    long long dp_r[10005][10][11];\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        long long mod = 1000000007;\\n        if ( n < 5 ) return 0;\\n        // pre-compute dp_l[i][j][k] from left to right\\n        for ( int i=1; i<n; ++i ) {\\n            for ( int j=0; j<10; ++j ) {\\n                for ( int k=0; k<10; ++k ) {\\n                    dp_l[i][j][k] = dp_l[i-1][j][k];\\n                }\\n            }\\n            for ( int j=0; j<10; ++j ) dp_l[i][j][s[i-1]-\\'0\\'] += dp_l[i-1][j][10];\\n            for ( int j=0; j<10; ++j ) dp_l[i][j][10] = dp_l[i-1][j][10];\\n            dp_l[i][s[i-1]-\\'0\\'][10]++;\\n        }\\n        // pre-compute dp_r[i][j][k] from right to left\\n        for ( int i=n-2; i>=0; --i ) {\\n            for ( int j=0; j<10; ++j ) {\\n                for ( int k=0; k<10; ++k ) {\\n                    dp_r[i][j][k] = dp_r[i+1][j][k];\\n                }\\n            }\\n            for ( int j=0; j<10; ++j ) dp_r[i][s[i+1]-\\'0\\'][j] += dp_r[i+1][j][10];\\n            for ( int j=0; j<10; ++j ) dp_r[i][j][10] = dp_r[i+1][j][10];\\n            dp_r[i][s[i+1]-\\'0\\'][10]++;\\n        }\\n        // compute final answer\\n        long long ans = 0;\\n        for ( int i=2; i<n-2; ++i ) {\\n            for ( int j=0; j<10; ++j ) {\\n                for ( int k=0; k<10; ++k ) {\\n                    ans = (ans + dp_l[i][j][k]*dp_r[i][k][j]%mod) % mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851196,
                "title": "2d-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.find out all the possible palindromic string of length 5.\\n2. cnt  the no of ways to make this string as a subsequences in original string s.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n-  1e4* 100* 10\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(string &temp,string &s)\\n    {\\n        int n=s.size();\\n        int m=temp.size();\\n        int dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0][0]=1;\\n        int mod=1e9+7;\\n        for(int i=0;i<=n;i++)dp[i][0]=1;\\n          for(int i=1;i<=n;i++)\\n          {\\n              for(int j=1;j<=m;j++)\\n              {\\n                  if(s[i-1]==temp[j-1])\\n                  {\\n                      dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%mod;\\n                  }\\n                  else dp[i][j]=dp[i-1][j];\\n              }\\n          }\\n        return dp[n][m];\\n        \\n    }\\n    int countPalindromes(string s) {\\n        int ans=0;\\n        int mod=1e9+7;\\n      for(int i=0;i<=99;i++)\\n      {\\n           string temp=\"\";\\n           if(i<=9){temp+=\\'0\\';\\n           temp+=(i+\\'0\\');\\n                   }\\n          else temp=to_string(i);\\n          string org=temp;\\n          for(int j=0;j<=9;j++)\\n          {   temp+=(j+\\'0\\');\\n           string temp2=org;\\n           reverse(temp2.begin(),temp2.end());\\n             temp+=temp2;\\n              int val=rec(temp,s);\\n               ans=(ans+ val)%mod;\\n            // if(val>0)\\n            //   cout<<temp<<\" \"<<val<<endl;\\n             temp=org;\\n          }\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(string &temp,string &s)\\n    {\\n        int n=s.size();\\n        int m=temp.size();\\n        int dp[n+1][m+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[0][0]=1;\\n        int mod=1e9+7;\\n        for(int i=0;i<=n;i++)dp[i][0]=1;\\n          for(int i=1;i<=n;i++)\\n          {\\n              for(int j=1;j<=m;j++)\\n              {\\n                  if(s[i-1]==temp[j-1])\\n                  {\\n                      dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%mod;\\n                  }\\n                  else dp[i][j]=dp[i-1][j];\\n              }\\n          }\\n        return dp[n][m];\\n        \\n    }\\n    int countPalindromes(string s) {\\n        int ans=0;\\n        int mod=1e9+7;\\n      for(int i=0;i<=99;i++)\\n      {\\n           string temp=\"\";\\n           if(i<=9){temp+=\\'0\\';\\n           temp+=(i+\\'0\\');\\n                   }\\n          else temp=to_string(i);\\n          string org=temp;\\n          for(int j=0;j<=9;j++)\\n          {   temp+=(j+\\'0\\');\\n           string temp2=org;\\n           reverse(temp2.begin(),temp2.end());\\n             temp+=temp2;\\n              int val=rec(temp,s);\\n               ans=(ans+ val)%mod;\\n            // if(val>0)\\n            //   cout<<temp<<\" \"<<val<<endl;\\n             temp=org;\\n          }\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2850434,
                "title": "python3-counting",
                "content": "**Biweekly Contest 92 Submission**\\n\\n**Counting**\\n\\n**Intuition**\\n\\nSince 5 is an odd length each *palindromic subsequences* must have a single middle element (\\'3\\' in the case of \"10301\"). Each *palindromic subsequences* must also have an ordered pair prior to a middle element with a mirrored ordered pair after (\"10\", \"01\" in the case of \"10301\"). The idea of this solution is to count the number of ordered pairs that mirror before and after each middle index (`index \\u2208 [2, len(S) - 2)`).\\n\\n**Algorithm**\\n1. If the length of the input string `S` is less than 5 no strings can be built of length 5 (return 0).\\n2. Get the number of ordered pairs before and after each index.\\n3. Count the number of matching pairs before and after each index. There are only 10 possible digits to loop through for each pair addition resulting in a global linear runtime.\\n4. Return the value calculated modulo `10^9 + 7`.\\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def countPalindromes(self, S: str) -> int:\\n        #Ignore string less than 5 characters (cannot have a 5 length substring)\\n        if len(S) < 5:\\n            return 0\\n        \\n        #Returns the running pair counts for each index\\n        def get_pairs(s):\\n            seen_cnt = {str(num):0 for num in range(10)}\\n            seen_cnt[s[0]] = 1 #We have seen the first character since we start the loop at 1\\n            pair_cnts = defaultdict(int)\\n            res = [None] #Filler empty dict (index = 0 / end index)\\n            \\n            #Getting running pairs\\n            for idx in range(1, len(s) - 1):\\n                res.append(pair_cnts.copy()) #Append running pair counts\\n                for num in seen_cnt.keys():\\n                    pair_cnts[(num, s[idx])] += seen_cnt[num]\\n                seen_cnt[s[idx]] += 1\\n                \\n            #Filler empty dict (index = 0 / end index)\\n            res.append(None)\\n            \\n            return res\\n        \\n        res = 0\\n        #Getting post and pre pair counts\\n        pre, post = get_pairs(S), get_pairs(S[::-1])[::-1]\\n        \\n        #Check all possible middle characters -> S[2, len(S) - 2)\\n        for idx in range(2, len(S) - 2):\\n            for key, val in pre[idx].items():\\n                if key in post[idx]:\\n                    res += post[idx][key] * val #Total pairs per key\\n                    res %= 1000000007\\n                    \\n        return res             \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def countPalindromes(self, S: str) -> int:\\n        #Ignore string less than 5 characters (cannot have a 5 length substring)\\n        if len(S) < 5:\\n            return 0\\n        \\n        #Returns the running pair counts for each index\\n        def get_pairs(s):\\n            seen_cnt = {str(num):0 for num in range(10)}\\n            seen_cnt[s[0]] = 1 #We have seen the first character since we start the loop at 1\\n            pair_cnts = defaultdict(int)\\n            res = [None] #Filler empty dict (index = 0 / end index)\\n            \\n            #Getting running pairs\\n            for idx in range(1, len(s) - 1):\\n                res.append(pair_cnts.copy()) #Append running pair counts\\n                for num in seen_cnt.keys():\\n                    pair_cnts[(num, s[idx])] += seen_cnt[num]\\n                seen_cnt[s[idx]] += 1\\n                \\n            #Filler empty dict (index = 0 / end index)\\n            res.append(None)\\n            \\n            return res\\n        \\n        res = 0\\n        #Getting post and pre pair counts\\n        pre, post = get_pairs(S), get_pairs(S[::-1])[::-1]\\n        \\n        #Check all possible middle characters -> S[2, len(S) - 2)\\n        for idx in range(2, len(S) - 2):\\n            for key, val in pre[idx].items():\\n                if key in post[idx]:\\n                    res += post[idx][key] * val #Total pairs per key\\n                    res %= 1000000007\\n                    \\n        return res             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851748,
                "title": "python-3-13-lines-dp-t-m-918ms-13-8mb",
                "content": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n\\n        ans = 0\\n        for n in range(100):\\n\\n            dp=[0,0,0,0,0,1]\\n\\n            x = str(n).rjust(2,\\'0\\')\\n            mask =  x+\\'$\\'+x[1]+x[0]\\n\\n            for ch in s:\\n\\n                if ch==mask[0]: dp[0]+=dp[1]\\n                if ch==mask[1]: dp[1]+=dp[2]\\n                dp[2]+=dp[3]\\n                if ch==mask[3]: dp[3]+=dp[4]\\n                if ch==mask[4]: dp[4]+=dp[5]\\n\\n            ans+= dp[0]\\n\\n        return ans%1000000007\\n```\\n[https://leetcode.com/submissions/detail/850365441/](http://)\\n\\n\\n\\n\\n\\n\\nI could be wrong, but I think it\\'s T: *O*(*N*) S: *O*(*N*).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n\\n        ans = 0\\n        for n in range(100):\\n\\n            dp=[0,0,0,0,0,1]\\n\\n            x = str(n).rjust(2,\\'0\\')\\n            mask =  x+\\'$\\'+x[1]+x[0]\\n\\n            for ch in s:\\n\\n                if ch==mask[0]: dp[0]+=dp[1]\\n                if ch==mask[1]: dp[1]+=dp[2]\\n                dp[2]+=dp[3]\\n                if ch==mask[3]: dp[3]+=dp[4]\\n                if ch==mask[4]: dp[4]+=dp[5]\\n\\n            ans+= dp[0]\\n\\n        return ans%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850833,
                "title": "c-4-d-dp-top-down-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t// <index, length, first_num, second_num>\\n    int dp[10001][6][10][10];\\n    int MOD = 1e9+7;\\n\\t\\n    int topDown(int i, int len, int a, int b, string &s){\\n        if(len == 5){\\n            return 1;\\n        }\\n        \\n        if(5-len > s.size()-i){\\n            return 0;\\n        }\\n        \\n        if(dp[i][len][a][b] != -1){\\n            return dp[i][len][a][b];\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// First number in the palindrome\\n        if(len == 0){\\n            ans = (ans + topDown(i+1, len+1, s[i]-\\'0\\', b, s))%MOD;\\n        }\\n\\t\\t// Second number in the palindrome\\n        else if(len == 1){\\n            ans = (ans + topDown(i+1, len+1, a, s[i]-\\'0\\', s))%MOD;\\n        }\\n\\t\\t// Third number in the palindrome\\n        else if(len == 2){\\n            ans = (ans + topDown(i+1, len+1, a, b, s))%MOD;\\n        }\\n\\t\\t// Fourth number in the palindrome\\n        else if(len == 3){\\n            if(s[i]-\\'0\\' == b){\\n                ans = (ans + topDown(i+1, len+1, a, b, s))%MOD;\\n            }\\n        }\\n\\t\\t// Fifth number in the palindrome\\n        else if(len == 4){\\n            if(s[i]-\\'0\\' == a){\\n                ans = (ans + topDown(i+1, len+1, a, b, s))%MOD;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Not involving the current number\\n        ans = (ans + topDown(i+1, len, a, b, s))%MOD;\\n        return dp[i][len][a][b] = ans;\\n    }\\n    \\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return topDown(0, 0, 0, 0, s);\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl; \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// <index, length, first_num, second_num>\\n    int dp[10001][6][10][10];\\n    int MOD = 1e9+7;\\n\\t\\n    int topDown(int i, int len, int a, int b, string &s){\\n        if(len == 5){\\n            return 1;\\n        }\\n        \\n        if(5-len > s.size()-i){\\n            return 0;\\n        }\\n        \\n        if(dp[i][len][a][b] != -1){\\n            return dp[i][len][a][b];\\n        }\\n        \\n        int ans = 0;\\n\\t\\t// First number in the palindrome\\n        if(len == 0){\\n            ans = (ans + topDown(i+1, len+1, s[i]-\\'0\\', b, s))%MOD;\\n        }\\n\\t\\t// Second number in the palindrome\\n        else if(len == 1){\\n            ans = (ans + topDown(i+1, len+1, a, s[i]-\\'0\\', s))%MOD;\\n        }\\n\\t\\t// Third number in the palindrome\\n        else if(len == 2){\\n            ans = (ans + topDown(i+1, len+1, a, b, s))%MOD;\\n        }\\n\\t\\t// Fourth number in the palindrome\\n        else if(len == 3){\\n            if(s[i]-\\'0\\' == b){\\n                ans = (ans + topDown(i+1, len+1, a, b, s))%MOD;\\n            }\\n        }\\n\\t\\t// Fifth number in the palindrome\\n        else if(len == 4){\\n            if(s[i]-\\'0\\' == a){\\n                ans = (ans + topDown(i+1, len+1, a, b, s))%MOD;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Not involving the current number\\n        ans = (ans + topDown(i+1, len, a, b, s))%MOD;\\n        return dp[i][len][a][b] = ans;\\n    }\\n    \\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return topDown(0, 0, 0, 0, s);\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2850442,
                "title": "java-o-n-with-comments",
                "content": "```\\nclass Solution {\\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long totalCount = 0;\\n        \\n        // for palindromes of the form \"cd.dc\", we will check\\n        // every possible combination of \"cd\" from \"00\" to \"99\"\\n        for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n            for (char d = \\'0\\'; d <= \\'9\\'; d++) {\\n                \\n                // number of combinations of \"cd.\" up to each index (inclusive)\\n                long[] startCount = new long[n];\\n                \\n                // number of combinations of \"cd\"\\n                long cBeforeD = 0;\\n                \\n                // number of \"c\"\\n                long cCount = 0;\\n                \\n                // scan forwards to populate startCount\\n                for (int i = 0; i < n; i++) {\\n                    startCount[i] = cBeforeD;\\n                    \\n                    // use multiple if instead of if/else for when c == d\\n                    char ch = s.charAt(i);\\n                    if (ch == d) {\\n                        cBeforeD += cCount;\\n                    }\\n                    if (ch == c) {\\n                        cCount++;\\n                    }\\n                }\\n                \\n                // reset counts\\n                cBeforeD = 0;\\n                cCount = 0;\\n                \\n                // scan backwards to update totalCount, stop at i == 3\\n                // because startCount counts the first 3 characters \"cd.\"\\n                for (int i = n - 1; i >= 3; i--) {\\n                    char ch = s.charAt(i);\\n                    if (ch == d) {\\n                        cBeforeD += cCount;\\n                    }\\n                    if (ch == c) {\\n                        cCount++;\\n                    }\\n                    \\n                    // the update to totalCount is the number of combinations of \"dc\"\\n                    // encountered so far multiplied by the number of combinations\\n                    // of \"cd.\" up to index i - 1\\n                    totalCount = (totalCount + cBeforeD * startCount[i - 1]) % M;\\n                }\\n            }\\n        }\\n        \\n        return (int)totalCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long totalCount = 0;\\n        \\n        // for palindromes of the form \"cd.dc\", we will check\\n        // every possible combination of \"cd\" from \"00\" to \"99\"\\n        for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n            for (char d = \\'0\\'; d <= \\'9\\'; d++) {\\n                \\n                // number of combinations of \"cd.\" up to each index (inclusive)\\n                long[] startCount = new long[n];\\n                \\n                // number of combinations of \"cd\"\\n                long cBeforeD = 0;\\n                \\n                // number of \"c\"\\n                long cCount = 0;\\n                \\n                // scan forwards to populate startCount\\n                for (int i = 0; i < n; i++) {\\n                    startCount[i] = cBeforeD;\\n                    \\n                    // use multiple if instead of if/else for when c == d\\n                    char ch = s.charAt(i);\\n                    if (ch == d) {\\n                        cBeforeD += cCount;\\n                    }\\n                    if (ch == c) {\\n                        cCount++;\\n                    }\\n                }\\n                \\n                // reset counts\\n                cBeforeD = 0;\\n                cCount = 0;\\n                \\n                // scan backwards to update totalCount, stop at i == 3\\n                // because startCount counts the first 3 characters \"cd.\"\\n                for (int i = n - 1; i >= 3; i--) {\\n                    char ch = s.charAt(i);\\n                    if (ch == d) {\\n                        cBeforeD += cCount;\\n                    }\\n                    if (ch == c) {\\n                        cCount++;\\n                    }\\n                    \\n                    // the update to totalCount is the number of combinations of \"dc\"\\n                    // encountered so far multiplied by the number of combinations\\n                    // of \"cd.\" up to index i - 1\\n                    totalCount = (totalCount + cBeforeD * startCount[i - 1]) % M;\\n                }\\n            }\\n        }\\n        \\n        return (int)totalCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986951,
                "title": "simple-recursion-memoization-c",
                "content": "# Intuition\\nThe problem is to count the number of palindromic substrings in a given string. To solve this problem efficiently, the code uses dynamic programming to keep track of different states and their counts.\\n\\nThe dynamic programming approach involves breaking down the problem into smaller subproblems and reusing their solutions to avoid redundant computations. In this case, the subproblems are defined by the current index i, the count of characters processed cnt, and the last two characters used as first and second in forming a palindrome\\n\\n# Approach\\nThe dynamic programming approach involves breaking down the problem into smaller subproblems and reusing their solutions to avoid redundant computations. In this case, the subproblems are defined by the current index i, the count of characters processed cnt, and the last two characters used as first and second in forming a palindrome.\\n\\nThe dp array is used to store the results of these subproblems. Each entry dp[i][cnt][first+1][second+1] represents the count of palindromic substrings that can be formed given the current state (i, cnt, first, second).\\n\\nThe base case of the recursion is when i reaches the end of the string. If cnt is equal to 5 at this point, it means that all characters have been used to form a palindrome, and a valid palindromic substring has been found. Otherwise, no palindromic substring can be formed.\\n\\nFor the recursive cases, the code considers different scenarios based on the value of cnt and the characters at the current index i. It calculates the count of valid palindromic substrings by either extending an existing palindrome or starting a new palindrome with the current character. The results of these recursive cases are accumulated in variables x and y.\\n\\nThe key insight is that by using dynamic programming, the code avoids recalculating the same subproblem multiple times. Instead, it computes the solution for each subproblem only once and stores it in the dp array. This leads to significant efficiency gains compared to a naive recursive approach.\\n\\nIn summary, the code breaks down the problem of counting palindromic substrings into smaller subproblems, uses dynamic programming to store and reuse solutions to these subproblems, and carefully considers different scenarios to accurately calculate the count of palindromic substrings.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNumber of Unique Subproblems: O(1)\\nRecursion Depth: O(n)\\nWork per Subproblem: O(1)\\nConsidering the recursion depth is the main factor in determining the time complexity, the overall time complexity of the code is O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nDynamic Programming Array (dp): The size of the dp array is [10001][6][11][11], which is used to store the results of subproblems. Each entry in the array holds an integer value. Therefore, the space complexity contributed by the dp array is proportional to its dimensions, which is O(10001 * 6 * 11 * 11) = O(726726).\\n\\nRecursive Call Stack: The recursion depth in the recur function depends on the length of the input string n. In the worst case, the recursion depth could be as large as n, which contributes to the space complexity with an additional O(n) space for the call stack.\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int dp[10001][6][11][11];\\n    const int m=pow(10,9)+7;\\n    \\n    int recur(int i, int n, string &s, int cnt, int first, int second)\\n    {\\n        if (i == n)\\n        {\\n            return dp[i][cnt][first+1][second+1] = cnt == 5;\\n        }\\n\\n        if (dp[i][cnt][first+1][second+1] != -1)\\n        {\\n            return dp[i][cnt][first+1][second+1]%m;\\n        }\\n\\n        int x = recur(i + 1, n, s, cnt, first, second)%m;\\n        int y = 0;\\n\\n        if (cnt == 4 && s[i] - \\'0\\' == first)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, second)%m;\\n        }\\n\\n        if (cnt == 3 && s[i] - \\'0\\' == second)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, second)%m;\\n        }\\n\\n        if (cnt == 2)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, second)%m;\\n        }\\n\\n        if (cnt == 1)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, s[i] - \\'0\\')%m;\\n        }\\n\\n        if (cnt == 0)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, s[i] - \\'0\\', second)%m;\\n        }\\n\\n        return dp[i][cnt][first+1][second+1] = (x%m + y%m)%m;\\n    }\\n\\n    int countPalindromes(string s)\\n    {\\n        memset(dp, -1, sizeof dp);\\n        return recur(0, s.size(), s, 0, -1, -1)%m;\\n    }\\n};\\n\\nplease upvote if you like the solution.\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dp[10001][6][11][11];\\n    const int m=pow(10,9)+7;\\n    \\n    int recur(int i, int n, string &s, int cnt, int first, int second)\\n    {\\n        if (i == n)\\n        {\\n            return dp[i][cnt][first+1][second+1] = cnt == 5;\\n        }\\n\\n        if (dp[i][cnt][first+1][second+1] != -1)\\n        {\\n            return dp[i][cnt][first+1][second+1]%m;\\n        }\\n\\n        int x = recur(i + 1, n, s, cnt, first, second)%m;\\n        int y = 0;\\n\\n        if (cnt == 4 && s[i] - \\'0\\' == first)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, second)%m;\\n        }\\n\\n        if (cnt == 3 && s[i] - \\'0\\' == second)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, second)%m;\\n        }\\n\\n        if (cnt == 2)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, second)%m;\\n        }\\n\\n        if (cnt == 1)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, first, s[i] - \\'0\\')%m;\\n        }\\n\\n        if (cnt == 0)\\n        {\\n            y = recur(i + 1, n, s, cnt + 1, s[i] - \\'0\\', second)%m;\\n        }\\n\\n        return dp[i][cnt][first+1][second+1] = (x%m + y%m)%m;\\n    }\\n\\n    int countPalindromes(string s)\\n    {\\n        memset(dp, -1, sizeof dp);\\n        return recur(0, s.size(), s, 0, -1, -1)%m;\\n    }\\n};\\n\\nplease upvote if you like the solution.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850472,
                "title": "c-dp-solution-o-100-n",
                "content": "\\n**Explanation**\\n\\nWe have to count the total number of palindromic subsequences of length 5. Since it\\'s a palindrome we can ignore the middle digit as it can be any number from 0 to 9. Also, the first two digits and the reverse of last two digits has to be same.\\n\\nEx: s=\"10301\"\\n-> first two digits (10) and reverse of last two digits (10)\\n\\nNow, for every index i, the task is to find count1 and count2. \\ncount1 -> The count of two digit numbers till (i-1)th index in prefix.\\ncount2 -> The count of two digit numbers till (i+1)th index in suffix.\\n\\nA total of (count1 * count2) will be contributed by numbers(0 to 99) to the final result for each ith index.\\n\\nwe can precalcuate either count1 or count2 and calculate the answer in the second iteration.\\n\\nEx: 103301\\ntotal=0\\nat index 2, there is one \"10\" in the prefix and one \"01\" in the suffix. total =1 (1 * 1)\\nat index 3, there is one \"10\" in the prefix and one \"01\" in the suffix. total = 1 + 1 (1 * 1)\\n\\nIn total, there are 2 subsequences in the given string.\\n\\n**Complexity**\\nTime O(100 * N)\\nSpace O(100 * N)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countPalindromes(string s) {\\n        map<int,int> counter;\\n        int n=s.length(),mod=1e9+7;\\n        long long ans=0;\\n        \\n        //map is used to save the 2 digit subsequences count till ith index.\\n        unordered_map<int,long long> store[n];\\n        for(int i=0;i<n;i++){\\n            string temp;\\n            temp+=s[i];\\n            for(int j=0;j<10;j++){\\n                temp=to_string(j)+temp;\\n                store[i][stoi(temp)]+=counter[j];\\n                temp.erase(temp.begin());\\n            }\\n            \\n            counter[s[i]-\\'0\\']++;\\n            \\n            if(i>1){\\n                for(int j=0;j<100;j++)\\n                    store[i][j]+=store[i-1][j];\\n            }\\n            \\n        }\\n        \\n        counter.clear();\\n        \\n        //suffixCount map is used to save the 2 digit suffix subsequences count till ith index.\\n        map<string,long long> suffixCount;\\n        for(int i=n-1;i>=2;i--){\\n            string temp;\\n            temp+=s[i];\\n            for(int j=0;j<10;j++){\\n                temp+=to_string(j);\\n                suffixCount[temp]+=counter[j];\\n                temp.pop_back();\\n            }\\n            \\n            counter[s[i]-\\'0\\']++;\\n            \\n            for(auto key:suffixCount){\\n                string num=key.first;\\n                reverse(num.begin(),num.end());\\n                int numInt=stoi(num);\\n                ans=(ans+(key.second*store[i-2][numInt])%mod)%mod;\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countPalindromes(string s) {\\n        map<int,int> counter;\\n        int n=s.length(),mod=1e9+7;\\n        long long ans=0;\\n        \\n        //map is used to save the 2 digit subsequences count till ith index.\\n        unordered_map<int,long long> store[n];\\n        for(int i=0;i<n;i++){\\n            string temp;\\n            temp+=s[i];\\n            for(int j=0;j<10;j++){\\n                temp=to_string(j)+temp;\\n                store[i][stoi(temp)]+=counter[j];\\n                temp.erase(temp.begin());\\n            }\\n            \\n            counter[s[i]-\\'0\\']++;\\n            \\n            if(i>1){\\n                for(int j=0;j<100;j++)\\n                    store[i][j]+=store[i-1][j];\\n            }\\n            \\n        }\\n        \\n        counter.clear();\\n        \\n        //suffixCount map is used to save the 2 digit suffix subsequences count till ith index.\\n        map<string,long long> suffixCount;\\n        for(int i=n-1;i>=2;i--){\\n            string temp;\\n            temp+=s[i];\\n            for(int j=0;j<10;j++){\\n                temp+=to_string(j);\\n                suffixCount[temp]+=counter[j];\\n                temp.pop_back();\\n            }\\n            \\n            counter[s[i]-\\'0\\']++;\\n            \\n            for(auto key:suffixCount){\\n                string num=key.first;\\n                reverse(num.begin(),num.end());\\n                int numInt=stoi(num);\\n                ans=(ans+(key.second*store[i-2][numInt])%mod)%mod;\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887248,
                "title": "simple-dp-pattern-matching-c",
                "content": "May be the Time complexity is higher than other solutions provided but in this way we can convert this problem into well known dp problem (pattern matching). \\nThere are 100 possible ways to fill first two characters go through the 100 possible ways now form a string ab*ba (a,b be any two digits from 0 to 9) and count the number  of subsequences ab*ba in string s just like pattern matching\\nHere * represents any character  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int countPalindromes(string s) {\\n        int ans=0;\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                string t=to_string(i)+to_string(j)+\"*\"+to_string(j)+to_string(i);\\n                vector<vector<int>> dp(s.size()+1,vector<int>(6,0));\\n                for(int a=0;a<=s.size();a++) dp[a][0]=1;\\n                for(int a=1;a<=s.size();a++){\\n                    for(int b=1;b<=5;b++){\\n                        if(t[b-1]==\\'*\\'||s[a-1]==t[b-1]) dp[a][b]=(dp[a-1][b-1]+dp[a-1][b]*1LL)%mod;\\n                        else  dp[a][b]=dp[a-1][b];\\n                    }\\n                }\\n              \\n                ans=(ans+dp[s.size()][5])%mod;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int countPalindromes(string s) {\\n        int ans=0;\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                string t=to_string(i)+to_string(j)+\"*\"+to_string(j)+to_string(i);\\n                vector<vector<int>> dp(s.size()+1,vector<int>(6,0));\\n                for(int a=0;a<=s.size();a++) dp[a][0]=1;\\n                for(int a=1;a<=s.size();a++){\\n                    for(int b=1;b<=5;b++){\\n                        if(t[b-1]==\\'*\\'||s[a-1]==t[b-1]) dp[a][b]=(dp[a-1][b-1]+dp[a-1][b]*1LL)%mod;\\n                        else  dp[a][b]=dp[a-1][b];\\n                    }\\n                }\\n              \\n                ans=(ans+dp[s.size()][5])%mod;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885691,
                "title": "easy-clean-recursion-memoization-code",
                "content": "# Intuition:\\nRecursion, DP, Memoization\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor each elements we have choices take or not take and we have to take exactly 5 char from the strings such that they result in pallindrome so for first char we have choice to take any char from the string and same goes for the second and 3rd char for the 4th char it must be equal to the 2nd char and 5th char must be equal to the 1st char.\\nBase case: if len == 5 we have to return 1 else 0;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[10001][10][10][6];\\n    string ss;\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int rec(int pos, char f, char s, int len) {\\n        \\n        if(len == 5)\\n            return 1;\\n        \\n        if(pos < 0)\\n            return 0;\\n        \\n        if(dp[pos][f - \\'0\\'][s - \\'0\\'][len] != -1)\\n            return dp[pos][f - \\'0\\'][s - \\'0\\'][len];\\n        \\n        int ans = 0;\\n        if(len == 0)\\n            ans = rec(pos - 1, ss[pos], s, len + 1) % mod;\\n        else if(len == 1)\\n            ans = rec(pos - 1, f, ss[pos], len + 1) % mod;\\n        else if(len == 2)\\n            ans = rec(pos - 1, f, s, len + 1) %mod;\\n        else if(len == 3 && ss[pos] == s)\\n            ans = rec(pos - 1, f, s, len + 1) % mod;\\n        else if(len == 4 && ss[pos] == f)\\n            ans = rec(pos - 1, f, s, len + 1) % mod;\\n        \\n        (ans += rec(pos - 1, f, s, len)) %= mod;\\n        \\n        return dp[pos][f - \\'0\\'][s - \\'0\\'][len] = ans % mod;\\n    }\\n    int countPalindromes(string s1) {\\n        ss = s1;\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return rec(s1.size() - 1, \\'1\\', \\'1\\', 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[10001][10][10][6];\\n    string ss;\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int rec(int pos, char f, char s, int len) {\\n        \\n        if(len == 5)\\n            return 1;\\n        \\n        if(pos < 0)\\n            return 0;\\n        \\n        if(dp[pos][f - \\'0\\'][s - \\'0\\'][len] != -1)\\n            return dp[pos][f - \\'0\\'][s - \\'0\\'][len];\\n        \\n        int ans = 0;\\n        if(len == 0)\\n            ans = rec(pos - 1, ss[pos], s, len + 1) % mod;\\n        else if(len == 1)\\n            ans = rec(pos - 1, f, ss[pos], len + 1) % mod;\\n        else if(len == 2)\\n            ans = rec(pos - 1, f, s, len + 1) %mod;\\n        else if(len == 3 && ss[pos] == s)\\n            ans = rec(pos - 1, f, s, len + 1) % mod;\\n        else if(len == 4 && ss[pos] == f)\\n            ans = rec(pos - 1, f, s, len + 1) % mod;\\n        \\n        (ans += rec(pos - 1, f, s, len)) %= mod;\\n        \\n        return dp[pos][f - \\'0\\'][s - \\'0\\'][len] = ans % mod;\\n    }\\n    int countPalindromes(string s1) {\\n        ss = s1;\\n        memset(dp, -1, sizeof(dp));\\n        \\n        return rec(s1.size() - 1, \\'1\\', \\'1\\', 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851053,
                "title": "c-4d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[10001][10][10][6];\\n    long long mod = 1000000007;\\n    \\n    long long solve(string &s, long long idx, long long first, long long second, long long cnt){\\n        int n = s.size();\\n        if(idx == n){\\n            if(cnt == 5) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][first][second][cnt] != -1) return dp[idx][first][second][cnt];\\n        \\n        long long inc = 0, exc = 0, val = s[idx]-\\'0\\';\\n        if(cnt == 0){\\n            inc += solve(s, idx+1, val, second, cnt+1); \\n        }\\n        else if(cnt == 1){\\n            inc += solve(s, idx+1, first, val, cnt+1); \\n        }\\n        else if(cnt == 2){\\n            inc += solve(s, idx+1, first, second, cnt+1); \\n        }\\n        else if(cnt == 3){\\n            if(val == second) inc += solve(s, idx+1, first, second, cnt+1); \\n        }\\n        else if(cnt == 4){\\n            if(val == first) inc += solve(s, idx+1, first, second, cnt+1); \\n        }\\n        exc += solve(s, idx+1, first, second, cnt);\\n        return dp[idx][first][second][cnt] = (inc%mod+exc%mod)%mod;\\n    }\\n\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 0, 0, 0);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[10001][10][10][6];\\n    long long mod = 1000000007;\\n    \\n    long long solve(string &s, long long idx, long long first, long long second, long long cnt){\\n        int n = s.size();\\n        if(idx == n){\\n            if(cnt == 5) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][first][second][cnt] != -1) return dp[idx][first][second][cnt];\\n        \\n        long long inc = 0, exc = 0, val = s[idx]-\\'0\\';\\n        if(cnt == 0){\\n            inc += solve(s, idx+1, val, second, cnt+1); \\n        }\\n        else if(cnt == 1){\\n            inc += solve(s, idx+1, first, val, cnt+1); \\n        }\\n        else if(cnt == 2){\\n            inc += solve(s, idx+1, first, second, cnt+1); \\n        }\\n        else if(cnt == 3){\\n            if(val == second) inc += solve(s, idx+1, first, second, cnt+1); \\n        }\\n        else if(cnt == 4){\\n            if(val == first) inc += solve(s, idx+1, first, second, cnt+1); \\n        }\\n        exc += solve(s, idx+1, first, second, cnt);\\n        return dp[idx][first][second][cnt] = (inc%mod+exc%mod)%mod;\\n    }\\n\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850798,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long dp[10004][11][11][6];\\n    int find(string &s,int index,int first,int second,int count)\\n    {\\n        if(index>=s.size())\\n        {\\n            return count==5;\\n        }\\n        if(dp[index][first+1][second+1][count]!=-1)\\n        {\\n            return dp[index][first+1][second+1][count]%mod;\\n        }\\n        long long ans=find(s,index+1,first,second,count);\\n        if(count==0)\\n        {\\n            ans+=find(s,index+1,s[index]-\\'0\\',second,count+1);\\n        }\\n        if(count==1)\\n        {\\n            ans+=find(s,index+1,first,s[index]-\\'0\\',count+1);\\n        }\\n        if(count==2)\\n        {\\n            ans+=find(s,index+1,first,second,count+1);\\n        }\\n        if(count==3)\\n        {\\n            if((s[index]-\\'0\\')==second)\\n            {\\n                ans+=find(s,index+1,first,second,count+1);\\n            }\\n        }\\n        if(count==4)\\n        {\\n            if((s[index]-\\'0\\')==first)\\n            {\\n                ans+=find(s,index+1,first,second,count+1);\\n            }\\n        }\\n        return dp[index][first+1][second+1][count]= ans%mod;\\n        \\n    }\\n    int countPalindromes(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(s,0,-1,-1,0)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long dp[10004][11][11][6];\\n    int find(string &s,int index,int first,int second,int count)\\n    {\\n        if(index>=s.size())\\n        {\\n            return count==5;\\n        }\\n        if(dp[index][first+1][second+1][count]!=-1)\\n        {\\n            return dp[index][first+1][second+1][count]%mod;\\n        }\\n        long long ans=find(s,index+1,first,second,count);\\n        if(count==0)\\n        {\\n            ans+=find(s,index+1,s[index]-\\'0\\',second,count+1);\\n        }\\n        if(count==1)\\n        {\\n            ans+=find(s,index+1,first,s[index]-\\'0\\',count+1);\\n        }\\n        if(count==2)\\n        {\\n            ans+=find(s,index+1,first,second,count+1);\\n        }\\n        if(count==3)\\n        {\\n            if((s[index]-\\'0\\')==second)\\n            {\\n                ans+=find(s,index+1,first,second,count+1);\\n            }\\n        }\\n        if(count==4)\\n        {\\n            if((s[index]-\\'0\\')==first)\\n            {\\n                ans+=find(s,index+1,first,second,count+1);\\n            }\\n        }\\n        return dp[index][first+1][second+1][count]= ans%mod;\\n        \\n    }\\n    int countPalindromes(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(s,0,-1,-1,0)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097976,
                "title": "prefix-sum-dp-clean-c-with-expalination",
                "content": "Here is the key idea:\\n1 For a Palindrome with length 5, it must be [00-99][pivot][00-99] format, so we can conisder for each  pivot index, count the number we can get [00-99] on the left and right, and take all the conminations together.\\n2  To get the frequency of [00-99], we can use a prefix sum like approach. For the digits \\'d\\' in the current index, it will increase the frequency[xd] by frequency[x] before current index. So we also need to calculate the prefix sum of single digit frequency.\\n3 Time and space complexity is O(100N),  the space complexity can be improved but I think the idea is clear. \\n\\n\\tclass Solution {\\n\\t\\tint64_t mod = 1e9 + 7;\\n\\tpublic:\\n\\t\\tint countPalindromes(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\t// count for each single digit (0-9), how many do we have on the left side\\n\\t\\t\\tvector<vector<int64_t>> one_digits_left(10,vector<int64_t>(n+1,0));\\n\\t\\t\\t// count for each two digits (00-99), how many do we have on the left side\\n\\t\\t\\tvector<vector<int64_t>> two_digits_left(100,vector<int64_t>(n+1,0));\\n\\t\\t\\tfor(int i = 1; i <= n; i++){\\n\\t\\t\\t\\tint cur = s[i-1] - \\'0\\';\\n\\t\\t\\t\\tfor(int d = 0; d < 10; d++){\\n\\t\\t\\t\\t\\tone_digits_left[d][i] = one_digits_left[d][i-1];\\n\\t\\t\\t\\t\\tif(cur == d) one_digits_left[d][i]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int dd = 0; dd < 100; dd++){\\n\\t\\t\\t\\t\\tint ld = dd / 10;\\n\\t\\t\\t\\t\\tint rd = dd % 10;\\n\\t\\t\\t\\t\\ttwo_digits_left[dd][i] = two_digits_left[dd][i-1];\\n\\t\\t\\t\\t\\tif(rd == cur){\\n\\t\\t\\t\\t\\t\\ttwo_digits_left[dd][i] += one_digits_left[ld][i-1];\\n\\t\\t\\t\\t\\t\\ttwo_digits_left[dd][i] %= mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// count for each single digit (0-9), how many do we have on the right side\\n\\t\\t\\tvector<vector<int64_t>> one_digits_right(10,vector<int64_t>(n+1,0));\\n\\t\\t\\t// count for each two digits (00-99), how many do we have on the right side\\n\\t\\t\\tvector<vector<int64_t>> two_digits_right(100,vector<int64_t>(n+1,0));\\n\\t\\t\\tfor(int i = 1; i <= n; i++){\\n\\t\\t\\t\\tint cur = s[n - i] - \\'0\\';\\n\\t\\t\\t\\tfor(int d = 0; d < 10; d++){\\n\\t\\t\\t\\t\\tone_digits_right[d][i] = one_digits_right[d][i-1];\\n\\t\\t\\t\\t\\tif(cur == d) one_digits_right[d][i]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int dd = 0; dd < 100; dd++){\\n\\t\\t\\t\\t\\tint ld = dd / 10;\\n\\t\\t\\t\\t\\tint rd = dd % 10;\\n\\t\\t\\t\\t\\ttwo_digits_right[dd][i] = two_digits_right[dd][i-1];\\n\\t\\t\\t\\t\\tif(rd == cur){\\n\\t\\t\\t\\t\\t\\ttwo_digits_right[dd][i] += one_digits_right[ld][i-1];\\n\\t\\t\\t\\t\\t\\ttwo_digits_right[dd][i] %= mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// For each index, count every two digits (00-99) on its left and right, then take the combination\\n\\t\\t\\tint64_t res = 0;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tfor(int k = 0; k < 100; k++){\\n\\t\\t\\t\\t\\tint64_t left = two_digits_left[k][i];\\n\\t\\t\\t\\t\\tint64_t right = two_digits_right[k][n - 1 - i];\\n\\t\\t\\t\\t\\tres += left * right;\\n\\t\\t\\t\\t\\tres %= mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\t\\tint64_t mod = 1e9 + 7;\\n\\tpublic:\\n\\t\\tint countPalindromes(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\t// count for each single digit (0-9), how many do we have on the left side\\n\\t\\t\\tvector<vector<int64_t>> one_digits_left(10,vector<int64_t>(n+1,0));\\n\\t\\t\\t// count for each two digits (00-99), how many do we have on the left side\\n\\t\\t\\tvector<vector<int64_t>> two_digits_left(100,vector<int64_t>(n+1,0));\\n\\t\\t\\tfor(int i = 1; i <= n; i++){\\n\\t\\t\\t\\tint cur = s[i-1] - \\'0\\';\\n\\t\\t\\t\\tfor(int d = 0; d < 10; d++){\\n\\t\\t\\t\\t\\tone_digits_left[d][i] = one_digits_left[d][i-1];\\n\\t\\t\\t\\t\\tif(cur == d) one_digits_left[d][i]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2853892,
                "title": "time-o-10n-space-o-1-counting-the-increase-decrease-of-prefix-postfix",
                "content": "# Intuition\\nThe length is 5, so we need to count things like \"AB C BA\". Once the middle is determined, we just need to count subsequence \"AB\" for the prefix and \"BA\" for the postfix.\\n\\nFrom many posts, we can see approaches based on counting prefix and postfix. But, we don\\'t think it is a good way to precomputing everything and store (i.e. at least 100N w.r.t time and 10000N w.r.t space). \\n\\nStep by step, we move the middle from right of left (or left to right). Not every counter needs to be updated. For example, suppose that now \"5\" is the new middle, and \"4\" is the old middle (i.e \"##54##\"). For the prefix, count of \"05\", \"15\" .. \"95\" should decrease. For the postfix, count of \"40\", ..., \"49\" should increase.\\n \\nAs a result, we prefer to focus on the change of prefix and postfix, which will lead to 10N for time.\\n\\n# Approach\\nLet\\'s consider one example, s=\"0000000\".\\n\\nInitialization: We divide s as \"00000 0 0\".\\nFor the left part \"00000\", count of \"00\" is A[0][0]=10, count of \"0\" is A[0]=5;\\nFor the right part \"0\", count of \"00\" is B[0][0]=0, count of \"0\" is B[0]=1;\\nAnd, M=0 is number of match prefix and postfix.\\n\\nStep 1: We divide s as \"0000 0 00\".\\nFor the left part:A[0]-=1, A[0][0]-=A[0], M-= A[0] * B[0][0]\\nFor the righ part, B[0][0]+=B[0], M+= A[0][0] * B[0], B[0]+=1\\nA[0]=4, A[0][0]=6, B[0][0]=1, M=6, B[0]=2 | sum=6\\n\\nStep 2: We divide s as \"000 0 000\".\\nA[0]=3, A[0][0]=3, B[0][0]=3, M=9, B[0]=3 | sum=15\\n\\nStep 3: We divide s as \"00 0 0000\".\\nA[0]=2, A[0][0]=1, B[0][0]=6, M=6, B[0]=3 | sum=21\\n\\n# Complexity\\n- Time complexity: O(N) or O(10N)\\n- Space complexity: O(1) or O(100)\\n\\n# Code\\n```\\n/*\\nRuntime: 8 ms, faster than 100.00% of C++ online submissions for Count Palindromic Subsequences.\\nMemory Usage: 6.4 MB, less than 100.00% of C++ online submissions for Count Palindromic Subsequences.\\n*/\\n\\nlong A[10][11];//prefix \\nlong B[10][11];//postfix\\nlong M=1e9+7;\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=s.size();\\n        if(n<5)\\n            return 0;\\n        long sum=0, cnt=0;\\n        const char * c=s.c_str();\\n        for(int i=0, j; i<10; ++i) {\\n            for(j=0; j<11; ++j) {\\n                A[i][j]=B[i][j]=0;\\n            }\\n        }\\n        for(int i=0, j, k; i<=n-3; ++i) {\\n            k=c[i]-\\'0\\';\\n            for(j=0; j<10; ++j) {\\n                A[k][j]+=A[j][10];\\n            }\\n            ++A[k][10];//count of single k\\n        }\\n        B[c[n-1]-\\'0\\'][10]=1;\\n        for(int i=n-2, j, k; i>=2; --i) {\\n            //minus\\n            k=c[i-1]-\\'0\\';\\n            --A[k][10];\\n            for(j=0; j<10; ++j) {\\n                A[k][j]-=A[j][10];\\n                cnt-=A[j][10]*B[k][j];\\n            }\\n            //add\\n            k=c[i]-\\'0\\';\\n            for(j=0; j<10; ++j) {\\n                B[k][j]+=B[j][10];\\n                cnt+=A[k][j]*B[j][10];\\n            }\\n            ++B[k][10];\\n            cnt=(cnt+M)%M;\\n            sum=(sum+cnt)%M;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n/*\\nRuntime: 8 ms, faster than 100.00% of C++ online submissions for Count Palindromic Subsequences.\\nMemory Usage: 6.4 MB, less than 100.00% of C++ online submissions for Count Palindromic Subsequences.\\n*/\\n\\nlong A[10][11];//prefix \\nlong B[10][11];//postfix\\nlong M=1e9+7;\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=s.size();\\n        if(n<5)\\n            return 0;\\n        long sum=0, cnt=0;\\n        const char * c=s.c_str();\\n        for(int i=0, j; i<10; ++i) {\\n            for(j=0; j<11; ++j) {\\n                A[i][j]=B[i][j]=0;\\n            }\\n        }\\n        for(int i=0, j, k; i<=n-3; ++i) {\\n            k=c[i]-\\'0\\';\\n            for(j=0; j<10; ++j) {\\n                A[k][j]+=A[j][10];\\n            }\\n            ++A[k][10];//count of single k\\n        }\\n        B[c[n-1]-\\'0\\'][10]=1;\\n        for(int i=n-2, j, k; i>=2; --i) {\\n            //minus\\n            k=c[i-1]-\\'0\\';\\n            --A[k][10];\\n            for(j=0; j<10; ++j) {\\n                A[k][j]-=A[j][10];\\n                cnt-=A[j][10]*B[k][j];\\n            }\\n            //add\\n            k=c[i]-\\'0\\';\\n            for(j=0; j<10; ++j) {\\n                B[k][j]+=B[j][10];\\n                cnt+=A[k][j]*B[j][10];\\n            }\\n            ++B[k][10];\\n            cnt=(cnt+M)%M;\\n            sum=(sum+cnt)%M;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853126,
                "title": "python-clear-and-short-o-n-solution-counter-of-2-char-string-on-the-left-and-right",
                "content": "For each index i as the middle of 5-length Palindromic, the answer will be added with the product of number of 2-char string on the left and its reversed on the right.\\n\\n```\\nLet us take \\'103301\\' as an exmaple, note we only need to consider index 2 and 3.\\nWith index 2 as middle, left = {\\'10\\':1}, right = {\\'30\\':1, \\'31\\':1, \\'01\\':1}\\n\\tans += left[\\'10\\']*right[\\'01\\']\\nWith index 3 as middle, left = {\\'10\\':1, \\'13\\':1, \\'03\\':1}, right = {\\'01\\':1}\\n\\tans += left[\\'10\\']*right[\\'01\\']\\n```\\nThe following will explain how to efficient get the number of 2-char string in **O(N) time**.\\nTo achieve this, we also need to maintain 1-char Counter and 2-char Counter in rolling fashion.\\nWith current char-c, the 1-char Counter will decrease by 1.\\nThen it will result in the 2-char string of \\'cx\\' with the frequency of the char-x in 1-char Counter. \\n```\\nLet us take \\'3301\\' as an exmaple about calculate 2-char frequency.\\ncnter1 = {\\'3\\':2, \\'0\\':1, \\'1\\':1} - 1-char Counter\\ncnter2 = {} - 2-char Counter\\nWith index 0 and char \\'3\\':\\ncnter1 = {\\'3\\':1, \\'0\\':1, \\'1\\':1}, cnter2 = {\\'33\\':1, \\'30\\':1, \\'31\\':1}\\nWith index 1 and char \\'3\\':\\ncnter1 = {\\'0\\':1, \\'1\\':1}, cnter2 = {\\'33\\':1, \\'30\\':2, \\'31\\':1}\\nWith index 2 and char \\'0\\':\\ncnter1 = {\\'1\\':1}, cnter2 = {\\'33\\':1, \\'30\\':2, \\'31\\':1, \\'01\\':1}\\n```\\nYou can see that only 10 possible candidates in each iteration.\\nSo it will cost O(10N) time ~ **O(N)**\\nThe following is full of the implementation based on the previous algorithm\\n```\\ndef countPalindromes(self, s: str) -> int:\\n\\tleft1, left2 = Counter(s[:2]), Counter([s[:2]])  #1-char Counter, 2-char Counter\\n\\tright1, right2 = Counter(s[2:]), Counter()\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tright1[s[i]] -= 1\\n\\t\\tfor n in right1:\\n\\t\\t\\tright2[s[i]+n] += right1[n]  # pre-cache 2-char candidates on the right\\n\\tright1, ans, mod = Counter(s[2:]), 0, 10**9+7\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tright1[s[i]] -= 1\\n\\t\\tfor n in right1:\\n\\t\\t\\tright2[s[i]+n] -= right1[n]            \\n\\t\\tfor xy in left2:\\n\\t\\t\\tans = (ans+left2[xy]*right2[xy[::-1]]) % mod\\n\\t\\tfor n in left1:\\n\\t\\t\\tleft2[n+s[i]] += left1[n]\\n\\t\\tleft1[s[i]] += 1\\n\\n\\treturn ans\\n```\\nTime: O(100N)~O(N)\\nSpace: O(100N)~O(N)",
                "solutionTags": [],
                "code": "```\\nLet us take \\'103301\\' as an exmaple, note we only need to consider index 2 and 3.\\nWith index 2 as middle, left = {\\'10\\':1}, right = {\\'30\\':1, \\'31\\':1, \\'01\\':1}\\n\\tans += left[\\'10\\']*right[\\'01\\']\\nWith index 3 as middle, left = {\\'10\\':1, \\'13\\':1, \\'03\\':1}, right = {\\'01\\':1}\\n\\tans += left[\\'10\\']*right[\\'01\\']\\n```\n```\\nLet us take \\'3301\\' as an exmaple about calculate 2-char frequency.\\ncnter1 = {\\'3\\':2, \\'0\\':1, \\'1\\':1} - 1-char Counter\\ncnter2 = {} - 2-char Counter\\nWith index 0 and char \\'3\\':\\ncnter1 = {\\'3\\':1, \\'0\\':1, \\'1\\':1}, cnter2 = {\\'33\\':1, \\'30\\':1, \\'31\\':1}\\nWith index 1 and char \\'3\\':\\ncnter1 = {\\'0\\':1, \\'1\\':1}, cnter2 = {\\'33\\':1, \\'30\\':2, \\'31\\':1}\\nWith index 2 and char \\'0\\':\\ncnter1 = {\\'1\\':1}, cnter2 = {\\'33\\':1, \\'30\\':2, \\'31\\':1, \\'01\\':1}\\n```\n```\\ndef countPalindromes(self, s: str) -> int:\\n\\tleft1, left2 = Counter(s[:2]), Counter([s[:2]])  #1-char Counter, 2-char Counter\\n\\tright1, right2 = Counter(s[2:]), Counter()\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tright1[s[i]] -= 1\\n\\t\\tfor n in right1:\\n\\t\\t\\tright2[s[i]+n] += right1[n]  # pre-cache 2-char candidates on the right\\n\\tright1, ans, mod = Counter(s[2:]), 0, 10**9+7\\n\\tfor i in range(2, len(s)-1):\\n\\t\\tright1[s[i]] -= 1\\n\\t\\tfor n in right1:\\n\\t\\t\\tright2[s[i]+n] -= right1[n]            \\n\\t\\tfor xy in left2:\\n\\t\\t\\tans = (ans+left2[xy]*right2[xy[::-1]]) % mod\\n\\t\\tfor n in left1:\\n\\t\\t\\tleft2[n+s[i]] += left1[n]\\n\\t\\tleft1[s[i]] += 1\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2850576,
                "title": "2d-dp-c-o-n-100",
                "content": "# Code\\n```\\n#define ll long long int\\nclass Solution {\\n    int MOD = 1e9 + 7;\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        \\n        vector<int> freq(10, 0);\\n        vector<vector<int>> right(n, vector<int>(100)), left(n, vector<int>(100));\\n        \\n        // Calculating number of subsequences from 0 to 99 till index i from left\\n        freq[s[0] - \\'0\\']++;\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < 10; j++){\\n                int num = j * 10 + (int)(s[i] - \\'0\\');\\n                left[i][num] = (freq[j]) % MOD;\\n            }\\n            for(int j = 0; j < 100; j++){\\n                left[i][j] = (left[i][j] + left[i - 1][j]) % MOD;\\n            }\\n            freq[s[i] - \\'0\\']++;\\n        }\\n        \\n        // Calculating number of subsequences from 0 to 99 till index i from right\\n        freq = vector<int>(10, 0);\\n        freq[s[n - 1] - \\'0\\']++;\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 0; j < 10; j++){\\n                int num = (int)(s[i] - \\'0\\') * 10 + j;\\n                right[i][num] = (freq[j]) % MOD;\\n            }\\n            for(int j = 0; j < 100; j++){\\n                right[i][j] = (right[i][j] + right[i + 1][j]) % MOD;\\n            }\\n            freq[s[i] - \\'0\\']++;\\n        }\\n        \\n        // As the size of the palindrome should be 5, therefore the \\n        // middle character will range from {2, N - 3}\\n        // Now we calculate for every subsequence num {0, 99} by \\n        // multiplying number of subsequences in left till i - 1 and \\n        // number of subsequences from right till i + 1 which we already calculated  \\n        int ans = 0;\\n        for(int i = 2; i < n - 2; i++){\\n            for(int leftNum = 0; leftNum < 100; leftNum++){\\n                int rightNum = (leftNum % 10) * 10 + leftNum / 10;\\n                ll temp = ((ll)left[i - 1][leftNum] * (ll)right[i + 1][rightNum]) % MOD;\\n                ans = (ans + temp) % MOD;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    int MOD = 1e9 + 7;\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        \\n        vector<int> freq(10, 0);\\n        vector<vector<int>> right(n, vector<int>(100)), left(n, vector<int>(100));\\n        \\n        // Calculating number of subsequences from 0 to 99 till index i from left\\n        freq[s[0] - \\'0\\']++;\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < 10; j++){\\n                int num = j * 10 + (int)(s[i] - \\'0\\');\\n                left[i][num] = (freq[j]) % MOD;\\n            }\\n            for(int j = 0; j < 100; j++){\\n                left[i][j] = (left[i][j] + left[i - 1][j]) % MOD;\\n            }\\n            freq[s[i] - \\'0\\']++;\\n        }\\n        \\n        // Calculating number of subsequences from 0 to 99 till index i from right\\n        freq = vector<int>(10, 0);\\n        freq[s[n - 1] - \\'0\\']++;\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 0; j < 10; j++){\\n                int num = (int)(s[i] - \\'0\\') * 10 + j;\\n                right[i][num] = (freq[j]) % MOD;\\n            }\\n            for(int j = 0; j < 100; j++){\\n                right[i][j] = (right[i][j] + right[i + 1][j]) % MOD;\\n            }\\n            freq[s[i] - \\'0\\']++;\\n        }\\n        \\n        // As the size of the palindrome should be 5, therefore the \\n        // middle character will range from {2, N - 3}\\n        // Now we calculate for every subsequence num {0, 99} by \\n        // multiplying number of subsequences in left till i - 1 and \\n        // number of subsequences from right till i + 1 which we already calculated  \\n        int ans = 0;\\n        for(int i = 2; i < n - 2; i++){\\n            for(int leftNum = 0; leftNum < 100; leftNum++){\\n                int rightNum = (leftNum % 10) * 10 + leftNum / 10;\\n                ll temp = ((ll)left[i - 1][leftNum] * (ll)right[i + 1][rightNum]) % MOD;\\n                ans = (ans + temp) % MOD;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850562,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int pre[30009][12][12]; \\n    int nxt[30009][12][12];\\npublic:\\n    int countPalindromes(string s) {\\n        int n=s.size();\\n        vector<int>aa(12);\\n        for(int i=1;i<=n;i++) \\n        {\\n            aa[s[i-1]-\\'0\\']++;\\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    pre[i][j][k]=pre[i-1][j][k];\\n                }\\n            }\\n            for(int j=0;j<10;j++) \\n            {\\n                if(j==s[i-1]-\\'0\\') \\n                {\\n                    pre[i][j][j]++; \\n                    continue; \\n                }\\n                pre[i][j][s[i-1]-\\'0\\']+=aa[j]; \\n            }\\n        }\\n        for(auto &x: aa) x=0; \\n        for(int i=n;i>=1;i--)\\n        {\\n            aa[s[i-1]-\\'0\\']++; \\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    nxt[i][j][k]=nxt[i+1][j][k];\\n                }\\n            }\\n            for(int j=0;j<10;j++)\\n            {\\n                if(j==s[i-1]-\\'0\\')\\n                {\\n                    nxt[i][j][j]++; \\n                    continue; \\n                }\\n                nxt[i][s[i-1]-\\'0\\'][j]+=aa[j]; \\n            }\\n        }\\n        long long  ans=0; \\n        for(int i=2;i<n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    if(j==k) \\n                    {\\n                        long long a=pre[i-1][j][j]; \\n                        long long  b=nxt[i+1][j][j]; \\n                        a=a*(a-1)/2; \\n                        b=b*(b-1)/2; \\n                        ans+=(a*b) % mod; \\n                    }\\n                    else \\n                    {\\n                       // if(pre[i-1][j][k] and nxt[i+1][k][j] ) cout<<i<<\\' \\'<<j<<\\' \\'<<k<<\\' \\'<<pre[i-1][j][k]<<\\' \\'<<nxt[i+1][k][j]<<endl; \\n                        ans+=((long long )pre[i-1][j][k] * (long long )nxt[i+1][k][j]) % mod; \\n                    }\\n                    ans%=mod; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    int pre[30009][12][12]; \\n    int nxt[30009][12][12];\\npublic:\\n    int countPalindromes(string s) {\\n        int n=s.size();\\n        vector<int>aa(12);\\n        for(int i=1;i<=n;i++) \\n        {\\n            aa[s[i-1]-\\'0\\']++;\\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    pre[i][j][k]=pre[i-1][j][k];\\n                }\\n            }\\n            for(int j=0;j<10;j++) \\n            {\\n                if(j==s[i-1]-\\'0\\') \\n                {\\n                    pre[i][j][j]++; \\n                    continue; \\n                }\\n                pre[i][j][s[i-1]-\\'0\\']+=aa[j]; \\n            }\\n        }\\n        for(auto &x: aa) x=0; \\n        for(int i=n;i>=1;i--)\\n        {\\n            aa[s[i-1]-\\'0\\']++; \\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    nxt[i][j][k]=nxt[i+1][j][k];\\n                }\\n            }\\n            for(int j=0;j<10;j++)\\n            {\\n                if(j==s[i-1]-\\'0\\')\\n                {\\n                    nxt[i][j][j]++; \\n                    continue; \\n                }\\n                nxt[i][s[i-1]-\\'0\\'][j]+=aa[j]; \\n            }\\n        }\\n        long long  ans=0; \\n        for(int i=2;i<n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    if(j==k) \\n                    {\\n                        long long a=pre[i-1][j][j]; \\n                        long long  b=nxt[i+1][j][j]; \\n                        a=a*(a-1)/2; \\n                        b=b*(b-1)/2; \\n                        ans+=(a*b) % mod; \\n                    }\\n                    else \\n                    {\\n                       // if(pre[i-1][j][k] and nxt[i+1][k][j] ) cout<<i<<\\' \\'<<j<<\\' \\'<<k<<\\' \\'<<pre[i-1][j][k]<<\\' \\'<<nxt[i+1][k][j]<<endl; \\n                        ans+=((long long )pre[i-1][j][k] * (long long )nxt[i+1][k][j]) % mod; \\n                    }\\n                    ans%=mod; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4067755,
                "title": "easiest-to-understand-implement-approach-o-500-n-2d-dp-pattern-matching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPattern matching\\n# Complexity\\n- Time complexity:\\nO(500*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\nconst int mod = 1000000007;\\n\\nint solve(string &s, string &t, int i, int j, vector<vector<int>>& dp) {\\n    if (j == t.length()) {\\n        return 1;\\n    }\\n    if (i >= s.length()) {\\n        return 0; \\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n\\n    int ta = 0, nt = 0;\\n    if (s[i] == t[j] || t[j]==\\'*\\') {\\n      \\n            ta = solve(s, t, i + 1, j + 1, dp);\\n       \\n    }\\n    nt = solve(s, t, i + 1, j, dp);\\n  \\n\\n    dp[i][j] = (ta + nt) % mod;\\n    return dp[i][j];\\n}\\n\\nint countPalindromes(string s) {\\n    int ans = 0;\\n    string tof = \"\";\\n    vector<vector<int>> dp(s.length() + 1, vector<int>(5, -1));\\n    vector<vector<int>> o(s.length() + 1, vector<int>(5, -1));\\n\\n    for (int i = 0; i <= 9; i++) { // Change loop bounds to 9\\n        for (int j = 0; j <= 9; j++) { // Change loop bounds to 9\\n            char a = \\'0\\' + i;\\n            char b = \\'0\\' + j;\\n            tof += a;\\n            tof += b;\\n            tof +=\\'*\\';\\n            tof += b;\\n            tof += a;\\n\\n            dp = o;\\n            int c1 = solve(s, tof, 0, 0, dp);\\n            ans = (ans + c1) % mod;\\n            tof.clear();\\n        }\\n    }\\n    return ans;\\n}\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\nconst int mod = 1000000007;\\n\\nint solve(string &s, string &t, int i, int j, vector<vector<int>>& dp) {\\n    if (j == t.length()) {\\n        return 1;\\n    }\\n    if (i >= s.length()) {\\n        return 0; \\n    }\\n    if (dp[i][j] != -1) {\\n        return dp[i][j];\\n    }\\n\\n    int ta = 0, nt = 0;\\n    if (s[i] == t[j] || t[j]==\\'*\\') {\\n      \\n            ta = solve(s, t, i + 1, j + 1, dp);\\n       \\n    }\\n    nt = solve(s, t, i + 1, j, dp);\\n  \\n\\n    dp[i][j] = (ta + nt) % mod;\\n    return dp[i][j];\\n}\\n\\nint countPalindromes(string s) {\\n    int ans = 0;\\n    string tof = \"\";\\n    vector<vector<int>> dp(s.length() + 1, vector<int>(5, -1));\\n    vector<vector<int>> o(s.length() + 1, vector<int>(5, -1));\\n\\n    for (int i = 0; i <= 9; i++) { // Change loop bounds to 9\\n        for (int j = 0; j <= 9; j++) { // Change loop bounds to 9\\n            char a = \\'0\\' + i;\\n            char b = \\'0\\' + j;\\n            tof += a;\\n            tof += b;\\n            tof +=\\'*\\';\\n            tof += b;\\n            tof += a;\\n\\n            dp = o;\\n            int c1 = solve(s, tof, 0, 0, dp);\\n            ans = (ans + c1) % mod;\\n            tof.clear();\\n        }\\n    }\\n    return ans;\\n}\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910638,
                "title": "top-down-recursive-memorization-palindrome-property",
                "content": "the given length of palindrome is 5\\n\\nstring : c0   c1   c2   c3  c4\\nso if this above string is palindram then  c0=c4  && c2=c3\\n\\napproach:\\nwe need to keep track of 0th & 1th value to select the next character and also a length variable to keep track of current length of palindrome \\n\\nimplimentation:\\n```\\nclass Solution {\\npublic:\\n    \\n    int m=1e9 +7;\\n    string s=\"\";\\n    int n=0;\\n    int dp[10001][11][11][6];\\n    //       curr index    curr length  value at 0th position    value at 1th position\\n    int solve(int idx,     int i,       int z,                   int o)\\n    {\\n        if(i==5) return 1;\\n        \\n        if(idx==n) return 0;\\n        \\n        if(dp[idx][z][o][i]!=-1) return dp[idx][z][o][i];\\n        \\n        int ans= solve(idx+1, i,z,o);\\n        ans= ans%m;\\n        \\n        if(i==0)\\n        {\\n            ans+=solve(idx+1,i+1,s[idx]-\\'0\\',o);\\n            ans%=m;\\n        }else if(i==1)\\n        {\\n            ans+=solve(idx+1,i+1,z,s[idx]-\\'0\\');\\n            ans%=m;\\n        }else if(i==2)\\n        {\\n            ans+=solve(idx+1,i+1,z,o);\\n            ans%=m;\\n            \\n        }else if(i==3)\\n        {\\n            if((s[idx]-\\'0\\')==o)\\n            {\\n                ans+=solve(idx+1,i+1,z,o);\\n                ans%=m;\\n                \\n            }\\n        }else\\n        {\\n            if((s[idx]-\\'0\\')==z)\\n            {\\n                ans+=solve(idx+1,i+1,z,o);\\n                ans%=m;\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return dp[idx][z][o][i]=ans;\\n        \\n    }\\n    \\n    int countPalindromes(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int m=1e9 +7;\\n    string s=\"\";\\n    int n=0;\\n    int dp[10001][11][11][6];\\n    //       curr index    curr length  value at 0th position    value at 1th position\\n    int solve(int idx,     int i,       int z,                   int o)\\n    {\\n        if(i==5) return 1;\\n        \\n        if(idx==n) return 0;\\n        \\n        if(dp[idx][z][o][i]!=-1) return dp[idx][z][o][i];\\n        \\n        int ans= solve(idx+1, i,z,o);\\n        ans= ans%m;\\n        \\n        if(i==0)\\n        {\\n            ans+=solve(idx+1,i+1,s[idx]-\\'0\\',o);\\n            ans%=m;\\n        }else if(i==1)\\n        {\\n            ans+=solve(idx+1,i+1,z,s[idx]-\\'0\\');\\n            ans%=m;\\n        }else if(i==2)\\n        {\\n            ans+=solve(idx+1,i+1,z,o);\\n            ans%=m;\\n            \\n        }else if(i==3)\\n        {\\n            if((s[idx]-\\'0\\')==o)\\n            {\\n                ans+=solve(idx+1,i+1,z,o);\\n                ans%=m;\\n                \\n            }\\n        }else\\n        {\\n            if((s[idx]-\\'0\\')==z)\\n            {\\n                ans+=solve(idx+1,i+1,z,o);\\n                ans%=m;\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return dp[idx][z][o][i]=ans;\\n        \\n    }\\n    \\n    int countPalindromes(string s1) \\n    {\\n        s=s1;\\n        n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788955,
                "title": "java-dp-memoization-no-prefix-suffix-calculation",
                "content": "# Complexity\\n- Time complexity: $$O(n * 11 * 11 * 6)$$ (DP)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * 11 * 11 * 6)$$ (DP) + $$O(n)$$ (Stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final int mod = (int) 1e9 + 7;\\n    private Integer[][][][] dp;\\n    private int n;\\n\\n    public int countPalindromes(String s) {\\n        n = s.length();\\n        dp = new Integer[n][11][11][6];\\n        return solve(0, 10, 10, 0, s.toCharArray());\\n    }\\n\\n    private int solve(int idx, int first, int second, int index, char[] str) {\\n        if(idx == n) return index == 5 ? 1 : 0;\\n        if(dp[idx][first][second][index] != null) return dp[idx][first][second][index];\\n        int notPick = solve(idx + 1, first, second, index, str);\\n        notPick %= mod;\\n\\n        int pick = 0;\\n        if(index == 0) {\\n            pick = solve(idx + 1, str[idx] - \\'0\\', second, index + 1, str);\\n        }\\n        else if(index == 1) {\\n            pick = solve(idx + 1, first, str[idx] - \\'0\\', index + 1, str);\\n        }\\n        else if(index == 2) {\\n            pick = solve(idx + 1, first, second, index + 1, str);\\n        }\\n        else if(index == 3) {\\n            pick = str[idx] - \\'0\\' == second ? solve(idx + 1, first, second, index + 1, str) : 0;\\n        }\\n        else if(index == 4) {\\n            pick = str[idx] - \\'0\\' == first ? solve(idx + 1, first, second, index + 1, str) : 0;\\n        }\\n        pick %= mod;\\n        return dp[idx][first][second][index] = (pick + notPick) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private final int mod = (int) 1e9 + 7;\\n    private Integer[][][][] dp;\\n    private int n;\\n\\n    public int countPalindromes(String s) {\\n        n = s.length();\\n        dp = new Integer[n][11][11][6];\\n        return solve(0, 10, 10, 0, s.toCharArray());\\n    }\\n\\n    private int solve(int idx, int first, int second, int index, char[] str) {\\n        if(idx == n) return index == 5 ? 1 : 0;\\n        if(dp[idx][first][second][index] != null) return dp[idx][first][second][index];\\n        int notPick = solve(idx + 1, first, second, index, str);\\n        notPick %= mod;\\n\\n        int pick = 0;\\n        if(index == 0) {\\n            pick = solve(idx + 1, str[idx] - \\'0\\', second, index + 1, str);\\n        }\\n        else if(index == 1) {\\n            pick = solve(idx + 1, first, str[idx] - \\'0\\', index + 1, str);\\n        }\\n        else if(index == 2) {\\n            pick = solve(idx + 1, first, second, index + 1, str);\\n        }\\n        else if(index == 3) {\\n            pick = str[idx] - \\'0\\' == second ? solve(idx + 1, first, second, index + 1, str) : 0;\\n        }\\n        else if(index == 4) {\\n            pick = str[idx] - \\'0\\' == first ? solve(idx + 1, first, second, index + 1, str) : 0;\\n        }\\n        pick %= mod;\\n        return dp[idx][first][second][index] = (pick + notPick) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458380,
                "title": "o-n-memoization-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe length of the input string $$N$$ is tight for less efficient DP. The key is the limited length of palindromes (`k` = 5 only) and the small vocabulary ($$|D|=10$$). So, we can solve the problem with DP by formulating a state as `(d1, d2, i, direction)`, where `d1` and `d2` are the first and the second characters, respectively, `i` is the current position in the input string `s`, and `direction` denotes whether we are dealing with the first three characters or the last two characters. \\n\\nBy exploring `s` from left to right one by one, we try to pick up the character `s[i]` or skip it. When `direction` is 0, we try to pick up `s[i]` as the first, the second, or the third charater in a palindrome. When `direction` is 1, we try to pick up the current character `s[i]` to match the second or the first character. \\n\\nFor an input string with a length of $$N$$, the size of the entire state space is $$10 \\\\times 10 \\\\times N \\\\times 2$$, and the resultant time and space complexities are $$O(N)$$. For such a small space, a trivial implementation in memoization can pass all the testcases. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        @cache\\n        def dp(d1, d2, i, direction):\\n            if i >= len(s):\\n                return 0\\n            if direction == 0:\\n                if d1 == -1:\\n                    return (dp(s[i], -1, i+1, 0) + dp(-1, -1, i+1, 0)) % 1000000007\\n                elif d2 == -1:\\n                    return (dp(d1, s[i], i+1, 0) + dp(d1, -1, i+1, 0)) % 1000000007\\n                else:\\n                    return (dp(d1, d2, i+1, 0) + dp(d1, d2, i+1, 1)) % 1000000007\\n            else:\\n                if d2 != -1:\\n                    if s[i] == d2:\\n                        return (dp(d1, d2, i+1, 1) + dp(d1, -1, i+1, 1)) % 1000000007\\n                    else:\\n                        return dp(d1, d2, i+1, 1)\\n                elif d1 != -1:\\n                    if s[i] == d1:\\n                        return (1 + dp(d1, d2, i+1, 1)) % 1000000007\\n                    else:\\n                        return dp(d1, d2, i+1, 1)\\n\\n        return dp(-1, -1, 0, 0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        @cache\\n        def dp(d1, d2, i, direction):\\n            if i >= len(s):\\n                return 0\\n            if direction == 0:\\n                if d1 == -1:\\n                    return (dp(s[i], -1, i+1, 0) + dp(-1, -1, i+1, 0)) % 1000000007\\n                elif d2 == -1:\\n                    return (dp(d1, s[i], i+1, 0) + dp(d1, -1, i+1, 0)) % 1000000007\\n                else:\\n                    return (dp(d1, d2, i+1, 0) + dp(d1, d2, i+1, 1)) % 1000000007\\n            else:\\n                if d2 != -1:\\n                    if s[i] == d2:\\n                        return (dp(d1, d2, i+1, 1) + dp(d1, -1, i+1, 1)) % 1000000007\\n                    else:\\n                        return dp(d1, d2, i+1, 1)\\n                elif d1 != -1:\\n                    if s[i] == d1:\\n                        return (1 + dp(d1, d2, i+1, 1)) % 1000000007\\n                    else:\\n                        return dp(d1, d2, i+1, 1)\\n\\n        return dp(-1, -1, 0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239760,
                "title": "go-solution-dp-o-n",
                "content": "# Intuition\\nThe solution uses a dynamic programming approach to count the number of palindromic subsequences of length 5 in the given input string s.\\n\\n# Approach\\nThe solution first calculates the count of right palindromic subsequences of length 3 for each digit from 0 to 9, by iterating over the string from right to left. For each digit encountered, the solution updates the count of that digit in the right half of the subsequence and updates the count of all pairs of digits that can form a palindrome with that digit in the right half of the subsequence.\\n\\nNext, the solution iterates over the string from left to right and simultaneously calculates the count of left palindromic subsequences of length 3 and the total count of palindromic subsequences of length 5. For each digit encountered, the solution updates the count of that digit in the left half of the subsequence and updates the count of all pairs of digits that can form a palindrome with that digit in the left half of the subsequence. It also calculates the contribution of each pair of digits to the total count of palindromic subsequences of length 5 by multiplying the corresponding counts of left and right palindromic subsequences of length 3.\\n\\nFinally, the solution returns the total count of palindromic subsequences of length 5 modulo 10^9 + 7.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given solution is O(n), where n is the length of the input string s.\\nThe solution performs a single pass through the string s from right to left to calculate the count of right palindromic subsequences of length 3, and then performs another pass from left to right to calculate the count of left palindromic subsequences of length 3 and simultaneously count the total number of palindromic subsequences of length 5. The loops over the digits 0 to 9 inside the two passes each have a constant upper bound of 10, so they do not contribute to the time complexity.\\nThus, the overall time complexity is O(n), making the solution efficient enough to handle the given constraints of 1 <= s.length <= 10^4.\\n\\n- Space complexity:\\nThe space complexity of the given solution is O(1), as the amount of memory used by the program does not depend on the length of the input string s. The solution only uses a fixed-size array of length 10 for each of the left and right counts, and two fixed-size 2D arrays of size 10x10 for each of the left and right counts of each pair of digits. Thus, the space used by the program remains constant regardless of the length of the input string.\\n\\n# Code\\n```\\nfunc countPalindromes(s string) int {\\n    n := len(s)\\n    left, right := make([]int, 10), make([]int, 10)\\n    cntLeft, cntRight := make([][]int, 10), make([][]int, 10)\\n    for i := range cntLeft {\\n        cntLeft[i], cntRight[i] = make([]int, 10), make([]int, 10)\\n    }\\n    M := int(1e9) + 7\\n    for i := n - 2; i >= 2; i-- {\\n        right[s[i+1]-\\'0\\']++\\n        d := s[i] - \\'0\\'\\n        for j := 0; j < 10; j++ {\\n            cntRight[d][j] += right[j]\\n        }\\n    }\\n    ans := 0\\n    for i := 2; i < n-2; i++ {\\n        // update left\\n        left[s[i-2]-\\'0\\']++\\n        // update cntLeft\\n        d := s[i-1] - \\'0\\'\\n        for j := 0; j < 10; j++ {\\n            cntLeft[j][d] += left[j]\\n        }\\n        // update cntRight\\n        d = s[i] - \\'0\\'\\n        for j := 0; j < 10; j++ {\\n            cntRight[d][j] -= right[j]\\n        }\\n        // update ans\\n        for j := 0; j < 10; j++ {\\n            for k := 0; k < 10; k++ {\\n                ans += cntLeft[j][k] * cntRight[k][j]\\n                ans %= M\\n            }\\n        }\\n        // update right\\n        right[s[i+1]-\\'0\\']--\\n    }\\n    return ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countPalindromes(s string) int {\\n    n := len(s)\\n    left, right := make([]int, 10), make([]int, 10)\\n    cntLeft, cntRight := make([][]int, 10), make([][]int, 10)\\n    for i := range cntLeft {\\n        cntLeft[i], cntRight[i] = make([]int, 10), make([]int, 10)\\n    }\\n    M := int(1e9) + 7\\n    for i := n - 2; i >= 2; i-- {\\n        right[s[i+1]-\\'0\\']++\\n        d := s[i] - \\'0\\'\\n        for j := 0; j < 10; j++ {\\n            cntRight[d][j] += right[j]\\n        }\\n    }\\n    ans := 0\\n    for i := 2; i < n-2; i++ {\\n        // update left\\n        left[s[i-2]-\\'0\\']++\\n        // update cntLeft\\n        d := s[i-1] - \\'0\\'\\n        for j := 0; j < 10; j++ {\\n            cntLeft[j][d] += left[j]\\n        }\\n        // update cntRight\\n        d = s[i] - \\'0\\'\\n        for j := 0; j < 10; j++ {\\n            cntRight[d][j] -= right[j]\\n        }\\n        // update ans\\n        for j := 0; j < 10; j++ {\\n            for k := 0; k < 10; k++ {\\n                ans += cntLeft[j][k] * cntRight[k][j]\\n                ans %= M\\n            }\\n        }\\n        // update right\\n        right[s[i+1]-\\'0\\']--\\n    }\\n    return ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3199877,
                "title": "brute-force-based-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we were given the palindrome, then we can count its occurence as\\na subsequence in the given string by doing simple DP\\n\\nProblem - [Distinct Occurences](https://practice.geeksforgeeks.org/problems/distinct-occurrences/1)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, we\\'ll try to fix the palindrome and then we\\'ll try to find its count in S.\\n\\nWe can observe that there are 1000 palindromes of length 5. You can get it like this : \\n\\nwe know that the palindrome will of the form -> ABCBA\\nSo, we have 10 choices (0-10) for first character and 10 choices for 2nd character and 10 choices for 3rd character as well and 4th and 5th character will be fixed by choosing the 1st and 2nd character.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nT.C = (#palindromes) * (time req to count freq of a given palindrome in S)\\n\\nT.C. = O(1000 * N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nS.C = O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // brute force solution\\n\\n    string t;\\n\\n    vector<string> gen()\\n    {\\n        vector<string> ans;\\n        for (char c1=\\'0\\'; c1<=\\'9\\'; c1++)\\n        {\\n            for (char c2=\\'0\\'; c2<=\\'9\\'; c2++)\\n            {\\n                for (char c3=\\'0\\'; c3<=\\'9\\'; c3++)\\n                {\\n                    for (char c4=\\'0\\'; c4<=\\'9\\'; c4++)\\n                    {\\n                        for (char c5=\\'0\\'; c5<=\\'9\\'; c5++)\\n                        {\\n                            string s;\\n                            s += c1; s+=c2; s+=c3; s+=c4; s+=c5;\\n                            string t = s;\\n                            reverse(t.begin(), t.end());\\n                            if (t==s) \\n                            {\\n                                ans.push_back(s);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int dp[10010][6];\\n    const int mod = 1e9+7;\\n    int n;\\n    string s;\\n\\n    int rec(int i, int matched)\\n    {\\n        // base case\\n        if (i==n)\\n        {\\n            if (matched == 5) return 1;\\n            return 0;\\n        }\\n\\n        if (dp[i][matched] != -1) return dp[i][matched];\\n\\n        int op1 = 0;\\n        if (matched < 5 and s[i] == t[matched])\\n        {\\n            op1 += rec(i+1, matched+1);\\n        }\\n\\n        int op2 = rec(i+1, matched);\\n\\n        return dp[i][matched] = (op1+op2) % mod;\\n    }\\n\\n\\n    int countPalindromes(string S) {\\n        \\n        // count palindromic subseq of length 5\\n\\n        n = S.length(); s = S;\\n\\n        // generate all possible palindriomes of length 5\\n        // its count will be 1000\\n        \\n        vector<string> all_palindromes = gen();\\n        int ans = 0;\\n        for (auto str : all_palindromes)\\n        {\\n            memset(dp, -1, sizeof dp);\\n            t = str;\\n\\n            // count freq of string str in S\\n            ans = (ans + rec(0, 0)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // brute force solution\\n\\n    string t;\\n\\n    vector<string> gen()\\n    {\\n        vector<string> ans;\\n        for (char c1=\\'0\\'; c1<=\\'9\\'; c1++)\\n        {\\n            for (char c2=\\'0\\'; c2<=\\'9\\'; c2++)\\n            {\\n                for (char c3=\\'0\\'; c3<=\\'9\\'; c3++)\\n                {\\n                    for (char c4=\\'0\\'; c4<=\\'9\\'; c4++)\\n                    {\\n                        for (char c5=\\'0\\'; c5<=\\'9\\'; c5++)\\n                        {\\n                            string s;\\n                            s += c1; s+=c2; s+=c3; s+=c4; s+=c5;\\n                            string t = s;\\n                            reverse(t.begin(), t.end());\\n                            if (t==s) \\n                            {\\n                                ans.push_back(s);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int dp[10010][6];\\n    const int mod = 1e9+7;\\n    int n;\\n    string s;\\n\\n    int rec(int i, int matched)\\n    {\\n        // base case\\n        if (i==n)\\n        {\\n            if (matched == 5) return 1;\\n            return 0;\\n        }\\n\\n        if (dp[i][matched] != -1) return dp[i][matched];\\n\\n        int op1 = 0;\\n        if (matched < 5 and s[i] == t[matched])\\n        {\\n            op1 += rec(i+1, matched+1);\\n        }\\n\\n        int op2 = rec(i+1, matched);\\n\\n        return dp[i][matched] = (op1+op2) % mod;\\n    }\\n\\n\\n    int countPalindromes(string S) {\\n        \\n        // count palindromic subseq of length 5\\n\\n        n = S.length(); s = S;\\n\\n        // generate all possible palindriomes of length 5\\n        // its count will be 1000\\n        \\n        vector<string> all_palindromes = gen();\\n        int ans = 0;\\n        for (auto str : all_palindromes)\\n        {\\n            memset(dp, -1, sizeof dp);\\n            t = str;\\n\\n            // count freq of string str in S\\n            ans = (ans + rec(0, 0)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874556,
                "title": "python-prefix-counting",
                "content": "```\\nclass Solution:\\n    \\n    def countPalindromes(self, S: str) -> int:\\n        \\n        \"\"\"\\n             . COUNT palindromic subsequences of s having length 5\\n             \\n             \\n             since length of palindrome is always odd, we can use +1, -1 trick ?\\n        \"\"\"\\n        \\n        MOD = 10 ** 9 +7\\n        \\n        def make_prefix(S):\\n            \\n            prefix = {}\\n            counter_single = defaultdict(int) # for counting all single digit from [:i]\\n            counter_double = defaultdict(int) # for counting all double figit from [:p]\\n            \\n            for i in range(len(S)):\\n                curr = int(S[i])\\n                for j in range(10):\\n                    if j in counter_single:\\n                        possible_double_dig = (j * 10) + curr # if curr is 3, we will have 03,13,23,33,43..93\\n                        counter_double[possible_double_dig] += counter_single[j]\\n                \\n                counter_single[curr] += 1\\n            \\n                prefix[i] = counter_double.copy()\\n            \\n            return prefix\\n                \\n    \\n        dp_prefix = make_prefix(S)\\n        dp_sufix = make_prefix(S[::-1])\\n        \\n        ans = 0\\n        N = len(S)\\n        for i in range(1, N-1):\\n            for j in dp_prefix[i]:\\n                ans += (dp_prefix[i-1][j] * dp_sufix[N-i-2][j]) \\n                ans = ans % MOD\\n        \\n        return ans\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def countPalindromes(self, S: str) -> int:\\n        \\n        \"\"\"\\n             . COUNT palindromic subsequences of s having length 5\\n             \\n             \\n             since length of palindrome is always odd, we can use +1, -1 trick ?\\n        \"\"\"\\n        \\n        MOD = 10 ** 9 +7\\n        \\n        def make_prefix(S):\\n            \\n            prefix = {}\\n            counter_single = defaultdict(int) # for counting all single digit from [:i]\\n            counter_double = defaultdict(int) # for counting all double figit from [:p]\\n            \\n            for i in range(len(S)):\\n                curr = int(S[i])\\n                for j in range(10):\\n                    if j in counter_single:\\n                        possible_double_dig = (j * 10) + curr # if curr is 3, we will have 03,13,23,33,43..93\\n                        counter_double[possible_double_dig] += counter_single[j]\\n                \\n                counter_single[curr] += 1\\n            \\n                prefix[i] = counter_double.copy()\\n            \\n            return prefix\\n                \\n    \\n        dp_prefix = make_prefix(S)\\n        dp_sufix = make_prefix(S[::-1])\\n        \\n        ans = 0\\n        N = len(S)\\n        for i in range(1, N-1):\\n            for j in dp_prefix[i]:\\n                ans += (dp_prefix[i-1][j] * dp_sufix[N-i-2][j]) \\n                ans = ans % MOD\\n        \\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855385,
                "title": "c-code-for-beginners-recursion-memo-fully-commented",
                "content": "Assume the palindrome as XY_YX where _ can be anything as middle element can be anything in a palindrome, so just try to build palindromes using this format. If len==0, which means you are allowed to choose X, when len==1 , you are allowed to choose Y, when len==2 you can pick any element you want as middle element, when len==3 you wanna match your current character with already picked Y previously, similarly for len==4, check for X matching\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[10001][6][11][11];\\n    \\n    int helper(string &s, char x, char y, int curr, int len){\\n        if(len==5){\\n            return 1;\\n        }\\n        if(curr==s.size()){\\n            return 0;\\n        }\\n        if(dp[curr][len][x-\\'0\\'][y-\\'0\\']!=-1){\\n            return dp[curr][len][x-\\'0\\'][y-\\'0\\'];\\n        }\\n        int res=helper(s,x,y,curr+1,len);  // ignore current element\\n        \\n        // xy_yx, let us think of this format as our palindrome, where _ is any character\\n        \\n        if(len==0){  // free to choose x as the current character and update x\\n            res+=helper(s,s[curr],y,curr+1,len+1);\\n            res%=1000000007;\\n        }\\n        if(len==1){  // free to choose y as the current character and update y\\n            res+=helper(s,x,s[curr],curr+1,len+1);\\n            res%=1000000007;\\n        }\\n        if(len==2){ // free to choose middle as the current character, doesnt matter\\n            res+=helper(s,x,y,curr+1,len+1);\\n            res%=1000000007;\\n        }\\n        if(len==3 && s[curr]==y){  // current char must be equal to y to make palindrome\\n            res+=helper(s,x,y,curr+1,len+1);\\n            res%=1000000007;\\n        } \\n        if(len==4 && s[curr]==x){  // current char must be equal to x to make palindrome \\n            res+=helper(s,x,y,curr+1,len+1);\\n            res%=1000000007;\\n        } \\n        return dp[curr][len][x-\\'0\\'][y-\\'0\\']=res;\\n    }\\n    \\n    int countPalindromes(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(s,\\'0\\',\\'0\\',0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10001][6][11][11];\\n    \\n    int helper(string &s, char x, char y, int curr, int len){\\n        if(len==5){\\n            return 1;\\n        }\\n        if(curr==s.size()){\\n            return 0;\\n        }\\n        if(dp[curr][len][x-\\'0\\'][y-\\'0\\']!=-1){\\n            return dp[curr][len][x-\\'0\\'][y-\\'0\\'];\\n        }\\n        int res=helper(s,x,y,curr+1,len);  // ignore current element\\n        \\n        // xy_yx, let us think of this format as our palindrome, where _ is any character\\n        \\n        if(len==0){  // free to choose x as the current character and update x\\n            res+=helper(s,s[curr],y,curr+1,len+1);\\n            res%=1000000007;\\n        }\\n        if(len==1){  // free to choose y as the current character and update y\\n            res+=helper(s,x,s[curr],curr+1,len+1);\\n            res%=1000000007;\\n        }\\n        if(len==2){ // free to choose middle as the current character, doesnt matter\\n            res+=helper(s,x,y,curr+1,len+1);\\n            res%=1000000007;\\n        }\\n        if(len==3 && s[curr]==y){  // current char must be equal to y to make palindrome\\n            res+=helper(s,x,y,curr+1,len+1);\\n            res%=1000000007;\\n        } \\n        if(len==4 && s[curr]==x){  // current char must be equal to x to make palindrome \\n            res+=helper(s,x,y,curr+1,len+1);\\n            res%=1000000007;\\n        } \\n        return dp[curr][len][x-\\'0\\'][y-\\'0\\']=res;\\n    }\\n    \\n    int countPalindromes(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(s,\\'0\\',\\'0\\',0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850942,
                "title": "c-counting-o-10n-time-and-o-100-space-faster-than-100",
                "content": "Basically, maintain 4 vectors while doing sliding window. We loop over each character in `s`, and for each one, calculate the number of 5-palindromes where `s[j]` is the middle character. The trick is that, instead of calculating the number every time, use a variable `sum_to_add` to record this number, and only adjust it marginally for each `j`.\\n\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        vector<long> count_c_before(10, 0);  // count occurrence of \\'0\\' - \\'9\\'\\n        vector<long> count_c_after(10, 0);\\n        vector<long> count_cc_before(100, 0);  // count occurrences of \\'00\\' - \\'99\\'\\n        vector<long> count_cc_after(100, 0);\\n\\t\\t// initialize count_c_after and count_cc_after\\n        for (char c: s){\\n            int ci = c - \\'0\\';\\n            for (int i = 0; i <= 9; ++i){\\n                count_cc_after[i * 10 + ci] += count_c_after[i];\\n            }\\n            ++count_c_after[ci];\\n        }\\n        long res = 0;\\n        long sum_to_add = 0;\\n        for (int j = 0; j != s.size(); ++j){\\n            int ci = s[j] - \\'0\\';\\n            // adjust sum_to_add after including the previous char\\n            if (j > 0){\\n                int cj = s[j - 1] - \\'0\\';\\n                for (int i = 0; i <= 9; ++i){\\n                    sum_to_add += count_c_before[i] * count_cc_after[cj * 10 + i];\\n                    count_cc_before[i * 10 + cj] += count_c_before[i];\\n                }\\n                ++count_c_before[cj];\\n            }\\n            // adjust sum_to_add after excluding the current char\\n            --count_c_after[ci];\\n            for (int i = 0; i <= 9; ++i){\\n                sum_to_add -= count_c_after[i] * count_cc_before[i * 10 + ci];\\n                count_cc_after[ci * 10 + i] -= count_c_after[i];\\n            }\\n            \\n            res += sum_to_add;\\n            res %= 1000000007;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        vector<long> count_c_before(10, 0);  // count occurrence of \\'0\\' - \\'9\\'\\n        vector<long> count_c_after(10, 0);\\n        vector<long> count_cc_before(100, 0);  // count occurrences of \\'00\\' - \\'99\\'\\n        vector<long> count_cc_after(100, 0);\\n\\t\\t// initialize count_c_after and count_cc_after\\n        for (char c: s){\\n            int ci = c - \\'0\\';\\n            for (int i = 0; i <= 9; ++i){\\n                count_cc_after[i * 10 + ci] += count_c_after[i];\\n            }\\n            ++count_c_after[ci];\\n        }\\n        long res = 0;\\n        long sum_to_add = 0;\\n        for (int j = 0; j != s.size(); ++j){\\n            int ci = s[j] - \\'0\\';\\n            // adjust sum_to_add after including the previous char\\n            if (j > 0){\\n                int cj = s[j - 1] - \\'0\\';\\n                for (int i = 0; i <= 9; ++i){\\n                    sum_to_add += count_c_before[i] * count_cc_after[cj * 10 + i];\\n                    count_cc_before[i * 10 + cj] += count_c_before[i];\\n                }\\n                ++count_c_before[cj];\\n            }\\n            // adjust sum_to_add after excluding the current char\\n            --count_c_after[ci];\\n            for (int i = 0; i <= 9; ++i){\\n                sum_to_add -= count_c_after[i] * count_cc_before[i * 10 + ci];\\n                count_cc_after[ci * 10 + i] -= count_c_after[i];\\n            }\\n            \\n            res += sum_to_add;\\n            res %= 1000000007;\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850890,
                "title": "python3-solution-with-dp",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        res=0\\n        for i in range(10):\\n            for j in range(10):\\n                pattern=str(i)+str(j)+\"|\"+str(j)+str(i)\\n                dp=[0]*6\\n                dp[-1]=1\\n                for x in range(len(s)):\\n                    for y in range(5):\\n                        if s[x]==pattern[y] or y==2:\\n                            dp[y]+=dp[y+1]\\n\\n                res=(res+dp[0])%(10**9+7)\\n\\n        return res                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        res=0\\n        for i in range(10):\\n            for j in range(10):\\n                pattern=str(i)+str(j)+\"|\"+str(j)+str(i)\\n                dp=[0]*6\\n                dp[-1]=1\\n                for x in range(len(s)):\\n                    for y in range(5):\\n                        if s[x]==pattern[y] or y==2:\\n                            dp[y]+=dp[y+1]\\n\\n                res=(res+dp[0])%(10**9+7)\\n\\n        return res                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850794,
                "title": "4d-dp-recursion-memorization-c",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int solve(int i,string &s,char fr,char sec,int len, vector<vector<vector<vector<int>>>> &dp){\\n        if(len == 5) return 1;\\n        if(i == s.size()) return 0;\\n        if(dp[fr-\\'0\\'][sec - \\'0\\'][len][i] != -1) return dp[fr-\\'0\\'][sec - \\'0\\'][len][i];\\n        \\n        long long op1 = 0, op2 = 0, op3 = 0, op4 = 0,op5 = 0;\\n        if(len == 0) op1 = solve(i+1,s,s[i],sec,len+1,dp);\\n        if(len == 1) op2 = solve(i+1,s,fr,s[i],len+1,dp);\\n        if(len == 2) op3 = solve(i+1,s,fr,sec,len+1,dp);\\n        if(len == 3 and s[i] == sec) op4 = solve(i+1,s,fr,sec,len+1,dp);\\n        if(len == 4 and s[i] == fr) op5 = solve(i+1,s,fr,sec,len+1,dp);\\n        long long op6 = solve(i+1,s,fr,sec,len,dp);\\n        \\n        return dp[fr-\\'0\\'][sec - \\'0\\'][len][i] = (op1 + op2 + op3 + op4 + op5 + op6) % mod;\\n    }\\n    int countPalindromes(string s) {\\n        vector<vector<vector<vector<int>>>> dp(10, vector<vector<vector<int>>> (10, vector<vector<int>> (5,vector<int>(s.size(),-1))));\\n        return solve(0,s,\\'1\\',\\'1\\',0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int solve(int i,string &s,char fr,char sec,int len, vector<vector<vector<vector<int>>>> &dp){\\n        if(len == 5) return 1;\\n        if(i == s.size()) return 0;\\n        if(dp[fr-\\'0\\'][sec - \\'0\\'][len][i] != -1) return dp[fr-\\'0\\'][sec - \\'0\\'][len][i];\\n        \\n        long long op1 = 0, op2 = 0, op3 = 0, op4 = 0,op5 = 0;\\n        if(len == 0) op1 = solve(i+1,s,s[i],sec,len+1,dp);\\n        if(len == 1) op2 = solve(i+1,s,fr,s[i],len+1,dp);\\n        if(len == 2) op3 = solve(i+1,s,fr,sec,len+1,dp);\\n        if(len == 3 and s[i] == sec) op4 = solve(i+1,s,fr,sec,len+1,dp);\\n        if(len == 4 and s[i] == fr) op5 = solve(i+1,s,fr,sec,len+1,dp);\\n        long long op6 = solve(i+1,s,fr,sec,len,dp);\\n        \\n        return dp[fr-\\'0\\'][sec - \\'0\\'][len][i] = (op1 + op2 + op3 + op4 + op5 + op6) % mod;\\n    }\\n    int countPalindromes(string s) {\\n        vector<vector<vector<vector<int>>>> dp(10, vector<vector<vector<int>>> (10, vector<vector<int>> (5,vector<int>(s.size(),-1))));\\n        return solve(0,s,\\'1\\',\\'1\\',0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850647,
                "title": "simple-l-r-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int N = 1e4+4;\\nconst int MOD = 1e9+7;\\nconst int x = 5;\\ntypedef long long ll;\\nll dp[N][N];\\n\\nclass Solution {\\npublic:\\n    int countPalindromes(string str) {\\n        ll ans = 0;\\n        memset(dp, sizeof(dp), 0);\\n        int n = str.size();\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = i+2; j<n; j++){\\n                dp[i][j] = dp[i][j-1];\\n                if(str[i] == str[j]){\\n                    dp[i][j] = (dp[i][j] + j - i - 1)%MOD;\\n                }\\n                if(dp[i+1][j] != dp[i+1][j-1]){\\n                    dp[i][j] = (dp[i][j] - dp[i+1][j-1] + dp[i+1][j])%MOD;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = i + x - 1; j<n; j++){\\n                if(str[i] == str[j]) ans = (ans + dp[i+1][j-1])%MOD;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 1e4+4;\\nconst int MOD = 1e9+7;\\nconst int x = 5;\\ntypedef long long ll;\\nll dp[N][N];\\n\\nclass Solution {\\npublic:\\n    int countPalindromes(string str) {\\n        ll ans = 0;\\n        memset(dp, sizeof(dp), 0);\\n        int n = str.size();\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = i+2; j<n; j++){\\n                dp[i][j] = dp[i][j-1];\\n                if(str[i] == str[j]){\\n                    dp[i][j] = (dp[i][j] + j - i - 1)%MOD;\\n                }\\n                if(dp[i+1][j] != dp[i+1][j-1]){\\n                    dp[i][j] = (dp[i][j] - dp[i+1][j-1] + dp[i+1][j])%MOD;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i<n; i++){\\n            for(int j = i + x - 1; j<n; j++){\\n                if(str[i] == str[j]) ans = (ans + dp[i+1][j-1])%MOD;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850538,
                "title": "python-tle-o-5-1000-n",
                "content": "TLE...\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 10**9+7\\n        ans = 0\\n        dp = [[0]*5 for _ in range(1000)]\\n        tmps = [str(i).rjust(3,\"0\") for i in range(1000)]\\n        for c in s:\\n            for i in range(1000):\\n                tmp = tmps[i]\\n                if(c==tmp[0]):\\n                    dp[i][4] = (dp[i][3]+dp[i][4])%MOD\\n                if(c==tmp[1]):\\n                    dp[i][3] = (dp[i][2]+dp[i][3])%MOD\\n                if(c==tmp[2]):\\n                    dp[i][2] = (dp[i][1]+dp[i][2])%MOD\\n                if(c== tmp[1]):\\n                    dp[i][1] = (dp[i][0]+dp[i][1])%MOD\\n                if(c ==tmp[0]):\\n                    dp[i][0] = (1+dp[i][0])%MOD\\n                    \\n        for i in range(len(dp)):\\n            ans = (ans+dp[i][4])%MOD\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 10**9+7\\n        ans = 0\\n        dp = [[0]*5 for _ in range(1000)]\\n        tmps = [str(i).rjust(3,\"0\") for i in range(1000)]\\n        for c in s:\\n            for i in range(1000):\\n                tmp = tmps[i]\\n                if(c==tmp[0]):\\n                    dp[i][4] = (dp[i][3]+dp[i][4])%MOD\\n                if(c==tmp[1]):\\n                    dp[i][3] = (dp[i][2]+dp[i][3])%MOD\\n                if(c==tmp[2]):\\n                    dp[i][2] = (dp[i][1]+dp[i][2])%MOD\\n                if(c== tmp[1]):\\n                    dp[i][1] = (dp[i][0]+dp[i][1])%MOD\\n                if(c ==tmp[0]):\\n                    dp[i][0] = (1+dp[i][0])%MOD\\n                    \\n        for i in range(len(dp)):\\n            ans = (ans+dp[i][4])%MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850451,
                "title": "java-preffix-sum-o-n",
                "content": "We are looking for palindromes of length 5.\\nCharacter in the middle of a palindrome with odd length does not need to match any other character => can be any character.\\nI.e. we are looking for polindomes that look like `abcba`.\\nWhere `c` is any character.\\n\\nWe can find all `ab` from the left and all `ba` from the right using preffix sum.\\nAt the end we just need to sum all palindromes for all characters `c` (in `abcba`)\\nNumber of palindromes for a single `c` character is all `ab` `*` all `ba`.\\n\\n```\\npublic int countPalindromes(String s) {\\n\\tvar ll = new long[10];\\n\\tll[s.charAt(0) - \\'0\\']++;\\n\\tvar l = new long[s.length()][10][10];\\n\\tfor (int i = 1; i < s.length(); i++) {\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tl[i][j] = l[i - 1][j].clone();\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tl[i][j][s.charAt(i) - \\'0\\'] += ll[j];\\n\\t\\t}\\n\\t\\tll[s.charAt(i) - \\'0\\']++;\\n\\t}\\n\\n\\tvar rr = new long[10];\\n\\trr[s.charAt(s.length() - 1) - \\'0\\']++;\\n\\tvar r = new long[s.length()][10][10];\\n\\tfor (int i = s.length() - 2; i >= 0; i--) {\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tr[i][j] = r[i + 1][j].clone();\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tr[i][j][s.charAt(i) - \\'0\\'] += rr[j];\\n\\t\\t}\\n\\t\\trr[s.charAt(i) - \\'0\\']++;\\n\\t}\\n\\n\\tlong res = 0;\\n\\tfor (int i = 2; i < s.length() - 2; i++) {\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tfor (int k = 0; k < 10; k++) {\\n\\t\\t\\t\\tres = (res + l[i - 1][j][k] * r[i + 1][j][k]) % 1_000_000_007;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn (int) res;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int countPalindromes(String s) {\\n\\tvar ll = new long[10];\\n\\tll[s.charAt(0) - \\'0\\']++;\\n\\tvar l = new long[s.length()][10][10];\\n\\tfor (int i = 1; i < s.length(); i++) {\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tl[i][j] = l[i - 1][j].clone();\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tl[i][j][s.charAt(i) - \\'0\\'] += ll[j];\\n\\t\\t}\\n\\t\\tll[s.charAt(i) - \\'0\\']++;\\n\\t}\\n\\n\\tvar rr = new long[10];\\n\\trr[s.charAt(s.length() - 1) - \\'0\\']++;\\n\\tvar r = new long[s.length()][10][10];\\n\\tfor (int i = s.length() - 2; i >= 0; i--) {\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tr[i][j] = r[i + 1][j].clone();\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tr[i][j][s.charAt(i) - \\'0\\'] += rr[j];\\n\\t\\t}\\n\\t\\trr[s.charAt(i) - \\'0\\']++;\\n\\t}\\n\\n\\tlong res = 0;\\n\\tfor (int i = 2; i < s.length() - 2; i++) {\\n\\t\\tfor (int j = 0; j < 10; j++) {\\n\\t\\t\\tfor (int k = 0; k < 10; k++) {\\n\\t\\t\\t\\tres = (res + l[i - 1][j][k] * r[i + 1][j][k]) % 1_000_000_007;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn (int) res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094185,
                "title": "c-solution-with-intuition-explained",
                "content": "# Intuition\\n\\n    DP with prefix sum everything is here\\n\\n    since palindrome should be of length 5 -> for middle element of palindrome-> 2 elements in both side    \\n\\n    intution: for every index, calculate how many 2 digits numbers are in both sides\\n    e.g  lets have :  1 0 3 3 0 1 \\n    for index=2 : \\n    All 2 digit numbers in left : {10}\\n    All 2 digit numbers in right : {30,31,01} = {30,31,01} -> flipped right side numbers {03,31,10}\\n    in {10} ans {03,31,10} -> 10 is found in both sides \\n    \\n    after calculating -> iterate : if a number is found in both side\\n    lets say around an index nuber 45 is 2 times in left and 3 times in right -> add (2*3)=(6) in answer\\n\\n    thus: use some sort of dp which stores how many numbers in left and right of an index\\n    good amount of involvement of prefix sum method\\n\\n    try storing number of left and right (try this intution on pen paper, get better clearity)\\n*/\\n\\n\\n# Complexity\\n- Time complexity: O(N*100)\\n\\n- Space complexity: O(N*100)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        \\n        int n=s.length(), mod=1e9+7;\\n\\n        long long left[n][100], right[n][100];\\n        memset(left,0,sizeof(left));\\n        memset(right,0,sizeof(right));\\n\\n        //compute left\\n        int count[10]={0};\\n        count[s[0]-\\'0\\']=1;\\n        for(int i=1;i<n;i++) {\\n            for(int j=0;j<10;j++) {\\n                if(count[j]>0) {\\n                    int digit=j*10+(s[i]-\\'0\\');\\n                    left[i][digit] += count[j];\\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n\\n            for(int k=0;k<100;k++) { //prefix sum DP\\n                left[i][k]+=left[i-1][k];\\n                left[i][k]%=mod;\\n            }\\n        }\\n\\n\\n\\n        //compute right\\n        memset(count,0,sizeof(count));\\n        count[s[n-1]-\\'0\\']=1;\\n        for(int i=n-2;i>=0;i--) {\\n            for(int j=0;j<10;j++) {\\n                if(count[j]>0) {\\n                    int digit=j*10+(s[i]-\\'0\\');  //if we are storing 10 of left -> in right 01 -> should be stored as 10\\n                    //otherwise while final computing -> we will have to reverse \\n                    //e.g 10301 -> left 10, right 01-> needs to be stored as 10 in dp\\n                    right[i][digit]+=count[j];\\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n\\n            for(int k=0;k<100;k++) { //prefix sum DP\\n                right[i][k]+=right[i+1][k];\\n                right[i][k]%=mod;\\n            }\\n        }\\n\\n\\n        //compute ans;\\n        long long ans=0;\\n        for(int i=2;i<n-2;i++) { //considering middle element of palindrome\\n            for(int j=0;j<100;j++) {\\n                ans+=(left[i-1][j]*right[i+1][j]);\\n                ans%=mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        \\n        int n=s.length(), mod=1e9+7;\\n\\n        long long left[n][100], right[n][100];\\n        memset(left,0,sizeof(left));\\n        memset(right,0,sizeof(right));\\n\\n        //compute left\\n        int count[10]={0};\\n        count[s[0]-\\'0\\']=1;\\n        for(int i=1;i<n;i++) {\\n            for(int j=0;j<10;j++) {\\n                if(count[j]>0) {\\n                    int digit=j*10+(s[i]-\\'0\\');\\n                    left[i][digit] += count[j];\\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n\\n            for(int k=0;k<100;k++) { //prefix sum DP\\n                left[i][k]+=left[i-1][k];\\n                left[i][k]%=mod;\\n            }\\n        }\\n\\n\\n\\n        //compute right\\n        memset(count,0,sizeof(count));\\n        count[s[n-1]-\\'0\\']=1;\\n        for(int i=n-2;i>=0;i--) {\\n            for(int j=0;j<10;j++) {\\n                if(count[j]>0) {\\n                    int digit=j*10+(s[i]-\\'0\\');  //if we are storing 10 of left -> in right 01 -> should be stored as 10\\n                    //otherwise while final computing -> we will have to reverse \\n                    //e.g 10301 -> left 10, right 01-> needs to be stored as 10 in dp\\n                    right[i][digit]+=count[j];\\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n\\n            for(int k=0;k<100;k++) { //prefix sum DP\\n                right[i][k]+=right[i+1][k];\\n                right[i][k]%=mod;\\n            }\\n        }\\n\\n\\n        //compute ans;\\n        long long ans=0;\\n        for(int i=2;i<n-2;i++) { //considering middle element of palindrome\\n            for(int j=0;j<100;j++) {\\n                ans+=(left[i-1][j]*right[i+1][j]);\\n                ans%=mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066088,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countPalindromes(string s) \\n    {\\n        int n,ans;\\n        n=s.size();\\n        ans=0;\\n\\n        vector<int> count1(10),count2(10);\\n        vector<vector<vector<int>>> pre(n,vector<vector<int>>(10,vector<int>(10)));\\n        vector<vector<vector<int>>> suf(n,vector<vector<int>>(10,vector<int>(10)));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int x;\\n            x=s[i]-\\'0\\';\\n\\n            if(i>0)\\n            {\\n                for(int j=0;j<10;j++)\\n                {\\n                    for(int k=0;k<10;k++)\\n                    {\\n                        pre[i][j][k]=pre[i-1][j][k];\\n\\n                        if(k==x)\\n                        {\\n                            pre[i][j][k]+=count1[j];\\n                        }                      \\n                    }\\n                }\\n            }\\n\\n            count1[x]++;\\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int x;\\n            x=s[i]-\\'0\\';\\n\\n            if(i<n-1)\\n            {\\n                for(int j=0;j<10;j++)\\n                {\\n                    for(int k=0;k<10;k++)\\n                    {\\n                        suf[i][j][k]=suf[i+1][j][k];\\n\\n                        if(k==x)\\n                        {\\n                            suf[i][j][k]+=count2[j];\\n                        }                      \\n                    }\\n                }\\n            }\\n\\n            count2[x]++;\\n        }\\n\\n        for(int i=2;i<n-2;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    ans=(ans+1LL*pre[i-1][j][k]*suf[i+1][j][k])%1000000007;\\n                }\\n            }\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countPalindromes(string s) \\n    {\\n        int n,ans;\\n        n=s.size();\\n        ans=0;\\n\\n        vector<int> count1(10),count2(10);\\n        vector<vector<vector<int>>> pre(n,vector<vector<int>>(10,vector<int>(10)));\\n        vector<vector<vector<int>>> suf(n,vector<vector<int>>(10,vector<int>(10)));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int x;\\n            x=s[i]-\\'0\\';\\n\\n            if(i>0)\\n            {\\n                for(int j=0;j<10;j++)\\n                {\\n                    for(int k=0;k<10;k++)\\n                    {\\n                        pre[i][j][k]=pre[i-1][j][k];\\n\\n                        if(k==x)\\n                        {\\n                            pre[i][j][k]+=count1[j];\\n                        }                      \\n                    }\\n                }\\n            }\\n\\n            count1[x]++;\\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int x;\\n            x=s[i]-\\'0\\';\\n\\n            if(i<n-1)\\n            {\\n                for(int j=0;j<10;j++)\\n                {\\n                    for(int k=0;k<10;k++)\\n                    {\\n                        suf[i][j][k]=suf[i+1][j][k];\\n\\n                        if(k==x)\\n                        {\\n                            suf[i][j][k]+=count2[j];\\n                        }                      \\n                    }\\n                }\\n            }\\n\\n            count2[x]++;\\n        }\\n\\n        for(int i=2;i<n-2;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                for(int k=0;k<10;k++)\\n                {\\n                    ans=(ans+1LL*pre[i-1][j][k]*suf[i+1][j][k])%1000000007;\\n                }\\n            }\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956552,
                "title": "rust-intuitive-solution",
                "content": "# Code\\n```rust\\nconst ALP_LEN: usize = 11;\\ntype Char = u8;\\n\\nconst MOD: usize = 1_000_000_007;\\n\\npub fn to_freq_map(\\n    vec: &Vec<Char>,\\n) -> Vec<[[usize; ALP_LEN]; ALP_LEN]> {\\n    let mut dp = [usize::MIN; ALP_LEN];\\n    dp[ALP_LEN - 1] = 1;\\n\\n    let mut count_map = [[usize::MIN; ALP_LEN]; ALP_LEN];\\n    count_map[ALP_LEN - 1][ALP_LEN - 1] = 1;\\n\\n    let mut ret = vec![count_map];\\n\\n    for &e in vec {\\n        for e_prev in 0..ALP_LEN {\\n            count_map[e as usize][e_prev] += dp[e_prev];\\n            count_map[e as usize][e_prev] %= MOD;\\n        }\\n        dp[e as usize] += 1;\\n\\n        ret.push(count_map);\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn count_palindromes(s: String) -> i32 {\\n        let mut vec = s.chars()\\n            .map(|c| c as Char - \\'0\\' as Char)\\n            .collect::<Vec<_>>();\\n        let n = vec.len();\\n\\n        let pref_vec = to_freq_map(&vec);\\n\\n        vec.reverse();\\n        let mut post_vec = to_freq_map(&vec);\\n        post_vec.reverse();\\n\\n        let mut ret = usize::MIN;\\n\\n        for (pref_map, post_map) in pref_vec.into_iter()\\n            .zip(post_vec.into_iter().skip(1)) {\\n            for c0 in 0..(ALP_LEN - 1) {\\n                for c1 in 0..(ALP_LEN - 1) {\\n                    let mut _ret = 1;\\n                    _ret *= pref_map[c0][c1];\\n                    _ret *= post_map[c0][c1];\\n                    _ret %= MOD;\\n\\n                    ret += _ret;\\n                    ret %= MOD;\\n                }\\n            }\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nconst ALP_LEN: usize = 11;\\ntype Char = u8;\\n\\nconst MOD: usize = 1_000_000_007;\\n\\npub fn to_freq_map(\\n    vec: &Vec<Char>,\\n) -> Vec<[[usize; ALP_LEN]; ALP_LEN]> {\\n    let mut dp = [usize::MIN; ALP_LEN];\\n    dp[ALP_LEN - 1] = 1;\\n\\n    let mut count_map = [[usize::MIN; ALP_LEN]; ALP_LEN];\\n    count_map[ALP_LEN - 1][ALP_LEN - 1] = 1;\\n\\n    let mut ret = vec![count_map];\\n\\n    for &e in vec {\\n        for e_prev in 0..ALP_LEN {\\n            count_map[e as usize][e_prev] += dp[e_prev];\\n            count_map[e as usize][e_prev] %= MOD;\\n        }\\n        dp[e as usize] += 1;\\n\\n        ret.push(count_map);\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn count_palindromes(s: String) -> i32 {\\n        let mut vec = s.chars()\\n            .map(|c| c as Char - \\'0\\' as Char)\\n            .collect::<Vec<_>>();\\n        let n = vec.len();\\n\\n        let pref_vec = to_freq_map(&vec);\\n\\n        vec.reverse();\\n        let mut post_vec = to_freq_map(&vec);\\n        post_vec.reverse();\\n\\n        let mut ret = usize::MIN;\\n\\n        for (pref_map, post_map) in pref_vec.into_iter()\\n            .zip(post_vec.into_iter().skip(1)) {\\n            for c0 in 0..(ALP_LEN - 1) {\\n                for c1 in 0..(ALP_LEN - 1) {\\n                    let mut _ret = 1;\\n                    _ret *= pref_map[c0][c1];\\n                    _ret *= post_map[c0][c1];\\n                    _ret %= MOD;\\n\\n                    ret += _ret;\\n                    ret %= MOD;\\n                }\\n            }\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929960,
                "title": "simple-dp-code-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor any index i, we need 2 digit numbers in left and right that can create a palindrome\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor every i find frequency of every 2 digit numbers in left and right to it \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*100)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*100)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp1(n,vector<int>(100,0)),dp2(n,vector<int>(100,0));\\n        vector<int>cnt(10,0);\\n        cnt[s[0]-\\'0\\']=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<100;j++) dp1[i][j]=dp1[i-1][j];\\n            for(int j=0;j<10;j++) dp1[i][j*10+(s[i]-\\'0\\')]+=cnt[j];\\n            cnt[s[i]-\\'0\\']++;\\n        }\\n        cnt.clear();\\n        cnt.resize(10,0);\\n        cnt[s[n-1]-\\'0\\']=1;\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<100;j++) dp2[i][j]=dp2[i+1][j];\\n            for(int j=0;j<10;j++) dp2[i][(s[i]-\\'0\\')*10+j]+=cnt[j];\\n            cnt[s[i]-\\'0\\']++;\\n        }\\n        int ans=0,mod=1e9+7;\\n        for(int i=2;i<n-2;i++){\\n            for(int j=0;j<100;j++){\\n                ans+=(1LL*dp1[i-1][j]*dp2[i+1][((j%10)*10)+j/10])%mod;\\n                ans%=mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp1(n,vector<int>(100,0)),dp2(n,vector<int>(100,0));\\n        vector<int>cnt(10,0);\\n        cnt[s[0]-\\'0\\']=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<100;j++) dp1[i][j]=dp1[i-1][j];\\n            for(int j=0;j<10;j++) dp1[i][j*10+(s[i]-\\'0\\')]+=cnt[j];\\n            cnt[s[i]-\\'0\\']++;\\n        }\\n        cnt.clear();\\n        cnt.resize(10,0);\\n        cnt[s[n-1]-\\'0\\']=1;\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<100;j++) dp2[i][j]=dp2[i+1][j];\\n            for(int j=0;j<10;j++) dp2[i][(s[i]-\\'0\\')*10+j]+=cnt[j];\\n            cnt[s[i]-\\'0\\']++;\\n        }\\n        int ans=0,mod=1e9+7;\\n        for(int i=2;i<n-2;i++){\\n            for(int j=0;j<100;j++){\\n                ans+=(1LL*dp1[i-1][j]*dp2[i+1][((j%10)*10)+j/10])%mod;\\n                ans%=mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835743,
                "title": "very-naive-o-n-solution",
                "content": "# Intuition\\nThe intuition: we keep open a set of machines which look hungrily for letters. Starting out the machines have no state and will accept any letter, once they accept one letter char they take on a partial state (0, char), and will accept any letter. The next time they encounter a letter char\\' they transition to state (1, (char, char\\')) and will again accept any letter. Upon the third letter of any type they transition to state (3, (char, char\\')) and will only accept only char\\'. And so on. Once they have consumed an entire palindrome 1 is added to the count. \\n\\nKeeping some kind of class structure or array for all of these machines is costly in space and costly to update in time, but because our vocabulary of letters is just [0-9] it is relatively cheap to just keep a dictionary of the number of machines in each state, which is what we do with the dictionary d.\\n\\n# Approach\\nPretty much exactly the same as the intuition section. The dictionary d[i][k] keeps track of the number of machines in state (i, k) in the above discussion. \\n\\n# Complexity\\n- Time complexity:\\nThere are a maximum of 10 keys for d[0], 10^2 for d[1], d[2]. So a maximum of 312 or so operations are performed for each character (including the if statement). The complexity is thus O(n).\\n\\n- Space complexity:\\nO(1), the only significant space is taken up by the dictionary. \\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        p = (10**9) + 7\\n        count = 0\\n        d = [defaultdict(lambda:0) for j in range(4)]\\n        for ind, i in enumerate(s):\\n            count += d[3][i]\\n            for l in d[2].keys():\\n                if l[1] == i:\\n                    d[3][l[0]] += d[2][l]\\n            for k in d[1].keys():\\n                d[2][k] += d[1][k]\\n            for j in d[0].keys():\\n                d[1][(j,i)] += d[0][j]\\n            d[0][i] += 1\\n        return (count % p)\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        p = (10**9) + 7\\n        count = 0\\n        d = [defaultdict(lambda:0) for j in range(4)]\\n        for ind, i in enumerate(s):\\n            count += d[3][i]\\n            for l in d[2].keys():\\n                if l[1] == i:\\n                    d[3][l[0]] += d[2][l]\\n            for k in d[1].keys():\\n                d[2][k] += d[1][k]\\n            for j in d[0].keys():\\n                d[1][(j,i)] += d[0][j]\\n            d[0][i] += 1\\n        return (count % p)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792193,
                "title": "explained-python-solution-o-n",
                "content": "# Solution:\\n\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        MOD = 1_000_000_007\\n        n = len(s)\\n        pref = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        suff = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        \\n        count = [0] * 10\\n        for i in range(n):\\n            ch_idx = int(s[i])\\n            if i > 0:\\n                for x in range(10):\\n                    for y in range(10):\\n                        pref[i][x][y] = pref[i - 1][x][y]\\n                        if y == ch_idx:\\n                            pref[i][x][y] += count[x]\\n            count[ch_idx] += 1\\n            \\n        count = [0] * 10\\n        for i in range(n - 1, -1, -1):\\n            ch_idx = int(s[i])\\n            if i < n - 1:\\n                for x in range(10):\\n                    for y in range(10):\\n                        suff[i][x][y] = suff[i + 1][x][y]\\n                        if x == ch_idx:\\n                            suff[i][x][y] += count[y]\\n            count[ch_idx] += 1\\n            \\n        ans = 0\\n        for i in range(2, n - 2):\\n            for x in range(10):\\n                for y in range(10):\\n                    ans += pref[i-1][x][y] * suff[i+1][y][x]\\n                    ans %= MOD\\n        return ans\\n```\\n\\n# Explanation:\\n\\nThis solution uses the concept of dynamic programming and prefix and suffix computation to count the number of palindromic subsequences of a given string. The basic idea is to build two 3D arrays (pref and suff) that capture the frequency of digit pairs (represented by x and y) in the prefix and suffix of the string at each position, respectively.\\n\\nThis solution operates under the idea that for a subsequence of length 5 to be palindromic, it must be in the form xyzyx. Here, the 1st and 5th, 2nd and 4th characters must be the same to fulfill the condition of being a palindrome.\\n\\nHere\\'s the step-by-step explanation:\\n\\n1. **Initialization**: The code first initializes the variables, where \\'n\\' is the length of the string, \\'pref\\' and \\'suff\\' are 3D arrays for storing prefix and suffix computations, and \\'count\\' is used to track the frequency of digits. \\'MOD\\' is the modulo constraint.\\n\\n2. **Prefix calculation**: The code then enters the first main loop, which calculates the prefix arrays. It iterates over every character in the string. For each character (ch_idx), it increments the count of that character. Then, for every pair of digits (x and y), it adds the current count of \\'x\\' to pref[i][x][y] if \\'y\\' equals the current character (ch_idx). This will keep track of how many times the sequence xy appears up to the ith position.\\n\\n3. **Suffix calculation**: This part is similar to the prefix calculation, but iterates in reverse order and checks if \\'x\\' equals the current character (ch_idx). This will keep track of how many times the sequence yx appears from the ith position to the end.\\n\\n4. **Combining prefixes and suffixes**: The last loop computes the final result. For each position in the string (except for the first two and last two positions), it multiplies the count of each possible pair of digits (xy) in the prefix before the current position by the count of the reversed pair (yx) in the suffix after the current position, then adds the product to the final result (\\'ans\\'). This process is equivalent to counting all the palindromic subsequences xyzyx, where z can be any digit.\\n\\n5. **Return value**: The function finally returns the total count of all such palindromic subsequences modulo 1_000_000_007. This is to prevent overflow as the count can be very large.\\n\\nBy using the prefix and suffix approach, the algorithm effectively reduces the problem\\'s time complexity to O(n), which is much faster than brute-forcing through all possible subsequences. The space complexity is also reasonable at O(n) due to the storage of the prefix and suffix arrays.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        MOD = 1_000_000_007\\n        n = len(s)\\n        pref = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        suff = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        \\n        count = [0] * 10\\n        for i in range(n):\\n            ch_idx = int(s[i])\\n            if i > 0:\\n                for x in range(10):\\n                    for y in range(10):\\n                        pref[i][x][y] = pref[i - 1][x][y]\\n                        if y == ch_idx:\\n                            pref[i][x][y] += count[x]\\n            count[ch_idx] += 1\\n            \\n        count = [0] * 10\\n        for i in range(n - 1, -1, -1):\\n            ch_idx = int(s[i])\\n            if i < n - 1:\\n                for x in range(10):\\n                    for y in range(10):\\n                        suff[i][x][y] = suff[i + 1][x][y]\\n                        if x == ch_idx:\\n                            suff[i][x][y] += count[y]\\n            count[ch_idx] += 1\\n            \\n        ans = 0\\n        for i in range(2, n - 2):\\n            for x in range(10):\\n                for y in range(10):\\n                    ans += pref[i-1][x][y] * suff[i+1][y][x]\\n                    ans %= MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672060,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int countPalindromes(String s) {\\n    int mod = 1000_000_007, n = s.length(), ans = 0, cnts[] = new int[10],\\n    pre[][][] = new int[n][10][10], suf[][][] = new int[n][10][10];\\n    for (int i = 0; i < n; i++) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i > 0)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    Arrays.fill(cnts, 0);\\n    for (int i = n - 1; i >= 0; i--) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i < n - 1)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    suf[i][j][k] = suf[i + 1][j][k];\\n                    if (k == c) suf[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    for (int i = 2; i < n - 2; i++)\\n        for (int j = 0; j < 10; j++)\\n            for (int k = 0; k < 10; k++)\\n                ans = (int)((ans + 1L * pre[i - 1][j][k] * suf[i + 1][j][k]) % mod);\\n    return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int countPalindromes(String s) {\\n    int mod = 1000_000_007, n = s.length(), ans = 0, cnts[] = new int[10],\\n    pre[][][] = new int[n][10][10], suf[][][] = new int[n][10][10];\\n    for (int i = 0; i < n; i++) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i > 0)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    pre[i][j][k] = pre[i - 1][j][k];\\n                    if (k == c) pre[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    Arrays.fill(cnts, 0);\\n    for (int i = n - 1; i >= 0; i--) {\\n        int c = s.charAt(i) - \\'0\\';\\n        if (i < n - 1)\\n            for (int j = 0; j < 10; j++)\\n                for (int k = 0; k < 10; k++) {\\n                    suf[i][j][k] = suf[i + 1][j][k];\\n                    if (k == c) suf[i][j][k] += cnts[j];\\n                }\\n        cnts[c]++;\\n    }\\n    for (int i = 2; i < n - 2; i++)\\n        for (int j = 0; j < 10; j++)\\n            for (int k = 0; k < 10; k++)\\n                ans = (int)((ans + 1L * pre[i - 1][j][k] * suf[i + 1][j][k]) % mod);\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600480,
                "title": "java-solution-easy-to-read-commented",
                "content": "\\n# Complexity \\n(ignore constants for big O)\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //allowed length of palindrom 5 \\n    static int MOD = 1000000007;\\n    public int countPalindromes(String s) {\\n        Integer[][][][] memo = new Integer[s.length()][10][10][5];\\n        //index can be till string length, 10 digits so use 10 in for first and second character and 5 is only allowed length.\\n        return solve(s, 0, 0, 0, 0, memo);\\n    }\\n\\n    int solve(String s, int index, int first, int second, int length, Integer[][][][] memo) {\\n        if(length == 5) {\\n            return 1;//palindrome achived count it\\n        }\\n        if(index == s.length()) {\\n            return 0;//not possible to achive palindrome\\n        }\\n        if(memo[index][first][second][length] != null) {\\n            return memo[index][first][second][length];\\n        }\\n        int value = s.charAt(index) - \\'0\\';\\n        \\n        int include = 0;\\n        if(length == 0) {\\n            include = solve(s, index + 1, value, second, length + 1, memo);//will be matched with 5th char\\n        }\\n        else if(length == 1) {\\n            include = solve(s, index + 1, first, value, length + 1, memo);//will be matched with 4th char\\n        }\\n        else if(length == 2) {\\n            include = solve(s, index + 1, first, second, length + 1, memo);// middle char of 5 letter palindrom, doe s not need matching\\n        }\\n        else if(length == 3 && value == second) {//check if same as second char\\n            include = solve(s, index + 1, first, second, length + 1, memo);\\n        }\\n        else if(length == 4 && value == first) {//check if same as first char\\n            include = solve(s, index + 1, first, value, length + 1, memo);\\n        }\\n        \\n        //ignore the current char and move to next char like we do not subsequences matching\\n        int exclude = solve(s, index + 1, first, second, length, memo);\\n\\n        int answer = (include % MOD)  + (exclude % MOD);//add both results\\n        return memo[index][first][second][length] = answer % MOD;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    //allowed length of palindrom 5 \\n    static int MOD = 1000000007;\\n    public int countPalindromes(String s) {\\n        Integer[][][][] memo = new Integer[s.length()][10][10][5];\\n        //index can be till string length, 10 digits so use 10 in for first and second character and 5 is only allowed length.\\n        return solve(s, 0, 0, 0, 0, memo);\\n    }\\n\\n    int solve(String s, int index, int first, int second, int length, Integer[][][][] memo) {\\n        if(length == 5) {\\n            return 1;//palindrome achived count it\\n        }\\n        if(index == s.length()) {\\n            return 0;//not possible to achive palindrome\\n        }\\n        if(memo[index][first][second][length] != null) {\\n            return memo[index][first][second][length];\\n        }\\n        int value = s.charAt(index) - \\'0\\';\\n        \\n        int include = 0;\\n        if(length == 0) {\\n            include = solve(s, index + 1, value, second, length + 1, memo);//will be matched with 5th char\\n        }\\n        else if(length == 1) {\\n            include = solve(s, index + 1, first, value, length + 1, memo);//will be matched with 4th char\\n        }\\n        else if(length == 2) {\\n            include = solve(s, index + 1, first, second, length + 1, memo);// middle char of 5 letter palindrom, doe s not need matching\\n        }\\n        else if(length == 3 && value == second) {//check if same as second char\\n            include = solve(s, index + 1, first, second, length + 1, memo);\\n        }\\n        else if(length == 4 && value == first) {//check if same as first char\\n            include = solve(s, index + 1, first, value, length + 1, memo);\\n        }\\n        \\n        //ignore the current char and move to next char like we do not subsequences matching\\n        int exclude = solve(s, index + 1, first, second, length, memo);\\n\\n        int answer = (include % MOD)  + (exclude % MOD);//add both results\\n        return memo[index][first][second][length] = answer % MOD;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572753,
                "title": "faster-than-100-python-implementation-using-numpy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe implement the prefix/suffix solution in numpy.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe build a running \"bag\" of characters:\\n- `bag.singles` -- `bag.singles[n]` is the number of times n appears in the list\\n- `bag.duples` -- An array of shape (10,10) where `bag.duples[n, m]` counts the number of subsequences n, m.\\n- `bag.append(n)` -- Add a character to the end of the list. Adjust singles and duples accordingly.\\n- `bag.pop0(n)` -- Remove a character from the beginning of the list. Adjust singles and duples accordingly.\\n\\nWe will have a `before_bag` and an `after_bag` to describe the list of characters before and after the current character.\\n\\n#### Finding the number of palindromes centered on the current character is a one-liner!\\n- `(after_bag.duples * before_bag.duples.T).sum()`\\n\\n# Complexity\\n- Time complexity: O(100n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(100)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        after_bag, before_bag = Bag(), Bag()\\n        for c in s:\\n            after_bag.append(int(c))\\n        cnt = 0\\n        for c in s:\\n            n = int(c)\\n            after_bag.pop0(n)\\n            cnt += (after_bag.duples * before_bag.duples.T).sum()\\n            before_bag.append(n)\\n            cnt = int(cnt) % (10**9 + 7)\\n        return cnt\\n\\nclass Bag:\\n    def __init__(self):\\n        self.singles = np.zeros(10)\\n        self.duples =  np.zeros((10,10))\\n\\n    def append(self, n):\\n        self.duples[:, n] += self.singles\\n        self.singles[n] += 1\\n\\n    def pop0(self, n):\\n        self.singles[n] -= 1\\n        self.duples[n, :] -= self.singles\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        after_bag, before_bag = Bag(), Bag()\\n        for c in s:\\n            after_bag.append(int(c))\\n        cnt = 0\\n        for c in s:\\n            n = int(c)\\n            after_bag.pop0(n)\\n            cnt += (after_bag.duples * before_bag.duples.T).sum()\\n            before_bag.append(n)\\n            cnt = int(cnt) % (10**9 + 7)\\n        return cnt\\n\\nclass Bag:\\n    def __init__(self):\\n        self.singles = np.zeros(10)\\n        self.duples =  np.zeros((10,10))\\n\\n    def append(self, n):\\n        self.duples[:, n] += self.singles\\n        self.singles[n] += 1\\n\\n    def pop0(self, n):\\n        self.singles[n] -= 1\\n        self.duples[n, :] -= self.singles\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519585,
                "title": "c-easy-to-understand-precomputation-prefix-sums",
                "content": "# Intuition\\nSince the length of palindromic subsequence is 5, we iterate on all indices with the ith index element as the middle element of the palindrome then calculate all possible first, second, fourth and fifth digits, where fifth digit is same as first and fourth digit is same as second digit.\\nThis can be optimally done by precomputing a prefix and postfix array which computes all j, k pair of subsequences ending at index i.\\n# Approach\\n\\nprecompute pair of j, k ending at i for both prefix and postfix\\n# Complexity\\n- Time complexity:\\nO(n * 81)\\n- Space complexity:\\nO(n * 81)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[10005][10][10];\\n    long long dp2[10005][10][10];\\n    const long long MOD = 1e9 + 7;\\n    \\n    void preprocess(string& s) {\\n        int n = s.length();\\n        vector<long long> cnt(10, 0);\\n        cnt[s[0] - \\'0\\']++;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == s[i] - \\'0\\') {\\n                        dp[i][j][k] = dp[i-1][j][k] + cnt[j];\\n                    } else {\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                    }\\n                }\\n            }\\n            cnt[s[i] - \\'0\\']++;\\n        }\\n        \\n        cnt = std::vector<long long>(10, 0);\\n        \\n        cnt[s[n - 1] - \\'0\\']++;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == s[i] - \\'0\\') {\\n                        dp2[i][k][j] = dp2[i+1][k][j] + cnt[j];\\n                    } else {\\n                        dp2[i][k][j] = dp2[i+1][k][j];\\n                    }\\n                }\\n            }\\n            cnt[s[i] - \\'0\\']++;\\n        }\\n    }\\n    \\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        preprocess(s);\\n        \\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (i - 1 >= 0 && i + 1 < n) {\\n                        ans = (ans%MOD + (dp[i - 1][j][k]%MOD * dp2[i+1][k][j]%MOD)%MOD)%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[10005][10][10];\\n    long long dp2[10005][10][10];\\n    const long long MOD = 1e9 + 7;\\n    \\n    void preprocess(string& s) {\\n        int n = s.length();\\n        vector<long long> cnt(10, 0);\\n        cnt[s[0] - \\'0\\']++;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == s[i] - \\'0\\') {\\n                        dp[i][j][k] = dp[i-1][j][k] + cnt[j];\\n                    } else {\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                    }\\n                }\\n            }\\n            cnt[s[i] - \\'0\\']++;\\n        }\\n        \\n        cnt = std::vector<long long>(10, 0);\\n        \\n        cnt[s[n - 1] - \\'0\\']++;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == s[i] - \\'0\\') {\\n                        dp2[i][k][j] = dp2[i+1][k][j] + cnt[j];\\n                    } else {\\n                        dp2[i][k][j] = dp2[i+1][k][j];\\n                    }\\n                }\\n            }\\n            cnt[s[i] - \\'0\\']++;\\n        }\\n    }\\n    \\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        preprocess(s);\\n        \\n        long long ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (i - 1 >= 0 && i + 1 < n) {\\n                        ans = (ans%MOD + (dp[i - 1][j][k]%MOD * dp2[i+1][k][j]%MOD)%MOD)%MOD;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442311,
                "title": "javascript-easy-dp-solution-with-comments-and-explanation",
                "content": "\\n# Code\\n```\\nvar countPalindromes = function(s) {\\n    const modulo = 1e9 + 7\\n    let answ = 0\\n\\n    for (let x = 0; x <= 9; x++) {\\n        for (let y = 0; y <= 9; y++) {\\n            // check all possible patterns - 00x00, 01x10, 02x20 ... 98x89, 99x99\\n            const pattern = [x, y, -1, y, x]\\n\\n            // init dynamic programming array\\n            // where dp[0] = 1, empty substring\\n            // dp[1] - number of substring equals \\'x\\'\\n            // dp[2] - number of substring equals \\'xy\\'\\n            // dp[3] - number of substring equals \\'xyN\\' where N - any character in the middle of a palindrom\\n            // dp[4] - number of substring equals \\'xyNy\\'\\n            // dp[5] - number of substring equals \\'xyNyx\\'\\n            const dp = [1, 0, 0, 0, 0, 0]\\n            for (let i = 0; i < s.length; i++) {\\n                for (let j = 5; j >= 1; j--) {\\n                    // if char at s[i] equals to pattern char or this is the middle of a palindrom\\n                    if (s[i] == pattern[j - 1] || j == 3) {\\n                        dp[j] = (dp[j] + dp[j - 1]) % modulo\\n                    }\\n                }\\n            }\\n            answ = (answ + dp[5]) % modulo\\n        }\\n    }\\n    return answ\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar countPalindromes = function(s) {\\n    const modulo = 1e9 + 7\\n    let answ = 0\\n\\n    for (let x = 0; x <= 9; x++) {\\n        for (let y = 0; y <= 9; y++) {\\n            // check all possible patterns - 00x00, 01x10, 02x20 ... 98x89, 99x99\\n            const pattern = [x, y, -1, y, x]\\n\\n            // init dynamic programming array\\n            // where dp[0] = 1, empty substring\\n            // dp[1] - number of substring equals \\'x\\'\\n            // dp[2] - number of substring equals \\'xy\\'\\n            // dp[3] - number of substring equals \\'xyN\\' where N - any character in the middle of a palindrom\\n            // dp[4] - number of substring equals \\'xyNy\\'\\n            // dp[5] - number of substring equals \\'xyNyx\\'\\n            const dp = [1, 0, 0, 0, 0, 0]\\n            for (let i = 0; i < s.length; i++) {\\n                for (let j = 5; j >= 1; j--) {\\n                    // if char at s[i] equals to pattern char or this is the middle of a palindrom\\n                    if (s[i] == pattern[j - 1] || j == 3) {\\n                        dp[j] = (dp[j] + dp[j - 1]) % modulo\\n                    }\\n                }\\n            }\\n            answ = (answ + dp[5]) % modulo\\n        }\\n    }\\n    return answ\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3377709,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\n\\nclass Solution {\\n    LL M = 1e9 + 7 ;\\npublic:\\n    int countPalindromes(string s) {\\n        s = \"#\" + s ;\\n        int n = s.size() ;\\n        auto dp1 = vector<vector<vector<LL>>>(n, vector<vector<LL>>(10, vector<LL>(10))) ;\\n        auto dp2 = vector<vector<vector<LL>>>(n, vector<vector<LL>>(10, vector<LL>(10))) ;\\n        auto count1 = vector<vector<LL>>(n, vector<LL>(10)) ;\\n        auto count2 = vector<vector<LL>>(n+1, vector<LL>(10)) ;\\n        for(int j = 0; j < 10; j++){\\n            for(int i = 1; i < n; i++){\\n                count1[i][j] = count1[i-1][j] ;\\n                if(s[i] == \\'0\\' + j)\\n                    count1[i][j]++ ;\\n            }\\n        }\\n    \\n        for(int j = 0; j < 10; j++){\\n            if(s[n-1] == \\'0\\' + j)\\n                count2[n-1][j] = 1 ;    \\n            for(int i = n-2; i > 0; i--){\\n                count2[i][j] = count2[i+1][j] ;\\n                if(s[i] == \\'0\\' + j)\\n                    count2[i][j]++ ;\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    dp1[i][j][k] = dp1[i-1][j][k] ;\\n                    if(s[i] == \\'0\\' + k)\\n                        dp1[i][j][k] = (dp1[i][j][k] + count1[i-1][j]) % M ;    \\n                }\\n            }\\n        }\\n        \\n        for(int i = n-2; i >= 1; i--){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    dp2[i][j][k] = dp2[i+1][j][k] ;\\n                    if(s[i] == \\'0\\' + j)\\n                        dp2[i][j][k] = (dp2[i][j][k] + count2[i+1][k]) % M ;\\n                }\\n            }\\n        }\\n        \\n        LL ret = 0 ;\\n        for(int i = 3; i <= n-3; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    ret += (dp1[i-1][j][k] * dp2[i+1][k][j] ) % M ;\\n                    ret %= M ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nusing LL = long long ;\\n\\nclass Solution {\\n    LL M = 1e9 + 7 ;\\npublic:\\n    int countPalindromes(string s) {\\n        s = \"#\" + s ;\\n        int n = s.size() ;\\n        auto dp1 = vector<vector<vector<LL>>>(n, vector<vector<LL>>(10, vector<LL>(10))) ;\\n        auto dp2 = vector<vector<vector<LL>>>(n, vector<vector<LL>>(10, vector<LL>(10))) ;\\n        auto count1 = vector<vector<LL>>(n, vector<LL>(10)) ;\\n        auto count2 = vector<vector<LL>>(n+1, vector<LL>(10)) ;\\n        for(int j = 0; j < 10; j++){\\n            for(int i = 1; i < n; i++){\\n                count1[i][j] = count1[i-1][j] ;\\n                if(s[i] == \\'0\\' + j)\\n                    count1[i][j]++ ;\\n            }\\n        }\\n    \\n        for(int j = 0; j < 10; j++){\\n            if(s[n-1] == \\'0\\' + j)\\n                count2[n-1][j] = 1 ;    \\n            for(int i = n-2; i > 0; i--){\\n                count2[i][j] = count2[i+1][j] ;\\n                if(s[i] == \\'0\\' + j)\\n                    count2[i][j]++ ;\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    dp1[i][j][k] = dp1[i-1][j][k] ;\\n                    if(s[i] == \\'0\\' + k)\\n                        dp1[i][j][k] = (dp1[i][j][k] + count1[i-1][j]) % M ;    \\n                }\\n            }\\n        }\\n        \\n        for(int i = n-2; i >= 1; i--){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    dp2[i][j][k] = dp2[i+1][j][k] ;\\n                    if(s[i] == \\'0\\' + j)\\n                        dp2[i][j][k] = (dp2[i][j][k] + count2[i+1][k]) % M ;\\n                }\\n            }\\n        }\\n        \\n        LL ret = 0 ;\\n        for(int i = 3; i <= n-3; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    ret += (dp1[i-1][j][k] * dp2[i+1][k][j] ) % M ;\\n                    ret %= M ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292191,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        auto vl = countLeft(s);\\n        reverse(begin(s), end(s));\\n        auto vr = countLeft(s);\\n        reverse(begin(vr), end(vr));\\n        long long res = 0;\\n        for(int i=0;i<s.size()-1;i++){\\n            for(int j = 0;j<100;j++)\\n                res += vl[i][j] * vr[i+1][j];\\n        }\\n        return res % 1000000007;\\n    }\\n\\n    vector<vector<long long>> countLeft(const string& s){\\n        const int n = s.size();\\n        vector<int> cnt(10, 0);\\n        auto res = vector(n+1, vector(100, 0LL));\\n        for(int i=0;i<n;i++){\\n            res[i+1] = res[i];\\n            int x = s[i] - \\'0\\';\\n            for(int y = 0; y<10; y++){\\n                int val = y*10 + x;\\n                res[i+1][val] += cnt[y];\\n            }\\n            cnt[x]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        auto vl = countLeft(s);\\n        reverse(begin(s), end(s));\\n        auto vr = countLeft(s);\\n        reverse(begin(vr), end(vr));\\n        long long res = 0;\\n        for(int i=0;i<s.size()-1;i++){\\n            for(int j = 0;j<100;j++)\\n                res += vl[i][j] * vr[i+1][j];\\n        }\\n        return res % 1000000007;\\n    }\\n\\n    vector<vector<long long>> countLeft(const string& s){\\n        const int n = s.size();\\n        vector<int> cnt(10, 0);\\n        auto res = vector(n+1, vector(100, 0LL));\\n        for(int i=0;i<n;i++){\\n            res[i+1] = res[i];\\n            int x = s[i] - \\'0\\';\\n            for(int y = 0; y<10; y++){\\n                int val = y*10 + x;\\n                res[i+1][val] += cnt[y];\\n            }\\n            cnt[x]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214076,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst mod = 1e9 + 7;\\nconst countPalindromes = (s) => {\\n    let res = 0, n = s.length, cnt = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        let tot = 0;\\n        for (let j = n - 1; j > i; j--) {\\n            if (s[i] == s[j]) {\\n                res += tot * (j - i - 1);\\n                res %= mod;\\n            }\\n            tot += cnt[s[j] - \\'0\\'];\\n        }\\n        cnt[s[i] - \\'0\\']++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst mod = 1e9 + 7;\\nconst countPalindromes = (s) => {\\n    let res = 0, n = s.length, cnt = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        let tot = 0;\\n        for (let j = n - 1; j > i; j--) {\\n            if (s[i] == s[j]) {\\n                res += tot * (j - i - 1);\\n                res %= mod;\\n            }\\n            tot += cnt[s[j] - \\'0\\'];\\n        }\\n        cnt[s[i] - \\'0\\']++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3208290,
                "title": "c-easy-dp",
                "content": "\\n\\n# Code\\n```\\n#define ll long long\\nll dp[10001][11][11][6];\\nclass Solution {\\npublic:\\n    ll mod;\\n    ll dfs(int ind, int first, int second, int i, string &s) {\\n        if(i == 5) return 1; \\n        if(ind == s.length()) return 0;\\n        if(dp[ind][first][second][i] != -1) return dp[ind][first][second][i];\\n        \\n        ll res = dfs(ind + 1, first, second, i, s);\\n\\n        if(i == 0) {\\n            res += dfs(ind + 1, s[ind] - \\'0\\', second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 1) {\\n            res += dfs(ind + 1, first, s[ind] - \\'0\\', i + 1, s);\\n            res %= mod;\\n        } else if(i == 2) {\\n            res += dfs(ind + 1, first, second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 3) {\\n          \\n            if(s[ind] - \\'0\\' == second) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        } else if(i == 4) {\\n       \\n            if(s[ind] - \\'0\\' == first) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        }\\n        return dp[ind][first][second][i] = res;\\n    }\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof dp); \\n        mod = 1e9 + 7;\\n        return dfs(0, 10, 10, 0, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nll dp[10001][11][11][6];\\nclass Solution {\\npublic:\\n    ll mod;\\n    ll dfs(int ind, int first, int second, int i, string &s) {\\n        if(i == 5) return 1; \\n        if(ind == s.length()) return 0;\\n        if(dp[ind][first][second][i] != -1) return dp[ind][first][second][i];\\n        \\n        ll res = dfs(ind + 1, first, second, i, s);\\n\\n        if(i == 0) {\\n            res += dfs(ind + 1, s[ind] - \\'0\\', second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 1) {\\n            res += dfs(ind + 1, first, s[ind] - \\'0\\', i + 1, s);\\n            res %= mod;\\n        } else if(i == 2) {\\n            res += dfs(ind + 1, first, second, i + 1, s);\\n            res %= mod;\\n        } else if(i == 3) {\\n          \\n            if(s[ind] - \\'0\\' == second) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        } else if(i == 4) {\\n       \\n            if(s[ind] - \\'0\\' == first) {\\n                res += dfs(ind + 1, first, second, i + 1, s);\\n                res %= mod;\\n            }\\n        }\\n        return dp[ind][first][second][i] = res;\\n    }\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof dp); \\n        mod = 1e9 + 7;\\n        return dfs(0, 10, 10, 0, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159184,
                "title": "c-o-10n-4ms-two-pass-optimized-counting",
                "content": "Since there are many elegant O(100n) solutions provided, let\\'s do a constant-time optimization to make it O(10n).\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe can divide the 5 digits subsequence into \\n1. the first two digits,\\n2. the central digit, and\\n3. the last two digits\\n\\nWe can loop through all the possible central digit `nums[i]` and enumerate how many `\"AB\"(A, B = 0..9)` subsequence in ther first `[0..i-1]` elements and how many `\"BA\"` subsequence in `[i+1..n-1]`. \\n\\n$\\\\text{numPalindrome} = \\\\sum_{i=2..n-3}\\\\sum_{A=0..9} \\\\sum_{B=0..9}(\\\\text{Num of \"AB\" in s[0..i-1]})\\\\cdot (\\\\text{Num of \"BA\" in s[0..i-1]})$\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIt\\'s easy to compute the number of 5-palindromic subsequences with central index `i` in $O(10\\\\cdot 10)$ by simply\\n1. creating a `int firstTwo[100]` to store the statistics of \"AB\" in `s[0..i-1]`\\n2. creating a `int lastTwo[100]` to store the statistics of \"BA\" in `s[i+1..n-1]`\\n3. for each central index, compute the sum of `firstTwo[AB]*lastTwo[BA]`\\n4. update `firsTwo`, `lastTwo` when sliding the central index. \\n\\nHowever, if we are given the number of 5-palindromic subsequences `npalindrome` with a central index `i`, can we get that for the central index `i+1` in $O(10)$ instead of trying all the $10\\\\cdot 10$ combinations? It seems like counting all the `10*10` combination of 2-subsequence for each central element `nums[i]` contains repeated work.\\n\\nObserving that when we slide the central index forward for 1 step(`i-1->i`), we are adding a `p = s[i]` to the tail of left subarray and remove a `q = s[i+1]` from the head of the right subarray. The affected `firstTwo` entries are only `Xp`, `X = 0..9`, and the affected `lastTwo` entries are only `qX`, `X = 0..9`. We can\\n1. remove `qX` from the `lastTwo` array for `X = 0..9`. For each `X`, we should decrease the count `lastTwo[qX]` by number of digit `X` in the right subarray(should remove a `q` first).\\n2. For each `qX` removed from the `lastTwo` table, we should decrease the `npalindrome` by `firstTwo[Xq]`.\\n3. Add `Xp` to the `firstTwo` table for each possible `X = 0..9`. For each `X`, we should increase the count `lastTwo[Xp]` by number of `X` in the right subarray(the count before adding \\'p\\').\\n4. For each `Xp` added to the `firstTwo` table, we should add the `npalindrome` by `lastTwo[pX]`.\\n\\nNoticing that we should do the first pass to get the statistics `LastTwo` for `s[2..n-1]` first.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(10\\\\cdot n + 10\\\\cdot n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(10*10)$\\n\\n# Code\\n```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        if (n < 5) return 0;\\n        int lcount[10] = {0}, rcount[10] = {0};\\n        long long firstTwo[100] = {0}, lastTwo[100] = {0};\\n        // count all the possible last two digits for s[2..n-1]\\n        for (int i = n-1; i > 1; --i) {\\n            int first_digit = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                if (rcount[j]) lastTwo[first_digit*10 + j] = (lastTwo[first_digit*10 + j] + rcount[j]) % mod; \\n            }\\n            ++rcount[first_digit];\\n        }\\n\\n        long long res = 0, npalindrome = 0;\\n        lcount[s[0] - \\'0\\'] = 1;\\n        for (int i = 1; i < n-2; ++i) {\\n            // remove s[i+1] from right\\n            int first_digit = s[i+1] - \\'0\\';\\n            --rcount[first_digit];\\n            for (int j = 0; j < 10; ++j) {\\n                if (rcount[j]) {\\n                    // will remove \"rcount[j]\" <first_digit,j> pair\\n                    npalindrome = ((npalindrome - firstTwo[j*10 + first_digit]*rcount[j]) % mod + mod) % mod;\\n                    lastTwo[first_digit*10 + j] = ((lastTwo[first_digit*10 + j] - rcount[j]) % mod + mod) % mod;\\n                }\\n            }\\n            // add s[i] to left\\n            // compute new lcount, firstTwo, number of palindromes\\n            int second_digit = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                if (lcount[j]) {\\n                    firstTwo[j*10 + second_digit] = (firstTwo[j*10 + second_digit] + lcount[j]) % mod;\\n                    if (lastTwo[second_digit*10 + j] != 0) {\\n                        npalindrome = (npalindrome + lcount[j] * lastTwo[second_digit*10 + j]) % mod;\\n                    }\\n                }\\n            }\\n            ++lcount[second_digit];\\n            res = (res + npalindrome) % mod;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\n\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        if (n < 5) return 0;\\n        int lcount[10] = {0}, rcount[10] = {0};\\n        long long firstTwo[100] = {0}, lastTwo[100] = {0};\\n        // count all the possible last two digits for s[2..n-1]\\n        for (int i = n-1; i > 1; --i) {\\n            int first_digit = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                if (rcount[j]) lastTwo[first_digit*10 + j] = (lastTwo[first_digit*10 + j] + rcount[j]) % mod; \\n            }\\n            ++rcount[first_digit];\\n        }\\n\\n        long long res = 0, npalindrome = 0;\\n        lcount[s[0] - \\'0\\'] = 1;\\n        for (int i = 1; i < n-2; ++i) {\\n            // remove s[i+1] from right\\n            int first_digit = s[i+1] - \\'0\\';\\n            --rcount[first_digit];\\n            for (int j = 0; j < 10; ++j) {\\n                if (rcount[j]) {\\n                    // will remove \"rcount[j]\" <first_digit,j> pair\\n                    npalindrome = ((npalindrome - firstTwo[j*10 + first_digit]*rcount[j]) % mod + mod) % mod;\\n                    lastTwo[first_digit*10 + j] = ((lastTwo[first_digit*10 + j] - rcount[j]) % mod + mod) % mod;\\n                }\\n            }\\n            // add s[i] to left\\n            // compute new lcount, firstTwo, number of palindromes\\n            int second_digit = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                if (lcount[j]) {\\n                    firstTwo[j*10 + second_digit] = (firstTwo[j*10 + second_digit] + lcount[j]) % mod;\\n                    if (lastTwo[second_digit*10 + j] != 0) {\\n                        npalindrome = (npalindrome + lcount[j] * lastTwo[second_digit*10 + j]) % mod;\\n                    }\\n                }\\n            }\\n            ++lcount[second_digit];\\n            res = (res + npalindrome) % mod;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095911,
                "title": "c-dp-pre-computation-o-100n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countPalindromes(string s) {\\n        int mod = pow(10,9)+7;\\n        vector<int> count(10, 0);\\n        vector<vector<vector<int>>> dp(10, vector<vector<int>>(10, vector<int>(s.length(), 0)));\\n        int n = s.length();\\n        for(int i=0;i<n;i++){\\n            if(i == 0)\\n            {\\n                count[s[i]-\\'0\\']++;\\n                continue;\\n            }\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    dp[j][k][i] = dp[j][k][i-1];\\n                    if(s[i] - \\'0\\' == k)\\n                        dp[j][k][i] += count[j];\\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n        }\\n        \\n\\nvector<vector<vector<int>>> dp_l(10, vector<vector<int>>(10, vector<int>(s.length(), 0)));\\n        count = vector<int>(10,0);\\n        \\n       for(int i=n-1;i>=0;i--){\\n                if(i == n-1)\\n                {\\n                    count[s[i]-\\'0\\']++;\\n                    continue;\\n                }\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    dp_l[j][k][i] = dp_l[j][k][i+1];\\n                    if(s[i] - \\'0\\' == j){\\n                       \\n                         dp_l[j][k][i] += count[k];\\n                    }\\n                       \\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n        }\\n        \\n        long long int answer = 0;\\n        for(int i=1;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int k = 0;k<10;k++){\\n                    answer = (answer +  ((long long)(dp[j][k][i-1])*(dp_l[k][j][i+1])))%mod;\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countPalindromes(string s) {\\n        int mod = pow(10,9)+7;\\n        vector<int> count(10, 0);\\n        vector<vector<vector<int>>> dp(10, vector<vector<int>>(10, vector<int>(s.length(), 0)));\\n        int n = s.length();\\n        for(int i=0;i<n;i++){\\n            if(i == 0)\\n            {\\n                count[s[i]-\\'0\\']++;\\n                continue;\\n            }\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    dp[j][k][i] = dp[j][k][i-1];\\n                    if(s[i] - \\'0\\' == k)\\n                        dp[j][k][i] += count[j];\\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n        }\\n        \\n\\nvector<vector<vector<int>>> dp_l(10, vector<vector<int>>(10, vector<int>(s.length(), 0)));\\n        count = vector<int>(10,0);\\n        \\n       for(int i=n-1;i>=0;i--){\\n                if(i == n-1)\\n                {\\n                    count[s[i]-\\'0\\']++;\\n                    continue;\\n                }\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    dp_l[j][k][i] = dp_l[j][k][i+1];\\n                    if(s[i] - \\'0\\' == j){\\n                       \\n                         dp_l[j][k][i] += count[k];\\n                    }\\n                       \\n                }\\n            }\\n            count[s[i]-\\'0\\']++;\\n        }\\n        \\n        long long int answer = 0;\\n        for(int i=1;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int k = 0;k<10;k++){\\n                    answer = (answer +  ((long long)(dp[j][k][i-1])*(dp_l[k][j][i+1])))%mod;\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031631,
                "title": "simple-dp-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will first count digits occurences till i\\'th place included .\\nAnd we will make dp for left side counts of pairs of digits and also right side count of pairs of digits .\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*100)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*100)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        if(s.length() < 5) return 0;\\n        int M = 1e9+7;\\n        vector<vector<int>> cntc(s.length(),vector<int>(10,0)); // we will store cnt of alphabets\\n        cntc[0][s[0]-\\'0\\']++;\\n        for(int i=1;i<s.length();i++){\\n            cntc[i] = cntc[i-1];\\n            cntc[i][s[i]-\\'0\\']++;\\n        }\\n        // we have the count of chars inclutding i\\'th char\\n        vector<vector<vector<int>>> dp(s.length(),vector<vector<int>>(10,vector<int>(10,0)));\\n        vector<vector<vector<int>>> dpr(s.length(),vector<vector<int>>(10,vector<int>(10,0)));\\n        for(int i=1;i<s.length();i++){\\n            // for every i we have to count previous chars that is we are finding ways to make\\n            // [0-9] s[i] this pair\\n            dp[i] = dp[i-1];\\n            for(int j=0;j<10;j++){\\n                dp[i][j][s[i]-\\'0\\'] += cntc[i-1][j];\\n                dp[i][j][s[i]-\\'0\\'] %= M;\\n            }\\n        }\\n        for(int i=s.length()-2;i>=0;i--){\\n            // for every i we have to count previous chars that is we are finding ways to make\\n            // [0-9] s[i] this pair\\n            dpr[i] = dpr[i+1];\\n            for(int j=0;j<10;j++){\\n                dpr[i][s[i]-\\'0\\'][j] += (cntc[s.length()-1][j] - cntc[i][j]);\\n                dpr[i][s[i]-\\'0\\'][j] %= M;\\n            }\\n        }\\n        long int ans = 0;\\n        for(int i=2;i<s.length()-2;i++){\\n            // if we take i\\'th \\n            // we will take count of left side digits\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    ans += ((1ll)*dp[i-1][j][k]*dpr[i+1][k][j]);\\n                    ans %= M;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        if(s.length() < 5) return 0;\\n        int M = 1e9+7;\\n        vector<vector<int>> cntc(s.length(),vector<int>(10,0)); // we will store cnt of alphabets\\n        cntc[0][s[0]-\\'0\\']++;\\n        for(int i=1;i<s.length();i++){\\n            cntc[i] = cntc[i-1];\\n            cntc[i][s[i]-\\'0\\']++;\\n        }\\n        // we have the count of chars inclutding i\\'th char\\n        vector<vector<vector<int>>> dp(s.length(),vector<vector<int>>(10,vector<int>(10,0)));\\n        vector<vector<vector<int>>> dpr(s.length(),vector<vector<int>>(10,vector<int>(10,0)));\\n        for(int i=1;i<s.length();i++){\\n            // for every i we have to count previous chars that is we are finding ways to make\\n            // [0-9] s[i] this pair\\n            dp[i] = dp[i-1];\\n            for(int j=0;j<10;j++){\\n                dp[i][j][s[i]-\\'0\\'] += cntc[i-1][j];\\n                dp[i][j][s[i]-\\'0\\'] %= M;\\n            }\\n        }\\n        for(int i=s.length()-2;i>=0;i--){\\n            // for every i we have to count previous chars that is we are finding ways to make\\n            // [0-9] s[i] this pair\\n            dpr[i] = dpr[i+1];\\n            for(int j=0;j<10;j++){\\n                dpr[i][s[i]-\\'0\\'][j] += (cntc[s.length()-1][j] - cntc[i][j]);\\n                dpr[i][s[i]-\\'0\\'][j] %= M;\\n            }\\n        }\\n        long int ans = 0;\\n        for(int i=2;i<s.length()-2;i++){\\n            // if we take i\\'th \\n            // we will take count of left side digits\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    ans += ((1ll)*dp[i-1][j][k]*dpr[i+1][k][j]);\\n                    ans %= M;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025117,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int mul(int a, int b) {\\n        return ((long long) a * b) % mod;\\n    }\\n    void add(int& a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n    }\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        vector<vector<vector<int>>> dpLeft(n, vector<vector<int>> (10, vector<int> (10)));\\n        vector<vector<vector<int>>> dpRight(n, vector<vector<int>> (10, vector<int> (10)));\\n        vector<int> digitFreq(10);\\n        for (int i = 0; i < n; i++) {\\n            int d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == d) {\\n                        add(dpLeft[i][j][d], digitFreq[j]);\\n                    }\\n                    if (i > 0) {\\n                        add(dpLeft[i][j][k], dpLeft[i - 1][j][k]);\\n                    }\\n                }\\n            }\\n            ++digitFreq[d];\\n        }\\n        digitFreq = vector<int> (10);\\n        for (int i = n - 1; i >= 0; i--) {\\n            int d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == d) {\\n                        add(dpRight[i][j][d], digitFreq[j]);\\n                    }\\n                    if (i < n - 1) {\\n                        add(dpRight[i][j][k], dpRight[i + 1][j][k]);\\n                    }\\n                }\\n            }\\n            ++digitFreq[d];\\n        }\\n        int sol = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    add(sol, mul(dpLeft[i - 1][j][k], dpRight[i + 1][j][k]));\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int mul(int a, int b) {\\n        return ((long long) a * b) % mod;\\n    }\\n    void add(int& a, int b) {\\n        a += b;\\n        if (a >= mod) {\\n            a -= mod;\\n        }\\n    }\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        vector<vector<vector<int>>> dpLeft(n, vector<vector<int>> (10, vector<int> (10)));\\n        vector<vector<vector<int>>> dpRight(n, vector<vector<int>> (10, vector<int> (10)));\\n        vector<int> digitFreq(10);\\n        for (int i = 0; i < n; i++) {\\n            int d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == d) {\\n                        add(dpLeft[i][j][d], digitFreq[j]);\\n                    }\\n                    if (i > 0) {\\n                        add(dpLeft[i][j][k], dpLeft[i - 1][j][k]);\\n                    }\\n                }\\n            }\\n            ++digitFreq[d];\\n        }\\n        digitFreq = vector<int> (10);\\n        for (int i = n - 1; i >= 0; i--) {\\n            int d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    if (k == d) {\\n                        add(dpRight[i][j][d], digitFreq[j]);\\n                    }\\n                    if (i < n - 1) {\\n                        add(dpRight[i][j][k], dpRight[i + 1][j][k]);\\n                    }\\n                }\\n            }\\n            ++digitFreq[d];\\n        }\\n        int sol = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    add(sol, mul(dpLeft[i - 1][j][k], dpRight[i + 1][j][k]));\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988446,
                "title": "c-solution-digit-counts-time-o-100-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string a) {\\n        int n = a.size();\\n        if(n<5) return 0;\\n        long long ans =0 , mod = 1e9+7;\\n        vector<vector<int>> rightCounts(n,vector<int> (10,0)), toAdd(10,vector<int>(10,0));\\n        vector<vector<long long>> leftCounts(10,vector<long long> (10,0));\\n        unordered_map<int,int> mp;\\n        for(int i=n-2;i>=0;i--){\\n            rightCounts[i] = rightCounts[i+1];\\n            rightCounts[i][a[i+1]-\\'0\\']++;\\n        }\\n        for(int i=2;i<n-2;i++){\\n            mp[a[i-2]-\\'0\\']++;\\n            for(auto j:mp) toAdd[j.first][a[i-1]-\\'0\\']+=j.second;\\n            for(int x=0;x<10;x++) for(int y=0;y<10;y++) leftCounts[x][y] += toAdd[x][y];\\n            for(int j=0;j<10;j++){\\n                ans += rightCounts[i+1][j]*leftCounts[j][a[i+1]-\\'0\\'];\\n                ans %= mod;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(100*N)\\n\\n- Space complexity: O(N)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string a) {\\n        int n = a.size();\\n        if(n<5) return 0;\\n        long long ans =0 , mod = 1e9+7;\\n        vector<vector<int>> rightCounts(n,vector<int> (10,0)), toAdd(10,vector<int>(10,0));\\n        vector<vector<long long>> leftCounts(10,vector<long long> (10,0));\\n        unordered_map<int,int> mp;\\n        for(int i=n-2;i>=0;i--){\\n            rightCounts[i] = rightCounts[i+1];\\n            rightCounts[i][a[i+1]-\\'0\\']++;\\n        }\\n        for(int i=2;i<n-2;i++){\\n            mp[a[i-2]-\\'0\\']++;\\n            for(auto j:mp) toAdd[j.first][a[i-1]-\\'0\\']+=j.second;\\n            for(int x=0;x<10;x++) for(int y=0;y<10;y++) leftCounts[x][y] += toAdd[x][y];\\n            for(int j=0;j<10;j++){\\n                ans += rightCounts[i+1][j]*leftCounts[j][a[i+1]-\\'0\\'];\\n                ans %= mod;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974116,
                "title": "python-another-o-100n-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        memo = [defaultdict(int), defaultdict(int), [defaultdict(int) for _ in range(10)], [defaultdict(int) for _ in range(10)]]\\n        out = 0\\n        for c in s:\\n            for k in memo[3][int(c)]:\\n                out += memo[3][int(c)][k]\\n            for k in memo[2][int(c)]:\\n                memo[3][int(k[0])][k] += memo[2][int(c)][k]\\n            for k in memo[1]:\\n                memo[2][int(k[1])][k] += memo[1][k]\\n            for k in memo[0]:\\n                memo[1][k+c] += memo[0][k]\\n            memo[0][c] += 1\\n        return out % (10**9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        memo = [defaultdict(int), defaultdict(int), [defaultdict(int) for _ in range(10)], [defaultdict(int) for _ in range(10)]]\\n        out = 0\\n        for c in s:\\n            for k in memo[3][int(c)]:\\n                out += memo[3][int(c)][k]\\n            for k in memo[2][int(c)]:\\n                memo[3][int(k[0])][k] += memo[2][int(c)][k]\\n            for k in memo[1]:\\n                memo[2][int(k[1])][k] += memo[1][k]\\n            for k in memo[0]:\\n                memo[1][k+c] += memo[0][k]\\n            memo[0][c] += 1\\n        return out % (10**9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930230,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_palindromes(s: String) -> i32 {\\n        const PALINDROME_LENGTH: usize = 5;\\n        const MODULO: i32 = 1_000_000_007;\\n\\n        let mut total_palindromes_with_length_five = 0;\\n\\n        for first in 0..=9 {\\n            for second in 0..=9 {\\n                let palindrome = [first, second, 0, second, first];\\n                let mut memo = [0, 0, 0, 0, 0, 1];\\n\\n                for i in 0..s.len() {\\n                    for n in 0..PALINDROME_LENGTH {\\n                        let digit = s.as_bytes()[i] - b\\'0\\';\\n                        if digit == palindrome[n] || n == 2 {\\n                            memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                        }\\n                    }\\n                }\\n                total_palindromes_with_length_five = (total_palindromes_with_length_five + memo[0]) % MODULO;\\n            }\\n        }\\n        total_palindromes_with_length_five\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_palindromes(s: String) -> i32 {\\n        const PALINDROME_LENGTH: usize = 5;\\n        const MODULO: i32 = 1_000_000_007;\\n\\n        let mut total_palindromes_with_length_five = 0;\\n\\n        for first in 0..=9 {\\n            for second in 0..=9 {\\n                let palindrome = [first, second, 0, second, first];\\n                let mut memo = [0, 0, 0, 0, 0, 1];\\n\\n                for i in 0..s.len() {\\n                    for n in 0..PALINDROME_LENGTH {\\n                        let digit = s.as_bytes()[i] - b\\'0\\';\\n                        if digit == palindrome[n] || n == 2 {\\n                            memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                        }\\n                    }\\n                }\\n                total_palindromes_with_length_five = (total_palindromes_with_length_five + memo[0]) % MODULO;\\n            }\\n        }\\n        total_palindromes_with_length_five\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927600,
                "title": "4d-dp-explained-easy-to-understand",
                "content": "\\nPalindromic subsequence of length 5 eg. = \"AB_BA\" the middle character matches with itself so don\\'t care about middle one.\\n\\nWe only care about 1st(A) and 5th(A) charcter and 2nd(B) and 4th (B)character\\n\\nInitially we will choose any two characters from string and any 3rd character(as it is middle char) .\\n\\nBut before choosing 4th character we will match it with 2nd character that we\\'ve already choosen if it matches then we will choose it otherwise we will skip it. Similarly for 5th character we will match with 1st character.\\n\\nTC - O(N * 6 * 10 * 10)\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1e9 + 7;\\npublic:\\n    int dp[10001][6][10][10];\\n    int countPalindromes(int idx, int len, int A, int B, string &s){\\n        if(len == 5)return 1;\\n        if(idx == s.size())return 0;\\n\\n        if(dp[idx][len][A][B] != -1)return dp[idx][len][A][B];\\n\\n        int dontTake = countPalindromes(idx + 1, len, A, B, s);\\n        int take = 0;\\n\\n        if(len == 0){\\n            take = countPalindromes(idx + 1, len + 1, s[idx] - \\'0\\', B, s);\\n        }\\n        else if(len == 1){\\n            take = countPalindromes(idx + 1, len + 1, A, s[idx] - \\'0\\', s);\\n        }\\n        else if(len == 2){\\n            take = countPalindromes(idx + 1, len + 1, A, B, s);\\n        }\\n        else if(len == 3){\\n            if(s[idx] - \\'0\\' == B)take = countPalindromes(idx + 1, len + 1, A, B, s);\\n        }\\n        else if(len == 4){\\n            if(s[idx] - \\'0\\' == A)take = countPalindromes(idx + 1, len + 1, A, B, s);\\n        }\\n        return dp[idx][len][A][B] = (dontTake + take) % MOD;\\n    }\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof dp);\\n\\n        return countPalindromes(0, 0, 0, 0, s);\\n    }\\n};\\n```\\nPlease UPVOTE if you found it helpful!\\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1e9 + 7;\\npublic:\\n    int dp[10001][6][10][10];\\n    int countPalindromes(int idx, int len, int A, int B, string &s){\\n        if(len == 5)return 1;\\n        if(idx == s.size())return 0;\\n\\n        if(dp[idx][len][A][B] != -1)return dp[idx][len][A][B];\\n\\n        int dontTake = countPalindromes(idx + 1, len, A, B, s);\\n        int take = 0;\\n\\n        if(len == 0){\\n            take = countPalindromes(idx + 1, len + 1, s[idx] - \\'0\\', B, s);\\n        }\\n        else if(len == 1){\\n            take = countPalindromes(idx + 1, len + 1, A, s[idx] - \\'0\\', s);\\n        }\\n        else if(len == 2){\\n            take = countPalindromes(idx + 1, len + 1, A, B, s);\\n        }\\n        else if(len == 3){\\n            if(s[idx] - \\'0\\' == B)take = countPalindromes(idx + 1, len + 1, A, B, s);\\n        }\\n        else if(len == 4){\\n            if(s[idx] - \\'0\\' == A)take = countPalindromes(idx + 1, len + 1, A, B, s);\\n        }\\n        return dp[idx][len][A][B] = (dontTake + take) % MOD;\\n    }\\n    int countPalindromes(string s) {\\n        memset(dp, -1, sizeof dp);\\n\\n        return countPalindromes(0, 0, 0, 0, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923828,
                "title": "c-dp",
                "content": "# Intuition\\nPerform forward and backward count for possible cases. Multiply to get the answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(100n)$$\\n\\n- Space complexity:\\n$$O(100n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        const int MOD = (int)(1E9 + 7);\\n        int len = s.length();\\n        vector<vector<int>> dp1(len, vector<int>(10));\\n        vector<vector<vector<int>>> cnt_forward(len, vector<vector<int>>(10, vector<int>(10)));\\n        vector<vector<int>> dp2(len, vector<int>(10));\\n        vector<vector<vector<int>>> cnt_backward(len, vector<vector<int>>(10, vector<int>(10)));\\n        for (int i = 0; i < len; ++i) {\\n            if (i > 0) {\\n                for (int j = 0; j < 10; ++j) {\\n                    for (int k = 0; k < 10; ++k) {\\n                        cnt_forward[i][j][k] = cnt_forward[i - 1][j][k];\\n                    }\\n                }\\n                for (int j = 0; j < 10; ++j) {\\n                    dp1[i][j] = dp1[i - 1][j];\\n                    cnt_forward[i][j][s[i] - \\'0\\'] += dp1[i - 1][j];\\n                }\\n            }\\n            ++dp1[i][s[i] - \\'0\\'];\\n        }\\n        for (int i = len - 1; i >= 0; --i) {\\n            if (i < len - 1) {\\n                for (int j = 0; j < 10; ++j) {\\n                    for (int k = 0; k < 10; ++k) {\\n                        cnt_backward[i][j][k] = cnt_backward[i + 1][j][k];\\n                    }\\n                }\\n                for (int j = 0; j < 10; ++j) {\\n                    dp2[i][j] = dp2[i + 1][j];\\n                    cnt_backward[i][s[i] - \\'0\\'][j] += dp2[i + 1][j];\\n                }\\n            }\\n            ++dp2[i][s[i] - \\'0\\'];\\n        }\\n        int result = 0;\\n        for (int i = 1; i < len - 1; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    result = (result + (cnt_forward[i - 1][j][k] * 1ll * cnt_backward[i + 1][k][j]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        const int MOD = (int)(1E9 + 7);\\n        int len = s.length();\\n        vector<vector<int>> dp1(len, vector<int>(10));\\n        vector<vector<vector<int>>> cnt_forward(len, vector<vector<int>>(10, vector<int>(10)));\\n        vector<vector<int>> dp2(len, vector<int>(10));\\n        vector<vector<vector<int>>> cnt_backward(len, vector<vector<int>>(10, vector<int>(10)));\\n        for (int i = 0; i < len; ++i) {\\n            if (i > 0) {\\n                for (int j = 0; j < 10; ++j) {\\n                    for (int k = 0; k < 10; ++k) {\\n                        cnt_forward[i][j][k] = cnt_forward[i - 1][j][k];\\n                    }\\n                }\\n                for (int j = 0; j < 10; ++j) {\\n                    dp1[i][j] = dp1[i - 1][j];\\n                    cnt_forward[i][j][s[i] - \\'0\\'] += dp1[i - 1][j];\\n                }\\n            }\\n            ++dp1[i][s[i] - \\'0\\'];\\n        }\\n        for (int i = len - 1; i >= 0; --i) {\\n            if (i < len - 1) {\\n                for (int j = 0; j < 10; ++j) {\\n                    for (int k = 0; k < 10; ++k) {\\n                        cnt_backward[i][j][k] = cnt_backward[i + 1][j][k];\\n                    }\\n                }\\n                for (int j = 0; j < 10; ++j) {\\n                    dp2[i][j] = dp2[i + 1][j];\\n                    cnt_backward[i][s[i] - \\'0\\'][j] += dp2[i + 1][j];\\n                }\\n            }\\n            ++dp2[i][s[i] - \\'0\\'];\\n        }\\n        int result = 0;\\n        for (int i = 1; i < len - 1; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    result = (result + (cnt_forward[i - 1][j][k] * 1ll * cnt_backward[i + 1][k][j]) % MOD) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921726,
                "title": "self-explainable-code-pick-not-pick-technique-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFocusing on given palindrome length = 5. We just have to make a observation that:\\nfirst second third second first\\n\\nfirst digit would be equal to last and \\nsecond digit would be equal to second last.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFollowing upper observation along with the classic Take not take approach we can solve this problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*100)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*100)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod ;\\n    vector<vector<vector<vector<long long>>>> dp; \\n    long long countHelper(int i, int palIndex, int first, int second, string &s){\\n        if(palIndex == 5) return 1;\\n        if(i >= s.size()) return 0;\\n        if(dp[i][palIndex][first][second] != -1) return dp[i][palIndex][first][second];\\n\\n        // notTake:\\n        long long notTake = countHelper(i+1, palIndex, first, second, s) % mod;\\n        \\n        // take:\\n        long long take = 0;\\n        if(palIndex == 0){\\n            take = countHelper(i+1, palIndex+1, s[i] - \\'0\\', second, s) % mod;\\n        }\\n        else if(palIndex == 1){\\n            take = countHelper(i+1, palIndex+1, first, s[i] - \\'0\\', s) % mod;\\n        }\\n        else if(palIndex == 2){\\n            take = countHelper(i+1, palIndex+1, first, second, s) % mod;\\n        }\\n        else if(palIndex == 3){\\n            if(s[i] - \\'0\\' == second) \\n                take = countHelper(i+1, palIndex+1, first, second, s) % mod;\\n        }\\n        else if(palIndex == 4){\\n            if(s[i] - \\'0\\' == first) \\n                take = countHelper(i+1, palIndex+1, first, second, s) % mod;\\n        }\\n\\n        return dp[i][palIndex][first][second] = (take + notTake) % mod;\\n    }\\n\\n    int countPalindromes(string s) {\\n        //4 D dp:\\n        long long n = s.size();\\n        mod = 1e9 + 7;\\n        dp = vector<vector<vector<vector<long long>>>> (n+1, vector<vector<vector<long long>>> (6, vector<vector<long long>> (11, vector<long long> (11, -1))));\\n        return countHelper(0, 0, 10, 10, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod ;\\n    vector<vector<vector<vector<long long>>>> dp; \\n    long long countHelper(int i, int palIndex, int first, int second, string &s){\\n        if(palIndex == 5) return 1;\\n        if(i >= s.size()) return 0;\\n        if(dp[i][palIndex][first][second] != -1) return dp[i][palIndex][first][second];\\n\\n        // notTake:\\n        long long notTake = countHelper(i+1, palIndex, first, second, s) % mod;\\n        \\n        // take:\\n        long long take = 0;\\n        if(palIndex == 0){\\n            take = countHelper(i+1, palIndex+1, s[i] - \\'0\\', second, s) % mod;\\n        }\\n        else if(palIndex == 1){\\n            take = countHelper(i+1, palIndex+1, first, s[i] - \\'0\\', s) % mod;\\n        }\\n        else if(palIndex == 2){\\n            take = countHelper(i+1, palIndex+1, first, second, s) % mod;\\n        }\\n        else if(palIndex == 3){\\n            if(s[i] - \\'0\\' == second) \\n                take = countHelper(i+1, palIndex+1, first, second, s) % mod;\\n        }\\n        else if(palIndex == 4){\\n            if(s[i] - \\'0\\' == first) \\n                take = countHelper(i+1, palIndex+1, first, second, s) % mod;\\n        }\\n\\n        return dp[i][palIndex][first][second] = (take + notTake) % mod;\\n    }\\n\\n    int countPalindromes(string s) {\\n        //4 D dp:\\n        long long n = s.size();\\n        mod = 1e9 + 7;\\n        dp = vector<vector<vector<vector<long long>>>> (n+1, vector<vector<vector<long long>>> (6, vector<vector<long long>> (11, vector<long long> (11, -1))));\\n        return countHelper(0, 0, 10, 10, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915398,
                "title": "c-simple-approach",
                "content": "# Intuition\\nThe intuition for this way was that in linear complexity we can find the number of times a string with length=2 occurs in a string\\n\\n# Approach\\n1. We have 5 places in the palindromic substring, if we fix the middle element. For example \"10201\" if we fix 2 , in the left we need number of times \"10\" occurs in left and number of times \"01\" occurs in the right\\n2. Since our strings to be searched are maximum of length 2,  we can have total 100 such strings starting from 00,01,02,..., 99\\n3. initialise left_double of size n*100 , where left[i][j] denotes number of times j occurs if we consider string till index i. j is from 00 to 99\\n4. How to count? \\n    1. left[i][j] = left[i-1][j] //if it occurs till i-1 then also occurs till i\\n    2. if(last dig of j matches with s[i] then we need to count number of times the second last dig occurs in the left)\\n    foreg: 10201     and    i=2 , j=12\\n    here last dig of 12 i.e 2 matches with index 2 , and therefore we now count number of 1\\'s in left \\n5. By using the algorithm in point4 we can also count for rightside of the string\\n6. Now we traverse through the string choosing each index as the centre element , and searching number of times j occurs in left and number of time reverse of j occcurs in right\\nfor eg: 10201 if i=2and j=10 \\nwe count 10 in left and 01 in right \\n\\nHope this helps :)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*100)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*100)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int countPalindromes(string s) {\\n        int n=s.length();\\n        vector<vector<long long> > left_double(n,vector<long long> (100)) , right_double(n , vector<long long> (100));\\n        vector<vector<long long> > leftCnt(n,vector< long long> (10)) , rightCnt(n,vector<long long> (10));\\n        \\n        for(int i=0;i<n;i++){\\n            int i_=n-i-1;\\n            for(int j=0;j<=9;j++){\\n                if(i-1>=0) leftCnt[i][j] = leftCnt[i-1][j];\\n                leftCnt[i][j] += ((s[i]-\\'0\\') == j);\\n                if(i_+1<n) rightCnt[i_][j] = rightCnt[i_+1][j];\\n                rightCnt[i_][j] += ((s[i_]-\\'0\\') == j);       \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int i_ = n-i-1;\\n            for(int j=0;j<100;j++){\\n                //for left double\\n                left_double[i][j] = left_double[i-1][j];\\n                int dig=j%10;\\n                if(dig==(s[i]-\\'0\\')) left_double[i][j]+=leftCnt[i-1][j/10];\\n                left_double[i][j]%=mod;\\n                \\n                //for right double\\n                if(i_+1<n){\\n                    right_double[i_][j] = right_double[i_+1][j];\\n                }\\n                dig=j/10;\\n                if(dig==(s[i_]-\\'0\\')){\\n                    if(i_+1<n) right_double[i_][j]+=rightCnt[i_+1][j%10];\\n                }\\n                right_double[i_][j]%=mod;\\n                \\n            }\\n        }\\n        \\n         \\n        \\n        long long ans=0;\\n        for(int i=1;i<n-1;i++){\\n            for(int j=0;j<100;j++){\\n                string s1;\\n                s1.push_back((j/10)+\\'0\\');\\n                s1.push_back((j%10)+\\'0\\');\\n                string s2=s1;\\n                reverse(s2.begin(),s2.end());\\n                \\n                int x = stoi(s1) , y = stoi(s2);\\n                ans = ( ans + left_double[i-1][x] * right_double[i+1][y])%mod;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int countPalindromes(string s) {\\n        int n=s.length();\\n        vector<vector<long long> > left_double(n,vector<long long> (100)) , right_double(n , vector<long long> (100));\\n        vector<vector<long long> > leftCnt(n,vector< long long> (10)) , rightCnt(n,vector<long long> (10));\\n        \\n        for(int i=0;i<n;i++){\\n            int i_=n-i-1;\\n            for(int j=0;j<=9;j++){\\n                if(i-1>=0) leftCnt[i][j] = leftCnt[i-1][j];\\n                leftCnt[i][j] += ((s[i]-\\'0\\') == j);\\n                if(i_+1<n) rightCnt[i_][j] = rightCnt[i_+1][j];\\n                rightCnt[i_][j] += ((s[i_]-\\'0\\') == j);       \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int i_ = n-i-1;\\n            for(int j=0;j<100;j++){\\n                //for left double\\n                left_double[i][j] = left_double[i-1][j];\\n                int dig=j%10;\\n                if(dig==(s[i]-\\'0\\')) left_double[i][j]+=leftCnt[i-1][j/10];\\n                left_double[i][j]%=mod;\\n                \\n                //for right double\\n                if(i_+1<n){\\n                    right_double[i_][j] = right_double[i_+1][j];\\n                }\\n                dig=j/10;\\n                if(dig==(s[i_]-\\'0\\')){\\n                    if(i_+1<n) right_double[i_][j]+=rightCnt[i_+1][j%10];\\n                }\\n                right_double[i_][j]%=mod;\\n                \\n            }\\n        }\\n        \\n         \\n        \\n        long long ans=0;\\n        for(int i=1;i<n-1;i++){\\n            for(int j=0;j<100;j++){\\n                string s1;\\n                s1.push_back((j/10)+\\'0\\');\\n                s1.push_back((j%10)+\\'0\\');\\n                string s2=s1;\\n                reverse(s2.begin(),s2.end());\\n                \\n                int x = stoi(s1) , y = stoi(s2);\\n                ans = ( ans + left_double[i-1][x] * right_double[i+1][y])%mod;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895591,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    private static final int PALINDROME_LENGTH = 5;\\n    private static final int MODULO = (int) Math.pow(10, 9) + 7;\\n\\n    public int countPalindromes(String input) {\\n        long totalPalindromesWithLengthFive = 0;\\n\\n        for (int first = 0; first <= 9; ++first) {\\n            for (int second = 0; second <= 9; ++second) {\\n\\n                int[] palindrome = {first, second, 0, second, first};\\n                long[] memo = {0, 0, 0, 0, 0, 1};\\n\\n                for (int i = 0; i < input.length(); ++i) {\\n                    for (int n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                        int digit = input.charAt(i) - \\'0\\';\\n                        if (digit == palindrome[n] || n == 2) {\\n                            memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                        }\\n                    }\\n                }\\n                totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n            }\\n        }\\n        return (int) totalPalindromesWithLengthFive;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar countPalindromes = function (input) {\\n    const PALINDROME_LENGTH = 5;\\n    const MODULO = Math.pow(10, 9) + 7;\\n    const ASCII_0 = 48;\\n\\n    let totalPalindromesWithLengthFive = 0;\\n\\n    for (let first = 0; first <= 9; ++first) {\\n        for (let second = 0; second <= 9; ++second) {\\n\\n            const palindrome = [first, second, 0, second, first];\\n            const memo = [0, 0, 0, 0, 0, 1];\\n\\n            for (let i = 0; i < input.length; ++i) {\\n                for (let n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                    let digit = input.codePointAt(i) - ASCII_0;\\n                    if (digit === palindrome[n] || n === 2) {\\n                        memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                    }\\n                }\\n            }\\n            totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n        }\\n    }\\n    return totalPalindromesWithLengthFive;\\n};\\n```\\n**C++**\\n```\\n#include <array>\\n#include <string>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    inline static const int PALINDROME_LENGTH = 5;\\n    inline static const int MODULO = pow(10, 9) + 7;\\n\\npublic:\\n    int countPalindromes(string input) const {\\n        long totalPalindromesWithLengthFive = 0;\\n\\n        for (int first = 0; first <= 9; ++first) {\\n            for (int second = 0; second <= 9; ++second) {\\n\\n                array<int, PALINDROME_LENGTH> palindrome{ first, second, 0, second, first};\\n                array<long, PALINDROME_LENGTH + 1> memo{ 0, 0, 0, 0, 0, 1};\\n\\n                for (int i = 0; i < input.length(); ++i) {\\n                    for (int n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                        int digit = input[i] - \\'0\\';\\n                        if (digit == palindrome[n] || n == 2) {\\n                            memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                        }\\n                    }\\n                }\\n                totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n            }\\n        }\\n        return totalPalindromesWithLengthFive;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n\\n    private static final int PALINDROME_LENGTH = 5;\\n    private static final int MODULO = (int) Math.pow(10, 9) + 7;\\n\\n    public int countPalindromes(String input) {\\n        long totalPalindromesWithLengthFive = 0;\\n\\n        for (int first = 0; first <= 9; ++first) {\\n            for (int second = 0; second <= 9; ++second) {\\n\\n                int[] palindrome = {first, second, 0, second, first};\\n                long[] memo = {0, 0, 0, 0, 0, 1};\\n\\n                for (int i = 0; i < input.length(); ++i) {\\n                    for (int n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                        int digit = input.charAt(i) - \\'0\\';\\n                        if (digit == palindrome[n] || n == 2) {\\n                            memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                        }\\n                    }\\n                }\\n                totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n            }\\n        }\\n        return (int) totalPalindromesWithLengthFive;\\n    }\\n}\\n```\n```\\n/**\\n * @param {string} input\\n * @return {number}\\n */\\nvar countPalindromes = function (input) {\\n    const PALINDROME_LENGTH = 5;\\n    const MODULO = Math.pow(10, 9) + 7;\\n    const ASCII_0 = 48;\\n\\n    let totalPalindromesWithLengthFive = 0;\\n\\n    for (let first = 0; first <= 9; ++first) {\\n        for (let second = 0; second <= 9; ++second) {\\n\\n            const palindrome = [first, second, 0, second, first];\\n            const memo = [0, 0, 0, 0, 0, 1];\\n\\n            for (let i = 0; i < input.length; ++i) {\\n                for (let n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                    let digit = input.codePointAt(i) - ASCII_0;\\n                    if (digit === palindrome[n] || n === 2) {\\n                        memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                    }\\n                }\\n            }\\n            totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n        }\\n    }\\n    return totalPalindromesWithLengthFive;\\n};\\n```\n```\\n#include <array>\\n#include <string>\\nusing namespace std;\\n\\nclass Solution {\\n    \\n    inline static const int PALINDROME_LENGTH = 5;\\n    inline static const int MODULO = pow(10, 9) + 7;\\n\\npublic:\\n    int countPalindromes(string input) const {\\n        long totalPalindromesWithLengthFive = 0;\\n\\n        for (int first = 0; first <= 9; ++first) {\\n            for (int second = 0; second <= 9; ++second) {\\n\\n                array<int, PALINDROME_LENGTH> palindrome{ first, second, 0, second, first};\\n                array<long, PALINDROME_LENGTH + 1> memo{ 0, 0, 0, 0, 0, 1};\\n\\n                for (int i = 0; i < input.length(); ++i) {\\n                    for (int n = 0; n < PALINDROME_LENGTH; ++n) {\\n\\n                        int digit = input[i] - \\'0\\';\\n                        if (digit == palindrome[n] || n == 2) {\\n                            memo[n] = (memo[n] + memo[n + 1]) % MODULO;\\n                        }\\n                    }\\n                }\\n                totalPalindromesWithLengthFive = (totalPalindromesWithLengthFive + memo[0]) % MODULO;\\n            }\\n        }\\n        return totalPalindromesWithLengthFive;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2878708,
                "title": "python3-count-double-digit-patterns-o-100n",
                "content": "[Link to solution](https://leetcode.com/submissions/detail/854778207/)\\n\\n```python\\nclass Solution2:\\n    def countPalindromes(self, s: str) -> int:\\n        \"\"\"The two hints are very useful.\\n\\n        The second hint points out that we should consider each middle digit\\n        when constructing the lenght-five palindrome. Once the middle digit is\\n        set, we need two on the left and two on the right.\\n\\n        The first hint points out that the two digit pattern on the left has no\\n        more than 100 possibilities. This means in the worst case we can iterate\\n        trough all the patterns, find its count on the left, and find its\\n        reverse\\'s count on the right. Then we just need to multiply the two\\n        counts, and we have the total number of length-five palindrome at the\\n        current middle digit.\\n\\n        The problem now has converted to how to compute the counts of all double\\n        digit pattern on the left and on the right. We can use DP to solve this.\\n        \\n        On the left side, each time a new digit is encountered, all the digits\\n        that have been encountered before can pair with the new digit to form\\n        additional double digit patterns. The total number of such additional\\n        double digit patterns is equal to the count of the previous digit.\\n        Thus, if we keep track of the count of single digit, we can easily\\n        compute the counts of all possible double digit pattern up till the\\n        newly encountered digit.\\n\\n        We can do the same on the right by going from right to left. The only\\n        difference is that the additional double digit patterns are formed with\\n        the newly encountered digit at the beginning.\\n\\n        We can precompute the left and right single and double digit conuter.\\n        And then as the middle digit move, we modify the counters as we go.\\n\\n        O(100N), 1354 ms, faster than 85.53%\\n        \"\"\"\\n        N = len(s)\\n        if N < 5:\\n            return 0\\n        lrsdc, lrddc = Counter(), Counter()\\n        for i in range(N - 3):\\n            for k, v in lrsdc.items():\\n                lrddc[k + s[i]] += v\\n            lrsdc[s[i]] += 1\\n        rlsdc, rlddc = Counter(s[-2:]), Counter([s[-2:]])\\n        # go from right to left, consider each digit as the center of the\\n        # palindrome. Find out how many length-five palindrome can be formed\\n        res = 0\\n        for j in range(N - 3, 1, -1):\\n            for dd, v in rlddc.items():\\n                res += lrddc[dd[::-1]] * v\\n            # remove dd ending in s[j - 1] from lrddc\\n            lrsdc[s[j - 1]] -= 1\\n            for k, v in lrsdc.items():\\n                lrddc[k + s[j - 1]] -= v\\n            # add dd starting with s[j] to rlddc\\n            for k, v in rlsdc.items():\\n                rlddc[s[j] + k] += v\\n            rlsdc[s[j]] += 1\\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution2:\\n    def countPalindromes(self, s: str) -> int:\\n        \"\"\"The two hints are very useful.\\n\\n        The second hint points out that we should consider each middle digit\\n        when constructing the lenght-five palindrome. Once the middle digit is\\n        set, we need two on the left and two on the right.\\n\\n        The first hint points out that the two digit pattern on the left has no\\n        more than 100 possibilities. This means in the worst case we can iterate\\n        trough all the patterns, find its count on the left, and find its\\n        reverse\\'s count on the right. Then we just need to multiply the two\\n        counts, and we have the total number of length-five palindrome at the\\n        current middle digit.\\n\\n        The problem now has converted to how to compute the counts of all double\\n        digit pattern on the left and on the right. We can use DP to solve this.\\n        \\n        On the left side, each time a new digit is encountered, all the digits\\n        that have been encountered before can pair with the new digit to form\\n        additional double digit patterns. The total number of such additional\\n        double digit patterns is equal to the count of the previous digit.\\n        Thus, if we keep track of the count of single digit, we can easily\\n        compute the counts of all possible double digit pattern up till the\\n        newly encountered digit.\\n\\n        We can do the same on the right by going from right to left. The only\\n        difference is that the additional double digit patterns are formed with\\n        the newly encountered digit at the beginning.\\n\\n        We can precompute the left and right single and double digit conuter.\\n        And then as the middle digit move, we modify the counters as we go.\\n\\n        O(100N), 1354 ms, faster than 85.53%\\n        \"\"\"\\n        N = len(s)\\n        if N < 5:\\n            return 0\\n        lrsdc, lrddc = Counter(), Counter()\\n        for i in range(N - 3):\\n            for k, v in lrsdc.items():\\n                lrddc[k + s[i]] += v\\n            lrsdc[s[i]] += 1\\n        rlsdc, rlddc = Counter(s[-2:]), Counter([s[-2:]])\\n        # go from right to left, consider each digit as the center of the\\n        # palindrome. Find out how many length-five palindrome can be formed\\n        res = 0\\n        for j in range(N - 3, 1, -1):\\n            for dd, v in rlddc.items():\\n                res += lrddc[dd[::-1]] * v\\n            # remove dd ending in s[j - 1] from lrddc\\n            lrsdc[s[j - 1]] -= 1\\n            for k, v in lrsdc.items():\\n                lrddc[k + s[j - 1]] -= v\\n            # add dd starting with s[j] to rlddc\\n            for k, v in rlsdc.items():\\n                rlddc[s[j] + k] += v\\n            rlsdc[s[j]] += 1\\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878236,
                "title": "iterate-all-possible-prefixes-00-to-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        vector<vector<int>> A(n, vector<int>(10, 0));\\n        vector<vector<int>> B(n, vector<int>(100, 0));\\n        vector<vector<int>> C(n, vector<int>(10, 0));\\n        vector<vector<int>> D(n, vector<int>(100, 0));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                A[i][j] = (int(s[i] - \\'0\\') == j ? 1 : 0) + (i ? A[i - 1][j] : 0);\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0; j < 10; ++j) {\\n                C[i][j] = (int(s[i] - \\'0\\') == j ? 1 : 0) + (i < n - 1 ? C[i + 1][j] : 0);\\n            }\\n        }\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < 100; ++j) {\\n                B[i][j] = B[i - 1][j];\\n                int a = j / 10, b = j % 10;\\n                if (int(s[i] - \\'0\\') == b) {\\n                    B[i][j] += A[i - 1][a];\\n                }\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; --i) {\\n            for (int j = 0; j < 100; ++j) {\\n                D[i][j] = D[i + 1][j];\\n                int a = j / 10, b = j % 10;\\n                if (int(s[i] - \\'0\\') == a) {\\n                    D[i][j] += C[i + 1][b];\\n                }\\n            }\\n        }\\n        vector<int> mirror(100, 0);\\n        for (int i = 0; i < 100; ++i) {\\n            int a = i / 10, b = i % 10;\\n            mirror[i] = b * 10 + a;\\n        }\\n        int ans = 0;\\n        for (int i = 2; i < n - 2; ++i) {\\n            for (int j = 0; j < 100; ++j) {\\n                ans = (0L + ans + 1L * B[i - 1][j] * D[i + 1][mirror[j]]) % int(1e9 + 7);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        vector<vector<int>> A(n, vector<int>(10, 0));\\n        vector<vector<int>> B(n, vector<int>(100, 0));\\n        vector<vector<int>> C(n, vector<int>(10, 0));\\n        vector<vector<int>> D(n, vector<int>(100, 0));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                A[i][j] = (int(s[i] - \\'0\\') == j ? 1 : 0) + (i ? A[i - 1][j] : 0);\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0; j < 10; ++j) {\\n                C[i][j] = (int(s[i] - \\'0\\') == j ? 1 : 0) + (i < n - 1 ? C[i + 1][j] : 0);\\n            }\\n        }\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < 100; ++j) {\\n                B[i][j] = B[i - 1][j];\\n                int a = j / 10, b = j % 10;\\n                if (int(s[i] - \\'0\\') == b) {\\n                    B[i][j] += A[i - 1][a];\\n                }\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; --i) {\\n            for (int j = 0; j < 100; ++j) {\\n                D[i][j] = D[i + 1][j];\\n                int a = j / 10, b = j % 10;\\n                if (int(s[i] - \\'0\\') == a) {\\n                    D[i][j] += C[i + 1][b];\\n                }\\n            }\\n        }\\n        vector<int> mirror(100, 0);\\n        for (int i = 0; i < 100; ++i) {\\n            int a = i / 10, b = i % 10;\\n            mirror[i] = b * 10 + a;\\n        }\\n        int ans = 0;\\n        for (int i = 2; i < n - 2; ++i) {\\n            for (int j = 0; j < 100; ++j) {\\n                ans = (0L + ans + 1L * B[i - 1][j] * D[i + 1][mirror[j]]) % int(1e9 + 7);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869999,
                "title": "swift-only-solution-can-pass-without-tle-one-time-iterator-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn Swift, both DFS or another O(N) solution to product the prefix and suffix count all get TLE to me,\\n\\nThanks for the solution only need 6 size of DP in one iterator (O(100N * 5))\\nhttps://leetcode.com/problems/count-palindromic-subsequences/solutions/2850557/cjavapython3-short-dp/comments/1701859/\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the input constraint, we can limit the pattern by\\n\\n    x in 0...9:\\n        y in 0...9:\\n            pattern = xy_yx\\n\\nfor every pattern\\ncheck each character of string j in 0..<5 indicates the character can contribute dp[j] count when it is the position (5-j) at this pattern\\n\\nhere use the trick is kind of reverse the dp position,\\nappend dummy value `1` at the end for the first character then can share the same logic without check `if j == 0`\\n\\ndry run an example:\\n\\n    pattern: 01_10\\n     string: 01210\\n\\n    i = 0, char: 0\\n    j: 0, dp = [0, 0, 0, 0, 0, 1]\\n    // check is s[i] chould is valid if in position 5 of pattern\\n    // although s[i] == pattern[j], but dp[1] is zero \\n    // means no any combination for \"1_10\", so if we take s[i], \\n    // can\\'t compose a valid palindrome\\n    j: 1, dp = [0, 0, 0, 0, 0, 1]\\n    j: 2, dp = [0, 0, 0, 0, 0, 1]\\n    j: 3, dp = [0, 0, 0, 0, 0, 1]\\n    j: 4, dp = [0, 0, 0, 0, 1, 1]\\n    // s[0] could be the first pattern\\n\\n    same procedure, when i = 1\\n    dp = [0, 0, 0, 1, 1, 1]\\n    i: 2\\n    dp = [0, 0, 1, 1, 1, 1]\\n    i: 3\\n    dp = [0, 1, 1, 1, 1, 1]\\n    i: 4\\n    dp = [1, 1, 1, 1, 1, 1]\\n    // \"01210\" can contribute one composition for one palindromic subsequence\\n\\nIf the stirng is 001210\\nwe will get 2 valid count in position 1\\nso the final dp would be \\n\\n    [2, 2, 2, 2, 2, 1]\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    let mod = 1e9+7\\n    func countPalindromes(_ s: String) -> Int {\\n        countPalindromes(Array(s))\\n    }\\n\\n    func countPalindromes(_ s: [Character]) -> Int {\\n        var count = 0\\n        for i in 0...9 {\\n            for j in 0...9 {\\n                let pattern = \"\\\\(i)\\\\(j)_\\\\(j)\\\\(i)\".map { $0 }\\n                var dp = Array(repeating: 0, count: 5)\\n                dp.append(1) // dummy source for the first index\\n                for char in s {\\n                    for k in 0..<5 {\\n                        if k == 2 || char == pattern[k] {\\n                            dp[k] += dp[k+1]\\n                        }\\n                    }\\n                }\\n                count = (count + dp[0]) % Int(mod)\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    let mod = 1e9+7\\n    func countPalindromes(_ s: String) -> Int {\\n        countPalindromes(Array(s))\\n    }\\n\\n    func countPalindromes(_ s: [Character]) -> Int {\\n        var count = 0\\n        for i in 0...9 {\\n            for j in 0...9 {\\n                let pattern = \"\\\\(i)\\\\(j)_\\\\(j)\\\\(i)\".map { $0 }\\n                var dp = Array(repeating: 0, count: 5)\\n                dp.append(1) // dummy source for the first index\\n                for char in s {\\n                    for k in 0..<5 {\\n                        if k == 2 || char == pattern[k] {\\n                            dp[k] += dp[k+1]\\n                        }\\n                    }\\n                }\\n                count = (count + dp[0]) % Int(mod)\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869482,
                "title": "simple-matrix-solution",
                "content": "```\\nclass Solution {\\n    private static final long mod = 1_000_000_007L;\\n    private long[][] leftSubsequences = new long[10][10];\\n    private long[][] rightSubsequences = new long[10][10];\\n    public int countPalindromes(String s) {\\n        int[] map1 = new int[10];\\n        int n = s.length();\\n        int[] a = new int[n];\\n        for(int i=0;i<n;i++) a[i] = s.charAt(i)-\\'0\\';\\n        for(int i=0;i<n;i++){\\n            for(int p=0;p<=9;p++) rightSubsequences[a[i]][p] = (rightSubsequences[a[i]][p]+map1[p])%mod;\\n            map1[a[i]]++;\\n        }\\n        long answer = 0L;\\n        int[] map2 = new int[10];\\n        for(int i=0;i<n;i++){\\n            map1[a[i]]--;\\n            for(int j=0;j<=9;j++) rightSubsequences[j][a[i]] = Math.floorMod(rightSubsequences[j][a[i]]-map1[j],mod);\\n            answer = (answer+count());\\n            for(int p=0;p<=9;p++) leftSubsequences[a[i]][p] = (leftSubsequences[a[i]][p]+map2[p])%mod;\\n            map2[a[i]]++;\\n        }\\n        return (int)(answer%mod);\\n    }\\n    private long count(){\\n        long sum = 0L;\\n        for(int i=0;i<10;i++){\\n            for(int j=0;j<10;j++){\\n                sum = (sum+leftSubsequences[i][j]*rightSubsequences[j][i]%mod)%mod;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private static final long mod = 1_000_000_007L;\\n    private long[][] leftSubsequences = new long[10][10];\\n    private long[][] rightSubsequences = new long[10][10];\\n    public int countPalindromes(String s) {\\n        int[] map1 = new int[10];\\n        int n = s.length();\\n        int[] a = new int[n];\\n        for(int i=0;i<n;i++) a[i] = s.charAt(i)-\\'0\\';\\n        for(int i=0;i<n;i++){\\n            for(int p=0;p<=9;p++) rightSubsequences[a[i]][p] = (rightSubsequences[a[i]][p]+map1[p])%mod;\\n            map1[a[i]]++;\\n        }\\n        long answer = 0L;\\n        int[] map2 = new int[10];\\n        for(int i=0;i<n;i++){\\n            map1[a[i]]--;\\n            for(int j=0;j<=9;j++) rightSubsequences[j][a[i]] = Math.floorMod(rightSubsequences[j][a[i]]-map1[j],mod);\\n            answer = (answer+count());\\n            for(int p=0;p<=9;p++) leftSubsequences[a[i]][p] = (leftSubsequences[a[i]][p]+map2[p])%mod;\\n            map2[a[i]]++;\\n        }\\n        return (int)(answer%mod);\\n    }\\n    private long count(){\\n        long sum = 0L;\\n        for(int i=0;i<10;i++){\\n            for(int j=0;j<10;j++){\\n                sum = (sum+leftSubsequences[i][j]*rightSubsequences[j][i]%mod)%mod;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869199,
                "title": "basic-technique-practice-3-d-dynamic-programming-python",
                "content": "1- A solution format aiming for details and connections \\n\\nBasically just DP table update, very straightforward in this sense. Onw can first read Part 3 below for analysis and example walkthrough.\\n\\nAnother Problem That can be solved using 3-D DP is: \\n\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)  and [Solution](https://www.youtube.com/watch?v=hPM11Tl2le0&list=PLWmR_uGniCLnBV4hP0ZcCHRrf2CREQ_kJ&index=6;)\\n\\n(Actually if one solves this Stock Buy and Sell Problems, one can deduce solutions for the whole series VERY EASILY,\\nsee [Playlist](https://www.youtube.com/watch?v=z8p13DJqIp0&list=PLWmR_uGniCLnBV4hP0ZcCHRrf2CREQ_kJ;))\\n\\n```\\n# Solution to Leetcode 2484\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        CONST, n, res = 10 ** 9 + 7, len(s), 0\\n        \\n        pre = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        cnts_pre = [[0] * 10 for _ in range(n)]\\n        \\n        # set up the cnts_pre\\n        for i in range(n):\\n            for j in range(10):\\n                if i == 0:\\n                    cnts_pre[i][j] = 1 if int(s[i]) == j else 0\\n                else:\\n                    cnts_pre[i][j] = cnts_pre[i-1][j] + int(int(s[i]) == j)\\n                    \\n        # set up the pre\\n        for i in range(n):\\n            c = int(s[i])\\n            if i > 0:\\n                for j in range(10):\\n                    for k in range(10):\\n                        pre[i][j][k] = pre[i-1][j][k]\\n                        if k == c:\\n                            pre[i][j][k] += cnts_pre[i-1][j]\\n        \\n        suf = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        cnts_suf = [[0] * 10 for _ in range(n)]\\n        \\n        # set up the cnts_suf\\n        for i in range(n-1, -1, -1):\\n            for j in range(10):\\n                if i == n - 1:\\n                    if int(s[i]) == j:\\n                        cnts_suf[i][j] = 1\\n                else:\\n                    cnts_suf[i][j] = cnts_suf[i+1][j] + int(int(s[i]) == j)\\n        \\n        # set up the suf\\n        for i in range(n-1, -1, -1):\\n            c = int(s[i])\\n            if i < n - 1:\\n                for j in range(10):\\n                    for k in range(10):\\n                        suf[i][j][k] = suf[i+1][j][k]\\n                        if j == c:\\n                            suf[i][j][k] += cnts_suf[i+1][k]\\n                            \\n        # do the counting\\n        for i in range(2, n-2):\\n            for j in range(10):\\n                for k in range(10):\\n                    res += pre[i-1][j][k] * suf[i+1][k][j]\\n        \\n        return res % CONST\\n        \\n```\\n\\n2- Video Explanation: [Click Here](https://youtu.be/oTA0oDnU4dQ;)\\n\\n3- Analysis, Summary\\n\\n\"\"\"\\n1. Method: DP, prefix and suffix subsequnces\\n\\n2. Notions and Idea\\n\\nTo compute the number of palindromic subsequences of s having length 5, we just need to consider\\nthe subsquences of format: \"jk*kj\".\\n\\nTwo things to notice:\\n\\n(a) 0 <= i, j <= 9, so the possible combinations of \"jk\" is bounded above by 10 * 10 = 100;\\n(b) we do not need to care about the middie char, as indicated by \"*\".\\n\\n\\n\\npre[i][j][k] := the number of prefixes/subsequences of \"jk\" from the beginning of s up to index i\\n    e.g., pre[i][1][2] means the number of prefixed \"12\" in s[:i+1]\\n\\nsuf[i][j][k] := the number of suffixes/subsequences of \"jk\" from index i to the end of s\\n    e.g., suf[i][1][2] means the number of suffixes \"12\" in s[i:]\\n    \\nTo compute the total number of desired palindromic subsequences, we just need to sum up the following:\\n\\n    pre[i-1][j][k] * suf[i+1][k][j]\\n    \\n    where 2 <= i <= n-3, 0 <= j <= 9, 0 <= k <= 10\\n    \\nin the sense of modulo 10 ** 9 + 7.\\n    \\n\\n3. DP update rule\\n\\ncnts_pre[i][j] := the number of j\\'s appeared in s[:i+1], \\ni.e., starting from index 0 ending at index i;\\n\\ncnts_suf[i][j] := the number of j\\'s appeared in s[i:],\\ni.e., starting from index i up to the end of s.\\n\\nFor these two DP tables, it is very easy to update. In general,\\n\\ncnts_pre[i][j] = cnts_pre[i-1][j] + int(int(s[i]) == j)\\ncnts_suf[i][j] = cnts_suf[i+1][j] + int(int(s[i]) == j)\\n\\n\\nUpdate order:\\n\\n(1) when we determine pre[i][j][k] and cnts_pre[i][j], we shall use i = 0, 1, ...., n-1, increasingly;\\n\\n(2) when we determine suf[i][j][k] and cnts_suf[i][j], we shall use i = n-1, n-2, 1, 0,\\ndecreasingly.\\n\\n\\nThe general DP update rule is:\\n\\npre[i][j][k] = pre[i-1][j][k] if int(s[i]) != k else pre[i-1][j][k] + cnts_pre[i-1][j]\\nsuf[i][j][k] = suf[i+1][j][k] if int(s[i]) != j else pre[i+1][j][k] + cnts_suf[i+1][k]\\n\\n\\n4. Walkthrough\\n\\nExample-1. s = \"103301\"; shall return 2\\n\\n\\ncnts_pre: \\n[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 1, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 2, 0, 0, 0, 0, 0, 0], \\n[2, 1, 0, 2, 0, 0, 0, 0, 0, 0], \\n[2, 2, 0, 2, 0, 0, 0, 0, 0, 0]]; \\n\\ncnts_suf: \\n[[2, 2, 0, 2, 0, 0, 0, 0, 0, 0], \\n[2, 1, 0, 2, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 2, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 1, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \\n[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\\n\\nYou can print out pre, suf using our solution\\n\\n\\nExample-1-modified s = \"1033031\"; shall return 5\\n\\ncnts_pre: \\n[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \\n[1, *1*, 0, 1, 0, 0, 0, 0, 0, 0], \\n[1, 1, 0, 2, 0, 0, 0, 0, 0, 0], \\n[2, 1, 0, 2, 0, 0, 0, 0, 0, 0], \\n[2, 1, 0, 3, 0, 0, 0, 0, 0, 0], \\n[2, 2, 0, 3, 0, 0, 0, 0, 0, 0]]\\n\\nConsider j=1, k=3, and i=3,\\nwe want to find pre[i][j][k], i.e., pre[3][1][3] = the number of \"13\" subsquences in s[:4].\\nWe know pre[2][1][3] = 1 because there is only 1 occurence of \"13\" in \"103\".\\nAs int(s[3]) = k which is 3 in this example, we want to know how many 1\\'s had appeared before index 3, which can make up \"13\" with s[3].\\nIn this example, it is cnts_pre[2][1] = 1. So we know pre[3][1][3] = pre[2][1][3] + cnts_pre[2][1] = 1 + 1 = 2.\\n\\nIn this example, the valid subsequnces are:\\n\\n10301(index:01256), 10301(index:01356), 13331(index:02356), 13031(index:03456), \\n13031(index:02456)\\n\\n\"\"\"\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Solution to Leetcode 2484\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        CONST, n, res = 10 ** 9 + 7, len(s), 0\\n        \\n        pre = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        cnts_pre = [[0] * 10 for _ in range(n)]\\n        \\n        # set up the cnts_pre\\n        for i in range(n):\\n            for j in range(10):\\n                if i == 0:\\n                    cnts_pre[i][j] = 1 if int(s[i]) == j else 0\\n                else:\\n                    cnts_pre[i][j] = cnts_pre[i-1][j] + int(int(s[i]) == j)\\n                    \\n        # set up the pre\\n        for i in range(n):\\n            c = int(s[i])\\n            if i > 0:\\n                for j in range(10):\\n                    for k in range(10):\\n                        pre[i][j][k] = pre[i-1][j][k]\\n                        if k == c:\\n                            pre[i][j][k] += cnts_pre[i-1][j]\\n        \\n        suf = [[[0] * 10 for _ in range(10)] for _ in range(n)]\\n        cnts_suf = [[0] * 10 for _ in range(n)]\\n        \\n        # set up the cnts_suf\\n        for i in range(n-1, -1, -1):\\n            for j in range(10):\\n                if i == n - 1:\\n                    if int(s[i]) == j:\\n                        cnts_suf[i][j] = 1\\n                else:\\n                    cnts_suf[i][j] = cnts_suf[i+1][j] + int(int(s[i]) == j)\\n        \\n        # set up the suf\\n        for i in range(n-1, -1, -1):\\n            c = int(s[i])\\n            if i < n - 1:\\n                for j in range(10):\\n                    for k in range(10):\\n                        suf[i][j][k] = suf[i+1][j][k]\\n                        if j == c:\\n                            suf[i][j][k] += cnts_suf[i+1][k]\\n                            \\n        # do the counting\\n        for i in range(2, n-2):\\n            for j in range(10):\\n                for k in range(10):\\n                    res += pre[i-1][j][k] * suf[i+1][k][j]\\n        \\n        return res % CONST\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866973,
                "title": "c-3d-dp-solution-better-than-70",
                "content": "class Solution {\\npublic:\\n    int dk[10020][11];\\n    long long dp[10020][11][11];  \\n    \\n    int dk2[10020][11], mod = 1e9 + 7, x;\\n    long long dp2[10020][11][11]; \\n    \\n    int countPalindromes(string s) {\\n        if(s.size() < 5) return 0;\\n        \\n        for(int i = 0;i < s.size();i ++){\\n            x = int(s[i] - 48);\\n            dk[i][x] = 1;\\n            for(int k = 0;k < 10;k ++){\\n                if(i > 0)\\n                    for(int c = 0;c < 10;c ++)\\n                        dp[i][k][c] = dp[i - 1][k][c];\\n                if(i > 0){\\n                    dk[i][k] += dk[i - 1][k];\\n                    dp[i][k][x] += dk[i - 1][k];  \\n                } \\n            }\\n        }\\n        for(int i = s.size() - 1;i >= 0;i --){\\n            x = int(s[i] - 48);\\n            dk2[i][x] = 1;  \\n            for(int k = 0;k < 10;k ++){\\n                for(int c = 0;c < 10;c ++)\\n                    dp2[i][k][c] = dp2[i + 1][k][c];\\n                dk2[i][k] += dk2[i + 1][k];\\n                dp2[i][k][x] += dk2[i + 1][k];  \\n            }\\n        }\\n        int cnt = 0;        \\n        for(int i = 2;i < s.size() - 2;i ++){\\n            long long val = 0;\\n            for(int k = 0;k < 10;k ++){\\n                for(int c = 0;c < 10;c ++){\\n                    val += (dp[i - 1][k][c] * dp2[i + 1][k][c]) % mod;\\n                }\\n            }\\n            cnt = (cnt + val) % mod;\\n        }\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dk[10020][11];\\n    long long dp[10020][11][11];  \\n    \\n    int dk2[10020][11], mod = 1e9 + 7, x;\\n    long long dp2[10020][11][11]; \\n    \\n    int countPalindromes(string s) {\\n        if(s.size() < 5) return 0;\\n        \\n        for(int i = 0;i < s.size();i ++){\\n            x = int(s[i] - 48);\\n            dk[i][x] = 1;\\n            for(int k = 0;k < 10;k ++){\\n                if(i > 0)\\n                    for(int c = 0;c < 10;c ++)\\n                        dp[i][k][c] = dp[i - 1][k][c];\\n                if(i > 0){\\n                    dk[i][k] += dk[i - 1][k];\\n                    dp[i][k][x] += dk[i - 1][k];  \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2863957,
                "title": "c-dp-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        long long res = 0;\\n        int mod = 1e9 + 7;\\n        int n = s.length();\\n        if(n < 5) return 0;\\n        \\n        int cntOne[10];\\n        int cntTwo[100];\\n        memset(cntOne, 0, sizeof(cntOne));\\n        memset(cntTwo, 0, sizeof(cntTwo));\\n        \\n        for(int i = 0; i < n; i++) {\\n\\t\\t\\n            for(int j = 0; j <= 9; j++)\\n                cntTwo[j * 10 + (s[i] - \\'0\\')] += cntOne[j];\\n            \\n            cntOne[s[i] - \\'0\\'] += 1;\\n        }\\n        \\n        int cO[10];\\n        int cT[100];\\n        memset(cO, 0, sizeof(cO));\\n        memset(cT, 0, sizeof(cT));\\n        \\n        for(int i = n - 1; i >= 2; i--) {\\n            cntOne[s[i] - \\'0\\'] -= 1;\\n\\t\\t\\t\\n            for(int k = 0; k <= 9; k++) \\n                cntTwo[k * 10 + s[i] - \\'0\\'] -= cntOne[k];\\n     \\n            if(i <= n - 3) \\n                for(int k = 0; k <= 99; k++) \\n                    res = (res + (long long)cT[k] * cntTwo[k]) % mod;\\n            \\n            for(int j = 0; j <= 9; j++) \\n                cT[j * 10 + s[i] - \\'0\\'] += cO[j];\\n            \\n            cO[s[i] - \\'0\\'] += 1;\\n        }\\n        \\n        return (int)res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        long long res = 0;\\n        int mod = 1e9 + 7;\\n        int n = s.length();\\n        if(n < 5) return 0;\\n        \\n        int cntOne[10];\\n        int cntTwo[100];\\n        memset(cntOne, 0, sizeof(cntOne));\\n        memset(cntTwo, 0, sizeof(cntTwo));\\n        \\n        for(int i = 0; i < n; i++) {\\n\\t\\t\\n            for(int j = 0; j <= 9; j++)\\n                cntTwo[j * 10 + (s[i] - \\'0\\')] += cntOne[j];\\n            \\n            cntOne[s[i] - \\'0\\'] += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2861113,
                "title": "javascript-prefix-suffix",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromes = function (s) {\\n  const n = s.length;\\n  const MOD = Math.pow(10, 9) + 7;\\n  let counts = new Array(10).fill(0);\\n\\n  const prefix = new Array(n)\\n    .fill()\\n    .map((_) => new Array(10).fill().map((_) => new Array(10).fill(0)));\\n  for (let i = 0; i < n; i++) {\\n    const num = Number(s[i]);\\n    for (let n1 = 0; n1 < 10; n1++) {\\n      for (let n2 = 0; n2 < 10; n2++) {\\n        if (i > 0) prefix[i][n1][n2] = prefix[i - 1][n1][n2];\\n\\n        if (num === n2) prefix[i][n1][n2] += counts[n1];\\n      }\\n    }\\n    counts[num]++;\\n  }\\n\\n  counts = counts.map((_) => 0);\\n  const suffix = new Array(n)\\n    .fill()\\n    .map((_) => new Array(10).fill().map((_) => new Array(10).fill(0)));\\n  for (let i = n - 1; i >= 0; i--) {\\n    const num = Number(s[i]);\\n    for (let n1 = 0; n1 < 10; n1++) {\\n      for (let n2 = 0; n2 < 10; n2++) {\\n        if (i < n - 1) suffix[i][n2][n1] = suffix[i + 1][n2][n1];\\n\\n        if (num === n2) suffix[i][n2][n1] += counts[n1];\\n      }\\n    }\\n    counts[num]++;\\n  }\\n\\n  let ans = 0;\\n  for (let i = 2; i < n - 2; i++) {\\n    for (let n1 = 0; n1 < 10; n1++) {\\n      for (let n2 = 0; n2 < 10; n2++) {\\n        const result = prefix[i - 1][n1][n2] * suffix[i + 1][n2][n1];\\n        ans = (ans + result) % MOD;\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPalindromes = function (s) {\\n  const n = s.length;\\n  const MOD = Math.pow(10, 9) + 7;\\n  let counts = new Array(10).fill(0);\\n\\n  const prefix = new Array(n)\\n    .fill()\\n    .map((_) => new Array(10).fill().map((_) => new Array(10).fill(0)));\\n  for (let i = 0; i < n; i++) {\\n    const num = Number(s[i]);\\n    for (let n1 = 0; n1 < 10; n1++) {\\n      for (let n2 = 0; n2 < 10; n2++) {\\n        if (i > 0) prefix[i][n1][n2] = prefix[i - 1][n1][n2];\\n\\n        if (num === n2) prefix[i][n1][n2] += counts[n1];\\n      }\\n    }\\n    counts[num]++;\\n  }\\n\\n  counts = counts.map((_) => 0);\\n  const suffix = new Array(n)\\n    .fill()\\n    .map((_) => new Array(10).fill().map((_) => new Array(10).fill(0)));\\n  for (let i = n - 1; i >= 0; i--) {\\n    const num = Number(s[i]);\\n    for (let n1 = 0; n1 < 10; n1++) {\\n      for (let n2 = 0; n2 < 10; n2++) {\\n        if (i < n - 1) suffix[i][n2][n1] = suffix[i + 1][n2][n1];\\n\\n        if (num === n2) suffix[i][n2][n1] += counts[n1];\\n      }\\n    }\\n    counts[num]++;\\n  }\\n\\n  let ans = 0;\\n  for (let i = 2; i < n - 2; i++) {\\n    for (let n1 = 0; n1 < 10; n1++) {\\n      for (let n2 = 0; n2 < 10; n2++) {\\n        const result = prefix[i - 1][n1][n2] * suffix[i + 1][n2][n1];\\n        ans = (ans + result) % MOD;\\n      }\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2860518,
                "title": "java-easy-similar-to-lis-o-n-perfect-clean-code",
                "content": "```\\nclass Solution {\\n\\t\\tpublic int countPalindromes(String s) {\\n            int n=s.length();\\n            long ans=0;\\n            int mod=(int)1e9+7;\\n            int[] count=new int[10];\\n            for(int i=0;i<n;i++)\\n            {\\n\\t\\t\\t\\t//The variable m keeps the count number of equal characters between indices 0 to i-1 and j+1 to n-1\\n                long m=0;\\n                for(int j=n-1;j>i;j--)\\n                {\\n                    if(s.charAt(i)==s.charAt(j))\\n                    {\\n\\t\\t\\t\\t\\t    //multiply the current palindrome with the already found equal characters\\n                        ans+=(m*(j-i-1));\\n                        ans=ans%mod;\\n                    }\\n                    m+=count[s.charAt(j)-\\'0\\'];\\n                }\\n                count[s.charAt(i)-\\'0\\']++;\\n            }\\n            return (int)ans;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t\\tpublic int countPalindromes(String s) {\\n            int n=s.length();\\n            long ans=0;\\n            int mod=(int)1e9+7;\\n            int[] count=new int[10];\\n            for(int i=0;i<n;i++)\\n            {\\n\\t\\t\\t\\t//The variable m keeps the count number of equal characters between indices 0 to i-1 and j+1 to n-1\\n                long m=0;\\n                for(int j=n-1;j>i;j--)\\n                {\\n                    if(s.charAt(i)==s.charAt(j))\\n                    {\\n\\t\\t\\t\\t\\t    //multiply the current palindrome with the already found equal characters\\n                        ans+=(m*(j-i-1));\\n                        ans=ans%mod;\\n                    }\\n                    m+=count[s.charAt(j)-\\'0\\'];\\n                }\\n                count[s.charAt(i)-\\'0\\']++;\\n            }\\n            return (int)ans;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858986,
                "title": "faster-than-99-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is based not on recursivity (dynamic programming), but on a complicated counting formula I found, which is somewhat hard to implement. Correcting the mistakes took a while. No wonder I could not do this problem during the competition.\\n\\nI suppose this could also be implemented in a recursive way (the formula shows the way), but some steps are more efficient when done all at once.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne can count all the palyndromic triples between pairs of identical values. Several optimizations are required to do it fast.\\n\\nThe palyndromic triples again consist of pairs of identical values with at least one more value between them (and the number of values between the pair gives the number of triples corresponding to the pair).\\n\\nCounting only gets more complicated from here.\\n\\nAlthough the code is highly optimized from a mathematical point of view, there are some further optimizations that can be done from a programming point of view.\\n\\n# Complexity\\n- Time complexity: Linear.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Linear.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        l=len(s)\\n        if l<5:\\n            return 0\\n        p=10**9+7\\n        digits=[[] for i in range(10)]\\n        for i in range(l):\\n            digits[int(s[i])].append(i)\\n        \\n        lo=[defaultdict(lambda:-1) for i in range(10)]\\n        hi=[defaultdict(lambda:l) for i in range(10)]\\n        for i in range(10):\\n            if len(digits[i])>=2:\\n                tmp=digits[i]\\n                prev=tmp[0]\\n                for k in range(prev):\\n                    hi[i][k]=0\\n                lo[i][prev]=0\\n                hi[i][prev]=0\\n                j=1\\n                while j<len(tmp):\\n                    for k in range(prev+1, tmp[j]):\\n                        lo[i][k]=j-1\\n                        hi[i][k]=j\\n                    prev=tmp[j]\\n                    lo[i][prev]=j\\n                    hi[i][prev]=j\\n                    j+=1\\n                for k in range(tmp[-1]+1, l):\\n                    lo[i][k]=j-1\\n        sums=[[] for i in range(10)]\\n        for i in range(10):\\n            s=0\\n            for j in range(len(digits[i])):\\n                sums[i].append(s)\\n                s+=digits[i][j]    \\n        \\n        ans=0\\n        for i in range(10):\\n            tmp=digits[i]\\n            if len(tmp)>=2:\\n                for k in range(10):\\n                    if len(digits[k])>=2:\\n                        sm=0\\n                        partial_sum=0\\n                        partial_ans=0\\n                        j2=0\\n                        l2=1\\n                        j=1\\n                        while j<len(tmp):\\n                            low=lo[k][tmp[j]-1]\\n                            while l2<=low:\\n                                while hi[k][tmp[j2]+1]<l2:\\n                                    sm+=hi[k][tmp[j2]+1]\\n                                    partial_sum+=sums[k][hi[k][tmp[j2]+1]]\\n                                    j2+=1\\n                                if j2:\\n                                    partial_ans+=(j2*l2-sm)*(digits[k][l2]-1)-(j2*sums[k][l2]-partial_sum)\\n                                l2+=1\\n                            ans+=partial_ans\\n                            j+=1\\n                        ans%=p\\n        return ans%p\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        l=len(s)\\n        if l<5:\\n            return 0\\n        p=10**9+7\\n        digits=[[] for i in range(10)]\\n        for i in range(l):\\n            digits[int(s[i])].append(i)\\n        \\n        lo=[defaultdict(lambda:-1) for i in range(10)]\\n        hi=[defaultdict(lambda:l) for i in range(10)]\\n        for i in range(10):\\n            if len(digits[i])>=2:\\n                tmp=digits[i]\\n                prev=tmp[0]\\n                for k in range(prev):\\n                    hi[i][k]=0\\n                lo[i][prev]=0\\n                hi[i][prev]=0\\n                j=1\\n                while j<len(tmp):\\n                    for k in range(prev+1, tmp[j]):\\n                        lo[i][k]=j-1\\n                        hi[i][k]=j\\n                    prev=tmp[j]\\n                    lo[i][prev]=j\\n                    hi[i][prev]=j\\n                    j+=1\\n                for k in range(tmp[-1]+1, l):\\n                    lo[i][k]=j-1\\n        sums=[[] for i in range(10)]\\n        for i in range(10):\\n            s=0\\n            for j in range(len(digits[i])):\\n                sums[i].append(s)\\n                s+=digits[i][j]    \\n        \\n        ans=0\\n        for i in range(10):\\n            tmp=digits[i]\\n            if len(tmp)>=2:\\n                for k in range(10):\\n                    if len(digits[k])>=2:\\n                        sm=0\\n                        partial_sum=0\\n                        partial_ans=0\\n                        j2=0\\n                        l2=1\\n                        j=1\\n                        while j<len(tmp):\\n                            low=lo[k][tmp[j]-1]\\n                            while l2<=low:\\n                                while hi[k][tmp[j2]+1]<l2:\\n                                    sm+=hi[k][tmp[j2]+1]\\n                                    partial_sum+=sums[k][hi[k][tmp[j2]+1]]\\n                                    j2+=1\\n                                if j2:\\n                                    partial_ans+=(j2*l2-sm)*(digits[k][l2]-1)-(j2*sums[k][l2]-partial_sum)\\n                                l2+=1\\n                            ans+=partial_ans\\n                            j+=1\\n                        ans%=p\\n        return ans%p\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858839,
                "title": "recursive-python-solution",
                "content": "```\\ndef countPalindromes(self, s: str) -> int:\\n        N = len(s)\\n        mod = 10 ** 9 + 7\\n        @cache\\n        def solve(i, curr, mid_after):\\n            if mid_after and curr == \\'\\':  return 1\\n            if i >= N:  return 0\\n\\t\\t\\t\\n            res = solve(i + 1, curr, mid_after)  # skip current char\\n            if len(curr) < 2 and not mid_after: # adding chars to pref\\n                return res + solve(i + 1, curr + s[i], 0)\\n            \\n            if len(curr) == 2 and not mid_after: \\n                return res + solve(i + 1, curr, 1)\\n            \\n            if mid_after and curr[-1] == s[i]: \\n                return res + solve(i + 1, curr[:-1], mid_after)\\n            return res \\n              \\n        ans = solve(0, \\'\\', 0) % mod\\n        solve.cache_clear()\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef countPalindromes(self, s: str) -> int:\\n        N = len(s)\\n        mod = 10 ** 9 + 7\\n        @cache\\n        def solve(i, curr, mid_after):\\n            if mid_after and curr == \\'\\':  return 1\\n            if i >= N:  return 0\\n\\t\\t\\t\\n            res = solve(i + 1, curr, mid_after)  # skip current char\\n            if len(curr) < 2 and not mid_after: # adding chars to pref\\n                return res + solve(i + 1, curr + s[i], 0)\\n            \\n            if len(curr) == 2 and not mid_after: \\n                return res + solve(i + 1, curr, 1)\\n            \\n            if mid_after and curr[-1] == s[i]: \\n                return res + solve(i + 1, curr[:-1], mid_after)\\n            return res \\n              \\n        ans = solve(0, \\'\\', 0) % mod\\n        solve.cache_clear()\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2858134,
                "title": "python3-o-n-solution-by-pre-calculate-all-prefix",
                "content": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        res = 0\\n        \\n\\t\\t#store count of single digits\\n        log = [0]*10\\n\\t\\t#store count of double digits from \\'00\\' until \\'99\\'\\n        track = [0]*100\\n        container = []\\n        \\n        for char in s:\\n            index_2 = ord(char) - 48\\n            for k in range(10):\\n                index = k * 10 + index_2\\n                track[index] += log[k]\\n            log[index_2] += 1\\n            container.append(track[:])\\n                        \\n        log = [0]*10\\n        track = [0]*100\\n        for t in range(len(s)-1, 1, -1):\\n            ref = container[t-1]\\n            for k in range(100):\\n                res += ref[k] * track[k]\\n            \\n            index_2 = ord(s[t]) - 48\\n            for k in range(10):\\n                index = k * 10 + index_2\\n                track[index] += log[k]\\n            log[index_2] += 1\\n         \\n        return res % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        res = 0\\n        \\n\\t\\t#store count of single digits\\n        log = [0]*10\\n\\t\\t#store count of double digits from \\'00\\' until \\'99\\'\\n        track = [0]*100\\n        container = []\\n        \\n        for char in s:\\n            index_2 = ord(char) - 48\\n            for k in range(10):\\n                index = k * 10 + index_2\\n                track[index] += log[k]\\n            log[index_2] += 1\\n            container.append(track[:])\\n                        \\n        log = [0]*10\\n        track = [0]*100\\n        for t in range(len(s)-1, 1, -1):\\n            ref = container[t-1]\\n            for k in range(100):\\n                res += ref[k] * track[k]\\n            \\n            index_2 = ord(s[t]) - 48\\n            for k in range(10):\\n                index = k * 10 + index_2\\n                track[index] += log[k]\\n            log[index_2] += 1\\n         \\n        return res % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856086,
                "title": "python3-o-100n-use-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnce set s[i] as center of the palindromic, all we need is to find the count of \\'00\\',\\'01\\',\\'02\\',...,\\'99\\' on the left and right of i. We use cur1 to store all sigle digits and cur2 to store all two digits before or after i. We process s from start to end and vice versa. In the end, the answer is sum of all left[i - 1][j] * right[i + 1][j] for j in [1, 99].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(100n) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(100n) \\n# Code\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        if len(s) < 5: return 0\\n        n = len(s)\\n        s = [int(c) for c in s]\\n        left, right = [0] * n, [0] * n\\n        cur1, cur2 = [0] * 10, [0] * 100\\n        cur1[s[0]] += 1\\n        for i in range(1, n - 1):\\n            for j in range(10): cur2[j * 10 + s[i]] += cur1[j]\\n            left[i] = cur2[:]\\n            cur1[s[i]] += 1\\n        cur1, cur2 = [0] * 10, [0] * 100\\n        cur1[s[-1]] += 1\\n        for i in range(n - 2, 1, -1):\\n            for j in range(10): cur2[j * 10 + s[i]] += cur1[j]\\n            right[i] = cur2[:]\\n            cur1[s[i]] += 1\\n        ans, MOD = 0, 10 ** 9 + 7\\n        for i in range(2, n - 2):\\n            ans = (ans + sum(left[i - 1][j] * right[i + 1][j] for j in range(100))) % MOD\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        if len(s) < 5: return 0\\n        n = len(s)\\n        s = [int(c) for c in s]\\n        left, right = [0] * n, [0] * n\\n        cur1, cur2 = [0] * 10, [0] * 100\\n        cur1[s[0]] += 1\\n        for i in range(1, n - 1):\\n            for j in range(10): cur2[j * 10 + s[i]] += cur1[j]\\n            left[i] = cur2[:]\\n            cur1[s[i]] += 1\\n        cur1, cur2 = [0] * 10, [0] * 100\\n        cur1[s[-1]] += 1\\n        for i in range(n - 2, 1, -1):\\n            for j in range(10): cur2[j * 10 + s[i]] += cur1[j]\\n            right[i] = cur2[:]\\n            cur1[s[i]] += 1\\n        ans, MOD = 0, 10 ** 9 + 7\\n        for i in range(2, n - 2):\\n            ans = (ans + sum(left[i - 1][j] * right[i + 1][j] for j in range(100))) % MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854299,
                "title": "o-1-space-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nCount all the (j, k) pairs to the left/right of position i. The value of j and k is from 0 to 9, for which we can use a dp array to cache the count and then update it on the fly\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(100 * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        long n = s.size();\\n        long left[10], right[10];\\n        memset(left, 0, sizeof(left));\\n        memset(right, 0, sizeof(right));\\n        long cnt_left[10][10], cnt_right[10][10];\\n        memset(cnt_left, 0, sizeof(cnt_left));\\n        memset(cnt_right, 0, sizeof(cnt_right));\\n        long M = 1e9 + 7;\\n        for (int i = n - 2; i >= 2; i--) {\\n            right[s[i + 1] - \\'0\\'] += 1;\\n            int d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                cnt_right[d][j] += right[j];\\n            }\\n        }\\n        long ans = 0;\\n        for (int i = 2; i < n - 2; i++) {\\n            // update left\\n            left[s[i - 2] - \\'0\\'] += 1;\\n            // update cnt_left\\n            int d = s[i - 1] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                cnt_left[j][d] += left[j];\\n            }\\n            // update cnt_right\\n            d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                cnt_right[d][j] -= right[j];\\n            }\\n            // update ans\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    ans += cnt_left[j][k] * cnt_right[k][j];\\n                    ans %= M;\\n                }\\n            }\\n            // update right\\n            right[s[i + 1] - \\'0\\'] -= 1;\\n        }\\n        return (int)(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        long n = s.size();\\n        long left[10], right[10];\\n        memset(left, 0, sizeof(left));\\n        memset(right, 0, sizeof(right));\\n        long cnt_left[10][10], cnt_right[10][10];\\n        memset(cnt_left, 0, sizeof(cnt_left));\\n        memset(cnt_right, 0, sizeof(cnt_right));\\n        long M = 1e9 + 7;\\n        for (int i = n - 2; i >= 2; i--) {\\n            right[s[i + 1] - \\'0\\'] += 1;\\n            int d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                cnt_right[d][j] += right[j];\\n            }\\n        }\\n        long ans = 0;\\n        for (int i = 2; i < n - 2; i++) {\\n            // update left\\n            left[s[i - 2] - \\'0\\'] += 1;\\n            // update cnt_left\\n            int d = s[i - 1] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                cnt_left[j][d] += left[j];\\n            }\\n            // update cnt_right\\n            d = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; j++) {\\n                cnt_right[d][j] -= right[j];\\n            }\\n            // update ans\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    ans += cnt_left[j][k] * cnt_right[k][j];\\n                    ans %= M;\\n                }\\n            }\\n            // update right\\n            right[s[i + 1] - \\'0\\'] -= 1;\\n        }\\n        return (int)(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853855,
                "title": "c-tle-o-3-n-10-10-max-iterations-3000000-reason",
                "content": "Can anyone tell why the below solution is giving TLE\\n\\n```\\nclass Solution {\\npublic:\\n    \\n  int countPalindromes(string s) {\\n\\n   int N = 10003;\\n     vector<vector<vector<int>>> dp (N, vector<vector<int>>(10, vector<int>(10,0)));\\n        vector<vector<vector<int>>> dpR(N, vector<vector<int>>(10, vector<int>(10,0)));\\n\\n    int n = s.length();\\n   \\n    vector<int>cnt(10, 0);\\n    vector<int>cntR(10, 0);\\n    cnt[s[0] - \\'0\\']++;\\n    cntR[s[n-1] - \\'0\\']++;\\n\\n    for(int i=1;i<s.length();i++)\\n    {\\n        for(int j=0;j<10;j++)\\n        {\\n            for(int k=0;k<10;k++)\\n            {\\n                dp[i][j][k] = dp[i-1][j][k];\\n                if(k == (s[i] - \\'0\\')){\\n                    dp[i][j][k] += cnt[j];\\n                }\\n            }\\n        }\\n        cnt[s[i] - \\'0\\']++;\\n    }\\n\\n    for(int i=n-2;i>=0;i--)\\n    {\\n        for(int j=0;j<10;j++)\\n        {\\n            for(int k=0;k<10;k++)\\n            {\\n                dpR[i][j][k] = dpR[i+1][j][k];\\n                if(j == (s[i] - \\'0\\')){\\n                    dpR[i][j][k] += cntR[k];\\n                }\\n            }\\n        }\\n        cntR[s[i] - \\'0\\']++;\\n    }\\n\\n    long long ans = 0;\\n    long long mod = 1e9 + 7;\\n\\n    for(int i=2;i<n-2;i++)\\n    {\\n        \\n        for(int j=0;j<10;j++)\\n        {\\n            for(int k=0;k<10;k++)\\n            {\\n                //left find \"jk\" \\n                //right find \"kj\"\\n                                \\n                long long left = dp[i-1][j][k];\\n                long long right = dpR[i+1][k][j];\\n\\n                ans += left*right;\\n                ans %= mod;\\n          \\n            }\\n        }\\n        //deb(ans);\\n    }\\n\\n    return ans;\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  int countPalindromes(string s) {\\n\\n   int N = 10003;\\n     vector<vector<vector<int>>> dp (N, vector<vector<int>>(10, vector<int>(10,0)));\\n        vector<vector<vector<int>>> dpR(N, vector<vector<int>>(10, vector<int>(10,0)));\\n\\n    int n = s.length();\\n   \\n    vector<int>cnt(10, 0);\\n    vector<int>cntR(10, 0);\\n    cnt[s[0] - \\'0\\']++;\\n    cntR[s[n-1] - \\'0\\']++;\\n\\n    for(int i=1;i<s.length();i++)\\n    {\\n        for(int j=0;j<10;j++)\\n        {\\n            for(int k=0;k<10;k++)\\n            {\\n                dp[i][j][k] = dp[i-1][j][k];\\n                if(k == (s[i] - \\'0\\')){\\n                    dp[i][j][k] += cnt[j];\\n                }\\n            }\\n        }\\n        cnt[s[i] - \\'0\\']++;\\n    }\\n\\n    for(int i=n-2;i>=0;i--)\\n    {\\n        for(int j=0;j<10;j++)\\n        {\\n            for(int k=0;k<10;k++)\\n            {\\n                dpR[i][j][k] = dpR[i+1][j][k];\\n                if(j == (s[i] - \\'0\\')){\\n                    dpR[i][j][k] += cntR[k];\\n                }\\n            }\\n        }\\n        cntR[s[i] - \\'0\\']++;\\n    }\\n\\n    long long ans = 0;\\n    long long mod = 1e9 + 7;\\n\\n    for(int i=2;i<n-2;i++)\\n    {\\n        \\n        for(int j=0;j<10;j++)\\n        {\\n            for(int k=0;k<10;k++)\\n            {\\n                //left find \"jk\" \\n                //right find \"kj\"\\n                                \\n                long long left = dp[i-1][j][k];\\n                long long right = dpR[i+1][k][j];\\n\\n                ans += left*right;\\n                ans %= mod;\\n          \\n            }\\n        }\\n        //deb(ans);\\n    }\\n\\n    return ans;\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853819,
                "title": "out-of-box-solution-copied-no-dp-c",
                "content": "Could not solve this problem in contest.\\nFound very cool soution from [uwi](https://leetcode.com/uwi/) in contest.\\nI was amazed, so thought of sharing here as nobody other have shared this.\\nSome people are so talented.\\nTook me some time to understand it.\\n\\n```cpp\\n    int countPalindromes2(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tint ff[10] = {0};\\n\\t\\t\\tfor(int i = 0;i < n;i++){\\n\\t\\t\\t\\tlong m = 0;                // m counts the outer pairs matched already.\\n\\t\\t\\t\\tfor(int j = n-1;j > i;j--){\\n\\t\\t\\t\\t\\tif(s[i] == s[j]){       // If current pairs match, and we know how many outer pairs are matched\\n\\t\\t\\t\\t\\t\\tans += m * (j-i-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tm += ff[s[j]-\\'0\\'];    // add pairs formed by s[j] for next set of iterations\\n\\t\\t\\t\\t\\tif(m >= mod)m -= mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tff[s[i] - \\'0\\']++;            // count the s[i] found from the front.\\n\\t\\t\\t}\\n\\t\\t\\treturn (int)(ans % mod);\\n\\t}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    int countPalindromes2(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tlong ans = 0;\\n\\t\\t\\tint ff[10] = {0};\\n\\t\\t\\tfor(int i = 0;i < n;i++){\\n\\t\\t\\t\\tlong m = 0;                // m counts the outer pairs matched already.\\n\\t\\t\\t\\tfor(int j = n-1;j > i;j--){\\n\\t\\t\\t\\t\\tif(s[i] == s[j]){       // If current pairs match, and we know how many outer pairs are matched\\n\\t\\t\\t\\t\\t\\tans += m * (j-i-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tm += ff[s[j]-\\'0\\'];    // add pairs formed by s[j] for next set of iterations\\n\\t\\t\\t\\t\\tif(m >= mod)m -= mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tff[s[i] - \\'0\\']++;            // count the s[i] found from the front.\\n\\t\\t\\t}\\n\\t\\t\\treturn (int)(ans % mod);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2853395,
                "title": "optimal-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*Ashutosh Kumar Choudhary*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\n//***************************************************************************************************************\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n//***************************************************************************************************************\\n#define ll long long\\n#define mod 1000000007\\n#define inf 1e18\\n#define pb push_back\\n#define intmax INT_MAX\\n#define intmin INT_MIN\\n#define f first\\n#define ss second\\n#define pi acos((long double)(-1))\\n#define all(x) (x).begin(), (x).end()\\n//***************************************************************************************************************\\nll power(ll n, ll k, ll m = mod) { if(k == 0)return 1; if(k % 2)return (n * power(n, k - 1, m)) % m; return power((n * n) % m, k / 2, m); }\\nll modinv(ll x, ll m = mod) { return power(x, m - 2); }\\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\\nll lcm(ll a, ll b) { return (((a * b) % mod) * modinv(gcd(a, b))) % mod; }\\n//***************************************************************************************************************\\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\n#define endl \\'\\\\n\\'\\nclass Solution {\\npublic:\\n    int dp[10001][11][11][5];\\n    int helper(string &s,int ind,int a,int b,ll flag,int dp[1000][11][11][5])\\n    {\\n      if(flag==3)\\n      return 1;\\n      if(ind==s.size())\\n      return 0;\\n      if(dp[ind][a+1][b+1][flag]!=-1)\\n      return dp[ind][a+1][b+1][flag];\\n      ll take=0;\\n      ll not_take=0;\\n      if(a==-1)\\n      {\\n        a=s[ind]-\\'0\\';\\n        take=helper(s,ind+1,a,b,0,dp);\\n        a=-1;\\n        not_take=helper(s,ind+1,a,b,0,dp);\\n      }\\n      else if(b==-1)\\n      {\\n        b=s[ind]-\\'0\\';\\n        take=helper(s,ind+1,a,b,0,dp);\\n        b=-1;\\n        not_take=helper(s,ind+1,a,b,0,dp);\\n      }\\n      else if(flag==0)\\n      {\\n        take=helper(s,ind+1,a,b,1,dp);\\n        not_take=helper(s,ind+1,a,b,0,dp);\\n      }\\n      else if(flag==1)\\n      {\\n        if((s[ind]-\\'0\\')==b)\\n        take=helper(s,ind+1,a,b,2,dp);\\n        not_take=helper(s,ind+1,a,b,1,dp);\\n      }\\n      else if(flag==2)\\n      {\\n        if((s[ind]-\\'0\\')==a)\\n        take=helper(s,ind+1,a,b,3,dp);\\n        not_take=helper(s,ind+1,a,b,2,dp);\\n      }\\n      return dp[ind][a+1][b+1][flag]=(take%mod+not_take%mod)%mod;\\n    }\\n    int countPalindromes(string s)\\n    {\\n      memset(dp,-1,sizeof(dp));\\n      return helper(s,0,-1,-1,0,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*Ashutosh Kumar Choudhary*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\n//***************************************************************************************************************\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n//***************************************************************************************************************\\n#define ll long long\\n#define mod 1000000007\\n#define inf 1e18\\n#define pb push_back\\n#define intmax INT_MAX\\n#define intmin INT_MIN\\n#define f first\\n#define ss second\\n#define pi acos((long double)(-1))\\n#define all(x) (x).begin(), (x).end()\\n//***************************************************************************************************************\\nll power(ll n, ll k, ll m = mod) { if(k == 0)return 1; if(k % 2)return (n * power(n, k - 1, m)) % m; return power((n * n) % m, k / 2, m); }\\nll modinv(ll x, ll m = mod) { return power(x, m - 2); }\\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\\nll lcm(ll a, ll b) { return (((a * b) % mod) * modinv(gcd(a, b))) % mod; }\\n//***************************************************************************************************************\\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\n#define endl \\'\\\\n\\'\\nclass Solution {\\npublic:\\n    int dp[10001][11][11][5];\\n    int helper(string &s,int ind,int a,int b,ll flag,int dp[1000][11][11][5])\\n    {\\n      if(flag==3)\\n      return 1;\\n      if(ind==s.size())\\n      return 0;\\n      if(dp[ind][a+1][b+1][flag]!=-1)\\n      return dp[ind][a+1][b+1][flag];\\n      ll take=0;\\n      ll not_take=0;\\n      if(a==-1)\\n      {\\n        a=s[ind]-\\'0\\';\\n        take=helper(s,ind+1,a,b,0,dp);\\n        a=-1;\\n        not_take=helper(s,ind+1,a,b,0,dp);\\n      }\\n      else if(b==-1)\\n      {\\n        b=s[ind]-\\'0\\';\\n        take=helper(s,ind+1,a,b,0,dp);\\n        b=-1;\\n        not_take=helper(s,ind+1,a,b,0,dp);\\n      }\\n      else if(flag==0)\\n      {\\n        take=helper(s,ind+1,a,b,1,dp);\\n        not_take=helper(s,ind+1,a,b,0,dp);\\n      }\\n      else if(flag==1)\\n      {\\n        if((s[ind]-\\'0\\')==b)\\n        take=helper(s,ind+1,a,b,2,dp);\\n        not_take=helper(s,ind+1,a,b,1,dp);\\n      }\\n      else if(flag==2)\\n      {\\n        if((s[ind]-\\'0\\')==a)\\n        take=helper(s,ind+1,a,b,3,dp);\\n        not_take=helper(s,ind+1,a,b,2,dp);\\n      }\\n      return dp[ind][a+1][b+1][flag]=(take%mod+not_take%mod)%mod;\\n    }\\n    int countPalindromes(string s)\\n    {\\n      memset(dp,-1,sizeof(dp));\\n      return helper(s,0,-1,-1,0,dp); \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2853200,
                "title": "simple-prefix-and-suffix-count-o-n-100",
                "content": "For every index i, we want to find the no of palindrome subsequences s.t ith element is the middle element in the subsequence. Therefore on the left of the index we need to find the count of all 2 digit subsequences and same for suffix.\\n\\n\\n\\n```\\n#define ll long long\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n=s.length();\\n        if(n<5)\\n            return 0;\\n        \\n        ll ans=0;\\n        unordered_map<string,ll> pref,suff;\\n        pref[s.substr(0,2)]++;\\n        vector<ll> cp(10,0),cs(10,0);\\n        cp[s[0]-\\'0\\']++;\\n        cp[s[1]-\\'0\\']++;\\n        \\n        cs[s.back()-\\'0\\']++;\\n        for(int i=n-2;i>1;i--){\\n            int one=s[i]-\\'0\\';\\n            string o=to_string(one);\\n            for(int j=0;j<10;j++){\\n                if(cs[j]){\\n                    string n=to_string(j)+o;\\n                    suff[n]=(suff[n]+cs[j])%mod;\\n                }\\n            }\\n            cs[one]++;\\n        }\\n        \\n        for(int i=2;i<n-2;i++){\\n            int one=s[i]-\\'0\\';\\n            cs[one]--;\\n            string o=to_string(one);\\n            for(int j=0;j<10;j++){\\n                if(cs[j]){\\n                    string n=to_string(j)+o;\\n                    suff[n]=(suff[n]-cs[j]+mod)%mod;\\n                }\\n            }\\n            \\n            for(int j=0;j<10;j++)\\n                for(int k=0;k<10;k++){\\n                    string s=to_string(j)+to_string(k);\\n                    ans=(ans+(pref[s]*suff[s])%mod)%mod;\\n                }\\n            \\n            for(int j=0;j<10;j++){\\n                if(cp[j]){\\n                    string n=to_string(j)+o;\\n                    pref[n]=(pref[n]+cp[j])%mod;\\n                }\\n            }\\n            cp[one]++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nconst int mod=1e9+7;\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n=s.length();\\n        if(n<5)\\n            return 0;\\n        \\n        ll ans=0;\\n        unordered_map<string,ll> pref,suff;\\n        pref[s.substr(0,2)]++;\\n        vector<ll> cp(10,0),cs(10,0);\\n        cp[s[0]-\\'0\\']++;\\n        cp[s[1]-\\'0\\']++;\\n        \\n        cs[s.back()-\\'0\\']++;\\n        for(int i=n-2;i>1;i--){\\n            int one=s[i]-\\'0\\';\\n            string o=to_string(one);\\n            for(int j=0;j<10;j++){\\n                if(cs[j]){\\n                    string n=to_string(j)+o;\\n                    suff[n]=(suff[n]+cs[j])%mod;\\n                }\\n            }\\n            cs[one]++;\\n        }\\n        \\n        for(int i=2;i<n-2;i++){\\n            int one=s[i]-\\'0\\';\\n            cs[one]--;\\n            string o=to_string(one);\\n            for(int j=0;j<10;j++){\\n                if(cs[j]){\\n                    string n=to_string(j)+o;\\n                    suff[n]=(suff[n]-cs[j]+mod)%mod;\\n                }\\n            }\\n            \\n            for(int j=0;j<10;j++)\\n                for(int k=0;k<10;k++){\\n                    string s=to_string(j)+to_string(k);\\n                    ans=(ans+(pref[s]*suff[s])%mod)%mod;\\n                }\\n            \\n            for(int j=0;j<10;j++){\\n                if(cp[j]){\\n                    string n=to_string(j)+o;\\n                    pref[n]=(pref[n]+cp[j])%mod;\\n                }\\n            }\\n            cp[one]++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852993,
                "title": "naive-dp-long-long-is-feasible",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        vector<int> num(10);\\n        const int n = s.length();\\n        vector<vector<int>> dp(n + 1, vector<int>(100));\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i] = dp[i - 1];\\n            const int c = s[i - 1] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                dp[i][j * 10 + c] += num[j];\\n            }\\n            ++num[c];\\n        }\\n        num = vector<int>(10);\\n        vector<int> temp(100);\\n        long long r = 0;\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0; j < 100; ++j) {\\n                r += static_cast<long long>(dp[i][j]) * temp[j];\\n            }\\n            const int c = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                temp[j * 10 + c] += num[j]; \\n            }\\n            ++num[c];\\n        }\\n        return r % 1000000007;\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        vector<int> num(10);\\n        const int n = s.length();\\n        vector<vector<int>> dp(n + 1, vector<int>(100));\\n        for (int i = 1; i <= n; ++i) {\\n            dp[i] = dp[i - 1];\\n            const int c = s[i - 1] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                dp[i][j * 10 + c] += num[j];\\n            }\\n            ++num[c];\\n        }\\n        num = vector<int>(10);\\n        vector<int> temp(100);\\n        long long r = 0;\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0; j < 100; ++j) {\\n                r += static_cast<long long>(dp[i][j]) * temp[j];\\n            }\\n            const int c = s[i] - \\'0\\';\\n            for (int j = 0; j < 10; ++j) {\\n                temp[j * 10 + c] += num[j]; \\n            }\\n            ++num[c];\\n        }\\n        return r % 1000000007;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852956,
                "title": "c-dp-o-n-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countPalindromes(string s) {\\n        if(s.size()<5) return 0;\\n        int n = s.size();\\n        vector<vector<vector<int>>> dp1(n,vector<vector<int>>(10,vector<int>(10,0)));\\n        vector<vector<vector<int>>> dp2(n,vector<vector<int>>(10,vector<int>(10,0)));\\n        \\n        vector<int> mp(10,0); mp[s[0]-\\'0\\']++;\\n        for(int i = 1; i<s.size();++i){\\n            dp1[i] = dp1[i-1];\\n            for(int j = 0; j<10;++j) dp1[i][s[i]-\\'0\\'][j]+=mp[j];\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        \\n        fill(mp.begin(),mp.end(),0);\\n        mp[s[s.size()-1]-\\'0\\']++;\\n        for(int i = s.size()-2;i>=0;i--){\\n            dp2[i] = dp2[i+1];\\n            for(int j = 0; j<10;++j) dp2[i][s[i]-\\'0\\'][j]+=mp[j];\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        \\n        long long re = 0;\\n        for(int i = 2; i<s.size()-2;++i){\\n            for(int a = 0; a<10;++a){\\n                for(int b = 0; b<10;++b){\\n                    re = (re + (long long)dp1[i-1][a][b]*dp2[i+1][a][b])%mod;\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countPalindromes(string s) {\\n        if(s.size()<5) return 0;\\n        int n = s.size();\\n        vector<vector<vector<int>>> dp1(n,vector<vector<int>>(10,vector<int>(10,0)));\\n        vector<vector<vector<int>>> dp2(n,vector<vector<int>>(10,vector<int>(10,0)));\\n        \\n        vector<int> mp(10,0); mp[s[0]-\\'0\\']++;\\n        for(int i = 1; i<s.size();++i){\\n            dp1[i] = dp1[i-1];\\n            for(int j = 0; j<10;++j) dp1[i][s[i]-\\'0\\'][j]+=mp[j];\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        \\n        fill(mp.begin(),mp.end(),0);\\n        mp[s[s.size()-1]-\\'0\\']++;\\n        for(int i = s.size()-2;i>=0;i--){\\n            dp2[i] = dp2[i+1];\\n            for(int j = 0; j<10;++j) dp2[i][s[i]-\\'0\\'][j]+=mp[j];\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        \\n        long long re = 0;\\n        for(int i = 2; i<s.size()-2;++i){\\n            for(int a = 0; a<10;++a){\\n                for(int b = 0; b<10;++b){\\n                    re = (re + (long long)dp1[i-1][a][b]*dp2[i+1][a][b])%mod;\\n                }\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852878,
                "title": "c-recursion-memoization",
                "content": "# Approach\\nevery 5 digit Palindromic \\n**1 st char is same last char**\\n**2 nd char is same 2nd last char**\\n**3 st char may unique may not your choice/depends on question**\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# code (TLE)\\n```\\nclass Solution {\\ntypedef long long ll;\\nint mod = 1e9+7;    \\nprivate:\\n    ll f(int ind,string &s,char first,char second,int len){\\n        if(len == 5){return 1;}\\n        if(ind >= s.size()){return 0;}\\n\\n        ll w1 = 0;\\n        ll w2 = 0; \\n        ll w3 = 0; \\n        ll w4 = 0; \\n        ll w5 = 0; \\n        if(len == 0){\\n            w1 = f(ind+1,s,s[ind],second,len+1)% mod;\\n        }\\n\\n        if(len == 1){\\n            w2 = f(ind+1,s,first,s[ind],len+1)% mod;\\n        }\\n\\n        if(len == 2){\\n            w3 = f(ind+1,s,first,second,len+1)% mod;\\n        }\\n\\n        if(len == 3 && s[ind] == second){\\n            w4 = f(ind+1,s,first,second,len+1)% mod;\\n        }\\n\\n        if(len == 4 && s[ind] == first){\\n            w5 = f(ind+1,s,first,second,len+1)% mod;\\n        }\\n        return w1 + w2 + w3 + w4 + w5 + f(ind+1,s,first,second,len) % mod;\\n    }\\n\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        return f(0,s,\\'*\\',\\'*\\',0)% mod;\\n    }\\n};\\n```\\n\\n# Code (ALL Passed)\\n```\\nclass Solution {\\ntypedef long long ll;\\nint mod = 1e9+7;    \\nprivate:\\n    ll f(int ind,string &s,char first,char second,int len,vector<vector<vector<vector<ll>>>> &dp){\\n        if(len == 5){return 1;}\\n        if(ind >= s.size()){return 0;}\\n        if(dp[ind][first-\\'0\\'][second - \\'0\\'][len] != -1){return dp[ind][first-\\'0\\'][second - \\'0\\'][len];}\\n\\n        ll w1 = 0;\\n        ll w2 = 0; \\n        ll w3 = 0; \\n        ll w4 = 0; \\n        ll w5 = 0; \\n        if(len == 0){\\n            w1 = f(ind+1,s,s[ind],second,len+1,dp)% mod;\\n        }\\n\\n        if(len == 1){\\n            w2 = f(ind+1,s,first,s[ind],len+1,dp)% mod;\\n        }\\n\\n        if(len == 2){\\n            w3 = f(ind+1,s,first,second,len+1,dp)% mod;\\n        }\\n\\n        if(len == 3 && s[ind] == second){\\n            w4 = f(ind+1,s,first,second,len+1,dp)% mod;\\n        }\\n\\n        if(len == 4 && s[ind] == first){\\n            w5 = f(ind+1,s,first,second,len+1,dp)% mod;\\n        }\\n        return dp[ind][first-\\'0\\'][second - \\'0\\'][len] = w1 + w2 + w3 + w4 + w5 + f(ind+1,s,first,second,len,dp) % mod;\\n    }\\n\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        vector<vector<vector<vector<ll>>>> dp(n+1,vector<vector<vector<ll>>>(9+1,vector<vector<ll>>(9+1,vector<ll>(5+1,-1))));\\n        return f(0,s,\\'1\\',\\'1\\',0,dp)% mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\nint mod = 1e9+7;    \\nprivate:\\n    ll f(int ind,string &s,char first,char second,int len){\\n        if(len == 5){return 1;}\\n        if(ind >= s.size()){return 0;}\\n\\n        ll w1 = 0;\\n        ll w2 = 0; \\n        ll w3 = 0; \\n        ll w4 = 0; \\n        ll w5 = 0; \\n        if(len == 0){\\n            w1 = f(ind+1,s,s[ind],second,len+1)% mod;\\n        }\\n\\n        if(len == 1){\\n            w2 = f(ind+1,s,first,s[ind],len+1)% mod;\\n        }\\n\\n        if(len == 2){\\n            w3 = f(ind+1,s,first,second,len+1)% mod;\\n        }\\n\\n        if(len == 3 && s[ind] == second){\\n            w4 = f(ind+1,s,first,second,len+1)% mod;\\n        }\\n\\n        if(len == 4 && s[ind] == first){\\n            w5 = f(ind+1,s,first,second,len+1)% mod;\\n        }\\n        return w1 + w2 + w3 + w4 + w5 + f(ind+1,s,first,second,len) % mod;\\n    }\\n\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        return f(0,s,\\'*\\',\\'*\\',0)% mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\ntypedef long long ll;\\nint mod = 1e9+7;    \\nprivate:\\n    ll f(int ind,string &s,char first,char second,int len,vector<vector<vector<vector<ll>>>> &dp){\\n        if(len == 5){return 1;}\\n        if(ind >= s.size()){return 0;}\\n        if(dp[ind][first-\\'0\\'][second - \\'0\\'][len] != -1){return dp[ind][first-\\'0\\'][second - \\'0\\'][len];}\\n\\n        ll w1 = 0;\\n        ll w2 = 0; \\n        ll w3 = 0; \\n        ll w4 = 0; \\n        ll w5 = 0; \\n        if(len == 0){\\n            w1 = f(ind+1,s,s[ind],second,len+1,dp)% mod;\\n        }\\n\\n        if(len == 1){\\n            w2 = f(ind+1,s,first,s[ind],len+1,dp)% mod;\\n        }\\n\\n        if(len == 2){\\n            w3 = f(ind+1,s,first,second,len+1,dp)% mod;\\n        }\\n\\n        if(len == 3 && s[ind] == second){\\n            w4 = f(ind+1,s,first,second,len+1,dp)% mod;\\n        }\\n\\n        if(len == 4 && s[ind] == first){\\n            w5 = f(ind+1,s,first,second,len+1,dp)% mod;\\n        }\\n        return dp[ind][first-\\'0\\'][second - \\'0\\'][len] = w1 + w2 + w3 + w4 + w5 + f(ind+1,s,first,second,len,dp) % mod;\\n    }\\n\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.size();\\n        vector<vector<vector<vector<ll>>>> dp(n+1,vector<vector<vector<ll>>>(9+1,vector<vector<ll>>(9+1,vector<ll>(5+1,-1))));\\n        return f(0,s,\\'1\\',\\'1\\',0,dp)% mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852865,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int N = s.size(), preCnt[10]{}, dp[10001][100]{}, prefix[100]{}, suffix[100]{}, tailCnt[10]{};\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < 10; j++) prefix[j*10 + (s[i]-\\'0\\')] += preCnt[j];\\n            copy(begin(prefix), end(prefix), begin(dp[i]));\\n            preCnt[s[i]-\\'0\\']++;\\n        }\\n\\n        long long ans = 0, mod = 1e9+7;\\n        for(int i = N-1; i >= 2; i--) {\\n            for(int k = 0; k < 100; k++) ans = (ans + ((long long)suffix[k]*dp[i-1][k]))%mod;\\n            for(int j = 0; j < 10; j++) suffix[j*10 + (s[i]-\\'0\\')] += tailCnt[j];\\n            tailCnt[s[i]-\\'0\\']++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int N = s.size(), preCnt[10]{}, dp[10001][100]{}, prefix[100]{}, suffix[100]{}, tailCnt[10]{};\\n\\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < 10; j++) prefix[j*10 + (s[i]-\\'0\\')] += preCnt[j];\\n            copy(begin(prefix), end(prefix), begin(dp[i]));\\n            preCnt[s[i]-\\'0\\']++;\\n        }\\n\\n        long long ans = 0, mod = 1e9+7;\\n        for(int i = N-1; i >= 2; i--) {\\n            for(int k = 0; k < 100; k++) ans = (ans + ((long long)suffix[k]*dp[i-1][k]))%mod;\\n            for(int j = 0; j < 10; j++) suffix[j*10 + (s[i]-\\'0\\')] += tailCnt[j];\\n            tailCnt[s[i]-\\'0\\']++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852842,
                "title": "c-dp-recursion",
                "content": "# Intuition\\nBasic recursion.\\n\\n# Approach\\nKeep track of every postion either it already taken or not so I used bool middle, tick1, tick2.\\n\\n# Complexity\\n- Time complexity:\\nO(length * 10 * 10 * 2 * 2 * 2)\\n\\n- Space complexity:\\nO(length * 10 * 10 * 2 * 2 * 2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    long long cache[10004][11][11][2][2][2];\\n    long long dp(int i, int prev1, int prev2, int middle, int tick1, int tick2, string &s) {\\n        if(i == (int) s.size()) {\\n            return (tick2 ? 1 : 0);\\n        } \\n        long long& ans = cache[i][prev1][prev2][middle][tick1][tick2];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        ans += dp(i + 1, prev1, prev2, middle, tick1, tick2, s);\\n        if(!prev1) {\\n            ans += dp(i + 1, s[i] - \\'0\\' + 1, prev2, middle, tick1, tick2, s);\\n        }\\n        else if(!prev2) {\\n            ans += dp(i + 1, prev1, s[i] - \\'0\\' + 1, middle, tick1, tick2, s);\\n        }\\n        else if(!middle) {\\n            ans += dp(i + 1, prev1, prev2, 1, tick1, tick2, s);\\n        }\\n        else if(!tick1 && s[i] - \\'0\\' == prev2 - 1) {\\n            ans += dp(i + 1, prev1, prev2, middle, 1, tick2, s);\\n        }\\n        else if(tick1 && !tick2 && s[i] - \\'0\\' == prev1 - 1) {\\n            ans += dp(i + 1, prev1, prev2, middle, tick1, 1, s);\\n        }\\n        ans %= mod;\\n        return ans;\\n    }\\n    int countPalindromes(string s) {\\n        memset(cache, -1, sizeof(cache));\\n        long long ans = dp(0, 0, 0, 0, 0, 0, s);\\n        ans %= mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    long long cache[10004][11][11][2][2][2];\\n    long long dp(int i, int prev1, int prev2, int middle, int tick1, int tick2, string &s) {\\n        if(i == (int) s.size()) {\\n            return (tick2 ? 1 : 0);\\n        } \\n        long long& ans = cache[i][prev1][prev2][middle][tick1][tick2];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        ans += dp(i + 1, prev1, prev2, middle, tick1, tick2, s);\\n        if(!prev1) {\\n            ans += dp(i + 1, s[i] - \\'0\\' + 1, prev2, middle, tick1, tick2, s);\\n        }\\n        else if(!prev2) {\\n            ans += dp(i + 1, prev1, s[i] - \\'0\\' + 1, middle, tick1, tick2, s);\\n        }\\n        else if(!middle) {\\n            ans += dp(i + 1, prev1, prev2, 1, tick1, tick2, s);\\n        }\\n        else if(!tick1 && s[i] - \\'0\\' == prev2 - 1) {\\n            ans += dp(i + 1, prev1, prev2, middle, 1, tick2, s);\\n        }\\n        else if(tick1 && !tick2 && s[i] - \\'0\\' == prev1 - 1) {\\n            ans += dp(i + 1, prev1, prev2, middle, tick1, 1, s);\\n        }\\n        ans %= mod;\\n        return ans;\\n    }\\n    int countPalindromes(string s) {\\n        memset(cache, -1, sizeof(cache));\\n        long long ans = dp(0, 0, 0, 0, 0, 0, s);\\n        ans %= mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852660,
                "title": "python-4-d-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 1000000007\\n        \\n        @cache\\n        def dp(idx: int, first: int, second: int, sz: int) -> int:\\n            if sz == 5:\\n                return 1\\n            if idx == len(s):\\n                return 0\\n            res = dp(idx + 1, first, second, sz)\\n            if sz == 0:\\n                res = (res + dp(idx + 1, (ord(s[idx]) - ord(\\'0\\')), second, sz + 1)) % MOD\\n            elif sz == 1:\\n                res = (res + dp(idx + 1, first, (ord(s[idx]) - ord(\\'0\\')), sz + 1)) % MOD\\n            elif sz == 2:\\n                res = (res + dp(idx + 1, first, second, sz + 1)) % MOD\\n            elif sz == 3:\\n                if ord(s[idx]) - ord(\\'0\\') == second:\\n                    res = (res + dp(idx + 1, first, second, sz + 1)) % MOD\\n            elif sz == 4:\\n                if ord(s[idx]) - ord(\\'0\\') == first:\\n                    res = (res + dp(idx + 1, first, second, sz + 1)) % MOD\\n            return res\\n        \\n        return dp(0, 10, 10, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 1000000007\\n        \\n        @cache\\n        def dp(idx: int, first: int, second: int, sz: int) -> int:\\n            if sz == 5:\\n                return 1\\n            if idx == len(s):\\n                return 0\\n            res = dp(idx + 1, first, second, sz)\\n            if sz == 0:\\n                res = (res + dp(idx + 1, (ord(s[idx]) - ord(\\'0\\')), second, sz + 1)) % MOD\\n            elif sz == 1:\\n                res = (res + dp(idx + 1, first, (ord(s[idx]) - ord(\\'0\\')), sz + 1)) % MOD\\n            elif sz == 2:\\n                res = (res + dp(idx + 1, first, second, sz + 1)) % MOD\\n            elif sz == 3:\\n                if ord(s[idx]) - ord(\\'0\\') == second:\\n                    res = (res + dp(idx + 1, first, second, sz + 1)) % MOD\\n            elif sz == 4:\\n                if ord(s[idx]) - ord(\\'0\\') == first:\\n                    res = (res + dp(idx + 1, first, second, sz + 1)) % MOD\\n            return res\\n        \\n        return dp(0, 10, 10, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852440,
                "title": "c-greedy-o-n-100",
                "content": "```\\nint countPalindromes(string s) {\\n\\tint cnt1[10] = {}, cnt2[100] = {}, cnt3[100] = {}, cnt4[10] = {}, res = 0, mod = 1e9 + 7;\\n\\tfor (char c : s) {\\n\\t\\tint curr = c - \\'0\\';\\n\\t\\tres = (res + cnt4[curr]) % mod;\\n\\t\\tfor (int i = curr; i < 100; i += 10)\\n\\t\\t\\tcnt4[i / 10] = (cnt4[i / 10] + cnt3[i]) % mod;\\n\\t\\tfor (int i = 0; i < 100; i++)\\n\\t\\t\\tcnt3[i] = (cnt3[i] + cnt2[i]) % mod;\\n\\t\\tfor (int i = 0; i < 10; i++)\\n\\t\\t\\tcnt2[i * 10 + curr] = (cnt2[i * 10 + curr] + cnt1[i]) % mod;\\n\\t\\tcnt1[curr] = (cnt1[curr] + 1) % mod;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint countPalindromes(string s) {\\n\\tint cnt1[10] = {}, cnt2[100] = {}, cnt3[100] = {}, cnt4[10] = {}, res = 0, mod = 1e9 + 7;\\n\\tfor (char c : s) {\\n\\t\\tint curr = c - \\'0\\';\\n\\t\\tres = (res + cnt4[curr]) % mod;\\n\\t\\tfor (int i = curr; i < 100; i += 10)\\n\\t\\t\\tcnt4[i / 10] = (cnt4[i / 10] + cnt3[i]) % mod;\\n\\t\\tfor (int i = 0; i < 100; i++)\\n\\t\\t\\tcnt3[i] = (cnt3[i] + cnt2[i]) % mod;\\n\\t\\tfor (int i = 0; i < 10; i++)\\n\\t\\t\\tcnt2[i * 10 + curr] = (cnt2[i * 10 + curr] + cnt1[i]) % mod;\\n\\t\\tcnt1[curr] = (cnt1[curr] + 1) % mod;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852383,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    long mod=1e9+7;\\n    int countPalindromes(string s) { \\n        int n=s.size(),ans=0; \\n        \\n        map<long,long> freql,freqr;  \\n        vector<long> fl(10,0);\\n        vector<long> fr(10,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int dig=s[i]-\\'0\\';\\n            \\n            for(int j=0;j<10;j++){\\n                int num=dig*10+j;\\n                freqr[num]+=fr[j];\\n            }\\n            fr[s[i]-\\'0\\']++;\\n        } \\n        \\n        for(int pp=0;pp<n;pp++){\\n            int dig=s[pp]-\\'0\\';\\n            \\n            fr[dig]--; \\n            for(int i=0;i<10;i++){\\n                int num=dig*10+i;\\n                freqr[num]-=fr[i];\\n            }\\n            \\n            for(int i=0;i<10;i++){\\n                for(int j=0;j<10;j++){\\n                    int num=10*i+j;\\n                    int op=10*j+i;\\n                    ans+=freql[num]*freqr[op];\\n                    ans=ans%mod;\\n                }\\n            }\\n            \\n            for(int i=0;i<10;i++){\\n                int num=i*10+dig;\\n                freql[num]+=fl[i];\\n            } \\n            fl[dig]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long mod=1e9+7;\\n    int countPalindromes(string s) { \\n        int n=s.size(),ans=0; \\n        \\n        map<long,long> freql,freqr;  \\n        vector<long> fl(10,0);\\n        vector<long> fr(10,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int dig=s[i]-\\'0\\';\\n            \\n            for(int j=0;j<10;j++){\\n                int num=dig*10+j;\\n                freqr[num]+=fr[j];\\n            }\\n            fr[s[i]-\\'0\\']++;\\n        } \\n        \\n        for(int pp=0;pp<n;pp++){\\n            int dig=s[pp]-\\'0\\';\\n            \\n            fr[dig]--; \\n            for(int i=0;i<10;i++){\\n                int num=dig*10+i;\\n                freqr[num]-=fr[i];\\n            }\\n            \\n            for(int i=0;i<10;i++){\\n                for(int j=0;j<10;j++){\\n                    int num=10*i+j;\\n                    int op=10*j+i;\\n                    ans+=freql[num]*freqr[op];\\n                    ans=ans%mod;\\n                }\\n            }\\n            \\n            for(int i=0;i<10;i++){\\n                int num=i*10+dig;\\n                freql[num]+=fl[i];\\n            } \\n            fl[dig]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851843,
                "title": "c-beats-100-both-time-memory-o-n-tc-o-1-sc",
                "content": "![\\u622A\\u5C4F2022-11-27 10.41.20.png](https://assets.leetcode.com/users/images/dc1417b9-7565-4e74-809d-954a366f3b44_1669516966.0377843.png)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ -> `n` is the length of the string `s`.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int countPalindromes(const string& s) {\\n        const int n = size(s);\\n        if (n < 5)\\n            return 0;\\n        int cnt[10]{}, cnt2[100]{}, rcnt[10]{}, rcnt2[100]{};\\n        for (int i = n - 1; i > 0; --i) {\\n            for (int j = 0; j < 10; ++j)\\n                rcnt2[10 * (s[i] - \\'0\\') + j] += rcnt[j];\\n            ++rcnt[s[i] - \\'0\\'];\\n        }\\n        int ret = 0;\\n        for (int i = 0; i < n - 3; ++i) {\\n            for (int j = 0; j < 10; ++j)\\n                cnt2[10 * (s[i] - \\'0\\') + j] += cnt[j];\\n            ++cnt[s[i] - \\'0\\'];\\n            --rcnt[s[i + 1] - \\'0\\'];\\n            for (int j = 0; j < 10; ++j)\\n                rcnt2[10 * (s[i + 1] - \\'0\\') + j] -= rcnt[j];\\n            for (int j = 0; j < 100; ++j) {\\n                int64_t a = cnt2[j];\\n                a *= rcnt2[j];\\n                ret = (ret + a) % 1000000007;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int countPalindromes(const string& s) {\\n        const int n = size(s);\\n        if (n < 5)\\n            return 0;\\n        int cnt[10]{}, cnt2[100]{}, rcnt[10]{}, rcnt2[100]{};\\n        for (int i = n - 1; i > 0; --i) {\\n            for (int j = 0; j < 10; ++j)\\n                rcnt2[10 * (s[i] - \\'0\\') + j] += rcnt[j];\\n            ++rcnt[s[i] - \\'0\\'];\\n        }\\n        int ret = 0;\\n        for (int i = 0; i < n - 3; ++i) {\\n            for (int j = 0; j < 10; ++j)\\n                cnt2[10 * (s[i] - \\'0\\') + j] += cnt[j];\\n            ++cnt[s[i] - \\'0\\'];\\n            --rcnt[s[i + 1] - \\'0\\'];\\n            for (int j = 0; j < 10; ++j)\\n                rcnt2[10 * (s[i + 1] - \\'0\\') + j] -= rcnt[j];\\n            for (int j = 0; j < 100; ++j) {\\n                int64_t a = cnt2[j];\\n                a *= rcnt2[j];\\n                ret = (ret + a) % 1000000007;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851613,
                "title": "c-dp-beat-100-time-21ms-100-memory-6-4mb",
                "content": "# Intuition\\nDP to save subseq w/ the pattern of i j X j i.\\n\\n# Approach\\ndp1 save # subseq w/ the pattern of i.\\ndp2 save # subseq w/ the pattern of i j.\\ndp3 save # subseq w/ the pattern of i j X.\\ndp4 save # subseq w/ the pattern of i j X j.\\ndp5 save # subseq w/ the pattern of i j X j i.\\nSum of dp5 give is the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n      int n = s.length();\\n      int dp1[10] = {0};     // # subseq w/ i\\n      int dp2[10][10] = {0}; // # subseq w/ i j\\n      int dp3[10][10] = {0}; // # subseq w/ i j X\\n      int dp4[10][10] = {0}; // # subseq w/ i j X j\\n      int dp5[10][10] = {0}; // # subseq w/ i j X j i\\n      int mod_p = 1000000007;\\n      for (char c: s) {\\n        for (int i = 0; i < 10; i++) {\\n          for (int j = 0; j < 10; j++) {\\n                if (c-\\'0\\' == i) {\\n                  dp5[i][j] = (dp5[i][j]+dp4[i][j]) % mod_p;\\n                }\\n          }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n          for (int j = 0; j < 10; j++) {\\n              if (c-\\'0\\' == j) {\\n                dp4[i][j] = (dp4[i][j]+dp3[i][j]) % mod_p;\\n              }\\n          }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n          for (int j = 0; j < 10; j++) {\\n            dp3[i][j] = (dp3[i][j]+dp2[i][j]) % mod_p;\\n          }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n          dp2[i][c-\\'0\\'] = (dp2[i][c-\\'0\\']+dp1[i]) % mod_p;\\n        }\\n        dp1[c-\\'0\\'] = (dp1[c-\\'0\\'] + 1) % mod_p;\\n      }\\n      int res = 0;\\n      for (int i = 0; i < 10; i++) {\\n        for (int j = 0; j < 10; j++) {\\n           res = (res + dp5[i][j]) % mod_p;\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n      int n = s.length();\\n      int dp1[10] = {0};     // # subseq w/ i\\n      int dp2[10][10] = {0}; // # subseq w/ i j\\n      int dp3[10][10] = {0}; // # subseq w/ i j X\\n      int dp4[10][10] = {0}; // # subseq w/ i j X j\\n      int dp5[10][10] = {0}; // # subseq w/ i j X j i\\n      int mod_p = 1000000007;\\n      for (char c: s) {\\n        for (int i = 0; i < 10; i++) {\\n          for (int j = 0; j < 10; j++) {\\n                if (c-\\'0\\' == i) {\\n                  dp5[i][j] = (dp5[i][j]+dp4[i][j]) % mod_p;\\n                }\\n          }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n          for (int j = 0; j < 10; j++) {\\n              if (c-\\'0\\' == j) {\\n                dp4[i][j] = (dp4[i][j]+dp3[i][j]) % mod_p;\\n              }\\n          }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n          for (int j = 0; j < 10; j++) {\\n            dp3[i][j] = (dp3[i][j]+dp2[i][j]) % mod_p;\\n          }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n          dp2[i][c-\\'0\\'] = (dp2[i][c-\\'0\\']+dp1[i]) % mod_p;\\n        }\\n        dp1[c-\\'0\\'] = (dp1[c-\\'0\\'] + 1) % mod_p;\\n      }\\n      int res = 0;\\n      for (int i = 0; i < 10; i++) {\\n        for (int j = 0; j < 10; j++) {\\n           res = (res + dp5[i][j]) % mod_p;\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851586,
                "title": "c-counting-with-o-1-space-faster-than-100",
                "content": "```\\ntypedef long long ll;\\n#define mdl 1000000007\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        ll ans = 0;\\n        for(int n = 0 ; n < 10 ; ++n){\\n            for(int m = 0 ; m < 10 ; ++m){\\n                ll cntr = 0, cntl = 0;\\n                ll r = 0, l = 0;\\n                for(int i = s.size()-1 ; i >= 0 ; --i){\\n                    if(s[i]-\\'0\\' == m) cntr += r;\\n                    if(s[i]-\\'0\\' == n) ++r; \\n                }\\n                for(int i = 0 ; i < s.size() ; ++i){\\n                    if(s[i]-\\'0\\' == n) --r;\\n                    if(s[i]-\\'0\\' == m) cntr -= r;\\n                    ans = (ans + cntl*cntr) % mdl;\\n                    if(s[i]-\\'0\\' == m) cntl += l;\\n                    if(s[i]-\\'0\\' == n) ++l;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\n#define mdl 1000000007\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        ll ans = 0;\\n        for(int n = 0 ; n < 10 ; ++n){\\n            for(int m = 0 ; m < 10 ; ++m){\\n                ll cntr = 0, cntl = 0;\\n                ll r = 0, l = 0;\\n                for(int i = s.size()-1 ; i >= 0 ; --i){\\n                    if(s[i]-\\'0\\' == m) cntr += r;\\n                    if(s[i]-\\'0\\' == n) ++r; \\n                }\\n                for(int i = 0 ; i < s.size() ; ++i){\\n                    if(s[i]-\\'0\\' == n) --r;\\n                    if(s[i]-\\'0\\' == m) cntr -= r;\\n                    ans = (ans + cntl*cntr) % mdl;\\n                    if(s[i]-\\'0\\' == m) cntl += l;\\n                    if(s[i]-\\'0\\' == n) ++l;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851420,
                "title": "o-100-n-time-and-o-n-memory-straightforward-solution-with-explanation",
                "content": "#### Thought process:\\nIn order to count all plaindromic with length 5 e.g. `xyzyx`\\nwe need to count the number of `xy` before  multiplite by the number of `yx` after for every possilbe `z`\\nand we know that `xy` is of length 2 so to get all possible `xy` we loop from `00` to `99`\\nand yx is just the reverse of that\\nwe then prefix sum all possible count of `xy` \\nand suffix sum all possible count of `yx`\\nand loop for every z and add `prefix[z] * suffix[z]`\\n\\n\\nTime : O(100n) n is the length of ths string\\nMemory: O(n)\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = size(s);\\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        string t;\\n        int count0;\\n        vector<long long> left(n), right(n);\\n        for(int k = 0; k < 100; k++) {\\n            t = getString(k);\\n            count0 = s[0] == t[0];\\n            for(int i = 1; i < n; i++) {\\n                left[i] = 0;\\n                if (s[i] == t[1]) left[i] = count0;\\n                count0 += s[i] == t[0];\\n                left[i] += left[i - 1];\\n            }\\n            count0 = s[n - 1] == t[0];\\n            for(int i = n - 2; i >= 0; i--) {\\n                right[i] = 0;\\n                if (s[i] == t[1]) right[i] = count0;\\n                count0 += s[i] == t[0];\\n                right[i] += right[i + 1];\\n            }\\n            for(int i = 1; i+1 < n; i++) {\\n                ans += (left[i - 1] * right[i + 1]);\\n                ans %= mod;\\n            } \\n        }\\n        return ans;\\n    }\\n    string getString(int x) {\\n        if (x >= 10) return to_string(x);\\n        string s = \"0\";\\n        s += (x + \\'0\\');\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = size(s);\\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        string t;\\n        int count0;\\n        vector<long long> left(n), right(n);\\n        for(int k = 0; k < 100; k++) {\\n            t = getString(k);\\n            count0 = s[0] == t[0];\\n            for(int i = 1; i < n; i++) {\\n                left[i] = 0;\\n                if (s[i] == t[1]) left[i] = count0;\\n                count0 += s[i] == t[0];\\n                left[i] += left[i - 1];\\n            }\\n            count0 = s[n - 1] == t[0];\\n            for(int i = n - 2; i >= 0; i--) {\\n                right[i] = 0;\\n                if (s[i] == t[1]) right[i] = count0;\\n                count0 += s[i] == t[0];\\n                right[i] += right[i + 1];\\n            }\\n            for(int i = 1; i+1 < n; i++) {\\n                ans += (left[i - 1] * right[i + 1]);\\n                ans %= mod;\\n            } \\n        }\\n        return ans;\\n    }\\n    string getString(int x) {\\n        if (x >= 10) return to_string(x);\\n        string s = \"0\";\\n        s += (x + \\'0\\');\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851349,
                "title": "o-n-c-bottom-up-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere will be 2 cases everytime whether to select current index or to not select it.\\nIf we are selecting the ind then, it would depend on i where i is the number of characters selected. If i==5, it means we have got a palindrome of size 5\\nThe general structure of a 5 letter palindrome would be xy_yx.\\nIf i==0 -> the next call would be (ind)y_yx\\nIf i==1 -> the next call would be x(ind)_yx\\nIf i==2 -> the next call would be xy_yx\\nIf i==3 -> the next call would be x(ind)_(ind)x\\nIf i==4 -> the next call would be (ind)y_y(ind)\\n\\nThen we just apply dp where state of the variables are x,y,ind and i.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[10001][11][11][6];\\n    //xy_yx\\n    int dfs(int ind,int x,int y,int i,string &s)\\n    {\\n        if(i==5)\\n        return 1;\\n        if(ind==s.size())\\n        return 0;\\n        if(dp[ind][x][y][i]!=-1)\\n            return dp[ind][x][y][i];\\n        //not chosing current ind\\n        long long int res = dfs(ind+1,x,y,i,s);\\n        int mod = 1e9+7;\\n        //chosing current ind\\n        if(i==0)\\n        {\\n            //iy_yx\\n            res+=dfs(ind+1,s[ind]-\\'0\\',y,i+1,s);\\n            res%=mod;\\n        }\\n        else if(i==1)\\n        {\\n            // xi_yx\\n            res+=dfs(ind+1,x,s[ind]-\\'0\\',i+1,s);\\n            res%=mod;\\n        }\\n        else if(i==2)\\n        {\\n            // xy_yx\\n            res+=dfs(ind+1,x,y,i+1,s);\\n            res%=mod;\\n        }\\n        else if(i==3)\\n        {\\n            // xi_ix\\n            if(s[ind]-\\'0\\'==y)\\n            {\\n                res+=dfs(ind+1,x,y,i+1,s);\\n                res%=mod;\\n            }\\n        }\\n        else if(i==4)\\n        {\\n            // iy_yi\\n            if(s[ind]-\\'0\\'== x)\\n            {\\n                res+=dfs(ind+1,x,y,i+1,s);\\n                res%=mod;\\n            }\\n        }\\n        return dp[ind][x][y][i] = res;\\n    }\\npublic:\\n    int countPalindromes(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return dfs(0,0,0,0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int dp[10001][11][11][6];\\n    //xy_yx\\n    int dfs(int ind,int x,int y,int i,string &s)\\n    {\\n        if(i==5)\\n        return 1;\\n        if(ind==s.size())\\n        return 0;\\n        if(dp[ind][x][y][i]!=-1)\\n            return dp[ind][x][y][i];\\n        //not chosing current ind\\n        long long int res = dfs(ind+1,x,y,i,s);\\n        int mod = 1e9+7;\\n        //chosing current ind\\n        if(i==0)\\n        {\\n            //iy_yx\\n            res+=dfs(ind+1,s[ind]-\\'0\\',y,i+1,s);\\n            res%=mod;\\n        }\\n        else if(i==1)\\n        {\\n            // xi_yx\\n            res+=dfs(ind+1,x,s[ind]-\\'0\\',i+1,s);\\n            res%=mod;\\n        }\\n        else if(i==2)\\n        {\\n            // xy_yx\\n            res+=dfs(ind+1,x,y,i+1,s);\\n            res%=mod;\\n        }\\n        else if(i==3)\\n        {\\n            // xi_ix\\n            if(s[ind]-\\'0\\'==y)\\n            {\\n                res+=dfs(ind+1,x,y,i+1,s);\\n                res%=mod;\\n            }\\n        }\\n        else if(i==4)\\n        {\\n            // iy_yi\\n            if(s[ind]-\\'0\\'== x)\\n            {\\n                res+=dfs(ind+1,x,y,i+1,s);\\n                res%=mod;\\n            }\\n        }\\n        return dp[ind][x][y][i] = res;\\n    }\\npublic:\\n    int countPalindromes(string s) {\\n        memset(dp,-1,sizeof dp);\\n        return dfs(0,0,0,0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851311,
                "title": "easy-pairing-logic-t-c-s-c-o-10-10-n",
                "content": "```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long arrl[] = new long[10];\\n        long arrr[] = new long[10];\\n        long dpl[][][] = new long[10][10][n];\\n        long dpr[][][] = new long[10][10][n];\\n        long mod = 1000000007l;\\n        for(int i = 0; i < n; i++){\\n            int digit = s.charAt(i) - \\'0\\';\\n            for(int j = 0; j < 10; j++){\\n                if(arrl[j] > 0){\\n                    long count = arrl[j];\\n                    dpl[j][digit][i] = ((dpl[j][digit][i] % mod) + (count % mod)) % mod;\\n                }\\n            }\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    if(i > 0 && arrl[j] > 0){\\n                        dpl[j][k][i] = ((dpl[j][k][i] % mod) + (dpl[j][k][i - 1] % mod)) % mod;\\n                    }\\n                }\\n            }\\n            arrl[digit] = (arrl[digit] + 1) % mod;\\n        }\\n        for(int i = n - 1; i >= 0; i--){\\n            int digit = s.charAt(i) - \\'0\\';\\n            for(int j = 0; j < 10; j++){\\n                if(arrr[j] > 0 && arrr[j] > 0){\\n                    long count = arrr[j];\\n                    dpr[j][digit][i] = ((dpr[j][digit][i] % mod) + (count % mod)) % mod;\\n                }\\n            }\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    if(i < n - 1 && arrr[j] > 0){\\n                        dpr[j][k][i] = ((dpr[j][k][i] % mod) + (dpr[j][k][i + 1] % mod) % mod);\\n                    }\\n                }\\n            }\\n            arrr[digit] = (arrr[digit] + 1) % mod;\\n        }\\n        long ans = 0;\\n        for(int i = 2; i < n - 2; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    if(dpl[j][k][i - 1] > 0 && dpr[j][k][i + 1] > 0){\\n                        ans = ((ans % mod) + (dpl[j][k][i - 1] * dpr[j][k][i + 1]) % mod) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        return (int)(ans % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long arrl[] = new long[10];\\n        long arrr[] = new long[10];\\n        long dpl[][][] = new long[10][10][n];\\n        long dpr[][][] = new long[10][10][n];\\n        long mod = 1000000007l;\\n        for(int i = 0; i < n; i++){\\n            int digit = s.charAt(i) - \\'0\\';\\n            for(int j = 0; j < 10; j++){\\n                if(arrl[j] > 0){\\n                    long count = arrl[j];\\n                    dpl[j][digit][i] = ((dpl[j][digit][i] % mod) + (count % mod)) % mod;\\n                }\\n            }\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    if(i > 0 && arrl[j] > 0){\\n                        dpl[j][k][i] = ((dpl[j][k][i] % mod) + (dpl[j][k][i - 1] % mod)) % mod;\\n                    }\\n                }\\n            }\\n            arrl[digit] = (arrl[digit] + 1) % mod;\\n        }\\n        for(int i = n - 1; i >= 0; i--){\\n            int digit = s.charAt(i) - \\'0\\';\\n            for(int j = 0; j < 10; j++){\\n                if(arrr[j] > 0 && arrr[j] > 0){\\n                    long count = arrr[j];\\n                    dpr[j][digit][i] = ((dpr[j][digit][i] % mod) + (count % mod)) % mod;\\n                }\\n            }\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    if(i < n - 1 && arrr[j] > 0){\\n                        dpr[j][k][i] = ((dpr[j][k][i] % mod) + (dpr[j][k][i + 1] % mod) % mod);\\n                    }\\n                }\\n            }\\n            arrr[digit] = (arrr[digit] + 1) % mod;\\n        }\\n        long ans = 0;\\n        for(int i = 2; i < n - 2; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int k = 0; k < 10; k++){\\n                    if(dpl[j][k][i - 1] > 0 && dpr[j][k][i + 1] > 0){\\n                        ans = ((ans % mod) + (dpl[j][k][i - 1] * dpr[j][k][i + 1]) % mod) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        return (int)(ans % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851263,
                "title": "cpp-bottom-up-dp",
                "content": "Let the 5 letter palindrome be **abcba**. Here, we make the **c** as the mirror and let the number of **ab** in its left be *x*. Let the number of **ba** in its right be *y*. So, the number of palindromes having first 2 letters as **ab** which are centered on this **c** = x\\\\*y. We iterate over all the **ab** combination 10\\\\*10 times. So, our overall time complexity is 10\\\\*10\\\\*n = O(n)\\n\\n**Time :** *O(n)*\\n**Space :** *O(n)*\\n\\n\\n\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define pb push_back\\n#define mii map<int, int>\\n#define mll map<ll, ll>\\n#define pii pair<int, int>\\n#define pic pair<int, char>\\n#define pdd pair<double, double>\\n#define pll pair<ll, ll>\\n#define vvi vector<vector<int>>\\n#define ull unsigned long long int\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll pre[10][10][10001],suf[10][10][10001];\\n    ll p1[10][10001],s1[10][10001];\\n\\t//    p1[i][j] : Number of occurrences of \\'0\\'+i in s[0]~s[j] and vice versa for s1\\n\\n    void ct(string &s){\\n        int n=s.size();\\n        for(int i=0;i<=9;i++){\\n            p1[i][0]=(s[0]-\\'0\\'==i);\\n            for(int pos=1;pos<n;pos++){\\n                p1[i][pos]=(p1[i][pos-1]+(s[pos]-\\'0\\'==i));\\n            }\\n            s1[i][n-1]=(s[n-1]-\\'0\\'==i);\\n            for(int pos=n-2;pos>=0;pos--){\\n                s1[i][pos]=(s1[i][pos+1]+(s[pos]-\\'0\\'==i));\\n            }\\n        }\\n        // pre[i][j][k] : no of pair of ij in s[0]~s[k] and vice versa for suf\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int pos=1;pos<n;pos++){\\n                    pre[i][j][pos]=pre[i][j][pos-1];\\n                    if(s[pos]-\\'0\\'==j){\\n                        pre[i][j][pos]=(pre[i][j][pos]+p1[i][pos-1])%mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int pos=n-2;pos>=0;pos--){\\n                    suf[i][j][pos]=suf[i][j][pos+1];\\n                    if(s[pos]-\\'0\\'==i){\\n                        suf[i][j][pos]=(suf[i][j][pos]+s1[j][pos+1]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int countPalindromes(string s) {\\n        memset(pre,0,sizeof(pre));\\n        memset(pre,0,sizeof(suf));\\n        memset(p1,0,sizeof(p1));\\n        memset(s1,0,sizeof(s1));\\n        ll n=s.size(),ans=0;\\n        ct(s);\\n        for(int i=2;i+2<n;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int k=0;k<=9;k++){\\n                    // x : how many (j+\\'0\\',k+\\'0\\') exist in s[0]~s[i-1]\\n                    // y : how many (k+\\'0\\',j+\\'0\\') exist in s[i+1]~s[n-1]\\n                    // ans=(ans+x*y)%mod;\\n                    ans=(ans+pre[j][k][i-1]*suf[k][j][i+1])%mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define pb push_back\\n#define mii map<int, int>\\n#define mll map<ll, ll>\\n#define pii pair<int, int>\\n#define pic pair<int, char>\\n#define pdd pair<double, double>\\n#define pll pair<ll, ll>\\n#define vvi vector<vector<int>>\\n#define ull unsigned long long int\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    ll pre[10][10][10001],suf[10][10][10001];\\n    ll p1[10][10001],s1[10][10001];\\n\\t//    p1[i][j] : Number of occurrences of \\'0\\'+i in s[0]~s[j] and vice versa for s1\\n\\n    void ct(string &s){\\n        int n=s.size();\\n        for(int i=0;i<=9;i++){\\n            p1[i][0]=(s[0]-\\'0\\'==i);\\n            for(int pos=1;pos<n;pos++){\\n                p1[i][pos]=(p1[i][pos-1]+(s[pos]-\\'0\\'==i));\\n            }\\n            s1[i][n-1]=(s[n-1]-\\'0\\'==i);\\n            for(int pos=n-2;pos>=0;pos--){\\n                s1[i][pos]=(s1[i][pos+1]+(s[pos]-\\'0\\'==i));\\n            }\\n        }\\n        // pre[i][j][k] : no of pair of ij in s[0]~s[k] and vice versa for suf\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int pos=1;pos<n;pos++){\\n                    pre[i][j][pos]=pre[i][j][pos-1];\\n                    if(s[pos]-\\'0\\'==j){\\n                        pre[i][j][pos]=(pre[i][j][pos]+p1[i][pos-1])%mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<=9;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int pos=n-2;pos>=0;pos--){\\n                    suf[i][j][pos]=suf[i][j][pos+1];\\n                    if(s[pos]-\\'0\\'==i){\\n                        suf[i][j][pos]=(suf[i][j][pos]+s1[j][pos+1]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int countPalindromes(string s) {\\n        memset(pre,0,sizeof(pre));\\n        memset(pre,0,sizeof(suf));\\n        memset(p1,0,sizeof(p1));\\n        memset(s1,0,sizeof(s1));\\n        ll n=s.size(),ans=0;\\n        ct(s);\\n        for(int i=2;i+2<n;i++){\\n            for(int j=0;j<=9;j++){\\n                for(int k=0;k<=9;k++){\\n                    // x : how many (j+\\'0\\',k+\\'0\\') exist in s[0]~s[i-1]\\n                    // y : how many (k+\\'0\\',j+\\'0\\') exist in s[i+1]~s[n-1]\\n                    // ans=(ans+x*y)%mod;\\n                    ans=(ans+pre[j][k][i-1]*suf[k][j][i+1])%mod;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2851238,
                "title": "c-prefixsum-o-n-2-and-o-100n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLen = 5:  pattern is {a b x b a}\\n{ab} are in range 0 to 99\\n\\nFor each center x, ans += count(left) * count(right)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPre-Compute prefixSum{ba} from right.\\nCompute prefixSum{ab} from left.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(100*N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        vector<vector<int>> cnt_right(n, vector<int>(100, 0));\\n        for(int i = n-2; i >= 0; --i) {\\n            auto& v = cnt_right[i];\\n            v = cnt_right[i+1];\\n            int b = s[i] - \\'0\\';\\n            for(int j = i+1; j < n; ++j) {\\n                int a = s[j] - \\'0\\';\\n                int c = a*10+b;\\n                v[c]++;\\n            }\\n        }\\n        int64_t ans = 0;\\n        int p = 1e9 + 7;\\n        vector<int> left(100, 0);\\n        for(int i = 1; i < (n-2); ++i) {\\n            auto & right = cnt_right[i+1];\\n            for(int j = 0; j < 100; ++j) {\\n                int64_t x = left[j];\\n                x*= right[j];\\n                ans += x;\\n                ans %= p;\\n            }\\n            \\n            int b = s[i] - \\'0\\';\\n            for(int j = 0; j < i; ++j) {\\n                int a = s[j] - \\'0\\';\\n                int c = a*10+b;\\n                left[c]++;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nVersion 2:  O(100N)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        if (n < 5) return 0;\\n        vector<vector<int>> right(n+1, vector<int>(10, 0));\\n        vector<vector<int>> left(n+1, vector<int>(10, 0));\\n        vector<vector<int>> w(n+1, vector<int>(100, 0));\\n        \\n        \\n        for(int i = n-1; i >= 0; --i) {\\n            auto& v = right[i]; v = right[i+1];\\n            int x = s[i] - \\'0\\';\\n            v[x]++;\\n            if (i < (n-1)) {\\n                w[i] = w[i+1];\\n                for(int j = 0; j < 10; ++j) {\\n                     w[i][x*10+j] += right[i + 1][j];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < (n-2); ++i) {\\n            auto& v = left[i]; if(i>0) v = left[i-1];\\n            int x = s[i] - \\'0\\';\\n            v[x]++;\\n        }\\n        \\n        \\n        int64_t ans = 0;\\n        int p = 1e9 + 7;\\n        vector<int64_t> v(100, 0);\\n        int a = s[0]-\\'0\\';\\n        int b = s[1]-\\'0\\';\\n        v[a+b*10] = 1;\\n        for(int i = 2; i < (n-2); ++i) {\\n            for(int d = 0; d < 100; ++d) {\\n                int64_t x = v[d];\\n                x*= w[i+1][d];\\n                ans+=x;\\n                ans%=p;\\n            }\\n            int x = s[i] - \\'0\\';\\n            for(int j = 0; j < 10; ++j) {\\n                v[x*10+j] += left[i - 1][j];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        vector<vector<int>> cnt_right(n, vector<int>(100, 0));\\n        for(int i = n-2; i >= 0; --i) {\\n            auto& v = cnt_right[i];\\n            v = cnt_right[i+1];\\n            int b = s[i] - \\'0\\';\\n            for(int j = i+1; j < n; ++j) {\\n                int a = s[j] - \\'0\\';\\n                int c = a*10+b;\\n                v[c]++;\\n            }\\n        }\\n        int64_t ans = 0;\\n        int p = 1e9 + 7;\\n        vector<int> left(100, 0);\\n        for(int i = 1; i < (n-2); ++i) {\\n            auto & right = cnt_right[i+1];\\n            for(int j = 0; j < 100; ++j) {\\n                int64_t x = left[j];\\n                x*= right[j];\\n                ans += x;\\n                ans %= p;\\n            }\\n            \\n            int b = s[i] - \\'0\\';\\n            for(int j = 0; j < i; ++j) {\\n                int a = s[j] - \\'0\\';\\n                int c = a*10+b;\\n                left[c]++;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        int n = s.length();\\n        if (n < 5) return 0;\\n        vector<vector<int>> right(n+1, vector<int>(10, 0));\\n        vector<vector<int>> left(n+1, vector<int>(10, 0));\\n        vector<vector<int>> w(n+1, vector<int>(100, 0));\\n        \\n        \\n        for(int i = n-1; i >= 0; --i) {\\n            auto& v = right[i]; v = right[i+1];\\n            int x = s[i] - \\'0\\';\\n            v[x]++;\\n            if (i < (n-1)) {\\n                w[i] = w[i+1];\\n                for(int j = 0; j < 10; ++j) {\\n                     w[i][x*10+j] += right[i + 1][j];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < (n-2); ++i) {\\n            auto& v = left[i]; if(i>0) v = left[i-1];\\n            int x = s[i] - \\'0\\';\\n            v[x]++;\\n        }\\n        \\n        \\n        int64_t ans = 0;\\n        int p = 1e9 + 7;\\n        vector<int64_t> v(100, 0);\\n        int a = s[0]-\\'0\\';\\n        int b = s[1]-\\'0\\';\\n        v[a+b*10] = 1;\\n        for(int i = 2; i < (n-2); ++i) {\\n            for(int d = 0; d < 100; ++d) {\\n                int64_t x = v[d];\\n                x*= w[i+1][d];\\n                ans+=x;\\n                ans%=p;\\n            }\\n            int x = s[i] - \\'0\\';\\n            for(int j = 0; j < 10; ++j) {\\n                v[x*10+j] += left[i - 1][j];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851224,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        n = len(s)\\n        ans = 0 \\n        MOD = int(1e9 + 7)\\n        \\n        for i in range(10): \\n            for j in range(10): \\n                \\n                x = str(i) + str(j) + \\'#\\' + str(j) + str(i) \\n                dp = [0, 0, 0, 0, 0, 1]\\n                \\n                for k in range(n): \\n                    for l in range(5): \\n                        if s[k] == x[l] or l == 2: \\n                            dp[l] += dp[l + 1]\\n                            \\n                ans += dp[0] % MOD\\n        \\n        return ans % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        n = len(s)\\n        ans = 0 \\n        MOD = int(1e9 + 7)\\n        \\n        for i in range(10): \\n            for j in range(10): \\n                \\n                x = str(i) + str(j) + \\'#\\' + str(j) + str(i) \\n                dp = [0, 0, 0, 0, 0, 1]\\n                \\n                for k in range(n): \\n                    for l in range(5): \\n                        if s[k] == x[l] or l == 2: \\n                            dp[l] += dp[l + 1]\\n                            \\n                ans += dp[0] % MOD\\n        \\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851167,
                "title": "python-3-3d-dp",
                "content": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        n = len(s)\\n        M = 10 ** 9 + 7\\n        \\n\\t\\t# p to store first two characters\\n\\t\\t# flag to indicate whether the middle character has been filled\\n        @cache\\n        def dp(i, p, flag):\\n            if flag and not p:\\n                return 1\\n            if i == n:\\n                return 0\\n\\n            if len(p) < 2 and not flag:\\n                return (dp(i + 1, p, flag) + dp(i + 1, p + s[i], flag)) % M\\n            elif len(p) == 2 and not flag:\\n                return (dp(i + 1, p, flag) + dp(i + 1, p, True)) % M\\n            else:\\n                if s[i] == p[-1]:\\n                    return (dp(i + 1, p, flag) + dp(i + 1, p[:-1], flag)) % M\\n                else:\\n                    return dp(i + 1, p, flag) % M\\n\\n                            \\n        \\n        return dp(0, \"\", False)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        \\n        n = len(s)\\n        M = 10 ** 9 + 7\\n        \\n\\t\\t# p to store first two characters\\n\\t\\t# flag to indicate whether the middle character has been filled\\n        @cache\\n        def dp(i, p, flag):\\n            if flag and not p:\\n                return 1\\n            if i == n:\\n                return 0\\n\\n            if len(p) < 2 and not flag:\\n                return (dp(i + 1, p, flag) + dp(i + 1, p + s[i], flag)) % M\\n            elif len(p) == 2 and not flag:\\n                return (dp(i + 1, p, flag) + dp(i + 1, p, True)) % M\\n            else:\\n                if s[i] == p[-1]:\\n                    return (dp(i + 1, p, flag) + dp(i + 1, p[:-1], flag)) % M\\n                else:\\n                    return dp(i + 1, p, flag) % M\\n\\n                            \\n        \\n        return dp(0, \"\", False)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2851054,
                "title": "left-to-right-precomputed-o-n-100-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int countPalindromes(string s) {\\n        ll n=s.size();\\n        if(n<5) return 0;\\n        map<ll,ll> mp;\\n        vector<vector<ll>> left(n,vector<ll>(100,0));\\n        mp[s[0]-\\'0\\']++;\\n        for(ll i=1;i<n;i++){\\n             for(int k=0;k<100;k++)\\n                 left[i][k] = left[i-1][k];\\n            for(int j=0;j<10;j++){\\n                int tmp = j*10 + (s[i]-\\'0\\');\\n                left[i][tmp] +=  mp[j];\\n            }\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        \\n        mp.clear();\\n        \\n        ll ans=0;\\n        vector<ll> right(100,0);\\n        \\n        for(int i=n-1;i>=2;i--){\\n            for(int k=0;k<100;k++){\\n                ll tmp = (k%10)*10 + k/10;\\n                ans += left[i-1][k] * right[tmp];\\n                ans%=mod;\\n            }\\n            \\n            for(int j=0;j<10;j++){\\n                ll tmp = (s[i]-\\'0\\')*10 + j;\\n                right[tmp]+=mp[j];\\n            }\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int countPalindromes(string s) {\\n        ll n=s.size();\\n        if(n<5) return 0;\\n        map<ll,ll> mp;\\n        vector<vector<ll>> left(n,vector<ll>(100,0));\\n        mp[s[0]-\\'0\\']++;\\n        for(ll i=1;i<n;i++){\\n             for(int k=0;k<100;k++)\\n                 left[i][k] = left[i-1][k];\\n            for(int j=0;j<10;j++){\\n                int tmp = j*10 + (s[i]-\\'0\\');\\n                left[i][tmp] +=  mp[j];\\n            }\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        \\n        mp.clear();\\n        \\n        ll ans=0;\\n        vector<ll> right(100,0);\\n        \\n        for(int i=n-1;i>=2;i--){\\n            for(int k=0;k<100;k++){\\n                ll tmp = (k%10)*10 + k/10;\\n                ans += left[i-1][k] * right[tmp];\\n                ans%=mod;\\n            }\\n            \\n            for(int j=0;j<10;j++){\\n                ll tmp = (s[i]-\\'0\\')*10 + j;\\n                right[tmp]+=mp[j];\\n            }\\n            mp[s[i]-\\'0\\']++;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850975,
                "title": "o-n-100-clean-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n*100)\\n\\n- Space complexity: O(n*100)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int mod = (int)1e9 + 7;\\n        long ans = 0;\\n        int n = s.length();\\n        if(n<5) return 0;\\n        long dp[][][] = new long[n][10][10];\\n        int count[] = new int[10];\\n        count[s.charAt(0)-\\'0\\']++;\\n        for(int i = 2 ; i<=n-3 ; i++){\\n            int val = s.charAt(i-1) - \\'0\\';\\n            for(int j = 0 ; j<10 ; j++){\\n                for(int k = 0 ; k<10 ; k++){\\n                    if(val==k)\\n                        dp[i][j][k] = dp[i-1][j][k] + count[j];\\n                    else\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                }\\n            }\\n            count[val]++;\\n        }\\n        long dp1[][][] = new long[n][10][10];\\n        count = new int[10];\\n        count[s.charAt(n-1)-\\'0\\']++;\\n        for(int i = n-3 ; i>=2 ; i--){\\n            int val = s.charAt(i+1) - \\'0\\';\\n            for(int j = 0 ; j<10 ; j++){\\n                for(int k = 0 ; k<10 ; k++){\\n                    if(val==k)\\n                        dp1[i][j][k] = dp1[i+1][j][k] + count[j];\\n                    else\\n                        dp1[i][j][k] = dp1[i+1][j][k];\\n                }\\n            }\\n            count[val]++;\\n        }\\n        \\n        for(int i = 2; i<=n-3 ; i++){\\n            for(int j = 0 ; j<10 ; j++){\\n                for(int k = 0 ; k<10 ; k++){\\n                    ans = (ans +  (dp[i][j][k] * dp1[i][j][k]) )%mod;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int mod = (int)1e9 + 7;\\n        long ans = 0;\\n        int n = s.length();\\n        if(n<5) return 0;\\n        long dp[][][] = new long[n][10][10];\\n        int count[] = new int[10];\\n        count[s.charAt(0)-\\'0\\']++;\\n        for(int i = 2 ; i<=n-3 ; i++){\\n            int val = s.charAt(i-1) - \\'0\\';\\n            for(int j = 0 ; j<10 ; j++){\\n                for(int k = 0 ; k<10 ; k++){\\n                    if(val==k)\\n                        dp[i][j][k] = dp[i-1][j][k] + count[j];\\n                    else\\n                        dp[i][j][k] = dp[i-1][j][k];\\n                }\\n            }\\n            count[val]++;\\n        }\\n        long dp1[][][] = new long[n][10][10];\\n        count = new int[10];\\n        count[s.charAt(n-1)-\\'0\\']++;\\n        for(int i = n-3 ; i>=2 ; i--){\\n            int val = s.charAt(i+1) - \\'0\\';\\n            for(int j = 0 ; j<10 ; j++){\\n                for(int k = 0 ; k<10 ; k++){\\n                    if(val==k)\\n                        dp1[i][j][k] = dp1[i+1][j][k] + count[j];\\n                    else\\n                        dp1[i][j][k] = dp1[i+1][j][k];\\n                }\\n            }\\n            count[val]++;\\n        }\\n        \\n        for(int i = 2; i<=n-3 ; i++){\\n            for(int j = 0 ; j<10 ; j++){\\n                for(int k = 0 ; k<10 ; k++){\\n                    ans = (ans +  (dp[i][j][k] * dp1[i][j][k]) )%mod;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850958,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1e9 + 7;\\n  static constexpr int n_palindrome = 5;\\n\\n public:\\n  int countPalindromes(const string &s) {\\n    constexpr int digits = 10;\\n    constexpr char zero = \\'0\\';\\n    bool digits_in_s[digits]{};\\n    for (const char c : s) {\\n      digits_in_s[c - zero] = true;\\n    }\\n    vector<char> all_digits;\\n    for (int d = 0; d < digits; ++d) {\\n      if (digits_in_s[d]) {\\n        all_digits.emplace_back(zero + d);\\n      }\\n    }\\n    const int n_digits = static_cast<int>(all_digits.size());\\n    \\n    int ret = 0;\\n    char palindrome[n_palindrome];\\n    for (int i = 0; i < n_digits; ++i) {\\n      palindrome[0] = all_digits[i];\\n      palindrome[4] = all_digits[i];\\n      for (int j = 0; j < n_digits; ++j) {\\n        palindrome[1] = all_digits[j];\\n        palindrome[3] = all_digits[j];\\n        for (int k = 0; k < n_digits; ++k) {\\n          palindrome[2] = all_digits[k];\\n          ret = (ret + count_subsequence(s, palindrome)) % mod;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int count_subsequence(const string &s, const char *palindrome) {\\n    const int n_s = static_cast<int>(s.size());\\n    int dp[2][n_s + 1];\\n    int previous = 0;\\n    int current = 1;\\n    fill(dp[previous], dp[previous] + n_s + 1, 1);\\n    for (int length_palindrome = 1; length_palindrome < n_palindrome + 1; ++length_palindrome) {\\n      memset(dp[current], 0, sizeof(dp[current]));\\n      for (int length_s = length_palindrome; length_s < n_s + 1; ++length_s) {\\n        if (length_s == 0) {\\n          dp[current][length_s] = 0;\\n          continue;\\n        }\\n        \\n        dp[current][length_s] = (dp[current][length_s - 1] + (s[length_s - 1] == palindrome[length_palindrome - 1] ? dp[previous][length_s - 1] : 0)) % mod;\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n    }\\n    return dp[previous][n_s];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1e9 + 7;\\n  static constexpr int n_palindrome = 5;\\n\\n public:\\n  int countPalindromes(const string &s) {\\n    constexpr int digits = 10;\\n    constexpr char zero = \\'0\\';\\n    bool digits_in_s[digits]{};\\n    for (const char c : s) {\\n      digits_in_s[c - zero] = true;\\n    }\\n    vector<char> all_digits;\\n    for (int d = 0; d < digits; ++d) {\\n      if (digits_in_s[d]) {\\n        all_digits.emplace_back(zero + d);\\n      }\\n    }\\n    const int n_digits = static_cast<int>(all_digits.size());\\n    \\n    int ret = 0;\\n    char palindrome[n_palindrome];\\n    for (int i = 0; i < n_digits; ++i) {\\n      palindrome[0] = all_digits[i];\\n      palindrome[4] = all_digits[i];\\n      for (int j = 0; j < n_digits; ++j) {\\n        palindrome[1] = all_digits[j];\\n        palindrome[3] = all_digits[j];\\n        for (int k = 0; k < n_digits; ++k) {\\n          palindrome[2] = all_digits[k];\\n          ret = (ret + count_subsequence(s, palindrome)) % mod;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int count_subsequence(const string &s, const char *palindrome) {\\n    const int n_s = static_cast<int>(s.size());\\n    int dp[2][n_s + 1];\\n    int previous = 0;\\n    int current = 1;\\n    fill(dp[previous], dp[previous] + n_s + 1, 1);\\n    for (int length_palindrome = 1; length_palindrome < n_palindrome + 1; ++length_palindrome) {\\n      memset(dp[current], 0, sizeof(dp[current]));\\n      for (int length_s = length_palindrome; length_s < n_s + 1; ++length_s) {\\n        if (length_s == 0) {\\n          dp[current][length_s] = 0;\\n          continue;\\n        }\\n        \\n        dp[current][length_s] = (dp[current][length_s - 1] + (s[length_s - 1] == palindrome[length_palindrome - 1] ? dp[previous][length_s - 1] : 0)) % mod;\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n    }\\n    return dp[previous][n_s];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850957,
                "title": "java-dp-count-the-occurrences-of-01-99-o-n",
                "content": "Since the palindromic subsequences is only length of 5, we can think of, for each `c` in `s` as the center of the palindrome, if 10 occurs 5 times before `c` and 01 appears 7 times after c, then we got the palindrome `10c01` for 35 times.\\n\\nTo achieve this, we\\'ll have 4 dp arrays (2 for each direction). \\n\\nTake the pre (<-) direction for example: \\n`sawPre[i]` is an array of length 10 to count the occurrence of each digit prior to `i`th character.\\n`dpPre[i]` is an array of length 100 to count the occurrence of 01~99 prior to `i`th character.\\n\\nFor `s = \"103301\"`\\n`sawPre[4][3] = 2` because we\\'ve seen digit `3` twice before `s(4)`.\\n`dpPre[4][03] = dpPre[3][03] + sawPre[4][3]` because `s(4) = 0` and we can form `\\'03\\'` twice because we\\'ve seen digit `3` twice before `s(4)`.\\n\\nOnce we finish computing those 4 dp arrays, we walk through all the ones that could be the center of the palindrome and add `dpPre[i - 1][j] * dpPost[i + 1][j]` to the result.\\n\\n```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int mod = (int) 1e9 + 7;\\n        int n = s.length();  // n <= 10000;\\n        char[] cs = s.toCharArray();\\n        long res = 0l;\\n        int[][] sawPre = new int[n][10];\\n        int[][] sawPost = new int[n][10];\\n        long[][] dpPre = new long[n][100];\\n        long[][] dpPost = new long[n][100];\\n        for (int i = 1; i < n - 1; i++) {\\n            int k = n - i - 1;\\n            for (int j = 0; j < 10; j++) {\\n                sawPre[i][j] = sawPre[i - 1][j];\\n                sawPost[k][j] = sawPost[k + 1][j];\\n            }\\n            sawPre[i][cs[i - 1] - \\'0\\']++;\\n            sawPost[k][cs[k + 1] - \\'0\\']++;\\n            for (int j = 0; j < 100; j++) {\\n                dpPre[i][j] = dpPre[i - 1][j];\\n                dpPost[k][j] = dpPost[k + 1][j];\\n            }\\n            for (int j = 0; j < 10; j++) {\\n                int tenth = (cs[i] - \\'0\\') * 10;\\n                int tenthK = (cs[k] - \\'0\\') * 10;\\n                dpPre[i][tenth + j] += sawPre[i][j];\\n                dpPost[k][tenthK + j] += sawPost[k][j];\\n            }\\n            \\n        }\\n        for (int i = 2; i < n - 2; i++) {\\n            for (int j = 0; j < 100; j++) {\\n                res += dpPre[i - 1][j] * dpPost[i + 1][j];\\n                res %= mod;\\n            }\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int mod = (int) 1e9 + 7;\\n        int n = s.length();  // n <= 10000;\\n        char[] cs = s.toCharArray();\\n        long res = 0l;\\n        int[][] sawPre = new int[n][10];\\n        int[][] sawPost = new int[n][10];\\n        long[][] dpPre = new long[n][100];\\n        long[][] dpPost = new long[n][100];\\n        for (int i = 1; i < n - 1; i++) {\\n            int k = n - i - 1;\\n            for (int j = 0; j < 10; j++) {\\n                sawPre[i][j] = sawPre[i - 1][j];\\n                sawPost[k][j] = sawPost[k + 1][j];\\n            }\\n            sawPre[i][cs[i - 1] - \\'0\\']++;\\n            sawPost[k][cs[k + 1] - \\'0\\']++;\\n            for (int j = 0; j < 100; j++) {\\n                dpPre[i][j] = dpPre[i - 1][j];\\n                dpPost[k][j] = dpPost[k + 1][j];\\n            }\\n            for (int j = 0; j < 10; j++) {\\n                int tenth = (cs[i] - \\'0\\') * 10;\\n                int tenthK = (cs[k] - \\'0\\') * 10;\\n                dpPre[i][tenth + j] += sawPre[i][j];\\n                dpPost[k][tenthK + j] += sawPost[k][j];\\n            }\\n            \\n        }\\n        for (int i = 2; i < n - 2; i++) {\\n            for (int j = 0; j < 100; j++) {\\n                res += dpPre[i - 1][j] * dpPost[i + 1][j];\\n                res %= mod;\\n            }\\n        }\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850939,
                "title": "c-bottom-up-dp-runtime-o-500n-memory-o-6n",
                "content": "# Intuition\\nWe essentially want to compute how many times a certain length-5 palindrome occurs in the string. We then just add together all of these values. In other words, for all possible length-5 palindromes, how many times does each appear in the string. We then take the sum of these results, which would give our result.\\n\\nNote that this approach provides better memory (O(6n) instead of O(100n)) at the cost of runtime (O(500n) instead of O(100n)).\\n\\n# Approach\\nA majority of the implementation is just looping through all the possible length-5 numerical palindromes. Usually, this would require O(1000) time since we have 3 digits to determine, the 1st, 2nd, and 3rd digits. The 4th and 5th digits are already determined by the 1st and 2nd. \\n\\nFrom here, we would count how many times this subsequence occurs in the string s. Note that for each palindrome counting the number of times it occurs as a subsequence takes a total of O(5 * n) time. The approach for this is similar to LCS (longest common subsequence). We break it into two cases as we iterate up through both strings. Let\\'s set dp[i][j] to store the number of times the string of length-j from the palindrome occurs as a subsequence in s up to length i in s. \\n\\nFirstly, we always want to add in the number of matches up this character in the palindrome and up to the previous character in s (dp[l-1][g]). If the current characters match then we want to also add in the number of subsequence matches up to the previous character in s and previous character (dp[l-1][g-1]). Through this strategy we can successfully count the number of times a specific 5-length palindrome occurs as a subsequence in string s in O(5*n) time.\\n\\nThis gives our total runtime using this strategy as O(1000 * 5 * n) = O(5000n). THIS ACTUALLY TLE\\'s. So we need to get a bit better.\\n\\nRemember when we looped through 1000 combinations to determine all the palindromes? We can actually reduce our runtime when looping through these because the middle element can be any element in between the 2nd and 4th digits. To do this, we first loop through all the possible first and second digits (covered by the loops being iterated by i and j). Then instead of looping through the options for the third digit as well, we forget about it for now.\\n\\nInstead, when we come back for the counting portion. When we come to checking the third digit in the palindrome, we just assume it is ALWAYS a match, because that is basically what it is. No matter what, our third digit can match whatever character we want in string s. So we just pretend that this character is always a match. Now we have reduced by one loop so our runtime goes from O(5000n) to O(500n) and it passes.\\n\\nNote that the only space we need is our dp array/vector which is of n+1,6 which is approximately O(6n). We just re-use this vector over different iterations.\\n\\nAlso note that this solution is very edgy on the line of TLE\\'ing so you have to be very careful about any additional data structure/variable creations that can even slightly increase runtime. \\n\\n# Complexity\\n- Time complexity:\\nO(5 * 100 * n) = O(500n)\\n\\n- Space complexity:\\nO(6n)\\n\\n# Code\\n```\\ntypedef long long ll;\\nll M = 1000000007;\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        ll ans = 0;\\n        vector<vector<ll>> dp(s.size()+1, vector<ll>(6));\\n        for (int l = 0; l < s.size(); l++) {dp[l][0] = 1;}\\n        for (int i = 0; i <= 9; i++) {\\n            for (int j = 0; j <= 9; j++) {\\n                for (int l = 1; l <= s.size(); l++) {\\n                    for (int g = 1; g <= 5; g++) {\\n                        int c = -1; if (g == 1 || g== 5) c=i; else if (g%2 == 0) c=j; \\n                        dp[l][g] = dp[l-1][g];\\n                        if (s[l-1]-\\'0\\' == c || c == -1) {\\n                            dp[l][g] = (dp[l][g] + dp[l-1][g-1])%M;\\n                        }\\n                    }\\n                }\\n                ans = (ans + (dp.back().back()))%M;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nll M = 1000000007;\\nclass Solution {\\npublic:\\n    int countPalindromes(string s) {\\n        ll ans = 0;\\n        vector<vector<ll>> dp(s.size()+1, vector<ll>(6));\\n        for (int l = 0; l < s.size(); l++) {dp[l][0] = 1;}\\n        for (int i = 0; i <= 9; i++) {\\n            for (int j = 0; j <= 9; j++) {\\n                for (int l = 1; l <= s.size(); l++) {\\n                    for (int g = 1; g <= 5; g++) {\\n                        int c = -1; if (g == 1 || g== 5) c=i; else if (g%2 == 0) c=j; \\n                        dp[l][g] = dp[l-1][g];\\n                        if (s[l-1]-\\'0\\' == c || c == -1) {\\n                            dp[l][g] = (dp[l][g] + dp[l-1][g-1])%M;\\n                        }\\n                    }\\n                }\\n                ans = (ans + (dp.back().back()))%M;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850921,
                "title": "javascript-dp-1699ms",
                "content": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst mod = 1e9 + 7;\\nconst countPalindromes = (s) => {\\n    let res = 0, n = s.length, cnt = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        let tot = 0;\\n        for (let j = n - 1; j > i; j--) {\\n            if (s[i] == s[j]) {\\n                res += tot * (j - i - 1);\\n                res %= mod;\\n            }\\n            tot += cnt[s[j] - \\'0\\'];\\n        }\\n        cnt[s[i] - \\'0\\']++;\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst mod = 1e9 + 7;\\nconst countPalindromes = (s) => {\\n    let res = 0, n = s.length, cnt = Array(10).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        let tot = 0;\\n        for (let j = n - 1; j > i; j--) {\\n            if (s[i] == s[j]) {\\n                res += tot * (j - i - 1);\\n                res %= mod;\\n            }\\n            tot += cnt[s[j] - \\'0\\'];\\n        }\\n        cnt[s[i] - \\'0\\']++;\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850916,
                "title": "easy-4d-dp-python-100",
                "content": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 10**9 + 7\\n        res = 0\\n        dp = [[[[0]*11 for i in range(11)] for i in range(11)] for i in range(11)]\\n        for x in s:\\n            i = ord(x) - ord(\\'0\\')\\n            for j in range(10):\\n                for k in range(10):\\n                    res =(res+dp[i][j][k][j])%MOD\\n                    dp[j][i][k][i] += dp[j][i][k][10]\\n                    dp[j][k][i][10] += dp[j][k][10][10]\\n                dp[j][i][10][10] += dp[j][10][10][10];\\n            dp[i][10][10][10] +=1\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 10**9 + 7\\n        res = 0\\n        dp = [[[[0]*11 for i in range(11)] for i in range(11)] for i in range(11)]\\n        for x in s:\\n            i = ord(x) - ord(\\'0\\')\\n            for j in range(10):\\n                for k in range(10):\\n                    res =(res+dp[i][j][k][j])%MOD\\n                    dp[j][i][k][i] += dp[j][i][k][10]\\n                    dp[j][k][i][10] += dp[j][k][10][10]\\n                dp[j][i][10][10] += dp[j][10][10][10];\\n            dp[i][10][10][10] +=1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850899,
                "title": "two-dps",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$dp1(i, prefix)$$, where $$len(prefix) \\\\leq 2$$, calculates the number of palindromes, beginning from $$prefix$$, and continuation of the word starts from $$i^{th}$$ position.\\n\\n$$dp2(i, postfix)$$ calculates a number of postfixes starting from $$i^{th}$$ position.\\n\\n$$dp1(i, prefix)=dp1(i + 1, prefix)+\\\\begin{cases}dp1(i + 1, prefix + s_{i}),&\\\\text{if $len(prefix) < 2$}\\\\\\\\\\ndp2(i+1,prefix), &\\\\text{if\\\\ $len(prefix) = 2$}\\n\\\\end{cases}$$\\n\\n$$dp2(i,postfix)=\\\\begin{cases}dp2(i + 1, posftix),&\\\\text{if $postfix_p \\\\ne s_i$}\\\\\\\\\\ndp2(i + 1, postfix)+dp2(i + 1, posftix_{1..p-1}),&\\\\text{if $postfix_p = s_i$}\\\\\\\\\\n1, &\\\\text{if\\\\ $postfix=\"\"$}\\n\\\\end{cases}$$\\n\\n\\n# Complexity\\n- Time complexity: $$O(N K^2)$$, where $$N$$ is a length of string $$s$$, and $$K$$ is number of different chars in string (equals to 10).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N K^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        n = len(s)\\n\\n        @cache\\n        def dp2(index, postfix):\\n            if postfix == \\'\\':\\n                return 1\\n            if index >= n:\\n                return 0\\n            \\n            result = dp2(index + 1, postfix)\\n            if postfix[-1] == s[index]:\\n                result += dp2(index + 1, postfix[:-1])\\n            \\n            return result % MOD\\n\\n        @cache\\n        def dp1(index, prefix):\\n            if index >= n:\\n                return 0\\n            \\n            result = dp1(index + 1, prefix)\\n            if len(prefix) < 2:\\n                result += dp1(index + 1, prefix + s[index])\\n            else:\\n                result += dp2(index + 1, prefix)\\n            return result % MOD\\n\\n        return dp1(0, \"\")\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        n = len(s)\\n\\n        @cache\\n        def dp2(index, postfix):\\n            if postfix == \\'\\':\\n                return 1\\n            if index >= n:\\n                return 0\\n            \\n            result = dp2(index + 1, postfix)\\n            if postfix[-1] == s[index]:\\n                result += dp2(index + 1, postfix[:-1])\\n            \\n            return result % MOD\\n\\n        @cache\\n        def dp1(index, prefix):\\n            if index >= n:\\n                return 0\\n            \\n            result = dp1(index + 1, prefix)\\n            if len(prefix) < 2:\\n                result += dp1(index + 1, prefix + s[index])\\n            else:\\n                result += dp2(index + 1, prefix)\\n            return result % MOD\\n\\n        return dp1(0, \"\")\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850821,
                "title": "clean-3d-dp-cpp-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dpl[10005][11][10]; // dpl[i][j][k] stores count of subseq \"jk\" before i\\n    int dpr[10005][11][10]; // dpr[i][j][k] stores count of subseq \"jk\" after i\\n    \\n    // dpl[i][10][j] stores count of subseq \\'j\\' before i\\n    // dpr[i][10][j] stores count of subseq \\'j\\' after i\\n    \\n    int countPalindromes(string s) {\\n        int n = size(s);\\n        for(int i = 0; i < n; ++i){\\n            if(i){\\n                memcpy(dpl[i], dpl[i - 1], sizeof(dpl[i]));\\n                for(int j = 0; j < 10; ++j){\\n                    dpl[i][j][s[i] - \\'0\\'] += dpl[i - 1][10][j];\\n                }\\n            }\\n            dpl[i][10][s[i] - \\'0\\']++;\\n        }\\n        for(int i = n - 1; i >= 0; --i){\\n            if(i + 1 < n){\\n                memcpy(dpr[i], dpr[i + 1], sizeof(dpr[i]));\\n                for(int j = 0; j < 10; ++j){\\n                    dpr[i][s[i] - \\'0\\'][j] += dpr[i + 1][10][j];\\n                }\\n            }\\n            dpr[i][10][s[i] - \\'0\\']++;\\n        }\\n        long long answer = 0;\\n        for(int i = 2; i < n - 2; ++i){\\n            for(int j = 0; j < 10; ++j){\\n                for(int k = 0; k < 10; ++k){\\n                    answer += (dpl[i - 1][j][k] * 1LL * dpr[i + 1][k][j]) % mod;\\n                    answer %= mod;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int dpl[10005][11][10]; // dpl[i][j][k] stores count of subseq \"jk\" before i\\n    int dpr[10005][11][10]; // dpr[i][j][k] stores count of subseq \"jk\" after i\\n    \\n    // dpl[i][10][j] stores count of subseq \\'j\\' before i\\n    // dpr[i][10][j] stores count of subseq \\'j\\' after i\\n    \\n    int countPalindromes(string s) {\\n        int n = size(s);\\n        for(int i = 0; i < n; ++i){\\n            if(i){\\n                memcpy(dpl[i], dpl[i - 1], sizeof(dpl[i]));\\n                for(int j = 0; j < 10; ++j){\\n                    dpl[i][j][s[i] - \\'0\\'] += dpl[i - 1][10][j];\\n                }\\n            }\\n            dpl[i][10][s[i] - \\'0\\']++;\\n        }\\n        for(int i = n - 1; i >= 0; --i){\\n            if(i + 1 < n){\\n                memcpy(dpr[i], dpr[i + 1], sizeof(dpr[i]));\\n                for(int j = 0; j < 10; ++j){\\n                    dpr[i][s[i] - \\'0\\'][j] += dpr[i + 1][10][j];\\n                }\\n            }\\n            dpr[i][10][s[i] - \\'0\\']++;\\n        }\\n        long long answer = 0;\\n        for(int i = 2; i < n - 2; ++i){\\n            for(int j = 0; j < 10; ++j){\\n                for(int k = 0; k < 10; ++k){\\n                    answer += (dpl[i - 1][j][k] * 1LL * dpr[i + 1][k][j]) % mod;\\n                    answer %= mod;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850799,
                "title": "pre-post-combo",
                "content": "# Approach\\n\\nSince it is odd length palindrome we only need to check that left and right subsequence match. \\n\\nOn each iteration we have all the left and right combinations stored and just need to check if they exist in both.\\n\\nAt the beginning of each iteration we remove our current number from the right combinations\\nAt the end of each iteration we add our current number into the left combinations\\n\\nWe are also keeping track of the count of each number for easily getting how many times we can make a certain combination \\n\\n\\n# After thoughts:\\n\\nit may be faster to check which combo has the longer length instead of using the midpoint \\n\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        if len(s) < 5:\\n            return 0\\n        \\n        \\n        res = 0\\n\\n        #intializing our variables\\n\\n        comboLeft = {s[0]+s[1]:1}\\n        leftNums = {s[0]:1}\\n        comboRight = {}\\n        rightNums = {}\\n\\n        if s[1] == s[0]:\\n            leftNums[s[0]] += 1\\n        else:\\n            leftNums[s[1]] = 1\\n\\n        // populating our initial right combos\\n        // in comboRight we store the combination backwards for easy checking => xyCyx \\'yx\\' will be stored as \\'xy\\'\\n        for k in range(2, len(s)):\\n            \\n            for num in rightNums:\\n                combo = s[k] + num\\n                if combo not in comboRight:\\n                    comboRight[combo] = 0\\n                comboRight[combo] += rightNums[num]\\n\\n            if s[k] not in rightNums:\\n                rightNums[s[k]] = 0\\n            rightNums[s[k]]+=1\\n                \\n        mid = len(s)//2\\n    \\n        for i in range(2,len(s)-2):\\n            j = s[i]\\n            \\n            // removing the current number s[i] from our right combinations \\n            for num in rightNums:\\n                if num == j:\\n                    rightNums[num] -= 1\\n                combo = num+j\\n                if combo in comboRight:\\n                    comboRight[combo] -= rightNums[num]\\n            \\n            // checking if any of the combinations are in both left and right \\n            if i < mid:\\n                for num in comboLeft:\\n                    if num in comboRight:\\n                        res += max(0,comboLeft[num]*comboRight[num])\\n            else:\\n                for num in comboRight:\\n                    if num in comboLeft:\\n                        res+= max(0,comboLeft[num]*comboRight[num])\\n            \\n            // updating our current number into the left combinations\\n            for num in leftNums:\\n                combo = num+s[i]\\n                if combo not in comboLeft:\\n                    comboLeft[combo] = 0\\n                comboLeft[combo] += leftNums[num]\\n            if s[i] not in leftNums:\\n                leftNums[s[i]] = 0\\n            leftNums[s[i]] += 1\\n            \\n        return res%1000000007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        if len(s) < 5:\\n            return 0\\n        \\n        \\n        res = 0\\n\\n        #intializing our variables\\n\\n        comboLeft = {s[0]+s[1]:1}\\n        leftNums = {s[0]:1}\\n        comboRight = {}\\n        rightNums = {}\\n\\n        if s[1] == s[0]:\\n            leftNums[s[0]] += 1\\n        else:\\n            leftNums[s[1]] = 1\\n\\n        // populating our initial right combos\\n        // in comboRight we store the combination backwards for easy checking => xyCyx \\'yx\\' will be stored as \\'xy\\'\\n        for k in range(2, len(s)):\\n            \\n            for num in rightNums:\\n                combo = s[k] + num\\n                if combo not in comboRight:\\n                    comboRight[combo] = 0\\n                comboRight[combo] += rightNums[num]\\n\\n            if s[k] not in rightNums:\\n                rightNums[s[k]] = 0\\n            rightNums[s[k]]+=1\\n                \\n        mid = len(s)//2\\n    \\n        for i in range(2,len(s)-2):\\n            j = s[i]\\n            \\n            // removing the current number s[i] from our right combinations \\n            for num in rightNums:\\n                if num == j:\\n                    rightNums[num] -= 1\\n                combo = num+j\\n                if combo in comboRight:\\n                    comboRight[combo] -= rightNums[num]\\n            \\n            // checking if any of the combinations are in both left and right \\n            if i < mid:\\n                for num in comboLeft:\\n                    if num in comboRight:\\n                        res += max(0,comboLeft[num]*comboRight[num])\\n            else:\\n                for num in comboRight:\\n                    if num in comboLeft:\\n                        res+= max(0,comboLeft[num]*comboRight[num])\\n            \\n            // updating our current number into the left combinations\\n            for num in leftNums:\\n                combo = num+s[i]\\n                if combo not in comboLeft:\\n                    comboLeft[combo] = 0\\n                comboLeft[combo] += leftNums[num]\\n            if s[i] not in leftNums:\\n                leftNums[s[i]] = 0\\n            leftNums[s[i]] += 1\\n            \\n        return res%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850792,
                "title": "java-easy-dp-o-n-100",
                "content": "```\\nclass Solution {\\n    static long mod = (long)1000000007;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        \\n        long left[][] = new long[n][10];\\n        long dpLeft[][][] = new long[n][10][10];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = s.charAt(i) - \\'0\\';\\n            \\n            for (int j = 0; j < 10; ++j) {\\n                left[i][j] = ((i - 1 >= 0) ? left[i - 1][j] : 0) + ((j == num) ? 1 : 0);\\n                \\n                left[i][j] = left[i][j] % mod;\\n            }\\n            \\n            \\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    if (k == num) {\\n                        long soFar = ((i - 1 >= 0) ? left[i - 1][j] : 0);\\n                        dpLeft[i][j][k] = ((i - 1 >= 0) ? dpLeft[i - 1][j][k] : 0) + soFar;\\n                    }\\n                    else {\\n                        dpLeft[i][j][k] = ((i - 1 >= 0) ? dpLeft[i - 1][j][k] : 0);\\n                    }\\n                    \\n                    dpLeft[i][j][k] = dpLeft[i][j][k] % mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        long right[][] = new long[n][10];\\n        long dpRight[][][] = new long[n][10][10];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = s.charAt(n - 1 - i) - \\'0\\';\\n            \\n            for (int j = 0; j < 10; ++j) {\\n                right[i][j] = ((i - 1 >= 0) ? right[i - 1][j] : 0) + ((j == num) ? 1 : 0);\\n                \\n                right[i][j] = right[i][j] % mod;\\n            }\\n            \\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    if (k == num) {\\n                        long soFar = ((i - 1 >= 0) ? right[i - 1][j] : 0);\\n                        dpRight[i][j][k] = ((i - 1 >= 0) ? dpRight[i - 1][j][k] : 0) + soFar;\\n                    }\\n                    else {\\n                        dpRight[i][j][k] = ((i - 1 >= 0) ? dpRight[i - 1][j][k] : 0);\\n                    }\\n                    \\n                    dpRight[i][j][k] = dpRight[i][j][k] % mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        long ans = 0;\\n        \\n        for (int i = 2; i < n - 2; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    long mul = (dpLeft[i - 1][j][k] * dpRight[n - i - 2][j][k]) % mod;\\n                    ans = (ans + mul) % mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static long mod = (long)1000000007;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        \\n        long left[][] = new long[n][10];\\n        long dpLeft[][][] = new long[n][10][10];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = s.charAt(i) - \\'0\\';\\n            \\n            for (int j = 0; j < 10; ++j) {\\n                left[i][j] = ((i - 1 >= 0) ? left[i - 1][j] : 0) + ((j == num) ? 1 : 0);\\n                \\n                left[i][j] = left[i][j] % mod;\\n            }\\n            \\n            \\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    if (k == num) {\\n                        long soFar = ((i - 1 >= 0) ? left[i - 1][j] : 0);\\n                        dpLeft[i][j][k] = ((i - 1 >= 0) ? dpLeft[i - 1][j][k] : 0) + soFar;\\n                    }\\n                    else {\\n                        dpLeft[i][j][k] = ((i - 1 >= 0) ? dpLeft[i - 1][j][k] : 0);\\n                    }\\n                    \\n                    dpLeft[i][j][k] = dpLeft[i][j][k] % mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        long right[][] = new long[n][10];\\n        long dpRight[][][] = new long[n][10][10];\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = s.charAt(n - 1 - i) - \\'0\\';\\n            \\n            for (int j = 0; j < 10; ++j) {\\n                right[i][j] = ((i - 1 >= 0) ? right[i - 1][j] : 0) + ((j == num) ? 1 : 0);\\n                \\n                right[i][j] = right[i][j] % mod;\\n            }\\n            \\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    if (k == num) {\\n                        long soFar = ((i - 1 >= 0) ? right[i - 1][j] : 0);\\n                        dpRight[i][j][k] = ((i - 1 >= 0) ? dpRight[i - 1][j][k] : 0) + soFar;\\n                    }\\n                    else {\\n                        dpRight[i][j][k] = ((i - 1 >= 0) ? dpRight[i - 1][j][k] : 0);\\n                    }\\n                    \\n                    dpRight[i][j][k] = dpRight[i][j][k] % mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        long ans = 0;\\n        \\n        for (int i = 2; i < n - 2; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                for (int k = 0; k < 10; ++k) {\\n                    long mul = (dpLeft[i - 1][j][k] * dpRight[n - i - 2][j][k]) % mod;\\n                    ans = (ans + mul) % mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850789,
                "title": "c-dp",
                "content": "```\\nint countPalindromes(string s) {\\n        int N = s.size();\\n        long long ret = 0;\\n        int mod = 1000000007;\\n        vector<vector<long long>> left(N+1, vector<long long>(10, 0)), right(N+1, vector<long long>(10, 0));\\n        vector<vector<long long>> left2(N+1, vector<long long>(100, 0)), right2(N+1, vector<long long>(100, 0));\\n        for(int i=0; i<N; i++){\\n            left[i+1] = left[i];\\n            left2[i+1] = left2[i];\\n            left[i+1][s[i]-\\'0\\']++; \\n            for(int j=0; j<10; j++){\\n                int num = (s[i]-\\'0\\')*10;\\n                left2[i+1][num+j] += left[i][j];\\n            }\\n        }\\n        for(int i=N-1; i>=0; i--){\\n            right[i] = right[i+1];\\n            right2[i] = right2[i+1];\\n            right[i][s[i]-\\'0\\']++;\\n            for(int j=0; j<10; j++){\\n                int num = (s[i]-\\'0\\')*10;\\n                right2[i][num+j] += right[i+1][j];\\n            }\\n        }\\n        for(int i=1; i<N; i++){\\n            for(int j=0; j<100; j++){\\n                ret = (ret + left2[i][j]*right2[i+1][j]%mod)%mod;\\n            }\\n        }        \\n        return ret%mod;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countPalindromes(string s) {\\n        int N = s.size();\\n        long long ret = 0;\\n        int mod = 1000000007;\\n        vector<vector<long long>> left(N+1, vector<long long>(10, 0)), right(N+1, vector<long long>(10, 0));\\n        vector<vector<long long>> left2(N+1, vector<long long>(100, 0)), right2(N+1, vector<long long>(100, 0));\\n        for(int i=0; i<N; i++){\\n            left[i+1] = left[i];\\n            left2[i+1] = left2[i];\\n            left[i+1][s[i]-\\'0\\']++; \\n            for(int j=0; j<10; j++){\\n                int num = (s[i]-\\'0\\')*10;\\n                left2[i+1][num+j] += left[i][j];\\n            }\\n        }\\n        for(int i=N-1; i>=0; i--){\\n            right[i] = right[i+1];\\n            right2[i] = right2[i+1];\\n            right[i][s[i]-\\'0\\']++;\\n            for(int j=0; j<10; j++){\\n                int num = (s[i]-\\'0\\')*10;\\n                right2[i][num+j] += right[i+1][j];\\n            }\\n        }\\n        for(int i=1; i<N; i++){\\n            for(int j=0; j<100; j++){\\n                ret = (ret + left2[i][j]*right2[i+1][j]%mod)%mod;\\n            }\\n        }        \\n        return ret%mod;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850763,
                "title": "clean-python3-prefixes-dp-explained-o-n-time-o-1-space",
                "content": "First, we generate all palindromes of length 5. Notice that the for some palindromic string pal of length 5, `pal[0] == pal[4]` and `pal[1] == pal[3]`, and we do not care about `pal[2]`. Thus, there are only 100 palindromes of length 5 (consisting of only digits). We can simply put `*` for `pal[2]` for all cases to save some time and space. Once we have the palindrome itself generated, we also compute each prefix of it, an initialize the count of each prefix to 0 in `subs`it so we can store intermediate results. There are no more than a constant (5\\\\*100) substrings in `subs`.\\n\\nNext, we can use DP to build the solution from subsolutions. For each position `i` in `s`, `subs` will contain the counts of all valid subsequences we\\'ve seen so far for each substring. We will then go through each substring, and if it\\'s count `ct` is greater than 0 (done with the filter function), we should try to build the next string by appending `s[i]`, or simply `*` if it is the middle position. If the new string `nxt` we build is another substring, we update its count in `subs`. And if it is a palindrome of length 5 (we have all of them in `pals`), then we can instead update the result with this count.\\n\\nThe sizes of `subs`, `pals`, and the lengths of each string in `subs` and `pals` are all constant. Thus, the only work we do that depends on the size of the input is in the main loop `for i in range(len(s)):`.\\nThus, Time Complexity is `O(N)` where `N` is the length of the string, and Space Complexity is `O(1)`.\\n\\nPlease upvote if it helps :)\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        subs, pals = {\"\": 1}, set()\\n        for x in range(100): \\n            a, b = str(x // 10), str(x % 10)\\n            pal = a + b + \\'*\\' + b + a\\n            for i in range(1, 5):\\n                subs[pal[:i]] = 0\\n            pals.add(pal)\\n        \\n        res, mod = 0, 10**9 + 7\\n        for i in range(len(s)):\\n            for sub, ct in list(filter(lambda k: k[1] > 0, subs.items())):\\n                nxt = sub + (\\'*\\' if len(sub) == 2 else s[i])\\n                if nxt in subs:\\n                    subs[nxt] += ct\\n                elif nxt in pals:\\n                    res += ct\\n                    res %= mod\\n            \\n        return res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        subs, pals = {\"\": 1}",
                "codeTag": "Java"
            },
            {
                "id": 2850756,
                "title": "20-line-o-n-solution-with-counter",
                "content": "# Intuition\\nThe python time limit seems to require the solution to keep track of as fewer states as possible, which are of the following lengths:\\n\\n1. \"0\", \"1\", \"2\", ..., \"9\"\\n2. \"00\", \"01\", \"02\", ..., \"99\"\\n3. \"00*\", \"01*\", \"02*\", ..., \"99*\". Notice that we don\\'t need to track the middle digit since it doesn\\'t affect whether a palindrome is formed or not.\\n4. \"00\\\\*0\", \"01\\\\*1\", \"02\\\\*2\", ..., \"99\\\\*9\" conceptually, but we only need the first 2 digits to uniquely identify them.\\n\\n# Approach\\nUse a list of Counter to track each one of them and systematically add counts of subsequences forming through each digit. Of note:\\n\\n1. By going through the lengths in reverse order, we don\\'t need to worry about mixing up old counts with the new counts.\\n2. We don\\'t need to track the middle digit, so we add the counts of `curr[1]` to `curr[-2]` directly.\\n2. We can further save time by iterating through `(d + c for c in string.digits)` and `(c + d for c in string.digits)` (10 each) instead of all length-2 keys for adding counts from length-4 states to the answer and adding counts from length-3 states to length-4 states, respectively.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, and in general $$O(10^{\\\\left \\\\lfloor{\\\\frac{l}{2}}\\\\right \\\\rfloor}\\\\cdot n)$$ where $$l$$ is the length of the palindrome.\\n\\n- Space complexity:\\n$$O(1)$$, and in general $$O(10^{\\\\left \\\\lfloor{\\\\frac{l}{2}}\\\\right \\\\rfloor})$$ where $$l$$ is the length of the palindrome.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        mod = 10 ** 9 + 7\\n        ans = 0\\n        curr = [Counter() for _ in range(4)]\\n        for d in s:\\n            for k in (d + c for c in string.digits):\\n                ans += curr[-1][k]\\n            ans %= mod\\n            for k in (c + d for c in string.digits):\\n                curr[-1][k] += curr[-2][k]\\n                curr[-1][k] %= mod\\n            for k, v in curr[1].items():\\n                curr[-2][k] += v\\n                curr[-2][k] %= mod\\n            for k, v in curr[0].items():\\n                curr[1][k + d] += v\\n                curr[1][k + d] %= mod\\n            curr[0][d] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPalindromes(self, s: str) -> int:\\n        mod = 10 ** 9 + 7\\n        ans = 0\\n        curr = [Counter() for _ in range(4)]\\n        for d in s:\\n            for k in (d + c for c in string.digits):\\n                ans += curr[-1][k]\\n            ans %= mod\\n            for k in (c + d for c in string.digits):\\n                curr[-1][k] += curr[-2][k]\\n                curr[-1][k] %= mod\\n            for k, v in curr[1].items():\\n                curr[-2][k] += v\\n                curr[-2][k] %= mod\\n            for k, v in curr[0].items():\\n                curr[1][k + d] += v\\n                curr[1][k + d] %= mod\\n            curr[0][d] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850753,
                "title": "rolling-o-100n-time-o-100-extra-space-java",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n\\n    public int countPalindromes(String s) {\\n        if (s.length() < 5) return 0;\\n        int[] digitCountL = new int[10], digitCountR = new int[10];\\n        int[][] digitCountL2 = new int[10][10], digitCountR2 = new int[10][10];\\n        int res = 0;\\n\\n        digitCountR[s.charAt(s.length() - 1) - \\'0\\']++;\\n        for (int i = s.length() - 2; i > 1; i--) {\\n            int v = s.charAt(i) - \\'0\\';\\n            for (int j = 0; j <= 9; j++)\\n                digitCountR2[v][j] += digitCountR[j];\\n            digitCountR[v]++;\\n        }\\n\\n        digitCountL[s.charAt(0) - \\'0\\']++;\\n        digitCountL[s.charAt(1) - \\'0\\']++;\\n        digitCountL2[s.charAt(0) - \\'0\\'][s.charAt(1) - \\'0\\']++;\\n        for (int i = 2; i < s.length() - 2; i++) {\\n            int v = s.charAt(i) - \\'0\\';\\n\\n            digitCountR[v]--;\\n            for (int j = 0; j <= 9; j++)\\n                digitCountR2[v][j] -= digitCountR[j];\\n\\n            for (int j = 0; j <= 9; j++)\\n                for (int k = 0; k <= 9; k++)\\n                    res = (int) (res + ((long) digitCountL2[j][k] * digitCountR2[k][j]) % MOD) % MOD;\\n\\n            for (int j = 0; j <= 9; j++)\\n                digitCountL2[j][v] += digitCountL[j];\\n            digitCountL[v]++;\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n\\n    public int countPalindromes(String s) {\\n        if (s.length() < 5) return 0;\\n        int[] digitCountL = new int[10], digitCountR = new int[10];\\n        int[][] digitCountL2 = new int[10][10], digitCountR2 = new int[10][10];\\n        int res = 0;\\n\\n        digitCountR[s.charAt(s.length() - 1) - \\'0\\']++;\\n        for (int i = s.length() - 2; i > 1; i--) {\\n            int v = s.charAt(i) - \\'0\\';\\n            for (int j = 0; j <= 9; j++)\\n                digitCountR2[v][j] += digitCountR[j];\\n            digitCountR[v]++;\\n        }\\n\\n        digitCountL[s.charAt(0) - \\'0\\']++;\\n        digitCountL[s.charAt(1) - \\'0\\']++;\\n        digitCountL2[s.charAt(0) - \\'0\\'][s.charAt(1) - \\'0\\']++;\\n        for (int i = 2; i < s.length() - 2; i++) {\\n            int v = s.charAt(i) - \\'0\\';\\n\\n            digitCountR[v]--;\\n            for (int j = 0; j <= 9; j++)\\n                digitCountR2[v][j] -= digitCountR[j];\\n\\n            for (int j = 0; j <= 9; j++)\\n                for (int k = 0; k <= 9; k++)\\n                    res = (int) (res + ((long) digitCountL2[j][k] * digitCountR2[k][j]) % MOD) % MOD;\\n\\n            for (int j = 0; j <= 9; j++)\\n                digitCountL2[j][v] += digitCountL[j];\\n            digitCountL[v]++;\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850729,
                "title": "java-o-100-n-count-the-number-of-sub-sequence-ab-readable-code",
                "content": "```Java\\nclass Solution {\\n    private final static int MOD = 1_000_000_007;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long[][][] count1 = helper(s);  // count[i][a][b] is the number of subseq \"ab\" in s.substring(0, i);\\n        long[][][] count2 = helper(new StringBuilder(s).reverse().toString());\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// add the number of each abxba\\n            int i2 = n - 1 - i;\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    res = (res + count1[i][j][k] * count2[i2][j][k]) % MOD;\\n                }\\n            }\\n        }\\n        return (int)res;\\n    }\\n    \\n    private long[][][] helper(String s) {\\n        int n = s.length();\\n        long[][] count = new long[n + 1][10];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) count[i + 1][j] = count[i][j];\\n            count[i + 1][s.charAt(i) - \\'0\\']++;\\n        }\\n        \\n        long[][][] countEx = new long[n + 1][10][10]; \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    countEx[i + 1][j][k] = countEx[i][j][k];\\n                    if (k == s.charAt(i) - \\'0\\') {\\n                        countEx[i + 1][j][k] += count[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        return countEx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    private final static int MOD = 1_000_000_007;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        long[][][] count1 = helper(s);  // count[i][a][b] is the number of subseq \"ab\" in s.substring(0, i);\\n        long[][][] count2 = helper(new StringBuilder(s).reverse().toString());\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// add the number of each abxba\\n            int i2 = n - 1 - i;\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    res = (res + count1[i][j][k] * count2[i2][j][k]) % MOD;\\n                }\\n            }\\n        }\\n        return (int)res;\\n    }\\n    \\n    private long[][][] helper(String s) {\\n        int n = s.length();\\n        long[][] count = new long[n + 1][10];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) count[i + 1][j] = count[i][j];\\n            count[i + 1][s.charAt(i) - \\'0\\']++;\\n        }\\n        \\n        long[][][] countEx = new long[n + 1][10][10]; \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    countEx[i + 1][j][k] = countEx[i][j][k];\\n                    if (k == s.charAt(i) - \\'0\\') {\\n                        countEx[i + 1][j][k] += count[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        return countEx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850720,
                "title": "java-dp",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    final int MOD = (int)1e9 + 7;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        if (n < 5) return 0;\\n        int[][] cntLeft = new int[n][10];\\n        int[][] nearLeft = new int[n][10];\\n        int[][] dpLeft = new int[n][10];\\n        for (int i = 0 ; i < n ; i++) {\\n            if (i > 0) {\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    cntLeft[i][j] = cntLeft[i - 1][j];\\n                    nearLeft[i][j] = nearLeft[i - 1][j];\\n                }\\n                nearLeft[i][s.charAt(i - 1) - \\'0\\'] = i - 1;\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    int l = nearLeft[i][s.charAt(i) - \\'0\\'];\\n                    dpLeft[i][j] = cntLeft[i][j];\\n                    if (l != -1) dpLeft[i][j] += dpLeft[l][j];\\n                }\\n            } else {\\n                for (int j = 0 ; j < 10 ; j++) nearLeft[i][j] = -1;\\n            }\\n            cntLeft[i][s.charAt(i) - \\'0\\'] += 1;            \\n        }        \\n        \\n                \\n        int[][] cntRight = new int[n][10];\\n        int[][] nearRight = new int[n][10];\\n        int[][] dpRight = new int[n][10];\\n        for (int i = n - 1 ; i >= 0 ; i--) {\\n            if (i < n - 1) {\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    cntRight[i][j] = cntRight[i + 1][j];\\n                    nearRight[i][j] = nearRight[i + 1][j];\\n                }\\n                nearRight[i][s.charAt(i + 1) - \\'0\\'] = i + 1;\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    int r = nearRight[i][s.charAt(i) - \\'0\\'];\\n                    dpRight[i][j] = cntRight[i][j];\\n                    if (r != -1) dpRight[i][j] += dpRight[r][j];\\n                }\\n            } else {\\n                for (int j = 0 ; j < 10 ; j++) nearRight[i][j] = -1;\\n            }\\n            cntRight[i][s.charAt(i) - \\'0\\'] += 1;\\n        }\\n\\n        int result = 0;\\n        for (int i = 2 ; i < n - 2 ; i++) {\\n            for (int d1 = 0 ; d1 <= 9 ; d1++) {                \\n                int l = nearLeft[i][d1];\\n                int r = nearRight[i][d1];\\n                if (l == -1 || r == -1) continue;\\n                for (int d2 = 0 ; d2 <= 9 ; d2++) {\\n                    int lc = dpLeft[l][d2];\\n                    int rc = dpRight[r][d2];                    \\n                    int tc = mul(lc, rc);\\n                    result = add(result, tc);\\n                }                \\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int add(int a, int b) {\\n        return (a + b) % MOD;\\n    }\\n    public int mul(int a, int b) {\\n        long _a = 1L * a;\\n        long _b = 1L * b;\\n        return (int)((_a * _b) % MOD);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    final int MOD = (int)1e9 + 7;\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        if (n < 5) return 0;\\n        int[][] cntLeft = new int[n][10];\\n        int[][] nearLeft = new int[n][10];\\n        int[][] dpLeft = new int[n][10];\\n        for (int i = 0 ; i < n ; i++) {\\n            if (i > 0) {\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    cntLeft[i][j] = cntLeft[i - 1][j];\\n                    nearLeft[i][j] = nearLeft[i - 1][j];\\n                }\\n                nearLeft[i][s.charAt(i - 1) - \\'0\\'] = i - 1;\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    int l = nearLeft[i][s.charAt(i) - \\'0\\'];\\n                    dpLeft[i][j] = cntLeft[i][j];\\n                    if (l != -1) dpLeft[i][j] += dpLeft[l][j];\\n                }\\n            } else {\\n                for (int j = 0 ; j < 10 ; j++) nearLeft[i][j] = -1;\\n            }\\n            cntLeft[i][s.charAt(i) - \\'0\\'] += 1;            \\n        }        \\n        \\n                \\n        int[][] cntRight = new int[n][10];\\n        int[][] nearRight = new int[n][10];\\n        int[][] dpRight = new int[n][10];\\n        for (int i = n - 1 ; i >= 0 ; i--) {\\n            if (i < n - 1) {\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    cntRight[i][j] = cntRight[i + 1][j];\\n                    nearRight[i][j] = nearRight[i + 1][j];\\n                }\\n                nearRight[i][s.charAt(i + 1) - \\'0\\'] = i + 1;\\n                for (int j = 0 ; j < 10 ; j++) {\\n                    int r = nearRight[i][s.charAt(i) - \\'0\\'];\\n                    dpRight[i][j] = cntRight[i][j];\\n                    if (r != -1) dpRight[i][j] += dpRight[r][j];\\n                }\\n            } else {\\n                for (int j = 0 ; j < 10 ; j++) nearRight[i][j] = -1;\\n            }\\n            cntRight[i][s.charAt(i) - \\'0\\'] += 1;\\n        }\\n\\n        int result = 0;\\n        for (int i = 2 ; i < n - 2 ; i++) {\\n            for (int d1 = 0 ; d1 <= 9 ; d1++) {                \\n                int l = nearLeft[i][d1];\\n                int r = nearRight[i][d1];\\n                if (l == -1 || r == -1) continue;\\n                for (int d2 = 0 ; d2 <= 9 ; d2++) {\\n                    int lc = dpLeft[l][d2];\\n                    int rc = dpRight[r][d2];                    \\n                    int tc = mul(lc, rc);\\n                    result = add(result, tc);\\n                }                \\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int add(int a, int b) {\\n        return (a + b) % MOD;\\n    }\\n    public int mul(int a, int b) {\\n        long _a = 1L * a;\\n        long _b = 1L * b;\\n        return (int)((_a * _b) % MOD);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850680,
                "title": "java-easy-understanding-summary-solution",
                "content": "```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int len = s.length();\\n        if (len < 5) {\\n            return 0;\\n        }\\n        \\n        int mod = 1_000_000_007;\\n        int[] cnt = new int[10];\\n        \\n        cnt[s.charAt(0) - \\'0\\']++;\\n        \\n        long[][][] couple = new long[len][10][10];\\n        long[][][] right = new long[len][10][10];\\n        \\n        for (int i = 1; i < len; i++) {\\n            int k = s.charAt(i) - \\'0\\';\\n            for (int m = 0; m < 10; m++) {\\n                for (int n = 0; n < 10; n++) {\\n                    couple[i][m][n] = couple[i-1][m][n];\\n                }\\n            }\\n            for (int j = 0; j < 10; j++) {\\n                couple[i][j][k] += cnt[j];\\n            }\\n            cnt[k]++;\\n        }\\n        \\n        Arrays.fill(cnt, 0);\\n\\n        cnt[s.charAt(len-1) - \\'0\\']++;\\n        for (int i = len-2; i >= 0; i--) {\\n            int k = s.charAt(i) - \\'0\\';\\n            for (int m = 0; m < 10; m++) {\\n                for (int n = 0; n < 10; n++) {\\n                    right[i][m][n] = right[i+1][m][n];\\n                }\\n            }\\n            for (int j = 0; j < 10; j++) {\\n                right[i][k][j] = right[i+1][k][j] + cnt[j];\\n            }\\n            cnt[k]++;\\n        }\\n        \\n        long res = 0;\\n        \\n        for (int i = 2; i < len-2; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    res = (res + couple[i-1][j][k] * right[i+1][k][j]) % mod;\\n                }\\n            }\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPalindromes(String s) {\\n        int len = s.length();\\n        if (len < 5) {\\n            return 0;\\n        }\\n        \\n        int mod = 1_000_000_007;\\n        int[] cnt = new int[10];\\n        \\n        cnt[s.charAt(0) - \\'0\\']++;\\n        \\n        long[][][] couple = new long[len][10][10];\\n        long[][][] right = new long[len][10][10];\\n        \\n        for (int i = 1; i < len; i++) {\\n            int k = s.charAt(i) - \\'0\\';\\n            for (int m = 0; m < 10; m++) {\\n                for (int n = 0; n < 10; n++) {\\n                    couple[i][m][n] = couple[i-1][m][n];\\n                }\\n            }\\n            for (int j = 0; j < 10; j++) {\\n                couple[i][j][k] += cnt[j];\\n            }\\n            cnt[k]++;\\n        }\\n        \\n        Arrays.fill(cnt, 0);\\n\\n        cnt[s.charAt(len-1) - \\'0\\']++;\\n        for (int i = len-2; i >= 0; i--) {\\n            int k = s.charAt(i) - \\'0\\';\\n            for (int m = 0; m < 10; m++) {\\n                for (int n = 0; n < 10; n++) {\\n                    right[i][m][n] = right[i+1][m][n];\\n                }\\n            }\\n            for (int j = 0; j < 10; j++) {\\n                right[i][k][j] = right[i+1][k][j] + cnt[j];\\n            }\\n            cnt[k]++;\\n        }\\n        \\n        long res = 0;\\n        \\n        for (int i = 2; i < len-2; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                for (int k = 0; k < 10; k++) {\\n                    res = (res + couple[i-1][j][k] * right[i+1][k][j]) % mod;\\n                }\\n            }\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850629,
                "title": "javascript-o-n-dp",
                "content": "Step 1: count the number of each one-digit combination to the left and to the right of the current index.\\nStep 2: count the number of each two-digit combination to the left and to the right of the current index based on the result from step 1. Right combinations should be reversed.\\nStep 3: for each middle index, the number of palindromes equals the sum of products of two-digit combinations: 00 * 00, 01 * 10, and so on.\\n\\n\\n```js\\nfunction countPalindromes(s) {\\n    const singlel = Array.from({ length: s.length + 1 }).map(() => Array(10).fill(0));\\n    const singler = Array.from({ length: s.length + 1 }).map(() => Array(10).fill(0));\\n    for (let il = 0; il < s.length - 1; il += 1) {\\n        const ir = s.length - 1 - il;\\n        for (let j = 0; j < 10; j += 1) {\\n            singlel[il + 1][j] = singlel[il][j];\\n            singler[ir - 1][j] = singler[ir][j];\\n        }\\n        singlel[il + 1][Number(s.charAt(il))] += 1;\\n        singler[ir - 1][Number(s.charAt(ir))] += 1;\\n    }\\n    \\n    const doublel = Array.from({ length: s.length + 1 }).map(() => Array(100).fill(0));\\n    const doubler = Array.from({ length: s.length + 1 }).map(() => Array(100).fill(0));\\n    for (let il = 1; il < s.length - 2; il += 1) {\\n        const ir = s.length - 1 - il;\\n        for (let j = 0; j < 100; j += 1) {\\n            doublel[il + 1][j] = doublel[il][j];\\n            doubler[ir - 1][j] = doubler[ir][j];\\n        }\\n        \\n        for (let j = 0; j < 10; j += 1) {\\n            doublel[il + 1][j * 10 + Number(s.charAt(il))] += singlel[il][j];\\n            doubler[ir - 1][j * 10 + Number(s.charAt(ir))] += singler[ir][j];\\n        }\\n    }\\n    \\n    let result = 0;\\n    for (let i = 2; i < s.length - 2; i += 1) {\\n        for (let j = 0; j < 100; j += 1) {\\n            result += doublel[i][j] * doubler[i][j];\\n            result = result % 1000000007;\\n        }\\n    }\\n    \\n    return result;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```js\\nfunction countPalindromes(s) {\\n    const singlel = Array.from({ length: s.length + 1 }).map(() => Array(10).fill(0));\\n    const singler = Array.from({ length: s.length + 1 }).map(() => Array(10).fill(0));\\n    for (let il = 0; il < s.length - 1; il += 1) {\\n        const ir = s.length - 1 - il;\\n        for (let j = 0; j < 10; j += 1) {\\n            singlel[il + 1][j] = singlel[il][j];\\n            singler[ir - 1][j] = singler[ir][j];\\n        }\\n        singlel[il + 1][Number(s.charAt(il))] += 1;\\n        singler[ir - 1][Number(s.charAt(ir))] += 1;\\n    }\\n    \\n    const doublel = Array.from({ length: s.length + 1 }).map(() => Array(100).fill(0));\\n    const doubler = Array.from({ length: s.length + 1 }).map(() => Array(100).fill(0));\\n    for (let il = 1; il < s.length - 2; il += 1) {\\n        const ir = s.length - 1 - il;\\n        for (let j = 0; j < 100; j += 1) {\\n            doublel[il + 1][j] = doublel[il][j];\\n            doubler[ir - 1][j] = doubler[ir][j];\\n        }\\n        \\n        for (let j = 0; j < 10; j += 1) {\\n            doublel[il + 1][j * 10 + Number(s.charAt(il))] += singlel[il][j];\\n            doubler[ir - 1][j * 10 + Number(s.charAt(ir))] += singler[ir][j];\\n        }\\n    }\\n    \\n    let result = 0;\\n    for (let i = 2; i < s.length - 2; i += 1) {\\n        for (let j = 0; j < 100; j += 1) {\\n            result += doublel[i][j] * doubler[i][j];\\n            result = result % 1000000007;\\n        }\\n    }\\n    \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1698584,
                "content": [
                    {
                        "username": "pjagannadham170248",
                        "content": "I am trying to solve this problem using backtracking and it showing tle if any one knows how to optimize please share with us.\\nhere is my code.\\n class Solution {\\n    public static int palindrome(int i,String str,String str2,int n)\\n    {\\n        if(i>=n)\\n        {\\n            StringBuilder str3=new StringBuilder(str2);\\n            str3.reverse();\\n            String s1=str3.toString();\\n            if(s1.length()==5 && s1.equals(str2)) return 1;\\n            return 0;\\n        }\\n        str2+=str.charAt(i);\\n        int l=palindrome(i+1,str,str2,n);\\n        str2=str2.substring(0,str2.length()-1);\\n        int r=palindrome(i+1,str,str2,n);\\n        return (l%1000000007+r%1000000007)%1000000007;\\n    }\\n    public int countPalindromes(String s) {\\n        int n=s.length();\\n        return palindrome(0,s,\"\",n);\\n        \\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "woospiedoo",
                        "content": "palindrome of size 5 == subsequence of size 3  with distinct digits. (i,j,k,j,i).. we need i,j,k ."
                    },
                    {
                        "username": "Samarthakhare",
                        "content": "How to solve the same if a even length palindromic seq is asked ?"
                    },
                    {
                        "username": "shrik04",
                        "content": "Can anyone tell why my code gives output 24 instead of 21 for this test case: \"0000000\" ?\\n\\nHere is the code:\\n\\nclass Solution {\\n    public int solve(int i, int j, int n, String s, List<Integer> ds, int[][][] dp) {\\n        \\n        if(j-i+1 < n) return 0;\\n        \\n        if(i > j || i >= s.length() || j < 0) return 0;\\n        \\n        if(i == j) {\\n            if(n == 1) {\\n                System.out.println(ds);\\n                System.out.println(i);\\n                return dp[i][j][n] = 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][n] != -1) return dp[i][j][n];\\n        \\n        int cnt = 0;\\n        \\n        if(s.charAt(i) == s.charAt(j)) {\\n            int skipLeft = solve(i+1, j, n, s, ds, dp);\\n            int skipRight = solve(i, j-1, n, s, ds, dp);\\n            int pick = 0;\\n            if(n >= 2) {\\n                Collections.addAll(ds, i, j);\\n                pick = solve(i+1, j-1, n-2, s, ds, dp);\\n                ds.remove(ds.size()-1);\\n                ds.remove(ds.size()-1);\\n            }\\n            cnt += (skipLeft + skipRight + pick) % 1000000007;\\n        }\\n        else {\\n            int goRight = solve(i+1, j, n, s, ds, dp);\\n            int goLeft = solve(i, j-1, n, s, ds, dp);\\n            cnt += (goRight + goLeft) % 1000000007;\\n        }\\n        \\n        return dp[i][j][n] = cnt;\\n    }\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        int[][][] dp = new int[n][n][6];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return solve(0, s.length()-1, 5, s, new ArrayList<>(), dp);\\n    }\\n}\\n"
                    },
                    {
                        "username": "hansman",
                        "content": "I implemented a TLE solution based on backtracking and some memoization. How to evaluate the complexity of this solution? I believe the time complexity would be 2^n to explore the \\'visited\\' value space and 2^n space complexity. Any thoughts?\\n\\n```\\nclass Solution {\\npublic: \\n    unordered_set<string> visitedList;\\n    \\n    int countPalindromes(string s) {\\n        string visited(s.size(), \\'0\\');\\n        return countPalindromes(s, visited);\\n    }\\n    \\n    \\n    int countPalindromes(string s, string& visited, int count = 0) {\\n        if (visitedList.count(visited)) {\\n            return 0;\\n        }\\n        visitedList.insert(visited);\\n        int n = s.size();\\n        if ((n - count) < 5) {\\n            return 0;\\n        }\\n        if ((n - count) == 5) {\\n            // check palindrome\\n            int right = n - 1;\\n            int left = 0;\\n            while (right > left) {\\n                if (visited[left] == \\'1\\') {\\n                    left++;\\n                    continue;\\n                }\\n                if (visited[right] == \\'1\\') {\\n                    right--;\\n                    continue;\\n                }\\n                if (s[right--] != s[left++]) {\\n                    return 0;\\n                }\\n            }\\n            return 1;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == \\'1\\') {\\n                continue;\\n            }\\n            visited[i] = \\'1\\';\\n            ans += countPalindromes(s, visited, count + 1);\\n            visited[i] = \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "pjagannadham170248",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 2050096,
                "content": [
                    {
                        "username": "pjagannadham170248",
                        "content": "I am trying to solve this problem using backtracking and it showing tle if any one knows how to optimize please share with us.\\nhere is my code.\\n class Solution {\\n    public static int palindrome(int i,String str,String str2,int n)\\n    {\\n        if(i>=n)\\n        {\\n            StringBuilder str3=new StringBuilder(str2);\\n            str3.reverse();\\n            String s1=str3.toString();\\n            if(s1.length()==5 && s1.equals(str2)) return 1;\\n            return 0;\\n        }\\n        str2+=str.charAt(i);\\n        int l=palindrome(i+1,str,str2,n);\\n        str2=str2.substring(0,str2.length()-1);\\n        int r=palindrome(i+1,str,str2,n);\\n        return (l%1000000007+r%1000000007)%1000000007;\\n    }\\n    public int countPalindromes(String s) {\\n        int n=s.length();\\n        return palindrome(0,s,\"\",n);\\n        \\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "woospiedoo",
                        "content": "palindrome of size 5 == subsequence of size 3  with distinct digits. (i,j,k,j,i).. we need i,j,k ."
                    },
                    {
                        "username": "Samarthakhare",
                        "content": "How to solve the same if a even length palindromic seq is asked ?"
                    },
                    {
                        "username": "shrik04",
                        "content": "Can anyone tell why my code gives output 24 instead of 21 for this test case: \"0000000\" ?\\n\\nHere is the code:\\n\\nclass Solution {\\n    public int solve(int i, int j, int n, String s, List<Integer> ds, int[][][] dp) {\\n        \\n        if(j-i+1 < n) return 0;\\n        \\n        if(i > j || i >= s.length() || j < 0) return 0;\\n        \\n        if(i == j) {\\n            if(n == 1) {\\n                System.out.println(ds);\\n                System.out.println(i);\\n                return dp[i][j][n] = 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][n] != -1) return dp[i][j][n];\\n        \\n        int cnt = 0;\\n        \\n        if(s.charAt(i) == s.charAt(j)) {\\n            int skipLeft = solve(i+1, j, n, s, ds, dp);\\n            int skipRight = solve(i, j-1, n, s, ds, dp);\\n            int pick = 0;\\n            if(n >= 2) {\\n                Collections.addAll(ds, i, j);\\n                pick = solve(i+1, j-1, n-2, s, ds, dp);\\n                ds.remove(ds.size()-1);\\n                ds.remove(ds.size()-1);\\n            }\\n            cnt += (skipLeft + skipRight + pick) % 1000000007;\\n        }\\n        else {\\n            int goRight = solve(i+1, j, n, s, ds, dp);\\n            int goLeft = solve(i, j-1, n, s, ds, dp);\\n            cnt += (goRight + goLeft) % 1000000007;\\n        }\\n        \\n        return dp[i][j][n] = cnt;\\n    }\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        int[][][] dp = new int[n][n][6];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return solve(0, s.length()-1, 5, s, new ArrayList<>(), dp);\\n    }\\n}\\n"
                    },
                    {
                        "username": "hansman",
                        "content": "I implemented a TLE solution based on backtracking and some memoization. How to evaluate the complexity of this solution? I believe the time complexity would be 2^n to explore the \\'visited\\' value space and 2^n space complexity. Any thoughts?\\n\\n```\\nclass Solution {\\npublic: \\n    unordered_set<string> visitedList;\\n    \\n    int countPalindromes(string s) {\\n        string visited(s.size(), \\'0\\');\\n        return countPalindromes(s, visited);\\n    }\\n    \\n    \\n    int countPalindromes(string s, string& visited, int count = 0) {\\n        if (visitedList.count(visited)) {\\n            return 0;\\n        }\\n        visitedList.insert(visited);\\n        int n = s.size();\\n        if ((n - count) < 5) {\\n            return 0;\\n        }\\n        if ((n - count) == 5) {\\n            // check palindrome\\n            int right = n - 1;\\n            int left = 0;\\n            while (right > left) {\\n                if (visited[left] == \\'1\\') {\\n                    left++;\\n                    continue;\\n                }\\n                if (visited[right] == \\'1\\') {\\n                    right--;\\n                    continue;\\n                }\\n                if (s[right--] != s[left++]) {\\n                    return 0;\\n                }\\n            }\\n            return 1;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == \\'1\\') {\\n                continue;\\n            }\\n            visited[i] = \\'1\\';\\n            ans += countPalindromes(s, visited, count + 1);\\n            visited[i] = \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "pjagannadham170248",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1921342,
                "content": [
                    {
                        "username": "pjagannadham170248",
                        "content": "I am trying to solve this problem using backtracking and it showing tle if any one knows how to optimize please share with us.\\nhere is my code.\\n class Solution {\\n    public static int palindrome(int i,String str,String str2,int n)\\n    {\\n        if(i>=n)\\n        {\\n            StringBuilder str3=new StringBuilder(str2);\\n            str3.reverse();\\n            String s1=str3.toString();\\n            if(s1.length()==5 && s1.equals(str2)) return 1;\\n            return 0;\\n        }\\n        str2+=str.charAt(i);\\n        int l=palindrome(i+1,str,str2,n);\\n        str2=str2.substring(0,str2.length()-1);\\n        int r=palindrome(i+1,str,str2,n);\\n        return (l%1000000007+r%1000000007)%1000000007;\\n    }\\n    public int countPalindromes(String s) {\\n        int n=s.length();\\n        return palindrome(0,s,\"\",n);\\n        \\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "woospiedoo",
                        "content": "palindrome of size 5 == subsequence of size 3  with distinct digits. (i,j,k,j,i).. we need i,j,k ."
                    },
                    {
                        "username": "Samarthakhare",
                        "content": "How to solve the same if a even length palindromic seq is asked ?"
                    },
                    {
                        "username": "shrik04",
                        "content": "Can anyone tell why my code gives output 24 instead of 21 for this test case: \"0000000\" ?\\n\\nHere is the code:\\n\\nclass Solution {\\n    public int solve(int i, int j, int n, String s, List<Integer> ds, int[][][] dp) {\\n        \\n        if(j-i+1 < n) return 0;\\n        \\n        if(i > j || i >= s.length() || j < 0) return 0;\\n        \\n        if(i == j) {\\n            if(n == 1) {\\n                System.out.println(ds);\\n                System.out.println(i);\\n                return dp[i][j][n] = 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][n] != -1) return dp[i][j][n];\\n        \\n        int cnt = 0;\\n        \\n        if(s.charAt(i) == s.charAt(j)) {\\n            int skipLeft = solve(i+1, j, n, s, ds, dp);\\n            int skipRight = solve(i, j-1, n, s, ds, dp);\\n            int pick = 0;\\n            if(n >= 2) {\\n                Collections.addAll(ds, i, j);\\n                pick = solve(i+1, j-1, n-2, s, ds, dp);\\n                ds.remove(ds.size()-1);\\n                ds.remove(ds.size()-1);\\n            }\\n            cnt += (skipLeft + skipRight + pick) % 1000000007;\\n        }\\n        else {\\n            int goRight = solve(i+1, j, n, s, ds, dp);\\n            int goLeft = solve(i, j-1, n, s, ds, dp);\\n            cnt += (goRight + goLeft) % 1000000007;\\n        }\\n        \\n        return dp[i][j][n] = cnt;\\n    }\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        int[][][] dp = new int[n][n][6];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return solve(0, s.length()-1, 5, s, new ArrayList<>(), dp);\\n    }\\n}\\n"
                    },
                    {
                        "username": "hansman",
                        "content": "I implemented a TLE solution based on backtracking and some memoization. How to evaluate the complexity of this solution? I believe the time complexity would be 2^n to explore the \\'visited\\' value space and 2^n space complexity. Any thoughts?\\n\\n```\\nclass Solution {\\npublic: \\n    unordered_set<string> visitedList;\\n    \\n    int countPalindromes(string s) {\\n        string visited(s.size(), \\'0\\');\\n        return countPalindromes(s, visited);\\n    }\\n    \\n    \\n    int countPalindromes(string s, string& visited, int count = 0) {\\n        if (visitedList.count(visited)) {\\n            return 0;\\n        }\\n        visitedList.insert(visited);\\n        int n = s.size();\\n        if ((n - count) < 5) {\\n            return 0;\\n        }\\n        if ((n - count) == 5) {\\n            // check palindrome\\n            int right = n - 1;\\n            int left = 0;\\n            while (right > left) {\\n                if (visited[left] == \\'1\\') {\\n                    left++;\\n                    continue;\\n                }\\n                if (visited[right] == \\'1\\') {\\n                    right--;\\n                    continue;\\n                }\\n                if (s[right--] != s[left++]) {\\n                    return 0;\\n                }\\n            }\\n            return 1;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == \\'1\\') {\\n                continue;\\n            }\\n            visited[i] = \\'1\\';\\n            ans += countPalindromes(s, visited, count + 1);\\n            visited[i] = \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "pjagannadham170248",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1698926,
                "content": [
                    {
                        "username": "pjagannadham170248",
                        "content": "I am trying to solve this problem using backtracking and it showing tle if any one knows how to optimize please share with us.\\nhere is my code.\\n class Solution {\\n    public static int palindrome(int i,String str,String str2,int n)\\n    {\\n        if(i>=n)\\n        {\\n            StringBuilder str3=new StringBuilder(str2);\\n            str3.reverse();\\n            String s1=str3.toString();\\n            if(s1.length()==5 && s1.equals(str2)) return 1;\\n            return 0;\\n        }\\n        str2+=str.charAt(i);\\n        int l=palindrome(i+1,str,str2,n);\\n        str2=str2.substring(0,str2.length()-1);\\n        int r=palindrome(i+1,str,str2,n);\\n        return (l%1000000007+r%1000000007)%1000000007;\\n    }\\n    public int countPalindromes(String s) {\\n        int n=s.length();\\n        return palindrome(0,s,\"\",n);\\n        \\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "woospiedoo",
                        "content": "palindrome of size 5 == subsequence of size 3  with distinct digits. (i,j,k,j,i).. we need i,j,k ."
                    },
                    {
                        "username": "Samarthakhare",
                        "content": "How to solve the same if a even length palindromic seq is asked ?"
                    },
                    {
                        "username": "shrik04",
                        "content": "Can anyone tell why my code gives output 24 instead of 21 for this test case: \"0000000\" ?\\n\\nHere is the code:\\n\\nclass Solution {\\n    public int solve(int i, int j, int n, String s, List<Integer> ds, int[][][] dp) {\\n        \\n        if(j-i+1 < n) return 0;\\n        \\n        if(i > j || i >= s.length() || j < 0) return 0;\\n        \\n        if(i == j) {\\n            if(n == 1) {\\n                System.out.println(ds);\\n                System.out.println(i);\\n                return dp[i][j][n] = 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][n] != -1) return dp[i][j][n];\\n        \\n        int cnt = 0;\\n        \\n        if(s.charAt(i) == s.charAt(j)) {\\n            int skipLeft = solve(i+1, j, n, s, ds, dp);\\n            int skipRight = solve(i, j-1, n, s, ds, dp);\\n            int pick = 0;\\n            if(n >= 2) {\\n                Collections.addAll(ds, i, j);\\n                pick = solve(i+1, j-1, n-2, s, ds, dp);\\n                ds.remove(ds.size()-1);\\n                ds.remove(ds.size()-1);\\n            }\\n            cnt += (skipLeft + skipRight + pick) % 1000000007;\\n        }\\n        else {\\n            int goRight = solve(i+1, j, n, s, ds, dp);\\n            int goLeft = solve(i, j-1, n, s, ds, dp);\\n            cnt += (goRight + goLeft) % 1000000007;\\n        }\\n        \\n        return dp[i][j][n] = cnt;\\n    }\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        int[][][] dp = new int[n][n][6];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return solve(0, s.length()-1, 5, s, new ArrayList<>(), dp);\\n    }\\n}\\n"
                    },
                    {
                        "username": "hansman",
                        "content": "I implemented a TLE solution based on backtracking and some memoization. How to evaluate the complexity of this solution? I believe the time complexity would be 2^n to explore the \\'visited\\' value space and 2^n space complexity. Any thoughts?\\n\\n```\\nclass Solution {\\npublic: \\n    unordered_set<string> visitedList;\\n    \\n    int countPalindromes(string s) {\\n        string visited(s.size(), \\'0\\');\\n        return countPalindromes(s, visited);\\n    }\\n    \\n    \\n    int countPalindromes(string s, string& visited, int count = 0) {\\n        if (visitedList.count(visited)) {\\n            return 0;\\n        }\\n        visitedList.insert(visited);\\n        int n = s.size();\\n        if ((n - count) < 5) {\\n            return 0;\\n        }\\n        if ((n - count) == 5) {\\n            // check palindrome\\n            int right = n - 1;\\n            int left = 0;\\n            while (right > left) {\\n                if (visited[left] == \\'1\\') {\\n                    left++;\\n                    continue;\\n                }\\n                if (visited[right] == \\'1\\') {\\n                    right--;\\n                    continue;\\n                }\\n                if (s[right--] != s[left++]) {\\n                    return 0;\\n                }\\n            }\\n            return 1;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == \\'1\\') {\\n                continue;\\n            }\\n            visited[i] = \\'1\\';\\n            ans += countPalindromes(s, visited, count + 1);\\n            visited[i] = \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "pjagannadham170248",
                        "content": "same bro"
                    }
                ]
            },
            {
                "id": 1697991,
                "content": [
                    {
                        "username": "pjagannadham170248",
                        "content": "I am trying to solve this problem using backtracking and it showing tle if any one knows how to optimize please share with us.\\nhere is my code.\\n class Solution {\\n    public static int palindrome(int i,String str,String str2,int n)\\n    {\\n        if(i>=n)\\n        {\\n            StringBuilder str3=new StringBuilder(str2);\\n            str3.reverse();\\n            String s1=str3.toString();\\n            if(s1.length()==5 && s1.equals(str2)) return 1;\\n            return 0;\\n        }\\n        str2+=str.charAt(i);\\n        int l=palindrome(i+1,str,str2,n);\\n        str2=str2.substring(0,str2.length()-1);\\n        int r=palindrome(i+1,str,str2,n);\\n        return (l%1000000007+r%1000000007)%1000000007;\\n    }\\n    public int countPalindromes(String s) {\\n        int n=s.length();\\n        return palindrome(0,s,\"\",n);\\n        \\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "woospiedoo",
                        "content": "palindrome of size 5 == subsequence of size 3  with distinct digits. (i,j,k,j,i).. we need i,j,k ."
                    },
                    {
                        "username": "Samarthakhare",
                        "content": "How to solve the same if a even length palindromic seq is asked ?"
                    },
                    {
                        "username": "shrik04",
                        "content": "Can anyone tell why my code gives output 24 instead of 21 for this test case: \"0000000\" ?\\n\\nHere is the code:\\n\\nclass Solution {\\n    public int solve(int i, int j, int n, String s, List<Integer> ds, int[][][] dp) {\\n        \\n        if(j-i+1 < n) return 0;\\n        \\n        if(i > j || i >= s.length() || j < 0) return 0;\\n        \\n        if(i == j) {\\n            if(n == 1) {\\n                System.out.println(ds);\\n                System.out.println(i);\\n                return dp[i][j][n] = 1;\\n            }\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][n] != -1) return dp[i][j][n];\\n        \\n        int cnt = 0;\\n        \\n        if(s.charAt(i) == s.charAt(j)) {\\n            int skipLeft = solve(i+1, j, n, s, ds, dp);\\n            int skipRight = solve(i, j-1, n, s, ds, dp);\\n            int pick = 0;\\n            if(n >= 2) {\\n                Collections.addAll(ds, i, j);\\n                pick = solve(i+1, j-1, n-2, s, ds, dp);\\n                ds.remove(ds.size()-1);\\n                ds.remove(ds.size()-1);\\n            }\\n            cnt += (skipLeft + skipRight + pick) % 1000000007;\\n        }\\n        else {\\n            int goRight = solve(i+1, j, n, s, ds, dp);\\n            int goLeft = solve(i, j-1, n, s, ds, dp);\\n            cnt += (goRight + goLeft) % 1000000007;\\n        }\\n        \\n        return dp[i][j][n] = cnt;\\n    }\\n    \\n    public int countPalindromes(String s) {\\n        int n = s.length();\\n        int[][][] dp = new int[n][n][6];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return solve(0, s.length()-1, 5, s, new ArrayList<>(), dp);\\n    }\\n}\\n"
                    },
                    {
                        "username": "hansman",
                        "content": "I implemented a TLE solution based on backtracking and some memoization. How to evaluate the complexity of this solution? I believe the time complexity would be 2^n to explore the \\'visited\\' value space and 2^n space complexity. Any thoughts?\\n\\n```\\nclass Solution {\\npublic: \\n    unordered_set<string> visitedList;\\n    \\n    int countPalindromes(string s) {\\n        string visited(s.size(), \\'0\\');\\n        return countPalindromes(s, visited);\\n    }\\n    \\n    \\n    int countPalindromes(string s, string& visited, int count = 0) {\\n        if (visitedList.count(visited)) {\\n            return 0;\\n        }\\n        visitedList.insert(visited);\\n        int n = s.size();\\n        if ((n - count) < 5) {\\n            return 0;\\n        }\\n        if ((n - count) == 5) {\\n            // check palindrome\\n            int right = n - 1;\\n            int left = 0;\\n            while (right > left) {\\n                if (visited[left] == \\'1\\') {\\n                    left++;\\n                    continue;\\n                }\\n                if (visited[right] == \\'1\\') {\\n                    right--;\\n                    continue;\\n                }\\n                if (s[right--] != s[left++]) {\\n                    return 0;\\n                }\\n            }\\n            return 1;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == \\'1\\') {\\n                continue;\\n            }\\n            visited[i] = \\'1\\';\\n            ans += countPalindromes(s, visited, count + 1);\\n            visited[i] = \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "pjagannadham170248",
                        "content": "same bro"
                    }
                ]
            }
        ]
    }
]