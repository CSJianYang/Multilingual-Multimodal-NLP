[
    {
        "title": "Minimum Operations to Make the Array Alternating",
        "question_content": "You are given a 0-indexed array nums consisting of n positive integers.\nThe array nums is called alternating if:\n\n\tnums[i - 2] == nums[i], where 2 <= i <= n - 1.\n\tnums[i - 1] != nums[i], where 1 <= i <= n - 1.\n\nIn one operation, you can choose an index i and change nums[i] into any positive integer.\nReturn the minimum number of operations required to make the array alternating.\n&nbsp;\nExample 1:\n\nInput: nums = [3,1,3,2,4,3]\nOutput: 3\nExplanation:\nOne way to make the array alternating is by converting it to [3,1,3,1,3,1].\nThe number of operations required in this case is 3.\nIt can be proven that it is not possible to make the array alternating in less than 3 operations. \n\nExample 2:\n\nInput: nums = [1,2,2,2,2]\nOutput: 2\nExplanation:\nOne way to make the array alternating is by converting it to [1,2,1,2,1].\nThe number of operations required in this case is 2.\nNote that the array cannot be converted to [2,2,2,2,2] because in this case nums[0] == nums[1] which violates the conditions of an alternating array.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 1766804,
                "title": "c-find-max-and-second-max-easy-to-understand",
                "content": "**Approach**\\n1. Make separate hashmaps to store the frequency of even and odd indices elements separately. \\n2. Find the elements with maximum frequency and second maximum frequency for both even and odd indices. \\n3. As mentioned in the problem description, ``` arr[i]!=arr[i-1]``` so we need to take care that the elements with maximum frequency for odd and even indices are not same. That\\'s why we need the second maximum frequency for both odd and even indices so that we can use the second maximum frequency element for odd or even indices whichever gives the minimum result. \\n\\n\\n[@jionghongli](https://leetcode.com/jionghongli/) has explained the logic beautifully! Check out his comment:   https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/discuss/1766804/C++-or-Find-max-and-second-max-or-easy-to-understand/1264833\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        int totalEven = 0, totalOdd = 0;\\n        \\n        unordered_map<int,int> mapEven, mapOdd;\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            if(i%2==0) {\\n                totalEven++;\\n                mapEven[nums[i]]++;\\n            }\\n            \\n            else {\\n                totalOdd++;\\n                mapOdd[nums[i]]++;\\n            }\\n        }\\n        \\n        \\n        int firstEvenCount = 0, firstEven = 0;\\n        int secondEvenCount = 0, secondEven = 0;\\n        \\n        for(auto it=mapEven.begin();it!=mapEven.end();it++) {\\n            int num = it->first;\\n            int count = it->second;\\n            \\n            if(count>=firstEvenCount) {\\n                secondEvenCount = firstEvenCount;\\n                secondEven = firstEven;\\n                firstEvenCount = count;\\n                firstEven = num;\\n            }\\n            \\n            else if(count >= secondEvenCount) {\\n                secondEvenCount = count;\\n                secondEven = num;\\n            }\\n        }\\n        \\n        \\n        int firstOddCount = 0, firstOdd = 0;\\n        int secondOddCount = 0, secondOdd = 0;\\n        \\n        \\n        for(auto it=mapOdd.begin();it!=mapOdd.end();it++) {\\n            int num = it->first;\\n            int count = it->second;\\n            \\n            if(count>=firstOddCount) {\\n                secondOddCount = firstOddCount;\\n                secondOdd = firstOdd;\\n                firstOddCount = count;\\n                firstOdd = num;\\n            }\\n            \\n            else if(count>=secondOddCount) {\\n                secondOddCount = count;\\n                secondOdd = num;\\n            }\\n        }\\n        \\n        int operationsEven = 0, operationsOdd = 0;\\n        \\n        \\n        operationsEven = totalEven - firstEvenCount;\\n        \\n        if(firstEven!=firstOdd) operationsEven += (totalOdd - firstOddCount);\\n        else operationsEven += (totalOdd - secondOddCount);\\n        \\n        \\n        operationsOdd = totalOdd - firstOddCount;\\n        if(firstOdd!=firstEven) operationsOdd += (totalEven - firstEvenCount);\\n        else operationsOdd += (totalEven - secondEvenCount);\\n        \\n        \\n        return min(operationsEven, operationsOdd);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` arr[i]!=arr[i-1]```\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        int totalEven = 0, totalOdd = 0;\\n        \\n        unordered_map<int,int> mapEven, mapOdd;\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            if(i%2==0) {\\n                totalEven++;\\n                mapEven[nums[i]]++;\\n            }\\n            \\n            else {\\n                totalOdd++;\\n                mapOdd[nums[i]]++;\\n            }\\n        }\\n        \\n        \\n        int firstEvenCount = 0, firstEven = 0;\\n        int secondEvenCount = 0, secondEven = 0;\\n        \\n        for(auto it=mapEven.begin();it!=mapEven.end();it++) {\\n            int num = it->first;\\n            int count = it->second;\\n            \\n            if(count>=firstEvenCount) {\\n                secondEvenCount = firstEvenCount;\\n                secondEven = firstEven;\\n                firstEvenCount = count;\\n                firstEven = num;\\n            }\\n            \\n            else if(count >= secondEvenCount) {\\n                secondEvenCount = count;\\n                secondEven = num;\\n            }\\n        }\\n        \\n        \\n        int firstOddCount = 0, firstOdd = 0;\\n        int secondOddCount = 0, secondOdd = 0;\\n        \\n        \\n        for(auto it=mapOdd.begin();it!=mapOdd.end();it++) {\\n            int num = it->first;\\n            int count = it->second;\\n            \\n            if(count>=firstOddCount) {\\n                secondOddCount = firstOddCount;\\n                secondOdd = firstOdd;\\n                firstOddCount = count;\\n                firstOdd = num;\\n            }\\n            \\n            else if(count>=secondOddCount) {\\n                secondOddCount = count;\\n                secondOdd = num;\\n            }\\n        }\\n        \\n        int operationsEven = 0, operationsOdd = 0;\\n        \\n        \\n        operationsEven = totalEven - firstEvenCount;\\n        \\n        if(firstEven!=firstOdd) operationsEven += (totalOdd - firstOddCount);\\n        else operationsEven += (totalOdd - secondOddCount);\\n        \\n        \\n        operationsOdd = totalOdd - firstOddCount;\\n        if(firstOdd!=firstEven) operationsOdd += (totalEven - firstEvenCount);\\n        else operationsOdd += (totalEven - secondEvenCount);\\n        \\n        \\n        return min(operationsEven, operationsOdd);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766928,
                "title": "c-java-4-lines-frequency-table-explanation",
                "content": "- Store the frequencies of odd and even indexes. \\n- Then, keep track of maximum frequency of element in j and k variable.\\n-  It will give us how many elements __we don\\'t need to change__. In last just find how many elements __we have to change by subtracting from total number of elements__.\\n```cpp\\nclass Solution {\\n    int freq[100005][2];\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        memset(freq, 0, sizeof(freq));\\n        int n=nums.size(), i, j, k, ans=0;\\n        for(i = 0; i < n; i++) {\\n\\t\\t\\tfreq[nums[i]][i&1]++;\\n\\t\\t}\\n        for(i = 1, j=k=0; i <= 100000; i++) {\\n\\t\\t   // Add the maximum frequency of odd indexes to maximum frequency even indexes \\n\\t\\t   //and vice versa, it will give us how many elements we don\\'t need to change. \\n            ans = max(ans, max(freq[i][0] + k, freq[i][1] + j));\\n            j = max(j, freq[i][0]);\\n            k = max(k, freq[i][1]);\\n        }\\n        return n - ans;\\n    }\\n};\\n```\\n```java\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int freq[][] = new int[100005][2];\\n        int i, j, k, ans=0;\\n        for(i = 0; i < nums.length; i++) {\\n    \\t\\t\\tfreq[nums[i]][i&1]++;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor(i = 1, j=k=0; i <= 100000; i++) {\\n\\t\\t\\t// Add the maximum frequency of odd indexes to maximum frequency even indexes \\n\\t\\t    //and vice versa, it will give us how many elements we don\\'t need to change. \\n    \\t\\tans = Math.max(ans, Math.max(freq[i][0] + k, freq[i][1] + j));\\n            j = Math.max(j, freq[i][0]);\\n            k = Math.max(k, freq[i][1]);\\n        }\\n        return nums.length - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n    int freq[100005][2];\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        memset(freq, 0, sizeof(freq));\\n        int n=nums.size(), i, j, k, ans=0;\\n        for(i = 0; i < n; i++) {\\n\\t\\t\\tfreq[nums[i]][i&1]++;\\n\\t\\t}\\n        for(i = 1, j=k=0; i <= 100000; i++) {\\n\\t\\t   // Add the maximum frequency of odd indexes to maximum frequency even indexes \\n\\t\\t   //and vice versa, it will give us how many elements we don\\'t need to change. \\n            ans = max(ans, max(freq[i][0] + k, freq[i][1] + j));\\n            j = max(j, freq[i][0]);\\n            k = max(k, freq[i][1]);\\n        }\\n        return n - ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int freq[][] = new int[100005][2];\\n        int i, j, k, ans=0;\\n        for(i = 0; i < nums.length; i++) {\\n    \\t\\t\\tfreq[nums[i]][i&1]++;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor(i = 1, j=k=0; i <= 100000; i++) {\\n\\t\\t\\t// Add the maximum frequency of odd indexes to maximum frequency even indexes \\n\\t\\t    //and vice versa, it will give us how many elements we don\\'t need to change. \\n    \\t\\tans = Math.max(ans, Math.max(freq[i][0] + k, freq[i][1] + j));\\n            j = Math.max(j, freq[i][0]);\\n            k = Math.max(k, freq[i][1]);\\n        }\\n        return nums.length - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769327,
                "title": "top-2-frequent-numbers",
                "content": "To find out minimum operations to make `nums[i - 2] == nums[i]`, we need to find the most frequent number. Other numbers must be changed.\\n\\nFor this problem, we need to get the top frequent number independently for odd and even numbers. \\n\\nHowever, since the resulting array needs to be alternating, we cannot use the same number. \\n\\nTherefore, in addition to the top frequent number, we need to track the second frequent number. The function below returns the top frequent number (`[0]`), as well as frequency of that number (`[1]`) and frequency of the second frequent number (`[2]`).\\n\\n**C++**\\n```cpp\\narray<int, 3> top2Freq(vector<int>& nums, int start) {\\n    int first = 0, second = 0, cnt[100001] = {};\\n    for (int i = start; i < nums.size(); i += 2)\\n        if (++cnt[nums[i]] >= cnt[first]) {\\n            if (nums[i] != first)\\n                second = first;    \\n            first = nums[i];\\n        }\\n        else if (cnt[nums[i]] > cnt[second])\\n            second = nums[i];\\n    return {first, cnt[first], cnt[second]};\\n}\\nint minimumOperations(vector<int>& nums) {\\n    auto ev = top2Freq(nums, 0), od = top2Freq(nums, 1);\\n    return nums.size() - (ev[0] != od[0] ? ev[1] + od[1] : max(ev[1] + od[2], ev[2] + od[1]));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\narray<int, 3> top2Freq(vector<int>& nums, int start) {\\n    int first = 0, second = 0, cnt[100001] = {};\\n    for (int i = start; i < nums.size(); i += 2)\\n        if (++cnt[nums[i]] >= cnt[first]) {\\n            if (nums[i] != first)\\n                second = first;    \\n            first = nums[i];\\n        }\\n        else if (cnt[nums[i]] > cnt[second])\\n            second = nums[i];\\n    return {first, cnt[first], cnt[second]};\\n}\\nint minimumOperations(vector<int>& nums) {\\n    auto ev = top2Freq(nums, 0), od = top2Freq(nums, 1);\\n    return nums.size() - (ev[0] != od[0] ? ev[1] + od[1] : max(ev[1] + od[2], ev[2] + od[1]));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767018,
                "title": "short-and-clean-java-solution",
                "content": "Thank you for pointing out the corner cases @owenchen0804 and @vrohith2008. I have already fixed them and my idea is the same as @cpu2225. You can check out his solution https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/discuss/1767018/short-and-clean-java-solution/1266143 for more explanations.\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,Integer> odd = new HashMap<>();\\n        Map<Integer, Integer> even = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i%2 == 0) even.put(nums[i],even.getOrDefault(nums[i],0) + 1);\\n            else odd.put(nums[i],odd.getOrDefault(nums[i],0) + 1);\\n        }\\n        int oddKey1 = 0, oddKey2 = 0;\\n        int evenKey1 = 0, evenKey2 = 0;\\n        odd.put(0,0);\\n        even.put(0,0);\\n        for (int key : odd.keySet()) {\\n            if (odd.get(key) > odd.get(oddKey1)) {\\n                oddKey2 = oddKey1;\\n                oddKey1 = key;\\n            } else if (odd.get(key) > odd.get(oddKey2)){\\n                oddKey2 = key;\\n            } \\n        }\\n        \\n        for (int key : even.keySet()) {\\n            if (even.get(key) > even.get(evenKey1)) {\\n                evenKey2 = evenKey1;\\n                evenKey1 = key;\\n            } else if (even.get(key) > even.get(evenKey2)){\\n                evenKey2 = key;\\n            } \\n        }\\n        if (oddKey1 == evenKey1) \\n            return nums.length-Math.max(odd.get(oddKey1)+even.get(evenKey2)\\n                                        , odd.get(oddKey2)+even.get(evenKey1)); \\n        \\n        return nums.length-odd.get(oddKey1)-even.get(evenKey1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,Integer> odd = new HashMap<>();\\n        Map<Integer, Integer> even = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i%2 == 0) even.put(nums[i],even.getOrDefault(nums[i],0) + 1);\\n            else odd.put(nums[i],odd.getOrDefault(nums[i],0) + 1);\\n        }\\n        int oddKey1 = 0, oddKey2 = 0;\\n        int evenKey1 = 0, evenKey2 = 0;\\n        odd.put(0,0);\\n        even.put(0,0);\\n        for (int key : odd.keySet()) {\\n            if (odd.get(key) > odd.get(oddKey1)) {\\n                oddKey2 = oddKey1;\\n                oddKey1 = key;\\n            } else if (odd.get(key) > odd.get(oddKey2)){\\n                oddKey2 = key;\\n            } \\n        }\\n        \\n        for (int key : even.keySet()) {\\n            if (even.get(key) > even.get(evenKey1)) {\\n                evenKey2 = evenKey1;\\n                evenKey1 = key;\\n            } else if (even.get(key) > even.get(evenKey2)){\\n                evenKey2 = key;\\n            } \\n        }\\n        if (oddKey1 == evenKey1) \\n            return nums.length-Math.max(odd.get(oddKey1)+even.get(evenKey2)\\n                                        , odd.get(oddKey2)+even.get(evenKey1)); \\n        \\n        return nums.length-odd.get(oddKey1)-even.get(evenKey1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766909,
                "title": "python3-4-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/2506277d2af78559a0e58d2130fdbe87beab42b5) for solutions of weekly 280. \\n\\nUpdated implementation using `most_common()`\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        pad = lambda x: x + [(None, 0)]*(2-len(x))\\n        even = pad(Counter(nums[::2]).most_common(2))\\n        odd = pad(Counter(nums[1::2]).most_common(2))\\n        return len(nums) - (max(even[0][1] + odd[1][1], even[1][1] + odd[0][1]) if even[0][0] == odd[0][0] else even[0][1] + odd[0][1])\\n```\\n\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd, even = Counter(), Counter()\\n        for i, x in enumerate(nums): \\n            if i&1: odd[x] += 1\\n            else: even[x] += 1\\n        \\n        def fn(freq): \\n            key = None\\n            m0 = m1 = 0\\n            for k, v in freq.items(): \\n                if v > m0: key, m0, m1 = k, v, m0\\n                elif v > m1: m1 = v\\n            return key, m0, m1\\n        \\n        k0, m00, m01 = fn(even)\\n        k1, m10, m11 = fn(odd)\\n        return len(nums) - max(m00 + m11, m01 + m10) if k0 == k1 else len(nums) - m00 - m10\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        pad = lambda x: x + [(None, 0)]*(2-len(x))\\n        even = pad(Counter(nums[::2]).most_common(2))\\n        odd = pad(Counter(nums[1::2]).most_common(2))\\n        return len(nums) - (max(even[0][1] + odd[1][1], even[1][1] + odd[0][1]) if even[0][0] == odd[0][0] else even[0][1] + odd[0][1])\\n```\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd, even = Counter(), Counter()\\n        for i, x in enumerate(nums): \\n            if i&1: odd[x] += 1\\n            else: even[x] += 1\\n        \\n        def fn(freq): \\n            key = None\\n            m0 = m1 = 0\\n            for k, v in freq.items(): \\n                if v > m0: key, m0, m1 = k, v, m0\\n                elif v > m1: m1 = v\\n            return key, m0, m1\\n        \\n        k0, m00, m01 = fn(even)\\n        k1, m10, m11 = fn(odd)\\n        return len(nums) - max(m00 + m11, m01 + m10) if k0 == k1 else len(nums) - m00 - m10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767697,
                "title": "c-freq-table-easy-understanding",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* Make the array with alternate elements with min changes\\n#### \\u2714\\uFE0F **Solution - I (Best Approach)**\\n##### **Intuition :-**\\n* Store the frequencies of odd and even indexes.\\n* Then, keep track of the maximum frequency of elements in the j and k variable.\\n* It will give us how many elements we don\\'t need to change.\\n* In last, just find out how many elements we have to change by subtracting from the total number of elements.\\n##### **Code :-**\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumOperations(vector<int> &nums)\\n    {\\n        int mark[100001][2] = {}, i, j, k, res = 0;\\n        for (i = 0; i < nums.size(); i++)\\n            mark[nums[i]][i & 1]++;\\n        for (i = 1, j = k = 0; i <= 100000; i++)\\n            res = max(res, max(mark[i][0] + k, mark[i][1] + j)), j = max(j, mark[i][0]), k = max(k, mark[i][1]);\\n        return nums.size() - res;\\n    }\\n};\\n```\\n \\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumOperations(vector<int> &nums)\\n    {\\n        int mark[100001][2] = {}, i, j, k, res = 0;\\n        for (i = 0; i < nums.size(); i++)\\n            mark[nums[i]][i & 1]++;\\n        for (i = 1, j = k = 0; i <= 100000; i++)\\n            res = max(res, max(mark[i][0] + k, mark[i][1] + j)), j = max(j, mark[i][0]), k = max(k, mark[i][1]);\\n        return nums.size() - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767132,
                "title": "python-3-hashmap-solution-o-n-no-sort-needed",
                "content": "Key implementation step:\\n* Create two hashmaps to count the frequencies of num with odd and even indices, respectively;\\n* Search for the `num` in each hashmap with the maximum and second maximum frequencies:\\n\\t* If the two `num`\\'s with the maximum frequencies are not equal, then return `len(nums) - (maxFreqOdd + maxFreqEven)`;\\n\\t* Otherwise return `len(nums) - max(maxFreqOdd + secondMaxFreqEven, maxFreqEven + secondMaxFreqOdd)`.\\n\\nOne thing to note in step 2 is that after getting the two hashmaps for odd and even indices, we **don\\'t** need to sort the hashmap keys based on their values or using heaps, but only need to write a subroutine by scanning through all `num`\\'s in the hashmap, so the overall time complexity is `O(N)` instead of `O(NlogN)`.\\n\\nBelow is my in-contest solution, though I could have made it a bit neater. Please upvote if you find this solution helpful.\\n\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        odd, even = defaultdict(int), defaultdict(int)\\n        for i in range(n):\\n            if i % 2 == 0:\\n                even[nums[i]] += 1\\n            else:\\n                odd[nums[i]] += 1\\n        topEven, secondEven = (None, 0), (None, 0)\\n        for num in even:\\n            if even[num] > topEven[1]:\\n                topEven, secondEven = (num, even[num]), topEven\\n            elif even[num] > secondEven[1]:\\n                secondEven = (num, even[num])\\n        topOdd, secondOdd = (None, 0), (None, 0)\\n        for num in odd:\\n            if odd[num] > topOdd[1]:\\n                topOdd, secondOdd = (num, odd[num]), topOdd\\n            elif odd[num] > secondOdd[1]:\\n                secondOdd = (num, odd[num])\\n        if topOdd[0] != topEven[0]:\\n            return n - topOdd[1] - topEven[1]\\n        else:\\n            return n - max(secondOdd[1] + topEven[1], secondEven[1] + topOdd[1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        odd, even = defaultdict(int), defaultdict(int)\\n        for i in range(n):\\n            if i % 2 == 0:\\n                even[nums[i]] += 1\\n            else:\\n                odd[nums[i]] += 1\\n        topEven, secondEven = (None, 0), (None, 0)\\n        for num in even:\\n            if even[num] > topEven[1]:\\n                topEven, secondEven = (num, even[num]), topEven\\n            elif even[num] > secondEven[1]:\\n                secondEven = (num, even[num])\\n        topOdd, secondOdd = (None, 0), (None, 0)\\n        for num in odd:\\n            if odd[num] > topOdd[1]:\\n                topOdd, secondOdd = (num, odd[num]), topOdd\\n            elif odd[num] > secondOdd[1]:\\n                secondOdd = (num, odd[num])\\n        if topOdd[0] != topEven[0]:\\n            return n - topOdd[1] - topEven[1]\\n        else:\\n            return n - max(secondOdd[1] + topEven[1], secondEven[1] + topOdd[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767491,
                "title": "100-faster-o-max-element-with-full-explanation-removals-places-frequency-element",
                "content": "![image](https://assets.leetcode.com/users/images/c1aaf35d-102b-47f0-9637-42c709d49a77_1644741165.0047586.png)\\n\\n\\n\\n**Indirect statement of the question**:\\n\\nAll odd indices elements should be equal  i.e any value `p`.\\nAll even indices elements should be equal i.e any value `q`.\\nBut p!=q\\n\\nFor eg -> [1,2,1,2,1]\\nElement at even indexes = 1\\nElement at odd indexes = 2\\n1!=2. {This is what we want}.\\n\\nIt means we have to put single value on all even and odd seperately.\\n\\n**Question arises**: We are now clear that we have to place single elment but Which element we pick such that number of replace operation is minimum.\\n\\n**The observation here that I notices is that** :\\n\\nNumber of operation is inversly proportional to frequency of any single element.\\n\\nThe Formula that I discovered:\\n```\\nOperation =  Total places - Frequency of any single element.{Single element because all element should be equal, we will consider single only}.\\n```\\n\\nThe above equation clearly signifies that the number of removals will be minimum if:\\nWe place the most occuring element on even and odd indices individually.\\n\\n**There is a Catch** :\\nThe `most occuring on even and odd indices may be equal`, `which will be against rule of question`.\\nSomething like this -> [1,1,1,1,1]\\n\\n**Now how we will get our answer now**:\\n\\n# The second minimum removal operation will be required for replacing all indices with second most frequent element.\\n\\nTry to think deeply.\\n\\nLet me explain.\\n\\nLets Suppose:\\n`Most occuring element among even indices elements` = e1\\n`Second most frequency element among even index elements`  = e2 \\n`Most occuring element among odd indices elements`  = o1\\n`Second most frequent element among odd indexes elements` = o2\\n\\nRemember {most frequent can\\'t be equal to second most frequent}:\\n  ` e1!=e2 and o1!=o2`.\\n   \\n   If(e1==o1) , then `e1!=o2 and e2!=o1`. \\n\\nThere are two possibility only:\\n1. We replace all the even indices with Second Most Frequent i.e `e2`  and Most frequent element i.e `o1` on odd indices.\\n2. We replace all the even indices with  Most Frequent i.e `e1`  and Second Most frequent element i.e `o2` on odd indices.\\n\\nBy considering the above cases we are only putting unequal element.\\n\\nJust return minimum of both operations.\\n\\nSolution is a bit complicated because this problem is itself having so many edge cases.\\n\\nGo through solution line by line with pen and paper.\\n\\n# C++\\n   \\n    class Solution {\\n    public:\\n    \\n    //get top 2 most frequent along with their values pairs\\n    pair<pair<int,int>,pair<int,int>> get(vector<pair<int,int>> &nums){\\n        pair<int,int> p, q;\\n       \\n        for(auto i:nums){\\n            if(p.first<i.first) q=p, p=i;\\n            else if(q.first<i.first and i!=p) q=i;\\n        }\\n        return {p,q};\\n    }\\n\\n    int minimumOperations(vector<int>& nums) {\\n        int n= size(nums);\\n\\t\\t//count of even and odd places\\n        int p_e=0,p_o=0;\\n\\t\\t\\n\\t\\tint mx= *max_element(begin(nums),end(nums));\\n\\t\\t\\n\\t\\t//vector of pairs representing {count, element value}\\n        vector<pair<int,int>> even(mx+1),odd(mx+1);\\n\\t\\t\\n\\t\\tint k=0;\\n\\t\\t\\n        //get count of all elements along with their count\\n        for(auto i:nums){\\n            //even index\\n            if(k%2==0){\\n               even[i].first++, even[i].second=i, p_e++; \\n            }\\n            else{\\n               odd[i].first++, odd[i].second=i, p_o++; \\n            }\\n\\t\\t\\tk++;\\n        }\\n        \\n        //get the count and element of 1st and 2nd most frequency among odd and even indices individually.\\n        auto p= get(odd);\\n        auto q= get(even);\\n\\t\\t\\n\\t\\t//now return return as expailned in above explanation...\\n\\t\\t\\n\\t\\t//if most frequent on even and odd indices are not equal just use formula told in above explanation..\\n        if(q.first.second!=p.first.second) return (p_e- q.first.first)+(p_o-p.first.first);\\n        \\n\\t\\t//If both most frequent are equal, return most frequent with second most frequent\\n        int x= (p_e-q.first.first) + (p_o-p.second.first);\\n        int y= (p_e-q.second.first) + (p_o-p.first.first);\\n        \\n        return min(x,y);\\n    }\\n    };\\n\\n**Time** - O(N)\\n**Space** - O(Value of maximum element)\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nOperation =  Total places - Frequency of any single element.{Single element because all element should be equal, we will consider single only}.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766992,
                "title": "c-track-the-most-frequent-numbers-in-even-and-odd-indices",
                "content": "According to the problem statement, the array nums is called alternating if:\\nnums[i - 2] == nums[i], where 2 <= i <= n - 1.\\nnums[i - 1] != nums[i], where 1 <= i <= n - 1.\\nwhich basically means that we need to create an array of this pattern [x,y,x,y,x...] in minimum number of operations.\\n\\nSo, for this we will iterate through the array and keep a track of the frequencies of elements at even and odd indices separately. Then we will find the element which has the highest frequency at even positions and the one at odd positions. If both are equal then we need to check the next element with higher frequency.\\n\\n```\\nclass Solution {\\n    static bool cmp(pair<int, int>& a, pair<int, int>& b)\\n    {\\n        return a.second > b.second;\\n    }\\n    \\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> even, odd;\\n        int n = nums.size(), ans = 0;\\n        \\n        //Base cases\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n        {\\n            if(nums[0] == nums[1])\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        //iterating over nums to get frequency of elements\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i%2==0)\\n                even[nums[i]]++;\\n            else\\n                odd[nums[i]]++;\\n        }\\n      \\n        vector<pair<int, int>> A, B;\\n        for (auto& it : even)\\n            A.push_back(it);\\n        for (auto& it : odd)\\n            B.push_back(it);\\n        \\n        //sorting in descending order to get elements with higher frequency first\\n        sort(A.begin(), A.end(), cmp);\\n        sort(B.begin(), B.end(), cmp);\\n        \\n        if(B.empty()) \\n            return 0;\\n        \\n        if(A[0].first != B[0].first) \\n            return n - A[0].second - B[0].second;\\n        else {\\n            int odd1 = B[0].second;\\n            int odd2 = B.size() == 1 ? 0 : B[1].second;\\n            int even1 = A[0].second;\\n            int even2 = A.size() == 1 ? 0 : A[1].second;\\n            \\n            return n - max(odd1 + even2, odd2 + even1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(pair<int, int>& a, pair<int, int>& b)\\n    {\\n        return a.second > b.second;\\n    }\\n    \\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> even, odd;\\n        int n = nums.size(), ans = 0;\\n        \\n        //Base cases\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n        {\\n            if(nums[0] == nums[1])\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        //iterating over nums to get frequency of elements\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i%2==0)\\n                even[nums[i]]++;\\n            else\\n                odd[nums[i]]++;\\n        }\\n      \\n        vector<pair<int, int>> A, B;\\n        for (auto& it : even)\\n            A.push_back(it);\\n        for (auto& it : odd)\\n            B.push_back(it);\\n        \\n        //sorting in descending order to get elements with higher frequency first\\n        sort(A.begin(), A.end(), cmp);\\n        sort(B.begin(), B.end(), cmp);\\n        \\n        if(B.empty()) \\n            return 0;\\n        \\n        if(A[0].first != B[0].first) \\n            return n - A[0].second - B[0].second;\\n        else {\\n            int odd1 = B[0].second;\\n            int odd2 = B.size() == 1 ? 0 : B[1].second;\\n            int even1 = A[0].second;\\n            int even2 = A.size() == 1 ? 0 : A[1].second;\\n            \\n            return n - max(odd1 + even2, odd2 + even1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766960,
                "title": "priority-queue-and-hashmap-approach-explained-c",
                "content": "APPROACH: Use hashmap to store frequency of elemets appearing at odd and even indexes separately,then    using max heap to get element with highest frequency for both even and odd indexes .in order to get minimum operation we will not change elements with max frequency so we will delete their count from total elements given.thanks @jason0704 for suggesting edits.\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()<=1) return 0;\\n        unordered_map<int,int> m_even;\\n        unordered_map<int,int> m_odd;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) m_even[nums[i]]++;\\n            else m_odd[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>>maxh_even;\\n        priority_queue<pair<int,int>>maxh_odd;\\n        for(auto x:m_even){\\n            maxh_even.push({x.second,x.first});\\n        }\\n        for(auto x:m_odd){\\n            maxh_odd.push({x.second,x.first});\\n        }\\n        if(maxh_even.top().second!=maxh_odd.top().second){\\n            return n-maxh_even.top().first-maxh_odd.top().first;\\n        }\\n        else{\\n               int max1 = maxh_even.top().first;\\n               int max2 = maxh_odd.top().first;\\n               maxh_even.pop(); maxh_odd.pop();\\n              int second1 = (maxh_even.empty()) ? 0 : maxh_even.top().first;\\n             int second2 = (maxh_odd.empty()) ? 0 : maxh_odd.top().first;\\n             return n - max(max1 + second2, max2 + second1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()<=1) return 0;\\n        unordered_map<int,int> m_even;\\n        unordered_map<int,int> m_odd;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i%2==0) m_even[nums[i]]++;\\n            else m_odd[nums[i]]++;\\n        }\\n        priority_queue<pair<int,int>>maxh_even;\\n        priority_queue<pair<int,int>>maxh_odd;\\n        for(auto x:m_even){\\n            maxh_even.push({x.second,x.first});\\n        }\\n        for(auto x:m_odd){\\n            maxh_odd.push({x.second,x.first});\\n        }\\n        if(maxh_even.top().second!=maxh_odd.top().second){\\n            return n-maxh_even.top().first-maxh_odd.top().first;\\n        }\\n        else{\\n               int max1 = maxh_even.top().first;\\n               int max2 = maxh_odd.top().first;\\n               maxh_even.pop(); maxh_odd.pop();\\n              int second1 = (maxh_even.empty()) ? 0 : maxh_even.top().first;\\n             int second2 = (maxh_odd.empty()) ? 0 : maxh_odd.top().first;\\n             return n - max(max1 + second2, max2 + second1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767085,
                "title": "java-find-max-second-max-approach-explained",
                "content": "**Approach:**\\nKeep separate count array for both even & odd indices elements.\\nFind max & second max candidates for both even & odd.\\n\\nSince *arr[i] != arr[i + 1]* so we need to take care that max candidate element should not be same for both odd & even.\\nIf it is same, then we need to use either second max for odd or even whichever gives minimum result.\\n\\n**Code:**\\n```\\npublic int minimumOperations(int[] nums) {\\n        // make count for even & odd indices elements\\n        int[] count1 = new int[100001];\\n        int[] count2 = new int[100001];\\n        \\n        int n = nums.length;\\n        for (int i = 0; i < n; i += 2) {\\n            ++count1[nums[i]];\\n            if (i + 1 < n) {\\n                ++count2[nums[i + 1]];\\n            }\\n        }\\n        \\n        // find max & second max for both odd & even , store along with candidate element\\n        int[] even = new int[4];\\n        int[] odd = new int[4];\\n        for (int i = 1; i < 100001; ++i) {\\n            int c = count1[i];\\n            if (even[0] < c) {\\n                even[2] = even[0];\\n                even[3] = even[1];\\n                \\n                even[0] = c;\\n                even[1] = i;\\n            } else if (even[2] < c) {\\n                even[2] = c;\\n                even[3] = i;\\n            }\\n            \\n            c = count2[i];\\n            if (odd[0] < c) {\\n                odd[2] = odd[0];\\n                odd[3] = odd[1];\\n\\n                odd[0] = c;\\n                odd[1] = i;\\n            } else if (odd[2] < c) {\\n                odd[2] = c;\\n                odd[3] = i;\\n            }\\n        }\\n        \\n        // if max candidate for odd & even is different, can use them.\\n        if (odd[1] != even[1]) {\\n            return n - odd[0] - even[0];\\n        }\\n        // else take either of second max for odd or even.\\n        return Math.min(n - odd[0] - even[2], n - odd[2] - even[0]);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumOperations(int[] nums) {\\n        // make count for even & odd indices elements\\n        int[] count1 = new int[100001];\\n        int[] count2 = new int[100001];\\n        \\n        int n = nums.length;\\n        for (int i = 0; i < n; i += 2) {\\n            ++count1[nums[i]];\\n            if (i + 1 < n) {\\n                ++count2[nums[i + 1]];\\n            }\\n        }\\n        \\n        // find max & second max for both odd & even , store along with candidate element\\n        int[] even = new int[4];\\n        int[] odd = new int[4];\\n        for (int i = 1; i < 100001; ++i) {\\n            int c = count1[i];\\n            if (even[0] < c) {\\n                even[2] = even[0];\\n                even[3] = even[1];\\n                \\n                even[0] = c;\\n                even[1] = i;\\n            } else if (even[2] < c) {\\n                even[2] = c;\\n                even[3] = i;\\n            }\\n            \\n            c = count2[i];\\n            if (odd[0] < c) {\\n                odd[2] = odd[0];\\n                odd[3] = odd[1];\\n\\n                odd[0] = c;\\n                odd[1] = i;\\n            } else if (odd[2] < c) {\\n                odd[2] = c;\\n                odd[3] = i;\\n            }\\n        }\\n        \\n        // if max candidate for odd & even is different, can use them.\\n        if (odd[1] != even[1]) {\\n            return n - odd[0] - even[0];\\n        }\\n        // else take either of second max for odd or even.\\n        return Math.min(n - odd[0] - even[2], n - odd[2] - even[0]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401747,
                "title": "python-2-lines",
                "content": "Use `Counter.most_common` to get top 2 frequent numbers.\\nUse `product` to iterate all cases from odd/even side to find maximum.\\nSecure there are different number from odd/even side by adding `[0,0]`.\\n\\n```\\nclass Solution:\\n  def minimumOperations(self, A: List[int]) -> int:\\n    e,o = [list(Counter(A[i::2]).most_common(2)) + [[0,0]] for i in range(2)]\\n    return len(A) - max(a[1]+b[1] for a,b in product(e,o) if a[0]!=b[0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def minimumOperations(self, A: List[int]) -> int:\\n    e,o = [list(Counter(A[i::2]).most_common(2)) + [[0,0]] for i in range(2)]\\n    return len(A) - max(a[1]+b[1] for a,b in product(e,o) if a[0]!=b[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487227,
                "title": "greedy-approach-hashing-frequency-count-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>even,odd;\\n         odd[0]=0,even[0]=0;\\n int oddlen=0,evenlen=0,n=nums.size(),firstodd=0,secondodd=0,firsteven=0,secondeven=0,firstoddcount=0,secondoddcount=0,firstevencount=0,secondevencount=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2)\\n            {\\n                oddlen++;\\n                odd[nums[i]]++;\\n            }\\n            else\\n            {\\n                evenlen++;\\n                even[nums[i]]++;\\n            }\\n        }\\n        for(auto i:odd)\\n        {\\n            if(i.second>=firstoddcount)\\n            {\\n                secondoddcount=firstoddcount;\\n                secondodd=firstodd;\\n                firstodd=i.first;\\n                firstoddcount=i.second;\\n            }\\n            else if(i.second>secondoddcount)\\n            {\\n                 secondoddcount=i.second;\\n                 secondodd=i.first;\\n            }\\n        }\\n         for(auto i:even)\\n        {\\n            if(i.second>=firstevencount)\\n            {\\n                secondevencount=firstevencount;\\n                secondeven=firsteven;\\n                firsteven=i.first;\\n                firstevencount=i.second;\\n            }\\n            else if(i.second>secondevencount)\\n            {\\n                 secondevencount=i.second;\\n                 secondeven=i.first;\\n            }\\n        }\\n        int operations=1e9;\\n if(firsteven!=firstodd) operations=evenlen-firstevencount+oddlen-firstoddcount;\\n return min(operations,min(evenlen-secondevencount+oddlen-firstoddcount,evenlen-firstevencount+oddlen-secondoddcount));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>even,odd;\\n         odd[0]=0,even[0]=0;\\n int oddlen=0,evenlen=0,n=nums.size(),firstodd=0,secondodd=0,firsteven=0,secondeven=0,firstoddcount=0,secondoddcount=0,firstevencount=0,secondevencount=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2)\\n            {\\n                oddlen++;\\n                odd[nums[i]]++;\\n            }\\n            else\\n            {\\n                evenlen++;\\n                even[nums[i]]++;\\n            }\\n        }\\n        for(auto i:odd)\\n        {\\n            if(i.second>=firstoddcount)\\n            {\\n                secondoddcount=firstoddcount;\\n                secondodd=firstodd;\\n                firstodd=i.first;\\n                firstoddcount=i.second;\\n            }\\n            else if(i.second>secondoddcount)\\n            {\\n                 secondoddcount=i.second;\\n                 secondodd=i.first;\\n            }\\n        }\\n         for(auto i:even)\\n        {\\n            if(i.second>=firstevencount)\\n            {\\n                secondevencount=firstevencount;\\n                secondeven=firsteven;\\n                firsteven=i.first;\\n                firstevencount=i.second;\\n            }\\n            else if(i.second>secondevencount)\\n            {\\n                 secondevencount=i.second;\\n                 secondeven=i.first;\\n            }\\n        }\\n        int operations=1e9;\\n if(firsteven!=firstodd) operations=evenlen-firstevencount+oddlen-firstoddcount;\\n return min(operations,min(evenlen-secondevencount+oddlen-firstoddcount,evenlen-firstevencount+oddlen-secondoddcount));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878583,
                "title": "c-solution-90-faster-unordered-map-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> mpEven, mpOdd;\\n\\t\\t\\n\\t\\t// Finding Frequency of EVEN index elements\\n        for(int i=0; i<nums.size(); i+=2)\\n            mpEven[nums[i]]++;\\n        \\n\\t\\t// Finding Frequency of ODD index elements\\n        for(int i=1; i<nums.size(); i+=2)\\n            mpOdd[nums[i]]++;\\n        \\n        int eveFristMax = 0, eveSecondMax = 0;\\n        int eveFirstFreq = 0, eveSecondFreq = 0;\\n        \\n        auto it = mpEven.begin();\\n\\t\\t\\n\\t\\t// Finding frequency of first most and second most occurring number in even position elements\\n        while(it != mpEven.end()) {\\n            if(it->second >= eveFirstFreq) {\\n                eveSecondMax = eveFristMax;\\n                eveSecondFreq = eveFirstFreq;\\n                \\n                eveFristMax = it->first;\\n                eveFirstFreq = it->second;\\n            }\\n            \\n            else if(it->second > eveSecondFreq) {\\n                eveSecondMax = it->first;\\n                eveSecondFreq = it->second;\\n            }\\n            it++;\\n        }\\n        \\n        int oddFristMax = 0, oddSecondMax = 0;\\n        int oddFirstFreq = 0, oddSecondFreq = 0;\\n        \\n        it = mpOdd.begin();\\n\\t\\t\\n\\t\\t//Finding frequency of first most and second most occurring number in odd position elements\\n        while(it != mpOdd.end()) {\\n            if(it->second >= oddFirstFreq) {\\n                oddSecondMax = oddFristMax;\\n                oddSecondFreq = oddFirstFreq;\\n                \\n                oddFristMax = it->first;\\n                oddFirstFreq = it->second;\\n            }\\n            \\n            else if(it->second > oddSecondFreq) {\\n                oddSecondMax = it->first;\\n                oddSecondFreq = it->second;\\n            }\\n            it++;\\n        }\\n        // When Max Frequncy element at even and odd index are not equal\\n        if(eveFristMax != oddFristMax)\\n            return nums.size() - eveFirstFreq - oddFirstFreq;\\n\\t\\t\\t\\n        else     // When Max Frequncy element at even and odd index are equal\\n            return min(nums.size() - eveFirstFreq - oddSecondFreq, nums.size() - oddFirstFreq - eveSecondFreq);\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> mpEven, mpOdd;\\n\\t\\t\\n\\t\\t// Finding Frequency of EVEN index elements\\n        for(int i=0; i<nums.size(); i+=2)\\n            mpEven[nums[i]]++;\\n        \\n\\t\\t// Finding Frequency of ODD index elements\\n        for(int i=1; i<nums.size(); i+=2)\\n            mpOdd[nums[i]]++;\\n        \\n        int eveFristMax = 0, eveSecondMax = 0;\\n        int eveFirstFreq = 0, eveSecondFreq = 0;\\n        \\n        auto it = mpEven.begin();\\n\\t\\t\\n\\t\\t// Finding frequency of first most and second most occurring number in even position elements\\n        while(it != mpEven.end()) {\\n            if(it->second >= eveFirstFreq) {\\n                eveSecondMax = eveFristMax;\\n                eveSecondFreq = eveFirstFreq;\\n                \\n                eveFristMax = it->first;\\n                eveFirstFreq = it->second;\\n            }\\n            \\n            else if(it->second > eveSecondFreq) {\\n                eveSecondMax = it->first;\\n                eveSecondFreq = it->second;\\n            }\\n            it++;\\n        }\\n        \\n        int oddFristMax = 0, oddSecondMax = 0;\\n        int oddFirstFreq = 0, oddSecondFreq = 0;\\n        \\n        it = mpOdd.begin();\\n\\t\\t\\n\\t\\t//Finding frequency of first most and second most occurring number in odd position elements\\n        while(it != mpOdd.end()) {\\n            if(it->second >= oddFirstFreq) {\\n                oddSecondMax = oddFristMax;\\n                oddSecondFreq = oddFirstFreq;\\n                \\n                oddFristMax = it->first;\\n                oddFirstFreq = it->second;\\n            }\\n            \\n            else if(it->second > oddSecondFreq) {\\n                oddSecondMax = it->first;\\n                oddSecondFreq = it->second;\\n            }\\n            it++;\\n        }\\n        // When Max Frequncy element at even and odd index are not equal\\n        if(eveFristMax != oddFristMax)\\n            return nums.size() - eveFirstFreq - oddFirstFreq;\\n\\t\\t\\t\\n        else     // When Max Frequncy element at even and odd index are equal\\n            return min(nums.size() - eveFirstFreq - oddSecondFreq, nums.size() - oddFirstFreq - eveSecondFreq);\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780125,
                "title": "c-hashmap-tc-o-n-sc-o-n-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n\\n        unordered_map<int,int> mp1,mp2;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++)  {\\n            if(i%2==0) mp1[nums[i]]++;\\n            else mp2[nums[i]]++;\\n        }\\n        \\n        // 4 max with their frequency\\n        vector<int> even_max1(2,0);\\n        vector<int> odd_max1(2,0);\\n        vector<int> even_max2(2,0);\\n        vector<int> odd_max2(2,0);\\n        \\n        // odd map even map mei se max 2 elements storing \\n        for (auto i: mp1)   if(even_max1[1]<=i.second) { even_max1={i.first, i.second}; }\\n        mp1[even_max1[0]]=0;\\n        for (auto i: mp1)   if(even_max2[1]<=i.second) { even_max2[0]=i.first; even_max2[1]=i.second; }\\n        \\n        for (auto i: mp2)   if(odd_max1[1]<=i.second) { odd_max1={i.first, i.second}; }\\n        mp2[odd_max1[0]]=0;\\n        for (auto i: mp2)   if(odd_max2[1]<=i.second) { odd_max2[0]=i.first; odd_max2[1]=i.second; }   \\n        \\n        //cout<<even_max1[1] << \" \" << even_max2[1] << endl;\\n        //cout<<odd_max1[1] << \" \" << odd_max2[1] << endl;\\n        \\n        if(even_max1[0]==odd_max1[0])  return n-max(even_max1[1]+odd_max2[1],even_max2[1]+odd_max1[1]);\\n        return n-even_max1[1]-odd_max1[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n\\n        unordered_map<int,int> mp1,mp2;\\n        int n=nums.size();\\n        \\n        for(int i=0; i<n; i++)  {\\n            if(i%2==0) mp1[nums[i]]++;\\n            else mp2[nums[i]]++;\\n        }\\n        \\n        // 4 max with their frequency\\n        vector<int> even_max1(2,0);\\n        vector<int> odd_max1(2,0);\\n        vector<int> even_max2(2,0);\\n        vector<int> odd_max2(2,0);\\n        \\n        // odd map even map mei se max 2 elements storing \\n        for (auto i: mp1)   if(even_max1[1]<=i.second) { even_max1={i.first, i.second}; }\\n        mp1[even_max1[0]]=0;\\n        for (auto i: mp1)   if(even_max2[1]<=i.second) { even_max2[0]=i.first; even_max2[1]=i.second; }\\n        \\n        for (auto i: mp2)   if(odd_max1[1]<=i.second) { odd_max1={i.first, i.second}; }\\n        mp2[odd_max1[0]]=0;\\n        for (auto i: mp2)   if(odd_max2[1]<=i.second) { odd_max2[0]=i.first; odd_max2[1]=i.second; }   \\n        \\n        //cout<<even_max1[1] << \" \" << even_max2[1] << endl;\\n        //cout<<odd_max1[1] << \" \" << odd_max2[1] << endl;\\n        \\n        if(even_max1[0]==odd_max1[0])  return n-max(even_max1[1]+odd_max2[1],even_max2[1]+odd_max1[1]);\\n        return n-even_max1[1]-odd_max1[1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1767912,
                "title": "python-freq-table-easy-to-understand",
                "content": "In this question we are suppose to find minimum number of removal to make array alternating .\\nwhich also means len(arr)- max nummber of element that we are not suppose to move .\\n```\\n\\t\\todd=defaultdict(int) #frequency table to count frequency of odd elements in array \\n        even=defaultdict(int) #frequency table to count frequency of even elements in array \\n        for i in range(len(nums)):\\n            if i%2:\\n                even[nums[i]]+=1\\n            else:\\n                odd[nums[i]]+=1\\n        even[-1]=0      #just in case there is only one element in even to avoid index out of range in last line of code \\n        odd[-2]=0\\n        a=sorted([(odd[i],i) for i in odd],reverse=True)\\n        b=sorted([(even[i],i) for i in even],reverse=True)#sorting to get element with max freq a[0][0] represents element with most frequency and a[0][1] is the element\\n        if a[0][1]!=b[0][1]:    #according to given condition even and odd should be different \\n            return len(nums)-a[0][0]-b[0][0]    \\n        return len(nums)-max(a[0][0]+b[1][0],a[1][0]+b[0][0])# else taking second element with max freq from odd and even to calculate min  \\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\todd=defaultdict(int) #frequency table to count frequency of odd elements in array \\n        even=defaultdict(int) #frequency table to count frequency of even elements in array \\n        for i in range(len(nums)):\\n            if i%2:\\n                even[nums[i]]+=1\\n            else:\\n                odd[nums[i]]+=1\\n        even[-1]=0      #just in case there is only one element in even to avoid index out of range in last line of code \\n        odd[-2]=0\\n        a=sorted([(odd[i],i) for i in odd],reverse=True)\\n        b=sorted([(even[i],i) for i in even],reverse=True)#sorting to get element with max freq a[0][0] represents element with most frequency and a[0][1] is the element\\n        if a[0][1]!=b[0][1]:    #according to given condition even and odd should be different \\n            return len(nums)-a[0][0]-b[0][0]    \\n        return len(nums)-max(a[0][0]+b[1][0],a[1][0]+b[0][0])# else taking second element with max freq from odd and even to calculate min  \\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1767012,
                "title": "c-naive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int> even;\\n        int even_max_freq=0,even_max_element=0,even_sec_max_freq=0,even_sec_max_element=0;\\n        //Largest and SecondLargest Frequency element at even index\\n        for(int i=0;i<n;i=i+2){\\n            even[nums[i]]++;\\n            if(even[nums[i]]>even_max_freq){\\n                even_max_element=nums[i];\\n                even_max_freq=even[nums[i]];\\n            }\\n            else if(even[nums[i]]<=even_max_freq && nums[i]!=even_max_element && even_sec_max_freq<even[nums[i]]){\\n                even_sec_max_element=nums[i];\\n                even_sec_max_freq=even[nums[i]];\\n            }\\n        }\\n        unordered_map<int,int> odd;\\n        int odd_max_freq=0,odd_max_element=0,odd_sec_max_freq=0,odd_sec_max_element=0;\\n        //Largest and SecondLargest Frequency element at odd index\\n        for(int i=1;i<n;i=i+2){\\n         odd[nums[i]]++;\\n            if(odd[nums[i]]>odd_max_freq){\\n             odd_max_element=nums[i];\\n             odd_max_freq=odd[nums[i]];\\n            }\\n            else if(odd[nums[i]]<=odd_max_freq && nums[i]!=odd_max_element && odd_sec_max_freq<odd[nums[i]]){\\n                odd_sec_max_element=nums[i];\\n                odd_sec_max_freq=odd[nums[i]];\\n            }\\n        } \\n        if(even_max_element!=odd_max_element){\\n            return n-even_max_freq-odd_max_freq;\\n        }\\n        else{\\n          return  min(n-odd_max_freq-even_sec_max_freq,n-even_max_freq-odd_sec_max_freq);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        unordered_map<int,int> even;\\n        int even_max_freq=0,even_max_element=0,even_sec_max_freq=0,even_sec_max_element=0;\\n        //Largest and SecondLargest Frequency element at even index\\n        for(int i=0;i<n;i=i+2){\\n            even[nums[i]]++;\\n            if(even[nums[i]]>even_max_freq){\\n                even_max_element=nums[i];\\n                even_max_freq=even[nums[i]];\\n            }\\n            else if(even[nums[i]]<=even_max_freq && nums[i]!=even_max_element && even_sec_max_freq<even[nums[i]]){\\n                even_sec_max_element=nums[i];\\n                even_sec_max_freq=even[nums[i]];\\n            }\\n        }\\n        unordered_map<int,int> odd;\\n        int odd_max_freq=0,odd_max_element=0,odd_sec_max_freq=0,odd_sec_max_element=0;\\n        //Largest and SecondLargest Frequency element at odd index\\n        for(int i=1;i<n;i=i+2){\\n         odd[nums[i]]++;\\n            if(odd[nums[i]]>odd_max_freq){\\n             odd_max_element=nums[i];\\n             odd_max_freq=odd[nums[i]];\\n            }\\n            else if(odd[nums[i]]<=odd_max_freq && nums[i]!=odd_max_element && odd_sec_max_freq<odd[nums[i]]){\\n                odd_sec_max_element=nums[i];\\n                odd_sec_max_freq=odd[nums[i]];\\n            }\\n        } \\n        if(even_max_element!=odd_max_element){\\n            return n-even_max_freq-odd_max_freq;\\n        }\\n        else{\\n          return  min(n-odd_max_freq-even_sec_max_freq,n-even_max_freq-odd_sec_max_freq);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766880,
                "title": "first-max-and-second-max-c-maxheap-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& arr) {\\n        int ans=0;\\n        int i=0,n=arr.size();\\n        if(n == 1) return 0;\\n        unordered_map<int,int> mp1,mp2;\\n        priority_queue<pair<int,int>> pq1,pq2;\\n        \\n        while(i < n){\\n            if(i % 2 == 0) mp1[arr[i]]++;\\n            \\n            else mp2[arr[i]]++;\\n            \\n            i++;\\n        }\\n        \\n        int odd,even;\\n        \\n        if(n%2) even = n/2 + 1,odd = n/2;\\n        else even = n/2,odd = n/2;\\n        \\n        for(auto it : mp1) pq1.push({it.second,it.first});\\n        \\n        for(auto it : mp2) pq2.push({it.second,it.first});\\n        \\n        auto t1 = pq1.top(); pq1.pop();\\n        auto t2 = pq2.top(); pq2.pop();\\n            \\n        if(t1.second == t2.second){\\n            int op1 = (even - t1.first);\\n            if(!pq2.empty()){\\n                op1 += (odd - pq2.top().first);\\n            }else{\\n                op1 += odd;\\n            }\\n                \\n            int op2 = (odd - t2.first);\\n            if(!pq1.empty()){\\n                op2 += (even - pq1.top().first);\\n            }else{\\n                op2 += even;\\n            } \\n                \\n            ans = min(op1,op2);\\n        }else{\\n            ans += (even - t1.first) + (odd - t2.first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& arr) {\\n        int ans=0;\\n        int i=0,n=arr.size();\\n        if(n == 1) return 0;\\n        unordered_map<int,int> mp1,mp2;\\n        priority_queue<pair<int,int>> pq1,pq2;\\n        \\n        while(i < n){\\n            if(i % 2 == 0) mp1[arr[i]]++;\\n            \\n            else mp2[arr[i]]++;\\n            \\n            i++;\\n        }\\n        \\n        int odd,even;\\n        \\n        if(n%2) even = n/2 + 1,odd = n/2;\\n        else even = n/2,odd = n/2;\\n        \\n        for(auto it : mp1) pq1.push({it.second,it.first});\\n        \\n        for(auto it : mp2) pq2.push({it.second,it.first});\\n        \\n        auto t1 = pq1.top(); pq1.pop();\\n        auto t2 = pq2.top(); pq2.pop();\\n            \\n        if(t1.second == t2.second){\\n            int op1 = (even - t1.first);\\n            if(!pq2.empty()){\\n                op1 += (odd - pq2.top().first);\\n            }else{\\n                op1 += odd;\\n            }\\n                \\n            int op2 = (odd - t2.first);\\n            if(!pq1.empty()){\\n                op2 += (even - pq1.top().first);\\n            }else{\\n                op2 += even;\\n            } \\n                \\n            ans = min(op1,op2);\\n        }else{\\n            ans += (even - t1.first) + (odd - t2.first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209439,
                "title": "c-o-n-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size(), maxEven, maxOdd, maxe1, maxe2, maxo1, maxo2;\\n        maxe1=maxe2=maxo1=maxo2=0;\\n        unordered_map<int,int> freqEven, freqOdd;\\n        for(int i=0; i<n; i++) {\\n            if(i&1) {\\n                freqOdd[nums[i]]++;\\n                if(maxo1<freqOdd[nums[i]]) {\\n                    if(maxOdd!=nums[i]) maxo2=maxo1;\\n                    maxo1=freqOdd[nums[i]];\\n                    maxOdd=nums[i];\\n                }\\n                else if(maxo2<freqOdd[nums[i]]) maxo2=freqOdd[nums[i]];\\n            }\\n            else {\\n                freqEven[nums[i]]++;\\n                if(maxe1<freqEven[nums[i]]) {\\n                    if(maxEven!=nums[i]) maxe2=maxe1;\\n                    maxe1=freqEven[nums[i]];\\n                    maxEven=nums[i];\\n                }\\n                else if(maxe2<freqEven[nums[i]]) maxe2=freqEven[nums[i]];\\n            }\\n        }\\n        return maxOdd!=maxEven?n-maxo1-maxe1:min(n-maxo1-maxe2,n-maxe1-maxo2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size(), maxEven, maxOdd, maxe1, maxe2, maxo1, maxo2;\\n        maxe1=maxe2=maxo1=maxo2=0;\\n        unordered_map<int,int> freqEven, freqOdd;\\n        for(int i=0; i<n; i++) {\\n            if(i&1) {\\n                freqOdd[nums[i]]++;\\n                if(maxo1<freqOdd[nums[i]]) {\\n                    if(maxOdd!=nums[i]) maxo2=maxo1;\\n                    maxo1=freqOdd[nums[i]];\\n                    maxOdd=nums[i];\\n                }\\n                else if(maxo2<freqOdd[nums[i]]) maxo2=freqOdd[nums[i]];\\n            }\\n            else {\\n                freqEven[nums[i]]++;\\n                if(maxe1<freqEven[nums[i]]) {\\n                    if(maxEven!=nums[i]) maxe2=maxe1;\\n                    maxe1=freqEven[nums[i]];\\n                    maxEven=nums[i];\\n                }\\n                else if(maxe2<freqEven[nums[i]]) maxe2=freqEven[nums[i]];\\n            }\\n        }\\n        return maxOdd!=maxEven?n-maxo1-maxe1:min(n-maxo1-maxe2,n-maxe1-maxo2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769915,
                "title": "c-find-first-max-and-second-max-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size(); \\n       \\n        // for single element in nums return 0.         \\n        if(n==1) return 0;\\n        \\n        //  create a map to store the count of number at even and odd indices...       \\n        map<int,int> even,odd;\\n        \\n        \\n        // Priority_queue for finding first and second maximum element in both even and odd map...        \\n        priority_queue<pair<int,int>> q1,q2;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                even[nums[i]]++;\\n            }\\n            else{\\n                odd[nums[i]]++;\\n            }\\n            \\n        }\\n        \\n        \\n        for(auto i:even){\\n           \\n            q1.push({i.second,i.first});\\n        }\\n        \\n        for(auto i:odd){\\n            \\n            q2.push({i.second,i.first});\\n        }\\n        \\n        \\n                \\n        int even_first_max_freq = q1.top().first;\\n        int odd_first_max_freq = q2.top().first;\\n        \\n        int even_first_max = q1.top().second;\\n        int odd_first_max = q2.top().second;\\n        \\n        q1.pop();\\n        q2.pop();\\n        \\n       \\n        \\n        if(even_first_max != odd_first_max){\\n            \\n            return n-(even_first_max_freq)-(odd_first_max_freq);\\n        }\\n        \\n     \\n        int even_second_max_freq = 0;\\n        int odd_second_max_freq = 0;\\n        \\n        if(!q1.empty()){\\n            even_second_max_freq = q1.top().first;\\n            q1.pop();\\n        }\\n        \\n        if(!q2.empty()){\\n            odd_second_max_freq = q2.top().first;\\n            q2.pop();\\n        }\\n        \\n        \\n        return min(n-(even_first_max_freq)-(odd_second_max_freq),n-(even_second_max_freq)-(odd_first_max_freq));\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size(); \\n       \\n        // for single element in nums return 0.         \\n        if(n==1) return 0;\\n        \\n        //  create a map to store the count of number at even and odd indices...       \\n        map<int,int> even,odd;\\n        \\n        \\n        // Priority_queue for finding first and second maximum element in both even and odd map...        \\n        priority_queue<pair<int,int>> q1,q2;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                even[nums[i]]++;\\n            }\\n            else{\\n                odd[nums[i]]++;\\n            }\\n            \\n        }\\n        \\n        \\n        for(auto i:even){\\n           \\n            q1.push({i.second,i.first});\\n        }\\n        \\n        for(auto i:odd){\\n            \\n            q2.push({i.second,i.first});\\n        }\\n        \\n        \\n                \\n        int even_first_max_freq = q1.top().first;\\n        int odd_first_max_freq = q2.top().first;\\n        \\n        int even_first_max = q1.top().second;\\n        int odd_first_max = q2.top().second;\\n        \\n        q1.pop();\\n        q2.pop();\\n        \\n       \\n        \\n        if(even_first_max != odd_first_max){\\n            \\n            return n-(even_first_max_freq)-(odd_first_max_freq);\\n        }\\n        \\n     \\n        int even_second_max_freq = 0;\\n        int odd_second_max_freq = 0;\\n        \\n        if(!q1.empty()){\\n            even_second_max_freq = q1.top().first;\\n            q1.pop();\\n        }\\n        \\n        if(!q2.empty()){\\n            odd_second_max_freq = q2.top().first;\\n            q2.pop();\\n        }\\n        \\n        \\n        return min(n-(even_first_max_freq)-(odd_second_max_freq),n-(even_second_max_freq)-(odd_first_max_freq));\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767435,
                "title": "c-solution-naive-method",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool mycompare(pair<int, int> &p1, pair<int, int> &p2){\\n      return p1.first > p2.first; \\n    }\\n    int minimumOperations(vector<int>& nums) {\\n            int n = nums.size();\\n            if(n == 1)\\n              return 0;\\n            if(n == 2)\\n               return nums[0] == nums[1] ? 1 : 0;\\n            unordered_map<int, int> mp1, mp2;\\n            for(int i = 0; i<n; i+=2){\\n                    mp1[nums[i]]++;\\n            }\\n            for(int i=1; i<n; i+=2){\\n                    mp2[nums[i]]++;\\n            }\\n            vector<pair<int, int>> v1, v2;\\n            for(auto &it : mp1)\\n                    v1.push_back({it.second, it.first});\\n            for(auto &it : mp2)\\n                    v2.push_back({it.second, it.first});\\n            sort(v1.begin(), v1.end(), mycompare);\\n            sort(v2.begin(), v2.end(), mycompare);\\n            \\n            if(v1[0].second != v2[0].second)\\n                    return (n - v1[0].first - v2[0].first);\\n            else\\n            {\\n                    int ans = n;\\n                    if(v1.size() == 1 && v2.size() == 1)\\n                            return ans - max(v1[0].first, v2[0].first);\\n                    else if(v1.size() == 1)\\n                            return ans - v1[0].first - v2[1].first;\\n                    else if(v2.size() == 1)\\n                            return ans - v1[1].first - v2[0].first;\\n                    else\\n                            return ans - max(v1[0].first+v2[1].first, v1[1].first+v2[0].first);\\n            }\\n            return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool mycompare(pair<int, int> &p1, pair<int, int> &p2){\\n      return p1.first > p2.first; \\n    }\\n    int minimumOperations(vector<int>& nums) {\\n            int n = nums.size();\\n            if(n == 1)\\n              return 0;\\n            if(n == 2)\\n               return nums[0] == nums[1] ? 1 : 0;\\n            unordered_map<int, int> mp1, mp2;\\n            for(int i = 0; i<n; i+=2){\\n                    mp1[nums[i]]++;\\n            }\\n            for(int i=1; i<n; i+=2){\\n                    mp2[nums[i]]++;\\n            }\\n            vector<pair<int, int>> v1, v2;\\n            for(auto &it : mp1)\\n                    v1.push_back({it.second, it.first});\\n            for(auto &it : mp2)\\n                    v2.push_back({it.second, it.first});\\n            sort(v1.begin(), v1.end(), mycompare);\\n            sort(v2.begin(), v2.end(), mycompare);\\n            \\n            if(v1[0].second != v2[0].second)\\n                    return (n - v1[0].first - v2[0].first);\\n            else\\n            {\\n                    int ans = n;\\n                    if(v1.size() == 1 && v2.size() == 1)\\n                            return ans - max(v1[0].first, v2[0].first);\\n                    else if(v1.size() == 1)\\n                            return ans - v1[0].first - v2[1].first;\\n                    else if(v2.size() == 1)\\n                            return ans - v1[1].first - v2[0].first;\\n                    else\\n                            return ans - max(v1[0].first+v2[1].first, v1[1].first+v2[0].first);\\n            }\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767189,
                "title": "java-solution-using-hashmap-priorityqueue-updated-with-comments-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n\\t\\t// map all even values and its count\\n    \\tMap<Integer, Integer> evenMap = new HashMap<>();\\n\\n    \\tint evenCount = 0, oddCount = 0;\\n    \\tfor(int i = 0 ; i < nums.length; i+=2) {\\n    \\t\\tevenMap.put(nums[i], evenMap.getOrDefault(nums[i], 0)+1);\\n    \\t\\tevenCount++;\\n    \\t}\\n\\t\\t// map all of the odd values and its count\\n    \\tMap<Integer, Integer> oddMap = new HashMap<>();\\n    \\t\\n    \\tfor(int i = 1 ; i < nums.length; i+=2) {\\n    \\t\\toddMap.put(nums[i], oddMap.getOrDefault(nums[i], 0)+1);\\n    \\t\\toddCount++;\\n    \\t}\\n\\n    \\n    \\t// add even and odd keys to priority queue and arrange them in descending order\\n    \\tPriorityQueue<Integer> even = new PriorityQueue<Integer>((n1, n2) -> evenMap.get(n2) - evenMap.get(n1));\\n    \\tPriorityQueue<Integer> oddd = new PriorityQueue<Integer>((n1, n2) -> oddMap.get(n2) - oddMap.get(n1));\\n    \\teven.addAll(evenMap.keySet()); // adding elements\\n    \\toddd.addAll(oddMap.keySet()); // adding elements\\n    \\t\\t\\n\\t\\t\\t// check if the top elements are equal, and remove them\\n        while(!even.isEmpty() && !oddd.isEmpty() && (even.peek() == oddd.peek())) {\\n           if(evenMap.get(even.peek()) > oddMap.get(oddd.peek())) {  // this step is to reduce the number of operations\\n               oddd.poll();\\n           } else {\\n               even.poll();\\n           }\\n        }\\n              \\n\\t\\t\\t  // at this step the top element are not equal\\n\\t\\t\\t  // check if the priority queues are empty , if empty then all the values need to be replaced\\n        return (even.isEmpty() ? evenCount : evenCount-evenMap.get(even.peek())) + (oddd.isEmpty() ? oddCount : oddCount - oddMap.get(oddd.peek()));\\n    \\n    \\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n\\t\\t// map all even values and its count\\n    \\tMap<Integer, Integer> evenMap = new HashMap<>();\\n\\n    \\tint evenCount = 0, oddCount = 0;\\n    \\tfor(int i = 0 ; i < nums.length; i+=2) {\\n    \\t\\tevenMap.put(nums[i], evenMap.getOrDefault(nums[i], 0)+1);\\n    \\t\\tevenCount++;\\n    \\t}\\n\\t\\t// map all of the odd values and its count\\n    \\tMap<Integer, Integer> oddMap = new HashMap<>();\\n    \\t\\n    \\tfor(int i = 1 ; i < nums.length; i+=2) {\\n    \\t\\toddMap.put(nums[i], oddMap.getOrDefault(nums[i], 0)+1);\\n    \\t\\toddCount++;\\n    \\t}\\n\\n    \\n    \\t// add even and odd keys to priority queue and arrange them in descending order\\n    \\tPriorityQueue<Integer> even = new PriorityQueue<Integer>((n1, n2) -> evenMap.get(n2) - evenMap.get(n1));\\n    \\tPriorityQueue<Integer> oddd = new PriorityQueue<Integer>((n1, n2) -> oddMap.get(n2) - oddMap.get(n1));\\n    \\teven.addAll(evenMap.keySet()); // adding elements\\n    \\toddd.addAll(oddMap.keySet()); // adding elements\\n    \\t\\t\\n\\t\\t\\t// check if the top elements are equal, and remove them\\n        while(!even.isEmpty() && !oddd.isEmpty() && (even.peek() == oddd.peek())) {\\n           if(evenMap.get(even.peek()) > oddMap.get(oddd.peek())) {  // this step is to reduce the number of operations\\n               oddd.poll();\\n           } else {\\n               even.poll();\\n           }\\n        }\\n              \\n\\t\\t\\t  // at this step the top element are not equal\\n\\t\\t\\t  // check if the priority queues are empty , if empty then all the values need to be replaced\\n        return (even.isEmpty() ? evenCount : evenCount-evenMap.get(even.peek())) + (oddd.isEmpty() ? oddCount : oddCount - oddMap.get(oddd.peek()));\\n    \\n    \\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767180,
                "title": "c-traverse-odd-index-even-index",
                "content": "Traverse odd index seperately and even index seperately and find the element with max occurance in both. \\n if the max occurance in both are the same then we need to change either of one(look at the last if else conditions).\\n \\n ```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 1){\\n            return 0;\\n        }\\n        if(n == 2){\\n            if(nums[0] == nums[1]){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int m1 = n/2,m2 = n/2;\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        int max1 = 0;\\n        int k;\\n        int max2 = 0;\\n        int y;\\n        if(n%2 != 0){\\n            m1 +=1;\\n        }\\n        for(int i =0;i < n;i+=2){\\n           mp1[nums[i]]++; \\n           if(max1 < mp1[nums[i]]){\\n                max1= mp1[nums[i]];\\n                k = nums[i];\\n           }\\n        }\\n        mp1.erase(k);\\n        for(int i =1;i < n;i+=2){\\n           mp2[nums[i]]++; \\n           if(max2 < mp2[nums[i]]){\\n                max2= mp2[nums[i]];\\n                y = nums[i];\\n            }\\n        }\\n        mp2.erase(y);\\n        \\n       if(k == y){\\n            if(m1-max1 < m2-max2){\\n                max2 = 0;\\n                for(int i =1;i < n;i+=2){\\n                    if(max2 < mp2[nums[i]]){\\n                        max2= mp2[nums[i]];\\n                    }\\n                }\\n                \\n                \\n            }\\n            else if(m1-max1 == m2-max2 && m1 < m2){\\n                max1 = 0;\\n                for(int i =0;i < n;i+=2){\\n                    if(max1 < mp1[nums[i]]){\\n                        max1= mp1[nums[i]];\\n                    }\\n                }\\n        \\n            }\\n            else if(m1-max1 == m2-max2 && m1 >= m2){\\n                max2 = 0;\\n                for(int i =1;i < n;i+=2){\\n                    if(max2 < mp2[nums[i]]){\\n                        max2= mp2[nums[i]];\\n                    }\\n                }\\n            }\\n            else{\\n                max1 = 0;\\n                for(int i =0;i < n;i+=2){\\n                    if(max1 < mp1[nums[i]]){\\n                        max1= mp1[nums[i]];\\n                    }\\n                }\\n            }\\n        }\\n        c = m1-max1 + m2-max2;\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int c = 0;\\n        int n = nums.size();\\n        if(n == 1){\\n            return 0;\\n        }\\n        if(n == 2){\\n            if(nums[0] == nums[1]){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int m1 = n/2,m2 = n/2;\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        int max1 = 0;\\n        int k;\\n        int max2 = 0;\\n        int y;\\n        if(n%2 != 0){\\n            m1 +=1;\\n        }\\n        for(int i =0;i < n;i+=2){\\n           mp1[nums[i]]++; \\n           if(max1 < mp1[nums[i]]){\\n                max1= mp1[nums[i]];\\n                k = nums[i];\\n           }\\n        }\\n        mp1.erase(k);\\n        for(int i =1;i < n;i+=2){\\n           mp2[nums[i]]++; \\n           if(max2 < mp2[nums[i]]){\\n                max2= mp2[nums[i]];\\n                y = nums[i];\\n            }\\n        }\\n        mp2.erase(y);\\n        \\n       if(k == y){\\n            if(m1-max1 < m2-max2){\\n                max2 = 0;\\n                for(int i =1;i < n;i+=2){\\n                    if(max2 < mp2[nums[i]]){\\n                        max2= mp2[nums[i]];\\n                    }\\n                }\\n                \\n                \\n            }\\n            else if(m1-max1 == m2-max2 && m1 < m2){\\n                max1 = 0;\\n                for(int i =0;i < n;i+=2){\\n                    if(max1 < mp1[nums[i]]){\\n                        max1= mp1[nums[i]];\\n                    }\\n                }\\n        \\n            }\\n            else if(m1-max1 == m2-max2 && m1 >= m2){\\n                max2 = 0;\\n                for(int i =1;i < n;i+=2){\\n                    if(max2 < mp2[nums[i]]){\\n                        max2= mp2[nums[i]];\\n                    }\\n                }\\n            }\\n            else{\\n                max1 = 0;\\n                for(int i =0;i < n;i+=2){\\n                    if(max1 < mp1[nums[i]]){\\n                        max1= mp1[nums[i]];\\n                    }\\n                }\\n            }\\n        }\\n        c = m1-max1 + m2-max2;\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767111,
                "title": "cpp-ugly-solution-intuition-explained-map-easy",
                "content": "To reduce the operations to minimum, we need to keep the most frequent elements as it is(for odd positioned and even positioned separately) , and change the rest. \\n\\nHowever, we need to have the second most frequent element of odd and even positioned elements too.\\nWhy? Because there might be a case where the most frequent element for odd and even is the same. \\n(take example 2 as given, [1,2,2,2,2]. Most frequent for both odd and even positions is \\'2\\'. In that case, we cant change \\'1\\' to \\'2\\', because the array will become [2,2,2,2,2] which is invalid)\\n\\nTo store the highest and second highest frequency of even elements, we use evenmax and evenmax2\\nSame goes for odd elements,i.e, oddmax and oddmax2\\n\\nevenc and oddc is the total count of even and odd positioned elements.\\n\\net is the element corresponding to evenmax\\not is the element corresponding to oddmax\\n\\nAt the end, when we get all these variables calculated, we see if ot==et , i.e. we\\'ll check if most frequent element in both odd and even positoned elements is the same element or not. \\nIf it\\'s not we simply return \"evenc - evenmax +oddc - oddmax\" (i.e. evenc - evenmax gives us the number of elements which need to be changed to \\'et\\'.... Same goes for oddc-oddmax)\\n\\nHowever, if ot==et, then we cant have oddmax and evenmax together. \\nWe have to take the second highest of either of them. (or else the array will have all same elements after operation)\\n\\nThus, we take the minimum of the two possibilities:\\n\"oddc-oddmax + evenc-evenmax2\" and \"oddc-oddmax2 + evenc-evenmax\"\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int> even;\\n        int evenc=0;\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            even[nums[i]]++;\\n            evenc++;\\n        }\\n        int evenmax=0;\\n        int et;\\n      \\n         for (auto i : even)\\n         {\\n             evenmax=max(i.second,evenmax);\\n             if(evenmax==i.second)\\n                 et=i.first;\\n           \\n         }\\n        int evenmax2=0;\\n        \\n        for (auto i : even)\\n         {\\n            if(i.first==et)\\n                continue;\\n             evenmax2=max(i.second,evenmax2);\\n            \\n         }\\n      \\n         unordered_map<int,int> odd;\\n        int oddc=0;\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            odd[nums[i]]++;\\n            oddc++;\\n        }\\n      \\n       \\n       int ot=-1;\\n            int oddmax=0;\\n         for (auto i : odd)\\n         {\\n           \\n            \\n             oddmax=max(i.second,oddmax);\\n              if(oddmax==i.second)\\n                 ot=i.first;\\n                 \\n                \\n             \\n             \\n         }\\n        int oddmax2=0;\\n         for (auto i : odd)\\n         {\\n            if(i.first==ot)\\n                continue;\\n             oddmax2=max(i.second,oddmax2);\\n            \\n         }\\n        \\n       if(ot==et)\\n           return min(oddc-oddmax + evenc-evenmax2,oddc-oddmax2 + evenc-evenmax);\\n           \\n           return oddc-oddmax + evenc-evenmax;\\n  \\n       \\n        \\n    }\\n        \\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int> even;\\n        int evenc=0;\\n        for(int i=0;i<nums.size();i+=2)\\n        {\\n            even[nums[i]]++;\\n            evenc++;\\n        }\\n        int evenmax=0;\\n        int et;\\n      \\n         for (auto i : even)\\n         {\\n             evenmax=max(i.second,evenmax);\\n             if(evenmax==i.second)\\n                 et=i.first;\\n           \\n         }\\n        int evenmax2=0;\\n        \\n        for (auto i : even)\\n         {\\n            if(i.first==et)\\n                continue;\\n             evenmax2=max(i.second,evenmax2);\\n            \\n         }\\n      \\n         unordered_map<int,int> odd;\\n        int oddc=0;\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            odd[nums[i]]++;\\n            oddc++;\\n        }\\n      \\n       \\n       int ot=-1;\\n            int oddmax=0;\\n         for (auto i : odd)\\n         {\\n           \\n            \\n             oddmax=max(i.second,oddmax);\\n              if(oddmax==i.second)\\n                 ot=i.first;\\n                 \\n                \\n             \\n             \\n         }\\n        int oddmax2=0;\\n         for (auto i : odd)\\n         {\\n            if(i.first==ot)\\n                continue;\\n             oddmax2=max(i.second,oddmax2);\\n            \\n         }\\n        \\n       if(ot==et)\\n           return min(oddc-oddmax + evenc-evenmax2,oddc-oddmax2 + evenc-evenmax);\\n           \\n           return oddc-oddmax + evenc-evenmax;\\n  \\n       \\n        \\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766977,
                "title": "commented-java-solution-with-mediocre-code",
                "content": "Code is all over the place but it worked in the contest lol. Overall this is a pretty tricky question with a somewhat long solution so this is somewhat expected. \\n\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n\\t\\t\\n\\t\\t// First map the numbers to frequencies\\n        Map<Integer, Integer> evenFreq = new HashMap<>();\\n        Map<Integer, Integer> oddFreq = new HashMap<>();\\n        \\n\\t\\t// Also generate counts for evens and odds, this can be improved with simple math\\n        int evenCount = 0;\\n        int oddCount = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            Map<Integer, Integer> currMap;\\n            if ((i % 2) == 0) {\\n                currMap = evenFreq;\\n                evenCount++;\\n            }\\n            else {\\n                currMap = oddFreq;\\n                oddCount++;\\n            }\\n            currMap.put(nums[i], currMap.getOrDefault(nums[i], 0)+1);\\n        }\\n        \\n\\t\\t// Put the character:frequency mappings into a priority queue by frequency\\n        PriorityQueue<Pair<Integer, Integer>> evenQueue = new PriorityQueue<>((a, b) -> Integer.compare(b.getValue(), a.getValue()));\\n        for (int key : evenFreq.keySet()) {\\n            evenQueue.add(new Pair<Integer, Integer>(key, evenFreq.get(key)));\\n        }\\n        \\n        PriorityQueue<Pair<Integer, Integer>> oddQueue = new PriorityQueue<>((a, b) -> Integer.compare(b.getValue(), a.getValue()));\\n        for (int key : oddFreq.keySet()) {\\n            oddQueue.add(new Pair<Integer, Integer>(key, oddFreq.get(key)));\\n        }\\n        \\n\\t\\t\\t// You want to keep the largest value the same so if evenFreq.peek() (can now consider it larger freq)\\n\\t\\t\\t// is smaller than the oddFreq (now smallerFreq), switch them\\n\\t\\t\\t// Importantly, you also have to switch them if they are the same!\\n\\t\\t\\t// That tripped me up for a while \\n        if (evenQueue.peek().getValue() <= oddQueue.peek().getValue()) {\\n            int tmp = oddCount;\\n            oddCount = evenCount;\\n            evenCount = tmp;\\n            \\n            PriorityQueue<Pair<Integer, Integer>> mapTmp = evenQueue;\\n            evenQueue = oddQueue;\\n            oddQueue = mapTmp;\\n        }\\n        \\n\\t\\t\\n\\t\\t// Now the number of things to change on the even indices is this\\n        int evenDiff = evenCount - evenQueue.peek().getValue();\\n        \\n\\t\\t// If the top number in the odd queue is the same as your even number that you are keeping\\n\\t\\t// the same you must use the second highest number, or change them all if there is no \\n\\t\\t// second highest number. \\n        if (evenQueue.peek().getKey() == oddQueue.peek().getKey()) {\\n            oddQueue.poll();\\n        }\\n        int oddDiff;\\n        if (oddQueue.size() == 0) {\\n            oddDiff = oddCount;\\n        }\\n        else {\\n            oddDiff = oddCount - oddQueue.peek().getValue();\\n        }\\n\\t\\t\\n\\t\\t// Return value is just the sum of the changes made to the even and odd parts of the array\\n        return oddDiff + evenDiff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        if (nums.length <= 1) return 0;\\n\\t\\t\\n\\t\\t// First map the numbers to frequencies\\n        Map<Integer, Integer> evenFreq = new HashMap<>();\\n        Map<Integer, Integer> oddFreq = new HashMap<>();\\n        \\n\\t\\t// Also generate counts for evens and odds, this can be improved with simple math\\n        int evenCount = 0;\\n        int oddCount = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            Map<Integer, Integer> currMap;\\n            if ((i % 2) == 0) {\\n                currMap = evenFreq;\\n                evenCount++;\\n            }\\n            else {\\n                currMap = oddFreq;\\n                oddCount++;\\n            }\\n            currMap.put(nums[i], currMap.getOrDefault(nums[i], 0)+1);\\n        }\\n        \\n\\t\\t// Put the character:frequency mappings into a priority queue by frequency\\n        PriorityQueue<Pair<Integer, Integer>> evenQueue = new PriorityQueue<>((a, b) -> Integer.compare(b.getValue(), a.getValue()));\\n        for (int key : evenFreq.keySet()) {\\n            evenQueue.add(new Pair<Integer, Integer>(key, evenFreq.get(key)));\\n        }\\n        \\n        PriorityQueue<Pair<Integer, Integer>> oddQueue = new PriorityQueue<>((a, b) -> Integer.compare(b.getValue(), a.getValue()));\\n        for (int key : oddFreq.keySet()) {\\n            oddQueue.add(new Pair<Integer, Integer>(key, oddFreq.get(key)));\\n        }\\n        \\n\\t\\t\\t// You want to keep the largest value the same so if evenFreq.peek() (can now consider it larger freq)\\n\\t\\t\\t// is smaller than the oddFreq (now smallerFreq), switch them\\n\\t\\t\\t// Importantly, you also have to switch them if they are the same!\\n\\t\\t\\t// That tripped me up for a while \\n        if (evenQueue.peek().getValue() <= oddQueue.peek().getValue()) {\\n            int tmp = oddCount;\\n            oddCount = evenCount;\\n            evenCount = tmp;\\n            \\n            PriorityQueue<Pair<Integer, Integer>> mapTmp = evenQueue;\\n            evenQueue = oddQueue;\\n            oddQueue = mapTmp;\\n        }\\n        \\n\\t\\t\\n\\t\\t// Now the number of things to change on the even indices is this\\n        int evenDiff = evenCount - evenQueue.peek().getValue();\\n        \\n\\t\\t// If the top number in the odd queue is the same as your even number that you are keeping\\n\\t\\t// the same you must use the second highest number, or change them all if there is no \\n\\t\\t// second highest number. \\n        if (evenQueue.peek().getKey() == oddQueue.peek().getKey()) {\\n            oddQueue.poll();\\n        }\\n        int oddDiff;\\n        if (oddQueue.size() == 0) {\\n            oddDiff = oddCount;\\n        }\\n        else {\\n            oddDiff = oddCount - oddQueue.peek().getValue();\\n        }\\n\\t\\t\\n\\t\\t// Return value is just the sum of the changes made to the even and odd parts of the array\\n        return oddDiff + evenDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766929,
                "title": "frequency-count-on-odd-even-index-c-concise-solution",
                "content": "1. Find highest frequency odd position number \\n2. Find highest frequency even position number skiping the highest fequency odd number.\\n3. Cost will the number that need to be changed. \\n```\\nclass Solution {\\nprivate: \\n    void call(vector<int>&num, int target, vector<int> &result, int skip){\\n        int size = num.size();\\n        unordered_map<int,int> frequency;\\n        int mx =0 , val = 0;\\n        \\n        for(int i=0; i<size; i++){\\n            if(skip>0 && num[i] == skip ) continue;  // skip those number which have been selected alredy. odd and even position can have same number. \\n            if(i % 2 == target){\\n                frequency[num[i]]++;\\n                if(frequency[num[i]] > mx) mx = frequency[num[i]], val = num[i];\\n            }\\n        }\\n        \\n        result.push_back(val);\\n        result.push_back(mx);\\n        return ;\\n    }\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        vector<int> oddResult, evenResult; // {0 index = value, 1 index = frequency}\\n        int answer = nums.size(), cost = 0;\\n        \\n        call(nums,0, oddResult,-1);    //highest frequency number will be placed on all odd position\\n        call(nums,1, evenResult, oddResult[0]); // Skiping the alredy placed number, and highest frequency number will be placed on all even position\\n        answer = nums.size() - oddResult[1] - evenResult[1]; // total number - those initial position was right \\n       \\n        \\n        oddResult.clear(); //clearing result data \\n        evenResult.clear(); \\n        \\n        call(nums, 1, evenResult,-1);  //highest frequency number will be placed on all even position\\n        call(nums, 0, oddResult, evenResult[0]); // Skiping the alredy placed number, and highest frequency number will be placed on all even position\\n        cost = nums.size() - oddResult[1] - evenResult[1];\\n        \\n        if(answer > cost ) answer = cost;\\n        \\n        return answer;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    void call(vector<int>&num, int target, vector<int> &result, int skip){\\n        int size = num.size();\\n        unordered_map<int,int> frequency;\\n        int mx =0 , val = 0;\\n        \\n        for(int i=0; i<size; i++){\\n            if(skip>0 && num[i] == skip ) continue;  // skip those number which have been selected alredy. odd and even position can have same number. \\n            if(i % 2 == target){\\n                frequency[num[i]]++;\\n                if(frequency[num[i]] > mx) mx = frequency[num[i]], val = num[i];\\n            }\\n        }\\n        \\n        result.push_back(val);\\n        result.push_back(mx);\\n        return ;\\n    }\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        vector<int> oddResult, evenResult; // {0 index = value, 1 index = frequency}\\n        int answer = nums.size(), cost = 0;\\n        \\n        call(nums,0, oddResult,-1);    //highest frequency number will be placed on all odd position\\n        call(nums,1, evenResult, oddResult[0]); // Skiping the alredy placed number, and highest frequency number will be placed on all even position\\n        answer = nums.size() - oddResult[1] - evenResult[1]; // total number - those initial position was right \\n       \\n        \\n        oddResult.clear(); //clearing result data \\n        evenResult.clear(); \\n        \\n        call(nums, 1, evenResult,-1);  //highest frequency number will be placed on all even position\\n        call(nums, 0, oddResult, evenResult[0]); // Skiping the alredy placed number, and highest frequency number will be placed on all even position\\n        cost = nums.size() - oddResult[1] - evenResult[1];\\n        \\n        if(answer > cost ) answer = cost;\\n        \\n        return answer;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766899,
                "title": "c-most-frequent-and-second-most-frequent",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        //special case\\n        if(nums.size()==1) return 0;\\n        if(nums.size()==2) {\\n            if(nums[0]==nums[1]) return 1;\\n            else return 0;\\n        }\\n        \\n        int n = nums.size();\\n        \\n        pair<int, int> f1 = make_pair(0, 0), s1= make_pair(0, 0); //even\\n        pair<int, int> f2 = make_pair(0, 0), s2 = make_pair(0, 0); //odd\\n        \\n        unordered_map<int, int> even;\\n        unordered_map<int, int> odd;\\n        \\n        for(int i=0; i<n; i+=2) even[nums[i]]++;\\n        for(int i=1; i<n; i+=2) odd[nums[i]]++;\\n        \\n        for(auto &x:even){\\n            if(x.second > f1.second){\\n                s1 = f1;\\n                f1.second = x.second; \\n                f1.first = x.first;\\n            }\\n            else{\\n                if(x.second > s1.second){\\n                    s1.second = x.second; \\n                    s1.first = x.first;\\n                }\\n            }\\n        }\\n        \\n        for(auto &x:odd){\\n            if(x.second > f2.second){\\n                s2 = f2;\\n                f2.second = x.second; \\n                f2.first = x.first;\\n            }\\n            else{\\n                if(x.second > s2.second){\\n                    s2.second = x.second; \\n                    s2.first = x.first;\\n                }\\n            }\\n        }\\n\\n        //if both are unequal -> res+= n/2 - f1.s + n/2 - f2.s;\\n        \\n        if(f1.first != f2.first){\\n            if(n%2) return ((n/2+1 - f1.second) + (n/2 - f2.second));\\n            else return ((n/2 - f1.second) + (n/2 - f2.second));\\n        }\\n        \\n        if(n%2){\\n            int res = 0;\\n            res = min((n/2 + 1 - f1.second) + (n/2 - s2.second) , (n/2 - f2.second) + (n/2 + 1 - s1.second));\\n            return res;\\n        }\\n        int res = 0;\\n        res = min((n/2 - f1.second) + (n/2 - s2.second) , (n/2 - f2.second) + (n/2 - s1.second));\\n        return res;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        //special case\\n        if(nums.size()==1) return 0;\\n        if(nums.size()==2) {\\n            if(nums[0]==nums[1]) return 1;\\n            else return 0;\\n        }\\n        \\n        int n = nums.size();\\n        \\n        pair<int, int> f1 = make_pair(0, 0), s1= make_pair(0, 0); //even\\n        pair<int, int> f2 = make_pair(0, 0), s2 = make_pair(0, 0); //odd\\n        \\n        unordered_map<int, int> even;\\n        unordered_map<int, int> odd;\\n        \\n        for(int i=0; i<n; i+=2) even[nums[i]]++;\\n        for(int i=1; i<n; i+=2) odd[nums[i]]++;\\n        \\n        for(auto &x:even){\\n            if(x.second > f1.second){\\n                s1 = f1;\\n                f1.second = x.second; \\n                f1.first = x.first;\\n            }\\n            else{\\n                if(x.second > s1.second){\\n                    s1.second = x.second; \\n                    s1.first = x.first;\\n                }\\n            }\\n        }\\n        \\n        for(auto &x:odd){\\n            if(x.second > f2.second){\\n                s2 = f2;\\n                f2.second = x.second; \\n                f2.first = x.first;\\n            }\\n            else{\\n                if(x.second > s2.second){\\n                    s2.second = x.second; \\n                    s2.first = x.first;\\n                }\\n            }\\n        }\\n\\n        //if both are unequal -> res+= n/2 - f1.s + n/2 - f2.s;\\n        \\n        if(f1.first != f2.first){\\n            if(n%2) return ((n/2+1 - f1.second) + (n/2 - f2.second));\\n            else return ((n/2 - f1.second) + (n/2 - f2.second));\\n        }\\n        \\n        if(n%2){\\n            int res = 0;\\n            res = min((n/2 + 1 - f1.second) + (n/2 - s2.second) , (n/2 - f2.second) + (n/2 + 1 - s1.second));\\n            return res;\\n        }\\n        int res = 0;\\n        res = min((n/2 - f1.second) + (n/2 - s2.second) , (n/2 - f2.second) + (n/2 - s1.second));\\n        return res;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766847,
                "title": "java-solution-find-max-and-second-max",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        if (nums.length == 1) return 0;\\n        \\n\\t\\t// Counts the nums in odd and even indices\\n        Map<Integer, Integer> odd = new HashMap<>();\\n        Map<Integer, Integer> even = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2==0) even.put(nums[i], even.getOrDefault(nums[i], 0) + 1);\\n            else odd.put(nums[i], odd.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n\\t\\t// Use heaps to find the max and the second max for odd-index nums and even-index nums\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<Map.Entry<Integer, Integer>>(11, (a, b) -> b.getValue() - a.getValue());\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq2 = new PriorityQueue<Map.Entry<Integer, Integer>>(11, (a, b) -> b.getValue() - a.getValue());\\n        odd.entrySet().forEach(s -> pq.offer(s));\\n        even.entrySet().forEach(s -> pq2.offer(s));\\n        \\n\\t\\t// # of odd-index nums and # of even-index nums\\n        int co = nums.length / 2;\\n        int ce = nums.length - co;\\n\\t\\t\\n\\t\\t// if the maxes are different, we could return value\\n        if (pq.peek().getKey() != pq2.peek().getKey()) {\\n            return co - pq.peek().getValue() + ce - pq2.peek().getValue();\\n        }\\n\\t\\t// if the maxes are the same, we need to consider the second maxes, note that we need to try (odd1, even2) and (odd2, even1)\\n        else {\\n\\t\\t    // odd max \\n            int a = pq.poll().getValue();\\n\\t\\t    // even max \\n            int b = pq2.poll().getValue();\\n\\t\\t\\t// odd second max, if there is no second max, we set it to 0\\n            int c = pq.isEmpty() ? 0 : pq.poll().getValue();\\n\\t\\t    // even second max \\n            int d = pq2.isEmpty() ? 0 : pq2.poll().getValue();\\n            \\n            return co + ce - Math.max(a + d, b + c);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        if (nums.length == 1) return 0;\\n        \\n\\t\\t// Counts the nums in odd and even indices\\n        Map<Integer, Integer> odd = new HashMap<>();\\n        Map<Integer, Integer> even = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2==0) even.put(nums[i], even.getOrDefault(nums[i], 0) + 1);\\n            else odd.put(nums[i], odd.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n\\t\\t// Use heaps to find the max and the second max for odd-index nums and even-index nums\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<Map.Entry<Integer, Integer>>(11, (a, b) -> b.getValue() - a.getValue());\\n        PriorityQueue<Map.Entry<Integer, Integer>> pq2 = new PriorityQueue<Map.Entry<Integer, Integer>>(11, (a, b) -> b.getValue() - a.getValue());\\n        odd.entrySet().forEach(s -> pq.offer(s));\\n        even.entrySet().forEach(s -> pq2.offer(s));\\n        \\n\\t\\t// # of odd-index nums and # of even-index nums\\n        int co = nums.length / 2;\\n        int ce = nums.length - co;\\n\\t\\t\\n\\t\\t// if the maxes are different, we could return value\\n        if (pq.peek().getKey() != pq2.peek().getKey()) {\\n            return co - pq.peek().getValue() + ce - pq2.peek().getValue();\\n        }\\n\\t\\t// if the maxes are the same, we need to consider the second maxes, note that we need to try (odd1, even2) and (odd2, even1)\\n        else {\\n\\t\\t    // odd max \\n            int a = pq.poll().getValue();\\n\\t\\t    // even max \\n            int b = pq2.poll().getValue();\\n\\t\\t\\t// odd second max, if there is no second max, we set it to 0\\n            int c = pq.isEmpty() ? 0 : pq.poll().getValue();\\n\\t\\t    // even second max \\n            int d = pq2.isEmpty() ? 0 : pq2.poll().getValue();\\n            \\n            return co + ce - Math.max(a + d, b + c);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766831,
                "title": "python-readable-odd-even-counters-approach-o-nlogn",
                "content": "```\\nclass Solution:  # works\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        end = len(nums)\\n        def freq(start):\\n            counter = dict()\\n            for i in range(start, end, 2):\\n                if nums[i] not in counter:\\n                    counter[nums[i]] = 1\\n                else:\\n                    counter[nums[i]] += 1\\n            return counter\\n        odd, even = freq(0), freq(1)\\n        odd_sum, even_sum = sum(odd.values()), sum(even.values())\\n        odd = [(k, v) for k, v in odd.items()]\\n        even = [(k, v) for k, v in even.items()]\\n        odd = sorted(odd, key=lambda i:i[1], reverse=True)\\n        even = sorted(even, key=lambda i: i[1], reverse=True)\\n        for i in odd:\\n            for j in even:\\n                if i[0] != j[0]:\\n                    return odd_sum - i[1] + even_sum - j[1]\\n        return min(odd_sum, even_sum)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:  # works\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        end = len(nums)\\n        def freq(start):\\n            counter = dict()\\n            for i in range(start, end, 2):\\n                if nums[i] not in counter:\\n                    counter[nums[i]] = 1\\n                else:\\n                    counter[nums[i]] += 1\\n            return counter\\n        odd, even = freq(0), freq(1)\\n        odd_sum, even_sum = sum(odd.values()), sum(even.values())\\n        odd = [(k, v) for k, v in odd.items()]\\n        even = [(k, v) for k, v in even.items()]\\n        odd = sorted(odd, key=lambda i:i[1], reverse=True)\\n        even = sorted(even, key=lambda i: i[1], reverse=True)\\n        for i in odd:\\n            for j in even:\\n                if i[0] != j[0]:\\n                    return odd_sum - i[1] + even_sum - j[1]\\n        return min(odd_sum, even_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897063,
                "title": "easy-sol",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo the approach behind this problem is that, \\nThe elements at odd and even indices must be different.\\nSo for that purpose, we find out the first 2 elements at the odd and even indices respectively with the highest frequencies and we also store their frequencies\\n\\nAfter we have calculated the elements and their frequencies :-\\n    **1. Case 1 ->** If the the maximum elements at the odd and even indices are not equal, then it means we can alter the array without any issue, so we simply return \\n            **n - freqFirstMaxEven - freqFirstMaxOdd**\\nThis will return the calculations needed to alter the array\\n\\n**2. Case 2 ->** If the the maximum elements at the odd and even indices are equal, then it means we can not alter the array so we can either select \\n    a. Second Max Element at Even Index and First Max Element at Odd Index\\n\\nb. First Max Element at the Even Index and Second Max Element at the Odd Index.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1e5)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int freqEven[100001] = {0};\\n        int freqOdd[100001] = {0};\\n        \\n        int n = nums.size();\\n        \\n        int maxEle = nums[0];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(i%2 == 0) {\\n                freqEven[nums[i]]++;\\n            }\\n            else {\\n                freqOdd[nums[i]]++;\\n            }\\n            \\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        \\n        \\n        int firstMaxEven = 0, freqFirstMaxEven = 0;\\n        int secondMaxEven = 0, freqSecondMaxEven = 0;\\n        \\n        int firstMaxOdd = 0, freqFirstMaxOdd = 0;\\n        int secondMaxOdd = 0, freqSecondMaxOdd = 0;\\n        \\n        \\n        for(int i=1;i<=maxEle;i++) {\\n            if(freqEven[i] > freqFirstMaxEven) {\\n                secondMaxEven = firstMaxEven;\\n                freqSecondMaxEven = freqFirstMaxEven;\\n                \\n                firstMaxEven = i;\\n                freqFirstMaxEven = freqEven[i];\\n            }\\n            else if(freqEven[i] > freqSecondMaxEven) {\\n                secondMaxEven = i;\\n                freqSecondMaxEven = freqEven[i];\\n            }\\n            \\n            \\n            if(freqOdd[i] > freqFirstMaxOdd) {\\n                secondMaxOdd = firstMaxOdd;\\n                freqSecondMaxOdd = freqFirstMaxOdd;\\n                \\n                firstMaxOdd = i;\\n                freqFirstMaxOdd = freqOdd[i];\\n            }\\n            else if(freqOdd[i] > freqSecondMaxOdd) {\\n                secondMaxOdd = i;\\n                freqSecondMaxOdd = freqOdd[i];\\n            }\\n        }\\n        \\n        \\n        if(firstMaxEven != firstMaxOdd) {\\n            return (n-freqFirstMaxEven - freqFirstMaxOdd);\\n        }\\n        \\n        int ans = min(n-freqFirstMaxEven-freqSecondMaxOdd,n-freqSecondMaxEven-freqFirstMaxOdd);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int freqEven[100001] = {0};\\n        int freqOdd[100001] = {0};\\n        \\n        int n = nums.size();\\n        \\n        int maxEle = nums[0];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(i%2 == 0) {\\n                freqEven[nums[i]]++;\\n            }\\n            else {\\n                freqOdd[nums[i]]++;\\n            }\\n            \\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        \\n        \\n        int firstMaxEven = 0, freqFirstMaxEven = 0;\\n        int secondMaxEven = 0, freqSecondMaxEven = 0;\\n        \\n        int firstMaxOdd = 0, freqFirstMaxOdd = 0;\\n        int secondMaxOdd = 0, freqSecondMaxOdd = 0;\\n        \\n        \\n        for(int i=1;i<=maxEle;i++) {\\n            if(freqEven[i] > freqFirstMaxEven) {\\n                secondMaxEven = firstMaxEven;\\n                freqSecondMaxEven = freqFirstMaxEven;\\n                \\n                firstMaxEven = i;\\n                freqFirstMaxEven = freqEven[i];\\n            }\\n            else if(freqEven[i] > freqSecondMaxEven) {\\n                secondMaxEven = i;\\n                freqSecondMaxEven = freqEven[i];\\n            }\\n            \\n            \\n            if(freqOdd[i] > freqFirstMaxOdd) {\\n                secondMaxOdd = firstMaxOdd;\\n                freqSecondMaxOdd = freqFirstMaxOdd;\\n                \\n                firstMaxOdd = i;\\n                freqFirstMaxOdd = freqOdd[i];\\n            }\\n            else if(freqOdd[i] > freqSecondMaxOdd) {\\n                secondMaxOdd = i;\\n                freqSecondMaxOdd = freqOdd[i];\\n            }\\n        }\\n        \\n        \\n        if(firstMaxEven != firstMaxOdd) {\\n            return (n-freqFirstMaxEven - freqFirstMaxOdd);\\n        }\\n        \\n        int ans = min(n-freqFirstMaxEven-freqSecondMaxOdd,n-freqSecondMaxEven-freqFirstMaxOdd);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428665,
                "title": "java-simplest-solution",
                "content": "\\n# Code\\n```\\nimport static java.util.Collections.*;\\nimport static java.lang.Math.*;\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        HashMap<Integer, Integer> even = new HashMap<>(), odd = new HashMap<>();\\n        int n = nums.length, n1 = 0, n2 = 0;\\n        if(n == 1) return 0;\\n        for(int i = 0; i<nums.length; i++) \\n            if(i%2 == 0) even.merge(nums[i], 1, Integer :: sum); \\n            else odd.merge(nums[i], 1, Integer :: sum);\\n        List<int[]> a = new ArrayList<>(), b = new ArrayList<>();\\n        for(int i : even.keySet()) a.add(new int[]{i, even.get(i)});\\n        for(int i : odd.keySet()) b.add(new int[]{i, odd.get(i)});\\n        sort(a, (x, y) -> y[1] - x[1]);\\n        sort(b, (x, y) -> y[1] - x[1]);\\n        if(a.get(0)[0] != b.get(0)[0]) return n - a.get(0)[1] - b.get(0)[1];\\n        if(a.size() == 1 && b.size() == 1) return min(a.get(0)[1], b.get(0)[1]);\\n        if(a.size() == 1) return n - a.get(0)[1] - b.get(1)[1];\\n        if(b.size() == 1) return n - a.get(1)[1] - b.get(0)[1];\\n        return min(n - a.get(0)[1] - b.get(1)[1], n - a.get(1)[1] - b.get(0)[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport static java.util.Collections.*;\\nimport static java.lang.Math.*;\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        HashMap<Integer, Integer> even = new HashMap<>(), odd = new HashMap<>();\\n        int n = nums.length, n1 = 0, n2 = 0;\\n        if(n == 1) return 0;\\n        for(int i = 0; i<nums.length; i++) \\n            if(i%2 == 0) even.merge(nums[i], 1, Integer :: sum); \\n            else odd.merge(nums[i], 1, Integer :: sum);\\n        List<int[]> a = new ArrayList<>(), b = new ArrayList<>();\\n        for(int i : even.keySet()) a.add(new int[]{i, even.get(i)});\\n        for(int i : odd.keySet()) b.add(new int[]{i, odd.get(i)});\\n        sort(a, (x, y) -> y[1] - x[1]);\\n        sort(b, (x, y) -> y[1] - x[1]);\\n        if(a.get(0)[0] != b.get(0)[0]) return n - a.get(0)[1] - b.get(0)[1];\\n        if(a.size() == 1 && b.size() == 1) return min(a.get(0)[1], b.get(0)[1]);\\n        if(a.size() == 1) return n - a.get(0)[1] - b.get(1)[1];\\n        if(b.size() == 1) return n - a.get(1)[1] - b.get(0)[1];\\n        return min(n - a.get(0)[1] - b.get(1)[1], n - a.get(1)[1] - b.get(0)[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415495,
                "title": "best-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int[] freqEven = new int[100001];\\n        int[] freqOdd = new int[100001];\\n        int n= nums.length;\\n        int max = 0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                freqEven[nums[i]]++;\\n            else\\n                freqOdd[nums[i]]++;\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        int firstMaxEven = 0, freqFirstMaxEven = 0;\\n        int firstMaxOdd = 0, freqFirstMaxOdd = 0;\\n\\n        int secondMaxEven = 0, freqSecondMaxEven = 0;\\n        int secondMaxOdd = 0, freqSecondMaxOdd = 0;\\n\\n        for(int i=1;i<=max;i++){\\n            if(freqEven[i]>freqFirstMaxEven){\\n\\n                secondMaxEven=firstMaxEven;\\n                freqSecondMaxEven=freqFirstMaxEven;\\n\\n                firstMaxEven=i;\\n                freqFirstMaxEven=freqEven[i];\\n\\n                    \\n            }\\n            else if(freqEven[i]>freqSecondMaxEven){\\n                secondMaxEven=i;\\n                freqSecondMaxEven=freqEven[i];\\n            }\\n\\n            if(freqOdd[i]>freqFirstMaxOdd){\\n                secondMaxOdd=firstMaxOdd;\\n                freqSecondMaxOdd=freqFirstMaxOdd;\\n\\n                firstMaxOdd=i;\\n                freqFirstMaxOdd=freqOdd[i];\\n\\n            }\\n            else if(freqOdd[i]>freqSecondMaxOdd){\\n                secondMaxOdd=i;\\n                freqSecondMaxOdd=freqOdd[i];\\n            }\\n        }\\n        System.out.println(firstMaxEven+\":\"+freqFirstMaxEven+\":\"+firstMaxOdd+\":\"+freqFirstMaxOdd);\\n        System.out.println(secondMaxEven+\":\"+freqSecondMaxEven+\":\"+secondMaxOdd+\":\"+freqSecondMaxOdd);\\n\\n        System.out.println(n-freqFirstMaxEven-freqSecondMaxEven);\\n        if(firstMaxEven!=firstMaxOdd)\\n            return n-freqFirstMaxEven-freqFirstMaxOdd;\\n        return Math.min(n-freqFirstMaxEven-freqSecondMaxOdd, n-freqSecondMaxEven-freqFirstMaxOdd);\\n    }\\n}\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int[] freqEven = new int[100001];\\n        int[] freqOdd = new int[100001];\\n        int n= nums.length;\\n        int max = 0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                freqEven[nums[i]]++;\\n            else\\n                freqOdd[nums[i]]++;\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        int firstMaxEven = 0, freqFirstMaxEven = 0;\\n        int firstMaxOdd = 0, freqFirstMaxOdd = 0;\\n\\n        int secondMaxEven = 0, freqSecondMaxEven = 0;\\n        int secondMaxOdd = 0, freqSecondMaxOdd = 0;\\n\\n        for(int i=1;i<=max;i++){\\n            if(freqEven[i]>freqFirstMaxEven){\\n\\n                secondMaxEven=firstMaxEven;\\n                freqSecondMaxEven=freqFirstMaxEven;\\n\\n                firstMaxEven=i;\\n                freqFirstMaxEven=freqEven[i];\\n\\n                    \\n            }\\n            else if(freqEven[i]>freqSecondMaxEven){\\n                secondMaxEven=i;\\n                freqSecondMaxEven=freqEven[i];\\n            }\\n\\n            if(freqOdd[i]>freqFirstMaxOdd){\\n                secondMaxOdd=firstMaxOdd;\\n                freqSecondMaxOdd=freqFirstMaxOdd;\\n\\n                firstMaxOdd=i;\\n                freqFirstMaxOdd=freqOdd[i];\\n\\n            }\\n            else if(freqOdd[i]>freqSecondMaxOdd){\\n                secondMaxOdd=i;\\n                freqSecondMaxOdd=freqOdd[i];\\n            }\\n        }\\n        System.out.println(firstMaxEven+\":\"+freqFirstMaxEven+\":\"+firstMaxOdd+\":\"+freqFirstMaxOdd);\\n        System.out.println(secondMaxEven+\":\"+freqSecondMaxEven+\":\"+secondMaxOdd+\":\"+freqSecondMaxOdd);\\n\\n        System.out.println(n-freqFirstMaxEven-freqSecondMaxEven);\\n        if(firstMaxEven!=firstMaxOdd)\\n            return n-freqFirstMaxEven-freqFirstMaxOdd;\\n        return Math.min(n-freqFirstMaxEven-freqSecondMaxOdd, n-freqSecondMaxEven-freqFirstMaxOdd);\\n    }\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926122,
                "title": "o-n-clean-code-cpp-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Find max and second max in both positions \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Function getMinMax returns { {max,max_no} ,{second_max,second_max_no}}\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // returns first min and \\n    vector<vector<int>> getMinMax(vector<int>& nums,int start){\\n\\n        unordered_map<int,int> freq ;\\n\\n        for(int i=start;i<nums.size();i+=2) freq[nums[i]]++;\\n\\n        int mx =0 , mx_num =-1, second_mx =0 , second_mx_num =-1;\\n\\n        for(auto i :freq){\\n\\n            if(i.second>mx){\\n                \\n                second_mx = mx ;\\n                second_mx_num = mx_num ;\\n                mx = i.second ;\\n                mx_num = i.first ;\\n            }\\n\\n            else if(i.second>second_mx){\\n\\n                second_mx= i.second ;\\n                second_mx_num = i.first;\\n\\n            }\\n\\n        }\\n\\n        return {{mx,mx_num},{second_mx,second_mx_num}};\\n\\n    }\\n\\n    int minimumOperations(vector<int>& nums) {\\n\\n\\n        int even_count = ceil(nums.size()/2.0); // starts with 0\\n\\n        int odd_count = nums.size()/2 ,cost =0;\\n\\n        vector<vector<int>> even = getMinMax(nums,0),odd = getMinMax(nums,1);\\n\\n        if(even[0][1]!=odd[0][1]){\\n\\n            cost = even_count-even[0][0] + odd_count-odd[0][0];\\n\\n        }\\n\\n        else {\\n\\n            // combination of both\\n            // 1 second mx - mx \\n\\n            int second_first = even_count - even[1][0] + odd_count - odd[0][0];\\n\\n            int first_second = even_count - even[0][0] + odd_count - odd[1][0];\\n\\n            cost = min(second_first,first_second);\\n\\n        }\\n\\n        return cost ;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // returns first min and \\n    vector<vector<int>> getMinMax(vector<int>& nums,int start){\\n\\n        unordered_map<int,int> freq ;\\n\\n        for(int i=start;i<nums.size();i+=2) freq[nums[i]]++;\\n\\n        int mx =0 , mx_num =-1, second_mx =0 , second_mx_num =-1;\\n\\n        for(auto i :freq){\\n\\n            if(i.second>mx){\\n                \\n                second_mx = mx ;\\n                second_mx_num = mx_num ;\\n                mx = i.second ;\\n                mx_num = i.first ;\\n            }\\n\\n            else if(i.second>second_mx){\\n\\n                second_mx= i.second ;\\n                second_mx_num = i.first;\\n\\n            }\\n\\n        }\\n\\n        return {{mx,mx_num},{second_mx,second_mx_num}};\\n\\n    }\\n\\n    int minimumOperations(vector<int>& nums) {\\n\\n\\n        int even_count = ceil(nums.size()/2.0); // starts with 0\\n\\n        int odd_count = nums.size()/2 ,cost =0;\\n\\n        vector<vector<int>> even = getMinMax(nums,0),odd = getMinMax(nums,1);\\n\\n        if(even[0][1]!=odd[0][1]){\\n\\n            cost = even_count-even[0][0] + odd_count-odd[0][0];\\n\\n        }\\n\\n        else {\\n\\n            // combination of both\\n            // 1 second mx - mx \\n\\n            int second_first = even_count - even[1][0] + odd_count - odd[0][0];\\n\\n            int first_second = even_count - even[0][0] + odd_count - odd[1][0];\\n\\n            cost = min(second_first,first_second);\\n\\n        }\\n\\n        return cost ;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526505,
                "title": "python-counter-solution",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd_counter, even_counter = collections.defaultdict(int), collections.defaultdict(int)\\n        n = len(nums)\\n        for i, num in enumerate(nums):\\n            if i % 2 == 0:\\n                even_counter[num] += 1\\n            else:\\n                odd_counter[num] += 1\\n        \\n        def find_top_2(counter):\\n            max_num, second_max_num = 0, 0\\n            max_count, second_max_count = 0, 0\\n            \\n            for num, count in counter.items():\\n                if count > max_count:\\n                    second_max_count = max_count\\n                    second_max_num = max_num\\n                    max_count = count\\n                    max_num = num\\n                elif count > second_max_count:\\n                    second_max_count = count\\n                    second_max_num = num\\n            return max_num, second_max_num\\n            \\n        max_even, second_even = find_top_2(even_counter)\\n        max_odd, second_odd = find_top_2(odd_counter)\\n\\n        if max_even != max_odd:\\n            return n - (even_counter[max_even] + odd_counter[max_odd])\\n        else:\\n            return n - max(even_counter[max_even] + odd_counter[second_odd], odd_counter[max_odd] + even_counter[second_even]) \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd_counter, even_counter = collections.defaultdict(int), collections.defaultdict(int)\\n        n = len(nums)\\n        for i, num in enumerate(nums):\\n            if i % 2 == 0:\\n                even_counter[num] += 1\\n            else:\\n                odd_counter[num] += 1\\n        \\n        def find_top_2(counter):\\n            max_num, second_max_num = 0, 0\\n            max_count, second_max_count = 0, 0\\n            \\n            for num, count in counter.items():\\n                if count > max_count:\\n                    second_max_count = max_count\\n                    second_max_num = max_num\\n                    max_count = count\\n                    max_num = num\\n                elif count > second_max_count:\\n                    second_max_count = count\\n                    second_max_num = num\\n            return max_num, second_max_num\\n            \\n        max_even, second_even = find_top_2(even_counter)\\n        max_odd, second_odd = find_top_2(odd_counter)\\n\\n        if max_even != max_odd:\\n            return n - (even_counter[max_even] + odd_counter[max_odd])\\n        else:\\n            return n - max(even_counter[max_even] + odd_counter[second_odd], odd_counter[max_odd] + even_counter[second_even]) \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506064,
                "title": "optimal-c-solution-beats-97-45-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int freq[100005][2];\\n    \\n    int minimumOperations(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        memset(freq, 0, sizeof(freq));\\n        int n = nums.size(), i, j, k, ans = 0;\\n        for(i = 0; i < n; i++) freq[nums[i]][i&1]++;\\n        for(i=1, j=0, k = 0; i <= 100000; i++) {\\n            ans = max(ans, max(freq[i][0]+k, freq[i][1]+j));\\n            j = max(j, freq[i][0]);\\n            k = max(k, freq[i][1]);\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int freq[100005][2];\\n    \\n    int minimumOperations(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        memset(freq, 0, sizeof(freq));\\n        int n = nums.size(), i, j, k, ans = 0;\\n        for(i = 0; i < n; i++) freq[nums[i]][i&1]++;\\n        for(i=1, j=0, k = 0; i <= 100000; i++) {\\n            ans = max(ans, max(freq[i][0]+k, freq[i][1]+j));\\n            j = max(j, freq[i][0]);\\n            k = max(k, freq[i][1]);\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2452638,
                "title": "java-frequency-maps-and-priorityqueues",
                "content": "You can think of this array as containing two subarrays, `a` and `b`. First create a frequency map for each of these subarrays. Then we will create a max PriorityQueue for each subarray, which will then be sorted by the VALUE of the most frequent element.\\n\\nIf the values of `a` and `b`\\'s most frequent element are different, we can immediately return the length of the array minus the frequencies of these two elements. The edge case is when the most frequent elements are the same. In this case we must find the second max value for each subarray, and then return the answer that minimizes the number of operations.\\n\\n```\\npublic int minimumOperations(int[] nums) {\\n        if (nums.length == 1) {\\n            return 0;\\n        }\\n        \\n        // Create frequency maps for both sections\\n        final Map<Integer, Integer> aFreq = new HashMap<>();\\n        final Map<Integer, Integer> bFreq = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (i % 2 == 0) {\\n                aFreq.put(num, aFreq.getOrDefault(num, 0) + 1);\\n            } else {\\n                bFreq.put(num, bFreq.getOrDefault(num, 0) + 1);\\n            }\\n        }\\n        \\n        // Create PriorityQueues of the most frequent elements\\n        PriorityQueue<Integer> aQ = new PriorityQueue<>(10, (a,b) -> Integer.compare(aFreq.get(b), aFreq.get(a)));\\n        PriorityQueue<Integer> bQ = new PriorityQueue<>(10, (a,b) -> Integer.compare(bFreq.get(b), bFreq.get(a)));\\n        for (Map.Entry<Integer, Integer> e: aFreq.entrySet()) {\\n            aQ.offer(e.getKey());\\n        }\\n        for (Map.Entry<Integer, Integer> e: bFreq.entrySet()) {\\n            bQ.offer(e.getKey());\\n        }\\n        \\n        // Get maximums, check if they differ. If they do, check the secondmost frequent element\\n        int aMaxNum = aQ.poll();\\n        int aMaxFreq = aFreq.get(aMaxNum);\\n        int bMaxNum = bQ.poll();\\n        int bMaxFreq = bFreq.get(bMaxNum);\\n        if (aMaxNum != bMaxNum) {\\n            return nums.length - aMaxFreq - bMaxFreq;\\n        } else {\\n            int bSecondFreq = 0;\\n            int aSecondFreq = 0;\\n            if (!bQ.isEmpty()) {\\n                bSecondFreq = bFreq.get(bQ.poll());\\n            }\\n            if (!aQ.isEmpty()) {\\n                aSecondFreq = aFreq.get(aQ.poll());\\n            }\\n            return Math.min(nums.length - aMaxFreq - bSecondFreq, nums.length - bMaxFreq - aSecondFreq);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "You can think of this array as containing two subarrays, `a` and `b`. First create a frequency map for each of these subarrays. Then we will create a max PriorityQueue for each subarray, which will then be sorted by the VALUE of the most frequent element.\\n\\nIf the values of `a` and `b`\\'s most frequent element are different, we can immediately return the length of the array minus the frequencies of these two elements. The edge case is when the most frequent elements are the same. In this case we must find the second max value for each subarray, and then return the answer that minimizes the number of operations.\\n\\n```\\npublic int minimumOperations(int[] nums) {\\n        if (nums.length == 1) {\\n            return 0;\\n        }\\n        \\n        // Create frequency maps for both sections\\n        final Map<Integer, Integer> aFreq = new HashMap<>();\\n        final Map<Integer, Integer> bFreq = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (i % 2 == 0) {\\n                aFreq.put(num, aFreq.getOrDefault(num, 0) + 1);\\n            } else {\\n                bFreq.put(num, bFreq.getOrDefault(num, 0) + 1);\\n            }\\n        }\\n        \\n        // Create PriorityQueues of the most frequent elements\\n        PriorityQueue<Integer> aQ = new PriorityQueue<>(10, (a,b) -> Integer.compare(aFreq.get(b), aFreq.get(a)));\\n        PriorityQueue<Integer> bQ = new PriorityQueue<>(10, (a,b) -> Integer.compare(bFreq.get(b), bFreq.get(a)));\\n        for (Map.Entry<Integer, Integer> e: aFreq.entrySet()) {\\n            aQ.offer(e.getKey());\\n        }\\n        for (Map.Entry<Integer, Integer> e: bFreq.entrySet()) {\\n            bQ.offer(e.getKey());\\n        }\\n        \\n        // Get maximums, check if they differ. If they do, check the secondmost frequent element\\n        int aMaxNum = aQ.poll();\\n        int aMaxFreq = aFreq.get(aMaxNum);\\n        int bMaxNum = bQ.poll();\\n        int bMaxFreq = bFreq.get(bMaxNum);\\n        if (aMaxNum != bMaxNum) {\\n            return nums.length - aMaxFreq - bMaxFreq;\\n        } else {\\n            int bSecondFreq = 0;\\n            int aSecondFreq = 0;\\n            if (!bQ.isEmpty()) {\\n                bSecondFreq = bFreq.get(bQ.poll());\\n            }\\n            if (!aQ.isEmpty()) {\\n                aSecondFreq = aFreq.get(aQ.poll());\\n            }\\n            return Math.min(nums.length - aMaxFreq - bSecondFreq, nums.length - bMaxFreq - aSecondFreq);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2158400,
                "title": "can-anyone-tell-me-whats-wrong-here",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinOp(vector<int>&nums){\\n        unordered_map<int,int>odd,even;\\n        int maxOdd=0, maxEven=0;\\n        int smEven=0,smOdd=0;\\n        int mxO=0,mxE=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i=i+2){\\n            odd[nums[i]]++;  \\n            if(odd[nums[i]]>maxOdd) mxO=nums[i];\\n            maxOdd=max(maxOdd,odd[nums[i]]);\\n        } \\n        for(int i=1;i<n;i=i+2){\\n            even[nums[i]]++;  \\n            if(even[nums[i]]>maxEven) mxE=nums[i];\\n            maxEven=max(maxEven,even[nums[i]]);\\n        } \\n        for(auto it:even){\\n            if(it.second<maxEven && it.second>smEven) smEven=it.second;\\n        }\\n        for(auto it:odd){\\n            if(it.second<maxOdd && it.second>smOdd) smOdd=it.second;\\n        }\\n        \\n        int oddF=(n%2)?n/2+1:n/2;\\n        int evenF=n/2;\\n        if(mxO!=mxE) return oddF-maxOdd+evenF-maxEven;\\n        return min(oddF-maxOdd+evenF-smEven,oddF-smOdd+evenF-maxEven);\\n    }\\n    \\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        return getMinOp(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinOp(vector<int>&nums){\\n        unordered_map<int,int>odd,even;\\n        int maxOdd=0, maxEven=0;\\n        int smEven=0,smOdd=0;\\n        int mxO=0,mxE=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i=i+2){\\n            odd[nums[i]]++;  \\n            if(odd[nums[i]]>maxOdd) mxO=nums[i];\\n            maxOdd=max(maxOdd,odd[nums[i]]);\\n        } \\n        for(int i=1;i<n;i=i+2){\\n            even[nums[i]]++;  \\n            if(even[nums[i]]>maxEven) mxE=nums[i];\\n            maxEven=max(maxEven,even[nums[i]]);\\n        } \\n        for(auto it:even){\\n            if(it.second<maxEven && it.second>smEven) smEven=it.second;\\n        }\\n        for(auto it:odd){\\n            if(it.second<maxOdd && it.second>smOdd) smOdd=it.second;\\n        }\\n        \\n        int oddF=(n%2)?n/2+1:n/2;\\n        int evenF=n/2;\\n        if(mxO!=mxE) return oddF-maxOdd+evenF-maxEven;\\n        return min(oddF-maxOdd+evenF-smEven,oddF-smOdd+evenF-maxEven);\\n    }\\n    \\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        return getMinOp(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104438,
                "title": "javascript-solution",
                "content": "```\\nvar minimumOperations = function(nums) {\\n    const n = nums.length;\\n\\n    const evens = new Map();\\n    const odds = new Map();\\n\\n    for (let i = 0; i < n; ++i) {\\n        const num = nums[i];\\n\\n        if (i % 2 === 0) {\\n            if (!evens.has(num)) evens.set(num, 0);\\n            evens.set(num, evens.get(num) + 1);\\n        }\\n        else {\\n            if (!odds.has(num)) odds.set(num, 0);\\n            odds.set(num, odds.get(num) + 1);\\n        }\\n    }\\n\\n    \\n    const evenLen = Math.floor((n + 1)/ 2);\\n    const oddLen = Math.floor(n / 2);\\n    \\n    const [ maxEven1,  maxEven2 ] = getTopTwoFreqNums(evens);\\n    const [ maxOdd1, maxOdd2 ] = getTopTwoFreqNums(odds);\\n    \\n    if (maxEven1.num != maxOdd1.num) {\\n        return (evenLen - maxEven1.count) + (oddLen - maxOdd1.count);\\n    }\\n    \\n    return Math.min((evenLen - maxEven1.count) + (oddLen - maxOdd2.count), (evenLen - maxEven2.count) + (oddLen - maxOdd1.count));\\n \\n    \\n    \\n    function getTopTwoFreqNums(counts) {\\n        let maxNum1 = null;\\n        let maxCount1 = 0;\\n\\n        let maxNum2 = null;\\n        let maxCount2 = 0;\\n\\n\\n        for (const [currNum, currCount] of counts) {\\n            if (maxNum1 == null || currCount > maxCount1) {\\n                maxNum2 = maxCount1;\\n                maxCount2 = maxCount1;\\n\\n                maxNum1 = currNum;\\n                maxCount1 = currCount;\\n            }\\n            else if (maxNum2 == null || currCount > maxCount2) {\\n                maxNum2 = currNum;\\n                maxCount2 = currCount;\\n            }\\n        }\\n\\n        return [{ num: maxNum1, count: maxCount1 }, { num: maxNum2, count: maxCount2 }];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumOperations = function(nums) {\\n    const n = nums.length;\\n\\n    const evens = new Map();\\n    const odds = new Map();\\n\\n    for (let i = 0; i < n; ++i) {\\n        const num = nums[i];\\n\\n        if (i % 2 === 0) {\\n            if (!evens.has(num)) evens.set(num, 0);\\n            evens.set(num, evens.get(num) + 1);\\n        }\\n        else {\\n            if (!odds.has(num)) odds.set(num, 0);\\n            odds.set(num, odds.get(num) + 1);\\n        }\\n    }\\n\\n    \\n    const evenLen = Math.floor((n + 1)/ 2);\\n    const oddLen = Math.floor(n / 2);\\n    \\n    const [ maxEven1,  maxEven2 ] = getTopTwoFreqNums(evens);\\n    const [ maxOdd1, maxOdd2 ] = getTopTwoFreqNums(odds);\\n    \\n    if (maxEven1.num != maxOdd1.num) {\\n        return (evenLen - maxEven1.count) + (oddLen - maxOdd1.count);\\n    }\\n    \\n    return Math.min((evenLen - maxEven1.count) + (oddLen - maxOdd2.count), (evenLen - maxEven2.count) + (oddLen - maxOdd1.count));\\n \\n    \\n    \\n    function getTopTwoFreqNums(counts) {\\n        let maxNum1 = null;\\n        let maxCount1 = 0;\\n\\n        let maxNum2 = null;\\n        let maxCount2 = 0;\\n\\n\\n        for (const [currNum, currCount] of counts) {\\n            if (maxNum1 == null || currCount > maxCount1) {\\n                maxNum2 = maxCount1;\\n                maxCount2 = maxCount1;\\n\\n                maxNum1 = currNum;\\n                maxCount1 = currCount;\\n            }\\n            else if (maxNum2 == null || currCount > maxCount2) {\\n                maxNum2 = currNum;\\n                maxCount2 = currCount;\\n            }\\n        }\\n\\n        return [{ num: maxNum1, count: maxCount1 }, { num: maxNum2, count: maxCount2 }];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047952,
                "title": "python-hashmap-simple-solution-with-explanation",
                "content": "### Logic:\\n1. As per the hints given for the problem, To minimize the number of operations we need to maximize the number of elements we keep from the original array. We will use this hint to build our solution.\\n2. Check the below examples-\\n\\t- Let\\'s say we have an array [1,2,3,4,5] and one of the possible alternating array of this with minimum operations could be [1,2,1,2,1] (minimum operations: 3)\\n\\t- Let\\'s say we have another array [1,2,1,2,4,2] and one of the possible alternating array of this with minimum operations could be [1,2,1,2,1,2] (minimum operations: 1)\\n\\t- Let\\'s say we have another array [1,1,1,1,1,5,3,4,3] and one of the possible alternating array of this with minimum operations could be [3,1,3,1,3,1,3,1,3] (minimum operations: 5)\\n3. What are we actually doing? We are actually calculating the minimum number of elements that needs to be altered to make the array alternating **OR** We are actually calculating the number of elements that need **not** to altered to make the array alternating.\\n4. Below three conditions need to be satisfied for all elements of array:\\n\\t- Elements present at even index should be same.\\n\\t- Elements present at odd index should be same\\n\\t- Adjacent elements should not be same\\n5. Now look closely at the above examples:-\\n\\t- For example 2.a: Since all the numbers are different, we could fix any element at any even index and other element at any odd index. Let\\'s say the elements present at 0th and 1st index are fixed and remaining elements are altered accordingly. Minimum number of operations required could be deduced as => len(nums) - max frequency of a number present at even index - max frequency of a number present at odd index, i.e., 5 - 1 - 1 = 3\\n\\t- For example 2.b, we see that the max frequency for odd indexes is 3 for element 2 and max frequency for even indexes is 2 for element 1 and since the elements having the max frequency are not same so we should fix these elements and alter others. Therefore, minimum number of operations required => len(nums) - max frequency of a number present at even index - max frequency of a number present at odd index, i.e., 6 - 3 - 2 = 1\\n\\t- For example 2.c, we see that the max frequency for odd indexes is 2 for element 1 and max frequency for even indexes is 3 for element 1 and since the elements having the max frequency are same so we can\\'t  fix these elements and alter others because it would contradict pt. 4.c. Therefore, we need to calculate the second maximum frequency for even and odd index. The second maximum frequency for odd index is 1 for element 5 and second maximum frequency for even index is 2 for element 3. Therefore, minimum number of operations required => len(nums) - **max**((max frequency of a number present at even index + second max frequency present at odd index), (max frequency of a number present at odd index + second max frequency of a number present at even index)), i.e., 9 - max(3+1, 2+2) = 9 - 4 = 5\\n\\n\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even, odd = {}, {}\\n        maxEvenFreq, maxOddFreq = [None, 0], [None, 0]\\n        secondMaxEvenFreq, secondMaxOddFreq = [None, 0], [None, 0]\\n        \\n        for i, num in enumerate(nums):\\n            if i & 1:\\n                if num in odd:\\n                    odd[num] += 1\\n                else:\\n                    odd[num] = 1\\n            else:\\n                if num in even:\\n                    even[num] += 1\\n                else:\\n                    even[num] = 1\\n\\n        for num in odd:\\n            if odd[num] > maxOddFreq[1]:\\n                maxOddFreq, secondMaxOddFreq = [num, odd[num]], maxOddFreq\\n            elif odd[num] > secondMaxOddFreq[1]:\\n                secondMaxOddFreq = [num, odd[num]]\\n        \\n        for num in even:\\n            if even[num] > maxEvenFreq[1]:\\n                maxEvenFreq, secondMaxEvenFreq = [num, even[num]], maxEvenFreq\\n            elif even[num] > secondMaxEvenFreq[1]:\\n                secondMaxEvenFreq = [num, even[num]]\\n        \\n        if maxEvenFreq[0] != maxOddFreq[0]:\\n            return len(nums) - (maxEvenFreq[1] + maxOddFreq[1])\\n        else:\\n            return len(nums) - max(maxEvenFreq[1] + secondMaxOddFreq[1],  maxOddFreq[1] + secondMaxEvenFreq[1])\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even, odd = {}, {}\\n        maxEvenFreq, maxOddFreq = [None, 0], [None, 0]\\n        secondMaxEvenFreq, secondMaxOddFreq = [None, 0], [None, 0]\\n        \\n        for i, num in enumerate(nums):\\n            if i & 1:\\n                if num in odd:\\n                    odd[num] += 1\\n                else:\\n                    odd[num] = 1\\n            else:\\n                if num in even:\\n                    even[num] += 1\\n                else:\\n                    even[num] = 1\\n\\n        for num in odd:\\n            if odd[num] > maxOddFreq[1]:\\n                maxOddFreq, secondMaxOddFreq = [num, odd[num]], maxOddFreq\\n            elif odd[num] > secondMaxOddFreq[1]:\\n                secondMaxOddFreq = [num, odd[num]]\\n        \\n        for num in even:\\n            if even[num] > maxEvenFreq[1]:\\n                maxEvenFreq, secondMaxEvenFreq = [num, even[num]], maxEvenFreq\\n            elif even[num] > secondMaxEvenFreq[1]:\\n                secondMaxEvenFreq = [num, even[num]]\\n        \\n        if maxEvenFreq[0] != maxOddFreq[0]:\\n            return len(nums) - (maxEvenFreq[1] + maxOddFreq[1])\\n        else:\\n            return len(nums) - max(maxEvenFreq[1] + secondMaxOddFreq[1],  maxOddFreq[1] + secondMaxEvenFreq[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016495,
                "title": "java-solution",
                "content": "![image](https://assets.leetcode.com/users/images/77f1fb3b-be26-4aac-afc2-e5e47b51aa99_1651929088.890157.png)\\n\\n```java\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int even_max=0; //Maximum Value at Even Index\\n        int odd_max=0; //Minimum Value at Even Index\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i%2==0&&nums[i]>even_max)\\n                even_max=nums[i];\\n            else if(i%2==1&&nums[i]>odd_max)\\n                odd_max=nums[i];\\n        }\\n        \\n        int[] a = new int[even_max+1]; //Even Indices Mapping\\n        int[] b = new int[odd_max+1]; //Odd Indices Mapping\\n        \\n        for(int i=0;i<nums.length;i+=2)\\n            a[nums[i]]++;\\n        for(int i=1;i<nums.length;i+=2)\\n            b[nums[i]]++;\\n        \\n        int even_max_count=0; //Even Index Maximum Count \\n        int even_max_value=a[0]; //Value Having Maximum Count at Even Index \\n        int prev_even=0; //Even Index Second Maximum Count \\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(even_max_count<a[i])\\n            {\\n                 even_max_count=a[i];\\n                 even_max_value=i;\\n            }      \\n        }\\n        for(int i=0;i<a.length;i++)\\n        {\\n           if(prev_even<a[i]&&i!=even_max_value)\\n                prev_even=a[i];     \\n        }\\n        int odd_max_count=0; //Odd Index Maximum Count \\n        int odd_max_value=b[0]; //Value Having Maximum Count at Odd Index \\n        int prev_odd=0; //Odd Index Second Maximum Count \\n        \\n        for(int i=0;i<b.length;i++)\\n        {\\n            if(odd_max_count<b[i])\\n            {\\n                 odd_max_count=b[i];\\n                 odd_max_value=i;\\n            }  \\n        }\\n        for(int i=0;i<b.length;i++)\\n        {\\n            if(prev_odd<b[i]&&i!=odd_max_value)\\n                prev_odd=b[i]; \\n        }\\n        \\n        if(even_max_value==odd_max_value)\\nreturn Math.min(nums.length-odd_max_count-prev_even,nums.length-even_max_count-prev_odd);\\n        else\\n        return nums.length-even_max_count-odd_max_count;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int even_max=0; //Maximum Value at Even Index\\n        int odd_max=0; //Minimum Value at Even Index\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i%2==0&&nums[i]>even_max)\\n                even_max=nums[i];\\n            else if(i%2==1&&nums[i]>odd_max)\\n                odd_max=nums[i];\\n        }\\n        \\n        int[] a = new int[even_max+1]; //Even Indices Mapping\\n        int[] b = new int[odd_max+1]; //Odd Indices Mapping\\n        \\n        for(int i=0;i<nums.length;i+=2)\\n            a[nums[i]]++;\\n        for(int i=1;i<nums.length;i+=2)\\n            b[nums[i]]++;\\n        \\n        int even_max_count=0; //Even Index Maximum Count \\n        int even_max_value=a[0]; //Value Having Maximum Count at Even Index \\n        int prev_even=0; //Even Index Second Maximum Count \\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(even_max_count<a[i])\\n            {\\n                 even_max_count=a[i];\\n                 even_max_value=i;\\n            }      \\n        }\\n        for(int i=0;i<a.length;i++)\\n        {\\n           if(prev_even<a[i]&&i!=even_max_value)\\n                prev_even=a[i];     \\n        }\\n        int odd_max_count=0; //Odd Index Maximum Count \\n        int odd_max_value=b[0]; //Value Having Maximum Count at Odd Index \\n        int prev_odd=0; //Odd Index Second Maximum Count \\n        \\n        for(int i=0;i<b.length;i++)\\n        {\\n            if(odd_max_count<b[i])\\n            {\\n                 odd_max_count=b[i];\\n                 odd_max_value=i;\\n            }  \\n        }\\n        for(int i=0;i<b.length;i++)\\n        {\\n            if(prev_odd<b[i]&&i!=odd_max_value)\\n                prev_odd=b[i]; \\n        }\\n        \\n        if(even_max_value==odd_max_value)\\nreturn Math.min(nums.length-odd_max_count-prev_even,nums.length-even_max_count-prev_odd);\\n        else\\n        return nums.length-even_max_count-odd_max_count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896484,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nint minimumOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpe;\\n        \\n        unordered_map<int, int> mpo;\\n        \\n        for(int i = 0; i < n; i += 2)\\n        {\\n            mpe[nums[i]]++;\\n        }\\n        \\n        for(int i = 1; i < n; i += 2)\\n        {\\n            mpo[nums[i]]++;\\n        }\\n        \\n        int even_first_max_val = 0;\\n        \\n        int even_first_max_freq = 0;\\n        \\n        int even_second_max_val = 0;\\n        \\n        int even_second_max_freq = 0;\\n        \\n        \\n        \\n        for(auto x : mpe)\\n        {\\n            if(x.second >= even_first_max_freq)\\n            {\\n                even_second_max_freq = even_first_max_freq;\\n                \\n                even_second_max_val = even_first_max_val;\\n                \\n                even_first_max_val = x.first;\\n                \\n                even_first_max_freq = x.second;\\n            }\\n            \\n            else if(x.second > even_second_max_freq)\\n            {\\n                even_second_max_freq = x.second;\\n                \\n                even_second_max_val = x.first;\\n            }\\n        }\\n        \\n        int odd_first_max_val = 0;\\n        \\n        int odd_first_max_freq = 0;\\n        \\n        int odd_second_max_val = 0;\\n        \\n        int odd_second_max_freq = 0;\\n        \\n        for(auto x : mpo)\\n        {\\n            if(x.second >= odd_first_max_freq)\\n            {\\n                odd_second_max_freq = odd_first_max_freq;\\n                \\n                odd_second_max_val = odd_first_max_val;\\n                \\n                odd_first_max_val = x.first;\\n                \\n                odd_first_max_freq = x.second;\\n            }\\n            \\n            else if(x.second > odd_second_max_freq)\\n            {\\n                odd_second_max_freq = x.second;\\n                \\n                odd_second_max_val = x.first;\\n            }\\n        }\\n        \\n        if(even_first_max_val != odd_first_max_val)\\n        {\\n            return n - even_first_max_freq - odd_first_max_freq;\\n        }\\n        \\n        else if(even_first_max_val == odd_first_max_val)\\n        {\\n            return n - max({even_first_max_freq + odd_second_max_freq, even_second_max_freq + odd_first_max_freq});\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int, int> mpe;\\n        \\n        unordered_map<int, int> mpo;\\n        \\n        for(int i = 0; i < n; i += 2)\\n        {\\n            mpe[nums[i]]++;\\n        }\\n        \\n        for(int i = 1; i < n; i += 2)\\n        {\\n            mpo[nums[i]]++;\\n        }\\n        \\n        int even_first_max_val = 0;\\n        \\n        int even_first_max_freq = 0;\\n        \\n        int even_second_max_val = 0;\\n        \\n        int even_second_max_freq = 0;\\n        \\n        \\n        \\n        for(auto x : mpe)\\n        {\\n            if(x.second >= even_first_max_freq)\\n            {\\n                even_second_max_freq = even_first_max_freq;\\n                \\n                even_second_max_val = even_first_max_val;\\n                \\n                even_first_max_val = x.first;\\n                \\n                even_first_max_freq = x.second;\\n            }\\n            \\n            else if(x.second > even_second_max_freq)\\n            {\\n                even_second_max_freq = x.second;\\n                \\n                even_second_max_val = x.first;\\n            }\\n        }\\n        \\n        int odd_first_max_val = 0;\\n        \\n        int odd_first_max_freq = 0;\\n        \\n        int odd_second_max_val = 0;\\n        \\n        int odd_second_max_freq = 0;\\n        \\n        for(auto x : mpo)\\n        {\\n            if(x.second >= odd_first_max_freq)\\n            {\\n                odd_second_max_freq = odd_first_max_freq;\\n                \\n                odd_second_max_val = odd_first_max_val;\\n                \\n                odd_first_max_val = x.first;\\n                \\n                odd_first_max_freq = x.second;\\n            }\\n            \\n            else if(x.second > odd_second_max_freq)\\n            {\\n                odd_second_max_freq = x.second;\\n                \\n                odd_second_max_val = x.first;\\n            }\\n        }\\n        \\n        if(even_first_max_val != odd_first_max_val)\\n        {\\n            return n - even_first_max_freq - odd_first_max_freq;\\n        }\\n        \\n        else if(even_first_max_val == odd_first_max_val)\\n        {\\n            return n - max({even_first_max_freq + odd_second_max_freq, even_second_max_freq + odd_first_max_freq});\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1883980,
                "title": "python-faster-than-98-87",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        odd = collections.Counter(nums[::2])\\n        even = collections.Counter(nums[1::2])\\n        \\n        if len(odd) == len(even) == 1:\\n            if odd.keys() == even.keys():\\n                return N//2\\n            else:\\n                return 0\\n        \\n        odd_top = heapq.nlargest(2, odd, key = odd.get)\\n        even_top = heapq.nlargest(2, even, key = even.get)\\n        total_evens = N // 2\\n        total_odds = (N+1) // 2\\n        \\n        if not (len(odd_top) >= 1 and len(even_top) >= 1):\\n            return 0\\n        \\n        # top element in odd is different from top element in even\\n        if odd_top[0] != even_top[0]:\\n            return total_evens - even[even_top[0]] + total_odds - odd[odd_top[0]]\\n        \\n        # top element in odd is same as top element in even\\n        # I can either change all elements in odd to second most, and all elements in even to most common\\n        # or I can change all elements in odd to most common, and all elements in even to second most common\\n        res = N\\n        if len(odd_top) == 2:\\n            res = min(res, total_odds - odd[odd_top[1]] + total_evens - even[even_top[0]])\\n            \\n        if len(even_top) == 2:\\n            res = min(res, total_odds - odd[odd_top[0]] + total_evens - even[even_top[1]])\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        odd = collections.Counter(nums[::2])\\n        even = collections.Counter(nums[1::2])\\n        \\n        if len(odd) == len(even) == 1:\\n            if odd.keys() == even.keys():\\n                return N//2\\n            else:\\n                return 0\\n        \\n        odd_top = heapq.nlargest(2, odd, key = odd.get)\\n        even_top = heapq.nlargest(2, even, key = even.get)\\n        total_evens = N // 2\\n        total_odds = (N+1) // 2\\n        \\n        if not (len(odd_top) >= 1 and len(even_top) >= 1):\\n            return 0\\n        \\n        # top element in odd is different from top element in even\\n        if odd_top[0] != even_top[0]:\\n            return total_evens - even[even_top[0]] + total_odds - odd[odd_top[0]]\\n        \\n        # top element in odd is same as top element in even\\n        # I can either change all elements in odd to second most, and all elements in even to most common\\n        # or I can change all elements in odd to most common, and all elements in even to second most common\\n        res = N\\n        if len(odd_top) == 2:\\n            res = min(res, total_odds - odd[odd_top[1]] + total_evens - even[even_top[0]])\\n            \\n        if len(even_top) == 2:\\n            res = min(res, total_odds - odd[odd_top[0]] + total_evens - even[even_top[1]])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826848,
                "title": "python-frequency-counter",
                "content": "1. Count frequency separately for numbers at odd indices and even indices\\n2. Find the top 2 frequent numbers from odds and evens\\n3. Calculate\\n\\t* If `the most frequent number at even index != the most frequent number at odd index`, then the operation number is `(total_evens - frequency[most_freq_even_num]) + (total_odds - frequency[most_freq_odd_num])`\\n\\t* If they are the same, then we try combinations of `(most_freq_even, second_most_freq_odd)` and `(second_most_freq_even, most_freq_odd)`\\n\\t* There might be cases where the second most does not exist. In that case, we can try to replace all the numbers at odd/even indices\\n\\n\\n```python\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n\\t\\t# step 1\\n        size = len(nums)\\n        if size <= 1: return 0\\n        from collections import Counter\\n        odds, evens = Counter(), Counter()\\n        for index, num in enumerate(nums):\\n            if index % 2 == 0:\\n                evens[num] += 1\\n            else:\\n                odds[num] += 1\\n\\t\\t\\n        total_evens = size // 2 + size % 2\\n        total_odds = size - total_evens\\n\\t\\t# step 2\\n        common_evens = evens.most_common(2)\\n        common_odds = odds.most_common(2)\\n\\t\\t# step 3.1\\n        if common_evens[0][0] != common_odds[0][0]:\\n            return total_evens - common_evens[0][1] + total_odds - common_odds[0][1]\\n\\t\\t# step 3.3. Replace all odds or all evens\\n        min_moves = min(total_evens - common_evens[0][1] + total_odds,\\n                        total_odds - common_odds[0][1] + total_evens)\\n        if len(common_odds) > 1: # step 3.2, (most_freq_even, second_most_freq_odd)\\n            min_moves = min(min_moves, \\n                            total_evens - common_evens[0][1] + total_odds - common_odds[1][1])\\n        if len(common_evens) > 1: # step 3.2, (second_most_freq_even, most_freq_odd)\\n            min_moves = min(min_moves, \\n                            total_evens - common_evens[1][1] + total_odds - common_odds[0][1])\\n        return min_moves\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n\\t\\t# step 1\\n        size = len(nums)\\n        if size <= 1: return 0\\n        from collections import Counter\\n        odds, evens = Counter(), Counter()\\n        for index, num in enumerate(nums):\\n            if index % 2 == 0:\\n                evens[num] += 1\\n            else:\\n                odds[num] += 1\\n\\t\\t\\n        total_evens = size // 2 + size % 2\\n        total_odds = size - total_evens\\n\\t\\t# step 2\\n        common_evens = evens.most_common(2)\\n        common_odds = odds.most_common(2)\\n\\t\\t# step 3.1\\n        if common_evens[0][0] != common_odds[0][0]:\\n            return total_evens - common_evens[0][1] + total_odds - common_odds[0][1]\\n\\t\\t# step 3.3. Replace all odds or all evens\\n        min_moves = min(total_evens - common_evens[0][1] + total_odds,\\n                        total_odds - common_odds[0][1] + total_evens)\\n        if len(common_odds) > 1: # step 3.2, (most_freq_even, second_most_freq_odd)\\n            min_moves = min(min_moves, \\n                            total_evens - common_evens[0][1] + total_odds - common_odds[1][1])\\n        if len(common_evens) > 1: # step 3.2, (second_most_freq_even, most_freq_odd)\\n            min_moves = min(min_moves, \\n                            total_evens - common_evens[1][1] + total_odds - common_odds[0][1])\\n        return min_moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790779,
                "title": "java-frequencies-hashmap",
                "content": "```\\nclass Solution \\n{\\n    public int minimumOperations(int[] nums) \\n    {\\n        HashMap<Integer,Integer> evenmap = new HashMap<Integer,Integer>();\\n        HashMap<Integer,Integer> oddmap = new HashMap<Integer,Integer>();\\n        for(int i = 0 ; i < nums.length; i++)\\n        {\\n            if(i%2==0) evenmap.put(nums[i],evenmap.getOrDefault(nums[i],0)+1);\\n            else oddmap.put(nums[i],oddmap.getOrDefault(nums[i],0)+1);\\n        }\\n        int freqfirstmaxEven = 0;\\n        int freqsecondmaxEven = 0;\\n        int firstmaxEven = 0;\\n        int secondmaxEven = 0;\\n        System.out.println(evenmap);\\n        System.out.println(oddmap);\\n        for(Map.Entry<Integer,Integer>entry:evenmap.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int freq = entry.getValue();\\n            if(freq>freqfirstmaxEven)\\n            {\\n                freqsecondmaxEven = freqfirstmaxEven;\\n                secondmaxEven = firstmaxEven;\\n                freqfirstmaxEven = freq;\\n                firstmaxEven = key;\\n            }\\n            else if(freq>freqsecondmaxEven)\\n            {\\n                freqsecondmaxEven = freq;\\n                secondmaxEven = key;\\n            }\\n        }\\n        System.out.println(firstmaxEven+\"  \"+secondmaxEven+\"   frequencies  \"+freqfirstmaxEven+\"  \"+freqsecondmaxEven);\\n        int freqfirstmaxOdd = 0;\\n        int freqsecondmaxOdd = 0;\\n        int firstmaxOdd = 0;\\n        int secondmaxOdd = 0;\\n        for(Map.Entry<Integer,Integer>entry:oddmap.entrySet())\\n        {\\n            int key1 = entry.getKey();\\n            int freq1 = entry.getValue();\\n            if(freq1>freqfirstmaxOdd)\\n            {\\n                freqsecondmaxOdd = freqfirstmaxOdd;\\n                secondmaxOdd = firstmaxOdd;\\n                freqfirstmaxOdd = freq1;\\n                firstmaxOdd = key1;\\n            }\\n            else if(freq1>freqsecondmaxOdd)\\n            {\\n                freqsecondmaxOdd = freq1;\\n                secondmaxOdd = key1;\\n            }\\n        }\\n        System.out.println(firstmaxOdd+\"  \"+secondmaxOdd+\"   frequencies  \"+freqfirstmaxOdd+\"  \"+freqsecondmaxOdd);\\n        if(firstmaxEven!=firstmaxOdd) return nums.length-freqfirstmaxEven-freqfirstmaxOdd;\\n        else\\n        {\\n            int val1 = nums.length-freqfirstmaxEven - freqsecondmaxOdd;\\n            int val2 = nums.length-freqsecondmaxEven - freqfirstmaxOdd;\\n            return Math.min(val1,val2);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int minimumOperations(int[] nums) \\n    {\\n        HashMap<Integer,Integer> evenmap = new HashMap<Integer,Integer>();\\n        HashMap<Integer,Integer> oddmap = new HashMap<Integer,Integer>();\\n        for(int i = 0 ; i < nums.length; i++)\\n        {\\n            if(i%2==0) evenmap.put(nums[i],evenmap.getOrDefault(nums[i],0)+1);\\n            else oddmap.put(nums[i],oddmap.getOrDefault(nums[i],0)+1);\\n        }\\n        int freqfirstmaxEven = 0;\\n        int freqsecondmaxEven = 0;\\n        int firstmaxEven = 0;\\n        int secondmaxEven = 0;\\n        System.out.println(evenmap);\\n        System.out.println(oddmap);\\n        for(Map.Entry<Integer,Integer>entry:evenmap.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int freq = entry.getValue();\\n            if(freq>freqfirstmaxEven)\\n            {\\n                freqsecondmaxEven = freqfirstmaxEven;\\n                secondmaxEven = firstmaxEven;\\n                freqfirstmaxEven = freq;\\n                firstmaxEven = key;\\n            }\\n            else if(freq>freqsecondmaxEven)\\n            {\\n                freqsecondmaxEven = freq;\\n                secondmaxEven = key;\\n            }\\n        }\\n        System.out.println(firstmaxEven+\"  \"+secondmaxEven+\"   frequencies  \"+freqfirstmaxEven+\"  \"+freqsecondmaxEven);\\n        int freqfirstmaxOdd = 0;\\n        int freqsecondmaxOdd = 0;\\n        int firstmaxOdd = 0;\\n        int secondmaxOdd = 0;\\n        for(Map.Entry<Integer,Integer>entry:oddmap.entrySet())\\n        {\\n            int key1 = entry.getKey();\\n            int freq1 = entry.getValue();\\n            if(freq1>freqfirstmaxOdd)\\n            {\\n                freqsecondmaxOdd = freqfirstmaxOdd;\\n                secondmaxOdd = firstmaxOdd;\\n                freqfirstmaxOdd = freq1;\\n                firstmaxOdd = key1;\\n            }\\n            else if(freq1>freqsecondmaxOdd)\\n            {\\n                freqsecondmaxOdd = freq1;\\n                secondmaxOdd = key1;\\n            }\\n        }\\n        System.out.println(firstmaxOdd+\"  \"+secondmaxOdd+\"   frequencies  \"+freqfirstmaxOdd+\"  \"+freqsecondmaxOdd);\\n        if(firstmaxEven!=firstmaxOdd) return nums.length-freqfirstmaxEven-freqfirstmaxOdd;\\n        else\\n        {\\n            int val1 = nums.length-freqfirstmaxEven - freqsecondmaxOdd;\\n            int val2 = nums.length-freqsecondmaxEven - freqfirstmaxOdd;\\n            return Math.min(val1,val2);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782167,
                "title": "simple-java-counting-frequencies-with-p-queue-and-map-o-n-explained",
                "content": "**TIME : O(N), SPACE: O(N)**. The priority Queues always contain at most 2 elements.\\n\\n**1. WITH PRIORITY QUEUE AND HASHMAP**\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,int[]> numCounts = new HashMap<>();\\n        \\n        //count numbers and their occurrences in even and odd positions:\\n        //Map<num, [freq1, freq2]. freq1 = frequency at even position, \\n        //freq2 = freq at odd position\\n        for(int i=0; i<nums.length; i++){\\n            int[] pair = numCounts.getOrDefault(nums[i],new int[2]);\\n            pair[i%2]++;\\n            numCounts.put(nums[i],pair);\\n        }\\n        //get the top 2 elements that appear highest in even and odd positions.\\n        //PQueue<[freq,num]   for both even and odd\\n        PriorityQueue<int[]> even = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        PriorityQueue<int[]> odd = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        for(int num: numCounts.keySet()){\\n            int[] cur = numCounts.get(num);\\n            even.offer(new int[]{cur[0],num});\\n            odd.offer(new int[]{cur[1],num});\\n            if(even.size() > 2)even.poll();\\n            if(odd.size() > 2)odd.poll();\\n        }\\n        int[] even2 = even.size()==2?even.poll():new int[]{0,0}, even1 = even.poll();\\n        int[] odd2 = odd.size()==2?odd.poll():new int[]{0,0}, odd1 = odd.poll();\\n        \\n        //choose between different number from even and odd such that we would get the max\\n        int choice1 = even1[0] + ((even1[1] != odd1[1])?odd1[0]:odd2[0]);//use max even first\\n        int choice2 = odd1[0] + ((odd1[1] != even1[1])?even1[0]:even2[0]);//use max odd first\\n        \\n        //the difference betwee max(choice1, choice2) and n is the required number of changes\\n        int n= nums.length;\\n        return n-Math.max(choice1,choice2);\\n    }\\n}\\n\\n```\\n\\n**2. WITH HASHMAP ONLY**\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,int[]> numCounts = new HashMap<>();\\n        //count numbers and their occurrences in even and odd positions\\n        for(int i=0; i<nums.length; i++){\\n            int[] pair = numCounts.getOrDefault(nums[i],new int[2]);\\n            pair[i%2]++;\\n            numCounts.put(nums[i],pair);\\n        }\\n        //get the top 2 elements that appear highest in even and odd positions\\n        int[] even1={0,0}, even2 = {0,0}, odd1={0,0}, odd2={0,0};//(value,index)\\n        for(int num: numCounts.keySet()){\\n            int[] cur = numCounts.get(num);\\n            //for even\\n            if(cur[0]>even1[0]){\\n                even2 = even1;\\n                even1 = new int[]{cur[0],num};\\n            }else if(cur[0]>even2[0]){\\n                even2 = new int[]{cur[0],num};\\n            }\\n            //for odd\\n            if(cur[1]>odd1[0]){\\n                odd2 = odd1;\\n                odd1 = new int[]{cur[1],num};\\n            }else if(cur[1]>odd2[0]){\\n                odd2 = new int[]{cur[1],num};\\n            }\\n        }\\n        //choose between different number from even and odd such that we would get the max\\n        int choice1 = even1[0] + ((even1[1] != odd1[1])?odd1[0]:odd2[0]);//use max even first\\n        int choice2 = odd1[0] + ((odd1[1] != even1[1])?even1[0]:even2[0]);//use max odd first\\n        \\n        //the difference betwee max(choice1, choice2) and n is the required number of changes\\n        int n= nums.length;\\n        return n-Math.max(choice1,choice2);\\n    }\\n}\\n\\n*/\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,int[]> numCounts = new HashMap<>();\\n        \\n        //count numbers and their occurrences in even and odd positions:\\n        //Map<num, [freq1, freq2]. freq1 = frequency at even position, \\n        //freq2 = freq at odd position\\n        for(int i=0; i<nums.length; i++){\\n            int[] pair = numCounts.getOrDefault(nums[i],new int[2]);\\n            pair[i%2]++;\\n            numCounts.put(nums[i],pair);\\n        }\\n        //get the top 2 elements that appear highest in even and odd positions.\\n        //PQueue<[freq,num]   for both even and odd\\n        PriorityQueue<int[]> even = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        PriorityQueue<int[]> odd = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        for(int num: numCounts.keySet()){\\n            int[] cur = numCounts.get(num);\\n            even.offer(new int[]{cur[0],num});\\n            odd.offer(new int[]{cur[1],num});\\n            if(even.size() > 2)even.poll();\\n            if(odd.size() > 2)odd.poll();\\n        }\\n        int[] even2 = even.size()==2?even.poll():new int[]{0,0}, even1 = even.poll();\\n        int[] odd2 = odd.size()==2?odd.poll():new int[]{0,0}, odd1 = odd.poll();\\n        \\n        //choose between different number from even and odd such that we would get the max\\n        int choice1 = even1[0] + ((even1[1] != odd1[1])?odd1[0]:odd2[0]);//use max even first\\n        int choice2 = odd1[0] + ((odd1[1] != even1[1])?even1[0]:even2[0]);//use max odd first\\n        \\n        //the difference betwee max(choice1, choice2) and n is the required number of changes\\n        int n= nums.length;\\n        return n-Math.max(choice1,choice2);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,int[]> numCounts = new HashMap<>();\\n        //count numbers and their occurrences in even and odd positions\\n        for(int i=0; i<nums.length; i++){\\n            int[] pair = numCounts.getOrDefault(nums[i],new int[2]);\\n            pair[i%2]++;\\n            numCounts.put(nums[i],pair);\\n        }\\n        //get the top 2 elements that appear highest in even and odd positions\\n        int[] even1={0,0}, even2 = {0,0}, odd1={0,0}, odd2={0,0};//(value,index)\\n        for(int num: numCounts.keySet()){\\n            int[] cur = numCounts.get(num);\\n            //for even\\n            if(cur[0]>even1[0]){\\n                even2 = even1;\\n                even1 = new int[]{cur[0],num};\\n            }else if(cur[0]>even2[0]){\\n                even2 = new int[]{cur[0],num};\\n            }\\n            //for odd\\n            if(cur[1]>odd1[0]){\\n                odd2 = odd1;\\n                odd1 = new int[]{cur[1],num};\\n            }else if(cur[1]>odd2[0]){\\n                odd2 = new int[]{cur[1],num};\\n            }\\n        }\\n        //choose between different number from even and odd such that we would get the max\\n        int choice1 = even1[0] + ((even1[1] != odd1[1])?odd1[0]:odd2[0]);//use max even first\\n        int choice2 = odd1[0] + ((odd1[1] != even1[1])?even1[0]:even2[0]);//use max odd first\\n        \\n        //the difference betwee max(choice1, choice2) and n is the required number of changes\\n        int n= nums.length;\\n        return n-Math.max(choice1,choice2);\\n    }\\n}\\n\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771010,
                "title": "c-code-with-explanation-easy-to-understand",
                "content": "Explanation:-We have to find the minimum number of operation to make the array alternative \\n\\n1. First we will count the frequencies of numbers at even place as well as numbers at odd place.\\n2. Now the ans will be (Array size-max frequency of numbers at even places-max frequency of numbers at odd places).\\n3. But think of the case when maximum frequencies element at even place becomes equals to maximum frequencies element at odd place. In that case adjacent element becomes equal which is not possible according to question.\\n4. In that case we have to find second maximum frequency for odd places as well as even places elements.\\n5. And our ans will be minimum(array size-second max frequency at even places elements-first max frequency at odd places element,array size-max frequency element at even places-second maximum frequency at odd places).\\n\\nPlease upvote if you like.\\nNow here is the code- \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>odd,even;\\n        int omax=0,emax=0,somax=0,semax=0,oval,eval;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            even[nums[i]]+=1;\\n            else odd[nums[i]]+=1;\\n        }\\n        for(auto i:odd) if(i.second>omax){ omax=i.second; oval=i.first;}           \\n        for(auto i:even)if(i.second>emax){ emax=i.second; eval=i.first; }\\n        for(auto i:odd) if(i.first!=oval) somax=max(i.second,somax);\\n        for(auto i:even) if(i.first!=eval) semax=max(i.second,semax);\\n        if(oval!=eval) return  nums.size()-omax-emax;  \\n        return min(nums.size()-somax-emax,nums.size()-omax-semax);\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>odd,even;\\n        int omax=0,emax=0,somax=0,semax=0,oval,eval;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            even[nums[i]]+=1;\\n            else odd[nums[i]]+=1;\\n        }\\n        for(auto i:odd) if(i.second>omax){ omax=i.second; oval=i.first;}           \\n        for(auto i:even)if(i.second>emax){ emax=i.second; eval=i.first; }\\n        for(auto i:odd) if(i.first!=oval) somax=max(i.second,somax);\\n        for(auto i:even) if(i.first!=eval) semax=max(i.second,semax);\\n        if(oval!=eval) return  nums.size()-omax-emax;  \\n        return min(nums.size()-somax-emax,nums.size()-omax-semax);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770119,
                "title": "freq-first-max-and-second-max-detailed-explanation",
                "content": "The problem statement says ; every  alternating element should be same, in the same time the adjacent element should not be same. Keeping the  minimum number of operations. And operations are just; every time a number is changed it cost us 1 operation.\\n\\n```\\n[3,  1,  3,  2,  4,  3]          -> output  [3, 1, 3, 1, 3, 1]\\n 0   1   2   3   4   5 \\n```\\n \\nBy observation we can say that; numbers at index of 0 , 2 , 4 should be same and same goes to 1 , 3 , 5.\\nSo we can conclude if we make all the **even** element same and  all the **odd** element same we can make the array alternating, in the same time even and odd **!=** each other.\\nSo the intuition can be;  finding out the **maximum frequency** in the even and odd places.\\nIn the example:\\nFreq of  num 3 is 2 ||  4 is 1   for even place.\\nOut task to keep the operations to a minimum. So its quite obvious that chainging the number 4 to 3 will cost us less ( 1 operation) operation as compare to 3 to 4 ( 2 operations).\\nFreq of  num 1 is 1 || 2 is 1 || 3 is 1   for odd place.\\nHere the frequency is same for all the numbers so we can pick any one and change it. So we pick 1 and change the rest of the odd places to 1 and its cost us 2 operation.\\n\\n**Total number** of operation is **3**.\\nwe can calculate the number of operation to be done by this formula:\\n\\n```\\n                                  (n - freqMaxEven - freqMaxOdd)\\nThe formula is; we are substracting the number of elements we dont want to change in array \\nto the total number of elements in the array.\\n1.  where n is the total number of element in the array .\\n2.  freqMaxEven is most occured element in even places.\\n3.  freqMaxOdd is most occured element in odd places.\\n```\\n\\nBut here comes a catch! what if the most occured element in even and odd place is same\\neg:\\n```\\n[1, 1, 3, 2, 1, 1, 4, 1, 1, 2 , 3 ]\\n 0  1  2  3  4  5  6  7  8  9  10\\nIn even place:           ||   in odd place:\\n1 : 3 times (0,4,8)       ||   1 : 3 times(1,5,7)\\n3 : 2 times (2,10)        ||   2 : 2 times  (3,9)    \\n4 : 1 time(6)\\n```\\nHere our formula will fail beacause the most occured number in the both **odd** and **even** is **1** ; and we know that our adjacent should not be equal to each other.\\nSo our intuition can be to find the second most occured number. Because we cant keep **1**  in both adjacent places.\\nThe second most occured element is even is  3 -> 2 time and in odd is 2 -> 2 time,\\nHere we will have two cases:\\n1.  Pick **1**(first most occurring) in even and pick **2**(second most occurring) in odd.\\n\\t` (n - freqFirstMaxEven - freqSecMaxOdd)`\\n\\n2. Pick **3**(second most occurring) in even and pick **1**(first most occurring) in odd.\\n\\t`(n - freqSecMaxEven - freqFirstMaxOdd)`\\n\\nand then return which ever is the minimum.\\n\\n\\nJavaScript code:\\n```\\nvar minimumOperations = function (nums) {\\n  //its been given that nums.length goes upto 10^5\\n  let freqofEven = new Array(100001).fill(0);\\n  let freqofOdd = new Array(100001).fill(0);\\n  let n = nums.length;\\n\\n  // storing the of frequency of even and odd places\\n  //maxnum is just for complexity so that we dont have to traverse the whole freq array\\n  let maxnum = nums[0];\\n  for (let i = 0; i < n; i++) {\\n    if (i % 2 === 0) freqofEven[nums[i]]++;\\n    else freqofOdd[nums[i]]++;\\n    maxnum = Math.max(maxnum, nums[i]);\\n  }\\n\\n  let fMaxEven = 0;\\n  let sMaxEven = 0;\\n  let freqFirstMaxEven = 0;\\n  let freqSecMaxEven = 0;\\n\\n  let fMaxOdd = 0;\\n  let sMaxOdd = 0;\\n  let freqFirstMaxOdd = 0;\\n  let freqSecMaxOdd = 0;\\n\\n  //logic for finding the first and second most occured number\\n  for (let i = 0; i <= maxnum; i++) {\\n    //even\\n    if (freqofEven[i] > freqFirstMaxEven) {\\n      freqSecMaxEven = freqFirstMaxEven;\\n      sMaxEven = fMaxEven;\\n      //when find a higher freq store it in max frequency even. the element in index is the freq of that number\\n      freqFirstMaxEven = freqofEven[i];\\n      //The index is the actual number and its storing the number which has the highest frequency\\n      fMaxEven = i;\\n    } else if (freqofEven[i] > freqSecMaxEven) {\\n      freqSecMaxEven = freqofEven[i];\\n      sMaxEven = i;\\n    }\\n\\n    // odd\\n    if (freqofOdd[i] > freqFirstMaxOdd) {\\n      freqSecMaxOdd = freqFirstMaxOdd;\\n      sMaxOdd = fMaxOdd;\\n      freqFirstMaxOdd = freqofOdd[i];\\n      fMaxOdd = i;\\n    } else if (freqofOdd[i] > freqSecMaxOdd) {\\n      freqSecMaxOdd = freqofOdd[i];\\n      sMaxOdd = i;\\n    }\\n  }\\n\\n  // when most occured number in both odd and even are different\\n  if (fMaxEven !== fMaxOdd) return n - freqFirstMaxEven - freqFirstMaxOdd;\\n\\n  //when most occured number in both odd and even are same\\n  return Math.min(\\n    n - freqFirstMaxEven - freqSecMaxOdd,\\n    n - freqFirstMaxOdd - freqSecMaxEven\\n  );\\n};\\n```\\n\\nc++ code\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumOperations(vector<int> &nums)\\n    {\\n        int freqofEven[100001] = {0};\\n        int freqofOdd[100001] = {0};\\n        int n = nums.size();\\n\\n        // storing the of frequency of even and odd places\\n        // maxnum is just for complexity so that we dont have to traverse the whole freq array\\n        int maxnum = nums[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n\\n                freqofEven[nums[i]]++;\\n            }\\n            else\\n            {\\n\\n                freqofOdd[nums[i]]++;\\n            }\\n            maxnum = max(maxnum, nums[i]);\\n        }\\n\\n        int fMaxEven = 0;\\n        int sMaxEven = 0;\\n        int freqFirstMaxEven = 0;\\n        int freqSecMaxEven = 0;\\n\\n        int fMaxOdd = 0;\\n        int sMaxOdd = 0;\\n        int freqFirstMaxOdd = 0;\\n        int freqSecMaxOdd = 0;\\n\\n        // logic for finding the first and second most occured number\\n        for (int i = 0; i <= maxnum; i++)\\n        {\\n            // even\\n            if (freqofEven[i] > freqFirstMaxEven)\\n            {\\n                freqSecMaxEven = freqFirstMaxEven;\\n                sMaxEven = fMaxEven;\\n                // when find a higher freq store it in max frequency even. the element in index is the freq of that number\\n                freqFirstMaxEven = freqofEven[i];\\n                // The index is the actual number and its storing the number which has the highest frequency\\n                fMaxEven = i;\\n            }\\n            else if (freqofEven[i] > freqSecMaxEven)\\n            {\\n                freqSecMaxEven = freqofEven[i];\\n                sMaxEven = i;\\n            }\\n\\n            // odd\\n            if (freqofOdd[i] > freqFirstMaxOdd)\\n            {\\n                freqSecMaxOdd = freqFirstMaxOdd;\\n                sMaxOdd = fMaxOdd;\\n                freqFirstMaxOdd = freqofOdd[i];\\n                fMaxOdd = i;\\n            }\\n            else if (freqofOdd[i] > freqSecMaxOdd)\\n            {\\n                freqSecMaxOdd = freqofOdd[i];\\n                sMaxOdd = i;\\n            }\\n        }\\n\\n        // when most occured number in both odd and even are different\\n        if (fMaxEven != fMaxOdd)\\n        {\\n\\n            return n - freqFirstMaxEven - freqFirstMaxOdd;\\n        }\\n\\n        // when most occured number in both odd and even are same\\n        return min(\\n            n - freqFirstMaxEven - freqSecMaxOdd,\\n            n - freqFirstMaxOdd - freqSecMaxEven);\\n    }\\n};\\n```\\n\\n\\nHope this helps .I am just a beginner tried my best to give a proper explanation.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n[3,  1,  3,  2,  4,  3]          -> output  [3, 1, 3, 1, 3, 1]\\n 0   1   2   3   4   5 \\n```\n```\\n                                  (n - freqMaxEven - freqMaxOdd)\\nThe formula is; we are substracting the number of elements we dont want to change in array \\nto the total number of elements in the array.\\n1.  where n is the total number of element in the array .\\n2.  freqMaxEven is most occured element in even places.\\n3.  freqMaxOdd is most occured element in odd places.\\n```\n```\\n[1, 1, 3, 2, 1, 1, 4, 1, 1, 2 , 3 ]\\n 0  1  2  3  4  5  6  7  8  9  10\\nIn even place:           ||   in odd place:\\n1 : 3 times (0,4,8)       ||   1 : 3 times(1,5,7)\\n3 : 2 times (2,10)        ||   2 : 2 times  (3,9)    \\n4 : 1 time(6)\\n```\n```\\nvar minimumOperations = function (nums) {\\n  //its been given that nums.length goes upto 10^5\\n  let freqofEven = new Array(100001).fill(0);\\n  let freqofOdd = new Array(100001).fill(0);\\n  let n = nums.length;\\n\\n  // storing the of frequency of even and odd places\\n  //maxnum is just for complexity so that we dont have to traverse the whole freq array\\n  let maxnum = nums[0];\\n  for (let i = 0; i < n; i++) {\\n    if (i % 2 === 0) freqofEven[nums[i]]++;\\n    else freqofOdd[nums[i]]++;\\n    maxnum = Math.max(maxnum, nums[i]);\\n  }\\n\\n  let fMaxEven = 0;\\n  let sMaxEven = 0;\\n  let freqFirstMaxEven = 0;\\n  let freqSecMaxEven = 0;\\n\\n  let fMaxOdd = 0;\\n  let sMaxOdd = 0;\\n  let freqFirstMaxOdd = 0;\\n  let freqSecMaxOdd = 0;\\n\\n  //logic for finding the first and second most occured number\\n  for (let i = 0; i <= maxnum; i++) {\\n    //even\\n    if (freqofEven[i] > freqFirstMaxEven) {\\n      freqSecMaxEven = freqFirstMaxEven;\\n      sMaxEven = fMaxEven;\\n      //when find a higher freq store it in max frequency even. the element in index is the freq of that number\\n      freqFirstMaxEven = freqofEven[i];\\n      //The index is the actual number and its storing the number which has the highest frequency\\n      fMaxEven = i;\\n    } else if (freqofEven[i] > freqSecMaxEven) {\\n      freqSecMaxEven = freqofEven[i];\\n      sMaxEven = i;\\n    }\\n\\n    // odd\\n    if (freqofOdd[i] > freqFirstMaxOdd) {\\n      freqSecMaxOdd = freqFirstMaxOdd;\\n      sMaxOdd = fMaxOdd;\\n      freqFirstMaxOdd = freqofOdd[i];\\n      fMaxOdd = i;\\n    } else if (freqofOdd[i] > freqSecMaxOdd) {\\n      freqSecMaxOdd = freqofOdd[i];\\n      sMaxOdd = i;\\n    }\\n  }\\n\\n  // when most occured number in both odd and even are different\\n  if (fMaxEven !== fMaxOdd) return n - freqFirstMaxEven - freqFirstMaxOdd;\\n\\n  //when most occured number in both odd and even are same\\n  return Math.min(\\n    n - freqFirstMaxEven - freqSecMaxOdd,\\n    n - freqFirstMaxOdd - freqSecMaxEven\\n  );\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int minimumOperations(vector<int> &nums)\\n    {\\n        int freqofEven[100001] = {0};\\n        int freqofOdd[100001] = {0};\\n        int n = nums.size();\\n\\n        // storing the of frequency of even and odd places\\n        // maxnum is just for complexity so that we dont have to traverse the whole freq array\\n        int maxnum = nums[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n\\n                freqofEven[nums[i]]++;\\n            }\\n            else\\n            {\\n\\n                freqofOdd[nums[i]]++;\\n            }\\n            maxnum = max(maxnum, nums[i]);\\n        }\\n\\n        int fMaxEven = 0;\\n        int sMaxEven = 0;\\n        int freqFirstMaxEven = 0;\\n        int freqSecMaxEven = 0;\\n\\n        int fMaxOdd = 0;\\n        int sMaxOdd = 0;\\n        int freqFirstMaxOdd = 0;\\n        int freqSecMaxOdd = 0;\\n\\n        // logic for finding the first and second most occured number\\n        for (int i = 0; i <= maxnum; i++)\\n        {\\n            // even\\n            if (freqofEven[i] > freqFirstMaxEven)\\n            {\\n                freqSecMaxEven = freqFirstMaxEven;\\n                sMaxEven = fMaxEven;\\n                // when find a higher freq store it in max frequency even. the element in index is the freq of that number\\n                freqFirstMaxEven = freqofEven[i];\\n                // The index is the actual number and its storing the number which has the highest frequency\\n                fMaxEven = i;\\n            }\\n            else if (freqofEven[i] > freqSecMaxEven)\\n            {\\n                freqSecMaxEven = freqofEven[i];\\n                sMaxEven = i;\\n            }\\n\\n            // odd\\n            if (freqofOdd[i] > freqFirstMaxOdd)\\n            {\\n                freqSecMaxOdd = freqFirstMaxOdd;\\n                sMaxOdd = fMaxOdd;\\n                freqFirstMaxOdd = freqofOdd[i];\\n                fMaxOdd = i;\\n            }\\n            else if (freqofOdd[i] > freqSecMaxOdd)\\n            {\\n                freqSecMaxOdd = freqofOdd[i];\\n                sMaxOdd = i;\\n            }\\n        }\\n\\n        // when most occured number in both odd and even are different\\n        if (fMaxEven != fMaxOdd)\\n        {\\n\\n            return n - freqFirstMaxEven - freqFirstMaxOdd;\\n        }\\n\\n        // when most occured number in both odd and even are same\\n        return min(\\n            n - freqFirstMaxEven - freqSecMaxOdd,\\n            n - freqFirstMaxOdd - freqSecMaxEven);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768829,
                "title": "c-2170-minimum-operations-to-make-the-array-alternating",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> even, odd; \\n        for (int i = 0; i < nums.size(); ++i) \\n            if (i&1) ++odd[nums[i]]; \\n            else ++even[nums[i]]; \\n        \\n        auto fn = [&](unordered_map<int, int> freq) {\\n            int key = 0, m0 = 0, m1 = 0; \\n            for (auto& [k, v] : freq) \\n                if (v > m0) tie(key, m1, m0) = make_tuple(k, m0, v); \\n                else m1 = v;\\n            return make_tuple(key, m0, m1); \\n        };\\n        \\n        auto [k0, m00, m01] = fn(even); \\n        auto [k1, m10, m11] = fn(odd); \\n        return k0 == k1 ? nums.size() - max(m00 + m11, m01 + m10) : nums.size() - m00 - m10; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> even, odd; \\n        for (int i = 0; i < nums.size(); ++i) \\n            if (i&1) ++odd[nums[i]]; \\n            else ++even[nums[i]]; \\n        \\n        auto fn = [&](unordered_map<int, int> freq) {\\n            int key = 0, m0 = 0, m1 = 0; \\n            for (auto& [k, v] : freq) \\n                if (v > m0) tie(key, m1, m0) = make_tuple(k, m0, v); \\n                else m1 = v;\\n            return make_tuple(key, m0, m1); \\n        };\\n        \\n        auto [k0, m00, m01] = fn(even); \\n        auto [k1, m10, m11] = fn(odd); \\n        return k0 == k1 ? nums.size() - max(m00 + m11, m01 + m10) : nums.size() - m00 - m10; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768700,
                "title": "100-faster-simple-code-c-find-max-and-second-max-of-odd-and-even-indices-simplest-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        pair<int,int>even = {0,0};\\n       \\n        pair<int,int>odd = {0,0};//freq,number\\n        \\n        unordered_map<int,int>me;\\n        unordered_map<int,int>mo;\\n        for(int i = 0 ; i < n;++i){\\n            if(i&1){//odd\\n                mo[nums[i]]++;\\n                if(mo[nums[i]]>odd.first){\\n                    // odd2 = odd;\\n                    odd = {mo[nums[i]],nums[i]};\\n                }\\n            }\\n            else{//even\\n                me[nums[i]]++;\\n                if(me[nums[i]]>even.first){\\n                    // even2 = even;\\n                    even = {me[nums[i]],nums[i]};\\n                }\\n            }\\n        }\\n         pair<int,int>even2 = {0,0};//next possible number\\n    pair<int,int>odd2 = {0,0};//next possible number\\n         for(int i = 0 ; i < n;++i){\\n            if(i&1){//odd\\n                if(nums[i]!=odd.second){\\n                    if(mo[nums[i]]>odd2.first){\\n                        odd2 = {mo[nums[i]],nums[i]};\\n                    }\\n                    \\n                }\\n            }\\n            else{//even\\n                if(nums[i]!=even.second){\\n                    if(me[nums[i]]>even2.first){\\n                        even2 = {me[nums[i]],nums[i]};\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n       \\n        if(even.second==odd.second){\\n            if(even2.second==0&&odd2.second==0){//all elements are equal\\n                return n/2;\\n            }\\n            int ans1 = n-(odd2.first+even.first);\\n            int ans2 = n-(even2.first+odd.first);\\n            return min(ans1,ans2);\\n        }\\n        return n-(odd.first+even.first);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        pair<int,int>even = {0,0};\\n       \\n        pair<int,int>odd = {0,0};//freq,number\\n        \\n        unordered_map<int,int>me;\\n        unordered_map<int,int>mo;\\n        for(int i = 0 ; i < n;++i){\\n            if(i&1){//odd\\n                mo[nums[i]]++;\\n                if(mo[nums[i]]>odd.first){\\n                    // odd2 = odd;\\n                    odd = {mo[nums[i]],nums[i]};\\n                }\\n            }\\n            else{//even\\n                me[nums[i]]++;\\n                if(me[nums[i]]>even.first){\\n                    // even2 = even;\\n                    even = {me[nums[i]],nums[i]};\\n                }\\n            }\\n        }\\n         pair<int,int>even2 = {0,0};//next possible number\\n    pair<int,int>odd2 = {0,0};//next possible number\\n         for(int i = 0 ; i < n;++i){\\n            if(i&1){//odd\\n                if(nums[i]!=odd.second){\\n                    if(mo[nums[i]]>odd2.first){\\n                        odd2 = {mo[nums[i]],nums[i]};\\n                    }\\n                    \\n                }\\n            }\\n            else{//even\\n                if(nums[i]!=even.second){\\n                    if(me[nums[i]]>even2.first){\\n                        even2 = {me[nums[i]],nums[i]};\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n       \\n        if(even.second==odd.second){\\n            if(even2.second==0&&odd2.second==0){//all elements are equal\\n                return n/2;\\n            }\\n            int ans1 = n-(odd2.first+even.first);\\n            int ans2 = n-(even2.first+odd.first);\\n            return min(ans1,ans2);\\n        }\\n        return n-(odd.first+even.first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768444,
                "title": "java-9ms-beats-100-with-explanation",
                "content": "Intuition\\n- Consider all numbers at odd and odd index separately. In order to make the array alternating, in the end, there will be only one number in odd and even index, i.e. the final form of the array should be `[a, b, a, b, ..., a, b]`.\\n- To achieve this in minimum number of steps, we can find out number appeared most in odd and even index, `odd` and `even`, and change other numbers to this two number.\\n- However, It may be possible that `odd == even`. In this case, we need to select a different number in odd or even index.\\n- The best choice is a different number with lower frequency. We can go through the array and find out `odd1`, `odd2`, `even1` and `even2`. `odd1` and `odd2` are the number with highest and second highest frequency at odd index, and so is for `even1` and `even2`, `odd1 != odd2`, `even1 != even2`.\\n- To make sure `even1`, `even2` are distinct, and `odd1`, `odd2` are distinct, we can use a sentinel value.\\n- The range of `nums[i]` is `[1,100000]`, which means we can use an array as a hash table, instead of using the expensive hash table data structure.\\n\\nCode:\\n```java\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        // use array as hash table to speed up\\n        int[] oddFreq = new int[100001];\\n        int[] evenFreq = new int[100001];\\n        // -1 is sentinel value, meaning not found yet \\n        int even1 = nums[0], even2 = -1;\\n        int odd1 = nums[1], odd2 = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                int freq = ++evenFreq[nums[i]];\\n                if (freq >= evenFreq[even1]) {\\n                    if (even1 != nums[i]) even2 = even1;\\n                    even1 = nums[i];\\n                } else if (even2 == -1 || freq > evenFreq[even2]) {\\n                    even2 = nums[i];\\n                }\\n            } else {\\n                int freq = ++oddFreq[nums[i]];\\n                if (freq >= oddFreq[odd1]) {\\n                    if (odd1 != nums[i]) odd2 = odd1;\\n                    odd1 = nums[i];\\n                } else if (odd2 == -1 || freq > oddFreq[odd2]) {\\n                    odd2 = nums[i];\\n                }\\n            }\\n        }\\n\\n        // n0: total count of number at even index\\n        // n1: total count of number at odd index\\n        int n0 = (n + 1) / 2, n1 = n / 2;\\n\\n        int evenf2 = even2 == -1 ? 0 : evenFreq[even2];\\n        int oddf2 = odd2 == -1 ? 0 : oddFreq[odd2];\\n\\n        if (odd1 != even1) {\\n            return n0 - evenFreq[even1] + n1 - oddFreq[odd1];\\n        } else {\\n            int count1 = n0 - evenFreq[even1] + n1 - oddf2;\\n            int count2 = n0 - evenf2 + n1 - oddFreq[odd1];\\n            return Math.min(count1, count2);\\n        }\\n    }\\n}\\n```\\n\\n- Time complexity: `O(n)`, we iterate the array once.\\n- Space complexity: `O(n)`, to store the frequency of each number.\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return 0;\\n        // use array as hash table to speed up\\n        int[] oddFreq = new int[100001];\\n        int[] evenFreq = new int[100001];\\n        // -1 is sentinel value, meaning not found yet \\n        int even1 = nums[0], even2 = -1;\\n        int odd1 = nums[1], odd2 = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                int freq = ++evenFreq[nums[i]];\\n                if (freq >= evenFreq[even1]) {\\n                    if (even1 != nums[i]) even2 = even1;\\n                    even1 = nums[i];\\n                } else if (even2 == -1 || freq > evenFreq[even2]) {\\n                    even2 = nums[i];\\n                }\\n            } else {\\n                int freq = ++oddFreq[nums[i]];\\n                if (freq >= oddFreq[odd1]) {\\n                    if (odd1 != nums[i]) odd2 = odd1;\\n                    odd1 = nums[i];\\n                } else if (odd2 == -1 || freq > oddFreq[odd2]) {\\n                    odd2 = nums[i];\\n                }\\n            }\\n        }\\n\\n        // n0: total count of number at even index\\n        // n1: total count of number at odd index\\n        int n0 = (n + 1) / 2, n1 = n / 2;\\n\\n        int evenf2 = even2 == -1 ? 0 : evenFreq[even2];\\n        int oddf2 = odd2 == -1 ? 0 : oddFreq[odd2];\\n\\n        if (odd1 != even1) {\\n            return n0 - evenFreq[even1] + n1 - oddFreq[odd1];\\n        } else {\\n            int count1 = n0 - evenFreq[even1] + n1 - oddf2;\\n            int count2 = n0 - evenf2 + n1 - oddFreq[odd1];\\n            return Math.min(count1, count2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768293,
                "title": "c-find-max-and-second-max-explained",
                "content": "\\n[@jionghongli](https://leetcode.com/jionghongli/) Explained this\\n\\nLet\\'s say we only care about the requirement ```nums[i - 2] == nums[i]```, then we need to get the max freq for both of the odd & even idx inorder to get the result using ```(total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even)```, now bring the second requirement ```nums[i] != nums[i-1]``` in and think of what if the number with the max freq is same for both of the even/odd idx ,then we either change the numbers with max freq in odd idx or change the numbers with max freq in even idx and that\\'s why we need to introduce the second max freq for both of the odd&even.\\nSo the result will be\\neither : \\n```(total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even) when the max freq num is not the same in both of the even and odd idx```\\nor : \\n```Math.min(total number in odd idx - second max freq in odd + total numbers in even - max freq in even, total numbers in even idx - second freq in even + total numbers in odd idx - max freq in odd);```\\n\\nPS : code is just an update to [@khushiprerak](https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/discuss/1766804/C%2B%2B-or-Find-max-and-second-max-or-easy-to-understand)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    //Function returns top two most frequent elements in O(n) time\\n    pair<int,int> twoMax(unordered_map<int,int>& m){\\n        pair<int,int> max1{0,0},max2{0,0};\\n        for(auto p:m){\\n            if(p.second>=max1.second){\\n                max2 = {max1.first,max1.second};\\n                max1 = {p.first,p.second}; }\\n            \\n            else if(p.second>=max2.second && p.second<max1.second ) max2 = {p.first,p.second}; \\n        }\\n        \\n        return {max1.first,max2.first};\\n    }\\n        \\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size(), evenInd = 0,oddInd = 0;\\n        unordered_map<int,int> freqOdd, freqEven;\\n        \\n        //Find frequencies of each element and count the number of even and odd indexes\\n        for(int i=0;i<n;i++){\\n            \\n            if(i%2==0){\\n                freqEven[nums[i]]++;\\n                evenInd++; }\\n            \\n            else{\\n                freqOdd[nums[i]]++;\\n                oddInd++; }\\n        }\\n       \\n        auto maxOdd = twoMax(freqOdd);\\n        auto maxEven = twoMax(freqEven);\\n        \\n        //when max frequencies are not equal\\n        //(total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even)\\n        if(maxOdd.first!=maxEven.first)\\n            return (evenInd-freqEven[maxEven.first] + oddInd-freqOdd[maxOdd.first]);\\n        \\n        //when max frequencies are equal we replace second max\\n        //Min((total number in odd idx - second max freq in odd + total numbers in even - max freq in even), \\n        //(total numbers in even idx - second freq in even + total numbers in odd idx - max freq in odd))\\n        else \\n            return min((evenInd-freqEven[maxEven.second]+oddInd-freqOdd[maxOdd.first]),\\n                     evenInd-freqEven[maxEven.first]+oddInd-freqOdd[maxOdd.second]);\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```nums[i - 2] == nums[i]```\n```(total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even)```\n```nums[i] != nums[i-1]```\n```(total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even) when the max freq num is not the same in both of the even and odd idx```\n```Math.min(total number in odd idx - second max freq in odd + total numbers in even - max freq in even, total numbers in even idx - second freq in even + total numbers in odd idx - max freq in odd);```\n```\\nclass Solution {\\npublic:\\n\\n    //Function returns top two most frequent elements in O(n) time\\n    pair<int,int> twoMax(unordered_map<int,int>& m){\\n        pair<int,int> max1{0,0},max2{0,0};\\n        for(auto p:m){\\n            if(p.second>=max1.second){\\n                max2 = {max1.first,max1.second};\\n                max1 = {p.first,p.second}; }\\n            \\n            else if(p.second>=max2.second && p.second<max1.second ) max2 = {p.first,p.second}; \\n        }\\n        \\n        return {max1.first,max2.first};\\n    }\\n        \\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size(), evenInd = 0,oddInd = 0;\\n        unordered_map<int,int> freqOdd, freqEven;\\n        \\n        //Find frequencies of each element and count the number of even and odd indexes\\n        for(int i=0;i<n;i++){\\n            \\n            if(i%2==0){\\n                freqEven[nums[i]]++;\\n                evenInd++; }\\n            \\n            else{\\n                freqOdd[nums[i]]++;\\n                oddInd++; }\\n        }\\n       \\n        auto maxOdd = twoMax(freqOdd);\\n        auto maxEven = twoMax(freqEven);\\n        \\n        //when max frequencies are not equal\\n        //(total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even)\\n        if(maxOdd.first!=maxEven.first)\\n            return (evenInd-freqEven[maxEven.first] + oddInd-freqOdd[maxOdd.first]);\\n        \\n        //when max frequencies are equal we replace second max\\n        //Min((total number in odd idx - second max freq in odd + total numbers in even - max freq in even), \\n        //(total numbers in even idx - second freq in even + total numbers in odd idx - max freq in odd))\\n        else \\n            return min((evenInd-freqEven[maxEven.second]+oddInd-freqOdd[maxOdd.first]),\\n                     evenInd-freqEven[maxEven.first]+oddInd-freqOdd[maxOdd.second]);\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767867,
                "title": "c-very-easy-efficient-100-space-efficient",
                "content": "the logic behind this code is :\\n1. We need to find num that occur maximun times at even index and odd index and store their frequency (greedy approch)\\n2. Cost to change num at even indexes = total even index - max freq in u1; similarily in odd indexes\\n3. In case if both max freq numbers are same then we also need to store 2nd max number and their freq in both     and use it in place of their respective 1st max. \\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        unordered_map<int,int>u1;      //map to store even index number frequency \\n        unordered_map<int,int>u2;     //map to store odd index number frequency\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                u1[nums[i]]++;\\n            }\\n            else{\\n                u2[nums[i]]++;\\n            }\\n        }\\n        int u1_m1=0;   // store max frequency of even index number;\\n        int t1=0;         // store number which have 2nd max frequency in u1 \\n        int y1=0;        // store number which have max frequency in u1\\n        int u2_m1=0;  //store max frequency of odd index number;\\n        int t2=0;         // store number which have 2nd max frequency in u2\\n        int y2=0;       // store number which have max frequency in u2\\n        int u1_m2=0;  // store 2nd max frequency of even index number;\\n        int u2_m2=0;  // store 2nd max frequency of odd index number;\\n        for(auto x:u1){\\n            if(x.second>u1_m2){\\n                u1_m2=x.second;\\n                t1=x.first;\\n            }\\n            if(u1_m1<u1_m2){\\n                swap(u1_m1,u1_m2);\\n                y1=t1;\\n                \\n            }\\n        }\\n        for(auto x:u2){\\n            if(x.second>u2_m2){\\n                u2_m2=x.second;\\n                t2=x.first;\\n            }\\n            if(u2_m1<u2_m2){\\n                swap(u2_m1,u2_m2);\\n                y2=t2;\\n                \\n            }\\n        }\\n        if(y1!=y2){                                        // if max freq num in u1 is different from max freq num in u2\\n            if(nums.size()%2!=0){\\n                return (nums.size()/2)+(nums.size()/2)+1-u1_m1-u2_m1;   // we can write it as (nums.size()/2)+1-u1_m1)+((nums.size()/2)-u2_m1), eg... let size=5, then even indices- 0,2,4 ; odd- 1,3.\\n            }\\n            else{                                                         \\n                return nums.size()-u1_m1-u2_m1;\\n            }\\n        }\\n        else{                                        // if max freq num in u1 is same as max freq num in u2\\n            if(nums.size()%2!=0){\\n                return (nums.size()/2)+(nums.size()/2)+1-max(u1_m1+u2_m2,u2_m1+u1_m2); // max(u1_m1+u2_m2,u2_m1+u1_m2) means taking max(u1) +2nd max(u2)  OR max(u2) +2nd max(u1);\\n            }\\n            else{\\n                return nums.size()-max(u1_m1+u2_m2,u2_m1+u1_m2);\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1767827,
                "title": "python3-12-lines-split-odd-index-and-even-index-easy-to-understand",
                "content": "```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd_index_top_2 = Counter(nums[1::2]).most_common(2)\\n        even_index_top_2 = Counter(nums[::2]).most_common(2)\\n        if len(odd_index_top_2) < 2:\\n            odd_index_top_2.extend([(0, 0), (0, 0)])\\n        if len(even_index_top_2) < 2:\\n            even_index_top_2.extend([(0, 0), (0, 0)])\\n\\n        (odd_top_1_num, odd_top_1_count), (_, odd_top_2_count) = odd_index_top_2[0], odd_index_top_2[1]\\n        (even_top_1_num, even_top_1_count), (_, even_top_2_count) = even_index_top_2[0], even_index_top_2[1]\\n        \\n        if odd_top_1_num != even_top_1_num:\\n            return len(nums) - odd_top_1_count - even_top_1_count\\n        else:\\n            return len(nums) - max(odd_top_1_count + even_top_2_count,  odd_top_2_count + even_top_1_count)\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd_index_top_2 = Counter(nums[1::2]).most_common(2)\\n        even_index_top_2 = Counter(nums[::2]).most_common(2)\\n        if len(odd_index_top_2) < 2:\\n            odd_index_top_2.extend([(0, 0), (0, 0)])\\n        if len(even_index_top_2) < 2:\\n            even_index_top_2.extend([(0, 0), (0, 0)])\\n\\n        (odd_top_1_num, odd_top_1_count), (_, odd_top_2_count) = odd_index_top_2[0], odd_index_top_2[1]\\n        (even_top_1_num, even_top_1_count), (_, even_top_2_count) = even_index_top_2[0], even_index_top_2[1]\\n        \\n        if odd_top_1_num != even_top_1_num:\\n            return len(nums) - odd_top_1_count - even_top_1_count\\n        else:\\n            return len(nums) - max(odd_top_1_count + even_top_2_count,  odd_top_2_count + even_top_1_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767544,
                "title": "java-find-odd-and-even-s-mostfreq-and-secondfreq-number",
                "content": "Why we want to get most freq number?\\nans: so we keep the most freq number and only change the rest of number(even or odd) that we can get min result.\\n\\nWhy we need most second freq number?\\nans: if odd and even has the same amount of freq number, we need to sacrifice one.\\n\\nWe prepare the most freq number and second most freq number for both odd and even sub array.\\n1. if odd most freq number == even most freq number, we need to look up the odd second most freq number and even second most freq number\\n2. if there are different, just calculate the result\\n\\n\\nnote that (n + 1) is needed if nums.length is an odd number.\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int[] odd = getMax(nums, 0);\\n        int[] even = getMax(nums, 1);\\n        int n = nums.length;\\n        \\n        int oddFirstMax = odd[0], oddFirstFreq = odd[1], oddSecMax = odd[2], oddSecFreq = odd[3];\\n        int evenFirstMax = even[0], evenFirstFreq = even[1], evenSecMax = even[2], evenSecFreq = even[3];\\n        \\n        if (oddFirstMax == evenFirstMax) {\\n            return Math.min(n / 2 - evenSecFreq + (n + 1) / 2 - oddFirstFreq, (n + 1) / 2 - oddSecFreq + n / 2 - evenFirstFreq);\\n        } else {\\n            return (n + 1) / 2 - oddFirstFreq + n / 2 - evenFirstFreq;\\n        }\\n    }\\n    \\n    private int[] getMax(int[] nums, int idx) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int i = idx; i < nums.length; i += 2)\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);\\n        \\n        int maxFreq = 0, maxVal = 0;\\n        for (int key : freq.keySet()) {\\n            if (freq.get(key) > maxFreq) {\\n                maxFreq = freq.get(key);\\n                maxVal = key;\\n            }\\n        }\\n        \\n        int maxSecFreq = 0, maxSecVal = 0;\\n        for (int key : freq.keySet()) {\\n            if (key == maxVal)\\n                continue;\\n            if (freq.get(key) > maxSecFreq) {\\n                maxSecFreq = freq.get(key);\\n                maxSecVal = key;\\n            }\\n        }\\n        \\n        return new int[]{maxVal, maxFreq, maxSecVal, maxSecFreq};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int[] odd = getMax(nums, 0);\\n        int[] even = getMax(nums, 1);\\n        int n = nums.length;\\n        \\n        int oddFirstMax = odd[0], oddFirstFreq = odd[1], oddSecMax = odd[2], oddSecFreq = odd[3];\\n        int evenFirstMax = even[0], evenFirstFreq = even[1], evenSecMax = even[2], evenSecFreq = even[3];\\n        \\n        if (oddFirstMax == evenFirstMax) {\\n            return Math.min(n / 2 - evenSecFreq + (n + 1) / 2 - oddFirstFreq, (n + 1) / 2 - oddSecFreq + n / 2 - evenFirstFreq);\\n        } else {\\n            return (n + 1) / 2 - oddFirstFreq + n / 2 - evenFirstFreq;\\n        }\\n    }\\n    \\n    private int[] getMax(int[] nums, int idx) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        for (int i = idx; i < nums.length; i += 2)\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);\\n        \\n        int maxFreq = 0, maxVal = 0;\\n        for (int key : freq.keySet()) {\\n            if (freq.get(key) > maxFreq) {\\n                maxFreq = freq.get(key);\\n                maxVal = key;\\n            }\\n        }\\n        \\n        int maxSecFreq = 0, maxSecVal = 0;\\n        for (int key : freq.keySet()) {\\n            if (key == maxVal)\\n                continue;\\n            if (freq.get(key) > maxSecFreq) {\\n                maxSecFreq = freq.get(key);\\n                maxSecVal = key;\\n            }\\n        }\\n        \\n        return new int[]{maxVal, maxFreq, maxSecVal, maxSecFreq};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767492,
                "title": "sorting-python-dictionary-easy-to-understand",
                "content": "\\t\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        # 1. corner case\\n        if len(nums)==1:\\n            return 0\\n        \\n        \\n\\t\\teven={}\\n        odd={}\\n        \\n        for i in range(len(nums)):\\n            if i&1==0:\\n                try:\\n                    even[nums[i]]+=1 # if present increment count of that value\\n                except:\\n                    even[nums[i]]=1 # if not assign new key to dictionary\\n            else:\\n                try:\\n                    odd[nums[i]]+=1\\n                except:\\n                    odd[nums[i]]=1\\n        \\n        #sorting dictionary based on frequency\\n        even={key: val for key, val in sorted(even.items(), key = lambda ele: ele[1],reverse=True)}\\n        odd={key: val for key, val in sorted(odd.items(), key = lambda ele: ele[1],reverse=True)}\\n        \\n        #getting first key of both even oand odd dictionary\\n        e2=list(even.keys())[0]\\n        e1=list(odd.keys())[0]\\n        \\n        # 2. what if both values are equal\\n        if (e1==e2):\\n            if even[e2]==odd[e1]: # check if the frequency is equal or not\\n                try:\\n                    e1=list(odd.keys())[1] # try getting next element from odd dictionary if available\\n                except:\\n                    try:\\n                        e2=list(even.keys())[1] # if next element from odd dictionary if not available\\n                    except:\\n                        return len(nums)//2 # if both are empty\\n            else: # chosing the element having highest frequency to stay\\n                if even[e2]>odd[e1]:\\n                    try:\\n                        e1=list(odd.keys())[1]\\n                    except:\\n                        return len(nums)//2\\n                else:\\n                    try:\\n                        e2=list(even.keys())[1]\\n                    except:\\n                        return len(nums)//2\\n        #c as a counter to check how many times we have to replace\\n        c=0\\n        # iterating over the loop to check where we have to change\\n        for i in range(len(nums)):\\n            if i&1==0:\\n                if nums[i]!=e2:\\n                    c+=1\\n            else:\\n                if nums[i]!=e1:\\n                    c+=1\\n        return c #returning c\\n            \\n            \\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\t\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        # 1. corner case\\n        if len(nums)==1:\\n            return 0\\n        \\n        \\n\\t\\teven={}\\n        odd={}\\n        \\n        for i in range(len(nums)):\\n            if i&1==0:\\n                try:\\n                    even[nums[i]]+=1 # if present increment count of that value\\n                except:\\n                    even[nums[i]]=1 # if not assign new key to dictionary\\n            else:\\n                try:\\n                    odd[nums[i]]+=1\\n                except:\\n                    odd[nums[i]]=1\\n        \\n        #sorting dictionary based on frequency\\n        even={key: val for key, val in sorted(even.items(), key = lambda ele: ele[1],reverse=True)}\\n        odd={key: val for key, val in sorted(odd.items(), key = lambda ele: ele[1],reverse=True)}\\n        \\n        #getting first key of both even oand odd dictionary\\n        e2=list(even.keys())[0]\\n        e1=list(odd.keys())[0]\\n        \\n        # 2. what if both values are equal\\n        if (e1==e2):\\n            if even[e2]==odd[e1]: # check if the frequency is equal or not\\n                try:\\n                    e1=list(odd.keys())[1] # try getting next element from odd dictionary if available\\n                except:\\n                    try:\\n                        e2=list(even.keys())[1] # if next element from odd dictionary if not available\\n                    except:\\n                        return len(nums)//2 # if both are empty\\n            else: # chosing the element having highest frequency to stay\\n                if even[e2]>odd[e1]:\\n                    try:\\n                        e1=list(odd.keys())[1]\\n                    except:\\n                        return len(nums)//2\\n                else:\\n                    try:\\n                        e2=list(even.keys())[1]\\n                    except:\\n                        return len(nums)//2\\n        #c as a counter to check how many times we have to replace\\n        c=0\\n        # iterating over the loop to check where we have to change\\n        for i in range(len(nums)):\\n            if i&1==0:\\n                if nums[i]!=e2:\\n                    c+=1\\n            else:\\n                if nums[i]!=e1:\\n                    c+=1\\n        return c #returning c\\n            \\n            \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1767257,
                "title": "c-maps-implementation",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        //a b a b a b a b\\n        \\n        map<int,int>odd,even;\\n        int n=nums.size();\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n            return nums[0]==nums[1]?1:0;\\n        \\n        int o=0,e=0,who,whe;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i&1)\\n            {\\n                o++;\\n                odd[nums[i]]++;\\n            }\\n            else\\n            {\\n                e++;\\n                even[nums[i]]++;\\n            }\\n        }\\n        int modd=0,meven=0;\\n        for(auto &x:odd)\\n        {\\n            if(modd<x.second)\\n            {who=x.first;\\n             modd=x.second;\\n            }\\n        }\\n        \\n         for(auto &x:even)\\n        {\\n            if(meven<x.second)\\n            {whe=x.first;\\n             meven=x.second;\\n            }\\n        }\\n        int soddm=0,sevenm=0;\\n        for(auto &x:odd)\\n        {\\n            if(x.first==who)continue;\\n            soddm=max(soddm,x.second);\\n        }\\n         for(auto &x:even)\\n        {\\n            if(x.first==whe)continue;\\n            sevenm=max(sevenm,x.second);\\n        }\\n       // cout<<modd<<\" \"<<meven<<\" \"<<soddm<<\" \"<<sevenm<<\" \";\\n        if(who!=whe)\\n        {\\n           return (o-modd)+(e-meven);  \\n        }\\n       else\\n       {\\n          \\n           return min((o-modd)+(e-sevenm),(e-meven)+(o-soddm));\\n       }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        //a b a b a b a b\\n        \\n        map<int,int>odd,even;\\n        int n=nums.size();\\n        if(n==1)\\n            return 0;\\n        if(n==2)\\n            return nums[0]==nums[1]?1:0;\\n        \\n        int o=0,e=0,who,whe;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i&1)\\n            {\\n                o++;\\n                odd[nums[i]]++;\\n            }\\n            else\\n            {\\n                e++;\\n                even[nums[i]]++;\\n            }\\n        }\\n        int modd=0,meven=0;\\n        for(auto &x:odd)\\n        {\\n            if(modd<x.second)\\n            {who=x.first;\\n             modd=x.second;\\n            }\\n        }\\n        \\n         for(auto &x:even)\\n        {\\n            if(meven<x.second)\\n            {whe=x.first;\\n             meven=x.second;\\n            }\\n        }\\n        int soddm=0,sevenm=0;\\n        for(auto &x:odd)\\n        {\\n            if(x.first==who)continue;\\n            soddm=max(soddm,x.second);\\n        }\\n         for(auto &x:even)\\n        {\\n            if(x.first==whe)continue;\\n            sevenm=max(sevenm,x.second);\\n        }\\n       // cout<<modd<<\" \"<<meven<<\" \"<<soddm<<\" \"<<sevenm<<\" \";\\n        if(who!=whe)\\n        {\\n           return (o-modd)+(e-meven);  \\n        }\\n       else\\n       {\\n          \\n           return min((o-modd)+(e-sevenm),(e-meven)+(o-soddm));\\n       }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1767227,
                "title": "c-100-fast-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int>mp,mp2;\\n        for(int i=1;i<n;i += 2){\\n            mp[nums[i]]++;\\n        }\\n        for(int i=0;i<n;i += 2){\\n            mp2[nums[i]]++;\\n        }\\n        int cnt = 0,cnt2 = 0;\\n        int val = 0,val2 = 0;\\n        for(auto it :mp){\\n            if(cnt < it.second){\\n                cnt = it.second;\\n                val = it.first;\\n            }\\n        }\\n        for(auto it :mp2){\\n            if(cnt2 < it.second){\\n                cnt2 = it.second;\\n                val2 = it.first;\\n            }\\n        }\\n        if(val == val2){\\n            if(cnt > cnt2){\\n                cnt2 = 1;\\n                for(auto it :mp2){\\n                    if(cnt2 < it.second && it.first != val){\\n                        cnt2 = it.second;\\n                    }\\n                }\\n            }\\n            else{\\n                if(cnt + cnt2 != n)cnt = 1;\\n                else cnt = 0;\\n                for(auto it :mp){\\n                    if(cnt < it.second && it.first != val){\\n                        cnt = it.second;\\n                    }\\n                }\\n            }\\n        }\\n        return n - (cnt + cnt2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int>mp,mp2;\\n        for(int i=1;i<n;i += 2){\\n            mp[nums[i]]++;\\n        }\\n        for(int i=0;i<n;i += 2){\\n            mp2[nums[i]]++;\\n        }\\n        int cnt = 0,cnt2 = 0;\\n        int val = 0,val2 = 0;\\n        for(auto it :mp){\\n            if(cnt < it.second){\\n                cnt = it.second;\\n                val = it.first;\\n            }\\n        }\\n        for(auto it :mp2){\\n            if(cnt2 < it.second){\\n                cnt2 = it.second;\\n                val2 = it.first;\\n            }\\n        }\\n        if(val == val2){\\n            if(cnt > cnt2){\\n                cnt2 = 1;\\n                for(auto it :mp2){\\n                    if(cnt2 < it.second && it.first != val){\\n                        cnt2 = it.second;\\n                    }\\n                }\\n            }\\n            else{\\n                if(cnt + cnt2 != n)cnt = 1;\\n                else cnt = 0;\\n                for(auto it :mp){\\n                    if(cnt < it.second && it.first != val){\\n                        cnt = it.second;\\n                    }\\n                }\\n            }\\n        }\\n        return n - (cnt + cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767220,
                "title": "c-hash-map-easy",
                "content": "```\\nint minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> odd,even;\\n        for(int i=0;i<n;i++) {\\n            if(i%2 != 0) {\\n                odd[nums[i]]++;\\n            }\\n            else {\\n                even[nums[i]]++;\\n            }\\n        }\\n        int oddVals = odd.size(), evenVal = even.size();\\n        vector<pair<int,int>> oddfrq, evenfrq;\\n        for(auto x : odd) {\\n            oddfrq.push_back({x.second, x.first});\\n        }\\n        for(auto x : even) {\\n            evenfrq.push_back({x.second, x.first});\\n        }\\n        sort(oddfrq.rbegin(), oddfrq.rend());\\n        sort(evenfrq.rbegin(), evenfrq.rend());\\n        \\n       if(oddfrq[0].second != evenfrq[0].second)\\n            return n - oddfrq[0].first - evenfrq[0].first;\\n        \\n        else {\\n            int max1 = evenfrq[0].first, max2 = oddfrq[0].first;\\n            int second1 = (evenfrq.size() <= 1) ? 0 : evenfrq[1].first;\\n            int second2 = (oddfrq.size() <= 1) ? 0 : oddfrq[1].first;\\n            return n - max(max1+second2, max2+second1);\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> odd,even;\\n        for(int i=0;i<n;i++) {\\n            if(i%2 != 0) {\\n                odd[nums[i]]++;\\n            }\\n            else {\\n                even[nums[i]]++;\\n            }\\n        }\\n        int oddVals = odd.size(), evenVal = even.size();\\n        vector<pair<int,int>> oddfrq, evenfrq;\\n        for(auto x : odd) {\\n            oddfrq.push_back({x.second, x.first});\\n        }\\n        for(auto x : even) {\\n            evenfrq.push_back({x.second, x.first});\\n        }\\n        sort(oddfrq.rbegin(), oddfrq.rend());\\n        sort(evenfrq.rbegin(), evenfrq.rend());\\n        \\n       if(oddfrq[0].second != evenfrq[0].second)\\n            return n - oddfrq[0].first - evenfrq[0].first;\\n        \\n        else {\\n            int max1 = evenfrq[0].first, max2 = oddfrq[0].first;\\n            int second1 = (evenfrq.size() <= 1) ? 0 : evenfrq[1].first;\\n            int second2 = (oddfrq.size() <= 1) ? 0 : oddfrq[1].first;\\n            return n - max(max1+second2, max2+second1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1767107,
                "title": "java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    \\n    Map<Integer, Integer> oddMap = new HashMap();\\n    Map<Integer, Integer> evenMap = new HashMap();\\n    \\n    public int minimumOperations(int[] nums) {\\n            \\n        if(nums.length < 2){\\n            return 0;\\n        }\\n        \\n        generateMap(nums);\\n        \\n        int result = 0;\\n        \\n        Integer oddValue = computeOddAndEvenVal().getKey();\\n        Integer evenValue = computeOddAndEvenVal().getValue();\\n\\n        \\n        for(int i=0; i < nums.length; i++){\\n            if(i%2 == 0){\\n                if(nums[i] != evenValue){\\n                     nums[i] = evenValue;\\n                    result++;\\n                }\\n            }else{\\n                if(nums[i] != oddValue){\\n                     nums[i] = oddValue;\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Pair<Integer, Integer> computeOddAndEvenVal(){\\n        Integer oddValue = maxOccurence(oddMap).getKey();\\n        Integer oddValueCount = maxOccurence(oddMap).getValue();\\n        Integer evenValue = maxOccurence(evenMap).getKey();\\n        Integer evenValueCount = maxOccurence(evenMap).getValue();\\n                     \\n        if(oddValue == evenValue){\\n            if(oddValueCount == evenValueCount){\\n                if(oddMap.size() > evenMap.size()){\\n                    oddMap.remove(oddValue);\\n                    oddValue = maxOccurence(oddMap).getKey();\\n                }else{\\n                    evenMap.remove(evenValue);\\n                    evenValue = maxOccurence(evenMap).getKey();\\n                }\\n                \\n            }else if(oddValueCount > evenValueCount){\\n                evenMap.remove(evenValue);\\n                evenValue = maxOccurence(evenMap).getKey();\\n            } else{\\n                oddMap.remove(oddValue);\\n                oddValue = maxOccurence(oddMap).getKey();\\n            }\\n        }\\n        \\n        return new Pair(oddValue, evenValue);\\n    }\\n    \\n    private boolean checkArray(int nums[]){\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private void generateMap(int nums[]){\\n        for(int i=0; i < nums.length; i++){\\n            if(i%2 == 0){\\n                if(evenMap.containsKey(nums[i])){\\n                    int val = evenMap.get(nums[i]);\\n                    evenMap.put(nums[i], val + 1);\\n                }else{\\n                    evenMap.put(nums[i], 1);\\n                }  \\n            }else{\\n                  if(oddMap.containsKey(nums[i])){\\n                    oddMap.put(nums[i], oddMap.get(nums[i]) + 1);\\n                }else{\\n                    oddMap.put(nums[i], 1);\\n                }  \\n            }\\n        }\\n    }\\n    \\n    private Pair<Integer, Integer> maxOccurence(Map<Integer, Integer> map){\\n        int max = 0;\\n        int key = 0;\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n            Integer value = entry.getValue();\\n            if(value > max){\\n                max = value;\\n                key = entry.getKey();\\n            }\\n        }\\n        return new Pair(key, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, Integer> oddMap = new HashMap();\\n    Map<Integer, Integer> evenMap = new HashMap();\\n    \\n    public int minimumOperations(int[] nums) {\\n            \\n        if(nums.length < 2){\\n            return 0;\\n        }\\n        \\n        generateMap(nums);\\n        \\n        int result = 0;\\n        \\n        Integer oddValue = computeOddAndEvenVal().getKey();\\n        Integer evenValue = computeOddAndEvenVal().getValue();\\n\\n        \\n        for(int i=0; i < nums.length; i++){\\n            if(i%2 == 0){\\n                if(nums[i] != evenValue){\\n                     nums[i] = evenValue;\\n                    result++;\\n                }\\n            }else{\\n                if(nums[i] != oddValue){\\n                     nums[i] = oddValue;\\n                    result++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private Pair<Integer, Integer> computeOddAndEvenVal(){\\n        Integer oddValue = maxOccurence(oddMap).getKey();\\n        Integer oddValueCount = maxOccurence(oddMap).getValue();\\n        Integer evenValue = maxOccurence(evenMap).getKey();\\n        Integer evenValueCount = maxOccurence(evenMap).getValue();\\n                     \\n        if(oddValue == evenValue){\\n            if(oddValueCount == evenValueCount){\\n                if(oddMap.size() > evenMap.size()){\\n                    oddMap.remove(oddValue);\\n                    oddValue = maxOccurence(oddMap).getKey();\\n                }else{\\n                    evenMap.remove(evenValue);\\n                    evenValue = maxOccurence(evenMap).getKey();\\n                }\\n                \\n            }else if(oddValueCount > evenValueCount){\\n                evenMap.remove(evenValue);\\n                evenValue = maxOccurence(evenMap).getKey();\\n            } else{\\n                oddMap.remove(oddValue);\\n                oddValue = maxOccurence(oddMap).getKey();\\n            }\\n        }\\n        \\n        return new Pair(oddValue, evenValue);\\n    }\\n    \\n    private boolean checkArray(int nums[]){\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private void generateMap(int nums[]){\\n        for(int i=0; i < nums.length; i++){\\n            if(i%2 == 0){\\n                if(evenMap.containsKey(nums[i])){\\n                    int val = evenMap.get(nums[i]);\\n                    evenMap.put(nums[i], val + 1);\\n                }else{\\n                    evenMap.put(nums[i], 1);\\n                }  \\n            }else{\\n                  if(oddMap.containsKey(nums[i])){\\n                    oddMap.put(nums[i], oddMap.get(nums[i]) + 1);\\n                }else{\\n                    oddMap.put(nums[i], 1);\\n                }  \\n            }\\n        }\\n    }\\n    \\n    private Pair<Integer, Integer> maxOccurence(Map<Integer, Integer> map){\\n        int max = 0;\\n        int key = 0;\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n            Integer value = entry.getValue();\\n            if(value > max){\\n                max = value;\\n                key = entry.getKey();\\n            }\\n        }\\n        return new Pair(key, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767091,
                "title": "c-easy-soltuion-o-n-time-and-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        // To maintain the first max_count and second max_count of even and odd index. \\n        int even_mx=0,even_second_mx=0,odd_mx=0,odd_second_mx=0;\\n        \\n        // To store the corresponding numbers of max_count.\\n        int p,q,r,s;\\n        \\n        // Maps numbers to their occurance.\\n        unordered_map<int,int> even,odd;\\n        \\n        // Populate Map.\\n        for(int i=0;i<n;i++){\\n            if(i&1)odd[nums[i]]+=1;\\n            else even[nums[i]]+=1;\\n        }\\n        \\n        // Find the first and second max elements on even index.\\n        for(auto x:even){\\n            if(even_mx<x.second){\\n                even_second_mx=even_mx;\\n                even_mx=x.second;\\n                q=p;\\n                p=x.first;\\n            }else if(even_second_mx<x.second){\\n                even_second_mx=x.second;\\n                q=x.first;\\n            }\\n        }\\n        \\n        // Find the first and second max elements on odd index.\\n        for(auto x:odd){\\n            if(odd_mx<x.second){\\n                odd_second_mx=odd_mx;\\n                odd_mx=x.second;\\n                s=r;\\n                r=x.first;\\n            }else if(odd_second_mx<x.second){\\n                odd_second_mx=x.second;\\n                s=x.first;\\n            }\\n        }\\n        \\n        \\n        // Answer.\\n        int count;\\n        \\n        // Number of even and odd numbers.\\n        int c=n/2;\\n        int d=c+n%2;\\n        \\n        \\n        // If first max_element of both even and odd index is equal, then we check for two cases.\\n        // Case 1: Selecting first max of even and second max for odd.\\n        // Case 2: Selecting second max of even and first max for odd.\\n        if(p==r){\\n            // Take their minimum.\\n            count=min((d-even_mx+c-odd_second_mx),(c-odd_mx+d-even_second_mx));\\n        }else{\\n            // Else, select first max of both even and odd.\\n            count=d-even_mx+c-odd_mx;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        // To maintain the first max_count and second max_count of even and odd index. \\n        int even_mx=0,even_second_mx=0,odd_mx=0,odd_second_mx=0;\\n        \\n        // To store the corresponding numbers of max_count.\\n        int p,q,r,s;\\n        \\n        // Maps numbers to their occurance.\\n        unordered_map<int,int> even,odd;\\n        \\n        // Populate Map.\\n        for(int i=0;i<n;i++){\\n            if(i&1)odd[nums[i]]+=1;\\n            else even[nums[i]]+=1;\\n        }\\n        \\n        // Find the first and second max elements on even index.\\n        for(auto x:even){\\n            if(even_mx<x.second){\\n                even_second_mx=even_mx;\\n                even_mx=x.second;\\n                q=p;\\n                p=x.first;\\n            }else if(even_second_mx<x.second){\\n                even_second_mx=x.second;\\n                q=x.first;\\n            }\\n        }\\n        \\n        // Find the first and second max elements on odd index.\\n        for(auto x:odd){\\n            if(odd_mx<x.second){\\n                odd_second_mx=odd_mx;\\n                odd_mx=x.second;\\n                s=r;\\n                r=x.first;\\n            }else if(odd_second_mx<x.second){\\n                odd_second_mx=x.second;\\n                s=x.first;\\n            }\\n        }\\n        \\n        \\n        // Answer.\\n        int count;\\n        \\n        // Number of even and odd numbers.\\n        int c=n/2;\\n        int d=c+n%2;\\n        \\n        \\n        // If first max_element of both even and odd index is equal, then we check for two cases.\\n        // Case 1: Selecting first max of even and second max for odd.\\n        // Case 2: Selecting second max of even and first max for odd.\\n        if(p==r){\\n            // Take their minimum.\\n            count=min((d-even_mx+c-odd_second_mx),(c-odd_mx+d-even_second_mx));\\n        }else{\\n            // Else, select first max of both even and odd.\\n            count=d-even_mx+c-odd_mx;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767084,
                "title": "python-no-sorting-100-fast",
                "content": "Maybe not every time. But this solution shows faster than 100% ..\\nThe idea is simple just keep the most appeared numbers in even and the scond most appeard number in odd and change other numbers.\\n\\nThis is relatively harder contest question. Almost not finised it during the contest.\\n\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<2: return 0\\n        \\n        d1=defaultdict(int) #even\\n        for i in range(0,n, 2):\\n            d1[nums[i]]+=1\\n        \\n        d2=defaultdict(int)# odd\\n        for i in range(1,n, 2):\\n            d2[nums[i]]+=1\\n            \\n        k1,f1  = max(d1.items(), key=operator.itemgetter(1))\\n        k2,f2 = max(d2.items(), key=operator.itemgetter(1))\\n        if f2>=f1: \\n            d1,d2,k1,k2,f1,f2 = d2,d1,k2,k1,f2,f1\\n\\n        ans = n-f1 # the most appeared number should not be removed.\\n        \\n        # the most appeared nubmer (and not same as the most ones in even) in the odd list should not be removed\\n        if k1 in d2: \\n            del d2[k1]\\n        if len(d2)>0:\\n            k2,f2= max(d2.items(), key=operator.itemgetter(1))\\n            ans -= f2 #\\n        return ans\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/266e23f4-1e62-4f15-8cf4-1d8ebf3e33ca_1644726951.868156.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        if n<2: return 0\\n        \\n        d1=defaultdict(int) #even\\n        for i in range(0,n, 2):\\n            d1[nums[i]]+=1\\n        \\n        d2=defaultdict(int)# odd\\n        for i in range(1,n, 2):\\n            d2[nums[i]]+=1\\n            \\n        k1,f1  = max(d1.items(), key=operator.itemgetter(1))\\n        k2,f2 = max(d2.items(), key=operator.itemgetter(1))\\n        if f2>=f1: \\n            d1,d2,k1,k2,f1,f2 = d2,d1,k2,k1,f2,f1\\n\\n        ans = n-f1 # the most appeared number should not be removed.\\n        \\n        # the most appeared nubmer (and not same as the most ones in even) in the odd list should not be removed\\n        if k1 in d2: \\n            del d2[k1]\\n        if len(d2)>0:\\n            k2,f2= max(d2.items(), key=operator.itemgetter(1))\\n            ans -= f2 #\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766935,
                "title": "c-code-find-max-and-second-max-frequency-in-odd-indices-and-even-indices",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums)\\n    {\\n        int n = nums.size() ;\\n        int f = (n+1)/2 ; int s = n/2 ;\\n        \\n        map<int,int> mp ;\\n        \\n        for(int i=0;i<n;i+=2)\\n            mp[nums[i]]++ ;\\n        \\n        vector<pair<int,int>> v , w ;\\n        \\n        for(auto p : mp)\\n        {\\n            v.push_back({p.second,p.first}) ;\\n        }\\n        \\n        sort(v.begin(),v.end()) ;\\n        reverse(v.begin(),v.end()) ;\\n        mp.clear() ;\\n        \\n        for(int i=1;i<n;i+=2)\\n            mp[nums[i]]++ ;\\n        \\n        for(auto p : mp)\\n            w.push_back({p.second,p.first}) ;\\n        \\n        sort(w.begin(),w.end()) ;\\n        reverse(w.begin(),w.end()) ;\\n        \\n        if(n==1)\\n            return 0 ;\\n        \\n        int ans = INT_MAX ;\\n        \\n        \\n        if(v[0].second != w[0].second)\\n        {\\n            ans = min(ans,f-v[0].first+s-w[0].first) ;\\n        }\\n        else\\n        {\\n            \\n            if(v.size()>1)\\n            {\\n                ans = min(ans,f-v[1].first+s-w[0].first) ;\\n            }\\n            else\\n            {\\n                ans = min(ans,f) ;\\n            }\\n            \\n            if(w.size()>1)\\n            {\\n                ans = min(ans,f-v[0].first+s-w[1].first) ;\\n            }\\n            else\\n            {\\n                ans = min(ans,s) ;\\n            }\\n            \\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums)\\n    {\\n        int n = nums.size() ;\\n        int f = (n+1)/2 ; int s = n/2 ;\\n        \\n        map<int,int> mp ;\\n        \\n        for(int i=0;i<n;i+=2)\\n            mp[nums[i]]++ ;\\n        \\n        vector<pair<int,int>> v , w ;\\n        \\n        for(auto p : mp)\\n        {\\n            v.push_back({p.second,p.first}) ;\\n        }\\n        \\n        sort(v.begin(),v.end()) ;\\n        reverse(v.begin(),v.end()) ;\\n        mp.clear() ;\\n        \\n        for(int i=1;i<n;i+=2)\\n            mp[nums[i]]++ ;\\n        \\n        for(auto p : mp)\\n            w.push_back({p.second,p.first}) ;\\n        \\n        sort(w.begin(),w.end()) ;\\n        reverse(w.begin(),w.end()) ;\\n        \\n        if(n==1)\\n            return 0 ;\\n        \\n        int ans = INT_MAX ;\\n        \\n        \\n        if(v[0].second != w[0].second)\\n        {\\n            ans = min(ans,f-v[0].first+s-w[0].first) ;\\n        }\\n        else\\n        {\\n            \\n            if(v.size()>1)\\n            {\\n                ans = min(ans,f-v[1].first+s-w[0].first) ;\\n            }\\n            else\\n            {\\n                ans = min(ans,f) ;\\n            }\\n            \\n            if(w.size()>1)\\n            {\\n                ans = min(ans,f-v[0].first+s-w[1].first) ;\\n            }\\n            else\\n            {\\n                ans = min(ans,s) ;\\n            }\\n            \\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766908,
                "title": "python-using-counter-o-n-log-n",
                "content": "My first time writing a solution so please let me know how to improve :)\\nLogic flow:\\nMinimum number of operation to make array alternating, so the top elements found in the Counter would be the most frequently appearing ones. I top choose 2 to take the largest and second largest in the event both even and odd produces the same top element eg. [2,2,2,2,2]\\nThe (-1,0) is used to ensure there are at least 2 elements.\\n\\nTime: O(N log N) due to counter.most_common \\nSpace O(N)\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd = Counter()\\n        even = Counter()\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                even[nums[i]]+=1\\n            else:\\n                odd[nums[i]]+=1\\n        top_odd = odd.most_common(2)\\n        top_odd.append((-1,0))\\n        top_even = even.most_common(2)\\n        top_even.append((-1,0))\\n        if top_odd[0][0] == top_even[0][0]:\\n            if top_even[0][1]>=top_odd[0][1]:\\n                return len(nums)- (top_even[0][1] + max(top_even[1][1],top_odd[1][1]))\\n            else:\\n                return len(nums)- (top_odd[0][1] + max(top_even[1][1],top_odd[1][1]))\\n                \\n        else:\\n            return len(nums)- (top_odd[0][1] + top_even[0][1])\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        odd = Counter()\\n        even = Counter()\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                even[nums[i]]+=1\\n            else:\\n                odd[nums[i]]+=1\\n        top_odd = odd.most_common(2)\\n        top_odd.append((-1,0))\\n        top_even = even.most_common(2)\\n        top_even.append((-1,0))\\n        if top_odd[0][0] == top_even[0][0]:\\n            if top_even[0][1]>=top_odd[0][1]:\\n                return len(nums)- (top_even[0][1] + max(top_even[1][1],top_odd[1][1]))\\n            else:\\n                return len(nums)- (top_odd[0][1] + max(top_even[1][1],top_odd[1][1]))\\n                \\n        else:\\n            return len(nums)- (top_odd[0][1] + top_even[0][1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766891,
                "title": "c-max-and-second-max",
                "content": "It feels like there must be a DP solutions that\\'s much easier than this.. \\n\\n```\\nnt MinimumOperations(int[] nums)\\n{\\n    if (nums.Length == 1) return 0;\\n\\n    var evenTop2LetterToCount = nums.Where((k, v) => v % 2 == 0).GroupBy(n => n).Select(n => (n.Key, n.Count())).OrderByDescending(n => n.Item2).Take(2).ToList();\\n    var oddTop2LetterToCount = nums.Where((k, v) => v % 2 == 1).GroupBy(n => n).Select(n => (n.Key, n.Count())).OrderByDescending(n => n.Item2).Take(2).ToList();\\n\\n\\n\\n    var totalOdd = nums.Length / 2;\\n    var totalEven = nums.Length - totalOdd;\\n\\n    var maxCountOfEventLetter = evenTop2LetterToCount[0].Item2;\\n    var maxCountOfOddLetter = oddTop2LetterToCount[0].Item2;\\n\\n    if (evenTop2LetterToCount[0].Item1 != oddTop2LetterToCount[0].Item1)\\n    {\\n        return CalculateResult(maxCountOfOddLetter, maxCountOfEventLetter);\\n    }\\n\\n    var secondMaxEvenCount = evenTop2LetterToCount.Count == 1 ? 0 : evenTop2LetterToCount[1].Item2;\\n    var secondMaxOddCount = oddTop2LetterToCount.Count == 1 ? 0 : oddTop2LetterToCount[1].Item2;\\n\\n    return Math.Min(CalculateResult(maxCountOfOddLetter, secondMaxEvenCount), CalculateResult(maxCountOfEventLetter, secondMaxOddCount));\\n\\n    int CalculateResult(int numOfOddToKeep, int numOfEvenToKeep)\\n    {\\n        return totalOdd - numOfOddToKeep + totalEven - numOfEvenToKeep;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nnt MinimumOperations(int[] nums)\\n{\\n    if (nums.Length == 1) return 0;\\n\\n    var evenTop2LetterToCount = nums.Where((k, v) => v % 2 == 0).GroupBy(n => n).Select(n => (n.Key, n.Count())).OrderByDescending(n => n.Item2).Take(2).ToList();\\n    var oddTop2LetterToCount = nums.Where((k, v) => v % 2 == 1).GroupBy(n => n).Select(n => (n.Key, n.Count())).OrderByDescending(n => n.Item2).Take(2).ToList();\\n\\n\\n\\n    var totalOdd = nums.Length / 2;\\n    var totalEven = nums.Length - totalOdd;\\n\\n    var maxCountOfEventLetter = evenTop2LetterToCount[0].Item2;\\n    var maxCountOfOddLetter = oddTop2LetterToCount[0].Item2;\\n\\n    if (evenTop2LetterToCount[0].Item1 != oddTop2LetterToCount[0].Item1)\\n    {\\n        return CalculateResult(maxCountOfOddLetter, maxCountOfEventLetter);\\n    }\\n\\n    var secondMaxEvenCount = evenTop2LetterToCount.Count == 1 ? 0 : evenTop2LetterToCount[1].Item2;\\n    var secondMaxOddCount = oddTop2LetterToCount.Count == 1 ? 0 : oddTop2LetterToCount[1].Item2;\\n\\n    return Math.Min(CalculateResult(maxCountOfOddLetter, secondMaxEvenCount), CalculateResult(maxCountOfEventLetter, secondMaxOddCount));\\n\\n    int CalculateResult(int numOfOddToKeep, int numOfEvenToKeep)\\n    {\\n        return totalOdd - numOfOddToKeep + totalEven - numOfEvenToKeep;\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766869,
                "title": "priority-queue-and-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        priority_queue<pair<int,int>> pqo;\\n        unordered_map<int,int> mpodd;\\n        for(int i=0;i<n;i=i+2){\\n            mpodd[nums[i]]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mpodd.begin();itr!=mpodd.end();itr++){\\n            pqo.push({itr->second,itr->first});\\n        }\\n        \\n        priority_queue<pair<int,int>> pqe;\\n        unordered_map<int,int> mpeven;\\n        for(int i=1;i<n;i=i+2){\\n            mpeven[nums[i]]++;\\n        }\\n        \\n        for(itr=mpeven.begin();itr!=mpeven.end();itr++){\\n            pqe.push({itr->second,itr->first});\\n        }\\n        if(pqe.top().second != pqo.top().second){\\n            return n-pqe.top().first-pqo.top().first;\\n        }\\n    \\n        if(pqe.top().first >pqo.top().first){\\n            pqo.pop();\\n            if(!pqo.empty()){\\n                return n-pqe.top().first-pqo.top().first;\\n            }\\n            else{\\n                return n-pqe.top().first;\\n            }\\n        }\\n        if(pqe.top().first <pqo.top().first){\\n            pqe.pop();\\n            if(!pqe.empty()){\\n                return n-pqe.top().first-pqo.top().first;\\n            }\\n            else{\\n                return n-pqo.top().first;\\n            }\\n        }\\n        if(pqe.top().first==pqo.top().first){\\n            int a=pqe.top().first;\\n            pqe.pop();\\n            pqo.pop();\\n            if(pqo.empty() && pqe.empty()){\\n                return n-a;\\n            }\\n            if(pqo.empty()){\\n                return n-a-pqe.top().first;\\n            }\\n            if(pqe.empty()){\\n                return n-a-pqo.top().first;\\n            }\\n            return min(n-a-pqo.top().first,n-a-pqe.top().first);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        priority_queue<pair<int,int>> pqo;\\n        unordered_map<int,int> mpodd;\\n        for(int i=0;i<n;i=i+2){\\n            mpodd[nums[i]]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mpodd.begin();itr!=mpodd.end();itr++){\\n            pqo.push({itr->second,itr->first});\\n        }\\n        \\n        priority_queue<pair<int,int>> pqe;\\n        unordered_map<int,int> mpeven;\\n        for(int i=1;i<n;i=i+2){\\n            mpeven[nums[i]]++;\\n        }\\n        \\n        for(itr=mpeven.begin();itr!=mpeven.end();itr++){\\n            pqe.push({itr->second,itr->first});\\n        }\\n        if(pqe.top().second != pqo.top().second){\\n            return n-pqe.top().first-pqo.top().first;\\n        }\\n    \\n        if(pqe.top().first >pqo.top().first){\\n            pqo.pop();\\n            if(!pqo.empty()){\\n                return n-pqe.top().first-pqo.top().first;\\n            }\\n            else{\\n                return n-pqe.top().first;\\n            }\\n        }\\n        if(pqe.top().first <pqo.top().first){\\n            pqe.pop();\\n            if(!pqe.empty()){\\n                return n-pqe.top().first-pqo.top().first;\\n            }\\n            else{\\n                return n-pqo.top().first;\\n            }\\n        }\\n        if(pqe.top().first==pqo.top().first){\\n            int a=pqe.top().first;\\n            pqe.pop();\\n            pqo.pop();\\n            if(pqo.empty() && pqe.empty()){\\n                return n-a;\\n            }\\n            if(pqo.empty()){\\n                return n-a-pqe.top().first;\\n            }\\n            if(pqe.empty()){\\n                return n-a-pqo.top().first;\\n            }\\n            return min(n-a-pqo.top().first,n-a-pqe.top().first);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766841,
                "title": "priority-queue-c-easy-solution",
                "content": "```\\n                                                          //PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        vector<int>v1,v2;\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size();i=i+2)\\n            v1.push_back(nums[i]);\\n        \\n        for(int i=1;i<nums.size();i=i+2)\\n            v2.push_back(nums[i]);\\n        \\n        unordered_map<int,int>m1,m2;\\n        \\n        for(int i=0;i<v1.size();i++)                        // storing the elements in map\\n            m1[v1[i]]++;\\n        \\n        for(int i=0;i<v2.size();i++)               //storing the elements in map\\n            m2[v2[i]]++;\\n        \\n       priority_queue<pair<int,int>,vector<pair<int,int>> >pq1,pq2;\\n        \\n        for(auto it : m1)\\n            pq1.push({it.second,it.first});\\n        \\n        for(auto it : m2)                            \\n            pq2.push({it.second,it.first});\\n        \\n        int cnt=0;\\n        if(pq1.top().second==pq2.top().second)\\n        {\\n            cnt+=min(pq1.top().first, pq2.top().first);           // i have to count the min frequency so that later i can pop it\\n                \\n            if(pq1.top().first > pq2.top().first)\\n                pq2.pop();\\n\\t\\t\\t\\t\\n            else if(pq1.top().first < pq2.top().first)\\n                pq1.pop();\\n \\n            else\\n                pq1.pop();\\n            \\n        }\\n        \\n        if(!pq1.empty())          // this is done becoz i have to change the further elements in priority queue\\n        pq1.pop();                   //  to the element which has max frequency in pr queue\\n        if(!pq2.empty())          // that\\'s why i have to pop it.\\n        pq2.pop();\\n        \\n        while(!pq1.empty())\\n        {\\n            cnt+=pq1.top().first;\\n            pq1.pop();\\n        }\\n        \\n         while(!pq2.empty())\\n         {\\n            cnt+=pq2.top().first;\\n            pq2.pop();\\n         }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n                                                          //PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        vector<int>v1,v2;\\n        \\n        if(nums.size()==1)\\n            return 0;\\n        \\n        for(int i=0;i<nums.size();i=i+2)\\n            v1.push_back(nums[i]);\\n        \\n        for(int i=1;i<nums.size();i=i+2)\\n            v2.push_back(nums[i]);\\n        \\n        unordered_map<int,int>m1,m2;\\n        \\n        for(int i=0;i<v1.size();i++)                        // storing the elements in map\\n            m1[v1[i]]++;\\n        \\n        for(int i=0;i<v2.size();i++)               //storing the elements in map\\n            m2[v2[i]]++;\\n        \\n       priority_queue<pair<int,int>,vector<pair<int,int>> >pq1,pq2;\\n        \\n        for(auto it : m1)\\n            pq1.push({it.second,it.first});\\n        \\n        for(auto it : m2)                            \\n            pq2.push({it.second,it.first});\\n        \\n        int cnt=0;\\n        if(pq1.top().second==pq2.top().second)\\n        {\\n            cnt+=min(pq1.top().first, pq2.top().first);           // i have to count the min frequency so that later i can pop it\\n                \\n            if(pq1.top().first > pq2.top().first)\\n                pq2.pop();\\n\\t\\t\\t\\t\\n            else if(pq1.top().first < pq2.top().first)\\n                pq1.pop();\\n \\n            else\\n                pq1.pop();\\n            \\n        }\\n        \\n        if(!pq1.empty())          // this is done becoz i have to change the further elements in priority queue\\n        pq1.pop();                   //  to the element which has max frequency in pr queue\\n        if(!pq2.empty())          // that\\'s why i have to pop it.\\n        pq2.pop();\\n        \\n        while(!pq1.empty())\\n        {\\n            cnt+=pq1.top().first;\\n            pq1.pop();\\n        }\\n        \\n         while(!pq2.empty())\\n         {\\n            cnt+=pq2.top().first;\\n            pq2.pop();\\n         }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060924,
                "title": "i-got-the-inspiration-after-reading-the-hint-need-to-be-cleaned-rust-tm",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_operations(nums: Vec<i32>) -> i32 {\\n        if nums.len() <= 1 {return 0}\\n        let mut odd_pos: HashMap<i32, i32> = HashMap::new();\\n        // let mut max_freq_odd: [i32; 3] = [0, 0, nums.len() as i32 / 2]; // [max_freq, num, the_length]\\n        // if nums.len() % 2 != 0 {\\n        //     max_freq_odd[2] += 1;\\n        // }\\n        let mut even_pos: HashMap<i32, i32> = HashMap::new();\\n        // let mut max_freq_even: [i32; 3] = [0, 0, nums.len() as i32 / 2]; // [max_freq, num, the_length]\\n\\n        for i in 0..nums.len() {\\n            if (i+1) % 2 != 0 { // odd\\n                if let Some(freq) = odd_pos.get_mut(&nums[i]) {\\n                    *freq += 1;\\n                    // if *freq > max_freq_odd[0] {\\n                    //     max_freq_odd[0] = *freq;\\n                    //     max_freq_odd[1] = nums[i];\\n                    // }\\n                } else {\\n                    odd_pos.insert(nums[i], 1);\\n                    // if max_freq_odd[0] < 1 {\\n                    //     max_freq_odd[0] = 1;\\n                    //     max_freq_odd[1] = nums[i];\\n                    // }\\n                }\\n                continue;\\n            }\\n            if let Some(freq) = even_pos.get_mut(&nums[i]) {\\n                *freq += 1;\\n                // if *freq > max_freq_even[0] {\\n                //     max_freq_even[0] = *freq;\\n                //     max_freq_even[1] = nums[i];\\n                // }\\n            } else {\\n                even_pos.insert(nums[i], 1);\\n                // if max_freq_even[0] < 1 {\\n                //     max_freq_even[0] = 1;\\n                //     max_freq_even[1] = nums[i];\\n                // }\\n            }\\n \\n        }\\n        let mut odd_freq: Vec<Vec<i32>> = vec![];\\n        let mut even_freq: Vec<Vec<i32>> = vec![];\\n        // [[num, freq]]\\n        for (num, freq) in odd_pos.iter() {\\n            odd_freq.push(vec![*num, *freq]);\\n        }\\n        for (num, freq) in even_pos.iter() {\\n            even_freq.push(vec![*num, *freq]);\\n        }\\n        odd_freq.sort_by(|a, b| {\\n           if a[1] != b[1] {b[1].cmp(&a[1])}\\n           else {a[0].cmp(&b[0])} \\n        });\\n        even_freq.sort_by(|a, b| {\\n           if a[1] != b[1] {b[1].cmp(&a[1])}\\n           else {a[0].cmp(&b[0])} \\n        });\\n\\n        // println!(\"{:?}\\\\n{:?}\", odd_pos, even_pos);\\n        // println!(\"odd=>{:?}\\\\neven=>{:?}\", max_freq_odd, max_freq_even);\\n        // println!(\"odd_vec=>{:?}\\\\neven_vec=>{:?}\", odd_freq, even_freq);\\n        \\n        let mut count: i32 = 0;\\n        // the idea behind the solution is, i got it from reading the hint,\\n        // finding the num combination to maximaze unreplaced nums\\n\\n        // the first thing after we sort the nums based on the frequencies\\n        \\n        // condition 1 : if the odd and even have different num at the max frequencies\\n        // so to maximize it we just need to replace the number that arent the max freq in both odd and even, so just add the frequencies after the indices 0 -> 1,2,3,... on both odd and even\\n\\n        // condition 2 : if the nums are the same at the max frequencies\\n        // i made two count : the first -> if we replace the odd so the the num that need to be replaced are --> for odd (0,2,3,...) we skip indice 1 cause if we want to replace the odd the indice 1 is the next max frequencies after indeice 0\\n        // the second we replace the even, its the same as the odd, but we just reverse\\n\\n        // after that we compare it, which one is leesser\\n\\n        if odd_freq[0][0] != even_freq[0][0] {\\n            for i in 1..odd_freq.len() {\\n                count += odd_freq[i][1];\\n            }\\n            for i in 1..even_freq.len() {\\n                count += even_freq[i][1];\\n            } \\n        } else {\\n            let mut temp_1: i32 = odd_freq[0][1];\\n            // we change the odd\\n            for i in 2..odd_freq.len() {\\n                temp_1 += odd_freq[i][1];\\n            }\\n            for i in 1..even_freq.len() {\\n                temp_1 += even_freq[i][1];\\n            }\\n            let mut temp_2: i32 = even_freq[0][1];\\n            // we change the even\\n            for i in 2..even_freq.len() {\\n                temp_2 += even_freq[i][1];\\n            }\\n            for i in 1..odd_freq.len() {\\n                temp_2 += odd_freq[i][1];\\n            }\\n            // println!(\"1:>{}\\\\n2:>{}\", temp_1, temp_2);\\n            count = if (temp_1 >= temp_2) {temp_2} else {temp_1};\\n        }\\n\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn minimum_operations(nums: Vec<i32>) -> i32 {\\n        if nums.len() <= 1 {return 0}\\n        let mut odd_pos: HashMap<i32, i32> = HashMap::new();\\n        // let mut max_freq_odd: [i32; 3] = [0, 0, nums.len() as i32 / 2]; // [max_freq, num, the_length]\\n        // if nums.len() % 2 != 0 {\\n        //     max_freq_odd[2] += 1;\\n        // }\\n        let mut even_pos: HashMap<i32, i32> = HashMap::new();\\n        // let mut max_freq_even: [i32; 3] = [0, 0, nums.len() as i32 / 2]; // [max_freq, num, the_length]\\n\\n        for i in 0..nums.len() {\\n            if (i+1) % 2 != 0 { // odd\\n                if let Some(freq) = odd_pos.get_mut(&nums[i]) {\\n                    *freq += 1;\\n                    // if *freq > max_freq_odd[0] {\\n                    //     max_freq_odd[0] = *freq;\\n                    //     max_freq_odd[1] = nums[i];\\n                    // }\\n                } else {\\n                    odd_pos.insert(nums[i], 1);\\n                    // if max_freq_odd[0] < 1 {\\n                    //     max_freq_odd[0] = 1;\\n                    //     max_freq_odd[1] = nums[i];\\n                    // }\\n                }\\n                continue;\\n            }\\n            if let Some(freq) = even_pos.get_mut(&nums[i]) {\\n                *freq += 1;\\n                // if *freq > max_freq_even[0] {\\n                //     max_freq_even[0] = *freq;\\n                //     max_freq_even[1] = nums[i];\\n                // }\\n            } else {\\n                even_pos.insert(nums[i], 1);\\n                // if max_freq_even[0] < 1 {\\n                //     max_freq_even[0] = 1;\\n                //     max_freq_even[1] = nums[i];\\n                // }\\n            }\\n \\n        }\\n        let mut odd_freq: Vec<Vec<i32>> = vec![];\\n        let mut even_freq: Vec<Vec<i32>> = vec![];\\n        // [[num, freq]]\\n        for (num, freq) in odd_pos.iter() {\\n            odd_freq.push(vec![*num, *freq]);\\n        }\\n        for (num, freq) in even_pos.iter() {\\n            even_freq.push(vec![*num, *freq]);\\n        }\\n        odd_freq.sort_by(|a, b| {\\n           if a[1] != b[1] {b[1].cmp(&a[1])}\\n           else {a[0].cmp(&b[0])} \\n        });\\n        even_freq.sort_by(|a, b| {\\n           if a[1] != b[1] {b[1].cmp(&a[1])}\\n           else {a[0].cmp(&b[0])} \\n        });\\n\\n        // println!(\"{:?}\\\\n{:?}\", odd_pos, even_pos);\\n        // println!(\"odd=>{:?}\\\\neven=>{:?}\", max_freq_odd, max_freq_even);\\n        // println!(\"odd_vec=>{:?}\\\\neven_vec=>{:?}\", odd_freq, even_freq);\\n        \\n        let mut count: i32 = 0;\\n        // the idea behind the solution is, i got it from reading the hint,\\n        // finding the num combination to maximaze unreplaced nums\\n\\n        // the first thing after we sort the nums based on the frequencies\\n        \\n        // condition 1 : if the odd and even have different num at the max frequencies\\n        // so to maximize it we just need to replace the number that arent the max freq in both odd and even, so just add the frequencies after the indices 0 -> 1,2,3,... on both odd and even\\n\\n        // condition 2 : if the nums are the same at the max frequencies\\n        // i made two count : the first -> if we replace the odd so the the num that need to be replaced are --> for odd (0,2,3,...) we skip indice 1 cause if we want to replace the odd the indice 1 is the next max frequencies after indeice 0\\n        // the second we replace the even, its the same as the odd, but we just reverse\\n\\n        // after that we compare it, which one is leesser\\n\\n        if odd_freq[0][0] != even_freq[0][0] {\\n            for i in 1..odd_freq.len() {\\n                count += odd_freq[i][1];\\n            }\\n            for i in 1..even_freq.len() {\\n                count += even_freq[i][1];\\n            } \\n        } else {\\n            let mut temp_1: i32 = odd_freq[0][1];\\n            // we change the odd\\n            for i in 2..odd_freq.len() {\\n                temp_1 += odd_freq[i][1];\\n            }\\n            for i in 1..even_freq.len() {\\n                temp_1 += even_freq[i][1];\\n            }\\n            let mut temp_2: i32 = even_freq[0][1];\\n            // we change the even\\n            for i in 2..even_freq.len() {\\n                temp_2 += even_freq[i][1];\\n            }\\n            for i in 1..odd_freq.len() {\\n                temp_2 += odd_freq[i][1];\\n            }\\n            // println!(\"1:>{}\\\\n2:>{}\", temp_1, temp_2);\\n            count = if (temp_1 >= temp_2) {temp_2} else {temp_1};\\n        }\\n\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050069,
                "title": "easy-to-understand-c-map",
                "content": "\\n\\n# Approach\\nGet the first max element and it frq and freq of second max element ,thats all \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int freqmaxeven=0;\\n        int freqsecmaxeven=0;\\n        int maxeven=0;\\n        \\n        int freqmaxodd=0;\\n        int freqsecmaxodd=0;\\n        int maxodd=0;\\n        \\n        map<int,int> even,odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2){\\n                odd[nums[i]]++;\\n            }else{\\n                even[nums[i]]++; \\n            }\\n        }\\n       \\n        for(auto i: even){\\n             if(i.second>=freqmaxeven)\\n            {\\n                freqsecmaxeven=freqmaxeven;\\n                maxeven=i.first;\\n                freqmaxeven=i.second;\\n            }\\n            else if(i.second>freqsecmaxeven)\\n            {\\n                 freqsecmaxeven=i.second;\\n            }\\n    \\n        }\\n         for(auto i: odd){\\n             if(i.second>=freqmaxodd)\\n            {\\n                freqsecmaxodd=freqmaxodd;\\n                maxodd=i.first;\\n                freqmaxodd=i.second;\\n            }\\n            else if(i.second>freqsecmaxodd)\\n            {\\n                 freqsecmaxodd=i.second;\\n            }\\n    \\n        }\\n        if(maxodd!=maxeven){\\n            return nums.size()-(freqmaxodd+freqmaxeven);\\n        }else{\\n            return nums.size()-max(freqmaxeven+freqsecmaxodd,freqmaxodd+freqsecmaxeven);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int freqmaxeven=0;\\n        int freqsecmaxeven=0;\\n        int maxeven=0;\\n        \\n        int freqmaxodd=0;\\n        int freqsecmaxodd=0;\\n        int maxodd=0;\\n        \\n        map<int,int> even,odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2){\\n                odd[nums[i]]++;\\n            }else{\\n                even[nums[i]]++; \\n            }\\n        }\\n       \\n        for(auto i: even){\\n             if(i.second>=freqmaxeven)\\n            {\\n                freqsecmaxeven=freqmaxeven;\\n                maxeven=i.first;\\n                freqmaxeven=i.second;\\n            }\\n            else if(i.second>freqsecmaxeven)\\n            {\\n                 freqsecmaxeven=i.second;\\n            }\\n    \\n        }\\n         for(auto i: odd){\\n             if(i.second>=freqmaxodd)\\n            {\\n                freqsecmaxodd=freqmaxodd;\\n                maxodd=i.first;\\n                freqmaxodd=i.second;\\n            }\\n            else if(i.second>freqsecmaxodd)\\n            {\\n                 freqsecmaxodd=i.second;\\n            }\\n    \\n        }\\n        if(maxodd!=maxeven){\\n            return nums.size()-(freqmaxodd+freqmaxeven);\\n        }else{\\n            return nums.size()-max(freqmaxeven+freqsecmaxodd,freqmaxodd+freqsecmaxeven);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048736,
                "title": "very-intuitive-easy-java-solution-53ms-100-success",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public static class Pair\\n    {\\n        int ele, count;\\n\\n        public Pair(int ele, int count)\\n        {\\n            this.ele = ele;\\n            this.count = count;\\n        }\\n    }\\n\\n    public int minimumOperations(int[] nums)\\n    {\\n        final int n = nums.length;\\n        final HashMap<Integer, Integer> evenMap = new HashMap<>();\\n        final HashMap<Integer, Integer> oddMap = new HashMap<>();\\n\\n        Pair evenPrev = new Pair(0, 0), evenMax = new Pair(-1, 0);\\n        Pair oddPrev = new Pair(0, 0), oddMax = new Pair(-1, 0);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            int temp = 0;\\n\\n            if (i % 2 == 0)\\n            {\\n                evenMap.put(nums[i], temp = evenMap.getOrDefault(nums[i], 0) + 1);\\n\\n                if (evenMax.ele == nums[i])\\n                {\\n                    evenMax.count++;\\n                } \\n                else if (temp > evenMax.count)\\n                {\\n                    evenPrev = evenMax;\\n\\n                    evenMax = new Pair(nums[i], temp);\\n                }\\n                else if (temp > evenPrev.count) evenPrev = new Pair(nums[i], temp);\\n            }\\n            else\\n            {\\n                oddMap.put(nums[i], temp = oddMap.getOrDefault(nums[i], 0) + 1);\\n\\n                if (oddMax.ele == nums[i])\\n                {\\n                    oddMax.count++;\\n                }\\n                else if (temp > oddMax.count)\\n                {\\n                    oddPrev = oddMax;\\n\\n                    oddMax = new Pair(nums[i], temp);\\n                }\\n                else if (temp > oddPrev.count) oddPrev = new Pair(nums[i], temp);\\n            }\\n        }\\n\\n        int evenLen = (n / 2) + (n % 2), oddLen = (n / 2);\\n\\n        if (evenMax.ele == oddMax.ele)\\n        {\\n            int temp1 = (evenLen - evenMax.count) + (oddLen - oddPrev.count);\\n            int temp2 = (evenLen - evenPrev.count) + (oddLen - oddMax.count);\\n\\n            return Integer.min(temp1, temp2);\\n        }\\n\\n        return (evenLen - evenMax.count) + (oddLen - oddMax.count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public static class Pair\\n    {\\n        int ele, count;\\n\\n        public Pair(int ele, int count)\\n        {\\n            this.ele = ele;\\n            this.count = count;\\n        }\\n    }\\n\\n    public int minimumOperations(int[] nums)\\n    {\\n        final int n = nums.length;\\n        final HashMap<Integer, Integer> evenMap = new HashMap<>();\\n        final HashMap<Integer, Integer> oddMap = new HashMap<>();\\n\\n        Pair evenPrev = new Pair(0, 0), evenMax = new Pair(-1, 0);\\n        Pair oddPrev = new Pair(0, 0), oddMax = new Pair(-1, 0);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            int temp = 0;\\n\\n            if (i % 2 == 0)\\n            {\\n                evenMap.put(nums[i], temp = evenMap.getOrDefault(nums[i], 0) + 1);\\n\\n                if (evenMax.ele == nums[i])\\n                {\\n                    evenMax.count++;\\n                } \\n                else if (temp > evenMax.count)\\n                {\\n                    evenPrev = evenMax;\\n\\n                    evenMax = new Pair(nums[i], temp);\\n                }\\n                else if (temp > evenPrev.count) evenPrev = new Pair(nums[i], temp);\\n            }\\n            else\\n            {\\n                oddMap.put(nums[i], temp = oddMap.getOrDefault(nums[i], 0) + 1);\\n\\n                if (oddMax.ele == nums[i])\\n                {\\n                    oddMax.count++;\\n                }\\n                else if (temp > oddMax.count)\\n                {\\n                    oddPrev = oddMax;\\n\\n                    oddMax = new Pair(nums[i], temp);\\n                }\\n                else if (temp > oddPrev.count) oddPrev = new Pair(nums[i], temp);\\n            }\\n        }\\n\\n        int evenLen = (n / 2) + (n % 2), oddLen = (n / 2);\\n\\n        if (evenMax.ele == oddMax.ele)\\n        {\\n            int temp1 = (evenLen - evenMax.count) + (oddLen - oddPrev.count);\\n            int temp2 = (evenLen - evenPrev.count) + (oddLen - oddMax.count);\\n\\n            return Integer.min(temp1, temp2);\\n        }\\n\\n        return (evenLen - evenMax.count) + (oddLen - oddMax.count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048091,
                "title": "greedy-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        length=len(nums)\\n        if length%2:\\n            even_length=(length+1)//2\\n        else:\\n            even_length=length//2\\n        odd_length=length//2\\n        even_hash=defaultdict(int)\\n        odd_hash=defaultdict(int)\\n        maxi_even=0\\n        maxi_odd=0\\n        me=0\\n        mo=0\\n        for i in range(0,length,2):\\n            even_hash[nums[i]]+=1\\n            if maxi_even<even_hash[nums[i]]:\\n                maxi_even=even_hash[nums[i]]\\n                me=nums[i]\\n        opr_even=even_length-maxi_even\\n        for i in range(1,length,2):\\n            odd_hash[nums[i]]+=1\\n            if maxi_odd<odd_hash[nums[i]] and nums[i]!=me:\\n                maxi_odd=odd_hash[nums[i]]\\n                mo=nums[i]\\n        opr_odd=odd_length-maxi_odd\\n        fi=opr_odd+opr_even\\n        \\n        \\n        \\n        even_hash=defaultdict(int)\\n        odd_hash=defaultdict(int)\\n        maxi_even=0\\n        maxi_odd=0\\n        me=0\\n        mo=0\\n        \\n        for i in range(1,length,2):\\n            odd_hash[nums[i]]+=1\\n            if maxi_odd<odd_hash[nums[i]]:\\n                maxi_odd=odd_hash[nums[i]]\\n                mo=nums[i]\\n        for i in range(0,length,2):\\n            even_hash[nums[i]]+=1\\n            if maxi_even<even_hash[nums[i]] and nums[i]!=mo:\\n                maxi_even=even_hash[nums[i]]\\n                me=nums[i]\\n        opr_even=even_length-maxi_even\\n        opr_odd=odd_length-maxi_odd\\n        fj=opr_even+opr_odd\\n        return min(fi,fj)\\n            \\n\\n        \\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        length=len(nums)\\n        if length%2:\\n            even_length=(length+1)//2\\n        else:\\n            even_length=length//2\\n        odd_length=length//2\\n        even_hash=defaultdict(int)\\n        odd_hash=defaultdict(int)\\n        maxi_even=0\\n        maxi_odd=0\\n        me=0\\n        mo=0\\n        for i in range(0,length,2):\\n            even_hash[nums[i]]+=1\\n            if maxi_even<even_hash[nums[i]]:\\n                maxi_even=even_hash[nums[i]]\\n                me=nums[i]\\n        opr_even=even_length-maxi_even\\n        for i in range(1,length,2):\\n            odd_hash[nums[i]]+=1\\n            if maxi_odd<odd_hash[nums[i]] and nums[i]!=me:\\n                maxi_odd=odd_hash[nums[i]]\\n                mo=nums[i]\\n        opr_odd=odd_length-maxi_odd\\n        fi=opr_odd+opr_even\\n        \\n        \\n        \\n        even_hash=defaultdict(int)\\n        odd_hash=defaultdict(int)\\n        maxi_even=0\\n        maxi_odd=0\\n        me=0\\n        mo=0\\n        \\n        for i in range(1,length,2):\\n            odd_hash[nums[i]]+=1\\n            if maxi_odd<odd_hash[nums[i]]:\\n                maxi_odd=odd_hash[nums[i]]\\n                mo=nums[i]\\n        for i in range(0,length,2):\\n            even_hash[nums[i]]+=1\\n            if maxi_even<even_hash[nums[i]] and nums[i]!=mo:\\n                maxi_even=even_hash[nums[i]]\\n                me=nums[i]\\n        opr_even=even_length-maxi_even\\n        opr_odd=odd_length-maxi_odd\\n        fj=opr_even+opr_odd\\n        return min(fi,fj)\\n            \\n\\n        \\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040542,
                "title": "c-one-pass-o-n",
                "content": "It boils down to needing to find the most frequent numbers at even and odd indicies. With the caveat that when returning, if the two most freqeuent number are the same, must use second most frequent.\\n\\nI think this should be hard since it is rather tedious. I would not expect someone to get this in an interview.\\n\\nThe first code is the nicely formatted solution. The second code is the \"raw\" first draft code which shows the cases better.\\n\\n```\\n    int minimumOperations(vector<int>& nums) {\\n        vector<vector<int>>   times(2, vector<int>(100001, 0));\\n        vector<pair<int,int>> curr(2, {0,0});\\n        \\n        for (int i = 0; i != size(nums); ++i)\\n        {\\n            int n       = nums[i];\\n            auto& v     = times[i % 2];\\n            auto& [a,b] = curr[i % 2];\\n            int largest = ++v[n];\\n\\n            if (largest >= v[a])\\n            {\\n                if (n != a)\\n                    b = a;\\n                a = n;\\n            }\\n            else if (largest >= v[b])\\n                b = n;\\n        }\\n        \\n        auto& odd        = times[1];\\n        auto& even       = times[0];\\n        auto& [lo1, lo2] = curr[1];\\n        auto& [le1, le2] = curr[0];\\n        \\n        if (lo1 == le1)\\n            return size(nums) - max(odd[lo1] + even[le2], odd[lo2] + even[le1]);\\n        return size(nums) - odd[lo1] - even[le1];\\n    }\\n```\\n\\n```\\nint minimumOperations(vector<int>& nums) {\\n        vector<int> odd(100001, 0),\\n                    even(100001, 0);\\n        int le1 = 0, le2 = 0, lo1 = 0, lo2 = 0; \\n        \\n        for (int i = 0; i != size(nums); ++i)\\n        {\\n            int n = nums[i];\\n            \\n            if (i % 2)\\n            {\\n                int largest = ++odd[n];\\n                \\n                // if setting either 1,2 will result in same\\n                //  make sure its not same\\n                \\n                if (largest >= odd[lo1])\\n                {\\n                    if (n == lo2)\\n                    {\\n                        lo2 = lo1;\\n                        lo1 = n;\\n                    }\\n                    else if (n == lo1)\\n                    {\\n                        lo1 = n;\\n                    }\\n                    else\\n                    {\\n                        lo2 = lo1;\\n                        lo1 = n;\\n                    }\\n                }\\n                else if (largest >= odd[lo2])\\n                {\\n                    lo2 = n;\\n                }\\n            }\\n            else\\n            {\\n                int largest = ++even[n];\\n                \\n                if (largest >= even[le1])\\n                {\\n                    if (n == le2)\\n                    {\\n                        le2 = le1;\\n                        le1 = n;\\n                    }\\n                    else if (n == le1)\\n                    {\\n                        le1 = n;\\n                    }\\n                    else\\n                    {\\n                        le2 = le1;\\n                        le1 = n;\\n                    }\\n                }\\n                else if (largest >= even[le2])\\n                {\\n                    le2 = n;\\n                }\\n            }\\n        }\\n        \\n        if (lo1 == le1)\\n        {\\n            int a = max(odd[lo1] + even[le2], odd[lo2] + even[le1]);\\n            return size(nums) - a;\\n        }\\n            \\n        return size(nums) - odd[lo1] - even[le1];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int minimumOperations(vector<int>& nums) {\\n        vector<vector<int>>   times(2, vector<int>(100001, 0));\\n        vector<pair<int,int>> curr(2, {0,0});\\n        \\n        for (int i = 0; i != size(nums); ++i)\\n        {\\n            int n       = nums[i];\\n            auto& v     = times[i % 2];\\n            auto& [a,b] = curr[i % 2];\\n            int largest = ++v[n];\\n\\n            if (largest >= v[a])\\n            {\\n                if (n != a)\\n                    b = a;\\n                a = n;\\n            }\\n            else if (largest >= v[b])\\n                b = n;\\n        }\\n        \\n        auto& odd        = times[1];\\n        auto& even       = times[0];\\n        auto& [lo1, lo2] = curr[1];\\n        auto& [le1, le2] = curr[0];\\n        \\n        if (lo1 == le1)\\n            return size(nums) - max(odd[lo1] + even[le2], odd[lo2] + even[le1]);\\n        return size(nums) - odd[lo1] - even[le1];\\n    }\\n```\n```\\nint minimumOperations(vector<int>& nums) {\\n        vector<int> odd(100001, 0),\\n                    even(100001, 0);\\n        int le1 = 0, le2 = 0, lo1 = 0, lo2 = 0; \\n        \\n        for (int i = 0; i != size(nums); ++i)\\n        {\\n            int n = nums[i];\\n            \\n            if (i % 2)\\n            {\\n                int largest = ++odd[n];\\n                \\n                // if setting either 1,2 will result in same\\n                //  make sure its not same\\n                \\n                if (largest >= odd[lo1])\\n                {\\n                    if (n == lo2)\\n                    {\\n                        lo2 = lo1;\\n                        lo1 = n;\\n                    }\\n                    else if (n == lo1)\\n                    {\\n                        lo1 = n;\\n                    }\\n                    else\\n                    {\\n                        lo2 = lo1;\\n                        lo1 = n;\\n                    }\\n                }\\n                else if (largest >= odd[lo2])\\n                {\\n                    lo2 = n;\\n                }\\n            }\\n            else\\n            {\\n                int largest = ++even[n];\\n                \\n                if (largest >= even[le1])\\n                {\\n                    if (n == le2)\\n                    {\\n                        le2 = le1;\\n                        le1 = n;\\n                    }\\n                    else if (n == le1)\\n                    {\\n                        le1 = n;\\n                    }\\n                    else\\n                    {\\n                        le2 = le1;\\n                        le1 = n;\\n                    }\\n                }\\n                else if (largest >= even[le2])\\n                {\\n                    le2 = n;\\n                }\\n            }\\n        }\\n        \\n        if (lo1 == le1)\\n        {\\n            int a = max(odd[lo1] + even[le2], odd[lo2] + even[le1]);\\n            return size(nums) - a;\\n        }\\n            \\n        return size(nums) - odd[lo1] - even[le1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037436,
                "title": "greedy-clean-best-code",
                "content": "# Code\\n# Please Upvote if u found it useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size(), even_cnt = 0, odd_cnt = 0;\\n        if(n == 1)\\n            return 0;\\n        if(n == 2 && nums[0] == nums[1])\\n            return 1;\\n        unordered_map<int, int> even, odd;\\n        for(int i = 0 ; i < n ; i++){\\n            if(i & 1){\\n                odd_cnt++;\\n                odd[nums[i]]++;\\n            }\\n            else{\\n                even_cnt++;\\n                even[nums[i]]++;\\n            }\\n        }\\n        vector<pair<int, int>> e, o;\\n        for(auto it : even)\\n            e.push_back({it.second, it.first});\\n        for(auto it : odd)\\n            o.push_back({it.second, it.first});\\n        sort(e.begin(), e.end(), greater<pair<int, int>> ());\\n        sort(o.begin(), o.end(), greater<pair<int, int>> ());\\n\\n        int c1 = e[0].first, c2 = o[0].first, val1 = e[0].second, val2 = o[0].second;\\n        int tmp1 = even_cnt - c1, tmp2 = odd_cnt - c2, s1 = e.size(), s2 = o.size();\\n        if(val1 != val2)\\n            return tmp1 + tmp2;\\n        else{\\n            int x, y, cnt1 = c1, cnt2 = c2;\\n            if(s1 > 1)\\n                x = e[1].first, cnt1 = even_cnt - x;\\n            if(s2 > 1)\\n                y = o[1].first, cnt2 = odd_cnt - y;\\n            return min(tmp1 + cnt2, tmp2 + cnt1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size(), even_cnt = 0, odd_cnt = 0;\\n        if(n == 1)\\n            return 0;\\n        if(n == 2 && nums[0] == nums[1])\\n            return 1;\\n        unordered_map<int, int> even, odd;\\n        for(int i = 0 ; i < n ; i++){\\n            if(i & 1){\\n                odd_cnt++;\\n                odd[nums[i]]++;\\n            }\\n            else{\\n                even_cnt++;\\n                even[nums[i]]++;\\n            }\\n        }\\n        vector<pair<int, int>> e, o;\\n        for(auto it : even)\\n            e.push_back({it.second, it.first});\\n        for(auto it : odd)\\n            o.push_back({it.second, it.first});\\n        sort(e.begin(), e.end(), greater<pair<int, int>> ());\\n        sort(o.begin(), o.end(), greater<pair<int, int>> ());\\n\\n        int c1 = e[0].first, c2 = o[0].first, val1 = e[0].second, val2 = o[0].second;\\n        int tmp1 = even_cnt - c1, tmp2 = odd_cnt - c2, s1 = e.size(), s2 = o.size();\\n        if(val1 != val2)\\n            return tmp1 + tmp2;\\n        else{\\n            int x, y, cnt1 = c1, cnt2 = c2;\\n            if(s1 > 1)\\n                x = e[1].first, cnt1 = even_cnt - x;\\n            if(s2 > 1)\\n                y = o[1].first, cnt2 = odd_cnt - y;\\n            return min(tmp1 + cnt2, tmp2 + cnt1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968145,
                "title": "key-idea-explained-python",
                "content": "Final array looks like this `[x, y, x, y, x, y]`\\nfind the the most occuring elment on odd and even index separately, choose them as `x,y`\\n\\n`if x == y`, then pair second most occuring with `x,y` and return the best combination\\n\\n**Time: O(n)\\nSpace: O(n)**\\n```\\ndef minimumOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if n == 1: return 0\\n\\n    odd = Counter([nums[i] for i in range(n) if i%2])\\n    even = Counter([nums[i] for i in range(n) if not i%2])\\n    odd[\"x\"] = even[\"y\"] = 0\\n\\n    odd_cost = lambda k: n//2 - odd[k]\\n    even_cost = lambda k: ceil(n/2) - even[k]\\n\\n    odd_top_2 = nsmallest(2, odd.keys(), key=odd_cost)\\n    even_top_2 = nsmallest(2, even.keys(), key=even_cost)\\n\\n    a,b = odd_top_2[:2]\\n    c,d = even_top_2[:2]\\n\\n    if a != c: return odd_cost(a) + even_cost(c)\\n    return min(odd_cost(a) + even_cost(d), odd_cost(b) + even_cost(c))\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\ndef minimumOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if n == 1: return 0\\n\\n    odd = Counter([nums[i] for i in range(n) if i%2])\\n    even = Counter([nums[i] for i in range(n) if not i%2])\\n    odd[\"x\"] = even[\"y\"] = 0\\n\\n    odd_cost = lambda k: n//2 - odd[k]\\n    even_cost = lambda k: ceil(n/2) - even[k]\\n\\n    odd_top_2 = nsmallest(2, odd.keys(), key=odd_cost)\\n    even_top_2 = nsmallest(2, even.keys(), key=even_cost)\\n\\n    a,b = odd_top_2[:2]\\n    c,d = even_top_2[:2]\\n\\n    if a != c: return odd_cost(a) + even_cost(c)\\n    return min(odd_cost(a) + even_cost(d), odd_cost(b) + even_cost(c))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3952217,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return 0;\\n        }\\n        if(nums.length==2)\\n        {\\n            if(nums[0]!=nums[1])\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return 1;\\n            }\\n        }\\n       HashMap<Integer,Integer> h1=new HashMap<Integer,Integer>();\\n       HashMap<Integer,Integer> h2=new HashMap<Integer,Integer>();\\n       int countEven=0,countOdd=0;\\n       for(int i=0;i<nums.length;i=i+2)\\n       {\\n           countEven++;\\n           if(!h1.containsKey(nums[i]))\\n           {\\n               h1.put(nums[i],1);\\n           }\\n           else\\n           {\\n               h1.put(nums[i],h1.get(nums[i])+1);\\n           }\\n       }\\n        \\n       for(int i=1;i<nums.length;i=i+2)\\n       {\\n           countOdd++;\\n           if(!h2.containsKey(nums[i]))\\n           {\\n               h2.put(nums[i],1);\\n           }\\n           else\\n           {\\n               h2.put(nums[i],h2.get(nums[i])+1);\\n           }\\n       }\\n        int max1=1; // for even index\\n        int n1=0;\\n        for(Map.Entry<Integer,Integer> entry: h1.entrySet())\\n        {\\n            if(entry.getValue()>max1)\\n            {\\n                max1=entry.getValue();\\n                n1=entry.getKey();\\n            }\\n        }\\n        int max2=1; // for odd index\\n        int n2=0;\\n        for(Map.Entry<Integer,Integer> entry: h2.entrySet())\\n        {\\n            if(entry.getValue()>max2)\\n            {\\n                max2=entry.getValue();\\n                n2=entry.getKey();\\n            }\\n        }\\n        if(n1==n2)\\n        {\\n                     if(max1==countEven)\\n                     {\\n                         max2=0;\\n                        for(Map.Entry<Integer,Integer> entry: h2.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>max2 && entry.getKey()!=n2)\\n                            {\\n                                max2=total;\\n                            }\\n                        }\\n                     }\\n                     else if(max2==countOdd)\\n                     {\\n                         max1=0;\\n                        for(Map.Entry<Integer,Integer> entry: h1.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>max1 && entry.getKey()!=n2)\\n                            {\\n                                max1=total;\\n                            }\\n                        }\\n                     }\\n                     else\\n                     {\\n                         int m1=0,m2=0;\\n                        for(Map.Entry<Integer,Integer> entry: h2.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>m2 && entry.getKey()!=n2)\\n                            {\\n                                m2=total;\\n                            }\\n                        }\\n                        int ans1=countEven-max1+countOdd-m2;\\n                        for(Map.Entry<Integer,Integer> entry: h1.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>m1 && entry.getKey()!=n2)\\n                            {\\n                                m1=total;\\n                            }\\n                        }\\n                        int ans2=countEven-m1+countOdd-max2;\\n                        return Math.min(ans1,ans2);\\n\\n                     }\\n                }\\n    \\n            int result=0;\\n            result=countOdd-max2+countEven-max1;\\n\\n            return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return 0;\\n        }\\n        if(nums.length==2)\\n        {\\n            if(nums[0]!=nums[1])\\n            {\\n                return 0;\\n            }\\n            else\\n            {\\n                return 1;\\n            }\\n        }\\n       HashMap<Integer,Integer> h1=new HashMap<Integer,Integer>();\\n       HashMap<Integer,Integer> h2=new HashMap<Integer,Integer>();\\n       int countEven=0,countOdd=0;\\n       for(int i=0;i<nums.length;i=i+2)\\n       {\\n           countEven++;\\n           if(!h1.containsKey(nums[i]))\\n           {\\n               h1.put(nums[i],1);\\n           }\\n           else\\n           {\\n               h1.put(nums[i],h1.get(nums[i])+1);\\n           }\\n       }\\n        \\n       for(int i=1;i<nums.length;i=i+2)\\n       {\\n           countOdd++;\\n           if(!h2.containsKey(nums[i]))\\n           {\\n               h2.put(nums[i],1);\\n           }\\n           else\\n           {\\n               h2.put(nums[i],h2.get(nums[i])+1);\\n           }\\n       }\\n        int max1=1; // for even index\\n        int n1=0;\\n        for(Map.Entry<Integer,Integer> entry: h1.entrySet())\\n        {\\n            if(entry.getValue()>max1)\\n            {\\n                max1=entry.getValue();\\n                n1=entry.getKey();\\n            }\\n        }\\n        int max2=1; // for odd index\\n        int n2=0;\\n        for(Map.Entry<Integer,Integer> entry: h2.entrySet())\\n        {\\n            if(entry.getValue()>max2)\\n            {\\n                max2=entry.getValue();\\n                n2=entry.getKey();\\n            }\\n        }\\n        if(n1==n2)\\n        {\\n                     if(max1==countEven)\\n                     {\\n                         max2=0;\\n                        for(Map.Entry<Integer,Integer> entry: h2.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>max2 && entry.getKey()!=n2)\\n                            {\\n                                max2=total;\\n                            }\\n                        }\\n                     }\\n                     else if(max2==countOdd)\\n                     {\\n                         max1=0;\\n                        for(Map.Entry<Integer,Integer> entry: h1.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>max1 && entry.getKey()!=n2)\\n                            {\\n                                max1=total;\\n                            }\\n                        }\\n                     }\\n                     else\\n                     {\\n                         int m1=0,m2=0;\\n                        for(Map.Entry<Integer,Integer> entry: h2.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>m2 && entry.getKey()!=n2)\\n                            {\\n                                m2=total;\\n                            }\\n                        }\\n                        int ans1=countEven-max1+countOdd-m2;\\n                        for(Map.Entry<Integer,Integer> entry: h1.entrySet())\\n                        {\\n                            int total=entry.getValue();\\n                            if(total>m1 && entry.getKey()!=n2)\\n                            {\\n                                m1=total;\\n                            }\\n                        }\\n                        int ans2=countEven-m1+countOdd-max2;\\n                        return Math.min(ans1,ans2);\\n\\n                     }\\n                }\\n    \\n            int result=0;\\n            result=countOdd-max2+countEven-max1;\\n\\n            return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633657,
                "title": "check-maximum-and-second-maximum-at-odd-and-even-indices",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ctr = [Counter(), Counter()]\\n        for i in range(n):\\n            ctr[i % 2][nums[i]] += 1\\n        res = 0\\n        evensecmax, evenmax = (0, 0), (0, 0)\\n        oddsecmax, oddmax = (0, 0), (0, 0)\\n        for el in ctr[0]:\\n            temp, evensecmax, evenmax = sorted([evensecmax, evenmax, (ctr[0][el], el)])\\n        for el in ctr[1]:\\n            temp, oddsecmax, oddmax = sorted([oddsecmax, oddmax, (ctr[1][el], el)])\\n        for a in [evensecmax[1], evenmax[1]]:\\n            for b in [oddsecmax[1], oddmax[1]]:\\n                if a != b:\\n                    res = max(res, ctr[0][a] + ctr[1][b])\\n        return n - res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ctr = [Counter(), Counter()]\\n        for i in range(n):\\n            ctr[i % 2][nums[i]] += 1\\n        res = 0\\n        evensecmax, evenmax = (0, 0), (0, 0)\\n        oddsecmax, oddmax = (0, 0), (0, 0)\\n        for el in ctr[0]:\\n            temp, evensecmax, evenmax = sorted([evensecmax, evenmax, (ctr[0][el], el)])\\n        for el in ctr[1]:\\n            temp, oddsecmax, oddmax = sorted([oddsecmax, oddmax, (ctr[1][el], el)])\\n        for a in [evensecmax[1], evenmax[1]]:\\n            for b in [oddsecmax[1], oddmax[1]]:\\n                if a != b:\\n                    res = max(res, ctr[0][a] + ctr[1][b])\\n        return n - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584612,
                "title": "count-even-and-odd-array",
                "content": "# Approach\\nIf array contains one element, done.\\n\\nOtherwise, utilize odd, even counter to find frequency of most, second most elements of both arrays.\\n\\nIf most frequent element in both array has different, then we could turn other odd index elements into most common element in odd indices, and so does even array.\\n\\nElse, we consider most common element in odd (even) array and second common element in even(odd) array.  \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n\\n        Le = sorted(Counter([val for i, val in enumerate(nums) if i % 2 == 0]).items(), key = itemgetter(1), reverse = True)\\n        Lo = sorted(Counter([val for i, val in enumerate(nums) if i % 2]).items(), key = itemgetter(1), reverse = True)\\n        \\n        if Le[0][0] != Lo[0][0]:\\n            return len(nums) - Le[0][1] - Lo[0][1]\\n        else:\\n            ret = 10 ** 5 + 1\\n            \\n            if len(Le) == len(Lo) == 1:\\n                return Lo[0][1]\\n            if len(Le) > 1:\\n                ret = min(ret, len(nums) - Le[1][1] - Lo[0][1])\\n            if len(Lo) > 1:\\n                ret = min(ret, len(nums) - Le[0][1] - Lo[1][1])\\n\\n            return ret \\n\\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n\\n        Le = sorted(Counter([val for i, val in enumerate(nums) if i % 2 == 0]).items(), key = itemgetter(1), reverse = True)\\n        Lo = sorted(Counter([val for i, val in enumerate(nums) if i % 2]).items(), key = itemgetter(1), reverse = True)\\n        \\n        if Le[0][0] != Lo[0][0]:\\n            return len(nums) - Le[0][1] - Lo[0][1]\\n        else:\\n            ret = 10 ** 5 + 1\\n            \\n            if len(Le) == len(Lo) == 1:\\n                return Lo[0][1]\\n            if len(Le) > 1:\\n                ret = min(ret, len(nums) - Le[1][1] - Lo[0][1])\\n            if len(Lo) > 1:\\n                ret = min(ret, len(nums) - Le[0][1] - Lo[1][1])\\n\\n            return ret \\n\\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581501,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void setMax(int &nc1, int &nc2,  int &nums1, int &nums2, int curCnt, int curNum) {\\n        if (nc1 < curCnt) {\\n            if (curNum != nums1) {\\n                nc2 = nc1;\\n                nums2 = nums1;\\n            }\\n            nc1 = curCnt;\\n            nums1 = curNum;\\n        } else if (nc2 < curCnt) {\\n            nc2 = curCnt;\\n            nums2 = curNum;\\n        } \\n    }\\n    \\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int> even;\\n        unordered_map<int,int> odd;\\n        int n = nums.size();\\n        int ne1 = 0; int ne2 = 0;\\n        int no1 = 0; int no2 = 0;\\n        int e1 = -1,e2 = -1,o1 = -1,o2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (i%2 == 0) {\\n                even[nums[i]]++;\\n                setMax(ne1,ne2,e1,e2,even[nums[i]],nums[i]);\\n            } else {\\n                odd[nums[i]]++;\\n                setMax(no1,no2,o1,o2,odd[nums[i]],nums[i]);\\n            }\\n        }\\n        int total = 0;\\n        if (e1 != o1) {\\n            total = n - (ne1 + no1);\\n        } else {\\n            total = n - max((ne1 + no2), (ne2 + no1));\\n        }\\n        return total;\\n      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setMax(int &nc1, int &nc2,  int &nums1, int &nums2, int curCnt, int curNum) {\\n        if (nc1 < curCnt) {\\n            if (curNum != nums1) {\\n                nc2 = nc1;\\n                nums2 = nums1;\\n            }\\n            nc1 = curCnt;\\n            nums1 = curNum;\\n        } else if (nc2 < curCnt) {\\n            nc2 = curCnt;\\n            nums2 = curNum;\\n        } \\n    }\\n    \\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int> even;\\n        unordered_map<int,int> odd;\\n        int n = nums.size();\\n        int ne1 = 0; int ne2 = 0;\\n        int no1 = 0; int no2 = 0;\\n        int e1 = -1,e2 = -1,o1 = -1,o2 = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (i%2 == 0) {\\n                even[nums[i]]++;\\n                setMax(ne1,ne2,e1,e2,even[nums[i]],nums[i]);\\n            } else {\\n                odd[nums[i]]++;\\n                setMax(no1,no2,o1,o2,odd[nums[i]],nums[i]);\\n            }\\n        }\\n        int total = 0;\\n        if (e1 != o1) {\\n            total = n - (ne1 + no1);\\n        } else {\\n            total = n - max((ne1 + no2), (ne2 + no1));\\n        }\\n        return total;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580796,
                "title": "using-priority-queue-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        int n = nums.size();\\n        unordered_map<int,int> mp1,mp2;\\n        priority_queue<pair<int,int>> pq1,pq2;\\n        for(int i=0; i<n; i+=2){\\n            mp1[nums[i]]++;\\n        }\\n        for(int i=1; i<n; i+=2){\\n            mp2[nums[i]]++;\\n        }\\n        for(auto it : mp1){\\n            pq1.push({it.second,it.first});\\n        }\\n        for(auto it : mp2){\\n            pq2.push({it.second,it.first});\\n        }\\n        if(pq1.top().second != pq2.top().second){\\n            return n - pq1.top().first - pq2.top().first;\\n        }\\n        auto p1 = pq1.top();\\n        auto p2 = pq2.top();\\n        pq1.pop();\\n        pq2.pop();\\n        int f = 0,s = 0;\\n        if(pq1.size()){\\n            f = pq1.top().first;\\n        }\\n        if(pq2.size()){\\n            s = pq2.top().first;\\n        }\\n        return n - max(p1.first+s,f+p2.first);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        int n = nums.size();\\n        unordered_map<int,int> mp1,mp2;\\n        priority_queue<pair<int,int>> pq1,pq2;\\n        for(int i=0; i<n; i+=2){\\n            mp1[nums[i]]++;\\n        }\\n        for(int i=1; i<n; i+=2){\\n            mp2[nums[i]]++;\\n        }\\n        for(auto it : mp1){\\n            pq1.push({it.second,it.first});\\n        }\\n        for(auto it : mp2){\\n            pq2.push({it.second,it.first});\\n        }\\n        if(pq1.top().second != pq2.top().second){\\n            return n - pq1.top().first - pq2.top().first;\\n        }\\n        auto p1 = pq1.top();\\n        auto p2 = pq2.top();\\n        pq1.pop();\\n        pq2.pop();\\n        int f = 0,s = 0;\\n        if(pq1.size()){\\n            f = pq1.top().first;\\n        }\\n        if(pq2.size()){\\n            s = pq2.top().first;\\n        }\\n        return n - max(p1.first+s,f+p2.first);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559167,
                "title": "c-max-heap-hash-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return 0;\\n        priority_queue<pair<int,int>> e,o;\\n        map<int,int> m1,m2;\\n        for(int i=0;i<n;i+=2)\\n            m1[nums[i]]++;\\n        for(int i=1;i<n;i+=2)\\n            m2[nums[i]]++;\\n        for(auto &i:m1)\\n        {\\n            e.push({i.second,i.first});\\n        }\\n        for(auto &i:m2)\\n        {\\n            o.push({i.second,i.first});\\n        }\\n        if(o.top().second!=e.top().second)\\n        {\\n            return n-e.top().first-o.top().first;\\n        }\\n        else\\n        {\\n            int e1 = e.top().first;\\n            int o1 = o.top().first;\\n            e.pop();\\n            o.pop();\\n            int e2 = 0,o2 = 0;\\n            if(e.size()>0)\\n                e2 = e.top().first;\\n            if(o.size()>0)\\n                o2 = o.top().first;\\n            return n-max(e1+o2,o1+e2);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return 0;\\n        priority_queue<pair<int,int>> e,o;\\n        map<int,int> m1,m2;\\n        for(int i=0;i<n;i+=2)\\n            m1[nums[i]]++;\\n        for(int i=1;i<n;i+=2)\\n            m2[nums[i]]++;\\n        for(auto &i:m1)\\n        {\\n            e.push({i.second,i.first});\\n        }\\n        for(auto &i:m2)\\n        {\\n            o.push({i.second,i.first});\\n        }\\n        if(o.top().second!=e.top().second)\\n        {\\n            return n-e.top().first-o.top().first;\\n        }\\n        else\\n        {\\n            int e1 = e.top().first;\\n            int o1 = o.top().first;\\n            e.pop();\\n            o.pop();\\n            int e2 = 0,o2 = 0;\\n            if(e.size()>0)\\n                e2 = e.top().first;\\n            if(o.size()>0)\\n                o2 = o.top().first;\\n            return n-max(e1+o2,o1+e2);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489463,
                "title": "a-bit-harder-than-a-medium-level-at-first-glance",
                "content": "# Intuition\\nIn ideal alternating array there two different symbols most frequently appeared and no other symbols. So \"brocken\" array could have other symbols but less appeared then two-most frequently appeared.\\nTotal number of symbols minus number of two most frequently appeared symbols should give a minimum number of corrections.\\n\\n# Approach\\nHowever, odd and even symbols should be parsed separatelly. Since [2,2,2,2,2] is not an alternating. So, making a bucket counting class, and then two instances for odd and even numbers should give us a totals and two-most frequently appeared symbols count.  \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumOperations = function(nums) {\\nvar array = nums;\\n\\nclass maxCount {\\n  constructor() { \\n    this.fMax = 0;\\n    this.sMax = 0;\\n    this.fMaxIdx = \"\";\\n    this.sMaxIdx = \"\";\\n    this.iKey = {}; \\n    this.total = 0;\\n  }\\n  addMember(x) { \\n    let idx = x.toString();\\n    this.total++;\\n    if (this.iKey[idx]) { \\n      this.iKey[idx] = this.iKey[idx] + 1\\n    } else { \\n      this.iKey[idx] = 1 \\n    }\\n    if (this.fMax < this.iKey[idx]) {\\n       this.fMaxIdx = idx;\\n       this.fMax = this.iKey[idx]\\n    } else if (this.sMax < this.iKey[idx]) {\\n      this.sMaxIdx = idx;\\n      this.sMax = this.iKey[idx]\\n    }\\n  }\\n  getTotal() { \\n    return this.total\\n   }\\n  getMaxIdx() { \\n    return this.fMaxIdx\\n  }\\n  getFMax() {\\n    return this.fMax\\n  }\\n  getSMax() {\\n    return this.sMax\\n  }\\n}\\n\\nconst odd = new maxCount();\\nconst even = new maxCount();\\n\\nvar i = 0; \\nwhile (array[i]){\\n  odd.addMember(array[i]);\\n  if (array[i+1]) { even.addMember(array[i+1])}\\n  i=i+2;\\n}\\nlet odIdx = odd.getMaxIdx();\\nlet evIdx = even.getMaxIdx();\\nlet tot = odd.getTotal() + even.getTotal();\\n\\nif (!(odIdx == evIdx)) { \\n  return tot - odd.getFMax() - even.getFMax()\\n  }\\nelse { \\n  return Math.min(tot - odd.getFMax() - even.getSMax(), \\n                  tot - odd.getSMax() - even.getFMax()\\n                 )\\n}    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Bucket Sort",
                    "Counting Sort"
                ],
                "code": "# Intuition\\nIn ideal alternating array there two different symbols most frequently appeared and no other symbols. So \"brocken\" array could have other symbols but less appeared then two-most frequently appeared.\\nTotal number of symbols minus number of two most frequently appeared symbols should give a minimum number of corrections.\\n\\n# Approach\\nHowever, odd and even symbols should be parsed separatelly. Since [2,2,2,2,2] is not an alternating. So, making a bucket counting class, and then two instances for odd and even numbers should give us a totals and two-most frequently appeared symbols count.  \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumOperations = function(nums) {\\nvar array = nums;\\n\\nclass maxCount {\\n  constructor() { \\n    this.fMax = 0;\\n    this.sMax = 0;\\n    this.fMaxIdx = \"\";\\n    this.sMaxIdx = \"\";\\n    this.iKey = {}; \\n    this.total = 0;\\n  }\\n  addMember(x) { \\n    let idx = x.toString();\\n    this.total++;\\n    if (this.iKey[idx]) { \\n      this.iKey[idx] = this.iKey[idx] + 1\\n    } else { \\n      this.iKey[idx] = 1 \\n    }\\n    if (this.fMax < this.iKey[idx]) {\\n       this.fMaxIdx = idx;\\n       this.fMax = this.iKey[idx]\\n    } else if (this.sMax < this.iKey[idx]) {\\n      this.sMaxIdx = idx;\\n      this.sMax = this.iKey[idx]\\n    }\\n  }\\n  getTotal() { \\n    return this.total\\n   }\\n  getMaxIdx() { \\n    return this.fMaxIdx\\n  }\\n  getFMax() {\\n    return this.fMax\\n  }\\n  getSMax() {\\n    return this.sMax\\n  }\\n}\\n\\nconst odd = new maxCount();\\nconst even = new maxCount();\\n\\nvar i = 0; \\nwhile (array[i]){\\n  odd.addMember(array[i]);\\n  if (array[i+1]) { even.addMember(array[i+1])}\\n  i=i+2;\\n}\\nlet odIdx = odd.getMaxIdx();\\nlet evIdx = even.getMaxIdx();\\nlet tot = odd.getTotal() + even.getTotal();\\n\\nif (!(odIdx == evIdx)) { \\n  return tot - odd.getFMax() - even.getFMax()\\n  }\\nelse { \\n  return Math.min(tot - odd.getFMax() - even.getSMax(), \\n                  tot - odd.getSMax() - even.getFMax()\\n                 )\\n}    \\n};",
                "codeTag": "Java"
            },
            {
                "id": 3480022,
                "title": "c-clean-code-greedy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n == 1)\\n            return 0;\\n\\n        map<int, int> M1, M2;\\n        for(int i=0; i<n; i++) {\\n            if(i%2 == 0) {\\n                M1[nums[i]]++;\\n            } else {\\n                M2[nums[i]]++;\\n            }\\n        }\\n\\n        vector<pair<int, int>> vp1, vp2;\\n\\n        for(auto &[num, freq]: M1) {\\n            vp1.push_back({freq, num});\\n        }\\n        for(auto &[num, freq]: M2) {\\n            vp2.push_back({freq, num});\\n        }\\n\\n        sort(vp1.begin(), vp1.end());\\n        sort(vp2.begin(), vp2.end());\\n\\n        int i = vp1.size()-1;\\n        int j = vp2.size()-1;\\n\\n        if(vp1[i].second != vp2[j].second) {\\n            return n - vp1[i].first - vp2[j].first;\\n        }\\n        \\n        if(i==0 && j==0) {\\n            return n - max(vp1[i].first, vp2[j].first);\\n        } else if(j == 0) {\\n            return n - max(vp1[i].first, vp1[i-1].first+vp2[j].first);\\n        } else if(i == 0) {\\n            return n - max(vp2[j].first, vp2[j-1].first+vp1[i].first);\\n        }\\n        return n - max(vp1[i].first+vp2[j-1].first, vp1[i-1].first+vp2[j].first);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n == 1)\\n            return 0;\\n\\n        map<int, int> M1, M2;\\n        for(int i=0; i<n; i++) {\\n            if(i%2 == 0) {\\n                M1[nums[i]]++;\\n            } else {\\n                M2[nums[i]]++;\\n            }\\n        }\\n\\n        vector<pair<int, int>> vp1, vp2;\\n\\n        for(auto &[num, freq]: M1) {\\n            vp1.push_back({freq, num});\\n        }\\n        for(auto &[num, freq]: M2) {\\n            vp2.push_back({freq, num});\\n        }\\n\\n        sort(vp1.begin(), vp1.end());\\n        sort(vp2.begin(), vp2.end());\\n\\n        int i = vp1.size()-1;\\n        int j = vp2.size()-1;\\n\\n        if(vp1[i].second != vp2[j].second) {\\n            return n - vp1[i].first - vp2[j].first;\\n        }\\n        \\n        if(i==0 && j==0) {\\n            return n - max(vp1[i].first, vp2[j].first);\\n        } else if(j == 0) {\\n            return n - max(vp1[i].first, vp1[i-1].first+vp2[j].first);\\n        } else if(i == 0) {\\n            return n - max(vp2[j].first, vp2[j-1].first+vp1[i].first);\\n        }\\n        return n - max(vp1[i].first+vp2[j-1].first, vp1[i-1].first+vp2[j].first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467928,
                "title": "python-greedy",
                "content": "The idea is not that hard to come up with:\\n1. Either odd 1st max val and even 1st max values are different -> `N - even_first_max_count - odd_first_max_count`\\n**OR**\\n2. They are the same, thus you need to find which one requires min changes: \\nmin(N - even_first_max_count - odd_second_max_count **OR** N - even_second_max_count - odd_first_max_count)\\n\\nThe real pain in one place is how to quickly NOT TO WRITE something like this (LarryNY, hi! I code similar way :D ):\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even = Counter()\\n        odd = Counter()\\n        \\n        is_odd = False\\n        for num in nums:\\n            if is_odd:\\n                odd[num] += 1\\n            else:\\n                even[num] += 1\\n            is_odd = not is_odd\\n            \\n        even_top_2 = even.most_common(2)\\n        even_total = even.total()\\n        odd_top_2 = odd.most_common(2)\\n        odd_total = odd.total()\\n        \\n        if len(even_top_2) > 0 and len(odd_top_2) > 0:\\n            # top e != top o\\n            if even_top_2[0][0] != odd_top_2[0][0]:\\n                return even_total - even_top_2[0][1] + odd_total - odd_top_2[0][1]\\n            else:\\n                # top e == top o, len(e) > 1, len(o) > 1\\n                if len(even_top_2) > 1 and len(odd_top_2) > 1:\\n                    return min(even_total - even_top_2[0][1] + odd_total - odd_top_2[1][1],\\n                               even_total - even_top_2[1][1] + odd_total - odd_top_2[0][1])\\n                else:\\n                    # top e != top o, len(e) == 1, len(o) > 1\\n                    if len(even_top_2) == 1 and len(odd_top_2) > 1:\\n                        return min(odd_total - odd_top_2[0][1] + even_total,\\n                               odd_total - odd_top_2[1][1])\\n                    # top e != top o, len(e) > 1, len(o) == 1\\n                    elif len(odd_top_2) == 1 and len(even_top_2) > 1:\\n                        return min(even_total - even_top_2[0][1] + odd_total,\\n                               even_total - even_top_2[1][1])\\n                    elif len(odd_top_2) == 1 and len(even_top_2) == 1:\\n                        return min(even_total, odd_total)\\n        return 0\\n```\\nAnd write quickly this short one with the same logic:\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        even = Counter(nums[::2])\\n        odd = Counter(nums[1::2])\\n\\n        even[0], even[-1] = 0, 0 # to avoid fizzle-buzzle with edge cases [1], [2,2] and etc\\n        odd[0], odd[-1] = 0, 0\\n       \\n        (even_top1_val, even_top1_count), (_, even_top2_count) = even.most_common(2)\\n        (odd_top1_val, odd_top1_count), (_, odd_top2_count) = odd.most_common(2)\\n        \\n        if even_top1_val != odd_top1_val:\\n            return N - even_top1_count - odd_top1_count\\n\\n        return min(N - even_top1_count - odd_top2_count, N - even_top2_count - odd_top1_count)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even = Counter()\\n        odd = Counter()\\n        \\n        is_odd = False\\n        for num in nums:\\n            if is_odd:\\n                odd[num] += 1\\n            else:\\n                even[num] += 1\\n            is_odd = not is_odd\\n            \\n        even_top_2 = even.most_common(2)\\n        even_total = even.total()\\n        odd_top_2 = odd.most_common(2)\\n        odd_total = odd.total()\\n        \\n        if len(even_top_2) > 0 and len(odd_top_2) > 0:\\n            # top e != top o\\n            if even_top_2[0][0] != odd_top_2[0][0]:\\n                return even_total - even_top_2[0][1] + odd_total - odd_top_2[0][1]\\n            else:\\n                # top e == top o, len(e) > 1, len(o) > 1\\n                if len(even_top_2) > 1 and len(odd_top_2) > 1:\\n                    return min(even_total - even_top_2[0][1] + odd_total - odd_top_2[1][1],\\n                               even_total - even_top_2[1][1] + odd_total - odd_top_2[0][1])\\n                else:\\n                    # top e != top o, len(e) == 1, len(o) > 1\\n                    if len(even_top_2) == 1 and len(odd_top_2) > 1:\\n                        return min(odd_total - odd_top_2[0][1] + even_total,\\n                               odd_total - odd_top_2[1][1])\\n                    # top e != top o, len(e) > 1, len(o) == 1\\n                    elif len(odd_top_2) == 1 and len(even_top_2) > 1:\\n                        return min(even_total - even_top_2[0][1] + odd_total,\\n                               even_total - even_top_2[1][1])\\n                    elif len(odd_top_2) == 1 and len(even_top_2) == 1:\\n                        return min(even_total, odd_total)\\n        return 0\\n```\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        even = Counter(nums[::2])\\n        odd = Counter(nums[1::2])\\n\\n        even[0], even[-1] = 0, 0 # to avoid fizzle-buzzle with edge cases [1], [2,2] and etc\\n        odd[0], odd[-1] = 0, 0\\n       \\n        (even_top1_val, even_top1_count), (_, even_top2_count) = even.most_common(2)\\n        (odd_top1_val, odd_top1_count), (_, odd_top2_count) = odd.most_common(2)\\n        \\n        if even_top1_val != odd_top1_val:\\n            return N - even_top1_count - odd_top1_count\\n\\n        return min(N - even_top1_count - odd_top2_count, N - even_top2_count - odd_top1_count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362048,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) \\n    {\\n           unordered_map<int,int>m1,m2;\\n           int c=0,m=0,nm=0;\\n           for(int i=0;i<nums.size();i+=2)\\n           {\\n               ++m1[nums[i]];\\n               if(m1[nums[i]]>c)\\n               {\\n                   c=m1[nums[i]];\\n                   nm=1;\\n                   m=nums[i];\\n               }\\n               else if(m1[nums[i]]==c)\\n               {\\n                   nm=2;\\n               }\\n           }\\n         int c1=0,n1=0,mn=0;\\n         for(int i=1;i<nums.size();i+=2)\\n           {\\n               ++m2[nums[i]];\\n               if(m2[nums[i]]>c1)\\n               {\\n                   c1=m2[nums[i]];\\n                   mn=1;\\n                   n1=nums[i];\\n               }\\n               else if(m2[nums[i]]==c1)\\n               {\\n                   mn=2;\\n               }\\n           }   \\n          if(n1!=m)\\n          {\\n              return nums.size()-c1-c;\\n          }\\n        else\\n          {\\n            \\n             if(mn==2||nm==2)  \\n             {\\n                \\n                 return nums.size()-c1-c;\\n             }\\n            else\\n            {\\n                int lc=0;\\n               for(auto j:m1)\\n               {\\n                   if(j.second!=c)\\n                   {\\n                       lc=max(lc,j.second);\\n                   }\\n               }\\n               int lc1=0;\\n             for(auto j:m2)\\n               {\\n                   if(j.second!=c1)\\n                   {\\n                       lc1=max(lc1,j.second);\\n                   }\\n               }\\n                if(c+lc1>=c1+lc)\\n                    return nums.size()-c-lc1;\\n                else\\n                    return nums.size()-c1-lc;\\n            }\\n          }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) \\n    {\\n           unordered_map<int,int>m1,m2;\\n           int c=0,m=0,nm=0;\\n           for(int i=0;i<nums.size();i+=2)\\n           {\\n               ++m1[nums[i]];\\n               if(m1[nums[i]]>c)\\n               {\\n                   c=m1[nums[i]];\\n                   nm=1;\\n                   m=nums[i];\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 3336420,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\nThe Approach is simple basically we will store count of elements at even and odd index in two different unordered map and get max ele 1st time from mp1 and check max from mp2(Not equal to ele we took in mp1) and 2nd time we will firstly take mp2 and get max and check in mp1.\\nOut of these two whichever give max sum we will subtract from size of array which will be equal to our required answer.\\n\\n(Not a very good solution but Intutive one)\\n\\n\\nDRY RUN->\\n3 1 3 2 4 3\\n\\nmp1->\\nEle->count \\n 3->2\\n       4->1\\n\\nmp2->  \\nEle->count\\n1->1\\n       2->1\\n       3->1\\n\\nIn case 1->When we take max element from mp1,In that case max ele will be 3 as it is having frequency equals to 2\\n\\nso in mp2 we can either take 1 or 2 as both are having same frequency 1\\nSo result in this case will be nums.size()-2-1=>6-2-1=3\\n\\nSimilarly we can solve case 2\\n\\nSo max ans will be =3 (Max of both cases)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(3N)\\n\\n- Space complexity:\\nO(2N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>mp1,mp2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                mp1[nums[i]]++;\\n            }\\n            else\\n            {\\n                mp2[nums[i]]++;\\n            }\\n        }\\n        int maxi1=0;\\n        int maxi2=0;\\n        int ele=0;\\n        for(auto it:mp2)\\n        {\\n            if(it.second>maxi1)\\n            {\\n                maxi1=max(maxi1,it.second);\\n                ele=it.first;\\n            }\\n        }\\n        for(auto it:mp1)\\n        {\\n            if(it.first!=ele)\\n            maxi2=max(maxi2,it.second);\\n        }\\n        int maxi3=0;\\n        int maxi4=0;\\n        for(auto it:mp1)\\n        {\\n            if(it.second>maxi3)\\n            {\\n                maxi3=max(maxi3,it.second);\\n                ele=it.first;\\n            }\\n        }\\n        for(auto it:mp2)\\n        {\\n            if(it.first!=ele)\\n            maxi4=max(maxi4,it.second);\\n        }\\n        int z=min(nums.size()-maxi1-maxi2,nums.size()-maxi3-maxi4);\\n        return z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>mp1,mp2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                mp1[nums[i]]++;\\n            }\\n            else\\n            {\\n                mp2[nums[i]]++;\\n            }\\n        }\\n        int maxi1=0;\\n        int maxi2=0;\\n        int ele=0;\\n        for(auto it:mp2)\\n        {\\n            if(it.second>maxi1)\\n            {\\n                maxi1=max(maxi1,it.second);\\n                ele=it.first;\\n            }\\n        }\\n        for(auto it:mp1)\\n        {\\n            if(it.first!=ele)\\n            maxi2=max(maxi2,it.second);\\n        }\\n        int maxi3=0;\\n        int maxi4=0;\\n        for(auto it:mp1)\\n        {\\n            if(it.second>maxi3)\\n            {\\n                maxi3=max(maxi3,it.second);\\n                ele=it.first;\\n            }\\n        }\\n        for(auto it:mp2)\\n        {\\n            if(it.first!=ele)\\n            maxi4=max(maxi4,it.second);\\n        }\\n        int z=min(nums.size()-maxi1-maxi2,nums.size()-maxi3-maxi4);\\n        return z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299711,
                "title": "easy-to-understand-c-map-and-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly we will store alternate values in two vectors of pair sorted by frequency in descending order.\\nThen calculate the minimum values needed to change.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> mapToVector(map<int,int>&mp){\\n        vector<pair<int,int>>vec;\\n        for(auto x:mp){\\n            vec.push_back({x.second,x.first});\\n        }\\n        sort(vec.rbegin(), vec.rend());\\n        return vec;\\n    }\\n\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return 0;\\n        }\\n        map<int,int>first,second;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                first[nums[i]]++;\\n            }else{\\n                second[nums[i]]++;\\n            }\\n        }\\n        // pair.first = frequency , pair.second = value\\n        vector<pair<int,int>>fv = mapToVector(first);\\n        vector<pair<int,int>>sv = mapToVector(second);\\n        int res = n;\\n        if(fv[0].second == sv[0].second){\\n            if(fv.size() == 1 && sv.size() == 1 && fv[0].second == sv[0].second){\\n                // when all elements of the vector are same\\n                res = n - max(fv[0].first,sv[0].first);\\n            }else if(fv.size() == 1){\\n                res = n-fv[0].first-sv[1].first;\\n            }else if(sv.size() == 1){\\n                res = n-fv[1].first-sv[0].first;\\n            }else{\\n                res = min(n-fv[0].first-sv[1].first,n-fv[1].first-sv[0].first);\\n            }\\n        }else{\\n            res = n-fv[0].first-sv[0].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> mapToVector(map<int,int>&mp){\\n        vector<pair<int,int>>vec;\\n        for(auto x:mp){\\n            vec.push_back({x.second,x.first});\\n        }\\n        sort(vec.rbegin(), vec.rend());\\n        return vec;\\n    }\\n\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return 0;\\n        }\\n        map<int,int>first,second;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                first[nums[i]]++;\\n            }else{\\n                second[nums[i]]++;\\n            }\\n        }\\n        // pair.first = frequency , pair.second = value\\n        vector<pair<int,int>>fv = mapToVector(first);\\n        vector<pair<int,int>>sv = mapToVector(second);\\n        int res = n;\\n        if(fv[0].second == sv[0].second){\\n            if(fv.size() == 1 && sv.size() == 1 && fv[0].second == sv[0].second){\\n                // when all elements of the vector are same\\n                res = n - max(fv[0].first,sv[0].first);\\n            }else if(fv.size() == 1){\\n                res = n-fv[0].first-sv[1].first;\\n            }else if(sv.size() == 1){\\n                res = n-fv[1].first-sv[0].first;\\n            }else{\\n                res = min(n-fv[0].first-sv[1].first,n-fv[1].first-sv[0].first);\\n            }\\n        }else{\\n            res = n-fv[0].first-sv[0].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287252,
                "title": "easy-c-just-count-max-and-second-max-at-even-and-odd-positions",
                "content": "# Approach\\nFind max elements at even position and odd positions and replace remaining elements at those positions with this max element. If max elements at even and odd pos comes out to be same then find second max elements at even and odd pos.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& arr) {\\n        \\n        unordered_map<int, int> mpodd, mpeven;\\n        int n = arr.size();\\n        int odds = n/2, evens = n- odds;\\n\\n        for(int i=0; i<n; i++){\\n            if(i%2==0)\\n                mpeven[arr[i]]++;\\n            else\\n                mpodd[arr[i]]++;\\n        }\\n\\n        int maxiodd=0,maxieven=0, maxevenEle, maxoddEle;\\n\\n        for(auto x : mpodd){\\n               if(x.second>maxiodd){\\n                    maxiodd=x.second;\\n                    maxoddEle = x.first;\\n                }\\n        }\\n        \\n        for(auto x : mpeven){\\n            if(x.second>maxieven){\\n               maxieven=x.second;\\n               maxevenEle = x.first;\\n           }\\n        }\\n        \\n        if(maxoddEle == maxevenEle)\\n        {\\n            int secmaxiodd=0, secmaxieven=0;\\n            for(auto x : mpodd){\\n                if(x.second>secmaxiodd && x.first!=maxoddEle)\\n                    secmaxiodd=x.second;\\n            }\\n            for(auto x : mpeven){\\n                if(x.second>secmaxieven && x.first!=maxevenEle)\\n                    secmaxieven=x.second;\\n            }\\n            \\n            return min(odds-maxiodd + evens-secmaxieven, evens-maxieven + odds-secmaxiodd);\\n        }\\n        \\n        else\\n            return odds-maxiodd + evens-maxieven;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& arr) {\\n        \\n        unordered_map<int, int> mpodd, mpeven;\\n        int n = arr.size();\\n        int odds = n/2, evens = n- odds;\\n\\n        for(int i=0; i<n; i++){\\n            if(i%2==0)\\n                mpeven[arr[i]]++;\\n            else\\n                mpodd[arr[i]]++;\\n        }\\n\\n        int maxiodd=0,maxieven=0, maxevenEle, maxoddEle;\\n\\n        for(auto x : mpodd){\\n               if(x.second>maxiodd){\\n                    maxiodd=x.second;\\n                    maxoddEle = x.first;\\n                }\\n        }\\n        \\n        for(auto x : mpeven){\\n            if(x.second>maxieven){\\n               maxieven=x.second;\\n               maxevenEle = x.first;\\n           }\\n        }\\n        \\n        if(maxoddEle == maxevenEle)\\n        {\\n            int secmaxiodd=0, secmaxieven=0;\\n            for(auto x : mpodd){\\n                if(x.second>secmaxiodd && x.first!=maxoddEle)\\n                    secmaxiodd=x.second;\\n            }\\n            for(auto x : mpeven){\\n                if(x.second>secmaxieven && x.first!=maxevenEle)\\n                    secmaxieven=x.second;\\n            }\\n            \\n            return min(odds-maxiodd + evens-secmaxieven, evens-maxieven + odds-secmaxiodd);\\n        }\\n        \\n        else\\n            return odds-maxiodd + evens-maxieven;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207191,
                "title": "frequency-array-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n       int n = nums.length;\\n       if(n<2) return 0;\\n       int[] freqEven = new int[100001];\\n       int[] freqOdd = new int[100001];\\n       for(int i=0;i<n;i++){\\n           if(i%2==0) freqEven[nums[i]]++;\\n           else freqOdd[nums[i]]++;\\n       }\\n       int maxi=Integer.MIN_VALUE;\\n       for(int x:nums){\\n          maxi = Math.max(maxi,x);\\n       }\\n       int firstEven=0,SecondEven=0,freqfirstEven=0,freqSecondEven=0;\\n       int firstOdd=0,SecondOdd=0,freqfirstOdd=0,freqSecondOdd=0;\\n       for(int i=0;i<=maxi;i++){\\n           if(freqEven[i]>=freqfirstEven){\\n               SecondEven = firstEven;\\n               freqSecondEven = freqfirstEven;\\n               firstEven = i;\\n               freqfirstEven = freqEven[i];\\n           }\\n           else if(freqEven[i]>=freqSecondEven){\\n               SecondEven = i;\\n               freqSecondEven = freqEven[i];\\n           }\\n           if(freqOdd[i]>=freqfirstOdd){\\n               SecondOdd = firstOdd;\\n               freqSecondOdd = freqfirstOdd;\\n               firstOdd = i;\\n               freqfirstOdd = freqOdd[i];\\n           }\\n           else if(freqOdd[i]>=freqSecondOdd){\\n               SecondOdd = i;\\n               freqSecondOdd = freqOdd[i];\\n           }\\n       }\\n       if(firstEven!=firstOdd) return n-freqfirstEven-freqfirstOdd;\\n       return Math.min(n-freqfirstEven-freqSecondOdd,\\n       n-freqfirstOdd-freqSecondEven);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n       int n = nums.length;\\n       if(n<2) return 0;\\n       int[] freqEven = new int[100001];\\n       int[] freqOdd = new int[100001];\\n       for(int i=0;i<n;i++){\\n           if(i%2==0) freqEven[nums[i]]++;\\n           else freqOdd[nums[i]]++;\\n       }\\n       int maxi=Integer.MIN_VALUE;\\n       for(int x:nums){\\n          maxi = Math.max(maxi,x);\\n       }\\n       int firstEven=0,SecondEven=0,freqfirstEven=0,freqSecondEven=0;\\n       int firstOdd=0,SecondOdd=0,freqfirstOdd=0,freqSecondOdd=0;\\n       for(int i=0;i<=maxi;i++){\\n           if(freqEven[i]>=freqfirstEven){\\n               SecondEven = firstEven;\\n               freqSecondEven = freqfirstEven;\\n               firstEven = i;\\n               freqfirstEven = freqEven[i];\\n           }\\n           else if(freqEven[i]>=freqSecondEven){\\n               SecondEven = i;\\n               freqSecondEven = freqEven[i];\\n           }\\n           if(freqOdd[i]>=freqfirstOdd){\\n               SecondOdd = firstOdd;\\n               freqSecondOdd = freqfirstOdd;\\n               firstOdd = i;\\n               freqfirstOdd = freqOdd[i];\\n           }\\n           else if(freqOdd[i]>=freqSecondOdd){\\n               SecondOdd = i;\\n               freqSecondOdd = freqOdd[i];\\n           }\\n       }\\n       if(firstEven!=firstOdd) return n-freqfirstEven-freqfirstOdd;\\n       return Math.min(n-freqfirstEven-freqSecondOdd,\\n       n-freqfirstOdd-freqSecondEven);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199118,
                "title": "c-pq-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumOperations(int[] nums) {\\n        if (nums.Length==1) return 0;\\n        Dictionary<int,int> even=new ();\\n        Dictionary<int,int> odd=new ();\\n        for(int i=0;i< nums.Length;i++){\\n            if (i%2==0){\\n                if (!even.ContainsKey(  nums[i])    ) even[ nums[i]]=0;\\n                even[  nums[i] ]++;\\n            }\\n            else{\\n                if (!odd.ContainsKey(  nums[i])    ) odd[ nums[i]]=0;\\n                odd[  nums[i] ]++;\\n            }\\n        }\\n        PriorityQueue<int,int> pqEven=new ();\\n        PriorityQueue<int,int> pqOdd=new ();\\n        foreach(var pair in even){\\n            pqEven.Enqueue(pair.Key,pair.Value *(-1) );\\n        }\\n        foreach(var pair in odd){\\n            pqOdd.Enqueue(pair.Key,pair.Value *(-1) );\\n        }\\n        int evenTop=pqEven.Dequeue();\\n        int oddTop =pqOdd .Dequeue();\\n        int output=nums.Length;\\n        if (evenTop!=oddTop) return nums.Length-even[evenTop]-odd[oddTop];\\n        if (pqEven.Count==0 && pqOdd.Count==0 ) return (nums.Length)/2;\\n        if (pqEven.Count!=0 ){\\n            output=Math.Min(output,  nums.Length-    odd[oddTop]-    even[pqEven.Peek()]   );\\n        }\\n        if (pqOdd.Count!=0 ){\\n            output=Math.Min(output,  nums.Length-     even[evenTop]-   odd[pqOdd.Peek() ]   );\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumOperations(int[] nums) {\\n        if (nums.Length==1) return 0;\\n        Dictionary<int,int> even=new ();\\n        Dictionary<int,int> odd=new ();\\n        for(int i=0;i< nums.Length;i++){\\n            if (i%2==0){\\n                if (!even.ContainsKey(  nums[i])    ) even[ nums[i]]=0;\\n                even[  nums[i] ]++;\\n            }\\n            else{\\n                if (!odd.ContainsKey(  nums[i])    ) odd[ nums[i]]=0;\\n                odd[  nums[i] ]++;\\n            }\\n        }\\n        PriorityQueue<int,int> pqEven=new ();\\n        PriorityQueue<int,int> pqOdd=new ();\\n        foreach(var pair in even){\\n            pqEven.Enqueue(pair.Key,pair.Value *(-1) );\\n        }\\n        foreach(var pair in odd){\\n            pqOdd.Enqueue(pair.Key,pair.Value *(-1) );\\n        }\\n        int evenTop=pqEven.Dequeue();\\n        int oddTop =pqOdd .Dequeue();\\n        int output=nums.Length;\\n        if (evenTop!=oddTop) return nums.Length-even[evenTop]-odd[oddTop];\\n        if (pqEven.Count==0 && pqOdd.Count==0 ) return (nums.Length)/2;\\n        if (pqEven.Count!=0 ){\\n            output=Math.Min(output,  nums.Length-    odd[oddTop]-    even[pqEven.Peek()]   );\\n        }\\n        if (pqOdd.Count!=0 ){\\n            output=Math.Min(output,  nums.Length-     even[evenTop]-   odd[pqOdd.Peek() ]   );\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132872,
                "title": "c-find-2-max-frequent-numbers-easy-to-understand",
                "content": "```\\n int minimumOperations(vector<int>& nums) {\\n        int freqEven[100001] = {0};\\n        int freqOdd[100001] = {0};\\n        \\n        int n = nums.size();\\n        int maxi = nums[0];\\n        for(int i = 0; i < n ; i++){\\n            if(i%2 == 0){\\n                freqEven[nums[i]]++;\\n            } else{\\n                freqOdd[nums[i]]++;\\n            }\\n            maxi = max(nums[i], maxi);\\n        }\\n        \\n        int firstMaxEven = 0, freqFirstMaxEven = 0;\\n        int secondMaxEven = 0, freqSecondMaxEven = 0;\\n        \\n        int firstMaxOdd = 0, freqFirstMaxOdd = 0;\\n        int secondMaxOdd = 0, freqSecondMaxOdd = 0;\\n        \\n        for(int i = 1; i <= maxi; i++){\\n            if(freqEven[i] >= freqFirstMaxEven){\\n                secondMaxEven = firstMaxEven;\\n                freqSecondMaxEven = freqFirstMaxEven;\\n                \\n                freqFirstMaxEven = freqEven[i];\\n                firstMaxEven = i;\\n            }else if(freqEven[i] > freqSecondMaxEven){\\n                freqSecondMaxEven = freqEven[i];\\n                secondMaxEven = i;\\n            }\\n            \\n             if(freqOdd[i] >= freqFirstMaxOdd){\\n                secondMaxOdd = firstMaxOdd;\\n                freqSecondMaxOdd = freqFirstMaxOdd;\\n                 \\n                freqFirstMaxOdd = freqOdd[i];\\n                firstMaxOdd = i;\\n            }else if(freqOdd[i] > freqSecondMaxOdd){\\n                freqSecondMaxOdd = freqOdd[i];\\n                secondMaxOdd = i;\\n            }\\n        }\\n        cout<<firstMaxEven<< \" \"<< firstMaxOdd;\\n        if(firstMaxEven != firstMaxOdd){\\n            return n - freqFirstMaxEven - freqFirstMaxOdd;\\n        }\\n        return min(n - freqFirstMaxEven - freqSecondMaxOdd, n - freqFirstMaxOdd - freqSecondMaxEven);\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int minimumOperations(vector<int>& nums) {\\n        int freqEven[100001] = {0};\\n        int freqOdd[100001] = {0};\\n        \\n        int n = nums.size();\\n        int maxi = nums[0];\\n        for(int i = 0; i < n ; i++){\\n            if(i%2 == 0){\\n                freqEven[nums[i]]++;\\n            } else{\\n                freqOdd[nums[i]]++;\\n            }\\n            maxi = max(nums[i], maxi);\\n        }\\n        \\n        int firstMaxEven = 0, freqFirstMaxEven = 0;\\n        int secondMaxEven = 0, freqSecondMaxEven = 0;\\n        \\n        int firstMaxOdd = 0, freqFirstMaxOdd = 0;\\n        int secondMaxOdd = 0, freqSecondMaxOdd = 0;\\n        \\n        for(int i = 1; i <= maxi; i++){\\n            if(freqEven[i] >= freqFirstMaxEven){\\n                secondMaxEven = firstMaxEven;\\n                freqSecondMaxEven = freqFirstMaxEven;\\n                \\n                freqFirstMaxEven = freqEven[i];\\n                firstMaxEven = i;\\n            }else if(freqEven[i] > freqSecondMaxEven){\\n                freqSecondMaxEven = freqEven[i];\\n                secondMaxEven = i;\\n            }\\n            \\n             if(freqOdd[i] >= freqFirstMaxOdd){\\n                secondMaxOdd = firstMaxOdd;\\n                freqSecondMaxOdd = freqFirstMaxOdd;\\n                 \\n                freqFirstMaxOdd = freqOdd[i];\\n                firstMaxOdd = i;\\n            }else if(freqOdd[i] > freqSecondMaxOdd){\\n                freqSecondMaxOdd = freqOdd[i];\\n                secondMaxOdd = i;\\n            }\\n        }\\n        cout<<firstMaxEven<< \" \"<< firstMaxOdd;\\n        if(firstMaxEven != firstMaxOdd){\\n            return n - freqFirstMaxEven - freqFirstMaxOdd;\\n        }\\n        return min(n - freqFirstMaxEven - freqSecondMaxOdd, n - freqFirstMaxOdd - freqSecondMaxEven);\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 3122137,
                "title": "python-sorting-solution",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n\\n        even = []\\n        odd = []\\n        even_count = dict()\\n        odd_count = dict()\\n        even_double = []\\n        odd_double = []\\n        size_even = 0\\n        size_odd = 0\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i] in even_count:\\n                even_count[nums[i]] += 1\\n            else:\\n                even_count[nums[i]] = 1\\n                even.append(nums[i])\\n            \\n            size_even += 1\\n\\n        for i in range(1,len(nums),2):\\n            if nums[i] in odd_count:\\n                odd_count[nums[i]] += 1\\n            else:\\n                odd_count[nums[i]] = 1\\n                odd.append(nums[i])\\n            \\n            size_odd += 1\\n\\n        for num in even:even_double.append([even_count[num],num])\\n        even_double.append([0,float(\"inf\")])\\n        for num in odd:odd_double.append([odd_count[num],num])\\n        odd_double.append([0,float(\"inf\")])\\n\\n        even_double = sorted(even_double,reverse = True)\\n        odd_double = sorted(odd_double,reverse = True)\\n\\n        if even_double[0][1] == odd_double[0][1]:\\n            return min((size_even - even_double[1][0]) + (size_odd - odd_double[0][0]),(size_even - even_double[0][0]) + (size_odd - odd_double[1][0]))\\n        \\n        return (size_even - even_double[0][0]) + (size_odd - odd_double[0][0])\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n\\n        even = []\\n        odd = []\\n        even_count = dict()\\n        odd_count = dict()\\n        even_double = []\\n        odd_double = []\\n        size_even = 0\\n        size_odd = 0\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i] in even_count:\\n                even_count[nums[i]] += 1\\n            else:\\n                even_count[nums[i]] = 1\\n                even.append(nums[i])\\n            \\n            size_even += 1\\n\\n        for i in range(1,len(nums),2):\\n            if nums[i] in odd_count:\\n                odd_count[nums[i]] += 1\\n            else:\\n                odd_count[nums[i]] = 1\\n                odd.append(nums[i])\\n            \\n            size_odd += 1\\n\\n        for num in even:even_double.append([even_count[num],num])\\n        even_double.append([0,float(\"inf\")])\\n        for num in odd:odd_double.append([odd_count[num],num])\\n        odd_double.append([0,float(\"inf\")])\\n\\n        even_double = sorted(even_double,reverse = True)\\n        odd_double = sorted(odd_double,reverse = True)\\n\\n        if even_double[0][1] == odd_double[0][1]:\\n            return min((size_even - even_double[1][0]) + (size_odd - odd_double[0][0]),(size_even - even_double[0][0]) + (size_odd - odd_double[1][0]))\\n        \\n        return (size_even - even_double[0][0]) + (size_odd - odd_double[0][0])\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110468,
                "title": "c-solution-using-highest-and-second-highest-frequency-for-even-and-odd-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfinding numbers with highest and  second highest frequencies in the list\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\npublic class Solution {\\npublic  int MinimumOperations(int[] nums)\\n        {\\n\\n            int steps = 0;\\n            if (nums.Length == 2)\\n            {\\n                if (nums[0] != nums[1])\\n                {\\n                    return 0;\\n                }\\n                else\\n                {\\n                    return 1;\\n                }\\n            }\\n            else if (nums.Length == 1)\\n            {\\n                return 0;\\n            }\\n            int a = nums[0], b = nums[1];\\n            int prevA = a, prevB = b;\\n            Dictionary<int, long> evenDict = new Dictionary<int, long>();\\n            Dictionary<int, long> oddDict = new Dictionary<int, long>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                {\\n                    if (evenDict.ContainsKey(nums[i]))\\n                        evenDict[nums[i]]++;\\n                    else\\n                    {\\n                        evenDict.Add(nums[i], 1);\\n                    }\\n                }\\n                else\\n                {\\n                    if (oddDict.ContainsKey(nums[i]))\\n                        oddDict[nums[i]]++;\\n                    else\\n                    {\\n                        oddDict.Add(nums[i], 1);\\n                    }\\n                }\\n            }\\n            foreach (KeyValuePair<int, long> kvp in evenDict)\\n            {\\n\\n                if (kvp.Value > evenDict[a])\\n                {\\n                    a = kvp.Key;\\n                }\\n                else if (kvp.Value > evenDict[prevA] || prevA == a)\\n                {\\n                    prevA = kvp.Key;\\n                }\\n\\n            }\\n            foreach (KeyValuePair<int, long> kvp in oddDict)\\n            {\\n                if (kvp.Value > oddDict[b])\\n                {\\n                    b = kvp.Key;\\n                }\\n                else if (kvp.Value > oddDict[prevB] || prevB == b)\\n                {\\n                    prevB = kvp.Key;\\n                }\\n            }\\n\\n             if (a == b)\\n            {\\n                //checking diffrence b/w second highest and highest frequency number\\n                if (evenDict[a] - evenDict[prevA] > oddDict[b] - oddDict[prevB] && a!=prevA)\\n                {\\n                    if(b!=prevB)\\n                        b = prevB;\\n                    else\\n                        a = prevA;\\n                }\\n                else if (evenDict[a] - evenDict[prevA] < oddDict[b] - oddDict[prevB] && b!=prevB)\\n                {\\n                    if(a!=prevA)\\n                        a = prevA;\\n                    else\\n                        b = prevB;\\n                }\\n                else if(evenDict[a] >oddDict[b])\\n                {\\n                    if (b != prevB)\\n                        b = prevB;\\n                    else\\n                        b = a + 1;\\n                }\\n                else\\n                {\\n                    if (a != prevA)\\n                        a = prevA;\\n                    else\\n                        a = b + 1;\\n                }\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n\\n                switch (i % 2)\\n                {\\n                    case 0:\\n                        {\\n                            if (nums[i] != a)\\n                            {\\n\\n                                steps++;\\n                            }\\n                            break;\\n                        }\\n                    case 1:\\n                        {\\n                            if (nums[i] != b)\\n                            {\\n                                steps++;\\n                            }\\n                            break;\\n                        }\\n                }\\n\\n            }\\n\\n            return steps;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\npublic  int MinimumOperations(int[] nums)\\n        {\\n\\n            int steps = 0;\\n            if (nums.Length == 2)\\n            {\\n                if (nums[0] != nums[1])\\n                {\\n                    return 0;\\n                }\\n                else\\n                {\\n                    return 1;\\n                }\\n            }\\n            else if (nums.Length == 1)\\n            {\\n                return 0;\\n            }\\n            int a = nums[0], b = nums[1];\\n            int prevA = a, prevB = b;\\n            Dictionary<int, long> evenDict = new Dictionary<int, long>();\\n            Dictionary<int, long> oddDict = new Dictionary<int, long>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                {\\n                    if (evenDict.ContainsKey(nums[i]))\\n                        evenDict[nums[i]]++;\\n                    else\\n                    {\\n                        evenDict.Add(nums[i], 1);\\n                    }\\n                }\\n                else\\n                {\\n                    if (oddDict.ContainsKey(nums[i]))\\n                        oddDict[nums[i]]++;\\n                    else\\n                    {\\n                        oddDict.Add(nums[i], 1);\\n                    }\\n                }\\n            }\\n            foreach (KeyValuePair<int, long> kvp in evenDict)\\n            {\\n\\n                if (kvp.Value > evenDict[a])\\n                {\\n                    a = kvp.Key;\\n                }\\n                else if (kvp.Value > evenDict[prevA] || prevA == a)\\n                {\\n                    prevA = kvp.Key;\\n                }\\n\\n            }\\n            foreach (KeyValuePair<int, long> kvp in oddDict)\\n            {\\n                if (kvp.Value > oddDict[b])\\n                {\\n                    b = kvp.Key;\\n                }\\n                else if (kvp.Value > oddDict[prevB] || prevB == b)\\n                {\\n                    prevB = kvp.Key;\\n                }\\n            }\\n\\n             if (a == b)\\n            {\\n                //checking diffrence b/w second highest and highest frequency number\\n                if (evenDict[a] - evenDict[prevA] > oddDict[b] - oddDict[prevB] && a!=prevA)\\n                {\\n                    if(b!=prevB)\\n                        b = prevB;\\n                    else\\n                        a = prevA;\\n                }\\n                else if (evenDict[a] - evenDict[prevA] < oddDict[b] - oddDict[prevB] && b!=prevB)\\n                {\\n                    if(a!=prevA)\\n                        a = prevA;\\n                    else\\n                        b = prevB;\\n                }\\n                else if(evenDict[a] >oddDict[b])\\n                {\\n                    if (b != prevB)\\n                        b = prevB;\\n                    else\\n                        b = a + 1;\\n                }\\n                else\\n                {\\n                    if (a != prevA)\\n                        a = prevA;\\n                    else\\n                        a = b + 1;\\n                }\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n\\n                switch (i % 2)\\n                {\\n                    case 0:\\n                        {\\n                            if (nums[i] != a)\\n                            {\\n\\n                                steps++;\\n                            }\\n                            break;\\n                        }\\n                    case 1:\\n                        {\\n                            if (nums[i] != b)\\n                            {\\n                                steps++;\\n                            }\\n                            break;\\n                        }\\n                }\\n\\n            }\\n\\n            return steps;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103380,
                "title": "python-greedy",
                "content": "# Intuition\\nWe could calculate each values counts, separately for odd and even indices, remain the most frequent values, and change the rest to satisfy teh conditions.\\n\\n# Approach\\n1. Check special cases separately:\\n- For array of length ``1`` we don\\'t need to change anything => return ``0``\\n- For array of length ``2`` we only need to change one of the value if they are equal\\n2. Count values for odd and even indices separately and sort descending\\n3. Pick the most frequent values for odd and for event indices ``Vodd`` and ``Veven`` and their counts ``Codd`` and ``Ceven``.\\n- If ``Vodd != Veven``, then we only need to change the rest - ``n - Codd - Ceven``\\n- Otherwise we should try second-frequent values for either odd or even and return teh minimum value\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        if n == 2:\\n            return 0 if nums[0] != nums[1] else 1\\n        cnt_even, cnt_odd = defaultdict(int), defaultdict(int)\\n        for i, v in enumerate(nums):\\n            if i % 2:\\n                cnt_odd[v] += 1\\n            else:\\n                cnt_even[v] += 1\\n        even = [(cnt_even[v], v) for v in cnt_even]\\n        odd = [(cnt_odd[v], v) for v in cnt_odd]\\n        even.sort(reverse=True)\\n        odd.sort(reverse=True)\\n        if even[0][1] == odd[0][1]:\\n            # Here we use n // 2 because if all odd values are equal and we have len(odd) == 1, then we only need to change all even; and vice versa\\n            v1 = n - even[0][0] - odd[1][0] if len(odd) > 1 else n // 2\\n            v2 = n - even[1][0] - odd[0][0] if len(even) > 1 else n // 2\\n            return min(v1, v2)\\n\\n        return n - even[0][0] - odd[0][0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n < 2:\\n            return 0\\n        if n == 2:\\n            return 0 if nums[0] != nums[1] else 1\\n        cnt_even, cnt_odd = defaultdict(int), defaultdict(int)\\n        for i, v in enumerate(nums):\\n            if i % 2:\\n                cnt_odd[v] += 1\\n            else:\\n                cnt_even[v] += 1\\n        even = [(cnt_even[v], v) for v in cnt_even]\\n        odd = [(cnt_odd[v], v) for v in cnt_odd]\\n        even.sort(reverse=True)\\n        odd.sort(reverse=True)\\n        if even[0][1] == odd[0][1]:\\n            # Here we use n // 2 because if all odd values are equal and we have len(odd) == 1, then we only need to change all even; and vice versa\\n            v1 = n - even[0][0] - odd[1][0] if len(odd) > 1 else n // 2\\n            v2 = n - even[1][0] - odd[0][0] if len(even) > 1 else n // 2\\n            return min(v1, v2)\\n\\n        return n - even[0][0] - odd[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882699,
                "title": "c-brute-force-solution-using-unordered-map-first-max-and-second-max",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int> mp1,mp2;\\n        int maxi1=0,maxi2=0;\\n        int res1=0,res2=0;\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                mp1[nums[i]]++;\\n                res1++;\\n                maxi1=max(maxi1,mp1[nums[i]]);\\n            }\\n            else{\\n                mp2[nums[i]]++;\\n                res2++;\\n                maxi2=max(maxi2,mp2[nums[i]]);\\n            }\\n        }\\n        int mxi=*max_element(nums.begin(),nums.end());\\n        int mni=*min_element(nums.begin(),nums.end());\\n        if(mxi==mni){\\n            return nums.size()/2;\\n        }\\n        vector<pair<int,int>> vp1,vp2;\\n        for(auto &x:mp1){\\n            vp1.push_back({x.second,x.first});\\n        }\\n        for(auto &x:mp2){\\n            vp2.push_back({x.second,x.first});\\n        }\\n        sort(vp1.begin(),vp1.end(),greater<pair<int,int>> ());\\n        sort(vp2.begin(),vp2.end(),greater<pair<int,int>> ());\\n        if(vp1[0].second!=vp2[0].second){\\n            return abs(res1-vp1[0].first)+abs(res2-vp2[0].first);\\n        }\\n        int r1,r2;\\n        if(vp2.size()>1){\\n            r1=abs(res1-vp1[0].first)+abs(res2-vp2[1].first);\\n        }\\n        if(vp1.size()>1){\\n            r2=abs(res1-vp1[1].first)+abs(res2-vp2[0].first);\\n        }\\n        return min(r1,r2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int> mp1,mp2;\\n        int maxi1=0,maxi2=0;\\n        int res1=0,res2=0;\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                mp1[nums[i]]++;\\n                res1++;\\n                maxi1=max(maxi1,mp1[nums[i]]);\\n            }\\n            else{\\n                mp2[nums[i]]++;\\n                res2++;\\n                maxi2=max(maxi2,mp2[nums[i]]);\\n            }\\n        }\\n        int mxi=*max_element(nums.begin(),nums.end());\\n        int mni=*min_element(nums.begin(),nums.end());\\n        if(mxi==mni){\\n            return nums.size()/2;\\n        }\\n        vector<pair<int,int>> vp1,vp2;\\n        for(auto &x:mp1){\\n            vp1.push_back({x.second,x.first});\\n        }\\n        for(auto &x:mp2){\\n            vp2.push_back({x.second,x.first});\\n        }\\n        sort(vp1.begin(),vp1.end(),greater<pair<int,int>> ());\\n        sort(vp2.begin(),vp2.end(),greater<pair<int,int>> ());\\n        if(vp1[0].second!=vp2[0].second){\\n            return abs(res1-vp1[0].first)+abs(res2-vp2[0].first);\\n        }\\n        int r1,r2;\\n        if(vp2.size()>1){\\n            r1=abs(res1-vp1[0].first)+abs(res2-vp2[1].first);\\n        }\\n        if(vp1.size()>1){\\n            r2=abs(res1-vp1[1].first)+abs(res2-vp2[0].first);\\n        }\\n        return min(r1,r2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870899,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have no Idea what I have done , it just worked after 5-6 attemps :D\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        // nums[i - 2] == nums[i]== nums[i+2]\\n        // nums[i - 1] != nums[i] ! = nums[i+1]\\n\\n        // 0 2 4 6 .. idx element must be equal\\n        // 1 3 5 7 must be equal as well \\n        int n = nums.size();\\n        unordered_map<int,int>even;\\n        unordered_map<int,int>odd;\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[nums[i]]++;\\n            }\\n            else\\n            {\\n                odd[nums[i]]++;\\n            }\\n        }\\n\\n        map<int,vector<int>,greater<int>>even_f;\\n        map<int,vector<int>,greater<int>>odd_f;\\n\\n        for(auto &i:even)\\n            even_f[i.second].push_back(i.first);\\n\\n        for(auto &i:odd)\\n            odd_f[i.second].push_back(i.first);\\n\\n        \\n        pair<int,vector<int>>x,y,a,b;\\n\\n        int cnt = 0;\\n        for(auto &i:even_f)\\n            {\\n                if(cnt==0)\\n                    {\\n                        x={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else if(cnt==1)\\n                    {\\n                        y={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else\\n                    {\\n                        ;\\n                    }\\n            }\\n        cnt=0;\\n\\n        for(auto &i:odd_f)\\n            {\\n                if(cnt==0)\\n                    {\\n                        a={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else if(cnt==1)\\n                    {\\n                        b={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else\\n                    {\\n                        ;\\n                    }\\n            }\\n            \\n        int c = x.first+a.first;\\n\\n        if(x.second==a.second)\\n        {\\n            int i = x.first;\\n            int j = a.first;\\n\\n            if(i==j)\\n            {\\n                if(y.first<b.first)\\n                    c = i + b.first;\\n                else\\n                    c = j + a.first;\\n            }\\n            if(i-y.first<j-b.first)\\n                c=y.first + j;\\n            else\\n                c=i + b.first;\\n            \\n        }\\n\\n\\n        return n-c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        // nums[i - 2] == nums[i]== nums[i+2]\\n        // nums[i - 1] != nums[i] ! = nums[i+1]\\n\\n        // 0 2 4 6 .. idx element must be equal\\n        // 1 3 5 7 must be equal as well \\n        int n = nums.size();\\n        unordered_map<int,int>even;\\n        unordered_map<int,int>odd;\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[nums[i]]++;\\n            }\\n            else\\n            {\\n                odd[nums[i]]++;\\n            }\\n        }\\n\\n        map<int,vector<int>,greater<int>>even_f;\\n        map<int,vector<int>,greater<int>>odd_f;\\n\\n        for(auto &i:even)\\n            even_f[i.second].push_back(i.first);\\n\\n        for(auto &i:odd)\\n            odd_f[i.second].push_back(i.first);\\n\\n        \\n        pair<int,vector<int>>x,y,a,b;\\n\\n        int cnt = 0;\\n        for(auto &i:even_f)\\n            {\\n                if(cnt==0)\\n                    {\\n                        x={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else if(cnt==1)\\n                    {\\n                        y={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else\\n                    {\\n                        ;\\n                    }\\n            }\\n        cnt=0;\\n\\n        for(auto &i:odd_f)\\n            {\\n                if(cnt==0)\\n                    {\\n                        a={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else if(cnt==1)\\n                    {\\n                        b={i.first,i.second};\\n                        cnt++;\\n                    }\\n                else\\n                    {\\n                        ;\\n                    }\\n            }\\n            \\n        int c = x.first+a.first;\\n\\n        if(x.second==a.second)\\n        {\\n            int i = x.first;\\n            int j = a.first;\\n\\n            if(i==j)\\n            {\\n                if(y.first<b.first)\\n                    c = i + b.first;\\n                else\\n                    c = j + a.first;\\n            }\\n            if(i-y.first<j-b.first)\\n                c=y.first + j;\\n            else\\n                c=i + b.first;\\n            \\n        }\\n\\n\\n        return n-c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851797,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn minimum_operations(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n    let mut odds = HashMap::new();\\n    let mut odd_num = 0;\\n    let mut evens = HashMap::new();\\n    let mut even_num = 0;\\n    for i in 0..n {\\n      let v = nums[i];\\n      if i % 2 == 0 {\\n        odd_num += 1;\\n        *odds.entry(v).or_insert(0) += 1;\\n      } else {\\n        even_num += 1;\\n        *evens.entry(v).or_insert(0) += 1;\\n      }\\n    }\\n    odds.insert(10i32.pow(6), 0);\\n    evens.insert(10i32.pow(7), 0);\\n    evens.insert(10i32.pow(7)+1, 0);\\n\\n    let mut a = evens.into_iter().map(|v| (v.1,v.0)).collect::<Vec<(i32,i32)>>();\\n    a.sort();\\n    let top = a.pop().unwrap();\\n    let second = a.pop().unwrap();\\n  \\n    let mut result = n as i32;\\n    for (v1, num1) in odds {\\n      let mut temp = odd_num - num1;\\n      if top.1 != v1 {\\n        temp += even_num - top.0;\\n      } else {\\n        temp += even_num - second.0;\\n      }\\n      result = result.min(temp);\\n    }\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn minimum_operations(nums: Vec<i32>) -> i32 {\\n    let n = nums.len();\\n    let mut odds = HashMap::new();\\n    let mut odd_num = 0;\\n    let mut evens = HashMap::new();\\n    let mut even_num = 0;\\n    for i in 0..n {\\n      let v = nums[i];\\n      if i % 2 == 0 {\\n        odd_num += 1;\\n        *odds.entry(v).or_insert(0) += 1;\\n      } else {\\n        even_num += 1;\\n        *evens.entry(v).or_insert(0) += 1;\\n      }\\n    }\\n    odds.insert(10i32.pow(6), 0);\\n    evens.insert(10i32.pow(7), 0);\\n    evens.insert(10i32.pow(7)+1, 0);\\n\\n    let mut a = evens.into_iter().map(|v| (v.1,v.0)).collect::<Vec<(i32,i32)>>();\\n    a.sort();\\n    let top = a.pop().unwrap();\\n    let second = a.pop().unwrap();\\n  \\n    let mut result = n as i32;\\n    for (v1, num1) in odds {\\n      let mut temp = odd_num - num1;\\n      if top.1 != v1 {\\n        temp += even_num - top.0;\\n      } else {\\n        temp += even_num - second.0;\\n      }\\n      result = result.min(temp);\\n    }\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793348,
                "title": "c-priority-queue-with-custom-compare-function",
                "content": "```\\n\\nstruct CustomCompare\\n{\\n    bool operator()(const pair<int,int>& p1, const pair<int,int>& p2)\\n    {\\n        if(p1.second==p2.second) {\\n            return p1.first>p2.first;\\n        }\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMinOp(vector<int>& nums, int evenV, int oddV) {\\n        int ans=0;\\n        // cout<<\"E:\"<<evenV<<endl;\\n        // cout<<\"O:\"<<oddV<<endl;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0) {\\n                if(nums[i]!=evenV){\\n                    ans++;\\n                }\\n            } else {\\n                if(nums[i]!=oddV){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        unordered_map<int,int> om,em;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2){\\n                om[nums[i]]++;\\n            } else {\\n                em[nums[i]]++;\\n            }\\n        }\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, CustomCompare> oPq, ePq;\\n        for(auto it:om){\\n            oPq.push({it.first,it.second});\\n        }\\n        for(auto it:em){\\n            ePq.push({it.first,it.second});\\n        }\\n        \\n        pair<int,int> init = {0,0};\\n        auto evenM = ePq.top();\\n        ePq.pop();\\n        auto evenSM = ePq.empty() ? init : ePq.top();\\n        \\n        auto oddM = oPq.top();\\n        oPq.pop();\\n        auto oddSM = oPq.empty() ? init : oPq.top();\\n        \\n        // cout<<evenM.first<<\" \"<<oddM.first<<endl;\\n        \\n        if(evenM.first == oddM.first) {\\n            return min(findMinOp(nums, evenSM.first, oddM.first), findMinOp(nums, evenM.first, oddSM.first));\\n        } else {\\n            return findMinOp(nums, evenM.first, oddM.first);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct CustomCompare\\n{\\n    bool operator()(const pair<int,int>& p1, const pair<int,int>& p2)\\n    {\\n        if(p1.second==p2.second) {\\n            return p1.first>p2.first;\\n        }\\n        return p1.second < p2.second;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findMinOp(vector<int>& nums, int evenV, int oddV) {\\n        int ans=0;\\n        // cout<<\"E:\"<<evenV<<endl;\\n        // cout<<\"O:\"<<oddV<<endl;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0) {\\n                if(nums[i]!=evenV){\\n                    ans++;\\n                }\\n            } else {\\n                if(nums[i]!=oddV){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n        unordered_map<int,int> om,em;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2){\\n                om[nums[i]]++;\\n            } else {\\n                em[nums[i]]++;\\n            }\\n        }\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, CustomCompare> oPq, ePq;\\n        for(auto it:om){\\n            oPq.push({it.first,it.second});\\n        }\\n        for(auto it:em){\\n            ePq.push({it.first,it.second});\\n        }\\n        \\n        pair<int,int> init = {0,0};\\n        auto evenM = ePq.top();\\n        ePq.pop();\\n        auto evenSM = ePq.empty() ? init : ePq.top();\\n        \\n        auto oddM = oPq.top();\\n        oPq.pop();\\n        auto oddSM = oPq.empty() ? init : oPq.top();\\n        \\n        // cout<<evenM.first<<\" \"<<oddM.first<<endl;\\n        \\n        if(evenM.first == oddM.first) {\\n            return min(findMinOp(nums, evenSM.first, oddM.first), findMinOp(nums, evenM.first, oddSM.first));\\n        } else {\\n            return findMinOp(nums, evenM.first, oddM.first);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2780671,
                "title": "kotlin-straightforward-solution",
                "content": "A Kotlin solution which is referred from [guptayash3\\n](https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/solutions/1767679/java-38-ms-100-fast-100-mem/?page=2&languageTags=java)\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimumOperations(nums: IntArray): Int {\\n        var max: Int = 0\\n        var n: Int = nums.size\\n        for(i in 0 until nums.size) {\\n            if(nums[i] > max) {\\n                max = nums[i]\\n            }\\n        }\\n\\n        val freq = Array(max+1) {IntArray(2) {0}}\\n        for(i in 0 until nums.size) {\\n            freq[nums[i]][i and 1]++\\n        }\\n\\n        var acc: Int = 0\\n        var oddNum: Int = 0\\n        var evenNum: Int = 0\\n        for(i in 1 until max+1) {\\n            acc = Math.max(acc, Math.max(freq[i][0] + oddNum, freq[i][1] + evenNum))\\n            evenNum = Math.max(evenNum, freq[i][0])\\n            oddNum = Math.max(oddNum, freq[i][1])\\n        }\\n\\n        return n-acc\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumOperations(nums: IntArray): Int {\\n        var max: Int = 0\\n        var n: Int = nums.size\\n        for(i in 0 until nums.size) {\\n            if(nums[i] > max) {\\n                max = nums[i]\\n            }\\n        }\\n\\n        val freq = Array(max+1) {IntArray(2) {0}}\\n        for(i in 0 until nums.size) {\\n            freq[nums[i]][i and 1]++\\n        }\\n\\n        var acc: Int = 0\\n        var oddNum: Int = 0\\n        var evenNum: Int = 0\\n        for(i in 1 until max+1) {\\n            acc = Math.max(acc, Math.max(freq[i][0] + oddNum, freq[i][1] + evenNum))\\n            evenNum = Math.max(evenNum, freq[i][0])\\n            oddNum = Math.max(oddNum, freq[i][1])\\n        }\\n\\n        return n-acc\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778316,
                "title": "python3-commented-and-easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first one should recognize that we need to use the most frequent number for both odd and even indexed numbers. So we make a frequency counter for each of those.\\n\\nThen we use the frequency counters to get us the two most common elements (internally this uses a heap -> O(N + 2logN))\\n\\nThen we need to consider several cases:\\n1) Both most frequent numbers are different: We keep those and only change the rest\\n2) Most frequent numbers are the same\\n    a) Even/odd indexed has only one unqiue number but the other more than one\\n    b) Even and odd indexed numbers both have more than one unique numbers\\n    c) both of them have only one unique number -> change all odd index numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe rely on a frequency counter and max heap to find the two most common numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n\\n        # trivial case\\n        if len(nums) < 2:\\n            return 0\\n        \\n        # count the even and odd indexed numbers\\n        cn_even = collections.Counter(nums[::2])\\n        cn_odd = collections.Counter(nums[1::2])\\n\\n        # use the most common even and odd index numbers if they are not equal\\n        most_even = cn_even.most_common(2)\\n        most_odd = cn_odd.most_common(2)\\n\\n        # check whether most common elements are equal and if so\\n        # check out which combination is better\\n        if most_even[0][0] == most_odd[0][0]:\\n\\n            # if both have two most common elements\\n            if len(most_even) == 2 and len(most_odd) == 2:\\n\\n                # get the subtractor for the case where both have multiple different\\n                # elements and find the combination that has the most characters\\n                # that need no changing\\n                subtractor = max(most_even[0][1] + most_odd[1][1], most_even[1][1] + most_odd[0][1])\\n            elif len(most_even) == 2:\\n\\n                # we need to take \\n                subtractor = most_odd[0][1] + most_even[1][1]\\n            elif len(most_odd) == 2:\\n                subtractor = most_odd[1][1] + most_even[0][1]\\n            else:\\n                subtractor = len(nums) - len(nums)//2\\n        else:\\n            subtractor = most_even[0][1] + most_odd[0][1]\\n\\n        return len(nums) - subtractor\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n\\n        # trivial case\\n        if len(nums) < 2:\\n            return 0\\n        \\n        # count the even and odd indexed numbers\\n        cn_even = collections.Counter(nums[::2])\\n        cn_odd = collections.Counter(nums[1::2])\\n\\n        # use the most common even and odd index numbers if they are not equal\\n        most_even = cn_even.most_common(2)\\n        most_odd = cn_odd.most_common(2)\\n\\n        # check whether most common elements are equal and if so\\n        # check out which combination is better\\n        if most_even[0][0] == most_odd[0][0]:\\n\\n            # if both have two most common elements\\n            if len(most_even) == 2 and len(most_odd) == 2:\\n\\n                # get the subtractor for the case where both have multiple different\\n                # elements and find the combination that has the most characters\\n                # that need no changing\\n                subtractor = max(most_even[0][1] + most_odd[1][1], most_even[1][1] + most_odd[0][1])\\n            elif len(most_even) == 2:\\n\\n                # we need to take \\n                subtractor = most_odd[0][1] + most_even[1][1]\\n            elif len(most_odd) == 2:\\n                subtractor = most_odd[1][1] + most_even[0][1]\\n            else:\\n                subtractor = len(nums) - len(nums)//2\\n        else:\\n            subtractor = most_even[0][1] + most_odd[0][1]\\n\\n        return len(nums) - subtractor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749947,
                "title": "c-using-hashmaps-for-odd-and-even-places",
                "content": "```\\nint minimumOperations(vector<int>& nums) {\\n        if(nums.size() <2) return 0;\\n        \\n        unordered_map<int, int>even_hash_map;\\n        unordered_map<int, int>odd_hash_map;\\n        int total_even = 0, total_odd = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(i&1){\\n                odd_hash_map[nums[i]]++;\\n                total_odd++;\\n            }else{\\n                even_hash_map[nums[i]]++;\\n                total_even++;\\n            }\\n        }\\n        \\n        int first_even_count = 0, first_even_num = 0;\\n        int second_even_count = 0, second_even_num = 0;\\n        for(auto item: even_hash_map){\\n            int num = item.first;\\n            int count = item.second;\\n            if(count > first_even_count){\\n                second_even_count = first_even_count;\\n                first_even_count = count;\\n                second_even_num = first_even_num;\\n                first_even_num = num;\\n            }else if (count>second_even_count){\\n                second_even_count= count;\\n                second_even_num = num;\\n            }\\n        }\\n        \\n        int first_odd_count = 0, first_odd_num = 0;\\n        int second_odd_count = 0, second_odd_num = 0;\\n        for(auto item: odd_hash_map){\\n            int num = item.first;\\n            int count = item.second;\\n            if(count > first_odd_count){\\n                second_odd_count = first_odd_count;\\n                first_odd_count = count;\\n                second_odd_num = first_odd_num;\\n                first_odd_num = num;\\n            }else if (count>second_odd_count){\\n                second_odd_count= count;\\n                second_odd_num = num;\\n            }\\n        }\\n        \\n        int even_operation = total_even - first_even_count;\\n        int odd_operation = total_odd - first_odd_count;\\n        \\n        if(first_even_num!=first_odd_num) even_operation +=(total_odd - first_odd_count);\\n        else even_operation += (total_odd - second_odd_count);\\n        \\n        if(first_odd_num!=first_even_num) odd_operation +=(total_even - first_even_count);\\n        else odd_operation +=(total_even - second_even_count);\\n        \\n        return min(even_operation, odd_operation);\\n    }",
                "solutionTags": [],
                "code": "```\\nint minimumOperations(vector<int>& nums) {\\n        if(nums.size() <2) return 0;\\n        \\n        unordered_map<int, int>even_hash_map;\\n        unordered_map<int, int>odd_hash_map;\\n        int total_even = 0, total_odd = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(i&1){\\n                odd_hash_map[nums[i]]++;\\n                total_odd++;\\n            }else{\\n                even_hash_map[nums[i]]++;\\n                total_even++;\\n            }\\n        }\\n        \\n        int first_even_count = 0, first_even_num = 0;\\n        int second_even_count = 0, second_even_num = 0;\\n        for(auto item: even_hash_map){\\n            int num = item.first;\\n            int count = item.second;\\n            if(count > first_even_count){\\n                second_even_count = first_even_count;\\n                first_even_count = count;\\n                second_even_num = first_even_num;\\n                first_even_num = num;\\n            }else if (count>second_even_count){\\n                second_even_count= count;\\n                second_even_num = num;\\n            }\\n        }\\n        \\n        int first_odd_count = 0, first_odd_num = 0;\\n        int second_odd_count = 0, second_odd_num = 0;\\n        for(auto item: odd_hash_map){\\n            int num = item.first;\\n            int count = item.second;\\n            if(count > first_odd_count){\\n                second_odd_count = first_odd_count;\\n                first_odd_count = count;\\n                second_odd_num = first_odd_num;\\n                first_odd_num = num;\\n            }else if (count>second_odd_count){\\n                second_odd_count= count;\\n                second_odd_num = num;\\n            }\\n        }\\n        \\n        int even_operation = total_even - first_even_count;\\n        int odd_operation = total_odd - first_odd_count;\\n        \\n        if(first_even_num!=first_odd_num) even_operation +=(total_odd - first_odd_count);\\n        else even_operation += (total_odd - second_odd_count);\\n        \\n        if(first_odd_num!=first_even_num) odd_operation +=(total_even - first_even_count);\\n        else odd_operation +=(total_even - second_even_count);\\n        \\n        return min(even_operation, odd_operation);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2745638,
                "title": "java",
                "content": "\\tclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        //find max and second max element\\n        int fodd[]=new int[100001];\\n        int feven[]=new int[100001];\\n        \\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n            feven[nums[i]]++;\\n        }\\n        \\n        for(int i=1;i<nums.length;i+=2)\\n        {\\n            fodd[nums[i]]++;\\n        }\\n        \\n        int[]e=new int[4];\\n        int[]o=new int[4];\\n        \\n        for(int i=0;i<=100000;i++)\\n        {\\n            int c=feven[i];\\n            if(c>e[0])\\n            {\\n                e[2]=e[0];\\n                e[3]=e[1];\\n                e[0]=c;\\n                e[1]=i;\\n            }\\n            else if(c>e[2])\\n            {\\n                e[2]=c;\\n                e[3]=i;\\n            }\\n        }\\n        \\n        for(int i=0;i<=100000;i++)\\n        {\\n            int c=fodd[i];\\n            if(c>o[0])\\n            {\\n                o[2]=o[0];\\n                o[3]=o[1];\\n                o[0]=c;\\n                o[1]=i;\\n            }\\n            else if(c>o[2])\\n            {\\n                o[2]=c;\\n                o[3]=i;\\n            }\\n        }\\n        \\n        int n=nums.length;\\n        \\n        if(e[1]!=o[1]) return n-e[0]-o[0];\\n        else \\n        {\\n            return Math.min(n-e[0]-o[2], n-e[2]-o[0]);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumOperations(int[] nums) {\\n        //find max and second max element\\n        int fodd[]=new int[100001];\\n        int feven[]=new int[100001];\\n        \\n        for(int i=0;i<nums.length;i+=2)\\n        {\\n            feven[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2720723,
                "title": "c-frustrating-simple",
                "content": "```\\nFind the max and second max freq of elements for both odd and even indices.\\nNow we can only take max1 of both odd and even if they are not similar.\\nElse we need to take max1 for even and max2 for odd or max1 for odd and max2 for even.\\n```\\n```\\ntypedef pair<int, int> pi;\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        int odd[100001] = {0};\\n        int even[100001] = {0};\\n        for(int i=0; i<n; i++){\\n            if(i%2) odd[nums[i]]++;\\n            else even[nums[i]]++;\\n        }\\n        priority_queue<pi> p1, p2;\\n        for(int i=1; i<=100000; i++){\\n            if(odd[i] != 0) p2.push({odd[i],i});\\n            if(even[i] != 0) p1.push({even[i],i});\\n        }\\n        pi x = {0,0};\\n        pi e1 = p1.top(); p1.pop();\\n        pi e2 = (!p1.empty()?p1.top():x);\\n        pi o1 = p2.top(); p2.pop();\\n        pi o2 = (!p2.empty()?p2.top():x);\\n        int ans = n - e1.first  - (e1.second != o1.second?o1.first:o2.first);\\n        int b = n - e2.first  - (e2.second != o1.second?o1.first:o2.first);\\n        return min(ans,b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nFind the max and second max freq of elements for both odd and even indices.\\nNow we can only take max1 of both odd and even if they are not similar.\\nElse we need to take max1 for even and max2 for odd or max1 for odd and max2 for even.\\n```\n```\\ntypedef pair<int, int> pi;\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 0;\\n        int odd[100001] = {0};\\n        int even[100001] = {0};\\n        for(int i=0; i<n; i++){\\n            if(i%2) odd[nums[i]]++;\\n            else even[nums[i]]++;\\n        }\\n        priority_queue<pi> p1, p2;\\n        for(int i=1; i<=100000; i++){\\n            if(odd[i] != 0) p2.push({odd[i],i});\\n            if(even[i] != 0) p1.push({even[i],i});\\n        }\\n        pi x = {0,0};\\n        pi e1 = p1.top(); p1.pop();\\n        pi e2 = (!p1.empty()?p1.top():x);\\n        pi o1 = p2.top(); p2.pop();\\n        pi o2 = (!p2.empty()?p2.top():x);\\n        int ans = n - e1.first  - (e1.second != o1.second?o1.first:o2.first);\\n        int b = n - e2.first  - (e2.second != o1.second?o1.first:o2.first);\\n        return min(ans,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715024,
                "title": "python3-find-max-and-second-max",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 0\\n        n=len(nums)\\n        ans=float(\\'inf\\')\\n        oddFreq=Counter([nums[i] for i in range(n) if i%2!=0])\\n        evenFreq=Counter([nums[i] for i in range(n) if i%2==0])\\n        evenPos,oddPos=(n+1)//2,n//2\\n        evenArray=sorted([[key,value] for key,value in evenFreq.items()],key=lambda x:x[1],reverse=True)\\n        oddArray=sorted([[key,value] for key,value in oddFreq.items()],key=lambda x:x[1],reverse=True)\\n        if evenArray[0][0]==oddArray[0][0]:\\n            if len(oddArray)>1:\\n                ans=min(ans,evenPos-evenArray[0][1]+oddPos-oddArray[1][1])\\n            else:\\n                ans=min(ans,evenPos-evenArray[0][1]+oddArray[0][1])\\n            if len(evenArray)>1:\\n                ans=min(ans,oddPos-oddArray[0][1]+evenPos-evenArray[1][1])\\n            else:\\n                ans=min(ans,oddPos-oddArray[0][1]+evenArray[0][1])\\n        else:\\n            ans=min(ans,evenPos-evenArray[0][1]+oddPos-oddArray[0][1])\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return 0\\n        n=len(nums)\\n        ans=float(\\'inf\\')\\n        oddFreq=Counter([nums[i] for i in range(n) if i%2!=0])\\n        evenFreq=Counter([nums[i] for i in range(n) if i%2==0])\\n        evenPos,oddPos=(n+1)//2,n//2\\n        evenArray=sorted([[key,value] for key,value in evenFreq.items()],key=lambda x:x[1],reverse=True)\\n        oddArray=sorted([[key,value] for key,value in oddFreq.items()],key=lambda x:x[1],reverse=True)\\n        if evenArray[0][0]==oddArray[0][0]:\\n            if len(oddArray)>1:\\n                ans=min(ans,evenPos-evenArray[0][1]+oddPos-oddArray[1][1])\\n            else:\\n                ans=min(ans,evenPos-evenArray[0][1]+oddArray[0][1])\\n            if len(evenArray)>1:\\n                ans=min(ans,oddPos-oddArray[0][1]+evenPos-evenArray[1][1])\\n            else:\\n                ans=min(ans,oddPos-oddArray[0][1]+evenArray[0][1])\\n        else:\\n            ans=min(ans,evenPos-evenArray[0][1]+oddPos-oddArray[0][1])\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713142,
                "title": "find-max-and-second-max-or-easy-to-understand-cpp",
                "content": "class Solution {\\npublic:\\n    \\n    int solve( int even , int odd , vector<int>& nums ){\\n        \\n        int ans = 0;\\n        \\n        for( int i=0 ; i < nums.size() ; i++ ){\\n            \\n            if( i % 2 == 0 && nums[i] != even )  ans++;\\n                \\n            else if(i % 2 == 1 && nums[i] != odd ) ans++;\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    int minimumOperations(vector<int>& nums) {\\n        \\n        if( nums.size() == 1 ) return  0 ;\\n        \\n        if( nums.size() == 2 ) return nums[0] == nums[1] ? 1 : 0;\\n        \\n        \\n     \\n        \\n        map<int,int>ma;\\n        \\n        map<int,int>pa;\\n        \\n        for( int i=0 ; i < nums.size() ; i++ ) if( i % 2 == 0 ) ma[ nums [ i ] ]++;\\n        \\n        for( int i=0 ; i < nums.size() ; i++ ) if( i % 2 != 0 ) pa[ nums [ i ] ]++;\\n        \\n        \\n        int evenF=0,evenS=0,Fmaxx=0,Smaxx=0;\\n        \\n        for( auto it : ma ){\\n            \\n            \\n            if( it.second > Fmaxx ){\\n                \\n                Fmaxx = it.second;\\n                \\n                evenS = evenF;\\n                \\n                evenF = it.first;\\n            }\\n            \\n            if( it.second <= Fmaxx && it.second >= Smaxx && it.first != evenF){\\n                \\n                Smaxx = it.second;\\n                \\n                evenS = it.first;\\n            }\\n            \\n        }\\n        \\n        int oddF=0,oddS=0;\\n        \\n        Fmaxx=0,Smaxx=0;\\n        \\n        for( auto it : pa ){\\n            \\n            \\n            if( it.second > Fmaxx ){\\n                \\n                Fmaxx = it.second;\\n                \\n                oddS = oddF;\\n                \\n                oddF = it.first;\\n            }\\n            \\n            if( it.second <= Fmaxx && it.second >= Smaxx && it.first != oddF){\\n                \\n                Smaxx = it.second;\\n                \\n                oddS = it.first;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n        \\n        if( evenF == 0 ) evenF = -1;\\n        \\n        if( evenS == 0 ) evenS = -2;\\n        \\n        if( oddF == 0 ) oddF = -3;\\n        \\n        if( oddS == 0 ) oddS = -4;\\n        \\n        cout<<evenF<<\" \"<<evenS<<endl;\\n        \\n        cout<<oddF<<\" \"<<oddS<<endl;\\n        \\n        \\n        int ans=INT_MAX;\\n        \\n        if( evenF != oddF )  ans = min ( ans , solve( evenF , oddF , nums ) );\\n        \\n        if( evenF != oddS )  ans = min ( ans , solve( evenF , oddS , nums ) );\\n        \\n        if( evenS != oddF )  ans = min ( ans , solve( evenS , oddF , nums ) );\\n        \\n        if( evenS != oddS )  ans = min ( ans , solve( evenS , oddS , nums ) );\\n        \\n        \\n        return ans;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int solve( int even , int odd , vector<int>& nums ){\\n        \\n        int ans = 0;\\n        \\n        for( int i=0 ; i < nums.size() ; i++ ){\\n            \\n            if( i % 2 == 0 && nums[i] != even )  ans++;\\n                \\n            else if(i % 2 == 1 && nums[i] != odd ) ans++;\\n                \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2650384,
                "title": "scala-solution",
                "content": "```\\nimport scala.util.Try\\n\\n  def minimumOperations(nums: Array[Int]): Int = {\\n    val even = (nums.zipWithIndex).filter(_._2 % 2 == 0).map(_._1).groupBy(identity).mapValues(_.size).toList.sortBy(-_._2).take(2)\\n    val odd = (nums.zipWithIndex).filter(_._2 % 2 == 1).map(_._1).groupBy(identity).mapValues(_.size).toList.sortBy(-_._2).take(2)\\n\\n    if(even.head._1 == Try(odd.head._1).getOrElse(0))\\n      nums.size - ((even.head._2 + Try(odd.tail.head._2).getOrElse(0)) max (Try(even.tail.head._2).getOrElse(0) + odd.head._2))\\n    else nums.length - (even.head._2 + Try(odd.head._2).getOrElse(0))\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.util.Try\\n\\n  def minimumOperations(nums: Array[Int]): Int = {\\n    val even = (nums.zipWithIndex).filter(_._2 % 2 == 0).map(_._1).groupBy(identity).mapValues(_.size).toList.sortBy(-_._2).take(2)\\n    val odd = (nums.zipWithIndex).filter(_._2 % 2 == 1).map(_._1).groupBy(identity).mapValues(_.size).toList.sortBy(-_._2).take(2)\\n\\n    if(even.head._1 == Try(odd.head._1).getOrElse(0))\\n      nums.size - ((even.head._2 + Try(odd.tail.head._2).getOrElse(0)) max (Try(even.tail.head._2).getOrElse(0) + odd.head._2))\\n    else nums.length - (even.head._2 + Try(odd.head._2).getOrElse(0))\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2641298,
                "title": "ts-js-solution",
                "content": "```\\nfunction minimumOperations(nums: number[]): number {\\n  if (nums.length === 1) {\\n    return 0;\\n  }\\n\\n  const fullLength: number = nums.length;\\n  const even: Record<number, number> = {};\\n  const odd: Record<number, number> = {};\\n\\n  nums.forEach((num, i) => {\\n    const obj = i % 2 === 0 ? even : odd;\\n    \\n    obj[num] = (obj?.[num] || 0) + 1;\\n  });\\n\\n  const oddList = Object.entries(odd).sort((a, b) => b[1] - a[1]);\\n  const evenList = Object.entries(even).sort((a, b) => b[1] - a[1]);\\n  \\n  const [oddMaxNumber, oddMaxCount] = oddList[0];\\n  const [evenMaxNumber, evenMaxCount] = evenList[0];\\n  \\n  if (oddMaxNumber !== evenMaxNumber) {\\n      return fullLength - oddMaxCount - evenMaxCount;\\n  }\\n\\n  const oddSecondMaxCount = oddList?.[1]?.[1] || 0;\\n  const evenSecondMaxCount = evenList?.[1]?.[1] || 0;\\n\\n  return Math.min(\\n    fullLength - oddMaxCount - evenSecondMaxCount,\\n    fullLength - evenMaxCount - oddSecondMaxCount\\n  );\\n};\\n```\\n\\n```\\nRuntime: 438 ms, faster than 100.00% of TypeScript online submissions for Minimum Operations to Make the Array Alternating.\\nMemory Usage: 82.3 MB, less than 100.00% of TypeScript online submissions for Minimum Operations to Make the Array Alternating.\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumOperations(nums: number[]): number {\\n  if (nums.length === 1) {\\n    return 0;\\n  }\\n\\n  const fullLength: number = nums.length;\\n  const even: Record<number, number> = {};\\n  const odd: Record<number, number> = {};\\n\\n  nums.forEach((num, i) => {\\n    const obj = i % 2 === 0 ? even : odd;\\n    \\n    obj[num] = (obj?.[num] || 0) + 1;\\n  });\\n\\n  const oddList = Object.entries(odd).sort((a, b) => b[1] - a[1]);\\n  const evenList = Object.entries(even).sort((a, b) => b[1] - a[1]);\\n  \\n  const [oddMaxNumber, oddMaxCount] = oddList[0];\\n  const [evenMaxNumber, evenMaxCount] = evenList[0];\\n  \\n  if (oddMaxNumber !== evenMaxNumber) {\\n      return fullLength - oddMaxCount - evenMaxCount;\\n  }\\n\\n  const oddSecondMaxCount = oddList?.[1]?.[1] || 0;\\n  const evenSecondMaxCount = evenList?.[1]?.[1] || 0;\\n\\n  return Math.min(\\n    fullLength - oddMaxCount - evenSecondMaxCount,\\n    fullLength - evenMaxCount - oddSecondMaxCount\\n  );\\n};\\n```\n```\\nRuntime: 438 ms, faster than 100.00% of TypeScript online submissions for Minimum Operations to Make the Array Alternating.\\nMemory Usage: 82.3 MB, less than 100.00% of TypeScript online submissions for Minimum Operations to Make the Array Alternating.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2611644,
                "title": "o-n-time-o-n-space-clear-explanation-find-most-common-and-freeze",
                "content": "![image](https://assets.leetcode.com/users/images/a52d725c-f7b4-4d39-9cae-beceeff80193_1663874708.3286734.png)\\n\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        cnt_a, cnt_b = collections.Counter(nums[::2]).most_common(2), collections.Counter(nums[1::2]).most_common(2)\\n        ((a_ch, aa), (b_ch, bb), _), ((_, a), (_, b), _) = itertools.zip_longest(cnt_a, cnt_b, (0, 0), fillvalue=(None, 0))\\n        return len(nums) - (max(aa + b, a + bb) if a_ch == b_ch else aa + bb)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/a52d725c-f7b4-4d39-9cae-beceeff80193_1663874708.3286734.png)\\n\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        cnt_a, cnt_b = collections.Counter(nums[::2]).most_common(2), collections.Counter(nums[1::2]).most_common(2)\\n        ((a_ch, aa), (b_ch, bb), _), ((_, a), (_, b), _) = itertools.zip_longest(cnt_a, cnt_b, (0, 0), fillvalue=(None, 0))\\n        return len(nums) - (max(aa + b, a + bb) if a_ch == b_ch else aa + bb)",
                "codeTag": "Python3"
            },
            {
                "id": 2600933,
                "title": "o-n-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxct(vector<int> nums,int start)\\n    {\\n        vector<int> v1(1e5+1,0);\\n        int first=0,second=0;\\n        for(int i=start;i<nums.size();i+=2)\\n        {\\n            v1[nums[i]]++;\\n            if(nums[i]!=first)\\n            {\\n                if(v1[nums[i]]>=v1[first])\\n                {\\n                    second=first;\\n                    first=nums[i];\\n                }\\n                else\\n                {\\n                    if(v1[nums[i]]>=v1[second])\\n                    {\\n                        second=nums[i];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return {v1[first],v1[second],first,second};\\n    }\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1)return 0;\\n        if(nums.size()==2)return nums[0]==nums[1];\\n        vector<int> v1=maxct(nums,0),v2=maxct(nums,1);\\n        int a=v1[0],b=v2[0];\\n        int size=nums.size();\\n        if(v1[2]==v2[2])\\n        {\\n             return min((((size+1)/2)-a)+((size/2)-v2[1]),(((size+1)/2)-v1[1])+((size/2)-b));\\n        }\\n        \\n        return (((size+1)/2)-a)+((size/2)-b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxct(vector<int> nums,int start)\\n    {\\n        vector<int> v1(1e5+1,0);\\n        int first=0,second=0;\\n        for(int i=start;i<nums.size();i+=2)\\n        {\\n            v1[nums[i]]++;\\n            if(nums[i]!=first)\\n            {\\n                if(v1[nums[i]]>=v1[first])\\n                {\\n                    second=first;\\n                    first=nums[i];\\n                }\\n                else\\n                {\\n                    if(v1[nums[i]]>=v1[second])\\n                    {\\n                        second=nums[i];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return {v1[first],v1[second],first,second};\\n    }\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1)return 0;\\n        if(nums.size()==2)return nums[0]==nums[1];\\n        vector<int> v1=maxct(nums,0),v2=maxct(nums,1);\\n        int a=v1[0],b=v2[0];\\n        int size=nums.size();\\n        if(v1[2]==v2[2])\\n        {\\n             return min((((size+1)/2)-a)+((size/2)-v2[1]),(((size+1)/2)-v1[1])+((size/2)-b));\\n        }\\n        \\n        return (((size+1)/2)-a)+((size/2)-b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552516,
                "title": "c-hashmap",
                "content": "```\\n/*\\n\\nIn one step, we can change any no. to any other no.\\n\\nMin no. of steps to make the array alternating ?\\n\\n\\nall even index no\\'s should be equal\\n\\n\\nall odd index numbers should also be equal\\n\\n\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        \\n        unordered_map<int,int>even;\\n        \\n        int mxe=0;\\n        int no=0;\\n        int e=0;\\n\\n        for(int i=0;i<n;i+=2){\\n            even[nums[i]]++;\\n            if(mxe<even[nums[i]]){\\n                mxe=even[nums[i]];\\n                no=nums[i];\\n            }\\n            e++;\\n        }\\n        \\n        \\n        unordered_map<int,int>odd;\\n        \\n        int mxo=0;\\n        int no1=0;\\n        int o=0;\\n        \\n        for(int i=1;i<n;i+=2){\\n            odd[nums[i]]++;\\n            \\n             if(mxo<odd[nums[i]]){\\n                mxo=odd[nums[i]];\\n                no1=nums[i];\\n            }\\n            o++;\\n        }\\n        \\n        \\n        // keeping max freq. no with even indexes\\n    \\n           int total1=0;\\n        \\n            total1+=e-mxe;\\n        \\n              int mxo1=0;  // max freq. of a no that is not at even index\\n                    \\n        for(auto it:odd){\\n            \\n             if(mxo1<it.second && (it.first!=no)){\\n                mxo1=it.second;\\n            }\\n        \\n        }\\n        \\n         total1+=(o-mxo1);\\n            \\n            \\n     // keeping max freq. no with odd indexes       \\n        \\n            int total2=0;\\n            \\n            total2+=o-mxo;\\n                        \\n            int mxe1=0;     // max freq. of a no that is not at even index\\n\\n\\n        for(auto it:even){\\n            if(mxe1<it.second && it.first!=no1){\\n                mxe1=it.second;\\n            }\\n        }\\n            \\n             total2+=(e-mxe1);\\n                    \\n        return min(total1,total2);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        \\n        unordered_map<int,int>even;\\n        \\n        int mxe=0;\\n        int no=0;\\n        int e=0;\\n\\n        for(int i=0;i<n;i+=2){\\n            even[nums[i]]++;\\n            if(mxe<even[nums[i]]){\\n                mxe=even[nums[i]];\\n                no=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2538588,
                "title": "python3-2-lines-code-95-faster-and-80-lesser-memory",
                "content": "```\\nfrom itertools import product\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even, odd = [Counter(nums[i::2]).most_common(2) + [(0, 0)] for i in range(2)]\\n        return len(nums) - max(a[1] + b[1] for a, b in product(even, odd) if a[0] != b[0])\\n```\\n\\nReference: https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/discuss/2401747/Python-2-lines",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even, odd = [Counter(nums[i::2]).most_common(2) + [(0, 0)] for i in range(2)]\\n        return len(nums) - max(a[1] + b[1] for a, b in product(even, odd) if a[0] != b[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533472,
                "title": "python3-i-need-help-for-equal-top-frequencies-in-two-lists-how-do-i-debug",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        list1 = list(); list2 = list()\\n        \\n        for i, num in enumerate(nums):\\n            if i % 2 == 0: list1.append(num)\\n            if i % 2 == 1: list2.append(num)\\n            \\n        counterList1 = Counter(list1); counterList2 = Counter(list2)\\n        c1 = counterList1.most_common(1)[0][1]\\n        c2 = counterList2.most_common(1)[0][1]\\n        \\n        #minimum = min(c1, c2)\\n        #if c1 != c2:\\n        minimum = len(nums) - c1 - c2\\n        \\n        if c1 == c2: #I am not able to \\'debug\\' this\\n            #I am using https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/discuss/1766804/C++-or-Find-max-and-second-max-or-easy-to-understand/1264833 as reference\\n            try:\\n                c1_ = counterList1.most_common(2)[1][1]\\n            except IndexError:\\n                c1_ = c1\\n                \\n            try:\\n                c2_ = counterList2.most_common(2)[1][1]\\n            except IndexError:\\n                c2_ = c2\\n                \\n            minimum = min(len(nums) - c1_ - c2, len(nums) - c1 - c2_, minimum)\\n        \\n        return minimum\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        list1 = list(); list2 = list()\\n        \\n        for i, num in enumerate(nums):\\n            if i % 2 == 0: list1.append(num)\\n            if i % 2 == 1: list2.append(num)\\n            \\n        counterList1 = Counter(list1); counterList2 = Counter(list2)\\n        c1 = counterList1.most_common(1)[0][1]\\n        c2 = counterList2.most_common(1)[0][1]\\n        \\n        #minimum = min(c1, c2)\\n        #if c1 != c2:\\n        minimum = len(nums) - c1 - c2\\n        \\n        if c1 == c2: #I am not able to \\'debug\\' this\\n            #I am using https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/discuss/1766804/C++-or-Find-max-and-second-max-or-easy-to-understand/1264833 as reference\\n            try:\\n                c1_ = counterList1.most_common(2)[1][1]\\n            except IndexError:\\n                c1_ = c1\\n                \\n            try:\\n                c2_ = counterList2.most_common(2)[1][1]\\n            except IndexError:\\n                c2_ = c2\\n                \\n            minimum = min(len(nums) - c1_ - c2, len(nums) - c1 - c2_, minimum)\\n        \\n        return minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443074,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n\\t\\t// map to count occurrrences of numbers on even odd indices\\n        map<int, int> even, odd;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (i % 2) odd[nums[i]]++;\\n            else even[nums[i]]++;\\n        \\n\\t\\t// p1 and p2 are first and second candidates for even position and\\n\\t\\t// p3 and p4 are first and second candidates for odd position\\n        pair<int, int> p1 = {0, 0}, p2 = {0, 0}, p3 = {0, 0}, p4 = {0, 0}; \\n\\t\\t// first element in pair is the number while the second element is its count\\n        for (auto m : even) {\\n            if (m.second > p1.second) {\\n                p2 = p1;\\n                p1 = m;\\n            }\\n            else if (m.second > p2.second)\\n                p2 = m;\\n        }\\n        \\n        for (auto m : odd) {\\n            if (m.second > p3.second) {\\n                p4 = p3;\\n                p3 = m;\\n            }\\n            else if (m.second > p4.second)\\n                p4 = m;\\n        }\\n        \\n        int cnt1 = 0, cnt2 = 0;\\n\\t\\t// if numbers at alternate indices with largest counts are equal \\n\\t\\t// then we must consider our second candidates from both indices (odd and even indices)\\n        if (p1.first == p3.first) {                        \\n            cnt1 = p1.second + p4.second;\\n            cnt2 = p2.second + p3.second;\\n        }\\n        else cnt1 = p1.second + p3.second;\\n        \\n        return nums.size() - max(cnt1, cnt2);\\n    }\\n};\\n```\\n\\nFeel free to ask if you have any doubts :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n\\t\\t// map to count occurrrences of numbers on even odd indices\\n        map<int, int> even, odd;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (i % 2) odd[nums[i]]++;\\n            else even[nums[i]]++;\\n        \\n\\t\\t// p1 and p2 are first and second candidates for even position and\\n\\t\\t// p3 and p4 are first and second candidates for odd position\\n        pair<int, int> p1 = {0, 0}, p2 = {0, 0}, p3 = {0, 0}, p4 = {0, 0}; \\n\\t\\t// first element in pair is the number while the second element is its count\\n        for (auto m : even) {\\n            if (m.second > p1.second) {\\n                p2 = p1;\\n                p1 = m;\\n            }\\n            else if (m.second > p2.second)\\n                p2 = m;\\n        }\\n        \\n        for (auto m : odd) {\\n            if (m.second > p3.second) {\\n                p4 = p3;\\n                p3 = m;\\n            }\\n            else if (m.second > p4.second)\\n                p4 = m;\\n        }\\n        \\n        int cnt1 = 0, cnt2 = 0;\\n\\t\\t// if numbers at alternate indices with largest counts are equal \\n\\t\\t// then we must consider our second candidates from both indices (odd and even indices)\\n        if (p1.first == p3.first) {                        \\n            cnt1 = p1.second + p4.second;\\n            cnt2 = p2.second + p3.second;\\n        }\\n        else cnt1 = p1.second + p3.second;\\n        \\n        return nums.size() - max(cnt1, cnt2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364775,
                "title": "beginner-c-simple",
                "content": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) \\n    {\\n        unordered_map<int,int>even,odd;\\n        int mx1,mx2,mx3,mx4,ele1,ele2;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2)\\n            {\\n                odd[nums[i]]++;\\n                \\n                if(odd[nums[i]]>mx1)\\n                {\\n                    mx1=odd[nums[i]];\\n                    ele1=nums[i];\\n                }\\n                else if(odd[nums[i]]>mx2)\\n                    mx2=odd[nums[i]];\\n            }\\n            else\\n            {\\n                even[nums[i]]++;\\n                \\n                if(even[nums[i]]>mx3)\\n                {\\n                    mx3=even[nums[i]];\\n                    ele2=nums[i];\\n                }\\n                else if(even[nums[i]]>mx4)\\n                    mx4=even[nums[i]];\\n            }\\n        }\\n        \\n        if(ele1!=ele2)\\n            return n-mx1-mx3;\\n        \\n        return min(n-mx1-mx4,n-mx2-mx3);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) \\n    {\\n        unordered_map<int,int>even,odd;\\n        int mx1,mx2,mx3,mx4,ele1,ele2;\\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2)\\n            {\\n                odd[nums[i]]++;\\n                \\n                if(odd[nums[i]]>mx1)\\n                {\\n                    mx1=odd[nums[i]];\\n                    ele1=nums[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2356498,
                "title": "python-solution-for-top-2-element",
                "content": "```\\ndef minimumOperations(self, nums: List[int]) -> int:\\n\\tif len(set(nums))==1:\\n\\t\\treturn len(nums)//2\\n\\n\\tmx1 = Counter([nums[i] for i in range(len(nums)) if not i%2]).most_common(2)\\n\\tmx2 = Counter([nums[i] for i in range(len(nums)) if i%2]).most_common(2)\\n\\ts = mx1[0][1]+mx2[0][1]\\n\\tif mx1[0][0]==mx2[0][0]:\\n\\t\\tif len(mx1)>1 and len(mx2)>1:\\n\\t\\t\\ts = max(mx1[0][1]+mx2[1][1], mx1[1][1]+mx2[0][1])\\n\\t\\tif len(mx1)==1:\\n\\t\\t\\ts = mx1[0][1]+mx2[1][1]        \\n\\t\\tif len(mx2)==1:\\n\\t\\t\\ts = mx1[1][1]+mx2[0][1]          \\n\\n\\treturn len(nums)-s\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumOperations(self, nums: List[int]) -> int:\\n\\tif len(set(nums))==1:\\n\\t\\treturn len(nums)//2\\n\\n\\tmx1 = Counter([nums[i] for i in range(len(nums)) if not i%2]).most_common(2)\\n\\tmx2 = Counter([nums[i] for i in range(len(nums)) if i%2]).most_common(2)\\n\\ts = mx1[0][1]+mx2[0][1]\\n\\tif mx1[0][0]==mx2[0][0]:\\n\\t\\tif len(mx1)>1 and len(mx2)>1:\\n\\t\\t\\ts = max(mx1[0][1]+mx2[1][1], mx1[1][1]+mx2[0][1])\\n\\t\\tif len(mx1)==1:\\n\\t\\t\\ts = mx1[0][1]+mx2[1][1]        \\n\\t\\tif len(mx2)==1:\\n\\t\\t\\ts = mx1[1][1]+mx2[0][1]          \\n\\n\\treturn len(nums)-s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2354206,
                "title": "java-optimized-solution-clean-code",
                "content": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnums = [3,3,4,2,3,3,5,3,6]\\n*/\\n\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        HashMap<Integer, Integer> mapEven = new HashMap<>() ;\\n        HashMap<Integer, Integer> mapOdd = new HashMap<>() ;\\n        \\n        int maxE1 = 0, maxE2 = -1, maxO1 = 0, maxO2 = -1, keyE1 = 0, keyO1 = 0 ;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) mapEven.put(nums[i], mapEven.getOrDefault(nums[i], 0)+1) ;\\n            else mapOdd.put(nums[i], mapOdd.getOrDefault(nums[i], 0)+1) ;\\n        }\\n        \\n        for (Map.Entry m : mapEven.entrySet()) {\\n            int val = (int)m.getValue() ;\\n            if (val > maxE1) {\\n                maxE2 = maxE1 ;\\n                maxE1 = val ;\\n                keyE1 = (int)m.getKey() ;\\n            }\\n            else if (val > maxE2) maxE2 = val ;\\n        }\\n        \\n        for (Map.Entry m : mapOdd.entrySet()) {\\n            int val = (int)m.getValue() ;\\n            if (val > maxO1) {\\n                maxO2 = maxO1 ;\\n                maxO1 = val ;\\n                keyO1 = (int)m.getKey() ;\\n            }\\n            else if (val > maxO2) maxO2 = val ;\\n        }\\n        \\n        if (keyE1 != keyO1) return (nums.length - maxE1 - maxO1) ;\\n        else if (maxE2 <= 0 && maxO2 <= 0) return nums.length/2 ;\\n        return Math.min((nums.length-maxE1-maxO2), (nums.length-maxO1-maxE2)) ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnums = [3,3,4,2,3,3,5,3,6]\\n*/\\n\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        HashMap<Integer, Integer> mapEven = new HashMap<>() ;\\n        HashMap<Integer, Integer> mapOdd = new HashMap<>() ;\\n        \\n        int maxE1 = 0, maxE2 = -1, maxO1 = 0, maxO2 = -1, keyE1 = 0, keyO1 = 0 ;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) mapEven.put(nums[i], mapEven.getOrDefault(nums[i], 0)+1) ;\\n            else mapOdd.put(nums[i], mapOdd.getOrDefault(nums[i], 0)+1) ;\\n        }\\n        \\n        for (Map.Entry m : mapEven.entrySet()) {\\n            int val = (int)m.getValue() ;\\n            if (val > maxE1) {\\n                maxE2 = maxE1 ;\\n                maxE1 = val ;\\n                keyE1 = (int)m.getKey() ;\\n            }\\n            else if (val > maxE2) maxE2 = val ;\\n        }\\n        \\n        for (Map.Entry m : mapOdd.entrySet()) {\\n            int val = (int)m.getValue() ;\\n            if (val > maxO1) {\\n                maxO2 = maxO1 ;\\n                maxO1 = val ;\\n                keyO1 = (int)m.getKey() ;\\n            }\\n            else if (val > maxO2) maxO2 = val ;\\n        }\\n        \\n        if (keyE1 != keyO1) return (nums.length - maxE1 - maxO1) ;\\n        else if (maxE2 <= 0 && maxO2 <= 0) return nums.length/2 ;\\n        return Math.min((nums.length-maxE1-maxO2), (nums.length-maxO1-maxE2)) ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352457,
                "title": "c-top-2-frequent-entries",
                "content": "To solve that we should find most frequent characters - these we want to preserve and reverse the others. Basically there are only three options - most frequent characters for even and odd subsequence do not match - in that case we know the answer. If they do match - we have two options:\\n1. use most frequent from odd subsequence and second frequent from even\\n2. use second frequent from odd subsequence and most frequent from even\\n\\n\\n```\\npublic class Solution\\n{\\n    public int MinimumOperations(int[] nums)\\n    {\\n        var hashOdd = new Dictionary<int, int> { { -1, 0 } };\\n        var hashEven = new Dictionary<int, int> { { -1, 0 } };\\n\\n        var evenMax = -1;\\n        var evenSubMax = -1;\\n        var oddMax = -1;\\n        var oddSubMax = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            if (i % 2 == 0)\\n                Increment(hashEven, nums[i], ref evenMax, ref evenSubMax);\\n            else\\n                Increment(hashOdd, nums[i], ref oddMax, ref oddSubMax);\\n        }\\n\\n        var oddMaxValue = hashOdd.GetValueOrDefault(oddMax);\\n        var evenMaxValue = hashEven.GetValueOrDefault(evenMax);\\n        var oddSubMaxValue = hashOdd.GetValueOrDefault(oddSubMax);\\n        var evenSubMaxValue = hashEven.GetValueOrDefault(evenSubMax);\\n        \\n        return oddMax != evenMax\\n            ? nums.Length - oddMaxValue - evenMaxValue\\n            : Math.Min(\\n                nums.Length - oddMaxValue - evenSubMaxValue,\\n                nums.Length - oddSubMaxValue - evenMaxValue);\\n    }\\n\\n    public void Increment(Dictionary<int, int> hash, int key, ref int max, ref int subMax)\\n    {\\n        hash[key] = hash.GetValueOrDefault(key) + 1;\\n\\n        if (key == max)\\n            return;\\n\\n        if (hash[key] > hash[max])\\n            (subMax, max) = (max, key);\\n        else if (hash[key] > hash[subMax])\\n            subMax = key;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumOperations(int[] nums)\\n    {\\n        var hashOdd = new Dictionary<int, int> { { -1, 0 } };\\n        var hashEven = new Dictionary<int, int> { { -1, 0 } };\\n\\n        var evenMax = -1;\\n        var evenSubMax = -1;\\n        var oddMax = -1;\\n        var oddSubMax = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            if (i % 2 == 0)\\n                Increment(hashEven, nums[i], ref evenMax, ref evenSubMax);\\n            else\\n                Increment(hashOdd, nums[i], ref oddMax, ref oddSubMax);\\n        }\\n\\n        var oddMaxValue = hashOdd.GetValueOrDefault(oddMax);\\n        var evenMaxValue = hashEven.GetValueOrDefault(evenMax);\\n        var oddSubMaxValue = hashOdd.GetValueOrDefault(oddSubMax);\\n        var evenSubMaxValue = hashEven.GetValueOrDefault(evenSubMax);\\n        \\n        return oddMax != evenMax\\n            ? nums.Length - oddMaxValue - evenMaxValue\\n            : Math.Min(\\n                nums.Length - oddMaxValue - evenSubMaxValue,\\n                nums.Length - oddSubMaxValue - evenMaxValue);\\n    }\\n\\n    public void Increment(Dictionary<int, int> hash, int key, ref int max, ref int subMax)\\n    {\\n        hash[key] = hash.GetValueOrDefault(key) + 1;\\n\\n        if (key == max)\\n            return;\\n\\n        if (hash[key] > hash[max])\\n            (subMax, max) = (max, key);\\n        else if (hash[key] > hash[subMax])\\n            subMax = key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341309,
                "title": "c-solution-with-detailed-hindi-explanation",
                "content": "```\\n/*\\n    we need the same elements at odd indices : call it x\\n    we need the same element at even indices : call it y\\n    also x \\u2260 y\\n    \\n    bhai dekho obvious si baat ho, final array mein jo odd position pe aayega, vo element vo waala \\n    hona chahiye jo original array mein odd positions me sabse zyada baar aa raha hai, taaki \\n    jo replacements karni pad rhi hain vo kam se kam ho\\n    \\n    even indices ka bhi same hisaab kitaab hai, final array mein even positions mein jo aayega, \\n    vo element aayega jo original array mein even position pe sabse zyada baar aayega\\n    \\n    so it is better to make x = element which occurs maximum times on the odd indices\\n    and it is better to make y = element which occurs maximum time on the even indices\\n    \\n    eg:\\n    \\n     0 1 2 3 4 5 6 7 8 9\\n    [2,3,2,5,1,3,2,3,8,4]\\n    \\n    yhaan pe even indices pe sabse zyada baar 2 aa rha hai aur odd indices pe sabse zyada baar 3 aa rha hai\\n    sab even indices pe 2 rakh do aur sab odd indices pe 3 rakh do, is tareeke se number of operations minimum hongi\\n    \\n    par ek panga hai bhai, zindagi itni asaan nahi hai\\n    agar even waala max frequency element aur odd waala max freq element same hua toh?\\n    toh fir do optimal solutions hain\\n    -> even waale indices pe second highest frequency waala rakh do, aur odd pe highest rakh do\\n    -> even pe highest waala rakh do aur even pe second highest waala rakh do\\n    \\n*/\\nclass Solution {\\npublic:\\n    int count(vector<int> &a, int oddGuy, int evenGuy) {\\n        int cnt = 0;\\n        int n = a.size();\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0 && a[i] != evenGuy) cnt++;\\n            else if(i % 2 == 1 && a[i] != oddGuy) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    int minimumOperations(vector<int>& a) {\\n        \\n        unordered_map<int, int> odd;\\n        unordered_map<int, int> even;\\n        int n = a.size();\\n        int cnt = 12412321;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) even[a[i]]++;\\n            else odd[a[i]]++;\\n        }\\n        \\n        int maxOddFreq = 0, secondMaxOddFreq = 0;\\n        int maxEvenFreq = 0, secondMaxEvenFreq = 0;\\n        int maxOdd = 0, maxEven = 0, secondMaxOdd = 0, secondMaxEven = 0;\\n        \\n        for(auto m : odd) {\\n            int cur = m.first, freq = m.second;\\n            if(freq > maxOddFreq) {\\n                secondMaxOddFreq = maxOddFreq;\\n                secondMaxOdd = maxOdd;\\n                maxOdd = cur;\\n                maxOddFreq = freq;\\n            } else {\\n                if(freq >= secondMaxOddFreq) {\\n                    secondMaxOddFreq = freq;\\n                    secondMaxOdd = cur;\\n                }\\n            }\\n        }\\n        \\n        for(auto m : even) {\\n            int cur = m.first, freq = m.second;\\n            if(freq > maxEvenFreq) {\\n                secondMaxEvenFreq = maxEvenFreq;\\n                secondMaxEven = maxEven;\\n                maxEvenFreq = freq;\\n                maxEven = cur;\\n            } else if(freq >= secondMaxEvenFreq) {\\n                secondMaxEvenFreq = freq;\\n                secondMaxEven = cur;\\n            }\\n        }\\n        \\n        if(maxOdd == maxEven) return min(count(a, maxOdd, secondMaxEven), count(a, secondMaxOdd, maxEven));\\n        else return count(a, maxOdd, maxEven);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n    we need the same elements at odd indices : call it x\\n    we need the same element at even indices : call it y\\n    also x \\u2260 y\\n    \\n    bhai dekho obvious si baat ho, final array mein jo odd position pe aayega, vo element vo waala \\n    hona chahiye jo original array mein odd positions me sabse zyada baar aa raha hai, taaki \\n    jo replacements karni pad rhi hain vo kam se kam ho\\n    \\n    even indices ka bhi same hisaab kitaab hai, final array mein even positions mein jo aayega, \\n    vo element aayega jo original array mein even position pe sabse zyada baar aayega\\n    \\n    so it is better to make x = element which occurs maximum times on the odd indices\\n    and it is better to make y = element which occurs maximum time on the even indices\\n    \\n    eg:\\n    \\n     0 1 2 3 4 5 6 7 8 9\\n    [2,3,2,5,1,3,2,3,8,4]\\n    \\n    yhaan pe even indices pe sabse zyada baar 2 aa rha hai aur odd indices pe sabse zyada baar 3 aa rha hai\\n    sab even indices pe 2 rakh do aur sab odd indices pe 3 rakh do, is tareeke se number of operations minimum hongi\\n    \\n    par ek panga hai bhai, zindagi itni asaan nahi hai\\n    agar even waala max frequency element aur odd waala max freq element same hua toh?\\n    toh fir do optimal solutions hain\\n    -> even waale indices pe second highest frequency waala rakh do, aur odd pe highest rakh do\\n    -> even pe highest waala rakh do aur even pe second highest waala rakh do\\n    \\n*/\\nclass Solution {\\npublic:\\n    int count(vector<int> &a, int oddGuy, int evenGuy) {\\n        int cnt = 0;\\n        int n = a.size();\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0 && a[i] != evenGuy) cnt++;\\n            else if(i % 2 == 1 && a[i] != oddGuy) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    int minimumOperations(vector<int>& a) {\\n        \\n        unordered_map<int, int> odd;\\n        unordered_map<int, int> even;\\n        int n = a.size();\\n        int cnt = 12412321;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) even[a[i]]++;\\n            else odd[a[i]]++;\\n        }\\n        \\n        int maxOddFreq = 0, secondMaxOddFreq = 0;\\n        int maxEvenFreq = 0, secondMaxEvenFreq = 0;\\n        int maxOdd = 0, maxEven = 0, secondMaxOdd = 0, secondMaxEven = 0;\\n        \\n        for(auto m : odd) {\\n            int cur = m.first, freq = m.second;\\n            if(freq > maxOddFreq) {\\n                secondMaxOddFreq = maxOddFreq;\\n                secondMaxOdd = maxOdd;\\n                maxOdd = cur;\\n                maxOddFreq = freq;\\n            } else {\\n                if(freq >= secondMaxOddFreq) {\\n                    secondMaxOddFreq = freq;\\n                    secondMaxOdd = cur;\\n                }\\n            }\\n        }\\n        \\n        for(auto m : even) {\\n            int cur = m.first, freq = m.second;\\n            if(freq > maxEvenFreq) {\\n                secondMaxEvenFreq = maxEvenFreq;\\n                secondMaxEven = maxEven;\\n                maxEvenFreq = freq;\\n                maxEven = cur;\\n            } else if(freq >= secondMaxEvenFreq) {\\n                secondMaxEvenFreq = freq;\\n                secondMaxEven = cur;\\n            }\\n        }\\n        \\n        if(maxOdd == maxEven) return min(count(a, maxOdd, secondMaxEven), count(a, secondMaxOdd, maxEven));\\n        else return count(a, maxOdd, maxEven);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324119,
                "title": "python3-hashmap-and-priority-queue-easy-to-understand",
                "content": "find all frequency of odd and even numbers and put them into priority queue.\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        even = []\\n        even_table = defaultdict(int)\\n        for count, num in enumerate(nums):\\n            if not count&1:\\n                even_table[num] += 1\\n        for num, occurance in even_table.items():\\n            heapq.heappush(even, [-occurance, num])\\n\\n        odd_table = defaultdict(int)\\n        odd = []\\n        for count, num in enumerate(nums):\\n            if count&1:\\n                odd_table[num] += 1\\n        for num, occurance in odd_table.items():\\n            heapq.heappush(odd, [-occurance, num])\\n        even_frequent = heapq.heappop(even)\\n        odd_frequent = heapq.heappop(odd)\\n        while (even_frequent[1] == odd_frequent[1]):\\n            if not even and not odd:\\n                return int(len(nums)/2)\\n            elif not even:\\n                return self.count(nums, even_frequent, heapq.heappop(odd))\\n            elif not odd:\\n                return self.count(nums, heapq.heappop(even), odd_frequent)\\n            else:\\n                return min([self.count(nums, even_frequent, heapq.heappop(odd)), \\n                           self.count(nums, heapq.heappop(even), odd_frequent)])\\n        return self.count(nums, even_frequent, odd_frequent)\\n\\n    def count(self, nums: List[int], even_frequent: List[int], odd_frequent: List[int]) -> int:\\n        res = 0\\n        if not even_frequent or not odd_frequent:\\n            return float(\\'inf\\')\\n        for count, num in enumerate(nums):\\n            if not count&1 and num != even_frequent[1]:\\n                res += 1\\n            elif count&1 and num !=  odd_frequent[1]:\\n                    res += 1\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "find all frequency of odd and even numbers and put them into priority queue.\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums) < 2:\\n            return 0\\n        even = []\\n        even_table = defaultdict(int)\\n        for count, num in enumerate(nums):\\n            if not count&1:\\n                even_table[num] += 1\\n        for num, occurance in even_table.items():\\n            heapq.heappush(even, [-occurance, num])\\n\\n        odd_table = defaultdict(int)\\n        odd = []\\n        for count, num in enumerate(nums):\\n            if count&1:\\n                odd_table[num] += 1\\n        for num, occurance in odd_table.items():\\n            heapq.heappush(odd, [-occurance, num])\\n        even_frequent = heapq.heappop(even)\\n        odd_frequent = heapq.heappop(odd)\\n        while (even_frequent[1] == odd_frequent[1]):\\n            if not even and not odd:\\n                return int(len(nums)/2)\\n            elif not even:\\n                return self.count(nums, even_frequent, heapq.heappop(odd))\\n            elif not odd:\\n                return self.count(nums, heapq.heappop(even), odd_frequent)\\n            else:\\n                return min([self.count(nums, even_frequent, heapq.heappop(odd)), \\n                           self.count(nums, heapq.heappop(even), odd_frequent)])\\n        return self.count(nums, even_frequent, odd_frequent)\\n\\n    def count(self, nums: List[int], even_frequent: List[int], odd_frequent: List[int]) -> int:\\n        res = 0\\n        if not even_frequent or not odd_frequent:\\n            return float(\\'inf\\')\\n        for count, num in enumerate(nums):\\n            if not count&1 and num != even_frequent[1]:\\n                res += 1\\n            elif count&1 and num !=  odd_frequent[1]:\\n                    res += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2323404,
                "title": "python-simple-maths",
                "content": "\\n    def minimumOperations(self, nums):\\n        n = len(nums)\\n        \\n        if len(nums) == 1:\\n            return 0\\n        \\n        dict1 = Counter([j for i, j in enumerate(nums) if i%2 == 0])\\n        dict2 = Counter([j for i, j in enumerate(nums) if i%2 == 1])\\n        even_arr = sorted([(val, key) for key, val in dict1.items()])[::-1]\\n        odd_arr = sorted([(val, key) for key, val in dict2.items()])[::-1]\\n        \\n        if even_arr[0][1] != odd_arr[0][1]:\\n            return n - even_arr[0][0] - odd_arr[0][0]\\n        \\n        if len(even_arr) == 1 and len(odd_arr) == 1:\\n            return min(even_arr[0][0], odd_arr[0][0])\\n        \\n        if len(even_arr) == 1:\\n            return n - even_arr[0][0] - odd_arr[1][0]\\n        \\n        if len(odd_arr) == 1:\\n            return n - odd_arr[0][0] - even_arr[1][0]\\n        \\n        return min(n - even_arr[0][0] - odd_arr[1][0], n - even_arr[1][0] - odd_arr[0][0])",
                "solutionTags": [],
                "code": "\\n    def minimumOperations(self, nums):\\n        n = len(nums)\\n        \\n        if len(nums) == 1:\\n            return 0\\n        \\n        dict1 = Counter([j for i, j in enumerate(nums) if i%2 == 0])\\n        dict2 = Counter([j for i, j in enumerate(nums) if i%2 == 1])\\n        even_arr = sorted([(val, key) for key, val in dict1.items()])[::-1]\\n        odd_arr = sorted([(val, key) for key, val in dict2.items()])[::-1]\\n        \\n        if even_arr[0][1] != odd_arr[0][1]:\\n            return n - even_arr[0][0] - odd_arr[0][0]\\n        \\n        if len(even_arr) == 1 and len(odd_arr) == 1:\\n            return min(even_arr[0][0], odd_arr[0][0])\\n        \\n        if len(even_arr) == 1:\\n            return n - even_arr[0][0] - odd_arr[1][0]\\n        \\n        if len(odd_arr) == 1:\\n            return n - odd_arr[0][0] - even_arr[1][0]\\n        \\n        return min(n - even_arr[0][0] - odd_arr[1][0], n - even_arr[1][0] - odd_arr[0][0])",
                "codeTag": "Python3"
            },
            {
                "id": 2289554,
                "title": "nothing-easier-than-this-beginner-level",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        unordered_map<int,int> first;\\n        unordered_map<int,int> second;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                first[nums[i]] += 1;\\n            }\\n            else{\\n                second[nums[i]] += 1;\\n            }\\n        }\\n        int max_element= 0;\\n        int max_frequency = 0;\\n        \\n        for(auto &itr:first){\\n            if(itr.second>max_frequency){\\n                max_frequency = itr.second;\\n                max_element = itr.first;\\n            }\\n        }\\n        \\n        \\n        int MaxElement = 0;\\n        int MaxFrequent = 0;\\n        \\n        for(auto &itr:second){\\n            if(itr.second>MaxFrequent){\\n                MaxFrequent = itr.second;\\n                MaxElement = itr.first;\\n            }\\n        }\\n        \\n        if(max_element==MaxElement){\\n            \\n            first.erase(max_element);\\n            second.erase(MaxElement);\\n            \\n            int max_element_1= 0;\\n            int max_frequency_1 = 0;\\n        \\n            for(auto &itr:first){\\n                if(itr.second>max_frequency_1){\\n                    max_frequency_1 = itr.second;\\n                    max_element_1 = itr.first;\\n                }\\n            }\\n            \\n            int MaxElement1 = 0;\\n            int MaxFrequent1 = 0;\\n        \\n            for(auto &itr:second){\\n                if(itr.second>MaxFrequent1){\\n                    MaxFrequent1 = itr.second;\\n                    MaxElement1 = itr.first;\\n                }\\n            }\\n            \\n            return min(n-MaxFrequent-max_frequency_1,n-max_frequency-MaxFrequent1);\\n            \\n            \\n        }\\n        else{\\n            return n-MaxFrequent-max_frequency;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        \\n        unordered_map<int,int> first;\\n        unordered_map<int,int> second;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                first[nums[i]] += 1;\\n            }\\n            else{\\n                second[nums[i]] += 1;\\n            }\\n        }\\n        int max_element= 0;\\n        int max_frequency = 0;\\n        \\n        for(auto &itr:first){\\n            if(itr.second>max_frequency){\\n                max_frequency = itr.second;\\n                max_element = itr.first;\\n            }\\n        }\\n        \\n        \\n        int MaxElement = 0;\\n        int MaxFrequent = 0;\\n        \\n        for(auto &itr:second){\\n            if(itr.second>MaxFrequent){\\n                MaxFrequent = itr.second;\\n                MaxElement = itr.first;\\n            }\\n        }\\n        \\n        if(max_element==MaxElement){\\n            \\n            first.erase(max_element);\\n            second.erase(MaxElement);\\n            \\n            int max_element_1= 0;\\n            int max_frequency_1 = 0;\\n        \\n            for(auto &itr:first){\\n                if(itr.second>max_frequency_1){\\n                    max_frequency_1 = itr.second;\\n                    max_element_1 = itr.first;\\n                }\\n            }\\n            \\n            int MaxElement1 = 0;\\n            int MaxFrequent1 = 0;\\n        \\n            for(auto &itr:second){\\n                if(itr.second>MaxFrequent1){\\n                    MaxFrequent1 = itr.second;\\n                    MaxElement1 = itr.first;\\n                }\\n            }\\n            \\n            return min(n-MaxFrequent-max_frequency_1,n-max_frequency-MaxFrequent1);\\n            \\n            \\n        }\\n        else{\\n            return n-MaxFrequent-max_frequency;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250677,
                "title": "follow-this-code-easy-and-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Edge Cases\\n        if(n==1) return 0;\\n        if(n==2 && nums[0]==nums[1]) return 1;\\n        int cnt=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==nums[0])\\n            {\\n                cnt++;\\n            }\\n        }\\n        if(cnt==n) return n/2;\\n        // edge cases over\\n        map<int,int> mp1;  //for even  indices\\n        map<int,int> mp2;  // for odd indices\\n        int cnt1=0,cnt2=0;  // to find out number of even and odd elements\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                mp1[nums[i]]++;\\n                cnt1++;\\n            }else{\\n                mp2[nums[i]]++;\\n                cnt2++;\\n            }\\n        }\\n        \\n        priority_queue<pair<int,int>> pq1;    // for even ones;\\n        priority_queue<pair<int,int>> pq2;    // for odd ones;\\n        for(auto it:mp1){\\n            pq1.push({it.second,it.first});\\n        }\\n        for(auto it:mp2){\\n            pq2.push({it.second,it.first});\\n        }\\n        \\n        \\n        \\n        if(pq1.top().second!=pq2.top().second){\\n            return n-pq1.top().first-pq2.top().first;\\n        }\\n        if(pq1.top().second==pq2.top().second){\\n            int max1=pq1.top().first;\\n            int max2=pq2.top().first;\\n            pq1.pop();\\n            pq2.pop();\\n            int second1 = (pq1.empty()) ? 0 : pq1.top().first;\\n            int second2 = (pq2.empty()) ? 0 : pq2.top().first;\\n            return n - max(max1 + second2, max2 + second1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Edge Cases\\n        if(n==1) return 0;\\n        if(n==2 && nums[0]==nums[1]) return 1;\\n        int cnt=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]==nums[0])\\n            {\\n                cnt++;\\n            }\\n        }\\n        if(cnt==n) return n/2;\\n        // edge cases over\\n        map<int,int> mp1;  //for even  indices\\n        map<int,int> mp2;  // for odd indices\\n        int cnt1=0,cnt2=0;  // to find out number of even and odd elements\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                mp1[nums[i]]++;\\n                cnt1++;\\n            }else{\\n                mp2[nums[i]]++;\\n                cnt2++;\\n            }\\n        }\\n        \\n        priority_queue<pair<int,int>> pq1;    // for even ones;\\n        priority_queue<pair<int,int>> pq2;    // for odd ones;\\n        for(auto it:mp1){\\n            pq1.push({it.second,it.first});\\n        }\\n        for(auto it:mp2){\\n            pq2.push({it.second,it.first});\\n        }\\n        \\n        \\n        \\n        if(pq1.top().second!=pq2.top().second){\\n            return n-pq1.top().first-pq2.top().first;\\n        }\\n        if(pq1.top().second==pq2.top().second){\\n            int max1=pq1.top().first;\\n            int max2=pq2.top().first;\\n            pq1.pop();\\n            pq2.pop();\\n            int second1 = (pq1.empty()) ? 0 : pq1.top().first;\\n            int second2 = (pq2.empty()) ? 0 : pq2.top().first;\\n            return n - max(max1 + second2, max2 + second1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246317,
                "title": "c-hashmap-easy-greedy",
                "content": "Keep check of the **maximum** and **second-maximum frequency** for the **even-indexed** and **odd-indexed** array segments, and if the values for those frequencies match, use the arrangement which has the **maximum total frequency**.\\nDo comment down in case of any queries or remarks.\\n**Please upvote if you find the solution insightful.\\n*Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> odds, evens;\\n        int n = nums.size(), val = 0;\\n        if(n == 1) return 0;\\n        for(int i=0;i<n;i++) {\\n            if(i&1) odds[nums[i]]++;\\n            else evens[nums[i]]++;\\n        }\\n        int max1 = 0, secmax = 0, max2 = 0, secmax2 = 0;\\n        int maxval, secmaxval, max2val, secmax2val = -1;\\n        for(auto &p: odds) {\\n            if(p.second >= max1) {\\n                secmax = max1, max1 = p.second;\\n                maxval = p.first;\\n            }\\n            else if(p.second > secmax) {\\n                secmax = p.second;\\n            }\\n        }\\n        for(auto &p: evens) {\\n            if(p.second >= max2) {\\n                secmax2 = max2, max2 = p.second;\\n                max2val = p.first;\\n            }\\n            else if(p.second > secmax) {\\n                secmax2 = p.second;\\n            }\\n        }\\n        if(maxval == max2val) val = max(max2 + secmax, secmax2 + max1);\\n        else val = max1 + max2;\\n        return n - val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int, int> odds, evens;\\n        int n = nums.size(), val = 0;\\n        if(n == 1) return 0;\\n        for(int i=0;i<n;i++) {\\n            if(i&1) odds[nums[i]]++;\\n            else evens[nums[i]]++;\\n        }\\n        int max1 = 0, secmax = 0, max2 = 0, secmax2 = 0;\\n        int maxval, secmaxval, max2val, secmax2val = -1;\\n        for(auto &p: odds) {\\n            if(p.second >= max1) {\\n                secmax = max1, max1 = p.second;\\n                maxval = p.first;\\n            }\\n            else if(p.second > secmax) {\\n                secmax = p.second;\\n            }\\n        }\\n        for(auto &p: evens) {\\n            if(p.second >= max2) {\\n                secmax2 = max2, max2 = p.second;\\n                max2val = p.first;\\n            }\\n            else if(p.second > secmax) {\\n                secmax2 = p.second;\\n            }\\n        }\\n        if(maxval == max2val) val = max(max2 + secmax, secmax2 + max1);\\n        else val = max1 + max2;\\n        return n - val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238404,
                "title": "keep-track-of-max-and-second-max-for-even-and-odd-using-golang",
                "content": "```go\\nfunc minimumOperations(nums []int) int {\\n  if len(nums) <= 1 {\\n    return 0\\n  }\\n  n := len(nums)\\n  var odds [100001]int\\n  var evens [100001]int\\n  for i := 0; i < len(nums); i++ {\\n    if i%2 == 0 {\\n      evens[nums[i]]++\\n    } else {\\n      odds[nums[i]]++\\n    }\\n  }\\n  // Note that we don\\'t actually need to keep track of secondMaxEven and secondMaxOdd\\n  // We do however need the maxEven and maxOdd so we can check if they are not the same\\n  var maxEven, maxEvenCount int\\n  var maxOdd, maxOddCount int\\n  var secondMaxEvenCount, secondMaxOddCount int\\n  for i := 0; i < 100001; i++ {\\n    if evens[i] >= maxEvenCount {\\n      secondMaxEvenCount = maxEvenCount\\n      maxEvenCount = evens[i]\\n      maxEven = i\\n    } else if evens[i] >= secondMaxEvenCount {\\n      secondMaxEvenCount = evens[i]\\n    }\\n    if odds[i] >= maxOddCount {\\n      secondMaxOddCount = maxOddCount\\n      maxOddCount = odds[i]\\n      maxOdd = i\\n    } else if odds[i] >= secondMaxOddCount {\\n      secondMaxOddCount = odds[i]\\n    }\\n  }\\n  if maxEven != maxOdd {\\n    return (n+1)/2 - maxEvenCount + n/2 - maxOddCount\\n  } \\n  return min(\\n    (n+1)/2 - maxEvenCount + n/2 - secondMaxOddCount,  // we keep maxEven\\n    (n+1)/2 - secondMaxEvenCount + n/2 - maxOddCount,  // we keep maxOdd\\n  )\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimumOperations(nums []int) int {\\n  if len(nums) <= 1 {\\n    return 0\\n  }\\n  n := len(nums)\\n  var odds [100001]int\\n  var evens [100001]int\\n  for i := 0; i < len(nums); i++ {\\n    if i%2 == 0 {\\n      evens[nums[i]]++\\n    } else {\\n      odds[nums[i]]++\\n    }\\n  }\\n  // Note that we don\\'t actually need to keep track of secondMaxEven and secondMaxOdd\\n  // We do however need the maxEven and maxOdd so we can check if they are not the same\\n  var maxEven, maxEvenCount int\\n  var maxOdd, maxOddCount int\\n  var secondMaxEvenCount, secondMaxOddCount int\\n  for i := 0; i < 100001; i++ {\\n    if evens[i] >= maxEvenCount {\\n      secondMaxEvenCount = maxEvenCount\\n      maxEvenCount = evens[i]\\n      maxEven = i\\n    } else if evens[i] >= secondMaxEvenCount {\\n      secondMaxEvenCount = evens[i]\\n    }\\n    if odds[i] >= maxOddCount {\\n      secondMaxOddCount = maxOddCount\\n      maxOddCount = odds[i]\\n      maxOdd = i\\n    } else if odds[i] >= secondMaxOddCount {\\n      secondMaxOddCount = odds[i]\\n    }\\n  }\\n  if maxEven != maxOdd {\\n    return (n+1)/2 - maxEvenCount + n/2 - maxOddCount\\n  } \\n  return min(\\n    (n+1)/2 - maxEvenCount + n/2 - secondMaxOddCount,  // we keep maxEven\\n    (n+1)/2 - secondMaxEvenCount + n/2 - maxOddCount,  // we keep maxOdd\\n  )\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217563,
                "title": "c-greedy-map",
                "content": "\\n     class Solution {\\n     public:\\n \\n        int minimumOperations(vector<int>& nums) {\\n\\t \\n\\t\\t\\tif(nums.size() == 1)return 0;\\n\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tunordered_map<int ,int> mp1 , mp2;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t(i&1) ? mp1[nums[i]]++ : mp2[nums[i]]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<pair<int ,int>> vp1 ,vp2;\\n\\t\\t\\tfor(auto it : mp1)vp1.push_back({it.second , it.first});\\n\\t\\t\\tfor(auto it : mp2)vp2.push_back({it.second , it.first});\\n\\t\\t\\tsort(vp1.begin() , vp1.end());sort(vp2.begin() , vp2.end());\\n\\n\\t\\t\\tint num1  = vp1[vp1.size() - 1].second , freq1 = vp1[vp1.size() - 1].first; \\n\\t\\t\\tint num2  = vp2[vp2.size() - 1].second , freq2 = vp2[vp2.size() - 1].first;\\n\\n\\t\\t\\tif(num1 == num2){\\n\\t\\t\\t\\tif(vp1.size() == 1 && vp2.size() == 1){\\n\\t\\t\\t\\t\\t  return n/2;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse if(vp1.size() == 1){\\n\\t\\t\\t\\t\\t int ans2 = vp2[vp2.size() - 2].first;\\n\\t\\t\\t\\t\\t return n - freq1 - ans2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(vp2.size() == 1){\\n\\t\\t\\t\\t\\t int ans1 = vp1[vp1.size() - 2].first;\\n\\t\\t\\t\\t\\t return n - freq2 - ans1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t int ans1 = vp1[vp1.size() - 2].first;\\n\\t\\t\\t\\t\\t int ans2 = vp2[vp2.size() - 2].first;         \\n\\t\\t\\t\\t\\t return min( n - freq1 - ans2 , n - freq2 - ans1 ); \\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn n - freq1 - freq2;\\n\\t\\t\\t}\\n\\t\\t}  \\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n     public:\\n \\n        int minimumOperations(vector<int>& nums) {\\n\\t \\n\\t\\t\\tif(nums.size() == 1)return 0;\\n\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tunordered_map<int ,int> mp1 , mp2;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t(i&1) ? mp1[nums[i]]++ : mp2[nums[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2217089,
                "title": "c-solution-without-map",
                "content": "```\\npublic:\\n   int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int oddfreq[100001]={0};\\n        int evenfreq[100001]={0};\\n        \\n        int OddMaxfreq=0 , OddMax=INT_MIN;\\n        int OddSecondMaxfreq=0 , OddSecondMax=INT_MIN;\\n        \\n        for(int i=1; i<n; i+=2)\\n            oddfreq[nums[i]]++;\\n       \\n        for(int i=0; i<100001; i++){\\n            if(oddfreq[i]>OddMaxfreq){\\n                OddMaxfreq=oddfreq[i];\\n                OddMax=i;\\n            }\\n        }\\n       for(int i=0; i<100001; i++){\\n            if(oddfreq[i]>OddSecondMaxfreq && i!=OddMax){\\n                OddSecondMaxfreq=oddfreq[i];\\n                OddSecondMax=i;\\n            }\\n        }\\n        \\n        int EvenMaxfreq=0 , EvenMax=INT_MIN;\\n        int EvenSecondMaxfreq=0 , EvenSecondMax=INT_MIN;\\n        \\n        for(int i=0; i<n; i+=2)\\n            evenfreq[nums[i]]++;\\n       \\n        for(int i=0; i<100001; i++){\\n            if(evenfreq[i]>EvenMaxfreq){\\n                EvenMaxfreq=evenfreq[i];\\n                EvenMax=i;\\n            }\\n        }\\n        for(int i=0; i<100001; i++){\\n            if((evenfreq[i]>EvenSecondMaxfreq) && i!=EvenMax){\\n                EvenSecondMaxfreq=evenfreq[i];\\n                EvenSecondMax=i;\\n            }\\n        }\\n        if(OddMax!=EvenMax)\\n            return n-OddMaxfreq-EvenMaxfreq;\\n        return min(n-OddMaxfreq-EvenSecondMaxfreq , n-OddSecondMaxfreq-EvenMaxfreq);\\n    }\\n```\\nin this solution i tried to record the frequency of elements present at even and odd position or indexes and try to check heightest frquency element on even and odd position now if the differ than convert all the elements to heighest frequency element , but if they match then go for second heighest frequency element and do the same :)",
                "solutionTags": [],
                "code": "```\\npublic:\\n   int minimumOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int oddfreq[100001]={0};\\n        int evenfreq[100001]={0};\\n        \\n        int OddMaxfreq=0 , OddMax=INT_MIN;\\n        int OddSecondMaxfreq=0 , OddSecondMax=INT_MIN;\\n        \\n        for(int i=1; i<n; i+=2)\\n            oddfreq[nums[i]]++;\\n       \\n        for(int i=0; i<100001; i++){\\n            if(oddfreq[i]>OddMaxfreq){\\n                OddMaxfreq=oddfreq[i];\\n                OddMax=i;\\n            }\\n        }\\n       for(int i=0; i<100001; i++){\\n            if(oddfreq[i]>OddSecondMaxfreq && i!=OddMax){\\n                OddSecondMaxfreq=oddfreq[i];\\n                OddSecondMax=i;\\n            }\\n        }\\n        \\n        int EvenMaxfreq=0 , EvenMax=INT_MIN;\\n        int EvenSecondMaxfreq=0 , EvenSecondMax=INT_MIN;\\n        \\n        for(int i=0; i<n; i+=2)\\n            evenfreq[nums[i]]++;\\n       \\n        for(int i=0; i<100001; i++){\\n            if(evenfreq[i]>EvenMaxfreq){\\n                EvenMaxfreq=evenfreq[i];\\n                EvenMax=i;\\n            }\\n        }\\n        for(int i=0; i<100001; i++){\\n            if((evenfreq[i]>EvenSecondMaxfreq) && i!=EvenMax){\\n                EvenSecondMaxfreq=evenfreq[i];\\n                EvenSecondMax=i;\\n            }\\n        }\\n        if(OddMax!=EvenMax)\\n            return n-OddMaxfreq-EvenMaxfreq;\\n        return min(n-OddMaxfreq-EvenSecondMaxfreq , n-OddSecondMaxfreq-EvenMaxfreq);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2208784,
                "title": "67",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums)<=1:\\n            return 0\\n        o={}\\n        odd=0\\n        even=0\\n        e={}\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                if nums[i] not in e.keys():\\n                    e[nums[i]]=0\\n                e[nums[i]]+=1\\n                even+=1\\n            else:\\n                if nums[i] not in o.keys():\\n                    o[nums[i]]=0\\n                o[nums[i]]+=1\\n                odd+=1\\n        \\n        om=list(o.items())\\n        em=list(e.items())\\n        om.append((0,0))\\n        em.append((0,0))\\n        om.sort(key=lambda a:a[1])\\n        em.sort(key=lambda a:a[1])\\n        ans=0\\n        if om[-1][0]!=em[-1][0]:\\n            ans+=(odd-om[-1][1])\\n            ans+=(even-em[-1][1])\\n        else:\\n            if om[-2][1]+em[-1][1]>=om[-1][1]+em[-2][1]:\\n                ans+=(odd-om[-2][1])\\n                ans+=(even-em[-1][1])\\n            else:\\n                ans+=(odd-om[-1][1])\\n                ans+=(even-em[-2][1])\\n                \\n        return(ans)\\n```\\nPlease Upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums)<=1:\\n            return 0\\n        o={}\\n        odd=0\\n        even=0\\n        e={}\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                if nums[i] not in e.keys():\\n                    e[nums[i]]=0\\n                e[nums[i]]+=1\\n                even+=1\\n            else:\\n                if nums[i] not in o.keys():\\n                    o[nums[i]]=0\\n                o[nums[i]]+=1\\n                odd+=1\\n        \\n        om=list(o.items())\\n        em=list(e.items())\\n        om.append((0,0))\\n        em.append((0,0))\\n        om.sort(key=lambda a:a[1])\\n        em.sort(key=lambda a:a[1])\\n        ans=0\\n        if om[-1][0]!=em[-1][0]:\\n            ans+=(odd-om[-1][1])\\n            ans+=(even-em[-1][1])\\n        else:\\n            if om[-2][1]+em[-1][1]>=om[-1][1]+em[-2][1]:\\n                ans+=(odd-om[-2][1])\\n                ans+=(even-em[-1][1])\\n            else:\\n                ans+=(odd-om[-1][1])\\n                ans+=(even-em[-2][1])\\n                \\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206369,
                "title": "hash-map-and-priority-queue-sol-o-n",
                "content": "```\\n int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        int n=nums.size();\\n        unordered_map<int,int> m1;\\n        unordered_map<int,int> m2;\\n        int c1=0,c2=0;\\n        for(int i=0;i<n;i+=2){\\n            m1[nums[i]]++;c1++;\\n        } \\n        for(int i=1;i<nums.size();i+=2){\\n            m2[nums[i]]++;c2++;\\n        } \\n        priority_queue<pair<int,int>> p1;\\n        priority_queue<pair<int,int>> p2;\\n        for(auto& x: m1) p1.push({x.second,x.first});\\n        for(auto& x: m2) p2.push({x.second,x.first});\\n        auto k1=p1.top();auto k2=p2.top();\\n        int res=INT_MAX;\\n        if(k1.second!=k2.second){\\n            res=min(res,(c1-k1.first)+c2-k2.first);\\n        }\\n        else{\\n            if(p1.size()==1 and p2.size()==1) return n/2;\\n            p1.pop();\\n            if(p1.size()) res=min(res,(c1-p1.top().first)+c2-p2.top().first);\\n            p1.push(k1);\\n            p2.pop();\\n            if(p2.size()) res=min(res,(c1-p1.top().first)+c2-p2.top().first);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1) return 0;\\n        int n=nums.size();\\n        unordered_map<int,int> m1;\\n        unordered_map<int,int> m2;\\n        int c1=0,c2=0;\\n        for(int i=0;i<n;i+=2){\\n            m1[nums[i]]++;c1++;\\n        } \\n        for(int i=1;i<nums.size();i+=2){\\n            m2[nums[i]]++;c2++;\\n        } \\n        priority_queue<pair<int,int>> p1;\\n        priority_queue<pair<int,int>> p2;\\n        for(auto& x: m1) p1.push({x.second,x.first});\\n        for(auto& x: m2) p2.push({x.second,x.first});\\n        auto k1=p1.top();auto k2=p2.top();\\n        int res=INT_MAX;\\n        if(k1.second!=k2.second){\\n            res=min(res,(c1-k1.first)+c2-k2.first);\\n        }\\n        else{\\n            if(p1.size()==1 and p2.size()==1) return n/2;\\n            p1.pop();\\n            if(p1.size()) res=min(res,(c1-p1.top().first)+c2-p2.top().first);\\n            p1.push(k1);\\n            p2.pop();\\n            if(p2.size()) res=min(res,(c1-p1.top().first)+c2-p2.top().first);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2192000,
                "title": "python-defaultdict-faster-than-86",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, x: List[int]) -> int:\\n        l=len(x)\\n        if l<=1:return 0\\n        e=o=0\\n        ed=defaultdict(int)\\n        od=defaultdict(int)\\n        for i in range(l):\\n            if i%2==0:\\n                e+=1\\n                ed[x[i]]+=1\\n            else:\\n                o+=1\\n                od[x[i]]+=1\\n        ed=sorted(ed.items(),key=lambda i:i[1],reverse=True)[:2]\\n        od=sorted(od.items(),key=lambda i:i[1],reverse=True)[:2]\\n        if ed[0][0]!=od[0][0]:\\n            return e-ed[0][1]+o-od[0][1]\\n        if len(ed)==len(od)==1:\\n            return min(e,o)\\n        elif len(ed)==len(od)==2:    \\n            return min(e-ed[0][1]+o-od[1][1],e-ed[1][1]+o-od[0][1])\\n        elif len(ed)==1 and len(od)==2:\\n            return o-od[1][1]\\n        return e-ed[1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, x: List[int]) -> int:\\n        l=len(x)\\n        if l<=1:return 0\\n        e=o=0\\n        ed=defaultdict(int)\\n        od=defaultdict(int)\\n        for i in range(l):\\n            if i%2==0:\\n                e+=1\\n                ed[x[i]]+=1\\n            else:\\n                o+=1\\n                od[x[i]]+=1\\n        ed=sorted(ed.items(),key=lambda i:i[1],reverse=True)[:2]\\n        od=sorted(od.items(),key=lambda i:i[1],reverse=True)[:2]\\n        if ed[0][0]!=od[0][0]:\\n            return e-ed[0][1]+o-od[0][1]\\n        if len(ed)==len(od)==1:\\n            return min(e,o)\\n        elif len(ed)==len(od)==2:    \\n            return min(e-ed[0][1]+o-od[1][1],e-ed[1][1]+o-od[0][1])\\n        elif len(ed)==1 and len(od)==2:\\n            return o-od[1][1]\\n        return e-ed[1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187323,
                "title": "c-hashmaps-most-frequent-and-second-most-highest-frequent-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n       vector<int> v1,v2;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                v1.push_back(nums[i]);\\n            }\\n            else{\\n                v2.push_back(nums[i]);\\n            }\\n        }\\n        \\n        map<int,int> mp1,mp2;\\n        for(auto it:v1){\\n            mp1[it]++;\\n        }\\n        for(auto it:v2){\\n            mp2[it]++;\\n        }\\n        int mx1=INT_MIN,ele1;\\n        int mx2=INT_MIN,ele2;\\n        for(auto it:mp1){\\n            if(it.second>=mx1){\\n                mx1=it.second;\\n                ele1=it.first;\\n            }\\n        }\\n         for(auto it:mp2){\\n            if(it.second>=mx2){\\n                mx2=it.second;\\n                ele2=it.first;\\n            }\\n        }\\n        cout<<ele1<<\" \"<<ele2<<endl;\\n        if(ele1!=ele2){\\n            int sum=0;\\n            for(auto it:mp1){\\n                if(it.first!=ele1)\\n                    sum+=it.second;\\n            }\\n            for(auto it:mp2){\\n                if(it.first!=ele2)\\n                    sum+=it.second;\\n            }\\n            return sum;\\n        }\\n        int s1=0;\\n        //first find second higest element of mp2\\n        if(mp2.size()==1){\\n            //no second highest element exists\\n            s1=v2.size();\\n        }\\n        else if(mp2.size()>1){\\n            int oo=INT_MIN;\\n            int pp;\\n            for(auto it:mp2){\\n                if(it.first!=ele1){\\n                    if(it.second>=oo){\\n                        oo=it.second;\\n                        pp=it.first;\\n                    }\\n                }\\n            }\\n           \\n            //now replace all the lements in v2 with pp\\n            for(auto it:mp2){\\n                if(it.first!=pp){\\n                    s1+=it.second;\\n                }\\n            }\\n\\t\\t\\t//also change all elements in v1 which are not equal to ele1 \\n            for(auto it:mp1){\\n                if(it.first!=ele1){\\n                    s1+=it.second;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int s2=0;\\n        //second find second highest element of mp1\\n          if(mp1.size()==1){\\n            //no second highest element exists\\n            s2=v1.size();\\n        }\\n        else if(mp1.size()>1){\\n            int oo=INT_MIN;\\n            int pp;\\n            for(auto it:mp1){\\n                if(it.first!=ele2){\\n                    if(it.second>=oo){\\n                        oo=it.second;\\n                        pp=it.first;\\n                    }\\n                }\\n            }\\n            //now replace all the lements in v1 with pp\\n            for(auto it:mp1){\\n                if(it.first!=pp){\\n                    s2+=it.second;\\n                }\\n            } \\n            for(auto it:mp2){\\n                if(it.first!=ele2){\\n                    s2+=it.second;\\n                }\\n            }\\n        }  \\n        return min(s1,s2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return 0;\\n        }\\n       vector<int> v1,v2;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                v1.push_back(nums[i]);\\n            }\\n            else{\\n                v2.push_back(nums[i]);\\n            }\\n        }\\n        \\n        map<int,int> mp1,mp2;\\n        for(auto it:v1){\\n            mp1[it]++;\\n        }\\n        for(auto it:v2){\\n            mp2[it]++;\\n        }\\n        int mx1=INT_MIN,ele1;\\n        int mx2=INT_MIN,ele2;\\n        for(auto it:mp1){\\n            if(it.second>=mx1){\\n                mx1=it.second;\\n                ele1=it.first;\\n            }\\n        }\\n         for(auto it:mp2){\\n            if(it.second>=mx2){\\n                mx2=it.second;\\n                ele2=it.first;\\n            }\\n        }\\n        cout<<ele1<<\" \"<<ele2<<endl;\\n        if(ele1!=ele2){\\n            int sum=0;\\n            for(auto it:mp1){\\n                if(it.first!=ele1)\\n                    sum+=it.second;\\n            }\\n            for(auto it:mp2){\\n                if(it.first!=ele2)\\n                    sum+=it.second;\\n            }\\n            return sum;\\n        }\\n        int s1=0;\\n        //first find second higest element of mp2\\n        if(mp2.size()==1){\\n            //no second highest element exists\\n            s1=v2.size();\\n        }\\n        else if(mp2.size()>1){\\n            int oo=INT_MIN;\\n            int pp;\\n            for(auto it:mp2){\\n                if(it.first!=ele1){\\n                    if(it.second>=oo){\\n                        oo=it.second;\\n                        pp=it.first;\\n                    }\\n                }\\n            }\\n           \\n            //now replace all the lements in v2 with pp\\n            for(auto it:mp2){\\n                if(it.first!=pp){\\n                    s1+=it.second;\\n                }\\n            }\\n\\t\\t\\t//also change all elements in v1 which are not equal to ele1 \\n            for(auto it:mp1){\\n                if(it.first!=ele1){\\n                    s1+=it.second;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        int s2=0;\\n        //second find second highest element of mp1\\n          if(mp1.size()==1){\\n            //no second highest element exists\\n            s2=v1.size();\\n        }\\n        else if(mp1.size()>1){\\n            int oo=INT_MIN;\\n            int pp;\\n            for(auto it:mp1){\\n                if(it.first!=ele2){\\n                    if(it.second>=oo){\\n                        oo=it.second;\\n                        pp=it.first;\\n                    }\\n                }\\n            }\\n            //now replace all the lements in v1 with pp\\n            for(auto it:mp1){\\n                if(it.first!=pp){\\n                    s2+=it.second;\\n                }\\n            } \\n            for(auto it:mp2){\\n                if(it.first!=ele2){\\n                    s2+=it.second;\\n                }\\n            }\\n        }  \\n        return min(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2183803,
                "title": "c-using-dictionary-all-conditions",
                "content": "```\\n        public int MinimumOperations(int[] nums)\\n        {\\n            if (nums.Length <= 1) return 0;//special case\\n            Dictionary<int, int> evenDict = new Dictionary<int, int>();//frequencies of all elements at even-index\\n            Dictionary<int, int> oddDict = new Dictionary<int, int>();//frequencies of all elements at odd-index\\n            for (int i = 0; i < nums.Length; ++i)\\n            {\\n                if (i % 2 == 0)\\n                {\\n                    if (evenDict.ContainsKey(nums[i])) evenDict[nums[i]]++;\\n                    else evenDict.Add(nums[i], 1);\\n                }\\n                else\\n                {\\n                    if (oddDict.ContainsKey(nums[i])) oddDict[nums[i]]++;\\n                    else oddDict.Add(nums[i], 1);\\n                }\\n            }\\n            int lenOfEven = (nums.Length + 1) / 2;//count of even-index elements\\n            int lenOfOdd = nums.Length - lenOfEven;//count of odd-index elements\\n            var evenKeys = evenDict.Keys.OrderBy(x => -evenDict[x]).ToList();//sort by highest frequencies on even-index\\n            var oddKeys = oddDict.Keys.OrderBy(x => -oddDict[x]).ToList();//sort by highest frequencies on even-index\\n            int res = int.MaxValue;\\n            if(evenKeys.Count==1 && oddKeys.Count == 1)\\n            {\\n\\t\\t\\t    //when all elements are same, due to lenOfEven must >=lenOfOdd, replace all odds to another value\\n                if (evenKeys[0] == oddKeys[0]) res = oddDict[oddKeys[0]];\\n                else res = 0;//no need to change anyone\\n            }\\n            else if (evenKeys.Count == 1 || oddKeys.Count==1)\\n            {\\n                if (evenKeys.Count == 1)\\n                {\\n\\t\\t\\t\\t\\t//all evens are same\\n                    if (evenKeys[0] == oddKeys[0]) res = lenOfOdd - oddDict[oddKeys[1]];//replace all odds to the 2nd frequency num--oddKeys[1]\\n                    else res = lenOfOdd - oddDict[oddKeys[0]];//replace all odds to the 1st frequency num--oddKeys[0]\\n                }\\n                else\\n                {\\n\\t\\t\\t\\t\\t//all odds are same\\n\\t\\t\\t\\t\\t//if 1st even is same to 1st odd,  min of (replace all evens to 1st even-evenKeys[0] and replace all odds to another number)\\n\\t\\t\\t\\t\\t//                                                          vs (replace all evens to 2st even-evenKeys[1])\\n                    if (evenKeys[0] == oddKeys[0]) res = Math.Min(lenOfEven - evenDict[evenKeys[0]] + lenOfOdd, lenOfEven - evenDict[evenKeys[1]]);\\n                    else res = lenOfEven - evenDict[evenKeys[0]];//1st even is not  same to 1st odd, replace all evens to 2st even-evenKeys[1]\\n                }\\n            }\\n            else\\n            {\\n                if (evenKeys[0] == oddKeys[0])\\n                {\\n\\t\\t\\t\\t   //min of change to {1st-even, 2nd-odd} or {2nd-even, 1st-odd} \\n                    res = Math.Min(lenOfEven - evenDict[evenKeys[0]] + lenOfOdd - oddDict[oddKeys[1]],\\n                                    lenOfEven - evenDict[evenKeys[1]] + lenOfOdd - oddDict[oddKeys[0]]);\\n                }\\n                else\\n                {\\n\\t\\t\\t\\t    //change to {1st-even, 1st-odd} \\n                    res=lenOfEven- evenDict[evenKeys[0]] + lenOfOdd - oddDict[oddKeys[0]];\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MinimumOperations(int[] nums)\\n        {\\n            if (nums.Length <= 1) return 0;//special case\\n            Dictionary<int, int> evenDict = new Dictionary<int, int>();//frequencies of all elements at even-index\\n            Dictionary<int, int> oddDict = new Dictionary<int, int>();//frequencies of all elements at odd-index\\n            for (int i = 0; i < nums.Length; ++i)\\n            {\\n                if (i % 2 == 0)\\n                {\\n                    if (evenDict.ContainsKey(nums[i])) evenDict[nums[i]]++;\\n                    else evenDict.Add(nums[i], 1);\\n                }\\n                else\\n                {\\n                    if (oddDict.ContainsKey(nums[i])) oddDict[nums[i]]++;\\n                    else oddDict.Add(nums[i], 1);\\n                }\\n            }\\n            int lenOfEven = (nums.Length + 1) / 2;//count of even-index elements\\n            int lenOfOdd = nums.Length - lenOfEven;//count of odd-index elements\\n            var evenKeys = evenDict.Keys.OrderBy(x => -evenDict[x]).ToList();//sort by highest frequencies on even-index\\n            var oddKeys = oddDict.Keys.OrderBy(x => -oddDict[x]).ToList();//sort by highest frequencies on even-index\\n            int res = int.MaxValue;\\n            if(evenKeys.Count==1 && oddKeys.Count == 1)\\n            {\\n\\t\\t\\t    //when all elements are same, due to lenOfEven must >=lenOfOdd, replace all odds to another value\\n                if (evenKeys[0] == oddKeys[0]) res = oddDict[oddKeys[0]];\\n                else res = 0;//no need to change anyone\\n            }\\n            else if (evenKeys.Count == 1 || oddKeys.Count==1)\\n            {\\n                if (evenKeys.Count == 1)\\n                {\\n\\t\\t\\t\\t\\t//all evens are same\\n                    if (evenKeys[0] == oddKeys[0]) res = lenOfOdd - oddDict[oddKeys[1]];//replace all odds to the 2nd frequency num--oddKeys[1]\\n                    else res = lenOfOdd - oddDict[oddKeys[0]];//replace all odds to the 1st frequency num--oddKeys[0]\\n                }\\n                else\\n                {\\n\\t\\t\\t\\t\\t//all odds are same\\n\\t\\t\\t\\t\\t//if 1st even is same to 1st odd,  min of (replace all evens to 1st even-evenKeys[0] and replace all odds to another number)\\n\\t\\t\\t\\t\\t//                                                          vs (replace all evens to 2st even-evenKeys[1])\\n                    if (evenKeys[0] == oddKeys[0]) res = Math.Min(lenOfEven - evenDict[evenKeys[0]] + lenOfOdd, lenOfEven - evenDict[evenKeys[1]]);\\n                    else res = lenOfEven - evenDict[evenKeys[0]];//1st even is not  same to 1st odd, replace all evens to 2st even-evenKeys[1]\\n                }\\n            }\\n            else\\n            {\\n                if (evenKeys[0] == oddKeys[0])\\n                {\\n\\t\\t\\t\\t   //min of change to {1st-even, 2nd-odd} or {2nd-even, 1st-odd} \\n                    res = Math.Min(lenOfEven - evenDict[evenKeys[0]] + lenOfOdd - oddDict[oddKeys[1]],\\n                                    lenOfEven - evenDict[evenKeys[1]] + lenOfOdd - oddDict[oddKeys[0]]);\\n                }\\n                else\\n                {\\n\\t\\t\\t\\t    //change to {1st-even, 1st-odd} \\n                    res=lenOfEven- evenDict[evenKeys[0]] + lenOfOdd - oddDict[oddKeys[0]];\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150358,
                "title": "python-easy-o-n-time-and-space-solution-using-greedy-approach",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        #if we think of greedy approach as ultimatly all the odd indices will have same value\\n        #and all the even indices will have the same value that is not same as the odd value\\n        if len(nums) == 1:\\n            return 0\\n        oddMap = {}\\n        evenMap = {}\\n        oddMap[-1] = 0\\n        evenMap[-1] = 0\\n        for i in range(0,len(nums),2):\\n            if nums[i] in oddMap:\\n                oddMap[nums[i]] += 1\\n            else:\\n                oddMap[nums[i]] = 1\\n        for i in range(1,len(nums),2):\\n            if nums[i] in evenMap:\\n                evenMap[nums[i]] += 1\\n            else:\\n                evenMap[nums[i]] = 1\\n        maxOdd = -1\\n        maxOdd2 = -1\\n        for i in oddMap:\\n            if maxOdd == -1:\\n                maxOdd = i\\n            elif maxOdd2 == -1:\\n                maxOdd2 = i\\n            if oddMap[maxOdd] < oddMap[i]:\\n                maxOdd2 = maxOdd\\n                maxOdd = i\\n            else:\\n                if maxOdd2 != -1 and oddMap[maxOdd2] <= oddMap[i]:\\n                    maxOdd2 = i\\n        maxEven = -1\\n        maxEven2 = -1\\n        for i in evenMap:\\n            if maxEven == -1:\\n                maxEven = i\\n            elif maxEven2 == -1:\\n                maxEven2 = i\\n            if evenMap[maxEven] < evenMap[i]:\\n                maxEven2 = maxEven\\n                maxEven = i\\n            else:\\n                if maxEven2 != -1 and evenMap[maxEven2] <= evenMap[i]:\\n                    maxEven2 = i\\n        if maxEven != maxOdd:\\n            return len(nums) - evenMap[maxEven] - oddMap[maxOdd]\\n        else:\\n            return min(len(nums)-evenMap[maxEven]-oddMap[maxOdd2],len(nums)-evenMap[maxEven2]-oddMap[maxOdd])\\n        \\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        #if we think of greedy approach as ultimatly all the odd indices will have same value\\n        #and all the even indices will have the same value that is not same as the odd value\\n        if len(nums) == 1:\\n            return 0\\n        oddMap = {}",
                "codeTag": "Java"
            },
            {
                "id": 2075441,
                "title": "c-easy-solution-in-o-n",
                "content": "```\\n int minimumOperations(vector<int> &nums)\\n{\\n    int ans = 0, sum = 0;\\n    map<int, int> mp, mp1;\\n    int n = nums.size();\\n    if (n == 1)\\n        return 0;\\n    for (int i = 0; i < n; i += 2)\\n    {\\n        mp[nums[i]]++;\\n    }\\n    for (int j = 1; j < n; j += 2)\\n    {\\n        mp1[nums[j]]++;\\n    }\\n    vector<int> res;\\n    for (auto it : mp)\\n    {\\n        if (it.second > ans)\\n        {\\n            res.clear();\\n            res.push_back(it.first);\\n            ans = it.second;\\n        }\\n        else if (it.second == ans)\\n            res.push_back(it.first);\\n    }\\n    vector<int> sol;\\n    for (auto it : mp1)\\n    {\\n        if (it.second > sum)\\n        {\\n            sol.clear();\\n            sol.push_back(it.first);\\n            sum = it.second;\\n        }\\n        else if (it.second == sum)\\n            sol.push_back(it.first);\\n    }\\n    if ((res.size() > 1 || sol.size() > 1) || res[0] != sol[0])\\n        return n - ans - sum;\\n    else\\n    {\\n        int y = sol[0], m = INT_MAX;\\n        int a=ans,b=sum;\\n        sol.clear();\\n        sum = 0;\\n        for (auto it : mp1)\\n        {\\n            if (it.first == y)\\n                continue;\\n            if (it.second > sum)\\n            {\\n                sol.clear();\\n                sol.push_back(it.first);\\n                sum = it.second;\\n            }\\n            else if (it.second == sum)\\n                sol.push_back(it.first);\\n        }\\n        m = min(m, n - a - sum);\\n        res.clear();\\n        ans = 0;\\n        for (auto it : mp)\\n        {\\n            if (it.first == y)\\n                continue;\\n            if (it.second > ans)\\n            {\\n                res.clear();\\n                res.push_back(it.first);\\n                ans = it.second;\\n            }\\n            else if (it.second == ans)\\n                res.push_back(it.first);\\n        }\\n        m = min(m, n - ans - b);\\n        return m;\\n    }\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int minimumOperations(vector<int> &nums)\\n{\\n    int ans = 0, sum = 0;\\n    map<int, int> mp, mp1;\\n    int n = nums.size();\\n    if (n == 1)\\n        return 0;\\n    for (int i = 0; i < n; i += 2)\\n    {\\n        mp[nums[i]]++;\\n    }\\n    for (int j = 1; j < n; j += 2)\\n    {\\n        mp1[nums[j]]++;\\n    }\\n    vector<int> res;\\n    for (auto it : mp)\\n    {\\n        if (it.second > ans)\\n        {\\n            res.clear();\\n            res.push_back(it.first);\\n            ans = it.second;\\n        }\\n        else if (it.second == ans)\\n            res.push_back(it.first);\\n    }\\n    vector<int> sol;\\n    for (auto it : mp1)\\n    {\\n        if (it.second > sum)\\n        {\\n            sol.clear();\\n            sol.push_back(it.first);\\n            sum = it.second;\\n        }\\n        else if (it.second == sum)\\n            sol.push_back(it.first);\\n    }\\n    if ((res.size() > 1 || sol.size() > 1) || res[0] != sol[0])\\n        return n - ans - sum;\\n    else\\n    {\\n        int y = sol[0], m = INT_MAX;\\n        int a=ans,b=sum;\\n        sol.clear();\\n        sum = 0;\\n        for (auto it : mp1)\\n        {\\n            if (it.first == y)\\n                continue;\\n            if (it.second > sum)\\n            {\\n                sol.clear();\\n                sol.push_back(it.first);\\n                sum = it.second;\\n            }\\n            else if (it.second == sum)\\n                sol.push_back(it.first);\\n        }\\n        m = min(m, n - a - sum);\\n        res.clear();\\n        ans = 0;\\n        for (auto it : mp)\\n        {\\n            if (it.first == y)\\n                continue;\\n            if (it.second > ans)\\n            {\\n                res.clear();\\n                res.push_back(it.first);\\n                ans = it.second;\\n            }\\n            else if (it.second == ans)\\n                res.push_back(it.first);\\n        }\\n        m = min(m, n - ans - b);\\n        return m;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2051748,
                "title": "simple-java-o-n-solution-which-beats-100",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int maxOdd = 0,maxEven=0,max=0;\\n        int n= nums.length;\\n        for(int i=0;i<n;i++)max= Math.max(max,nums[i]);\\n        int even[]=new int[max+1];\\n        int odd[]=new int[max+1];\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)even[nums[i]]++;\\n            else odd[nums[i]]++;\\n        }\\n        int t1=0,t2=0;\\n        for(int i=0;i<max+1;i++){\\n            if(even[i]>maxEven){\\n                maxEven=even[i];t1=i;\\n            }\\n            if(odd[i]>maxOdd){\\n                maxOdd=odd[i];t2=i;\\n            }\\n        }\\n        int ans=0;\\n        if(t1==t2){\\n            int secondEven=0,secondOdd=0;\\n            for(int i=0;i<max+1;i++){\\n                if(i!=t1 && even[i]>secondEven)secondEven=even[i];\\n                if(i!=t2 && odd[i]>secondOdd)secondOdd=odd[i];\\n            }\\n            ans = Math.min((n/2+n%2-maxEven)+ (n/2-secondOdd),(n/2+n%2-secondEven)+(n/2-maxOdd));\\n        }\\n        else{\\n            ans = ((n/2+n%2)-maxEven)+ ((n/2)-maxOdd);  \\n        } \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        int maxOdd = 0,maxEven=0,max=0;\\n        int n= nums.length;\\n        for(int i=0;i<n;i++)max= Math.max(max,nums[i]);\\n        int even[]=new int[max+1];\\n        int odd[]=new int[max+1];\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)even[nums[i]]++;\\n            else odd[nums[i]]++;\\n        }\\n        int t1=0,t2=0;\\n        for(int i=0;i<max+1;i++){\\n            if(even[i]>maxEven){\\n                maxEven=even[i];t1=i;\\n            }\\n            if(odd[i]>maxOdd){\\n                maxOdd=odd[i];t2=i;\\n            }\\n        }\\n        int ans=0;\\n        if(t1==t2){\\n            int secondEven=0,secondOdd=0;\\n            for(int i=0;i<max+1;i++){\\n                if(i!=t1 && even[i]>secondEven)secondEven=even[i];\\n                if(i!=t2 && odd[i]>secondOdd)secondOdd=odd[i];\\n            }\\n            ans = Math.min((n/2+n%2-maxEven)+ (n/2-secondOdd),(n/2+n%2-secondEven)+(n/2-maxOdd));\\n        }\\n        else{\\n            ans = ((n/2+n%2)-maxEven)+ ((n/2)-maxOdd);  \\n        } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050566,
                "title": "find-first-second-max",
                "content": "```\\nvar minimumOperations = function(nums) {\\n   let countOddId = {}    \\n    let countEvenId = {}\\n    if(nums.length === 1) return 0\\n    if(nums.length === 2 && nums[0] === nums[1]) {\\n        return 1\\n    }\\n    nums.forEach((n, i) => {\\n        if(i%2) {\\n            if(!countOddId[n]) {\\n                countOddId[n] = 1;\\n            } else {\\n                countOddId[n]++\\n            }\\n        } else {\\n            if(!countEvenId[n]) {\\n                countEvenId[n] = 1;\\n            } else {\\n                countEvenId[n]++\\n            }\\n        }\\n    })\\n    \\n    const sortedEven = Object.entries(countEvenId).sort((a, b) => {\\n        return  b[1] - a[1]\\n    })\\n\\n    const sortedOdd = Object.entries(countOddId).sort((a, b) => {\\n        return  b[1] - a[1]\\n    })\\n\\n    if(sortedEven[0][0] === sortedOdd[0][0]) {\\n        let maxFirst =0;\\n        let maxSec =0;\\n\\n        if(sortedEven.length === 1) {\\n            maxFirst = sortedEven[0][1];\\n            maxSec = sortedOdd[1]? sortedOdd[1][1] : 0;\\n            return  nums.length - (maxFirst + maxSec)  \\n        } \\n        \\n        if(sortedOdd.length === 1) {\\n            maxFirst = sortedOdd[0][1];\\n            maxSec = sortedEven[1] ? sortedEven[1][1] : 0;\\n            return  nums.length - (maxFirst + maxSec)  \\n        }\\n        let one = sortedEven[0][1] + sortedOdd[1][1]\\n        let two = sortedOdd[0][1] + sortedEven[1][1]\\n        return nums.length - Math.max(one, two)\\n    } else {\\n        return nums.length - (sortedEven[0][1] + sortedOdd[0][1])\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "```\\nvar minimumOperations = function(nums) {\\n   let countOddId = {}    \\n    let countEvenId = {}\\n    if(nums.length === 1) return 0\\n    if(nums.length === 2 && nums[0] === nums[1]) {\\n        return 1\\n    }\\n    nums.forEach((n, i) => {\\n        if(i%2) {\\n            if(!countOddId[n]) {\\n                countOddId[n] = 1;\\n            } else {\\n                countOddId[n]++\\n            }\\n        } else {\\n            if(!countEvenId[n]) {\\n                countEvenId[n] = 1;\\n            } else {\\n                countEvenId[n]++\\n            }\\n        }\\n    })\\n    \\n    const sortedEven = Object.entries(countEvenId).sort((a, b) => {\\n        return  b[1] - a[1]\\n    })\\n\\n    const sortedOdd = Object.entries(countOddId).sort((a, b) => {\\n        return  b[1] - a[1]\\n    })\\n\\n    if(sortedEven[0][0] === sortedOdd[0][0]) {\\n        let maxFirst =0;\\n        let maxSec =0;\\n\\n        if(sortedEven.length === 1) {\\n            maxFirst = sortedEven[0][1];\\n            maxSec = sortedOdd[1]? sortedOdd[1][1] : 0;\\n            return  nums.length - (maxFirst + maxSec)  \\n        } \\n        \\n        if(sortedOdd.length === 1) {\\n            maxFirst = sortedOdd[0][1];\\n            maxSec = sortedEven[1] ? sortedEven[1][1] : 0;\\n            return  nums.length - (maxFirst + maxSec)  \\n        }\\n        let one = sortedEven[0][1] + sortedOdd[1][1]\\n        let two = sortedOdd[0][1] + sortedEven[1][1]\\n        return nums.length - Math.max(one, two)\\n    } else {\\n        return nums.length - (sortedEven[0][1] + sortedOdd[0][1])\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2040921,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        hash_odd = {}\\n        hash_even = {}\\n        m1, m2, n1, n2, max_key1, max_key2, secondevenmaxfreq, secondoddmaxfreq = 0, 0, 0, 0, -1, -1, 0, 0\\n        n = len(nums)\\n        hash_odd[-1] = 0\\n        hash_even[-1] = 0\\n        for i in range(len(nums)):\\n            if nums[i] not in hash_even:\\n                hash_even[nums[i]] = 0\\n            if nums[i] not in hash_odd:\\n                hash_odd[nums[i]] = 0\\n            if i%2 == 0:\\n                hash_even[nums[i]] =  hash_even[nums[i]] + 1\\n                if m1 < hash_even[nums[i]]:\\n                   m1 = hash_even[nums[i]]\\n                   n1 = nums[i]                     \\n            else:\\n                hash_odd[nums[i]] = hash_odd[nums[i]] + 1\\n                if m2 < hash_odd[nums[i]]:\\n                   m2 = hash_odd[nums[i]]\\n                   n2 = nums[i]\\n        if n1 != n2:\\n            return len(nums) - (m1 + m2)\\n        hash_even.pop(n1)\\n        hash_odd.pop(n2)\\n        if len(hash_even):\\n           max_key1 = max(hash_even, key=hash_even.get)\\n           secondevenmaxfreq = hash_even.get(max_key1)\\n        if len(hash_odd):\\n           max_key2 = max(hash_odd, key=hash_odd.get)\\n           secondoddmaxfreq = hash_odd.get(max_key2)\\n        return min(n-secondevenmaxfreq-m2, n-m1-secondoddmaxfreq);\\n        \\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        hash_odd = {}\\n        hash_even = {}\\n        m1, m2, n1, n2, max_key1, max_key2, secondevenmaxfreq, secondoddmaxfreq = 0, 0, 0, 0, -1, -1, 0, 0\\n        n = len(nums)\\n        hash_odd[-1] = 0\\n        hash_even[-1] = 0\\n        for i in range(len(nums)):\\n            if nums[i] not in hash_even:\\n                hash_even[nums[i]] = 0\\n            if nums[i] not in hash_odd:\\n                hash_odd[nums[i]] = 0\\n            if i%2 == 0:\\n                hash_even[nums[i]] =  hash_even[nums[i]] + 1\\n                if m1 < hash_even[nums[i]]:\\n                   m1 = hash_even[nums[i]]\\n                   n1 = nums[i]                     \\n            else:\\n                hash_odd[nums[i]] = hash_odd[nums[i]] + 1\\n                if m2 < hash_odd[nums[i]]:\\n                   m2 = hash_odd[nums[i]]\\n                   n2 = nums[i]\\n        if n1 != n2:\\n            return len(nums) - (m1 + m2)\\n        hash_even.pop(n1)\\n        hash_odd.pop(n2)\\n        if len(hash_even):\\n           max_key1 = max(hash_even, key=hash_even.get)\\n           secondevenmaxfreq = hash_even.get(max_key1)\\n        if len(hash_odd):\\n           max_key2 = max(hash_odd, key=hash_odd.get)\\n           secondoddmaxfreq = hash_odd.get(max_key2)\\n        return min(n-secondevenmaxfreq-m2, n-m1-secondoddmaxfreq);\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979620,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimum_operations(nums)\\n  nums.size <= 1 ? 0 : nums.size - nums.zip(1..).group_by { _2 % 2 }.map { |t, xs| xs.map(&:first).tally.merge(-1-t => 0).max_by(2) { _2 } }.reduce(&:product).filter_map { |(x, cx), (y, cy)| cx + cy if x != y }.max    \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef minimum_operations(nums)\\n  nums.size <= 1 ? 0 : nums.size - nums.zip(1..).group_by { _2 % 2 }.map { |t, xs| xs.map(&:first).tally.merge(-1-t => 0).max_by(2) { _2 } }.reduce(&:product).filter_map { |(x, cx), (y, cy)| cx + cy if x != y }.max    \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1978957,
                "title": "count-odd-even-first-and-second-largest-frequency-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>even;\\n        unordered_map<int,int>odd;\\n        int n=nums.size();\\n        vector<int>eveninfo(4,0);\\n        vector<int>oddinfo(4,0);\\n        for(int i=0;i<n;i++){\\n            if(i & 1) odd[nums[i]]++;\\n            else even[nums[i]]++;\\n        }\\n        for(auto it:even){\\n            if(it.second>eveninfo[1]){\\n                eveninfo[2]=eveninfo[0];\\n                eveninfo[3]=eveninfo[1];\\n                eveninfo[0]=it.first;\\n                eveninfo[1]=it.second;\\n            } else if(it.second>eveninfo[3]){\\n                eveninfo[2]=it.first;\\n                eveninfo[3]=it.second;\\n            } else{\\n                continue;\\n            }\\n        }\\n        for(auto it:odd){\\n            if(it.second>oddinfo[1]){\\n                oddinfo[2]=oddinfo[0];\\n                oddinfo[3]=oddinfo[1];\\n                oddinfo[0]=it.first;\\n                oddinfo[1]=it.second;\\n            } else if(it.second>oddinfo[3]){\\n                oddinfo[2]=it.first;\\n                oddinfo[3]=it.second;\\n            } else{\\n                continue;\\n            }\\n        }\\n        if(eveninfo[0]!=oddinfo[0]) return n-eveninfo[1]-oddinfo[1];\\n        int ans=min(n-eveninfo[1]-oddinfo[3],n-oddinfo[1]-eveninfo[3]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        unordered_map<int,int>even;\\n        unordered_map<int,int>odd;\\n        int n=nums.size();\\n        vector<int>eveninfo(4,0);\\n        vector<int>oddinfo(4,0);\\n        for(int i=0;i<n;i++){\\n            if(i & 1) odd[nums[i]]++;\\n            else even[nums[i]]++;\\n        }\\n        for(auto it:even){\\n            if(it.second>eveninfo[1]){\\n                eveninfo[2]=eveninfo[0];\\n                eveninfo[3]=eveninfo[1];\\n                eveninfo[0]=it.first;\\n                eveninfo[1]=it.second;\\n            } else if(it.second>eveninfo[3]){\\n                eveninfo[2]=it.first;\\n                eveninfo[3]=it.second;\\n            } else{\\n                continue;\\n            }\\n        }\\n        for(auto it:odd){\\n            if(it.second>oddinfo[1]){\\n                oddinfo[2]=oddinfo[0];\\n                oddinfo[3]=oddinfo[1];\\n                oddinfo[0]=it.first;\\n                oddinfo[1]=it.second;\\n            } else if(it.second>oddinfo[3]){\\n                oddinfo[2]=it.first;\\n                oddinfo[3]=it.second;\\n            } else{\\n                continue;\\n            }\\n        }\\n        if(eveninfo[0]!=oddinfo[0]) return n-eveninfo[1]-oddinfo[1];\\n        int ans=min(n-eveninfo[1]-oddinfo[3],n-oddinfo[1]-eveninfo[3]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975095,
                "title": "python3-clean-code",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if not nums or len(nums) <= 1:\\n            return 0\\n        c1, c2 = Counter(), Counter()\\n        t1 = t2 = 0\\n        for idx, val in enumerate(nums):\\n            if idx & 1:\\n                t2 += 1\\n                c2[val] += 1\\n            else:\\n                c1[val] += 1\\n                t1 += 1\\n        l1 = sorted([(fre, val) for val, fre in c1.items()])\\n        l2 = sorted([(fre, val) for val, fre in c2.items()])\\n        \\n        if l1[-1][-1] != l2[-1][-1]:\\n            return t1 - l1[-1][0] + t2 - l2[-1][0]\\n        can1 = t1 - l1[-1][0] + (t2 - (l2[-2][0] if len(l2) > 1 else 0))\\n        can2 = t2 - l2[-1][0] + (t1 - (l1[-2][0] if len(l1) > 1 else 0))\\n        return min(can1, can2)        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if not nums or len(nums) <= 1:\\n            return 0\\n        c1, c2 = Counter(), Counter()\\n        t1 = t2 = 0\\n        for idx, val in enumerate(nums):\\n            if idx & 1:\\n                t2 += 1\\n                c2[val] += 1\\n            else:\\n                c1[val] += 1\\n                t1 += 1\\n        l1 = sorted([(fre, val) for val, fre in c1.items()])\\n        l2 = sorted([(fre, val) for val, fre in c2.items()])\\n        \\n        if l1[-1][-1] != l2[-1][-1]:\\n            return t1 - l1[-1][0] + t2 - l2[-1][0]\\n        can1 = t1 - l1[-1][0] + (t2 - (l2[-2][0] if len(l2) > 1 else 0))\\n        can2 = t2 - l2[-1][0] + (t1 - (l1[-2][0] if len(l1) > 1 else 0))\\n        return min(can1, can2)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970306,
                "title": "c-unordered-map-max-and-second-max-77-faster",
                "content": "```\\n   int minimumOperations(vector<int>& nums) {\\n        \\n        if(nums.size()==1)  return 0;\\n       unordered_map<int,int>e,o;\\n      \\n        \\n        \\n        int n=nums.size();\\n          int even=n%2==0? n/2: n/2+1;\\n        int odd=n/2;\\n       \\n        int ind1,ind2;  int operations=0;\\n        \\n        int mx1=INT_MIN,mx2=INT_MIN; int smx1=INT_MIN,smx2=INT_MIN;\\n        for(int i=0;i<n;i++){\\n          if(i==0 || i%2==0){\\n              e[nums[i]]++; \\n               if(mx1<e[nums[i]])\\n              mx1=max(mx1,e[nums[i]]),ind1=nums[i];\\n          }  \\n            else{\\n              o[nums[i]]++;\\n                if(mx2<o[nums[i]])\\n                mx2=max(mx2,o[nums[i]]),ind2=nums[i];\\n            }\\n        }\\n        if(ind1==ind2){\\n            for(int i=1;i<n;i+=2){\\n                if(nums[i]!=ind1 && o[nums[i]]> smx2)  {\\n                    smx2=o[nums[i]];\\n                }\\n            }\\n           for(int i=0;i<n;i+=2){\\n               if(nums[i]!=ind2 && e[nums[i]]>smx1){\\n                   smx1=e[nums[i]];\\n               }\\n           }\\n          \\n            operations+=even-mx1;\\n            if(smx2==INT_MIN)  operations+=odd;\\n            else operations+=odd-smx2;\\n            \\n            int temp=odd-mx2;\\n            if(smx1==INT_MIN) temp+=even;\\n            else temp+=even-smx1;\\n           \\n            return min(temp,operations);\\n            \\n        }\\n    \\n          int  toperations=0;\\n            \\n         toperations+=even-mx1;\\n            toperations+=odd-mx2;\\n            \\n        \\n           return toperations;\\n                \\n    \\n        return operations;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int minimumOperations(vector<int>& nums) {\\n        \\n        if(nums.size()==1)  return 0;\\n       unordered_map<int,int>e,o;\\n      \\n        \\n        \\n        int n=nums.size();\\n          int even=n%2==0? n/2: n/2+1;\\n        int odd=n/2;\\n       \\n        int ind1,ind2;  int operations=0;\\n        \\n        int mx1=INT_MIN,mx2=INT_MIN; int smx1=INT_MIN,smx2=INT_MIN;\\n        for(int i=0;i<n;i++){\\n          if(i==0 || i%2==0){\\n              e[nums[i]]++; \\n               if(mx1<e[nums[i]])\\n              mx1=max(mx1,e[nums[i]]),ind1=nums[i];\\n          }  \\n            else{\\n              o[nums[i]]++;\\n                if(mx2<o[nums[i]])\\n                mx2=max(mx2,o[nums[i]]),ind2=nums[i];\\n            }\\n        }\\n        if(ind1==ind2){\\n            for(int i=1;i<n;i+=2){\\n                if(nums[i]!=ind1 && o[nums[i]]> smx2)  {\\n                    smx2=o[nums[i]];\\n                }\\n            }\\n           for(int i=0;i<n;i+=2){\\n               if(nums[i]!=ind2 && e[nums[i]]>smx1){\\n                   smx1=e[nums[i]];\\n               }\\n           }\\n          \\n            operations+=even-mx1;\\n            if(smx2==INT_MIN)  operations+=odd;\\n            else operations+=odd-smx2;\\n            \\n            int temp=odd-mx2;\\n            if(smx1==INT_MIN) temp+=even;\\n            else temp+=even-smx1;\\n           \\n            return min(temp,operations);\\n            \\n        }\\n    \\n          int  toperations=0;\\n            \\n         toperations+=even-mx1;\\n            toperations+=odd-mx2;\\n            \\n        \\n           return toperations;\\n                \\n    \\n        return operations;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958008,
                "title": "6-lines-python-solution-99-faster-memory-less-than-98",
                "content": "![image](https://assets.leetcode.com/users/images/9ffd7a92-0a7a-43aa-968b-7988b7771b1d_1650216640.4302225.png)\\n\\n\\n### ***Solution Using Counter: TC O(n) / SC O(1)***\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n=len(nums) ; odd_len=n//2 ; even_len=n-odd_len\\n        if n <= 1: return 0\\n        c1=Counter(nums[i] for i in range(0,n,2)).most_common(2)+[(-1,0)]\\n        c2=Counter(nums[i] for i in range(1,n,2)).most_common(2)+[(-1,0)]\\n        if c1[0][0]!=c2[0][0]: return (even_len-c1[0][1])+(odd_len-c2[0][1])\\n        else: return min((even_len-c1[0][1])+(odd_len-c2[1][1]), (even_len-c1[1][1])+(odd_len-c2[0][1]))\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        n=len(nums) ; odd_len=n//2 ; even_len=n-odd_len\\n        if n <= 1: return 0\\n        c1=Counter(nums[i] for i in range(0,n,2)).most_common(2)+[(-1,0)]\\n        c2=Counter(nums[i] for i in range(1,n,2)).most_common(2)+[(-1,0)]\\n        if c1[0][0]!=c2[0][0]: return (even_len-c1[0][1])+(odd_len-c2[0][1])\\n        else: return min((even_len-c1[0][1])+(odd_len-c2[1][1]), (even_len-c1[1][1])+(odd_len-c2[0][1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950706,
                "title": "python3",
                "content": "class Solution:\\n\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even, odd = {}, {}\\n        N = len(nums)\\n        \\n        for i in range(0,len(nums),2):\\n            ele = nums[i]\\n            even[ele] = even.get(ele,0) + 1\\n        \\n        for i in range(1,len(nums),2):\\n            ele = nums[i]\\n            odd[ele] = odd.get(ele,0) + 1\\n        \\n        evenMaxKey = evenSecMaxKey = evenMaxVal = evenSecMaxVal = 0\\n        \\n        for key,value in even.items():\\n            if value>evenMaxVal:\\n                evenSecMaxVal = evenMaxVal\\n                evenMaxVal = value\\n                evenSecMaxKey = evenMaxKey\\n                evenMaxKey = key\\n            elif value>evenSecMaxVal:\\n                evenSecMaxKey = key\\n                evenSecMaxVal = value\\n                \\n        oddMaxKey = oddSecMaxKey = oddMaxVal = oddSecMaxVal = 0\\n        \\n        for key,value in odd.items():\\n            if value>oddMaxVal:\\n                oddSecMaxVal = oddMaxVal\\n                oddMaxVal = value\\n                oddSecMaxKey = oddMaxKey\\n                oddMaxKey = key\\n            elif value>oddSecMaxVal:\\n                oddSecMaxKey = key\\n                oddSecMaxVal = value         \\n                \\n        if evenMaxKey!=oddMaxKey:\\n            return N-evenMaxVal-oddMaxVal\\n        \\n        return N-max(evenMaxVal+oddSecMaxVal,oddMaxVal+evenSecMaxVal)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        even, odd = {}",
                "codeTag": "Java"
            },
            {
                "id": 1929889,
                "title": "c-maps-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n\\n        if(nums.size() == 1 ) return 0;\\n        map<int, int> even_counts; //holds count of each value found in an even position (1-indexed)\\n        map<int, int> odd_counts; //holds count of each value found in an odd position (1-indexed)\\n        map<int, vector<int>> even_costs; //re-organizes even values by moves required to make all of the even positions the same with that value -- vector contains values that have the same cost\\n        map<int, vector<int>> odd_costs; //re-organizes odd values by moves required to make all the odd positions the same with that value -- vector contains values that have the same cost\\n\\t\\t\\n        for(int i = 0; i < nums.size(); i++){ //populate count maps\\n            if(i % 2 == 1)\\n                even_counts[nums[i]]++;\\n            else odd_counts[nums[i]]++;\\n            }\\n        \\n        for(auto it = even_counts.begin(); it != even_counts.end(); it++){ //populate cost maps for even/odd positions\\n            even_costs[abs((int)(nums.size() / 2) - (int)it->second)].push_back(it->first);\\n        }\\n        for(auto it = odd_counts.begin(); it != odd_counts.end(); it++){\\n            odd_costs[abs((int)((nums.size()+1) /2) - (int)it->second)].push_back(it->first);\\n        }\\n\\t\\t\\n        auto even_it = even_costs.begin();\\n        auto odd_it = odd_costs.begin();\\n        //iterate through cost-value maps, starting from lowest cost values. The if-else work is to account\\n\\t\\t//for possibility of finding the same value in both even position and odd position -- check next-highest cost if \\n\\t\\t//the numbers at the current cost levels are the same.\\n        while(even_it != even_costs.end() && odd_it != odd_costs.end()){ \\n            for(int i = 0; i < even_it->second.size(); i++)\\n                for(int j = 0; j < odd_it->second.size(); j++)\\n                    if(even_it->second[i] != odd_it->second[j]) return even_it->first + odd_it->first;\\n            auto temp_1 = even_it;\\n            auto temp_2 = odd_it;\\n            temp_1++;\\n            temp_2++;\\n            if(temp_1 == even_costs.end())\\n                odd_it++;\\n            else if(temp_2 == odd_costs.end())\\n                even_it++;\\n            else if(temp_1->first < temp_2->first)\\n                even_it++;\\n            else\\n                odd_it++;\\n        }\\n        return nums.size() /2 ; //in case of all elements the same\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n\\n        if(nums.size() == 1 ) return 0;\\n        map<int, int> even_counts; //holds count of each value found in an even position (1-indexed)\\n        map<int, int> odd_counts; //holds count of each value found in an odd position (1-indexed)\\n        map<int, vector<int>> even_costs; //re-organizes even values by moves required to make all of the even positions the same with that value -- vector contains values that have the same cost\\n        map<int, vector<int>> odd_costs; //re-organizes odd values by moves required to make all the odd positions the same with that value -- vector contains values that have the same cost\\n\\t\\t\\n        for(int i = 0; i < nums.size(); i++){ //populate count maps\\n            if(i % 2 == 1)\\n                even_counts[nums[i]]++;\\n            else odd_counts[nums[i]]++;\\n            }\\n        \\n        for(auto it = even_counts.begin(); it != even_counts.end(); it++){ //populate cost maps for even/odd positions\\n            even_costs[abs((int)(nums.size() / 2) - (int)it->second)].push_back(it->first);\\n        }\\n        for(auto it = odd_counts.begin(); it != odd_counts.end(); it++){\\n            odd_costs[abs((int)((nums.size()+1) /2) - (int)it->second)].push_back(it->first);\\n        }\\n\\t\\t\\n        auto even_it = even_costs.begin();\\n        auto odd_it = odd_costs.begin();\\n        //iterate through cost-value maps, starting from lowest cost values. The if-else work is to account\\n\\t\\t//for possibility of finding the same value in both even position and odd position -- check next-highest cost if \\n\\t\\t//the numbers at the current cost levels are the same.\\n        while(even_it != even_costs.end() && odd_it != odd_costs.end()){ \\n            for(int i = 0; i < even_it->second.size(); i++)\\n                for(int j = 0; j < odd_it->second.size(); j++)\\n                    if(even_it->second[i] != odd_it->second[j]) return even_it->first + odd_it->first;\\n            auto temp_1 = even_it;\\n            auto temp_2 = odd_it;\\n            temp_1++;\\n            temp_2++;\\n            if(temp_1 == even_costs.end())\\n                odd_it++;\\n            else if(temp_2 == odd_costs.end())\\n                even_it++;\\n            else if(temp_1->first < temp_2->first)\\n                even_it++;\\n            else\\n                odd_it++;\\n        }\\n        return nums.size() /2 ; //in case of all elements the same\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919437,
                "title": "self-explanatory-code",
                "content": "```\\nclass Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,Integer> oddIndexMap = new HashMap<>();\\n\\n        int totalLength = nums.length;\\n        int oddPartLength = 0;\\n        int currentIndex = 0;\\n        while(currentIndex<totalLength){\\n            int temp = oddIndexMap.getOrDefault(nums[currentIndex],0);\\n            oddIndexMap.put(nums[currentIndex],temp+1);\\n            currentIndex+=2;\\n        }\\n        int evenPartLength = totalLength - oddPartLength;\\n        int[] maxRightPart = new int[100002];\\n        int[] maxLeftPart = new int[100002];\\n        for(int i=1;i<totalLength;i+=2){\\n            maxRightPart[nums[i]]++;\\n            maxLeftPart[nums[i]]++;\\n            \\n        }\\n        for(int i=1;i<=100001;i++) maxLeftPart[i] = Math.max(maxLeftPart[i],maxLeftPart[i-1]);\\n        for(int i=100000;i>=0;i--) maxRightPart[i] = Math.max(maxRightPart[i],maxRightPart[i+1]);\\n        int ans = totalLength;\\n        for(int i=1;i<=100000;i++){\\n            ans = Math.min(totalLength-oddIndexMap.getOrDefault(i,0)-Math.max(maxLeftPart[i-1],maxRightPart[i+1]),ans);\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumOperations(int[] nums) {\\n        Map<Integer,Integer> oddIndexMap = new HashMap<>();\\n\\n        int totalLength = nums.length;\\n        int oddPartLength = 0;\\n        int currentIndex = 0;\\n        while(currentIndex<totalLength){\\n            int temp = oddIndexMap.getOrDefault(nums[currentIndex],0);\\n            oddIndexMap.put(nums[currentIndex],temp+1);\\n            currentIndex+=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1898838,
                "title": "c-greedy-approch-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return 0;\\n        int odd=0,even=0;\\n        unordered_map<int,int>mp_o;\\n        unordered_map<int,int>mp_e;\\n        for(int i=0;i<nums.size();i++){\\n            if(i&1){\\n                odd++;\\n                mp_o[nums[i]]++;\\n            }\\n            else{\\n                even++;\\n                mp_e[nums[i]]++;\\n            }\\n        }\\n        priority_queue<pair<int,int>>po,pe;\\n        for(auto x: mp_o){\\n            po.push({x.second,x.first});\\n        }\\n        for(auto x: mp_e){\\n            pe.push({x.second,x.first});\\n        }\\n        int no1= pe.top().first;\\n        int k= pe.top().second;\\n        pe.pop();\\n        int no2= po.top().first;\\n        int l= po.top().second;\\n        po.pop();\\n        if(k==l){\\n        if(pe.empty() && po.empty()){\\n            return min(odd,even);\\n        }\\n        if(pe.empty()){\\n             int p= even + (odd - no2);\\n            return min(p,odd-po.top().first);\\n        }\\n        if(po.empty()){\\n            int p= odd + (even-no2);\\n            return min(p,even-pe.top().first); \\n        }\\n        if(!po.empty() && !pe.empty()){\\n            int p= (odd - po.top().first) + (even - no1);\\n            int q= (even - pe.top().first) + (odd - no2);\\n            return min(p,q);\\n        }\\n        }\\n        return (even-no1) + (odd-no2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return 0;\\n        int odd=0,even=0;\\n        unordered_map<int,int>mp_o;\\n        unordered_map<int,int>mp_e;\\n        for(int i=0;i<nums.size();i++){\\n            if(i&1){\\n                odd++;\\n                mp_o[nums[i]]++;\\n            }\\n            else{\\n                even++;\\n                mp_e[nums[i]]++;\\n            }\\n        }\\n        priority_queue<pair<int,int>>po,pe;\\n        for(auto x: mp_o){\\n            po.push({x.second,x.first});\\n        }\\n        for(auto x: mp_e){\\n            pe.push({x.second,x.first});\\n        }\\n        int no1= pe.top().first;\\n        int k= pe.top().second;\\n        pe.pop();\\n        int no2= po.top().first;\\n        int l= po.top().second;\\n        po.pop();\\n        if(k==l){\\n        if(pe.empty() && po.empty()){\\n            return min(odd,even);\\n        }\\n        if(pe.empty()){\\n             int p= even + (odd - no2);\\n            return min(p,odd-po.top().first);\\n        }\\n        if(po.empty()){\\n            int p= odd + (even-no2);\\n            return min(p,even-pe.top().first); \\n        }\\n        if(!po.empty() && !pe.empty()){\\n            int p= (odd - po.top().first) + (even - no1);\\n            int q= (even - pe.top().first) + (odd - no2);\\n            return min(p,q);\\n        }\\n        }\\n        return (even-no1) + (odd-no2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892384,
                "title": "simple-two-case-approach-c-map",
                "content": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>&a) {\\n        int n=a.size();\\n        int od,ev,ans;\\n        od=n/2;//NUMBER OF ELEMENTS AT ODD POSITION\\n        ev=(n+1)/2;//NUMBER OF ELEMENTS AT EVEN POSITION\\n        map<int,int>mp,mpp;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                mp[a[i]]++;\\n            else\\n                mpp[a[i]]++;\\n        }\\n        int oddmax1=-1,oddmax2=-1,evenmax1=-1,evenmax2=-1;\\n        for(auto it:mp){\\n            if(it.second>mp[oddmax1]){\\n                oddmax2=oddmax1;\\n                oddmax1=it.first;\\n            }\\n            else if(it.second>mp[oddmax2])\\n                oddmax2=it.first;\\n        }\\n        for(auto it:mpp){\\n            if(it.second>mpp[evenmax1]){\\n                evenmax2=evenmax1;\\n                evenmax1=it.first;\\n            }\\n            else if(it.second>mpp[evenmax2])\\n                evenmax2=it.first;\\n        }\\n        if(oddmax1!=evenmax1){\\n            ans=od-mp[oddmax1]+ev-mpp[evenmax1];\\n        }\\n        else{\\n            int ans1=od-mp[oddmax1]+ev-mpp[evenmax2];\\n            int ans2=od-mp[oddmax2]+ev-mpp[evenmax1];\\n            ans=min(ans1,ans2);\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumOperations(vector<int>&a) {\\n        int n=a.size();\\n        int od,ev,ans;\\n        od=n/2;//NUMBER OF ELEMENTS AT ODD POSITION\\n        ev=(n+1)/2;//NUMBER OF ELEMENTS AT EVEN POSITION\\n        map<int,int>mp,mpp;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0)\\n                mp[a[i]]++;\\n            else\\n                mpp[a[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1890657,
                "title": "hashmap-odd-even",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int freqeven[100001] = {0};\\n        int freqodd[100001] = {0};\\n        int n = nums.size();\\n        int maxi = 0;\\n        \\n        int oddmax = 0;\\n        int firstoddmaxfreq = 0;\\n        int secondoddmax = 0;\\n        int secondoddmaxfreq = 0;\\n        \\n         int evenmax = 0;\\n        int firstevenmaxfreq = 0;\\n        int secondevenmax = 0;\\n        int secondevenmaxfreq = 0;\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(i%2==0)\\n                freqeven[nums[i]]++;\\n            else \\n                freqodd[nums[i]]++;\\n            maxi = max(maxi,nums[i]);\\n        }\\n        \\n        for(int i=1; i<=maxi ; i++){\\n            if(freqeven[i]>firstevenmaxfreq){\\n                secondevenmaxfreq = firstevenmaxfreq;\\n                secondevenmax = evenmax;\\n                firstevenmaxfreq = freqeven[i];\\n                evenmax = i;\\n            }\\n            else if(freqeven[i]>secondoddmaxfreq){\\n           \\n                secondevenmaxfreq = freqeven[i];\\n                    secondevenmax = i;\\n            }\\n                        \\n           if(freqodd[i]>firstoddmaxfreq){\\n               secondoddmaxfreq = firstoddmaxfreq;\\n                secondoddmax = oddmax;\\n               firstoddmaxfreq = freqodd[i];\\n                oddmax = i;\\n            }\\n            else if(freqodd[i]>secondoddmaxfreq){\\n                secondoddmaxfreq = freqodd[i];\\n                    secondoddmax = i;\\n            }                  \\n\\n        }\\n        \\n        if(evenmax != oddmax)\\n            return n-firstevenmaxfreq - firstoddmaxfreq;\\n        else\\n            return min(n-secondevenmaxfreq-firstoddmaxfreq , n-firstevenmaxfreq-secondoddmaxfreq);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int freqeven[100001] = {0};\\n        int freqodd[100001] = {0};\\n        int n = nums.size();\\n        int maxi = 0;\\n        \\n        int oddmax = 0;\\n        int firstoddmaxfreq = 0;\\n        int secondoddmax = 0;\\n        int secondoddmaxfreq = 0;\\n        \\n         int evenmax = 0;\\n        int firstevenmaxfreq = 0;\\n        int secondevenmax = 0;\\n        int secondevenmaxfreq = 0;\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(i%2==0)\\n                freqeven[nums[i]]++;\\n            else \\n                freqodd[nums[i]]++;\\n            maxi = max(maxi,nums[i]);\\n        }\\n        \\n        for(int i=1; i<=maxi ; i++){\\n            if(freqeven[i]>firstevenmaxfreq){\\n                secondevenmaxfreq = firstevenmaxfreq;\\n                secondevenmax = evenmax;\\n                firstevenmaxfreq = freqeven[i];\\n                evenmax = i;\\n            }\\n            else if(freqeven[i]>secondoddmaxfreq){\\n           \\n                secondevenmaxfreq = freqeven[i];\\n                    secondevenmax = i;\\n            }\\n                        \\n           if(freqodd[i]>firstoddmaxfreq){\\n               secondoddmaxfreq = firstoddmaxfreq;\\n                secondoddmax = oddmax;\\n               firstoddmaxfreq = freqodd[i];\\n                oddmax = i;\\n            }\\n            else if(freqodd[i]>secondoddmaxfreq){\\n                secondoddmaxfreq = freqodd[i];\\n                    secondoddmax = i;\\n            }                  \\n\\n        }\\n        \\n        if(evenmax != oddmax)\\n            return n-firstevenmaxfreq - firstoddmaxfreq;\\n        else\\n            return min(n-secondevenmaxfreq-firstoddmaxfreq , n-firstevenmaxfreq-secondoddmaxfreq);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851392,
                "title": "scala-explicit-solution",
                "content": "```\\ndef minimumOperations(nums: Array[Int]): Int = {\\n  val odds = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0) // % 2 == 1\\n  val evens = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n  nums.indices.foreach(i => if(i % 2 == 0) evens(nums(i)) += 1 else odds(nums(i)) += 1)\\n  val oddSorted = odds.toList.sortBy(- _._2)\\n  val evenSorted = evens.toList.sortBy(- _._2)\\n  val oddsAll = odds.map(_._2).sum\\n  val evensAll = evens.map(_._2).sum\\n  (oddSorted, evenSorted) match {\\n    case (_, Nil) => 0\\n    case (Nil, _) => 0\\n    case ((i1, n1) :: Nil, (j1, m1) :: Nil) => if(i1 == j1) n1 else 0\\n    case ((i1, n1) :: Nil, (j1, m1) :: (_, m2) :: _) => compare(i1, n1, evensAll, j1, m1, m2)\\n    case ((i1, n1) :: (_, n2) :: _, (j1, m1) :: Nil) => compare(j1, m1, oddsAll, i1, n1, n2)\\n    case ((i1, n1) :: (_, n2) :: _, (j1, m1) :: (_, m2) :: _) =>\\n      if(i1 == j1) {\\n        val toJ1 = (oddsAll - n2 + evensAll - m1)\\n        val toI1 = (oddsAll - n1 + evensAll - m2)\\n        math.min(toJ1, toI1)\\n      } else oddsAll - n1 + evensAll - m1\\n  }\\n}\\n\\nprivate def compare(i1: Int, n1: Int, iAll: Int, j1: Int, m1: Int, m2: Int) =\\n  if(i1 == j1) {\\n    val toJ1 = n1 + iAll - m1\\n    val toI1 = iAll - m2\\n    math.min(toJ1, toI1)\\n  } else iAll - m1\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef minimumOperations(nums: Array[Int]): Int = {\\n  val odds = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0) // % 2 == 1\\n  val evens = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n  nums.indices.foreach(i => if(i % 2 == 0) evens(nums(i)) += 1 else odds(nums(i)) += 1)\\n  val oddSorted = odds.toList.sortBy(- _._2)\\n  val evenSorted = evens.toList.sortBy(- _._2)\\n  val oddsAll = odds.map(_._2).sum\\n  val evensAll = evens.map(_._2).sum\\n  (oddSorted, evenSorted) match {\\n    case (_, Nil) => 0\\n    case (Nil, _) => 0\\n    case ((i1, n1) :: Nil, (j1, m1) :: Nil) => if(i1 == j1) n1 else 0\\n    case ((i1, n1) :: Nil, (j1, m1) :: (_, m2) :: _) => compare(i1, n1, evensAll, j1, m1, m2)\\n    case ((i1, n1) :: (_, n2) :: _, (j1, m1) :: Nil) => compare(j1, m1, oddsAll, i1, n1, n2)\\n    case ((i1, n1) :: (_, n2) :: _, (j1, m1) :: (_, m2) :: _) =>\\n      if(i1 == j1) {\\n        val toJ1 = (oddsAll - n2 + evensAll - m1)\\n        val toI1 = (oddsAll - n1 + evensAll - m2)\\n        math.min(toJ1, toI1)\\n      } else oddsAll - n1 + evensAll - m1\\n  }\\n}\\n\\nprivate def compare(i1: Int, n1: Int, iAll: Int, j1: Int, m1: Int, m2: Int) =\\n  if(i1 == j1) {\\n    val toJ1 = n1 + iAll - m1\\n    val toI1 = iAll - m2\\n    math.min(toJ1, toI1)\\n  } else iAll - m1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1836113,
                "title": "python-solution-find-most-and-second-most-number-in-num-2-and-nums-1-2",
                "content": "```python\\nclass Solution(object):\\n    def minimumOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 2:\\n            return 0\\n        def get_most(arr, filtered = None):\\n            mp = {arr[0]:1}\\n            fm = 1\\n            fn = arr[0]\\n            sm = 0\\n            sn = None\\n            \\n            for a in arr[1:]:\\n                if a not in mp:\\n                    mp[a] = 0\\n                mp[a] += 1\\n                if mp[a] > fm:\\n                    fm, fn = mp[a], a\\n                elif mp[a] > sm:\\n                    sm, sn = mp[a], a\\n                # print a, fm, fn, sm, sn\\n                \\n            \\n            return fm, fn, sm, sn\\n        \\n        a = get_most(nums[::2])\\n        b = get_most(nums[1::2])\\n        # print a, b\\n        if a[1] == b[1]:\\n            return len(nums) - max(a[0] + b[2], a[2] + b[0])\\n        \\n        return len(nums) - a[0] - b[0]\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def minimumOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 2:\\n            return 0\\n        def get_most(arr, filtered = None):\\n            mp = {arr[0]:1}\\n            fm = 1\\n            fn = arr[0]\\n            sm = 0\\n            sn = None\\n            \\n            for a in arr[1:]:\\n                if a not in mp:\\n                    mp[a] = 0\\n                mp[a] += 1\\n                if mp[a] > fm:\\n                    fm, fn = mp[a], a\\n                elif mp[a] > sm:\\n                    sm, sn = mp[a], a\\n                # print a, fm, fn, sm, sn\\n                \\n            \\n            return fm, fn, sm, sn\\n        \\n        a = get_most(nums[::2])\\n        b = get_most(nums[1::2])\\n        # print a, b\\n        if a[1] == b[1]:\\n            return len(nums) - max(a[0] + b[2], a[2] + b[0])\\n        \\n        return len(nums) - a[0] - b[0]\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827158,
                "title": "c-short-hashmap-based-solution",
                "content": "```\\nint minimumOperations(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int even_f=0, odd_f=0, even_s=0, odd_s=0;\\n        int freq_even_f=0, freq_even_s=0, freq_odd_f=0, freq_odd_s=0;\\n        \\n        unordered_map<int, int> even, odd;\\n        int maxi=0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i&1)\\n                odd[nums[i]]++;\\n            else\\n                even[nums[i]]++;\\n            maxi=max(maxi, nums[i]);\\n        }\\n        \\n        for(int i=1; i<=maxi; i++)\\n        {\\n            if(odd[i]>freq_odd_f)\\n            {\\n                odd_s=odd_f;\\n                freq_odd_s=freq_odd_f;\\n                \\n                freq_odd_f=odd[i];\\n                odd_f=i;\\n            }\\n            else if(odd[i]>freq_odd_s)\\n            {\\n                freq_odd_s=odd[i];\\n                odd_s=i;\\n            }\\n            \\n             \\n            if(even[i]>freq_even_f)\\n            {\\n                even_s=even_f;\\n                freq_even_s=freq_even_f;\\n                \\n                freq_even_f=even[i];\\n                even_f=i;\\n            }\\n            \\n            else if(even[i]>freq_even_s)\\n            {\\n                freq_even_s=even[i];\\n                even_s=i;\\n            }\\n            \\n        }\\n        \\n        if(even_f!=odd_f)\\n            return n-freq_even_f-freq_odd_f;\\n        \\n        return min(n-freq_even_f-freq_odd_s, n-freq_even_s-freq_odd_f);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minimumOperations(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int even_f=0, odd_f=0, even_s=0, odd_s=0;\\n        int freq_even_f=0, freq_even_s=0, freq_odd_f=0, freq_odd_s=0;\\n        \\n        unordered_map<int, int> even, odd;\\n        int maxi=0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i&1)\\n                odd[nums[i]]++;\\n            else\\n                even[nums[i]]++;\\n            maxi=max(maxi, nums[i]);\\n        }\\n        \\n        for(int i=1; i<=maxi; i++)\\n        {\\n            if(odd[i]>freq_odd_f)\\n            {\\n                odd_s=odd_f;\\n                freq_odd_s=freq_odd_f;\\n                \\n                freq_odd_f=odd[i];\\n                odd_f=i;\\n            }\\n            else if(odd[i]>freq_odd_s)\\n            {\\n                freq_odd_s=odd[i];\\n                odd_s=i;\\n            }\\n            \\n             \\n            if(even[i]>freq_even_f)\\n            {\\n                even_s=even_f;\\n                freq_even_s=freq_even_f;\\n                \\n                freq_even_f=even[i];\\n                even_f=i;\\n            }\\n            \\n            else if(even[i]>freq_even_s)\\n            {\\n                freq_even_s=even[i];\\n                even_s=i;\\n            }\\n            \\n        }\\n        \\n        if(even_f!=odd_f)\\n            return n-freq_even_f-freq_odd_f;\\n        \\n        return min(n-freq_even_f-freq_odd_s, n-freq_even_s-freq_odd_f);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824900,
                "title": "python-counter",
                "content": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return 0\\n        d = {1:[],0:[]}\\n        for i in range(len(nums)):\\n            d[i%2].append(nums[i])\\n        cd0,cd1 = Counter(d[0]),Counter(d[1])\\n        l0,l1 = sorted([[k,v] for k,v in cd0.items()],key=lambda a:-a[1]),sorted([[k,v] for k,v in cd1.items()],key=lambda a:-a[1])\\n        if l0[0][0] != l1[0][0]:\\n            return sum([a[1] for a in l0[1:]])+sum([a[1] for a in l1[1:]])\\n        else:\\n            return min(sum([a[1] for a in l0[1:]])+sum([a[1] for a in [l1[0]]+l1[2:]]),sum([a[1] for a in [l0[0]]+l0[2:]])+sum([a[1] for a in l1[1:]]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return 0\\n        d = {1:[],0:[]}\\n        for i in range(len(nums)):\\n            d[i%2].append(nums[i])\\n        cd0,cd1 = Counter(d[0]),Counter(d[1])\\n        l0,l1 = sorted([[k,v] for k,v in cd0.items()],key=lambda a:-a[1]),sorted([[k,v] for k,v in cd1.items()],key=lambda a:-a[1])\\n        if l0[0][0] != l1[0][0]:\\n            return sum([a[1] for a in l0[1:]])+sum([a[1] for a in l1[1:]])\\n        else:\\n            return min(sum([a[1] for a in l0[1:]])+sum([a[1] for a in [l1[0]]+l1[2:]]),sum([a[1] for a in [l0[0]]+l0[2:]])+sum([a[1] for a in l1[1:]]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824109,
                "title": "full-self-explanatory-code-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //@jionghongli\\n    //let\\'s say we only care about the requirement nums[i - 2] == nums[i], then we need to get the max freq for both of the odd & even idx inorder to get the result using (total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even), now bring the second requirement nums[i] != nums[i-1] in and think of what if the number with the max freq is same for both of the even/odd idx ,then we either change the numbers with max freq in odd idx or change the numbers with max freq in even idx and thats why we need to introduce the second max freq for both of the odd&even.\\n\\n    int minimumOperations(vector<int>& nums) {\\n        if (nums.size()==1)\\n            return 0;\\n       \\n        unordered_map<int,int> evenmp,oddmp;\\n        \\n        \\n        for (int i=0;i<nums.size();i+=2)\\n        {\\n            evenmp[nums[i]]++;\\n        }\\n        \\n        \\n        \\n        \\n        for (int i=1;i<nums.size();i+=2)\\n        {\\n             oddmp[nums[i]]++;\\n        }\\n        \\n        int maxfreqeven=0;\\n        int secondmaxfreqeven=0;\\n        int maxelementeven;\\n        \\n        for (auto x:evenmp)\\n        {\\n            int element=x.first;\\n            int freq=x.second;\\n            if (freq>=maxfreqeven)\\n            {\\n                secondmaxfreqeven=maxfreqeven;\\n                maxfreqeven=freq;\\n                maxelementeven=element;\\n            }\\n            else if (freq>=secondmaxfreqeven)\\n            {\\n                secondmaxfreqeven=freq;\\n            }\\n        }\\n        \\n        int maxfreqodd=0;\\n        int secondmaxfreqodd=0;\\n        int maxelementodd;\\n        \\n        \\n         for (auto x:oddmp)\\n        {\\n            int element=x.first;\\n            int freq=x.second;\\n            if (freq>=maxfreqodd)\\n            {\\n                secondmaxfreqodd=maxfreqodd;\\n                maxfreqodd=freq;\\n                maxelementodd=element;\\n            }\\n            else if (freq>=secondmaxfreqodd)\\n            {\\n                secondmaxfreqodd=freq;\\n            }\\n        }\\n        \\n        \\n        if (maxelementodd!=maxelementeven)\\n        {\\n            return nums.size()-(maxfreqeven+maxfreqodd);\\n        }\\n        else\\n        {\\n            return (min(nums.size()-(maxfreqeven+secondmaxfreqodd),nums.size()-(secondmaxfreqeven+maxfreqodd)));\\n        }\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //@jionghongli\\n    //let\\'s say we only care about the requirement nums[i - 2] == nums[i], then we need to get the max freq for both of the odd & even idx inorder to get the result using (total numbers in odd idx - max freq in odd) + (total numbers in even idx - max freq in even), now bring the second requirement nums[i] != nums[i-1] in and think of what if the number with the max freq is same for both of the even/odd idx ,then we either change the numbers with max freq in odd idx or change the numbers with max freq in even idx and thats why we need to introduce the second max freq for both of the odd&even.\\n\\n    int minimumOperations(vector<int>& nums) {\\n        if (nums.size()==1)\\n            return 0;\\n       \\n        unordered_map<int,int> evenmp,oddmp;\\n        \\n        \\n        for (int i=0;i<nums.size();i+=2)\\n        {\\n            evenmp[nums[i]]++;\\n        }\\n        \\n        \\n        \\n        \\n        for (int i=1;i<nums.size();i+=2)\\n        {\\n             oddmp[nums[i]]++;\\n        }\\n        \\n        int maxfreqeven=0;\\n        int secondmaxfreqeven=0;\\n        int maxelementeven;\\n        \\n        for (auto x:evenmp)\\n        {\\n            int element=x.first;\\n            int freq=x.second;\\n            if (freq>=maxfreqeven)\\n            {\\n                secondmaxfreqeven=maxfreqeven;\\n                maxfreqeven=freq;\\n                maxelementeven=element;\\n            }\\n            else if (freq>=secondmaxfreqeven)\\n            {\\n                secondmaxfreqeven=freq;\\n            }\\n        }\\n        \\n        int maxfreqodd=0;\\n        int secondmaxfreqodd=0;\\n        int maxelementodd;\\n        \\n        \\n         for (auto x:oddmp)\\n        {\\n            int element=x.first;\\n            int freq=x.second;\\n            if (freq>=maxfreqodd)\\n            {\\n                secondmaxfreqodd=maxfreqodd;\\n                maxfreqodd=freq;\\n                maxelementodd=element;\\n            }\\n            else if (freq>=secondmaxfreqodd)\\n            {\\n                secondmaxfreqodd=freq;\\n            }\\n        }\\n        \\n        \\n        if (maxelementodd!=maxelementeven)\\n        {\\n            return nums.size()-(maxfreqeven+maxfreqodd);\\n        }\\n        else\\n        {\\n            return (min(nums.size()-(maxfreqeven+secondmaxfreqodd),nums.size()-(secondmaxfreqeven+maxfreqodd)));\\n        }\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1789456,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "The goal is to make elements at even indices as well as odd indices same but element at even index != element at odd index. Eg. [x1, x2, x1, x2, x1, x2] , x1!=x2"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "tricky tricky...."
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Can anyone mark my mistake in below code do comment in out in my code please \\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                freq[nums[i]]++;\\n            } else {\\n                freq[-nums[i]]++;\\n            }\\n        }\\n\\n        int max1 = 0, max2 = 0, a = 0, b = 0;\\n\\n        for (auto it : freq) {\\n            if (it.second > max1) {\\n                max1 = it.second;\\n                a = it.first;\\n            }\\n        }\\n\\n        int max11 = 0, max22 = 0;\\n\\n        for (auto it : freq) {\\n            if (it.first != a && it.second > max11) {\\n                max11 = it.second;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.second > max2) {\\n                max2 = it.second;\\n                b = it.first;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.first != b && it.second > max22) {\\n                max22 = it.second;\\n            }\\n        }\\n\\n        if (max1 != max2) {\\n            int c = max1 + max2;\\n            return n - c;\\n        } else {\\n            ans = min(n - max2 - max11, n - max22 - max1);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "jatindigra",
                        "content": "nah bruh this ain\\'t medium xd"
                    }
                ]
            },
            {
                "id": 1973332,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "The goal is to make elements at even indices as well as odd indices same but element at even index != element at odd index. Eg. [x1, x2, x1, x2, x1, x2] , x1!=x2"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "tricky tricky...."
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Can anyone mark my mistake in below code do comment in out in my code please \\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                freq[nums[i]]++;\\n            } else {\\n                freq[-nums[i]]++;\\n            }\\n        }\\n\\n        int max1 = 0, max2 = 0, a = 0, b = 0;\\n\\n        for (auto it : freq) {\\n            if (it.second > max1) {\\n                max1 = it.second;\\n                a = it.first;\\n            }\\n        }\\n\\n        int max11 = 0, max22 = 0;\\n\\n        for (auto it : freq) {\\n            if (it.first != a && it.second > max11) {\\n                max11 = it.second;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.second > max2) {\\n                max2 = it.second;\\n                b = it.first;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.first != b && it.second > max22) {\\n                max22 = it.second;\\n            }\\n        }\\n\\n        if (max1 != max2) {\\n            int c = max1 + max2;\\n            return n - c;\\n        } else {\\n            ans = min(n - max2 - max11, n - max22 - max1);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "jatindigra",
                        "content": "nah bruh this ain\\'t medium xd"
                    }
                ]
            },
            {
                "id": 1884154,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "The goal is to make elements at even indices as well as odd indices same but element at even index != element at odd index. Eg. [x1, x2, x1, x2, x1, x2] , x1!=x2"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "tricky tricky...."
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Can anyone mark my mistake in below code do comment in out in my code please \\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                freq[nums[i]]++;\\n            } else {\\n                freq[-nums[i]]++;\\n            }\\n        }\\n\\n        int max1 = 0, max2 = 0, a = 0, b = 0;\\n\\n        for (auto it : freq) {\\n            if (it.second > max1) {\\n                max1 = it.second;\\n                a = it.first;\\n            }\\n        }\\n\\n        int max11 = 0, max22 = 0;\\n\\n        for (auto it : freq) {\\n            if (it.first != a && it.second > max11) {\\n                max11 = it.second;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.second > max2) {\\n                max2 = it.second;\\n                b = it.first;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.first != b && it.second > max22) {\\n                max22 = it.second;\\n            }\\n        }\\n\\n        if (max1 != max2) {\\n            int c = max1 + max2;\\n            return n - c;\\n        } else {\\n            ans = min(n - max2 - max11, n - max22 - max1);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "jatindigra",
                        "content": "nah bruh this ain\\'t medium xd"
                    }
                ]
            },
            {
                "id": 1703369,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "The goal is to make elements at even indices as well as odd indices same but element at even index != element at odd index. Eg. [x1, x2, x1, x2, x1, x2] , x1!=x2"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "tricky tricky...."
                    },
                    {
                        "username": "Rai_2002",
                        "content": "Can anyone mark my mistake in below code do comment in out in my code please \\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> freq;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (i % 2 == 0) {\\n                freq[nums[i]]++;\\n            } else {\\n                freq[-nums[i]]++;\\n            }\\n        }\\n\\n        int max1 = 0, max2 = 0, a = 0, b = 0;\\n\\n        for (auto it : freq) {\\n            if (it.second > max1) {\\n                max1 = it.second;\\n                a = it.first;\\n            }\\n        }\\n\\n        int max11 = 0, max22 = 0;\\n\\n        for (auto it : freq) {\\n            if (it.first != a && it.second > max11) {\\n                max11 = it.second;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.second > max2) {\\n                max2 = it.second;\\n                b = it.first;\\n            }\\n        }\\n\\n        for (auto it : freq) {\\n            if (it.first != b && it.second > max22) {\\n                max22 = it.second;\\n            }\\n        }\\n\\n        if (max1 != max2) {\\n            int c = max1 + max2;\\n            return n - c;\\n        } else {\\n            ans = min(n - max2 - max11, n - max22 - max1);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "jatindigra",
                        "content": "nah bruh this ain\\'t medium xd"
                    }
                ]
            }
        ]
    }
]