[
    {
        "title": "Minimum Number of Operations to Make Arrays Similar",
        "question_content": "You are given two positive integer arrays nums and target, of the same length.\nIn one operation, you can choose any two distinct indices i and j where 0 <= i, j < nums.length and:\n\n\tset nums[i] = nums[i] + 2 and\n\tset nums[j] = nums[j] - 2.\n\nTwo arrays are considered to be similar if the frequency of each element is the same.\nReturn the minimum number of operations required to make nums similar to target. The test cases are generated such that nums can always be similar to target.\n&nbsp;\nExample 1:\n\nInput: nums = [8,12,6], target = [2,14,10]\nOutput: 2\nExplanation: It is possible to make nums similar to target in two operations:\n- Choose i = 0 and j = 2, nums = [10,12,4].\n- Choose i = 1 and j = 2, nums = [10,14,2].\nIt can be shown that 2 is the minimum number of operations needed.\n\nExample 2:\n\nInput: nums = [1,2,5], target = [4,1,3]\nOutput: 1\nExplanation: We can make nums similar to target in one operation:\n- Choose i = 1 and j = 2, nums = [1,4,3].\n\nExample 3:\n\nInput: nums = [1,1,1,1,1], target = [1,1,1,1,1]\nOutput: 0\nExplanation: The array nums is already similiar to target.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length == target.length\n\t1 <= n <= 105\n\t1 <= nums[i], target[i] <= 106\n\tIt is possible to make nums similar to target.",
        "solutions": [
            {
                "id": 2734189,
                "title": "c-python-sort-odds-and-evens",
                "content": "# **Intuition**\\nTry to solve the simpler question that,\\n in one operation we can do:\\n`A[i] = A[i] + 1`\\n`A[j] = A[j] - 1`\\n\\nWe need to sort `A` and `B`,\\nand accumulate the difference `res = sum(A[i] - B[i])`,\\nand `return res / 2`\\n<br>\\n\\n# **Explanation**\\nIn this problem,\\n`A[i]` and `B[i]` won\\'t change parity (odd or even)\\nall evens play the game together,\\nall odds play the game together.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**C++**\\n```cpp\\n    long long makeSimilar(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> AA(2), BB(2);\\n        for(int a: A) AA[a % 2].push_back(a);\\n        for(int b: B) BB[b % 2].push_back(b);\\n        sort(AA[0].begin(), AA[0].end());\\n        sort(AA[1].begin(), AA[1].end());\\n        sort(BB[0].begin(), BB[0].end());\\n        sort(BB[1].begin(), BB[1].end());\\n\\n        long long res = 0;\\n        for (int i = 0; i < AA[0].size(); ++i)\\n            res += abs(AA[0][i] - BB[0][i]) / 2;\\n        for (int i = 0; i < AA[1].size(); ++i)\\n            res += abs(AA[1][i] - BB[1][i]) / 2;\\n        return res / 2;\\n\\n    }\\n```\\n**Python**\\n```py\\n    def makeSimilar(self, A, B):\\n        A1 = sorted(a for a in A if a % 2)\\n        B1 = sorted(a for a in B if a % 2)\\n        A2 = sorted(a for a in A if a % 2 == 0)\\n        B2 = sorted(a for a in B if a % 2 == 0)\\n        res1 = sum(abs(a - b) // 2 for a,b in zip(A1, B1))\\n        res2 = sum(abs(a - b) // 2 for a,b in zip(A2, B2))\\n        return (res1 + res2) // 2\\n```\\n**Python**\\nFrom @Bakerston\\n```py\\n    def makeSimilar(self, A, B):\\n        A.sort(key = lambda a: (a & 1, a))\\n        B.sort(key = lambda a: (a & 1, a))\\n        return sum(abs(a - b) for a,b in zip(A, B)) // 4\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\n    long long makeSimilar(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> AA(2), BB(2);\\n        for(int a: A) AA[a % 2].push_back(a);\\n        for(int b: B) BB[b % 2].push_back(b);\\n        sort(AA[0].begin(), AA[0].end());\\n        sort(AA[1].begin(), AA[1].end());\\n        sort(BB[0].begin(), BB[0].end());\\n        sort(BB[1].begin(), BB[1].end());\\n\\n        long long res = 0;\\n        for (int i = 0; i < AA[0].size(); ++i)\\n            res += abs(AA[0][i] - BB[0][i]) / 2;\\n        for (int i = 0; i < AA[1].size(); ++i)\\n            res += abs(AA[1][i] - BB[1][i]) / 2;\\n        return res / 2;\\n\\n    }\\n```\n```py\\n    def makeSimilar(self, A, B):\\n        A1 = sorted(a for a in A if a % 2)\\n        B1 = sorted(a for a in B if a % 2)\\n        A2 = sorted(a for a in A if a % 2 == 0)\\n        B2 = sorted(a for a in B if a % 2 == 0)\\n        res1 = sum(abs(a - b) // 2 for a,b in zip(A1, B1))\\n        res2 = sum(abs(a - b) // 2 for a,b in zip(A2, B2))\\n        return (res1 + res2) // 2\\n```\n```py\\n    def makeSimilar(self, A, B):\\n        A.sort(key = lambda a: (a & 1, a))\\n        B.sort(key = lambda a: (a & 1, a))\\n        return sum(abs(a - b) for a,b in zip(A, B)) // 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734078,
                "title": "c-java-python-sort-odd-and-even-explained-1-liner",
                "content": "\\n**Explanation**\\n* Guarantee of an answer means 2 things: \\n\\t - The number of odd and even numbers in both arrays is same\\n\\t - number_of_increments(odd array) + number_of_increments(even array) == number_of_decrements(odd array) + number_of_decrements(even array)\\n* Divide arrays in to odd and even groups and sort them\\n* Compare each index of odd arrays. We only count increments because we know a complimentary decrement must exist. Further, in one operation we increment by 2 and decrement by 2. This pair is defined as 1 operation. \\n* Now do same for even array\\n\\n*Time complexity: O(nlogn)*\\n\\n**C++**:\\n```\\nlong long makeSimilar(vector<int>& A, vector<int>& B) {\\n\\tsort(A.begin(), A.end()); sort(B.begin(), B.end());\\n\\tvector<int> oA, eA, oB, eB;\\n\\tfor (int& x: A) (x % 2) ? oA.push_back(x) : eA.push_back(x);\\n\\tfor (int& x: B) (x % 2) ? oB.push_back(x) : eB.push_back(x);\\n\\tauto incCount = [&](vector<int>& a, vector<int> &b, long long ans = 0) {\\n\\t\\tfor (int i = 0; i < a.size(); i++)\\n\\t\\t\\tif (a[i] > b[i]) ans += (a[i] - b[i]) / 2;\\n\\t\\treturn ans;\\n\\t};\\n\\treturn incCount(oA, oB) + incCount(eA, eB);\\n}\\n```\\n\\n```\\n# Sort by even inplace\\nlong long makeSimilar(vector<int>& A, vector<int>& B, long long ans = 0) {\\n\\tauto sortByEven = [](int a, int b) {return (a&1 && b&1 || !(a&1) && !(b&1)) ? a < b: b&1;};\\n\\tsort(A.begin(), A.end(), sortByEven);\\n\\tsort(B.begin(), B.end(), sortByEven);\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\tans += abs(A[i] - B[i]);\\n\\treturn ans / 4;\\n}\\n```\\n\\t\\n**Java**:\\n```\\npublic long makeSimilar(int[] A, int[] B) {\\n\\tArrays.sort(A); Arrays.sort(B);\\n\\tList<Integer> oA = new ArrayList(), eA = new ArrayList(), \\n\\toB = new ArrayList(), eB = new ArrayList();\\n\\tfor (int x: A) {\\n\\t\\tif (x % 2 == 1) oA.add(x);\\n\\t\\telse eA.add(x);\\n\\t}\\n\\tfor (int x: B) {\\n\\t\\tif (x % 2 == 1) oB.add(x);\\n\\t\\telse eB.add(x);\\n\\t}\\n\\tlong ans = 0;\\n\\tfor (int i = 0; i < oA.size(); i++)\\n\\t  if (oA.get(i) > oB.get(i)) \\n\\t\\t  ans += (oA.get(i) - oB.get(i)) / 2;\\n\\tfor (int i = 0; i < eA.size(); i++)\\n\\t  if (eA.get(i) > eB.get(i)) \\n\\t\\t  ans += (eA.get(i) - eB.get(i)) / 2;\\n\\treturn ans;\\n}\\n```\\n\\n**Python3**:\\n```\\ndef makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n\\tonums = sorted([x for x in nums if x % 2])\\n\\tenums = sorted([x for x in nums if x % 2 == 0])\\n\\totar = sorted([x for x in target if x % 2])\\n\\tetar = sorted([x for x in target if x % 2 == 0])\\n\\treturn sum((x - y) // 2 for x, y in zip(onums, otar) if x > y) + sum((x - y) // 2 for x, y in zip(enums, etar) if x > y)\\n```\\n**Python3 1 liner**:\\n```\\ndef makeSimilar(self, A, B, K = lambda x: (x & 1, x)):\\n\\treturn sum(abs(x - y) for x, y in zip(sorted(A, key = K), sorted(B, key = K))) // 4\\n```\\n```\\ndef makeSimilar(self, A, B, f = lambda A: sorted(A, key = lambda x: (x & 1, x))):\\n\\treturn sum(abs(x - y) for x, y in zip(f(A), f(B))) // 4\\n```\\n```\\nclass Solution:makeSimilar=lambda self,A,B,f=lambda A:sorted(A,key=lambda x:(x&1,x)):sum(abs(x-y) for x,y in zip(f(A),f(B)))//4\\n```",
                "solutionTags": [],
                "code": "```\\nlong long makeSimilar(vector<int>& A, vector<int>& B) {\\n\\tsort(A.begin(), A.end()); sort(B.begin(), B.end());\\n\\tvector<int> oA, eA, oB, eB;\\n\\tfor (int& x: A) (x % 2) ? oA.push_back(x) : eA.push_back(x);\\n\\tfor (int& x: B) (x % 2) ? oB.push_back(x) : eB.push_back(x);\\n\\tauto incCount = [&](vector<int>& a, vector<int> &b, long long ans = 0) {\\n\\t\\tfor (int i = 0; i < a.size(); i++)\\n\\t\\t\\tif (a[i] > b[i]) ans += (a[i] - b[i]) / 2;\\n\\t\\treturn ans;\\n\\t};\\n\\treturn incCount(oA, oB) + incCount(eA, eB);\\n}\\n```\n```\\n# Sort by even inplace\\nlong long makeSimilar(vector<int>& A, vector<int>& B, long long ans = 0) {\\n\\tauto sortByEven = [](int a, int b) {return (a&1 && b&1 || !(a&1) && !(b&1)) ? a < b: b&1;};\\n\\tsort(A.begin(), A.end(), sortByEven);\\n\\tsort(B.begin(), B.end(), sortByEven);\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\tans += abs(A[i] - B[i]);\\n\\treturn ans / 4;\\n}\\n```\n```\\npublic long makeSimilar(int[] A, int[] B) {\\n\\tArrays.sort(A); Arrays.sort(B);\\n\\tList<Integer> oA = new ArrayList(), eA = new ArrayList(), \\n\\toB = new ArrayList(), eB = new ArrayList();\\n\\tfor (int x: A) {\\n\\t\\tif (x % 2 == 1) oA.add(x);\\n\\t\\telse eA.add(x);\\n\\t}\\n\\tfor (int x: B) {\\n\\t\\tif (x % 2 == 1) oB.add(x);\\n\\t\\telse eB.add(x);\\n\\t}\\n\\tlong ans = 0;\\n\\tfor (int i = 0; i < oA.size(); i++)\\n\\t  if (oA.get(i) > oB.get(i)) \\n\\t\\t  ans += (oA.get(i) - oB.get(i)) / 2;\\n\\tfor (int i = 0; i < eA.size(); i++)\\n\\t  if (eA.get(i) > eB.get(i)) \\n\\t\\t  ans += (eA.get(i) - eB.get(i)) / 2;\\n\\treturn ans;\\n}\\n```\n```\\ndef makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n\\tonums = sorted([x for x in nums if x % 2])\\n\\tenums = sorted([x for x in nums if x % 2 == 0])\\n\\totar = sorted([x for x in target if x % 2])\\n\\tetar = sorted([x for x in target if x % 2 == 0])\\n\\treturn sum((x - y) // 2 for x, y in zip(onums, otar) if x > y) + sum((x - y) // 2 for x, y in zip(enums, etar) if x > y)\\n```\n```\\ndef makeSimilar(self, A, B, K = lambda x: (x & 1, x)):\\n\\treturn sum(abs(x - y) for x, y in zip(sorted(A, key = K), sorted(B, key = K))) // 4\\n```\n```\\ndef makeSimilar(self, A, B, f = lambda A: sorted(A, key = lambda x: (x & 1, x))):\\n\\treturn sum(abs(x - y) for x, y in zip(f(A), f(B))) // 4\\n```\n```\\nclass Solution:makeSimilar=lambda self,A,B,f=lambda A:sorted(A,key=lambda x:(x&1,x)):sum(abs(x-y) for x,y in zip(f(A),f(B)))//4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734100,
                "title": "break-into-odd-even",
                "content": "# Intuition/Approach\\n\\nWorking on the whole set seems difficult as we don\\'t know if we can even increase a number to a certain number. Intuition came that we can divide numbers in both nums and target into 2 groups of odd and even number. After that, we will know that for a set of odd(nums) we can definitely make any number in this set equal to any no. in odd(target). So we can just sort all the 4 arrays(target(odd),target(even),nums(odd),nums(even)). \\n **The problem now boils down to making nums(odd) equal to target(odd) and nums(even) equal to target(even)**.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        long long count = 0;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> odd1,odd2,even1,even2;\\n        \\n        for(int i:nums){\\n            if(i%2==0)even1.push_back(i);\\n            else\\n                odd1.push_back(i);\\n        }\\n         for(int i:target){\\n            if(i%2==0)even2.push_back(i);\\n            else\\n                odd2.push_back(i);\\n        }\\n        \\n\\n        for(int i =0;i<odd1.size();i++){\\n            if(odd1[i]<odd2[i]){\\n                count+= ((odd2[i]-odd1[i])/2);\\n            }\\n        }\\n         for(int i =0;i<even1.size();i++){\\n            if(even1[i]<even2[i]){\\n                count+= ((even2[i]-even1[i])/2);\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        long long count = 0;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> odd1,odd2,even1,even2;\\n        \\n        for(int i:nums){\\n            if(i%2==0)even1.push_back(i);\\n            else\\n                odd1.push_back(i);\\n        }\\n         for(int i:target){\\n            if(i%2==0)even2.push_back(i);\\n            else\\n                odd2.push_back(i);\\n        }\\n        \\n\\n        for(int i =0;i<odd1.size();i++){\\n            if(odd1[i]<odd2[i]){\\n                count+= ((odd2[i]-odd1[i])/2);\\n            }\\n        }\\n         for(int i =0;i<even1.size();i++){\\n            if(even1[i]<even2[i]){\\n                count+= ((even2[i]-even1[i])/2);\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734080,
                "title": "odd-even-pointers",
                "content": "We need to match odd numbers in `n` with odd numbers in `target`, and even with even.\\n\\nWe sort both arrays first. We use two pointers to indicate the smallest odd and even element in `target`.\\n\\nWe pick the next smallest number from `n`, and match with the next smallest (odd or even) in `target`. \\n\\nThe cost is `res += abs(n[i] - t[j]) / 2`. Note that this results in double-counting, so we return `res / 2` in the end.\\n\\n**C++**\\n```cpp\\nlong long makeSimilar(vector<int>& n, vector<int>& t) {\\n    sort(begin(n), end(n));\\n    sort(begin(t), end(t));\\n    long long res = 0;\\n    for (int i = 0, j1 = 0, j2 = 0; i < n.size(); ++i) {\\n        int &j = n[i] % 2 ? j1 : j2;\\n        while (n[i] % 2 != t[j] % 2)\\n            ++j;\\n        res += abs(n[i] - t[j]) / 2;\\n        ++j;\\n    }\\n    return res / 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long makeSimilar(vector<int>& n, vector<int>& t) {\\n    sort(begin(n), end(n));\\n    sort(begin(t), end(t));\\n    long long res = 0;\\n    for (int i = 0, j1 = 0, j2 = 0; i < n.size(); ++i) {\\n        int &j = n[i] % 2 ? j1 : j2;\\n        while (n[i] % 2 != t[j] % 2)\\n            ++j;\\n        res += abs(n[i] - t[j]) / 2;\\n        ++j;\\n    }\\n    return res / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734426,
                "title": "precise-c-code-with-explantaion",
                "content": "The main hint of this question is that the answer always exists, the test cases have been generated such. One important observation is that odd elements from nums must be made into odd elements in target and same for even elements. Therefore, I created 4 vectors for odd and even elements of nums and target, ans sorted them. The idea behind sorting that the minimum diffrence must be returned. Regarding the answer, the answer is only updated when the odd element of target or even element is greater than the corresponding element of nums. Note that it can also be done that answer is only updated when target element is less than the corresponding nums element to get the same answer. Thanks for reading!\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans=0;\\n        vector<int> oddn;\\n        vector<int> evenn;\\n        vector<int> oddt;\\n        vector<int> event;\\n        for(auto i:nums){\\n            if(i%2==1)\\n                oddn.push_back(i);\\n            else\\n                evenn.push_back(i);\\n        }\\n        for(auto i:target){\\n            if(i%2==1)\\n                oddt.push_back(i);\\n            else\\n                event.push_back(i);\\n        }\\n        \\n        sort(oddn.begin(),oddn.end());\\n        sort(evenn.begin(),evenn.end());\\n        sort(oddt.begin(),oddt.end());\\n        sort(event.begin(),event.end());\\n        \\n        for(int i=0;i<oddn.size();i++){\\n            if(oddt[i] >oddn[i] )\\n                ans+=(oddt[i]-oddn[i]);\\n        }\\n        for(int i=0;i<evenn.size();i++){\\n            if(event[i]>evenn[i])\\n                ans+=(event[i]-evenn[i]);\\n        }\\n        return ans/2;\\n    }\\n};\\n```\\nUpvote if found helpful. Thanks.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans=0;\\n        vector<int> oddn;\\n        vector<int> evenn;\\n        vector<int> oddt;\\n        vector<int> event;\\n        for(auto i:nums){\\n            if(i%2==1)\\n                oddn.push_back(i);\\n            else\\n                evenn.push_back(i);\\n        }\\n        for(auto i:target){\\n            if(i%2==1)\\n                oddt.push_back(i);\\n            else\\n                event.push_back(i);\\n        }\\n        \\n        sort(oddn.begin(),oddn.end());\\n        sort(evenn.begin(),evenn.end());\\n        sort(oddt.begin(),oddt.end());\\n        sort(event.begin(),event.end());\\n        \\n        for(int i=0;i<oddn.size();i++){\\n            if(oddt[i] >oddn[i] )\\n                ans+=(oddt[i]-oddn[i]);\\n        }\\n        for(int i=0;i<evenn.size();i++){\\n            if(event[i]>evenn[i])\\n                ans+=(event[i]-evenn[i]);\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734387,
                "title": "python-3-3-line-greedy",
                "content": "Assume we change `N[i]` into `T[j]`, they must be differ by muiltiple 2s, thus have the same Parity: odd to odd, even to even.\\n- Split odd and even numbers in `N` and `T`.\\n\\nGreedy approach\\n- Sort `N` and `T`.\\n\\nThus we can sort both `N` and `T` using two comparators: `x % 2` and `x`.\\n\\nFor example:\\n\\n[4, 1, 5, 3, 2] -> [2, 4 **|** 1, 3, 5]\\n\\nThen we calculate the total difference between `N[i]` and `T[i]`, each operation reduces the difference by `4`.\\n\\n```\\ndef makeSimilar(self, N: List[int], T: List[int]) -> int:\\n        N.sort(key=lambda x: [x % 2, x])\\n        T.sort(key=lambda x: [x % 2, x])\\n        \\n        return sum(abs(n - t) for n, t in zip(N, T)) // 4\\n```",
                "solutionTags": [],
                "code": "```\\ndef makeSimilar(self, N: List[int], T: List[int]) -> int:\\n        N.sort(key=lambda x: [x % 2, x])\\n        T.sort(key=lambda x: [x % 2, x])\\n        \\n        return sum(abs(n - t) for n, t in zip(N, T)) // 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734085,
                "title": "python-rust-c-simply-consider-evens-odds-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs sorting and splitting of arrays into even and odd parts. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/828439809/) | **992 ms (100.00%)** | **32.9 MB  (58.33%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828447504/) | **45 ms (100.00%)** | **4.1 MB (100.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828437747/) | **169 ms (100.00%)** | **87.0 MB  (11.11%)** |\\n<iframe src=\"https://leetcode.com/playground/h6NyEdxP/shared\" frameBorder=\"0\" width=\"800\" height=\"800\"></iframe>",
                "solutionTags": [],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs sorting and splitting of arrays into even and odd parts. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/828439809/) | **992 ms (100.00%)** | **32.9 MB  (58.33%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828447504/) | **45 ms (100.00%)** | **4.1 MB (100.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828437747/) | **169 ms (100.00%)** | **87.0 MB  (11.11%)** |\\n<iframe src=\"https://leetcode.com/playground/h6NyEdxP/shared\" frameBorder=\"0\" width=\"800\" height=\"800\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3558393,
                "title": "c-simple-sort-odd-even",
                "content": "solve for odd and even different - different.\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(2*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> o1,o2,e1,e2;\\n        int i;\\n        for(i = 0; i < nums.size(); i++){\\n            if(nums[i]&1){\\n                o1.push_back(nums[i]);\\n            }else{\\n                e1.push_back(nums[i]);\\n            }\\n            if(target[i]&1){\\n                o2.push_back(target[i]);\\n            }else{\\n                e2.push_back(target[i]);\\n            }\\n        }\\n        sort(o1.begin(),o1.end());\\n        sort(o2.begin(),o2.end());\\n        sort(e1.begin(),e1.end());\\n        sort(e2.begin(),e2.end());\\n        long long int ans = 0;\\n        for(i = 0; i < e1.size(); i++){\\n            ans += abs(e1[i]-e2[i]);\\n        }\\n        for(i = 0; i < o1.size(); i++){\\n            ans += abs(o1[i]-o2[i]);\\n        }\\n        return (ans>>2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> o1,o2,e1,e2;\\n        int i;\\n        for(i = 0; i < nums.size(); i++){\\n            if(nums[i]&1){\\n                o1.push_back(nums[i]);\\n            }else{\\n                e1.push_back(nums[i]);\\n            }\\n            if(target[i]&1){\\n                o2.push_back(target[i]);\\n            }else{\\n                e2.push_back(target[i]);\\n            }\\n        }\\n        sort(o1.begin(),o1.end());\\n        sort(o2.begin(),o2.end());\\n        sort(e1.begin(),e1.end());\\n        sort(e2.begin(),e2.end());\\n        long long int ans = 0;\\n        for(i = 0; i < e1.size(); i++){\\n            ans += abs(e1[i]-e2[i]);\\n        }\\n        for(i = 0; i < o1.size(); i++){\\n            ans += abs(o1[i]-o2[i]);\\n        }\\n        return (ans>>2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742722,
                "title": "simple-c-custom-sort-precise-and-less-code",
                "content": "# Sort and separate odd and even numbers in an Array using custom comparator\\n```\\nbool comp(int a,int b){\\n   if(a%2==b%2) return a<b;\\n    if(a%2==1 and b%2==0){\\n        return false;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(begin(nums),end(nums),comp);\\n        sort(begin(target),end(target),comp);\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]!=target[i])\\n                ans+=(abs(nums[i]-target[i]))/2;\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(int a,int b){\\n   if(a%2==b%2) return a<b;\\n    if(a%2==1 and b%2==0){\\n        return false;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(begin(nums),end(nums),comp);\\n        sort(begin(target),end(target),comp);\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]!=target[i])\\n                ans+=(abs(nums[i]-target[i]))/2;\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734139,
                "title": "python-simple-odd-even-sorting-o-nlogn-walmart-oa-india-simple-explanation",
                "content": "```\\nclass Solution:\\n    def makeSimilar(self, A: List[int], B: List[int]) -> int:\\n        if sum(A)!=sum(B): return 0\\n        # The first intuition is that only odd numbers can be chaged to odd numbers and even to even hence separate them\\n        # Now minimum steps to making the target to highest number in B is by converting max of A to max of B similarily\\n        # every number in A can be paired with a number in B by index hence sorting\\n        # now we need only the number of positives or number of negatives.\\n        oddA,evenA=[i for i in A if i%2],[i for i in A if i%2==0]\\n        oddB,evenB=[i for i in B if i%2],[i for i in B if i%2==0]        \\n        oddA.sort(),evenA.sort()\\n        oddB.sort(),evenB.sort()\\n        res=0\\n        for i,j in zip(oddA,oddB):\\n            if i>=j: res+=i-j\\n        \\n        for i,j in zip(evenA,evenB):\\n            if i>=j: res+=i-j\\n        \\n        return res//2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, A: List[int], B: List[int]) -> int:\\n        if sum(A)!=sum(B): return 0\\n        # The first intuition is that only odd numbers can be chaged to odd numbers and even to even hence separate them\\n        # Now minimum steps to making the target to highest number in B is by converting max of A to max of B similarily\\n        # every number in A can be paired with a number in B by index hence sorting\\n        # now we need only the number of positives or number of negatives.\\n        oddA,evenA=[i for i in A if i%2],[i for i in A if i%2==0]\\n        oddB,evenB=[i for i in B if i%2],[i for i in B if i%2==0]        \\n        oddA.sort(),evenA.sort()\\n        oddB.sort(),evenB.sort()\\n        res=0\\n        for i,j in zip(oddA,oddB):\\n            if i>=j: res+=i-j\\n        \\n        for i,j in zip(evenA,evenB):\\n            if i>=j: res+=i-j\\n        \\n        return res//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415765,
                "title": "c-sort-odds-evens-easy-to-understnad",
                "content": "````\\n-------\\n//try for diffrent odd and even numbers\\n-------\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> o1,o2,e1,e2;\\n        for(auto &i: nums){\\n            if(i&1){\\n                o1.push_back(i);\\n            }else{\\n                e1.push_back(i);\\n            }\\n        }\\n        for(auto &i: target){\\n            if(i&1){\\n                o2.push_back(i);\\n            }else{\\n                e2.push_back(i);\\n            }\\n        }\\n        long long int ans = 0;\\n        sort(o1.begin(),o1.end());\\n        sort(o2.begin(),o2.end());\\n        sort(e1.begin(),e1.end());\\n        sort(e2.begin(),e2.end());\\n        int i = 0, n = o1.size();\\n        for(i = 0; i < n; i++){\\n            ans += abs(o1[i]-o2[i]);\\n        }\\n        n = e1.size();\\n        for(i = 0; i < n; i++){\\n            ans += abs(e1[i]-e2[i]);\\n        }\\n        return (ans>>2);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "````\\n-------\\n//try for diffrent odd and even numbers\\n-------\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> o1,o2,e1,e2;\\n        for(auto &i: nums){\\n            if(i&1){\\n                o1.push_back(i);\\n            }else{\\n                e1.push_back(i);\\n            }\\n        }\\n        for(auto &i: target){\\n            if(i&1){\\n                o2.push_back(i);\\n            }else{\\n                e2.push_back(i);\\n            }\\n        }\\n        long long int ans = 0;\\n        sort(o1.begin(),o1.end());\\n        sort(o2.begin(),o2.end());\\n        sort(e1.begin(),e1.end());\\n        sort(e2.begin(),e2.end());\\n        int i = 0, n = o1.size();\\n        for(i = 0; i < n; i++){\\n            ans += abs(o1[i]-o2[i]);\\n        }\\n        n = e1.size();\\n        for(i = 0; i < n; i++){\\n            ans += abs(e1[i]-e2[i]);\\n        }\\n        return (ans>>2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739914,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        vector<int> oddNums,evenNums,oddTar,evenTar;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2 == 0){\\n                evenNums.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                oddNums.push_back(nums[i]);\\n            }\\n            if(target[i]%2 == 0){\\n                evenTar.push_back(target[i]);\\n            }\\n            else{\\n                oddTar.push_back(target[i]);\\n            }\\n        }\\n        \\n        long ans = 0;\\n        for(int i=0;i< oddNums.size();i++){\\n            ans += abs((oddNums[i] - oddTar[i]))/2;\\n        }\\n        for(int i=0;i< evenNums.size();i++){\\n            ans += abs((evenNums[i] - evenTar[i]))/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        vector<int> oddNums,evenNums,oddTar,evenTar;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2 == 0){\\n                evenNums.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                oddNums.push_back(nums[i]);\\n            }\\n            if(target[i]%2 == 0){\\n                evenTar.push_back(target[i]);\\n            }\\n            else{\\n                oddTar.push_back(target[i]);\\n            }\\n        }\\n        \\n        long ans = 0;\\n        for(int i=0;i< oddNums.size();i++){\\n            ans += abs((oddNums[i] - oddTar[i]))/2;\\n        }\\n        for(int i=0;i< evenNums.size();i++){\\n            ans += abs((evenNums[i] - evenTar[i]))/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734913,
                "title": "java-simple-code-easy-understanding",
                "content": "Answer exists, therefore we can say that number of odd elements  and even elements in both array are equal because we can increase or decrease the element by 2 only. \\nAdding +- 2 any element will not change even to odd or odd to even.\\nAfter sorting nearby elements will come closer so that answer will be minimize.\\nAnswer exist therefore it will compensate by another element further.\\n```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] % 2 == 1){\\n                nums[i] = -nums[i];\\n            }\\n            if(target[i] % 2 == 1){\\n                target[i] = -target[i];\\n            }\\n        }\\n        ArrayList<Integer> arr1 = new ArrayList<>();\\n        ArrayList<Integer> arr2 = new ArrayList<>();\\n        ArrayList<Integer> arr3 = new ArrayList<>();\\n        ArrayList<Integer> arr4 = new ArrayList<>();\\n        for(int i = 0; i< nums.length; i++){\\n            if(nums[i] < 0){\\n                arr1.add(nums[i]);\\n            }else{\\n                arr3.add(nums[i]);\\n            }\\n            if(target[i] < 0){\\n                arr2.add(target[i]);\\n            }else{\\n                arr4.add(target[i]);\\n            }\\n        }\\n        Collections.sort(arr1, (a, b) -> (b - a));\\n        \\n        Collections.sort(arr3);\\n        Collections.sort(arr2, (a, b) -> (b - a));\\n        Collections.sort(arr4);\\n        for(int i = 0; i < arr1.size(); i++){\\n            nums[i] = arr1.get(i);\\n            target[i] = arr2.get(i);\\n        }\\n        for(int i = arr1.size(); i < arr3.size() + arr1.size(); i++){\\n            nums[i] = arr3.get(i - arr1.size());\\n            target[i] = arr4.get(i - arr1.size());\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                nums[i] = -nums[i];\\n            }\\n            if(target[i] < 0){\\n                target[i] = -target[i];\\n            }\\n        }                     // till now i sorted the array in such a way that all odd numbers appears before even numbers in increasing order.\\n        long less = 0;    // it represents how many times we can decrement any number\\n        long more = 0; // it represents how many times we can increment any number\\n        long ans = 0;  // count minimum number so that nums and target array would be similar\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0){\\n                int diff = nums[i] - target[i];\\n                if(diff > 0){        // At 0th index we are calculating how many times we need to decrease  or increase element.\\n                    more = diff/2;\\n                    ans = ans + more;  // adding to the ans if difference is larger then we will decrease this element and assign half of the difference to \\'more\\' because this difference we will also have to increase in anyone element\\n                }else{\\n                    less = (-diff)/2;\\n                    ans = ans + less;    // similar to more\\n                }\\n            }else{\\n                int diff = nums[i] - target[i];\\n                if(diff >= 0){\\n                    if(less >= diff/2){\\n                        less = less - diff/2;       // if less is larger than difference, it means we have already that much value which is needed to be equal, then use that much diff and subtract from \\'less\\'\\n                    }else{\\n                        long t = diff - less*2;   // if difference is greater then use \\'less\\' as much as we can and then increase more variable which needed to make array element equal.\\n                        more = more + t/2;\\n                        ans = ans + t/2;\\n                        less = 0;\\n                    }\\n                }else{\\n                    if(more >= (-diff)/2){\\n                        more = more - (-diff)/2;   // similar like \\'less\\' case\\n                    }else{\\n                        long t = (-diff) - more*2;\\n                        less = less + t/2;\\n                        ans = ans + t/2;\\n                        more = 0;\\n                    }\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] % 2 == 1){\\n                nums[i] = -nums[i];\\n            }\\n            if(target[i] % 2 == 1){\\n                target[i] = -target[i];\\n            }\\n        }\\n        ArrayList<Integer> arr1 = new ArrayList<>();\\n        ArrayList<Integer> arr2 = new ArrayList<>();\\n        ArrayList<Integer> arr3 = new ArrayList<>();\\n        ArrayList<Integer> arr4 = new ArrayList<>();\\n        for(int i = 0; i< nums.length; i++){\\n            if(nums[i] < 0){\\n                arr1.add(nums[i]);\\n            }else{\\n                arr3.add(nums[i]);\\n            }\\n            if(target[i] < 0){\\n                arr2.add(target[i]);\\n            }else{\\n                arr4.add(target[i]);\\n            }\\n        }\\n        Collections.sort(arr1, (a, b) -> (b - a));\\n        \\n        Collections.sort(arr3);\\n        Collections.sort(arr2, (a, b) -> (b - a));\\n        Collections.sort(arr4);\\n        for(int i = 0; i < arr1.size(); i++){\\n            nums[i] = arr1.get(i);\\n            target[i] = arr2.get(i);\\n        }\\n        for(int i = arr1.size(); i < arr3.size() + arr1.size(); i++){\\n            nums[i] = arr3.get(i - arr1.size());\\n            target[i] = arr4.get(i - arr1.size());\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                nums[i] = -nums[i];\\n            }\\n            if(target[i] < 0){\\n                target[i] = -target[i];\\n            }\\n        }                     // till now i sorted the array in such a way that all odd numbers appears before even numbers in increasing order.\\n        long less = 0;    // it represents how many times we can decrement any number\\n        long more = 0; // it represents how many times we can increment any number\\n        long ans = 0;  // count minimum number so that nums and target array would be similar\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0){\\n                int diff = nums[i] - target[i];\\n                if(diff > 0){        // At 0th index we are calculating how many times we need to decrease  or increase element.\\n                    more = diff/2;\\n                    ans = ans + more;  // adding to the ans if difference is larger then we will decrease this element and assign half of the difference to \\'more\\' because this difference we will also have to increase in anyone element\\n                }else{\\n                    less = (-diff)/2;\\n                    ans = ans + less;    // similar to more\\n                }\\n            }else{\\n                int diff = nums[i] - target[i];\\n                if(diff >= 0){\\n                    if(less >= diff/2){\\n                        less = less - diff/2;       // if less is larger than difference, it means we have already that much value which is needed to be equal, then use that much diff and subtract from \\'less\\'\\n                    }else{\\n                        long t = diff - less*2;   // if difference is greater then use \\'less\\' as much as we can and then increase more variable which needed to make array element equal.\\n                        more = more + t/2;\\n                        ans = ans + t/2;\\n                        less = 0;\\n                    }\\n                }else{\\n                    if(more >= (-diff)/2){\\n                        more = more - (-diff)/2;   // similar like \\'less\\' case\\n                    }else{\\n                        long t = (-diff) - more*2;\\n                        less = less + t/2;\\n                        ans = ans + t/2;\\n                        more = 0;\\n                    }\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734792,
                "title": "java-100-fast-o-nlogn",
                "content": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        int len = nums.length, i, p = 0, j = 0, k = 0;\\n        long sum1 = 0, sum2 = 0;\\n        List<Integer> odd1 = new ArrayList<>();\\n        List<Integer> even1 = new ArrayList<>();\\n        for(i = 0; i < len; i++){\\n            if(nums[i] % 2 == 0)\\n                even1.add(nums[i]);\\n            else\\n                odd1.add(nums[i]);\\n        }\\n        for(i = 0; i < len; i++){\\n            if(target[i] % 2 == 0){\\n                sum1 += (long)Math.abs(even1.get(j) - target[i]);\\n                j++;\\n            }\\n            else{\\n                sum2 += (long)Math.abs(odd1.get(k) - target[i]);\\n                k++;\\n            }\\n        }\\n        sum1 /= 2;\\n        sum2 /= 2;\\n        return (sum1 + sum2) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        int len = nums.length, i, p = 0, j = 0, k = 0;\\n        long sum1 = 0, sum2 = 0;\\n        List<Integer> odd1 = new ArrayList<>();\\n        List<Integer> even1 = new ArrayList<>();\\n        for(i = 0; i < len; i++){\\n            if(nums[i] % 2 == 0)\\n                even1.add(nums[i]);\\n            else\\n                odd1.add(nums[i]);\\n        }\\n        for(i = 0; i < len; i++){\\n            if(target[i] % 2 == 0){\\n                sum1 += (long)Math.abs(even1.get(j) - target[i]);\\n                j++;\\n            }\\n            else{\\n                sum2 += (long)Math.abs(odd1.get(k) - target[i]);\\n                k++;\\n            }\\n        }\\n        sum1 /= 2;\\n        sum2 /= 2;\\n        return (sum1 + sum2) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734641,
                "title": "video-explanation-with-proof",
                "content": "https://www.youtube.com/watch?v=zFNdcUbUUvY",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=zFNdcUbUUvY",
                "codeTag": "Unknown"
            },
            {
                "id": 2734468,
                "title": "simple-solution-sorting",
                "content": "```\\n/*\\nAs the question states that answer is always possible which means \\nthe no(add operations) == no(subtract operations) \\nAs odd - even == odd && even - even == even\\nwe have to take care of odd and even values separately.\\n*/\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& tar) {\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        sort(tar.begin(), tar.end());\\n        vector<vector<int>> temp(4);\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] % 2){\\n                temp[0].push_back(nums[i]);\\n            }\\n            else{\\n                temp[2].push_back(nums[i]);\\n            }\\n            if(tar[i] % 2){\\n                temp[1].push_back(tar[i]);\\n            }\\n            else{\\n                temp[3].push_back(tar[i]);\\n            }\\n        }\\n        for(int i = 0; i < temp[0].size(); i++){\\n            ans += abs(temp[0][i] - temp[1][i]) / 2; // divide by 2 as we can +2 or -2\\n        }\\n        for(int i = 0; i < temp[2].size(); i++){\\n            ans += abs(temp[2][i] - temp[3][i]) / 2;\\n        }\\n        return ans / 2; // divide by 2 as we have to conisder 1 add and 1 subtract in a single operation\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n/*\\nAs the question states that answer is always possible which means \\nthe no(add operations) == no(subtract operations) \\nAs odd - even == odd && even - even == even\\nwe have to take care of odd and even values separately.\\n*/\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& tar) {\\n        long long ans = 0;\\n        sort(nums.begin(), nums.end());\\n        sort(tar.begin(), tar.end());\\n        vector<vector<int>> temp(4);\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] % 2){\\n                temp[0].push_back(nums[i]);\\n            }\\n            else{\\n                temp[2].push_back(nums[i]);\\n            }\\n            if(tar[i] % 2){\\n                temp[1].push_back(tar[i]);\\n            }\\n            else{\\n                temp[3].push_back(tar[i]);\\n            }\\n        }\\n        for(int i = 0; i < temp[0].size(); i++){\\n            ans += abs(temp[0][i] - temp[1][i]) / 2; // divide by 2 as we can +2 or -2\\n        }\\n        for(int i = 0; i < temp[2].size(); i++){\\n            ans += abs(temp[2][i] - temp[3][i]) / 2;\\n        }\\n        return ans / 2; // divide by 2 as we have to conisder 1 add and 1 subtract in a single operation\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734287,
                "title": "sort-odd-and-even-fully-explained-python",
                "content": "1. Seperate tha given nums and target arrays into two i.e., nums1 and target1 for even and nums2 and target2 for odd. Because, by adding multiples of 2 to an odd number, we can only can an odd number and same goes with even one.\\n\\n2. Now Sort them, because then only we will find the nearest number which can be acheived by either increasing or decreasing the number in nums.\\n\\n3. Now we can check for either the increasing case or the decreasing case of numbers to acheive the targets and store it in a variable.Because when an increase operation is performed automatically decrease should also be performed and both will be counted as a single operation. \\n\\n\\n```\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums1 = []\\n        target1 = []\\n        nums2 = []\\n        target2 = []\\n        nums.sort()\\n        target.sort()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                nums1.append(nums[i])\\n            else:\\n                nums2.append(nums[i])\\n            if target[i]%2==0:\\n                target1.append(target[i])\\n            else:\\n                target2.append(target[i])\\n        inc = 0\\n        dec = 0\\n        for i in range(len(nums1)):\\n            if nums1[i]<target1[i]:\\n                inc+=((target1[i]-nums1[i])//2) #dividing by 2 because to increase it by 2 you need 1 operation.\\n                \\n        for i in range(len(nums2)):\\n            if nums2[i]<target2[i]:\\n                inc+=((target2[i]-nums2[i])//2)\\n        return inc\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums1 = []\\n        target1 = []\\n        nums2 = []\\n        target2 = []\\n        nums.sort()\\n        target.sort()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                nums1.append(nums[i])\\n            else:\\n                nums2.append(nums[i])\\n            if target[i]%2==0:\\n                target1.append(target[i])\\n            else:\\n                target2.append(target[i])\\n        inc = 0\\n        dec = 0\\n        for i in range(len(nums1)):\\n            if nums1[i]<target1[i]:\\n                inc+=((target1[i]-nums1[i])//2) #dividing by 2 because to increase it by 2 you need 1 operation.\\n                \\n        for i in range(len(nums2)):\\n            if nums2[i]<target2[i]:\\n                inc+=((target2[i]-nums2[i])//2)\\n        return inc\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734093,
                "title": "python3-sortedlist-greedy-o-nlogn",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        odd_nums = SortedList([num for num in nums if num % 2 == 1])\\n        even_nums = SortedList([num for num in nums if num % 2 == 0])\\n        odd_target = SortedList([num for num in target if num % 2 == 1])\\n        even_target = SortedList([num for num in target if num % 2 == 0])\\n        ans = 0\\n        while odd_nums:\\n            ans += abs(odd_nums[0] - odd_target[0]) // 2\\n            odd_nums.pop(0)\\n            odd_target.remove(odd_target[0])\\n        while even_nums:\\n            ans += abs(even_nums[0] - even_target[0]) // 2\\n            even_nums.pop(0)\\n            even_target.remove(even_target[0])\\n        return ans // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        odd_nums = SortedList([num for num in nums if num % 2 == 1])\\n        even_nums = SortedList([num for num in nums if num % 2 == 0])\\n        odd_target = SortedList([num for num in target if num % 2 == 1])\\n        even_target = SortedList([num for num in target if num % 2 == 0])\\n        ans = 0\\n        while odd_nums:\\n            ans += abs(odd_nums[0] - odd_target[0]) // 2\\n            odd_nums.pop(0)\\n            odd_target.remove(odd_target[0])\\n        while even_nums:\\n            ans += abs(even_nums[0] - even_target[0]) // 2\\n            even_nums.pop(0)\\n            even_target.remove(even_target[0])\\n        return ans // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734090,
                "title": "python-straight-forward-solution",
                "content": "```\\n    def makeSimilar(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort(key = lambda x: (x % 2, x))\\n        target.sort(key = lambda x: (x % 2, x))\\n        \\n        res = 0\\n        for i in range(len(nums)):\\n            cnt = (nums[i] - target[i]) // 2\\n            if cnt > 0:\\n                res += cnt\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def makeSimilar(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort(key = lambda x: (x % 2, x))\\n        target.sort(key = lambda x: (x % 2, x))\\n        \\n        res = 0\\n        for i in range(len(nums)):\\n            cnt = (nums[i] - target[i]) // 2\\n            if cnt > 0:\\n                res += cnt\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3854494,
                "title": "most-easy-cpp-solution-100-beats-guys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) \\n    {\\n        long long ans = 0;\\n        vector<vector<int>> A(2);\\n        vector<vector<int>> B(2);\\n        for(const int num: nums)\\n        {\\n            A[num%2].push_back(num);\\n        }\\n        for(const int num: target)\\n        {\\n            B[num%2].push_back(num);\\n        }\\n        sort(A[0].begin() , A[0].end());\\n        sort(A[1].begin() , A[1].end());\\n        sort(B[0].begin() , B[0].end());\\n        sort(B[1].begin() , B[1].end());\\n\\n        for(int i=0; i<2; i++)\\n        {\\n            for(int j=0; j<A[i].size(); j++)\\n            {\\n                ans += abs(A[i][j]-B[i][j])/2;\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) \\n    {\\n        long long ans = 0;\\n        vector<vector<int>> A(2);\\n        vector<vector<int>> B(2);\\n        for(const int num: nums)\\n        {\\n            A[num%2].push_back(num);\\n        }\\n        for(const int num: target)\\n        {\\n            B[num%2].push_back(num);\\n        }\\n        sort(A[0].begin() , A[0].end());\\n        sort(A[1].begin() , A[1].end());\\n        sort(B[0].begin() , B[0].end());\\n        sort(B[1].begin() , B[1].end());\\n\\n        for(int i=0; i<2; i++)\\n        {\\n            for(int j=0; j<A[i].size(); j++)\\n            {\\n                ans += abs(A[i][j]-B[i][j])/2;\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464061,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        List<Integer>e1=new ArrayList<>();\\n        List<Integer>e2=new ArrayList<>();\\n        List<Integer>o1=new ArrayList<>();\\n        List<Integer>o2=new ArrayList<>();\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        long minop=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)e1.add(nums[i]);\\n            else o1.add(nums[i]);\\n            if(target[i]%2==0)e2.add(target[i]);\\n            else o2.add(target[i]);\\n        }\\n        for(int i=0;i<e1.size();i++)\\n        {\\n            if(e1.get(i)>e2.get(i)) minop+=(e1.get(i)-e2.get(i));\\n        }\\n        for(int i=0;i<o1.size();i++)\\n        {\\n            if(o1.get(i)>o2.get(i)) minop+=(o1.get(i)-o2.get(i));\\n        }\\n        return minop/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        List<Integer>e1=new ArrayList<>();\\n        List<Integer>e2=new ArrayList<>();\\n        List<Integer>o1=new ArrayList<>();\\n        List<Integer>o2=new ArrayList<>();\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        long minop=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)e1.add(nums[i]);\\n            else o1.add(nums[i]);\\n            if(target[i]%2==0)e2.add(target[i]);\\n            else o2.add(target[i]);\\n        }\\n        for(int i=0;i<e1.size();i++)\\n        {\\n            if(e1.get(i)>e2.get(i)) minop+=(e1.get(i)-e2.get(i));\\n        }\\n        for(int i=0;i<o1.size();i++)\\n        {\\n            if(o1.get(i)>o2.get(i)) minop+=(o1.get(i)-o2.get(i));\\n        }\\n        return minop/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945097,
                "title": "java-99-time-99-5-memory-o-n-nlogn",
                "content": "# Complexity\\n- Time complexity:\\nD - number of odd numbers, E - number of even numbers\\nO(N + 2N + 2 * (D log(D)) + 2 * (E log(E)) + N) =>\\n=> O(2N + 2(N + Dlog(D) + Elog(E))) =>\\n=> O(2 * (2N + Dlog(D) + Elog(E))) =>\\n=> O(2N + Dlog(D) + Elog(E)) => O(N + Dlog(D) + Elog(E))\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        //find odd and even numbers \\n        //and place them into different arrays\\n        int odd = 0, even = 0;\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] % 2 == 0) even++;\\n\\n        odd = nums.length - even;\\n        int[] oddNums = new int[odd], evenNums = new int[even];\\n        int countOdd = 0, countEven = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) evenNums[countEven++] = nums[i];\\n            else oddNums[countOdd++] = nums[i];\\n        }\\n        int[] oddT = new int[odd], evenT = new int[even];\\n        countOdd = 0;\\n        countEven = 0;\\n        for (int i = 0; i < target.length; i++) {\\n            if (target[i] % 2 == 0) evenT[countEven++] = target[i];\\n            else oddT[countOdd++] = target[i];\\n        }\\n        //sort all arrays so that odd numbers will correspond \\n        //to target odd numbers. The same to even numbers\\n        Arrays.sort(oddNums);\\n        Arrays.sort(evenNums);\\n        Arrays.sort(oddT);\\n        Arrays.sort(evenT);\\n        long countUp = 0;\\n\\n        //count difference in and find when we increment by 2\\n        //since we definitely have solution and number of \\n        //increments and decrements are equal\\n        //we just need number of increments\\n\\n        for (int i = 0; i < oddNums.length; i++) {\\n            int diff = oddT[i] - oddNums[i];\\n            if (diff == 0) continue;\\n            if (diff > 0) countUp += diff / 2;\\n        }\\n        for (int i = 0; i < evenNums.length; i++) {\\n            int diff = evenT[i] - evenNums[i];\\n            if (diff == 0) continue;\\n            if (diff > 0) countUp += diff / 2;\\n        }\\n        return countUp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        //find odd and even numbers \\n        //and place them into different arrays\\n        int odd = 0, even = 0;\\n        for (int i = 0; i < nums.length; i++)\\n            if (nums[i] % 2 == 0) even++;\\n\\n        odd = nums.length - even;\\n        int[] oddNums = new int[odd], evenNums = new int[even];\\n        int countOdd = 0, countEven = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) evenNums[countEven++] = nums[i];\\n            else oddNums[countOdd++] = nums[i];\\n        }\\n        int[] oddT = new int[odd], evenT = new int[even];\\n        countOdd = 0;\\n        countEven = 0;\\n        for (int i = 0; i < target.length; i++) {\\n            if (target[i] % 2 == 0) evenT[countEven++] = target[i];\\n            else oddT[countOdd++] = target[i];\\n        }\\n        //sort all arrays so that odd numbers will correspond \\n        //to target odd numbers. The same to even numbers\\n        Arrays.sort(oddNums);\\n        Arrays.sort(evenNums);\\n        Arrays.sort(oddT);\\n        Arrays.sort(evenT);\\n        long countUp = 0;\\n\\n        //count difference in and find when we increment by 2\\n        //since we definitely have solution and number of \\n        //increments and decrements are equal\\n        //we just need number of increments\\n\\n        for (int i = 0; i < oddNums.length; i++) {\\n            int diff = oddT[i] - oddNums[i];\\n            if (diff == 0) continue;\\n            if (diff > 0) countUp += diff / 2;\\n        }\\n        for (int i = 0; i < evenNums.length; i++) {\\n            int diff = evenT[i] - evenNums[i];\\n            if (diff == 0) continue;\\n            if (diff > 0) countUp += diff / 2;\\n        }\\n        return countUp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776194,
                "title": "c-easy-solution-sorting",
                "content": "\\n# Complexity\\n- Time complexity:\\n $$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<long long> eveN,oddN,eveT,oddT;\\n        for(auto i:nums)\\n        {\\n            if(i%2==0)\\n                eveN.push_back(i);\\n            else\\n                oddN.push_back(i);\\n        }\\n        for(auto i:target)\\n        {\\n            if(i%2==0)\\n                eveT.push_back(i);\\n            else\\n                oddT.push_back(i);\\n        }\\n        sort(eveN.begin(),eveN.end());\\n        sort(oddN.begin(),oddN.end());\\n        sort(eveT.begin(),eveT.end());\\n        sort(oddT.begin(),oddT.end());\\n        long long cnt=0;\\n        for(int i=0;i<eveN.size();i++)\\n        {\\n            cnt+=abs(eveN[i]-eveT[i])/2;\\n        }\\n        for(int i=0;i<oddN.size();i++)\\n        {\\n            cnt+=abs(oddN[i]-oddT[i])/2;\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<long long> eveN,oddN,eveT,oddT;\\n        for(auto i:nums)\\n        {\\n            if(i%2==0)\\n                eveN.push_back(i);\\n            else\\n                oddN.push_back(i);\\n        }\\n        for(auto i:target)\\n        {\\n            if(i%2==0)\\n                eveT.push_back(i);\\n            else\\n                oddT.push_back(i);\\n        }\\n        sort(eveN.begin(),eveN.end());\\n        sort(oddN.begin(),oddN.end());\\n        sort(eveT.begin(),eveT.end());\\n        sort(oddT.begin(),oddT.end());\\n        long long cnt=0;\\n        for(int i=0;i<eveN.size();i++)\\n        {\\n            cnt+=abs(eveN[i]-eveT[i])/2;\\n        }\\n        for(int i=0;i<oddN.size();i++)\\n        {\\n            cnt+=abs(oddN[i]-oddT[i])/2;\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744000,
                "title": "easy-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if it helps**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n=nums.size();\\n        long long minOperations=0;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        if(nums==target)\\n            return minOperations;\\n        vector<int> odd_nums,even_nums,odd_target,even_target;\\n        for(int i=0;i<n;i++){\\n            if((nums[i] & 1))   //Odd check\\n                odd_nums.push_back(nums[i]);\\n            if((target[i] & 1))\\n                odd_target.push_back(target[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if((nums[i] & 1)==0)  //Even Check\\n                even_nums.push_back(nums[i]);\\n            if((target[i] & 1)==0)\\n                even_target.push_back(target[i]);\\n        }\\n        for(int i=0;i<odd_nums.size();i++)\\n            minOperations+=abs((odd_nums[i]-odd_target[i])/2);\\n        for(int i=0;i<even_nums.size();i++)\\n            minOperations+=abs((even_nums[i]-even_target[i])/2);\\n        return minOperations/2;  //Above we are counting double the answer so finally we have to divide the ans by two in order to get the result\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n=nums.size();\\n        long long minOperations=0;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        if(nums==target)\\n            return minOperations;\\n        vector<int> odd_nums,even_nums,odd_target,even_target;\\n        for(int i=0;i<n;i++){\\n            if((nums[i] & 1))   //Odd check\\n                odd_nums.push_back(nums[i]);\\n            if((target[i] & 1))\\n                odd_target.push_back(target[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if((nums[i] & 1)==0)  //Even Check\\n                even_nums.push_back(nums[i]);\\n            if((target[i] & 1)==0)\\n                even_target.push_back(target[i]);\\n        }\\n        for(int i=0;i<odd_nums.size();i++)\\n            minOperations+=abs((odd_nums[i]-odd_target[i])/2);\\n        for(int i=0;i<even_nums.size();i++)\\n            minOperations+=abs((even_nums[i]-even_target[i])/2);\\n        return minOperations/2;  //Above we are counting double the answer so finally we have to divide the ans by two in order to get the result\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738885,
                "title": "faster-than-100-simple-java-solution",
                "content": "Break array in even and odd and then try to find difference for every element then calculate sum of that difference (positive) and then divide that number by 2 \\n***Happy Diwali!!***\\n```\\n public long makeSimilar(int[] nums, int[] target) {\\n       int[] arr = new int[nums.length];\\n       makeOddEven(nums);\\n       makeOddEven(target);\\n       for(int i = 0 ; i < nums.length ; i++){\\n           arr[i]=nums[i]-target[i];\\n       }\\n       long ans = 0;\\n       for(int i = 0 ; i < nums.length ; i++){\\n           if(arr[i]>0) ans+=arr[i];\\n       }\\n        \\n       return ans/2;\\n    \\n    }\\n    private static void makeOddEven(int[] nums){\\n       int[] arr = new int[nums.length];\\n       Arrays.sort(nums);\\n       int index = 0 ;\\n       for(int i = 0 ; i < nums.length ; i++){\\n           if((nums[i]&1)==1){\\n               arr[index]=nums[i];\\n               index++;\\n           }\\n       }\\n       for(int i = 0 ; i < nums.length ; i++){\\n           if((nums[i]&1)==0){\\n               arr[index]=nums[i];\\n               index++;\\n           }\\n       }\\n       for(int i = 0 ; i < nums.length ; i++){\\n           nums[i]=arr[i];\\n       }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public long makeSimilar(int[] nums, int[] target) {\\n       int[] arr = new int[nums.length];\\n       makeOddEven(nums);\\n       makeOddEven(target);\\n       for(int i = 0 ; i < nums.length ; i++){\\n           arr[i]=nums[i]-target[i];\\n       }\\n       long ans = 0;\\n       for(int i = 0 ; i < nums.length ; i++){\\n           if(arr[i]>0) ans+=arr[i];\\n       }\\n        \\n       return ans/2;\\n    \\n    }\\n    private static void makeOddEven(int[] nums){\\n       int[] arr = new int[nums.length];\\n       Arrays.sort(nums);\\n       int index = 0 ;\\n       for(int i = 0 ; i < nums.length ; i++){\\n           if((nums[i]&1)==1){\\n               arr[index]=nums[i];\\n               index++;\\n           }\\n       }\\n       for(int i = 0 ; i < nums.length ; i++){\\n           if((nums[i]&1)==0){\\n               arr[index]=nums[i];\\n               index++;\\n           }\\n       }\\n       for(int i = 0 ; i < nums.length ; i++){\\n           nums[i]=arr[i];\\n       }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735743,
                "title": "java-solution-even-odd-element-sorting-faster-than-100-o-nlogn-time",
                "content": "```java \\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int even=0;\\n        for(int x:nums)\\n        {\\n            if(x%2==0)\\n                even++;\\n        }\\n        int[] numsOdd = new int[nums.length-even];\\n        int[] targetOdd = new int[target.length-even];\\n        int[] numsEven = new int[even];\\n        int[] targetEven = new int[even];\\n        \\n        int j,k,a,b;\\n        j=k=a=b=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n                numsEven[j++]=nums[i];\\n            else\\n                numsOdd[k++]=nums[i];\\n            if(target[i]%2==0)\\n                targetEven[a++]=target[i];\\n            else\\n                targetOdd[b++]=target[i];\\n            \\n        }\\n        Arrays.sort(numsOdd);\\n        Arrays.sort(numsEven);\\n        Arrays.sort(targetOdd);\\n        Arrays.sort(targetEven);\\n        long sum=0;\\n        for(int i=0;i<numsOdd.length;i++)\\n        {\\n            sum+=Math.abs(numsOdd[i]-targetOdd[i]);\\n        }\\n        for(int i=0;i<numsEven.length;i++)\\n        {\\n            sum+=Math.abs(numsEven[i]-targetEven[i]);\\n        }\\n        return sum/4;\\n    } \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int even=0;\\n        for(int x:nums)\\n        {\\n            if(x%2==0)\\n                even++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2734761,
                "title": "javascript-greedy-math-455ms",
                "content": "```\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\n\\nconst makeSimilar = (a, b) => {\\n    let n = a.length, max = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) max = Math.max(max, a[i], b[i]);\\n    let f = Array(max + 1).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        f[b[i]]--;\\n    }\\n    for (let x = 2; x <= max; x++) f[x] += f[x - 2];\\n    return sm(f.map(x => Math.abs(x))) / 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\n\\nconst makeSimilar = (a, b) => {\\n    let n = a.length, max = Number.MIN_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) max = Math.max(max, a[i], b[i]);\\n    let f = Array(max + 1).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        f[b[i]]--;\\n    }\\n    for (let x = 2; x <= max; x++) f[x] += f[x - 2];\\n    return sm(f.map(x => Math.abs(x))) / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734520,
                "title": "explained-observation-c",
                "content": "Observation 1: Number of increments == number of decrements\\nObservation 2: Odd can go to odd ans even can go to even.\\n\\nSo what we do is sort both the given arrays. Then break the target arrays in odd and even numbers keeping the sorted order. I used a queue for that.\\nNow, put the odd numbers against odd number and even numbers against even numbers.\\nNo just calculate the number increments (or the decrements).\\n\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long n=nums.size(), i, j, o=0, e=0;\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        queue<long long>even, odd;\\n        \\n        for(i=0; i<n; i++){\\n            if(target[i]%2){odd.push(target[i]);}\\n            else{even.push(target[i]);}\\n        }\\n        \\n        for(i=0; i<n; i++){\\n            if(nums[i]%2){\\n                target[i] = odd.front();\\n                if(target[i]>nums[i]){o += (target[i]-nums[i])/2;}\\n                odd.pop();\\n            }\\n            else{\\n                target[i] = even.front();\\n                if(target[i]>nums[i]){e += (target[i]-nums[i])/2;}\\n                even.pop();\\n            }\\n        }\\n        \\n        return o + e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long n=nums.size(), i, j, o=0, e=0;\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        queue<long long>even, odd;\\n        \\n        for(i=0; i<n; i++){\\n            if(target[i]%2){odd.push(target[i]);}\\n            else{even.push(target[i]);}\\n        }\\n        \\n        for(i=0; i<n; i++){\\n            if(nums[i]%2){\\n                target[i] = odd.front();\\n                if(target[i]>nums[i]){o += (target[i]-nums[i])/2;}\\n                odd.pop();\\n            }\\n            else{\\n                target[i] = even.front();\\n                if(target[i]>nums[i]){e += (target[i]-nums[i])/2;}\\n                even.pop();\\n            }\\n        }\\n        \\n        return o + e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734164,
                "title": "java-prioryqueue-solution",
                "content": "```\\n//O(n*log(n)) time and O(n*log(n)) space\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        /*\\n            Split odd and even numbers into separate PriorityQueues because buy addding/removing 2 we will never change remainder\\n        */\\n        PriorityQueue<Integer> pqNumsOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqNumsEven = new PriorityQueue<>();\\n        \\n        PriorityQueue<Integer> pqTargetOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqTargetEven = new PriorityQueue<>();\\n\\n        for(int num : nums) {\\n            if(num % 2 == 0) {\\n                pqNumsEven.add(num);\\n            } else {\\n                pqNumsOdd.add(num);\\n            }\\n        }\\n        \\n        for(int tar : target) {\\n            if(tar % 2 == 0) {\\n                pqTargetEven.add(tar);\\n            } else {\\n                pqTargetOdd.add(tar);\\n            }            \\n        }\\n        \\n        long[] evens = helper(pqNumsEven, pqTargetEven, 0L, 0L);\\n        //pass number of adds and subs that we used in calculation of even numbers\\n        long[] odds = helper(pqNumsOdd, pqTargetOdd, evens[1], evens[2]);\\n        \\n        return evens[0] + odds[0];\\n    }\\n    \\n    private long[] helper(PriorityQueue<Integer> pqNums, PriorityQueue<Integer> pqTarget, long add, long sub) {\\n        //greedy solution\\n        long out = 0;\\n        \\n        while(!pqNums.isEmpty()) {\\n            //get smallest numbers from nums and target and see if we can match them\\n            int num = pqNums.poll();\\n            int target = pqTarget.poll();\\n            \\n            if(num < target) {\\n                //calculate number of operations we need to use to make numbers similar and apply free adds we gained by previously using subs\\n                long diff = (target - num) / 2 - add;\\n                \\n                if(diff > 0) {\\n                    //how many operations we need to use\\n                    out += diff;\\n                    //no free adds\\n                    add = 0;\\n                    //add free subs we can use later\\n                    sub += diff;\\n                } else {\\n                    //still have some adds to use in the future (or 0)\\n                    add = -diff;\\n                }\\n            } else {\\n                long diff = (num - target) / 2 - sub;\\n                \\n                if(diff > 0) {\\n                    out += diff;\\n                    sub = 0;\\n                    add += diff;\\n                }\\n            }\\n        }\\n        \\n        return new long[] {out, add, sub};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(n*log(n)) time and O(n*log(n)) space\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        /*\\n            Split odd and even numbers into separate PriorityQueues because buy addding/removing 2 we will never change remainder\\n        */\\n        PriorityQueue<Integer> pqNumsOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqNumsEven = new PriorityQueue<>();\\n        \\n        PriorityQueue<Integer> pqTargetOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqTargetEven = new PriorityQueue<>();\\n\\n        for(int num : nums) {\\n            if(num % 2 == 0) {\\n                pqNumsEven.add(num);\\n            } else {\\n                pqNumsOdd.add(num);\\n            }\\n        }\\n        \\n        for(int tar : target) {\\n            if(tar % 2 == 0) {\\n                pqTargetEven.add(tar);\\n            } else {\\n                pqTargetOdd.add(tar);\\n            }            \\n        }\\n        \\n        long[] evens = helper(pqNumsEven, pqTargetEven, 0L, 0L);\\n        //pass number of adds and subs that we used in calculation of even numbers\\n        long[] odds = helper(pqNumsOdd, pqTargetOdd, evens[1], evens[2]);\\n        \\n        return evens[0] + odds[0];\\n    }\\n    \\n    private long[] helper(PriorityQueue<Integer> pqNums, PriorityQueue<Integer> pqTarget, long add, long sub) {\\n        //greedy solution\\n        long out = 0;\\n        \\n        while(!pqNums.isEmpty()) {\\n            //get smallest numbers from nums and target and see if we can match them\\n            int num = pqNums.poll();\\n            int target = pqTarget.poll();\\n            \\n            if(num < target) {\\n                //calculate number of operations we need to use to make numbers similar and apply free adds we gained by previously using subs\\n                long diff = (target - num) / 2 - add;\\n                \\n                if(diff > 0) {\\n                    //how many operations we need to use\\n                    out += diff;\\n                    //no free adds\\n                    add = 0;\\n                    //add free subs we can use later\\n                    sub += diff;\\n                } else {\\n                    //still have some adds to use in the future (or 0)\\n                    add = -diff;\\n                }\\n            } else {\\n                long diff = (num - target) / 2 - sub;\\n                \\n                if(diff > 0) {\\n                    out += diff;\\n                    sub = 0;\\n                    add += diff;\\n                }\\n            }\\n        }\\n        \\n        return new long[] {out, add, sub};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734126,
                "title": "even-odd-sort-only-counting-the-positive-diffs-easy-to-understand",
                "content": "We can only think numbers falling down by multiple times of two\\'s,  it doesn\\'t matter how numbers grow up. Even will always be even. Odd can always be odd.\\n```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        List<Integer> even1 = getEven(nums, true);\\n        List<Integer> odd1 = getEven(nums, false);\\n        List<Integer> even2 = getEven(target, true);\\n        List<Integer> odd2 = getEven(target, false);\\n        long diff = 0;\\n        for (int i = 0 ; i < even1.size(); i++) {\\n            if (even1.get(i) > even2.get(i)) {\\n                diff += even1.get(i) - even2.get(i);\\n            }\\n        }\\n        for (int i = 0 ; i < odd1.size(); i++) {\\n            if (odd1.get(i) > odd2.get(i)) {\\n                diff += odd1.get(i) - odd2.get(i);\\n            }\\n        }\\n        \\n        \\n        return diff / 2;\\n    }\\n    \\n    private List<Integer> getEven(int[] nums, boolean flag) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (flag) {\\n                if (n % 2 == 0) {\\n                    list.add(n);                \\n                }   \\n            } else {\\n                if (n % 2 != 0) {\\n                    list.add(n);                \\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        List<Integer> even1 = getEven(nums, true);\\n        List<Integer> odd1 = getEven(nums, false);\\n        List<Integer> even2 = getEven(target, true);\\n        List<Integer> odd2 = getEven(target, false);\\n        long diff = 0;\\n        for (int i = 0 ; i < even1.size(); i++) {\\n            if (even1.get(i) > even2.get(i)) {\\n                diff += even1.get(i) - even2.get(i);\\n            }\\n        }\\n        for (int i = 0 ; i < odd1.size(); i++) {\\n            if (odd1.get(i) > odd2.get(i)) {\\n                diff += odd1.get(i) - odd2.get(i);\\n            }\\n        }\\n        \\n        \\n        return diff / 2;\\n    }\\n    \\n    private List<Integer> getEven(int[] nums, boolean flag) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (flag) {\\n                if (n % 2 == 0) {\\n                    list.add(n);                \\n                }   \\n            } else {\\n                if (n % 2 != 0) {\\n                    list.add(n);                \\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734092,
                "title": "java-even-odd-o-nlongn",
                "content": "```\\n\\nprivate long solve(int nums[], int target[], int oddEven){\\n\\t long res = 0L;\\n\\t int n=nums.length;\\n\\t for(int i=0, j=0; i<n && j<n;){\\n            if(nums[i]%2 == oddEven){\\n                i++;\\n                continue;\\n            }\\n            if(target[j]%2 == oddEven){\\n                j++;\\n                continue;\\n            }\\n            \\n            res += Math.abs(nums[i] - target[j]) / 2;\\n            i++; j++;\\n        }\\n\\t\\treturn res;\\n}\\n\\npublic long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        long res = solve(nums,target, 1)+ solve(nums, target, 0);\\n    \\n        return res / 2;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\nprivate long solve(int nums[], int target[], int oddEven){\\n\\t long res = 0L;\\n\\t int n=nums.length;\\n\\t for(int i=0, j=0; i<n && j<n;){\\n            if(nums[i]%2 == oddEven){\\n                i++;\\n                continue;\\n            }\\n            if(target[j]%2 == oddEven){\\n                j++;\\n                continue;\\n            }\\n            \\n            res += Math.abs(nums[i] - target[j]) / 2;\\n            i++; j++;\\n        }\\n\\t\\treturn res;\\n}\\n\\npublic long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        long res = solve(nums,target, 1)+ solve(nums, target, 0);\\n    \\n        return res / 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734084,
                "title": "sort-even-odd-c",
                "content": "The first observation is that all operations keep the parity of the numbers, so we really need to consider odd and even numbers separately in both arrays.  We split both arrays into odds and evens, sort everything and then simply sum the distances element-by-element.  Divide by 4 for the final answer.\\n\\n```\\nlong long makeSimilar(vector<int>& v, vector<int>& t) {\\n    long long ans=0;\\n    vector<int> vv[2], tt[2];\\n    for (int d: v) \\n        vv[d%2].push_back(d);\\n    for (int d: t) \\n        tt[d%2].push_back(d);\\n    for (int i=0; i<2; ++i) {            \\n        sort(vv[i].begin(), vv[i].end());\\n        sort(tt[i].begin(), tt[i].end());\\n    }\\n    long long  sum=0;\\n    for (int i=0; i<2; ++i)\\n        for (int j=0; j<vv[i].size(); j++)\\n            sum+=abs(tt[i][j]-vv[i][j]);\\n    return sum/4;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long makeSimilar(vector<int>& v, vector<int>& t) {\\n    long long ans=0;\\n    vector<int> vv[2], tt[2];\\n    for (int d: v) \\n        vv[d%2].push_back(d);\\n    for (int d: t) \\n        tt[d%2].push_back(d);\\n    for (int i=0; i<2; ++i) {            \\n        sort(vv[i].begin(), vv[i].end());\\n        sort(tt[i].begin(), tt[i].end());\\n    }\\n    long long  sum=0;\\n    for (int i=0; i<2; ++i)\\n        for (int j=0; j<vv[i].size(); j++)\\n            sum+=abs(tt[i][j]-vv[i][j]);\\n    return sum/4;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022164,
                "title": "greedy-based-solution-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long s=0,d=0;\\n    void solv(vector<int>& nums, vector<int>& t)\\n    {\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]>nums[i])\\n            {\\n                s+=(abs(nums[i]-t[i])/2);\\n            }\\n            else\\n            {\\n                d+=(abs(nums[i]-t[i])/2);\\n            }\\n        }\\n    }\\n    long long makeSimilar(vector<int>& nums, vector<int>& t) {\\n        sort(nums.begin(),nums.end());\\n        sort(t.begin(),t.end());\\n        \\n        vector<int>o1,o2,e1,e2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                e1.push_back(nums[i]);\\n            else\\n                o1.push_back(nums[i]);\\n            \\n            if(t[i]%2==0)\\n                e2.push_back(t[i]);\\n            else\\n                o2.push_back(t[i]);\\n        }\\n        solv(o1,o2);\\n        solv(e1,e2);\\n        \\n        long long ans;\\n        if(s<d)\\n        {\\n            ans=d;\\n        }\\n        else\\n        {\\n            ans=s;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long s=0,d=0;\\n    void solv(vector<int>& nums, vector<int>& t)\\n    {\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i]>nums[i])\\n            {\\n                s+=(abs(nums[i]-t[i])/2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3988838,
                "title": "c-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>even_nums;\\n        vector<int>even_target;\\n        vector<int>odd_nums;\\n        vector<int>odd_target;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even_nums.push_back(nums[i]);\\n\\n            }\\n            else{\\n                odd_nums.push_back(nums[i]);\\n            }\\n            if(target[i]%2==0){\\n                even_target.push_back(target[i]);\\n            }\\n            else{\\n                odd_target.push_back(target[i]);\\n            }\\n        }\\n        long long ans=0;\\n        \\n        for(int i=0;i<even_nums.size();i++){\\n            ans+=abs(even_nums[i]-even_target[i])/2;\\n        }\\n        for(int i=0;i<odd_nums.size();i++){\\n            ans+=abs(odd_nums[i]-odd_target[i])/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>even_nums;\\n        vector<int>even_target;\\n        vector<int>odd_nums;\\n        vector<int>odd_target;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even_nums.push_back(nums[i]);\\n\\n            }\\n            else{\\n                odd_nums.push_back(nums[i]);\\n            }\\n            if(target[i]%2==0){\\n                even_target.push_back(target[i]);\\n            }\\n            else{\\n                odd_target.push_back(target[i]);\\n            }\\n        }\\n        long long ans=0;\\n        \\n        for(int i=0;i<even_nums.size();i++){\\n            ans+=abs(even_nums[i]-even_target[i])/2;\\n        }\\n        for(int i=0;i<odd_nums.size();i++){\\n            ans+=abs(odd_nums[i]-odd_target[i])/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978645,
                "title": "python-solve",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        n=len(nums)\\n        inc=0\\n        dec=0\\n        arr=[]\\n        nums.sort()\\n        target.sort()\\n        i=0\\n        j=0\\n\\n        while i<n and j<n:\\n            if nums[i]%2==0 and target[j]%2==0:\\n                arr.append((nums[i], target[j]))\\n                i+=1\\n                j+=1\\n            else:\\n                if nums[i]%2!=0:\\n                    i+=1\\n                if target[j]%2!=0:\\n                    j+=1\\n\\n        i=0\\n        j=0\\n        while i<n and j<n:\\n            if nums[i]%2!=0 and target[j]%2!=0:\\n                arr.append((nums[i], target[j]))\\n                i+=1\\n                j+=1\\n               \\n            else:\\n                if nums[i]%2==0:\\n                    i+=1\\n                if target[j]%2==0:\\n                    j+=1\\n    \\n        for i in range(n):\\n            if arr[i][0]==arr[i][1]:\\n                continue\\n\\n            diff=abs(arr[i][0]-arr[i][1])\\n            if diff%2==0:\\n                if arr[i][0]<arr[i][1]:\\n                    inc+=diff//2\\n                else:\\n                    dec+=diff//2\\n\\n        return -1 if inc!=dec else inc\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        n=len(nums)\\n        inc=0\\n        dec=0\\n        arr=[]\\n        nums.sort()\\n        target.sort()\\n        i=0\\n        j=0\\n\\n        while i<n and j<n:\\n            if nums[i]%2==0 and target[j]%2==0:\\n                arr.append((nums[i], target[j]))\\n                i+=1\\n                j+=1\\n            else:\\n                if nums[i]%2!=0:\\n                    i+=1\\n                if target[j]%2!=0:\\n                    j+=1\\n\\n        i=0\\n        j=0\\n        while i<n and j<n:\\n            if nums[i]%2!=0 and target[j]%2!=0:\\n                arr.append((nums[i], target[j]))\\n                i+=1\\n                j+=1\\n               \\n            else:\\n                if nums[i]%2==0:\\n                    i+=1\\n                if target[j]%2==0:\\n                    j+=1\\n    \\n        for i in range(n):\\n            if arr[i][0]==arr[i][1]:\\n                continue\\n\\n            diff=abs(arr[i][0]-arr[i][1])\\n            if diff%2==0:\\n                if arr[i][0]<arr[i][1]:\\n                    inc+=diff//2\\n                else:\\n                    dec+=diff//2\\n\\n        return -1 if inc!=dec else inc\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946381,
                "title": "divide-the-numbers-into-odd-and-even-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> nodd,neven,todd,teven;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                neven.push_back(nums[i]);\\n            }\\n            if(nums[i]%2!=0){\\n                nodd.push_back(nums[i]);\\n            } \\n            if(target[i]%2==0){\\n                teven.push_back(target[i]);\\n            } \\n            if(target[i]%2!=0){\\n                todd.push_back(target[i]);\\n            } \\n        }\\n        sort(neven.begin(),neven.end());\\n        sort(nodd.begin(),nodd.end());\\n        sort(teven.begin(),teven.end());\\n        sort(todd.begin(),todd.end());\\n        long long cnt=0;\\n        for(int i=0;i<neven.size();i++){\\n            cnt+=abs(neven[i]-teven[i])/2;\\n        }\\n        for(int i=0;i<nodd.size();i++){\\n            cnt+=abs(nodd[i]-todd[i])/2;\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> nodd,neven,todd,teven;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                neven.push_back(nums[i]);\\n            }\\n            if(nums[i]%2!=0){\\n                nodd.push_back(nums[i]);\\n            } \\n            if(target[i]%2==0){\\n                teven.push_back(target[i]);\\n            } \\n            if(target[i]%2!=0){\\n                todd.push_back(target[i]);\\n            } \\n        }\\n        sort(neven.begin(),neven.end());\\n        sort(nodd.begin(),nodd.end());\\n        sort(teven.begin(),teven.end());\\n        sort(todd.begin(),todd.end());\\n        long long cnt=0;\\n        for(int i=0;i<neven.size();i++){\\n            cnt+=abs(neven[i]-teven[i])/2;\\n        }\\n        for(int i=0;i<nodd.size();i++){\\n            cnt+=abs(nodd[i]-todd[i])/2;\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910800,
                "title": "javascript-super-readable-detailed-fast-beats-100",
                "content": "# Intuition\\nSince we need the minimum number of steps, we will use the greedy approach.\\n\\nThe greedy step here is sorting both of the arrays, since we want to match the minimum value of $$nums$$ with the minimum value of $$target$$, the $$2nd$$ smallest value of $$nums$$ with the $$2nd$$ smallest value of $$target$$ and so on..\\n\\n# Approach\\n* Sorting both of the arrays\\n* Breaking down the arrays into evens & odds arrays.\\n* For each item $$i$$, we calculate the absolute difference of $$nums[i] - target[i]$$ (on both the evens & odd arrays), then dividing the result by $$2$$ (difference of $$2x$$ equals $$x$$ operations to perform).\\n* Dividing the final result by $$2$$ because in each operation, we can increase and decrease in two different indexes.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\cdot log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\nvar makeSimilar = function(nums, target) {\\n    // Helper functions\\n    const isEven = num => num % 2 === 0;\\n    const isOdd = num => num % 2 === 1;\\n\\n    // Since we need the minimum number of steps, we will use the greedy approach.\\n    // The greedy step here is sorting both of the arrays, since we want to match the minimum value of \\'nums\\' with the minimum value of \\'target\\', the 2nd smallest value of \\'nums\\' with the 2nd smallest value of \\'target\\' and so on..\\n    const sortedNums = nums.sort((a,b) => a - b);\\n    const sortedTarget = target.sort((a,b) => a - b);\\n\\n    // Breaking down the sorted arrays into separated evens & odds arrays.\\n    // This step is crucial since we can only increase / decrease the values by 2, if we would try to match an even number with an odd number it would be impossible.\\n    const numsEven = sortedNums.filter((item) => isEven(item));\\n    const targetEven = sortedTarget.filter((item) => isEven(item));\\n    const numsOdd = sortedNums.filter((item) => isOdd(item));\\n    const targetOdd = sortedTarget.filter((item) => isOdd(item));\\n\\n    let numberOfOperations = 0;\\n\\n    // iterating over the even values\\n    for(let i = 0; i < numsEven.length; i++) {\\n        // dividing by 2 because for each 2x difference in the calculation, there are x operations to perform (e.g: if the result is 2, then 1 operation is required to match).\\n        numberOfOperations += Math.abs(numsEven[i] - targetEven[i]) / 2;\\n    }\\n\\n    // iterating over the odd values\\n    for(let j = 0; j < numsOdd.length; j++) {\\n        // same reason for dividing by 2 here.\\n        numberOfOperations += Math.abs(numsOdd[j] - targetOdd[j]) / 2;\\n    } \\n\\n    // Dividing the final result by 2 because in each operation we can increase & decrease in two different indexes (as stated in the problem\\'s description using i & j indexes).\\n    return numberOfOperations / 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\nvar makeSimilar = function(nums, target) {\\n    // Helper functions\\n    const isEven = num => num % 2 === 0;\\n    const isOdd = num => num % 2 === 1;\\n\\n    // Since we need the minimum number of steps, we will use the greedy approach.\\n    // The greedy step here is sorting both of the arrays, since we want to match the minimum value of \\'nums\\' with the minimum value of \\'target\\', the 2nd smallest value of \\'nums\\' with the 2nd smallest value of \\'target\\' and so on..\\n    const sortedNums = nums.sort((a,b) => a - b);\\n    const sortedTarget = target.sort((a,b) => a - b);\\n\\n    // Breaking down the sorted arrays into separated evens & odds arrays.\\n    // This step is crucial since we can only increase / decrease the values by 2, if we would try to match an even number with an odd number it would be impossible.\\n    const numsEven = sortedNums.filter((item) => isEven(item));\\n    const targetEven = sortedTarget.filter((item) => isEven(item));\\n    const numsOdd = sortedNums.filter((item) => isOdd(item));\\n    const targetOdd = sortedTarget.filter((item) => isOdd(item));\\n\\n    let numberOfOperations = 0;\\n\\n    // iterating over the even values\\n    for(let i = 0; i < numsEven.length; i++) {\\n        // dividing by 2 because for each 2x difference in the calculation, there are x operations to perform (e.g: if the result is 2, then 1 operation is required to match).\\n        numberOfOperations += Math.abs(numsEven[i] - targetEven[i]) / 2;\\n    }\\n\\n    // iterating over the odd values\\n    for(let j = 0; j < numsOdd.length; j++) {\\n        // same reason for dividing by 2 here.\\n        numberOfOperations += Math.abs(numsOdd[j] - targetOdd[j]) / 2;\\n    } \\n\\n    // Dividing the final result by 2 because in each operation we can increase & decrease in two different indexes (as stated in the problem\\'s description using i & j indexes).\\n    return numberOfOperations / 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900222,
                "title": "separate-odds-and-evens",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        int n=nums.size();\\n        int m=target.size();\\n        long long pos=0,neg=0,res=0;\\n        int i=0,j=0;\\n        while(i<nums.size()&&j<target.size()) {\\n            while(i<n&&nums[i]%2) i++;\\n            while(j<m&&target[j]%2) j++;\\n            if(i==n) break;\\n            long long t=nums[i]-target[j];\\n            if(t==0) {\\n                i++,j++;\\n                continue;\\n            }\\n            if(t>0) {\\n                //we don\\'t need to do any operation\\n                if(pos>=t) pos-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=pos;\\n                    res+=t/2;\\n                    neg+=t;\\n                }\\n            }  \\n            else {\\n                //we don\\'t need to do any operation\\n                if(neg>=t) neg-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=neg;\\n                    res+=t/2;\\n                    pos+=t;\\n                }\\n            }  \\n            i++,j++;\\n        }\\n        i=0,j=0;\\n        while(i<nums.size()&&j<target.size()) {\\n            while(i<n&&nums[i]%2==0) i++;\\n            while(j<m&&target[j]%2==0) j++;\\n            if(i==n) break;\\n            int t=nums[i]-target[j];\\n            if(t==0) {\\n                i++,j++;\\n                continue;\\n            }\\n            if(t>0) {\\n                //we don\\'t need to do any operation\\n                if(pos>=t) pos-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=pos;\\n                    res+=t/2;\\n                    neg+=t;\\n                }\\n            }  \\n            else {\\n                //we don\\'t need to do any operation\\n                if(neg>=t) neg-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=neg;\\n                    res+=t/2;\\n                    pos+=t;\\n                }\\n            }  \\n            i++,j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        int n=nums.size();\\n        int m=target.size();\\n        long long pos=0,neg=0,res=0;\\n        int i=0,j=0;\\n        while(i<nums.size()&&j<target.size()) {\\n            while(i<n&&nums[i]%2) i++;\\n            while(j<m&&target[j]%2) j++;\\n            if(i==n) break;\\n            long long t=nums[i]-target[j];\\n            if(t==0) {\\n                i++,j++;\\n                continue;\\n            }\\n            if(t>0) {\\n                //we don\\'t need to do any operation\\n                if(pos>=t) pos-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=pos;\\n                    res+=t/2;\\n                    neg+=t;\\n                }\\n            }  \\n            else {\\n                //we don\\'t need to do any operation\\n                if(neg>=t) neg-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=neg;\\n                    res+=t/2;\\n                    pos+=t;\\n                }\\n            }  \\n            i++,j++;\\n        }\\n        i=0,j=0;\\n        while(i<nums.size()&&j<target.size()) {\\n            while(i<n&&nums[i]%2==0) i++;\\n            while(j<m&&target[j]%2==0) j++;\\n            if(i==n) break;\\n            int t=nums[i]-target[j];\\n            if(t==0) {\\n                i++,j++;\\n                continue;\\n            }\\n            if(t>0) {\\n                //we don\\'t need to do any operation\\n                if(pos>=t) pos-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=pos;\\n                    res+=t/2;\\n                    neg+=t;\\n                }\\n            }  \\n            else {\\n                //we don\\'t need to do any operation\\n                if(neg>=t) neg-=t;\\n                //we need to do more operations\\n                else {\\n                    t-=neg;\\n                    res+=t/2;\\n                    pos+=t;\\n                }\\n            }  \\n            i++,j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877039,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>even1,even2;\\n        vector<int>odd1,odd2;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]&1) odd1.push_back(nums[i]);\\n            else even1.push_back(nums[i]);\\n            if (target[i]&1) odd2.push_back(target[i]);\\n            else even2.push_back(target[i]);\\n        }\\n        long long ans=0;\\n        for (int i=0;i<even1.size();i++)\\n        {\\n            if (even1[i]>even2[i]) ans+=(long long)(even1[i]-even2[i]);\\n        }\\n        for (int i=0;i<odd1.size();i++)\\n        {\\n            if (odd1[i]>odd2[i]) ans+=(long long)(odd1[i]-odd2[i]);\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>even1,even2;\\n        vector<int>odd1,odd2;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            if (nums[i]&1) odd1.push_back(nums[i]);\\n            else even1.push_back(nums[i]);\\n            if (target[i]&1) odd2.push_back(target[i]);\\n            else even2.push_back(target[i]);\\n        }\\n        long long ans=0;\\n        for (int i=0;i<even1.size();i++)\\n        {\\n            if (even1[i]>even2[i]) ans+=(long long)(even1[i]-even2[i]);\\n        }\\n        for (int i=0;i<odd1.size();i++)\\n        {\\n            if (odd1[i]>odd2[i]) ans+=(long long)(odd1[i]-odd2[i]);\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825432,
                "title": "c-easy-sorting-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>odds,even;\\n        vector<int>t_odds,t_even;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)odds.push_back(nums[i]);\\n            else even.push_back(nums[i]);\\n\\n            if(target[i]&1)t_odds.push_back(target[i]);\\n            else t_even.push_back(target[i]);\\n        }\\n\\n        long long sumodd=0,sumeven=0;\\n        for(int i=0;i<odds.size();i++)\\n        {\\n            long long  t = abs(odds[i] - t_odds[i])/2;\\n            sumodd+=t;\\n        }\\n        for(int i=0;i<even.size();i++)\\n        {\\n            long long  t = abs(even[i]-t_even[i])/2;\\n            sumeven+=t;\\n            \\n        }\\n        \\n        return (sumodd+sumeven)/2;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>odds,even;\\n        vector<int>t_odds,t_even;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)odds.push_back(nums[i]);\\n            else even.push_back(nums[i]);\\n\\n            if(target[i]&1)t_odds.push_back(target[i]);\\n            else t_even.push_back(target[i]);\\n        }\\n\\n        long long sumodd=0,sumeven=0;\\n        for(int i=0;i<odds.size();i++)\\n        {\\n            long long  t = abs(odds[i] - t_odds[i])/2;\\n            sumodd+=t;\\n        }\\n        for(int i=0;i<even.size();i++)\\n        {\\n            long long  t = abs(even[i]-t_even[i])/2;\\n            sumeven+=t;\\n            \\n        }\\n        \\n        return (sumodd+sumeven)/2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763308,
                "title": "java-solution-beat-100-as-time-of-submitting-o-nlogn-time-o-1-space",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // Assume if nums/target is all odd or non even, the smallest value from nums will need to do enough action to become smallest value in target and so on\\n    // So if we sort, we can use the different value at each idx divide by 2 to get the number of action need to change on that idx. Since we know single operation \\n    // has 2 action, and guaranteed solution, we can get sum of action and divide by 2. So it is sum of absolute different divide by 4 (>> 2).\\n\\n    // Also note that even can only become even, and odd can only become odd after each action. So we can divide into 2 sub problem of even array and odd array.\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int len = nums.length;\\n        partitionAndSortEvenOdd(nums, len);\\n        partitionAndSortEvenOdd(target, len);\\n        long sum = 0;\\n        for (int i = 0; i < len; ++i) {\\n            sum += Math.abs(nums[i] - target[i]);\\n        }\\n        return sum >> 2;\\n    }\\n\\n    // Make even on left and odd on right side of array, both side are sorted.\\n    public void partitionAndSortEvenOdd(int[] arr, int len) {\\n        int evenI = -1;\\n        int oddI = len;\\n        while (evenI < oddI) {\\n            // evenI store index of 1st odd found from left side\\n            while (++evenI < oddI && arr[evenI] % 2 == 0) {}\\n            // oddI store index of 1st even found from right side\\n            while (--oddI > evenI && arr[oddI] % 2 == 1) {}\\n\\n            // swap them 1st odd from left is on left side of 1st even from right\\n            if (evenI < oddI) {\\n                int tmp = arr[evenI];\\n                arr[evenI] = arr[oddI];\\n                arr[oddI] = tmp;\\n            }\\n        }\\n\\n        // evenI will be storing the length of even side (left side). Now we sort.\\n        int evenLen = evenI;\\n        Arrays.sort(arr, 0, evenLen);\\n        Arrays.sort(arr, evenLen, len);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Assume if nums/target is all odd or non even, the smallest value from nums will need to do enough action to become smallest value in target and so on\\n    // So if we sort, we can use the different value at each idx divide by 2 to get the number of action need to change on that idx. Since we know single operation \\n    // has 2 action, and guaranteed solution, we can get sum of action and divide by 2. So it is sum of absolute different divide by 4 (>> 2).\\n\\n    // Also note that even can only become even, and odd can only become odd after each action. So we can divide into 2 sub problem of even array and odd array.\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int len = nums.length;\\n        partitionAndSortEvenOdd(nums, len);\\n        partitionAndSortEvenOdd(target, len);\\n        long sum = 0;\\n        for (int i = 0; i < len; ++i) {\\n            sum += Math.abs(nums[i] - target[i]);\\n        }\\n        return sum >> 2;\\n    }\\n\\n    // Make even on left and odd on right side of array, both side are sorted.\\n    public void partitionAndSortEvenOdd(int[] arr, int len) {\\n        int evenI = -1;\\n        int oddI = len;\\n        while (evenI < oddI) {\\n            // evenI store index of 1st odd found from left side\\n            while (++evenI < oddI && arr[evenI] % 2 == 0) {}\\n            // oddI store index of 1st even found from right side\\n            while (--oddI > evenI && arr[oddI] % 2 == 1) {}\\n\\n            // swap them 1st odd from left is on left side of 1st even from right\\n            if (evenI < oddI) {\\n                int tmp = arr[evenI];\\n                arr[evenI] = arr[oddI];\\n                arr[oddI] = tmp;\\n            }\\n        }\\n\\n        // evenI will be storing the length of even side (left side). Now we sort.\\n        int evenLen = evenI;\\n        Arrays.sort(arr, 0, evenLen);\\n        Arrays.sort(arr, evenLen, len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711937,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& t) {\\n        vector<int>odd_n;\\n        vector<int>odd_t;\\n        vector<int>even_n;\\n        vector<int>even_t;\\n        long long ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even_n.push_back(nums[i]);\\n            }\\n            else{\\n                odd_n.push_back(nums[i]);\\n            }\\n            if(t[i]%2==0){\\n                even_t.push_back(t[i]);\\n            }\\n            else{\\n                odd_t.push_back(t[i]);\\n            }\\n        }\\n        sort(even_n.begin(),even_n.end());\\n        sort(odd_n.begin(),odd_n.end());\\n        sort(even_t.begin(),even_t.end());\\n        sort(odd_t.begin(),odd_t.end());\\n        for(int i = 0;i<even_n.size();i++){\\n            ans = ans + abs(even_n[i] - even_t[i])/2;\\n        }\\n        for(int i = 0;i<odd_n.size();i++){\\n            ans = ans + abs(odd_n[i] - odd_t[i])/2;\\n        }\\n        return ans/2;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& t) {\\n        vector<int>odd_n;\\n        vector<int>odd_t;\\n        vector<int>even_n;\\n        vector<int>even_t;\\n        long long ans = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even_n.push_back(nums[i]);\\n            }\\n            else{\\n                odd_n.push_back(nums[i]);\\n            }\\n            if(t[i]%2==0){\\n                even_t.push_back(t[i]);\\n            }\\n            else{\\n                odd_t.push_back(t[i]);\\n            }\\n        }\\n        sort(even_n.begin(),even_n.end());\\n        sort(odd_n.begin(),odd_n.end());\\n        sort(even_t.begin(),even_t.end());\\n        sort(odd_t.begin(),odd_t.end());\\n        for(int i = 0;i<even_n.size();i++){\\n            ans = ans + abs(even_n[i] - even_t[i])/2;\\n        }\\n        for(int i = 0;i<odd_n.size();i++){\\n            ans = ans + abs(odd_n[i] - odd_t[i])/2;\\n        }\\n        return ans/2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696227,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& v, vector<int>& t) {\\n        long long ans=0;\\n        vector<int>vv[2], tt[2];\\n        for(int d:v){\\n            vv[d%2].push_back(d);\\n        }\\n        for(int d:t){\\n            tt[d%2].push_back(d);\\n        }\\n        for(int i=0;i<2;i++){\\n            sort(vv[i].begin(), vv[i].end());\\n            sort(tt[i].begin(), tt[i].end());\\n        }\\n\\n        long long sum=0;\\n        for(int i=0;i<2;i++){\\n            for(int j=0;j<vv[i].size();j++){\\n                sum += abs(tt[i][j]-vv[i][j]);\\n            }\\n        }\\n        return sum/4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& v, vector<int>& t) {\\n        long long ans=0;\\n        vector<int>vv[2], tt[2];\\n        for(int d:v){\\n            vv[d%2].push_back(d);\\n        }\\n        for(int d:t){\\n            tt[d%2].push_back(d);\\n        }\\n        for(int i=0;i<2;i++){\\n            sort(vv[i].begin(), vv[i].end());\\n            sort(tt[i].begin(), tt[i].end());\\n        }\\n\\n        long long sum=0;\\n        for(int i=0;i<2;i++){\\n            for(int j=0;j<vv[i].size();j++){\\n                sum += abs(tt[i][j]-vv[i][j]);\\n            }\\n        }\\n        return sum/4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674146,
                "title": "golang-sort-even-and-odd",
                "content": "# Code\\n```\\nfunc makeSimilar(nums []int, target []int) int64 {\\n    // nums even can be converted to target even only\\n    // nums odd can be converted to target odd only\\n    nums_even, nums_odd, target_even, target_odd := []int{}, []int{}, []int{}, []int{}\\n\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] % 2 == 0 {\\n            nums_even = append(nums_even, nums[i])\\n        } else {\\n            nums_odd = append(nums_odd, nums[i])\\n        }\\n\\n        if target[i] % 2 == 0 {\\n            target_even = append(target_even, target[i])\\n        } else {\\n            target_odd = append(target_odd, target[i])\\n        }\\n    }\\n\\n    sort.Ints(nums_even)\\n    sort.Ints(nums_odd)\\n    sort.Ints(target_even)\\n    sort.Ints(target_odd)\\n\\n    res := 0\\n    for i := 0; i < len(nums_even); i++ {\\n        res += abs(nums_even[i] - target_even[i]) / 2\\n    }\\n\\n    for i := 0; i < len(nums_odd); i++ {\\n        res += abs(nums_odd[i] - target_odd[i]) / 2\\n    }\\n\\n    return int64(res / 2)\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeSimilar(nums []int, target []int) int64 {\\n    // nums even can be converted to target even only\\n    // nums odd can be converted to target odd only\\n    nums_even, nums_odd, target_even, target_odd := []int{}, []int{}, []int{}, []int{}\\n\\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] % 2 == 0 {\\n            nums_even = append(nums_even, nums[i])\\n        } else {\\n            nums_odd = append(nums_odd, nums[i])\\n        }\\n\\n        if target[i] % 2 == 0 {\\n            target_even = append(target_even, target[i])\\n        } else {\\n            target_odd = append(target_odd, target[i])\\n        }\\n    }\\n\\n    sort.Ints(nums_even)\\n    sort.Ints(nums_odd)\\n    sort.Ints(target_even)\\n    sort.Ints(target_odd)\\n\\n    res := 0\\n    for i := 0; i < len(nums_even); i++ {\\n        res += abs(nums_even[i] - target_even[i]) / 2\\n    }\\n\\n    for i := 0; i < len(nums_odd); i++ {\\n        res += abs(nums_odd[i] - target_odd[i]) / 2\\n    }\\n\\n    return int64(res / 2)\\n}\\n\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653239,
                "title": "greedy-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> oddnum,oddtarget,evenum,eventarget;\\n        int i;\\n        for(i = 0; i < nums.size(); i++){\\n            if(nums[i]&1){\\n                oddnum.push_back(nums[i]);\\n            }else{\\n                evenum.push_back(nums[i]);\\n            }\\n            if(target[i]&1){\\n                oddtarget.push_back(target[i]);\\n            }else{\\n                eventarget.push_back(target[i]);\\n            }\\n        }\\n        sort(oddnum.begin(),oddnum.end());\\n        sort(oddtarget.begin(),oddtarget.end());\\n        sort(evenum.begin(),evenum.end());\\n        sort(eventarget.begin(),eventarget.end());\\n        long long int ans = 0;\\n        for(i = 0; i < evenum.size(); i++){\\n            ans += abs(evenum[i]-eventarget[i]);\\n        }\\n        for(i = 0; i < oddnum.size(); i++){\\n            ans += abs(oddnum[i]-oddtarget[i]);\\n        }\\n        return (ans>>2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> oddnum,oddtarget,evenum,eventarget;\\n        int i;\\n        for(i = 0; i < nums.size(); i++){\\n            if(nums[i]&1){\\n                oddnum.push_back(nums[i]);\\n            }else{\\n                evenum.push_back(nums[i]);\\n            }\\n            if(target[i]&1){\\n                oddtarget.push_back(target[i]);\\n            }else{\\n                eventarget.push_back(target[i]);\\n            }\\n        }\\n        sort(oddnum.begin(),oddnum.end());\\n        sort(oddtarget.begin(),oddtarget.end());\\n        sort(evenum.begin(),evenum.end());\\n        sort(eventarget.begin(),eventarget.end());\\n        long long int ans = 0;\\n        for(i = 0; i < evenum.size(); i++){\\n            ans += abs(evenum[i]-eventarget[i]);\\n        }\\n        for(i = 0; i < oddnum.size(); i++){\\n            ans += abs(oddnum[i]-oddtarget[i]);\\n        }\\n        return (ans>>2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613856,
                "title": "beats-100-easy-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n    }\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans = 0;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> v1,v2;\\n        for(int i: nums) if(i%2==0) v1.push_back(i);\\n        for(int i: target) if(i%2==0) v2.push_back(i);\\n        for(int i=0;i<v2.size();i++){\\n            if(v2[i] > v1[i]) ans += (v2[i] - v1[i]) / 2;\\n        }\\n        v1.clear();\\n        v2.clear();\\n        for(int i: nums) if(i%2) v1.push_back(i);\\n        for(int i: target) if(i%2) v2.push_back(i);\\n        for(int i=0;i<v2.size();i++){\\n            if(v2[i] > v1[i]) ans += (v2[i] - v1[i]) / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n    }\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans = 0;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> v1,v2;\\n        for(int i: nums) if(i%2==0) v1.push_back(i);\\n        for(int i: target) if(i%2==0) v2.push_back(i);\\n        for(int i=0;i<v2.size();i++){\\n            if(v2[i] > v1[i]) ans += (v2[i] - v1[i]) / 2;\\n        }\\n        v1.clear();\\n        v2.clear();\\n        for(int i: nums) if(i%2) v1.push_back(i);\\n        for(int i: target) if(i%2) v2.push_back(i);\\n        for(int i=0;i<v2.size();i++){\\n            if(v2[i] > v1[i]) ans += (v2[i] - v1[i]) / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3542982,
                "title": "there-just-wasn-t-a-solution-with-a-c-tag",
                "content": "# Code\\n```\\npublic class Solution {\\n    public long MakeSimilar(int[] nums, int[] target) {\\n        var numsEven = new List<int>();      \\n        var numsOdd = new List<int>();\\n        var targetEven = new List<int>();\\n        var targetOdd = new List<int>();\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            var n = nums[i];\\n            if (n % 2 == 0)\\n                numsEven.Add(n);\\n            else\\n                numsOdd.Add(n);\\n            var t = target[i];\\n            if (t % 2 == 0)\\n                targetEven.Add(t);\\n            else\\n                targetOdd.Add(t);\\n        }\\n        numsEven.Sort();\\n        numsOdd.Sort();\\n        targetEven.Sort();\\n        targetOdd.Sort();\\n        long count = 0;\\n        for (var i = 0; i < numsEven.Count; i++)\\n            count += Math.Abs(numsEven[i] - targetEven[i]);\\n        for (var i = 0; i < numsOdd.Count; i++)\\n            count += Math.Abs(numsOdd[i] - targetOdd[i]);\\n        return count / 4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MakeSimilar(int[] nums, int[] target) {\\n        var numsEven = new List<int>();      \\n        var numsOdd = new List<int>();\\n        var targetEven = new List<int>();\\n        var targetOdd = new List<int>();\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            var n = nums[i];\\n            if (n % 2 == 0)\\n                numsEven.Add(n);\\n            else\\n                numsOdd.Add(n);\\n            var t = target[i];\\n            if (t % 2 == 0)\\n                targetEven.Add(t);\\n            else\\n                targetOdd.Add(t);\\n        }\\n        numsEven.Sort();\\n        numsOdd.Sort();\\n        targetEven.Sort();\\n        targetOdd.Sort();\\n        long count = 0;\\n        for (var i = 0; i < numsEven.Count; i++)\\n            count += Math.Abs(numsEven[i] - targetEven[i]);\\n        for (var i = 0; i < numsOdd.Count; i++)\\n            count += Math.Abs(numsOdd[i] - targetOdd[i]);\\n        return count / 4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501853,
                "title": "minimum-number-of-operations-to-make-2-arrays-similar-c-easy-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->odd+2 = odd, even+2= even. \\nsort the vectors num and target.\\nthe difference between the sorted value/2 will be the minimum number of operations to make both the arrays similar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->sort the nums and target arrays\\ndivide the arrays in their odd and even halves, oddN, evenN, oddT, evenT.\\nsince the nums and target arrays are sorted, the odd and even vectors are also sorted, letting the minimum difference between the odd values of nums and target arrays,\\nfollow similar steps for even values\\non adding the (difference/2) gives the minimum number of operations.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long operations=0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n\\n        vector<int> oddN, oddT, evenN, evenT;\\n        for(int i=0;i<n; i++){\\n            if(nums[i]%2){\\n                oddN.push_back(nums[i]);\\n            }\\n            else{\\n                evenN.push_back(nums[i]);\\n            }\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(target[i]%2){\\n                oddT.push_back(target[i]);\\n            }\\n            else{\\n                evenT.push_back(target[i]);\\n            }\\n        }\\n\\n        for(int i=0;i<oddN.size();i++){\\n            if(oddN[i]<oddT[i]){\\n                operations += (int)((oddT[i]-oddN[i])/2);\\n            }\\n        }\\n        for(int i=0;i<evenN.size();i++){\\n            if(evenN[i]<evenT[i]){\\n                operations += (int)((evenT[i]-evenN[i])/2);\\n            }\\n        }\\n\\n        return operations;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long operations=0, n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n\\n        vector<int> oddN, oddT, evenN, evenT;\\n        for(int i=0;i<n; i++){\\n            if(nums[i]%2){\\n                oddN.push_back(nums[i]);\\n            }\\n            else{\\n                evenN.push_back(nums[i]);\\n            }\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(target[i]%2){\\n                oddT.push_back(target[i]);\\n            }\\n            else{\\n                evenT.push_back(target[i]);\\n            }\\n        }\\n\\n        for(int i=0;i<oddN.size();i++){\\n            if(oddN[i]<oddT[i]){\\n                operations += (int)((oddT[i]-oddN[i])/2);\\n            }\\n        }\\n        for(int i=0;i<evenN.size();i++){\\n            if(evenN[i]<evenT[i]){\\n                operations += (int)((evenT[i]-evenN[i])/2);\\n            }\\n        }\\n\\n        return operations;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498000,
                "title": "3-line-python-solution-in-o-n-log-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe answer is the total differences between odd/even pairs in sorted nums and target sequences. The solution can be easily implemented in Python in 3 lines.  \\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ In-place sorting with no additional memory required. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        target.sort(key=lambda x: (x % 2, x))\\n        nums.sort(key=lambda x: (x % 2, x))\\n        return sum(t-s for s, t in zip(nums, target) if t > s) // 2\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        target.sort(key=lambda x: (x % 2, x))\\n        nums.sort(key=lambda x: (x % 2, x))\\n        return sum(t-s for s, t in zip(nums, target) if t > s) // 2\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455028,
                "title": "one-of-the-worst-solution-in-java-if-you-agree-with-me-then-upvote-for-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int x=0,j=0,k=0,i=0;\\n        long count=0;\\n      ArrayList<Integer> even=new ArrayList<>();\\n      ArrayList<Integer> odd=new ArrayList<>();\\n      ArrayList<Integer> even1=new ArrayList<>();\\n      ArrayList<Integer> odd1=new ArrayList<>();\\n      for(i=0;i<nums.length;i++)\\n      {\\n         if(nums[i]%2==0)\\n         even.add(nums[i]);\\n         else\\n         odd.add(nums[i]);\\n         if(target[i]%2==0)\\n         even1.add(target[i]);\\n         else\\n         odd1.add(target[i]);\\n      }\\n      i=0;j=0;\\n      Collections.sort(even);Collections.sort(even1);\\n      Collections.sort(odd);Collections.sort(odd1);\\n      while(i<even.size() && j<even1.size())\\n      {\\n         x=Math.abs(even.get(i)-even1.get(j));\\n         count+=x/2;\\n         i++;j++;\\n      }\\n      i=0;j=0;\\n      while(i<odd.size() && j<odd1.size())\\n      {\\n         x=Math.abs(odd.get(i)-odd1.get(j));\\n         count+=x/2;\\n         i++;j++;\\n      }\\n      return count/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int x=0,j=0,k=0,i=0;\\n        long count=0;\\n      ArrayList<Integer> even=new ArrayList<>();\\n      ArrayList<Integer> odd=new ArrayList<>();\\n      ArrayList<Integer> even1=new ArrayList<>();\\n      ArrayList<Integer> odd1=new ArrayList<>();\\n      for(i=0;i<nums.length;i++)\\n      {\\n         if(nums[i]%2==0)\\n         even.add(nums[i]);\\n         else\\n         odd.add(nums[i]);\\n         if(target[i]%2==0)\\n         even1.add(target[i]);\\n         else\\n         odd1.add(target[i]);\\n      }\\n      i=0;j=0;\\n      Collections.sort(even);Collections.sort(even1);\\n      Collections.sort(odd);Collections.sort(odd1);\\n      while(i<even.size() && j<even1.size())\\n      {\\n         x=Math.abs(even.get(i)-even1.get(j));\\n         count+=x/2;\\n         i++;j++;\\n      }\\n      i=0;j=0;\\n      while(i<odd.size() && j<odd1.size())\\n      {\\n         x=Math.abs(odd.get(i)-odd1.get(j));\\n         count+=x/2;\\n         i++;j++;\\n      }\\n      return count/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430907,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> even, odd;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        for(int i=0; i<n; i++){\\n            if(nums[i]%2)odd.push_back(nums[i]);\\n            else\\n            even.push_back(nums[i]);\\n        }\\n        vector<int> even_tar, odd_tar;\\n        for(int i=0; i<n; i++){\\n            if(target[i]%2)odd_tar.push_back(target[i]);\\n            else\\n            even_tar.push_back(target[i]);\\n        }\\n        \\n        long long sum=0;\\n        for(int i=0; i<even.size(); i++){\\n            int x = even[i]-even_tar[i];\\n            if(x>=0){\\n                sum+=x;\\n            }\\n        }\\n        for(int i=0; i<odd.size(); i++){\\n            int x = odd[i]-odd_tar[i];\\n            if(x>=0){\\n                sum+=x;\\n            }\\n        }\\n        return sum/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> even, odd;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        for(int i=0; i<n; i++){\\n            if(nums[i]%2)odd.push_back(nums[i]);\\n            else\\n            even.push_back(nums[i]);\\n        }\\n        vector<int> even_tar, odd_tar;\\n        for(int i=0; i<n; i++){\\n            if(target[i]%2)odd_tar.push_back(target[i]);\\n            else\\n            even_tar.push_back(target[i]);\\n        }\\n        \\n        long long sum=0;\\n        for(int i=0; i<even.size(); i++){\\n            int x = even[i]-even_tar[i];\\n            if(x>=0){\\n                sum+=x;\\n            }\\n        }\\n        for(int i=0; i<odd.size(); i++){\\n            int x = odd[i]-odd_tar[i];\\n            if(x>=0){\\n                sum+=x;\\n            }\\n        }\\n        return sum/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399356,
                "title": "c-solution-easy-90-prateek-ece",
                "content": "# Intuition- \"Do\\'nt mind grammatical mistakes\".\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPura khel odd even ka hai. Do\\'nt worry it\\'s problem like two pointer. \\nThe only thing to keep in mind is to make the vectors of odd and even separate. Okay.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlong(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n\\n# Code\\n```\\nlong long solve(vector<int>& arr , vector<int>& target){\\n    long long total=0;\\n    for (int i=0; i<arr.size(); i++){\\n        total+=(  abs(target[i]-arr[i])/2);\\n    }\\n    return total;\\n}\\n\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        // Here we separated odd and even of nums and targets.\\n        vector<int> nums_eve;\\n        vector<int> nums_odd;\\n        vector<int> target_eve;\\n        vector<int> target_odd;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n\\n        for(auto i: nums){\\n            if (i%2==1){\\n                nums_odd.push_back(i);\\n            }\\n            else{\\n                nums_eve.push_back(i);\\n            }\\n        }\\n        \\n        for(auto i: target){\\n            if (i%2==1){\\n                target_odd.push_back(i);\\n            }\\n            else{\\n                target_eve.push_back(i);\\n            }\\n        }\\n        // separate ans1 and ans2 for odd and even value.\\n        long long ans1=solve(nums_eve,target_eve);\\n        long long ans2=solve(nums_odd,target_odd);\\n        cout<<ans1<<\" \"<<ans2<<endl;\\n        // divided by 2 because we need to consider i+2 and i-2 in one operation  \\'\\'\\'\\'\\'\\'\\n        return (ans1+ans2)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long solve(vector<int>& arr , vector<int>& target){\\n    long long total=0;\\n    for (int i=0; i<arr.size(); i++){\\n        total+=(  abs(target[i]-arr[i])/2);\\n    }\\n    return total;\\n}\\n\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        // Here we separated odd and even of nums and targets.\\n        vector<int> nums_eve;\\n        vector<int> nums_odd;\\n        vector<int> target_eve;\\n        vector<int> target_odd;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n\\n        for(auto i: nums){\\n            if (i%2==1){\\n                nums_odd.push_back(i);\\n            }\\n            else{\\n                nums_eve.push_back(i);\\n            }\\n        }\\n        \\n        for(auto i: target){\\n            if (i%2==1){\\n                target_odd.push_back(i);\\n            }\\n            else{\\n                target_eve.push_back(i);\\n            }\\n        }\\n        // separate ans1 and ans2 for odd and even value.\\n        long long ans1=solve(nums_eve,target_eve);\\n        long long ans2=solve(nums_odd,target_odd);\\n        cout<<ans1<<\" \"<<ans2<<endl;\\n        // divided by 2 because we need to consider i+2 and i-2 in one operation  \\'\\'\\'\\'\\'\\'\\n        return (ans1+ans2)/2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3392651,
                "title": "ruby-sort-and-partition",
                "content": "# Code\\n```ruby []\\ndef make_similar(nums, target)\\n  [nums, target]\\n    .map { _1.sort.partition(&:even?) }\\n    .transpose\\n    .sum { |nums, target| nums.zip(target).sum { (_1 - _2).abs } } / 4\\nend\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(n \\\\log n)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(n)$$",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Math"
                ],
                "code": "```ruby []\\ndef make_similar(nums, target)\\n  [nums, target]\\n    .map { _1.sort.partition(&:even?) }\\n    .transpose\\n    .sum { |nums, target| nums.zip(target).sum { (_1 - _2).abs } } / 4\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3338150,
                "title": "c-golang-greedy-sorting-sc-o-1",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    static bool comp(int &A, int &B) {\\n        return (A & 1) < (B & 1) || ((A & 1) == (B & 1) && A < B); \\n    }\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(), nums.end(), comp);\\n        sort(target.begin(), target.end(), comp);\\n        long long count = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            count += abs(nums[i] - target[i]); \\n        }\\n        return count >> 2;\\n    }\\n};\\n\\n//------------------------------------------------\\n\\n// Golang\\nfunc abs(a int) int {\\n    if a < 0 {return -a}\\n    return a\\n}\\n\\nfunc makeSimilar(nums []int, target []int) int64 {\\n    sort.Slice(nums, func(i, j int) bool {\\n        return nums[i] % 2 < nums[j] % 2 || (nums[i] % 2 == nums[j] % 2 && nums[i] < nums[j])\\n    })\\n    sort.Slice(target, func(i, j int) bool {\\n        return target[i] % 2 < target[j] % 2 || (target[i] % 2 == target[j] % 2 && target[i] < target[j])\\n    })\\n    var count int64 = 0\\n    for i := 0; i < len(nums); i++ {\\n        count += int64(abs(nums[i] - target[i])) \\n    }\\n    return count >> 2\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    static bool comp(int &A, int &B) {\\n        return (A & 1) < (B & 1) || ((A & 1) == (B & 1) && A < B); \\n    }\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(), nums.end(), comp);\\n        sort(target.begin(), target.end(), comp);\\n        long long count = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            count += abs(nums[i] - target[i]); \\n        }\\n        return count >> 2;\\n    }\\n};\\n\\n//------------------------------------------------\\n\\n// Golang\\nfunc abs(a int) int {\\n    if a < 0 {return -a}\\n    return a\\n}\\n\\nfunc makeSimilar(nums []int, target []int) int64 {\\n    sort.Slice(nums, func(i, j int) bool {\\n        return nums[i] % 2 < nums[j] % 2 || (nums[i] % 2 == nums[j] % 2 && nums[i] < nums[j])\\n    })\\n    sort.Slice(target, func(i, j int) bool {\\n        return target[i] % 2 < target[j] % 2 || (target[i] % 2 == target[j] % 2 && target[i] < target[j])\\n    })\\n    var count int64 = 0\\n    for i := 0; i < len(nums); i++ {\\n        count += int64(abs(nums[i] - target[i])) \\n    }\\n    return count >> 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330560,
                "title": "java-easy-solution-odd-even-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution always exist to make two arrays similar\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just have to increment and decrement, odd elements of nums with odd elements of target and same with even elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N long n)\\nTo sort both arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n2N : Elements of Nums + target, in 4 diff arraylist.\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeSimilar(int[] A, int[] B) {\\n        Arrays.sort(A); Arrays.sort(B);\\n        List<Integer> oddA = new ArrayList<>(), evenA = new ArrayList<>(),\\n        oddB = new ArrayList<>(), evenB = new ArrayList<>();\\n\\n        for(int i=0; i<A.length; i++){\\n            if(A[i]%2 == 1) oddA.add(A[i]);\\n            else evenA.add(A[i]);\\n            if(B[i]%2 == 1) oddB.add(B[i]);\\n            else evenB.add(B[i]);\\n        }\\n\\n        long ans = 0;\\n        for(int i=0; i<oddA.size(); i++){\\n            if(oddA.get(i) > oddB.get(i)) \\n                ans += (oddA.get(i) - oddB.get(i)) / 2;\\n        }\\n        for(int i=0; i<evenA.size(); i++){\\n            if(evenA.get(i) > evenB.get(i))\\n                ans += (evenA.get(i) - evenB.get(i)) / 2;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] A, int[] B) {\\n        Arrays.sort(A); Arrays.sort(B);\\n        List<Integer> oddA = new ArrayList<>(), evenA = new ArrayList<>(),\\n        oddB = new ArrayList<>(), evenB = new ArrayList<>();\\n\\n        for(int i=0; i<A.length; i++){\\n            if(A[i]%2 == 1) oddA.add(A[i]);\\n            else evenA.add(A[i]);\\n            if(B[i]%2 == 1) oddB.add(B[i]);\\n            else evenB.add(B[i]);\\n        }\\n\\n        long ans = 0;\\n        for(int i=0; i<oddA.size(); i++){\\n            if(oddA.get(i) > oddB.get(i)) \\n                ans += (oddA.get(i) - oddB.get(i)) / 2;\\n        }\\n        for(int i=0; i<evenA.size(); i++){\\n            if(evenA.get(i) > evenB.get(i))\\n                ans += (evenA.get(i) - evenB.get(i)) / 2;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291927,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        List<Integer> numsOdd = new ArrayList<>();\\n        List<Integer> numsEven = new ArrayList<>();\\n        List<Integer> targetOdd = new ArrayList<>();\\n        List<Integer> targetEven = new ArrayList<>();\\n        for(int i : nums){\\n            if(i%2 != 0)\\n                numsOdd.add(i);\\n            else\\n                numsEven.add(i);\\n        }\\n\\n        for(int i : target){\\n            if(i%2 != 0)\\n                targetOdd.add(i);\\n            else\\n                targetEven.add(i);\\n        }\\n\\n        Collections.sort(numsOdd);\\n        Collections.sort(numsEven);\\n        Collections.sort(targetOdd);\\n        Collections.sort(targetEven);\\n        long ans = 0;\\n        for(int i = 0; i < numsOdd.size(); i++)\\n            ans += Math.abs(numsOdd.get(i) - targetOdd.get(i));\\n        for(int i = 0; i < numsEven.size(); i++)\\n            ans += Math.abs(numsEven.get(i) - targetEven.get(i));\\n        return ans/4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        List<Integer> numsOdd = new ArrayList<>();\\n        List<Integer> numsEven = new ArrayList<>();\\n        List<Integer> targetOdd = new ArrayList<>();\\n        List<Integer> targetEven = new ArrayList<>();\\n        for(int i : nums){\\n            if(i%2 != 0)\\n                numsOdd.add(i);\\n            else\\n                numsEven.add(i);\\n        }\\n\\n        for(int i : target){\\n            if(i%2 != 0)\\n                targetOdd.add(i);\\n            else\\n                targetEven.add(i);\\n        }\\n\\n        Collections.sort(numsOdd);\\n        Collections.sort(numsEven);\\n        Collections.sort(targetOdd);\\n        Collections.sort(targetEven);\\n        long ans = 0;\\n        for(int i = 0; i < numsOdd.size(); i++)\\n            ans += Math.abs(numsOdd.get(i) - targetOdd.get(i));\\n        for(int i = 0; i < numsEven.size(); i++)\\n            ans += Math.abs(numsEven.get(i) - targetEven.get(i));\\n        return ans/4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281737,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSimilar(self, nums, target):\\n        odd_n, even_n = sorted([i for i in nums if i%2 == 1]), sorted([i for i in nums if i%2 == 0])\\n        odd_t, even_t = sorted([i for i in target if i%2 == 1]), sorted([i for i in target if i%2 == 0])\\n\\n        total = 0\\n\\n        for i,j in zip(odd_n,odd_t):\\n            if i <= j:\\n                total += j-i\\n\\n        for i,j in zip(even_n,even_t):\\n            if i <= j:\\n                total += j-i \\n\\n        return total//2\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums, target):\\n        odd_n, even_n = sorted([i for i in nums if i%2 == 1]), sorted([i for i in nums if i%2 == 0])\\n        odd_t, even_t = sorted([i for i in target if i%2 == 1]), sorted([i for i in target if i%2 == 0])\\n\\n        total = 0\\n\\n        for i,j in zip(odd_n,odd_t):\\n            if i <= j:\\n                total += j-i\\n\\n        for i,j in zip(even_n,even_t):\\n            if i <= j:\\n                total += j-i \\n\\n        return total//2\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253981,
                "title": "java-wow-very-easy-solution-100-faster-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/957a09a8-9eeb-4bc8-826d-f8347bc58c66_1677892630.955954.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//O(n*log(n)) time and O(n*log(n)) space\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        /*\\n            Split odd and even numbers into separate PriorityQueues because buy addding/removing 2 we will never change remainder\\n        */\\n        PriorityQueue<Integer> pqNumsOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqNumsEven = new PriorityQueue<>();\\n        \\n        PriorityQueue<Integer> pqTargetOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqTargetEven = new PriorityQueue<>();\\n\\n        for(int num : nums) {\\n            if(num % 2 == 0) {\\n                pqNumsEven.add(num);\\n            } else {\\n                pqNumsOdd.add(num);\\n            }\\n        }\\n        \\n        for(int tar : target) {\\n            if(tar % 2 == 0) {\\n                pqTargetEven.add(tar);\\n            } else {\\n                pqTargetOdd.add(tar);\\n            }            \\n        }\\n        \\n        long[] evens = helper(pqNumsEven, pqTargetEven, 0L, 0L);\\n        //pass number of adds and subs that we used in calculation of even numbers\\n        long[] odds = helper(pqNumsOdd, pqTargetOdd, evens[1], evens[2]);\\n        \\n        return evens[0] + odds[0];\\n    }\\n    \\n    private long[] helper(PriorityQueue<Integer> pqNums, PriorityQueue<Integer> pqTarget, long add, long sub) {\\n        //greedy solution\\n        long out = 0;\\n        \\n        while(!pqNums.isEmpty()) {\\n            //get smallest numbers from nums and target and see if we can match them\\n            int num = pqNums.poll();\\n            int target = pqTarget.poll();\\n            \\n            if(num < target) {\\n                //calculate number of operations we need to use to make numbers similar and apply free adds we gained by previously using subs\\n                long diff = (target - num) / 2 - add;\\n                \\n                if(diff > 0) {\\n                    //how many operations we need to use\\n                    out += diff;\\n                    //no free adds\\n                    add = 0;\\n                    //add free subs we can use later\\n                    sub += diff;\\n                } else {\\n                    //still have some adds to use in the future (or 0)\\n                    add = -diff;\\n                }\\n            } else {\\n                long diff = (num - target) / 2 - sub;\\n                \\n                if(diff > 0) {\\n                    out += diff;\\n                    sub = 0;\\n                    add += diff;\\n                }\\n            }\\n        }\\n        \\n        return new long[] {out, add, sub};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(n*log(n)) time and O(n*log(n)) space\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        /*\\n            Split odd and even numbers into separate PriorityQueues because buy addding/removing 2 we will never change remainder\\n        */\\n        PriorityQueue<Integer> pqNumsOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqNumsEven = new PriorityQueue<>();\\n        \\n        PriorityQueue<Integer> pqTargetOdd = new PriorityQueue<>();\\n        PriorityQueue<Integer> pqTargetEven = new PriorityQueue<>();\\n\\n        for(int num : nums) {\\n            if(num % 2 == 0) {\\n                pqNumsEven.add(num);\\n            } else {\\n                pqNumsOdd.add(num);\\n            }\\n        }\\n        \\n        for(int tar : target) {\\n            if(tar % 2 == 0) {\\n                pqTargetEven.add(tar);\\n            } else {\\n                pqTargetOdd.add(tar);\\n            }            \\n        }\\n        \\n        long[] evens = helper(pqNumsEven, pqTargetEven, 0L, 0L);\\n        //pass number of adds and subs that we used in calculation of even numbers\\n        long[] odds = helper(pqNumsOdd, pqTargetOdd, evens[1], evens[2]);\\n        \\n        return evens[0] + odds[0];\\n    }\\n    \\n    private long[] helper(PriorityQueue<Integer> pqNums, PriorityQueue<Integer> pqTarget, long add, long sub) {\\n        //greedy solution\\n        long out = 0;\\n        \\n        while(!pqNums.isEmpty()) {\\n            //get smallest numbers from nums and target and see if we can match them\\n            int num = pqNums.poll();\\n            int target = pqTarget.poll();\\n            \\n            if(num < target) {\\n                //calculate number of operations we need to use to make numbers similar and apply free adds we gained by previously using subs\\n                long diff = (target - num) / 2 - add;\\n                \\n                if(diff > 0) {\\n                    //how many operations we need to use\\n                    out += diff;\\n                    //no free adds\\n                    add = 0;\\n                    //add free subs we can use later\\n                    sub += diff;\\n                } else {\\n                    //still have some adds to use in the future (or 0)\\n                    add = -diff;\\n                }\\n            } else {\\n                long diff = (num - target) / 2 - sub;\\n                \\n                if(diff > 0) {\\n                    out += diff;\\n                    sub = 0;\\n                    add += diff;\\n                }\\n            }\\n        }\\n        \\n        return new long[] {out, add, sub};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246549,
                "title": "most-easy-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& v, vector<int>& ve) {\\n        long long sum=0;\\n        sort(v.begin(),v.end());\\n        sort(ve.begin(),ve.end());\\n        vector<int>a,b,c,d;\\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i]&1) a.push_back(v[i]);\\n            else b.push_back(v[i]);\\n            if(ve[i]&1) c.push_back(ve[i]);\\n            else d.push_back(ve[i]);\\n        }\\n        for(int i=0; i<a.size(); i++) sum+=abs(a[i]-c[i]);\\n        for(int i=0; i<b.size(); i++) sum+=abs(b[i]-d[i]);\\n        \\n        return sum/4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& v, vector<int>& ve) {\\n        long long sum=0;\\n        sort(v.begin(),v.end());\\n        sort(ve.begin(),ve.end());\\n        vector<int>a,b,c,d;\\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i]&1) a.push_back(v[i]);\\n            else b.push_back(v[i]);\\n            if(ve[i]&1) c.push_back(ve[i]);\\n            else d.push_back(ve[i]);\\n        }\\n        for(int i=0; i<a.size(); i++) sum+=abs(a[i]-c[i]);\\n        for(int i=0; i<b.size(); i++) sum+=abs(b[i]-d[i]);\\n        \\n        return sum/4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173531,
                "title": "simple-python-solution-using-heap-with-tc-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums.sort()\\n        odd, even = [], []\\n        for i in target:\\n            if(i % 2):\\n                heappush(odd, i)\\n            else:\\n                heappush(even, i)\\n        ans = 0\\n        for i in nums:\\n            if(i % 2):\\n                ele = heappop(odd)\\n                ans += abs(i-ele)//2\\n            else:\\n                ele = heappop(even)\\n                ans += abs(i-ele)//2\\n        return ans//2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums.sort()\\n        odd, even = [], []\\n        for i in target:\\n            if(i % 2):\\n                heappush(odd, i)\\n            else:\\n                heappush(even, i)\\n        ans = 0\\n        for i in nums:\\n            if(i % 2):\\n                ele = heappop(odd)\\n                ans += abs(i-ele)//2\\n            else:\\n                ele = heappop(even)\\n                ans += abs(i-ele)//2\\n        return ans//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171677,
                "title": "c-greedy-sorting-even-and-odd",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector <int> even,odd;   \\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2){\\n                odd.push_back(nums[i]);\\n            }\\n            else{\\n                even.push_back(nums[i]);\\n            }\\n        }\\n        long long i=0,j=0;          \\n        long long inc=0,dec=0;\\n        for(int k=0;k<target.size();k++){\\n            long long d;\\n            if(target[k]%2){\\n                d=1LL*odd[j++]-target[k];\\n            }\\n            else{\\n                d=1LL*even[i++]-target[k];\\n            }\\n            if(d<0){\\n                inc+=abs(d/2);\\n            }\\n            else{\\n                dec+=abs(d/2);\\n            }\\n        }\\n        long long ans=min(inc,dec)+(abs(inc-dec)/2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector <int> even,odd;   \\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2){\\n                odd.push_back(nums[i]);\\n            }\\n            else{\\n                even.push_back(nums[i]);\\n            }\\n        }\\n        long long i=0,j=0;          \\n        long long inc=0,dec=0;\\n        for(int k=0;k<target.size();k++){\\n            long long d;\\n            if(target[k]%2){\\n                d=1LL*odd[j++]-target[k];\\n            }\\n            else{\\n                d=1LL*even[i++]-target[k];\\n            }\\n            if(d<0){\\n                inc+=abs(d/2);\\n            }\\n            else{\\n                dec+=abs(d/2);\\n            }\\n        }\\n        long long ans=min(inc,dec)+(abs(inc-dec)/2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165521,
                "title": "waste-fellow-solution-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are creating four vectors and in ecah vector we are segregating based on odd and even after that we are sorting it and then subtracting each elemnts of differenty vectors after that we are adding all into the sum and at last dividing it by 4 because one we are adding at one place simultanously we are subtracting it , but while doing the sum we are connsidering all so divide with 4.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& t) {\\n        vector<int>v1,v2,v3,v4;\\n        int len1=nums.size();\\n        long long int sum=0;\\n        for(int i=0;i<len1;i++)\\n        {\\n            if(nums[i]%2==0)\\n            v1.push_back(nums[i]);\\n            else\\n            v2.push_back(nums[i]);\\n            if(t[i]%2==0)\\n            v3.push_back(t[i]);\\n            else\\n            v4.push_back(t[i]);\\n        } \\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        sort(v3.begin(),v3.end());\\n        sort(v4.begin(),v4.end());\\n        int len2=v1.size();\\n        int len3=v2.size();\\n        for(int i=0;i<len2;i++)\\n        {\\n            long long int sum1=v1[i]-v3[i];\\n            if(sum1<0)\\n            sum1=sum1*-1;\\n            sum+=sum1;\\n        }\\n        for(int i=0;i<len3;i++)\\n        {\\n            long long int sum1=v2[i]-v4[i];\\n            if(sum1<0)\\n            sum1=sum1*-1;\\n            sum+=sum1;\\n        }\\n        return sum/4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& t) {\\n        vector<int>v1,v2,v3,v4;\\n        int len1=nums.size();\\n        long long int sum=0;\\n        for(int i=0;i<len1;i++)\\n        {\\n            if(nums[i]%2==0)\\n            v1.push_back(nums[i]);\\n            else\\n            v2.push_back(nums[i]);\\n            if(t[i]%2==0)\\n            v3.push_back(t[i]);\\n            else\\n            v4.push_back(t[i]);\\n        } \\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        sort(v3.begin(),v3.end());\\n        sort(v4.begin(),v4.end());\\n        int len2=v1.size();\\n        int len3=v2.size();\\n        for(int i=0;i<len2;i++)\\n        {\\n            long long int sum1=v1[i]-v3[i];\\n            if(sum1<0)\\n            sum1=sum1*-1;\\n            sum+=sum1;\\n        }\\n        for(int i=0;i<len3;i++)\\n        {\\n            long long int sum1=v2[i]-v4[i];\\n            if(sum1<0)\\n            sum1=sum1*-1;\\n            sum+=sum1;\\n        }\\n        return sum/4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161501,
                "title": "c-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long c1=0;\\n       vector<int> a,b,c,d;\\n       sort(target.begin(),target.end());\\n       sort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]%2==0)\\n           a.push_back(nums[i]);\\n           else\\n           c.push_back(nums[i]);\\n           if(target[i]%2==0)\\n           b.push_back(target[i]);\\n           else\\n           d.push_back(target[i]);\\n       }\\n       for(int i=0;i<a.size();i++)\\n           c1+=abs(a[i]-b[i])/2;\\n       \\n     for(int i=0;i<c.size();i++)\\n           c1+=abs(c[i]-d[i])/2;\\n      return c1/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long c1=0;\\n       vector<int> a,b,c,d;\\n       sort(target.begin(),target.end());\\n       sort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]%2==0)\\n           a.push_back(nums[i]);\\n           else\\n           c.push_back(nums[i]);\\n           if(target[i]%2==0)\\n           b.push_back(target[i]);\\n           else\\n           d.push_back(target[i]);\\n       }\\n       for(int i=0;i<a.size();i++)\\n           c1+=abs(a[i]-b[i])/2;\\n       \\n     for(int i=0;i<c.size();i++)\\n           c1+=abs(c[i]-d[i])/2;\\n      return c1/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141366,
                "title": "easiest-solution-c-easy-to-understand-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<ll> odd1,odd2,even1,even2;\\n        for(auto i:nums) i%2==0?even1.push_back(i):odd1.push_back(i);\\n        for(auto i:target) i%2==0?even2.push_back(i):odd2.push_back(i);\\n        sort(odd1.begin(),odd1.end());\\n        sort(odd2.begin(),odd2.end());\\n        sort(even1.begin(),even1.end());\\n        sort(even2.begin(),even2.end());\\n        ll ans = 0;\\n        for(int i=0;i<odd1.size();i++) ans+=abs(odd1[i]-odd2[i]);\\n        for(int i=0;i<even1.size();i++) ans+=abs(even1[i]-even2[i]);\\n        return ans/4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<ll> odd1,odd2,even1,even2;\\n        for(auto i:nums) i%2==0?even1.push_back(i):odd1.push_back(i);\\n        for(auto i:target) i%2==0?even2.push_back(i):odd2.push_back(i);\\n        sort(odd1.begin(),odd1.end());\\n        sort(odd2.begin(),odd2.end());\\n        sort(even1.begin(),even1.end());\\n        sort(even2.begin(),even2.end());\\n        ll ans = 0;\\n        for(int i=0;i<odd1.size();i++) ans+=abs(odd1[i]-odd2[i]);\\n        for(int i=0;i<even1.size();i++) ans+=abs(even1[i]-even2[i]);\\n        return ans/4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127409,
                "title": "proper-and-beginner-friendly-solution-c",
                "content": "# Intuition\\n1. Differentiating the odd and even elements of nums in two different vectors odd1 and even1.\\n2. Differentiating the odd and even elements of target in two different vectors odd2 and even2.\\n3. Further operations on odd elements of both nums and target as well as even elements of both nums and target, We reach our solution.\\n# Approach\\nSorting technique\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n- Space complexity:\\nO(n)           \\n\\nThis is my first hard question on Leetcode..\\nSuggestions are highly appreciated\\uD83D\\uDE0A\\uD83D\\uDE4C...\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> odd1,odd2,even1,even2;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)\\n            {\\n                odd1.push_back(nums[i]);\\n            }\\n            else{\\n                even1.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]&1)\\n            {\\n                odd2.push_back(target[i]);\\n            }\\n            else{\\n                even2.push_back(target[i]);\\n            }\\n        }\\n\\n        long long int i=0,diff,plus=0,minus=0,ans;\\n        while(i<odd1.size() && i<odd2.size())\\n        {\\n            if(odd1[i]!=odd2[i])\\n            {\\n              diff=odd1[i]-odd2[i];\\n              if(diff>0)\\n              {\\n                 minus+=diff;\\n              }\\n              else{\\n                  plus-=(-1 * diff);\\n              }\\n            }\\n            i++;\\n        }\\n        \\n        i=0;\\n        while(i<even1.size() && i<even2.size())\\n        {\\n            if(even1[i]!=even2[i])\\n            {\\n                diff=even1[i]-even2[i];\\n                if(diff>0)\\n                {\\n                    minus+=diff;\\n                }\\n                else{\\n                    plus-=(-1 * diff);\\n                }\\n            }\\n            i++;\\n        }\\n        ans=minus/2;     //Since nums can always be similar to target minus value will always be equal but negative of plus(eg minus=8 -> plus=-8) \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> odd1,odd2,even1,even2;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)\\n            {\\n                odd1.push_back(nums[i]);\\n            }\\n            else{\\n                even1.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]&1)\\n            {\\n                odd2.push_back(target[i]);\\n            }\\n            else{\\n                even2.push_back(target[i]);\\n            }\\n        }\\n\\n        long long int i=0,diff,plus=0,minus=0,ans;\\n        while(i<odd1.size() && i<odd2.size())\\n        {\\n            if(odd1[i]!=odd2[i])\\n            {\\n              diff=odd1[i]-odd2[i];\\n              if(diff>0)\\n              {\\n                 minus+=diff;\\n              }\\n              else{\\n                  plus-=(-1 * diff);\\n              }\\n            }\\n            i++;\\n        }\\n        \\n        i=0;\\n        while(i<even1.size() && i<even2.size())\\n        {\\n            if(even1[i]!=even2[i])\\n            {\\n                diff=even1[i]-even2[i];\\n                if(diff>0)\\n                {\\n                    minus+=diff;\\n                }\\n                else{\\n                    plus-=(-1 * diff);\\n                }\\n            }\\n            i++;\\n        }\\n        ans=minus/2;     //Since nums can always be similar to target minus value will always be equal but negative of plus(eg minus=8 -> plus=-8) \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117818,
                "title": "python-faster-solution-easy-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first sort both of the lists. Then, we will differentiate evens from odds. After that, we calculate differences (we divide two because +2 and -2 is an one move we can make) between each odds and evens seperately. Lastly, we took (sum of differences // 2) because when we substract from one, we add to another. Both substraction and adding is a whole one move.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        evens_in_nums = []\\n        evens_in_target = []\\n        odd_in_nums = []\\n        odd_in_target = []\\n        nums.sort()\\n        target.sort()\\n        for i in nums:\\n            if i%2 == 0:\\n                evens_in_nums.append(i)\\n            else:\\n                odd_in_nums.append(i)\\n        for i in target:\\n            if i%2 == 0:\\n                evens_in_target.append(i)\\n            else:\\n                odd_in_target.append(i)\\n        dif = []\\n        for i in range(len(evens_in_nums)):\\n            current = abs(evens_in_nums[i]-evens_in_target[i])\\n            dif.append(current//2)\\n        for i in range(len(odd_in_nums)):\\n            current = abs(odd_in_nums[i]-odd_in_target[i])\\n            dif.append(current//2)\\n\\n        return sum(dif)//2\\n\\n\\n\\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        evens_in_nums = []\\n        evens_in_target = []\\n        odd_in_nums = []\\n        odd_in_target = []\\n        nums.sort()\\n        target.sort()\\n        for i in nums:\\n            if i%2 == 0:\\n                evens_in_nums.append(i)\\n            else:\\n                odd_in_nums.append(i)\\n        for i in target:\\n            if i%2 == 0:\\n                evens_in_target.append(i)\\n            else:\\n                odd_in_target.append(i)\\n        dif = []\\n        for i in range(len(evens_in_nums)):\\n            current = abs(evens_in_nums[i]-evens_in_target[i])\\n            dif.append(current//2)\\n        for i in range(len(odd_in_nums)):\\n            current = abs(odd_in_nums[i]-odd_in_target[i])\\n            dif.append(current//2)\\n\\n        return sum(dif)//2\\n\\n\\n\\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116080,
                "title": "simple-c-solution-using-sorting-and-greedy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        \\n        \\n        priority_queue<int,vector<int> , greater<int>> numodd;\\n        priority_queue<int,vector<int> , greater<int>> targetodd;\\n\\n        priority_queue<int,vector<int> , greater<int>> numeven;\\n        priority_queue<int,vector<int> , greater<int>> targeteven;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]%2==1){\\n                numodd.push(nums[i]);\\n            }\\n            else{\\n                numeven.push(nums[i]);\\n            }\\n\\n            if(target[i]%2==1){\\n                targetodd.push(target[i]);\\n            }\\n            else{\\n                targeteven.push(target[i]);\\n            }\\n        }\\n\\n        while(!numodd.empty()){\\n            int x = numodd.top();\\n            int y = targetodd.top();\\n            numodd.pop();\\n            targetodd.pop();\\n            if(x>y)\\n                ans += (x-y)/2;\\n        }\\n\\n        while(!numeven.empty()){\\n            int x = numeven.top();\\n            int y = targeteven.top();\\n            numeven.pop();\\n            targeteven.pop();\\n            if(x>y)\\n                ans += (x-y)/2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        \\n        \\n        priority_queue<int,vector<int> , greater<int>> numodd;\\n        priority_queue<int,vector<int> , greater<int>> targetodd;\\n\\n        priority_queue<int,vector<int> , greater<int>> numeven;\\n        priority_queue<int,vector<int> , greater<int>> targeteven;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(nums[i]%2==1){\\n                numodd.push(nums[i]);\\n            }\\n            else{\\n                numeven.push(nums[i]);\\n            }\\n\\n            if(target[i]%2==1){\\n                targetodd.push(target[i]);\\n            }\\n            else{\\n                targeteven.push(target[i]);\\n            }\\n        }\\n\\n        while(!numodd.empty()){\\n            int x = numodd.top();\\n            int y = targetodd.top();\\n            numodd.pop();\\n            targetodd.pop();\\n            if(x>y)\\n                ans += (x-y)/2;\\n        }\\n\\n        while(!numeven.empty()){\\n            int x = numeven.top();\\n            int y = targeteven.top();\\n            numeven.pop();\\n            targeteven.pop();\\n            if(x>y)\\n                ans += (x-y)/2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112924,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def makeSimilar(nums: Array[Int], target: Array[Int]): Long = {\\n        val (a1, b1) = nums.partition(_ % 2 == 0)\\n        val (a2, b2) = target.partition(_ % 2 == 0)\\n        ((a1.sorted zip a2.sorted).map(n => (n._2.toLong - n._1).abs / 2).sum + (b1.sorted zip b2.sorted).map(n => (n._2.toLong - n._1).abs / 2).sum) / 2\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def makeSimilar(nums: Array[Int], target: Array[Int]): Long = {\\n        val (a1, b1) = nums.partition(_ % 2 == 0)\\n        val (a2, b2) = target.partition(_ % 2 == 0)\\n        ((a1.sorted zip a2.sorted).map(n => (n._2.toLong - n._1).abs / 2).sum + (b1.sorted zip b2.sorted).map(n => (n._2.toLong - n._1).abs / 2).sum) / 2\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3082824,
                "title": "c-priority-queue-or-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n     \\n        long long a=0;\\n        long long b=0;\\n      \\n        sort(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>>even;\\n        priority_queue<int,vector<int>,greater<int>>odd;\\n\\n        \\n        \\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]%2==0)\\n                even.push(target[i]);\\n            else\\n                odd.push(target[i]);\\n\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n               target[i]=even.top();\\n        \\n                even.pop();\\n                \\n            }\\n            else\\n            {\\n                 target[i]=odd.top();\\n                odd.pop();\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=target[i])\\n           { \\n            int d=nums[i]-target[i];\\n            \\n            int z=abs(d/2);\\n            \\n             if(d<0)\\n             {\\n               a+=z; \\n              }\\n             else\\n             {\\n               b+=z; \\n              }\\n            }\\n        }\\n        \\n        return a;\\n    }\\n};\\n```\\n\\nsimilar problem : https://leetcode.com/contest/biweekly-contest-96/problems/minimum-operations-to-make-array-equal-ii/\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n     \\n        long long a=0;\\n        long long b=0;\\n      \\n        sort(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>>even;\\n        priority_queue<int,vector<int>,greater<int>>odd;\\n\\n        \\n        \\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]%2==0)\\n                even.push(target[i]);\\n            else\\n                odd.push(target[i]);\\n\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n               target[i]=even.top();\\n        \\n                even.pop();\\n                \\n            }\\n            else\\n            {\\n                 target[i]=odd.top();\\n                odd.pop();\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=target[i])\\n           { \\n            int d=nums[i]-target[i];\\n            \\n            int z=abs(d/2);\\n            \\n             if(d<0)\\n             {\\n               a+=z; \\n              }\\n             else\\n             {\\n               b+=z; \\n              }\\n            }\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074208,
                "title": "easy-to-understand-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>&v, vector<int>&t) {\\n        vector<int>ev,et,ov,ot;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]%2==0)ev.push_back(v[i]);\\n            else ov.push_back(v[i]);\\n            if(t[i]%2==0)et.push_back(t[i]);\\n            else ot.push_back(t[i]);\\n        }\\n        sort(ev.begin(),ev.end());\\n        sort(ov.begin(),ov.end());\\n        sort(et.begin(),et.end());\\n        sort(ot.begin(),ot.end());\\n        ll cnt=0;  \\n        for(int i=0;i<ev.size();i++){\\n            if(ev[i]>et[i]){\\n                cnt+=ev[i]-et[i];\\n            }\\n        }\\n        for(int i=0;i<ov.size();i++){\\n            if(ov[i]>ot[i]){\\n                cnt+=ov[i]-ot[i];\\n            }\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>&v, vector<int>&t) {\\n        vector<int>ev,et,ov,ot;\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]%2==0)ev.push_back(v[i]);\\n            else ov.push_back(v[i]);\\n            if(t[i]%2==0)et.push_back(t[i]);\\n            else ot.push_back(t[i]);\\n        }\\n        sort(ev.begin(),ev.end());\\n        sort(ov.begin(),ov.end());\\n        sort(et.begin(),et.end());\\n        sort(ot.begin(),ot.end());\\n        ll cnt=0;  \\n        for(int i=0;i<ev.size();i++){\\n            if(ev[i]>et[i]){\\n                cnt+=ev[i]-et[i];\\n            }\\n        }\\n        for(int i=0;i<ov.size();i++){\\n            if(ov[i]>ot[i]){\\n                cnt+=ov[i]-ot[i];\\n            }\\n        }\\n        return cnt/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993822,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\nvar makeSimilar = function (nums, target) {\\n  const numsEven = [];\\n  const numsOdd = [];\\n  nums.forEach((num) => {\\n    if (num % 2 == 0) {\\n      numsEven.push(num);\\n    } else {\\n      numsOdd.push(num);\\n    }\\n  });\\n  const targetEven = [];\\n  const targetOdd = [];\\n  target.forEach((num) => {\\n    if (num % 2 == 0) {\\n      targetEven.push(num);\\n    } else {\\n      targetOdd.push(num);\\n    }\\n  });\\n  numsEven.sort((a, b) => a - b);\\n  numsOdd.sort((a, b) => a - b);\\n  targetEven.sort((a, b) => a - b);\\n  targetOdd.sort((a, b) => a - b);\\n  let result = 0;\\n  for (let i = 0; i < numsEven.length; i++) {\\n    result += Math.abs(numsEven[i] - targetEven[i]);\\n  }\\n  for (let i = 0; i < numsOdd.length; i++) {\\n    result += Math.abs(numsOdd[i] - targetOdd[i]);\\n  }\\n  return result / 4;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\nvar makeSimilar = function (nums, target) {\\n  const numsEven = [];\\n  const numsOdd = [];\\n  nums.forEach((num) => {\\n    if (num % 2 == 0) {\\n      numsEven.push(num);\\n    } else {\\n      numsOdd.push(num);\\n    }\\n  });\\n  const targetEven = [];\\n  const targetOdd = [];\\n  target.forEach((num) => {\\n    if (num % 2 == 0) {\\n      targetEven.push(num);\\n    } else {\\n      targetOdd.push(num);\\n    }\\n  });\\n  numsEven.sort((a, b) => a - b);\\n  numsOdd.sort((a, b) => a - b);\\n  targetEven.sort((a, b) => a - b);\\n  targetOdd.sort((a, b) => a - b);\\n  let result = 0;\\n  for (let i = 0; i < numsEven.length; i++) {\\n    result += Math.abs(numsEven[i] - targetEven[i]);\\n  }\\n  for (let i = 0; i < numsOdd.length; i++) {\\n    result += Math.abs(numsOdd[i] - targetOdd[i]);\\n  }\\n  return result / 4;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973741,
                "title": "sort-break-odd-even-c-7-lines-code",
                "content": "***The code that challenges you is the code that changes you***\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());sort(target.begin(),target.end());\\n        vector<int>odd_nums,even_nums,odd_target,even_target;long long int moves=0;\\n        for(auto &num:nums)num%2?odd_nums.push_back(num):even_nums.push_back(num);\\n        for(auto &num:target)num%2?odd_target.push_back(num):even_target.push_back(num);\\n        for(int i=0;i<odd_nums.size();i++)moves+=abs(odd_nums[i]-odd_target[i]);\\n        for(int i=0;i<even_nums.size();i++)moves+=abs(even_nums[i]-even_target[i]);\\n        return moves/4;\\n    }\\n};\\n```\\n**logik:**\\n1.sort both the arrays\\n2.seperate each array into odd and even parts\\n3.match odd part with the odd part as number of odd numbers will be same in nums and target (can be proven from given)\\n4.match even part with even part\\n5.take a summation of absolute of differences in both matchings\\n6.divide it by 2 (as in each moves number can be +-2) and divide by 2 again(as in each moves we are actually making 2 moves +2 and -2)\\n7.return the moves",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());sort(target.begin(),target.end());\\n        vector<int>odd_nums,even_nums,odd_target,even_target;long long int moves=0;\\n        for(auto &num:nums)num%2?odd_nums.push_back(num):even_nums.push_back(num);\\n        for(auto &num:target)num%2?odd_target.push_back(num):even_target.push_back(num);\\n        for(int i=0;i<odd_nums.size();i++)moves+=abs(odd_nums[i]-odd_target[i]);\\n        for(int i=0;i<even_nums.size();i++)moves+=abs(even_nums[i]-even_target[i]);\\n        return moves/4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973583,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans=0;\\n\\n        int inc=0,dec=0;\\n        vector<int> numsE;\\n        vector<int> numsO;\\n        vector<int> targetE;\\n        vector<int> targetO;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n            numsE.push_back(nums[i]);\\n            else\\n            numsO.push_back(nums[i]);\\n\\n            if(target[i]%2==0)\\n            targetE.push_back(target[i]);\\n            else\\n            targetO.push_back(target[i]);\\n        }\\n\\n        for(int i=0;i<numsE.size();i++)\\n        {\\n            if(numsE[i]>targetE[i])\\n            {\\n                ans=ans+(numsE[i]-targetE[i])/2;\\n            }\\n        }\\n\\n        for(int i=0;i<numsO.size();i++)\\n        {\\n            if(numsO[i]>targetO[i])\\n            ans=ans+(numsO[i]-targetO[i])/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans=0;\\n\\n        int inc=0,dec=0;\\n        vector<int> numsE;\\n        vector<int> numsO;\\n        vector<int> targetE;\\n        vector<int> targetO;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n            numsE.push_back(nums[i]);\\n            else\\n            numsO.push_back(nums[i]);\\n\\n            if(target[i]%2==0)\\n            targetE.push_back(target[i]);\\n            else\\n            targetO.push_back(target[i]);\\n        }\\n\\n        for(int i=0;i<numsE.size();i++)\\n        {\\n            if(numsE[i]>targetE[i])\\n            {\\n                ans=ans+(numsE[i]-targetE[i])/2;\\n            }\\n        }\\n\\n        for(int i=0;i<numsO.size();i++)\\n        {\\n            if(numsO[i]>targetO[i])\\n            ans=ans+(numsO[i]-targetO[i])/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901992,
                "title": "super-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSimilar(self, nm: List[int], tg: List[int]) -> int:\\n        nm.sort()\\n        tg.sort()\\n        p=0\\n        nme=[]\\n        nmo=[]\\n        for a in nm:\\n            if(a%2==0):\\n                nme.append(a)\\n            else:\\n                nmo.append(a)\\n        tge=[]\\n        tgo=[]\\n        for a in tg:\\n            if(a%2==0):\\n                tge.append(a)\\n            else:\\n                tgo.append(a)\\n        for i in range(len(tgo)):\\n            if(tgo[i]-nmo[i]>0):\\n                p+=tgo[i]-nmo[i]\\n        for i in range(len(tge)):\\n            if(tge[i]-nme[i]>0):\\n                p+=tge[i]-nme[i]\\n        return p//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nm: List[int], tg: List[int]) -> int:\\n        nm.sort()\\n        tg.sort()\\n        p=0\\n        nme=[]\\n        nmo=[]\\n        for a in nm:\\n            if(a%2==0):\\n                nme.append(a)\\n            else:\\n                nmo.append(a)\\n        tge=[]\\n        tgo=[]\\n        for a in tg:\\n            if(a%2==0):\\n                tge.append(a)\\n            else:\\n                tgo.append(a)\\n        for i in range(len(tgo)):\\n            if(tgo[i]-nmo[i]>0):\\n                p+=tgo[i]-nmo[i]\\n        for i in range(len(tge)):\\n            if(tge[i]-nme[i]>0):\\n                p+=tge[i]-nme[i]\\n        return p//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889615,
                "title": "python3-easiest-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeSimilar(self, A, B):\\n        A1 = sorted(a for a in A if a % 2)\\n        B1 = sorted(a for a in B if a % 2)\\n        A2 = sorted(a for a in A if a % 2 == 0)\\n        B2 = sorted(a for a in B if a % 2 == 0)\\n        res1 = sum(abs(a - b) // 2 for a,b in zip(A1, B1))\\n        res2 = sum(abs(a - b) // 2 for a,b in zip(A2, B2))\\n        return (res1 + res2) // 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, A, B):\\n        A1 = sorted(a for a in A if a % 2)\\n        B1 = sorted(a for a in B if a % 2)\\n        A2 = sorted(a for a in A if a % 2 == 0)\\n        B2 = sorted(a for a in B if a % 2 == 0)\\n        res1 = sum(abs(a - b) // 2 for a,b in zip(A1, B1))\\n        res2 = sum(abs(a - b) // 2 for a,b in zip(A2, B2))\\n        return (res1 + res2) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883690,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n\\nIf you like the solution please upvote it....\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        vector<int>evennums,oddnums;\\n        vector<int>eventar,oddtar;\\n        \\n        int n = nums.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(nums[i]%2 == 0)evennums.push_back(nums[i]);\\n            else oddnums.push_back(nums[i]);\\n            \\n            if(target[i]%2 == 0) eventar.push_back(target[i]);\\n            else oddtar.push_back(target[i]);\\n        }\\n        \\n        long long count = 0;\\n        for(int i = 0;i<evennums.size();i++)\\n        {\\n            count+=abs(eventar[i] - evennums[i])/2;\\n            \\n        }\\n        \\n        for(int i = 0;i<oddnums.size();i++)\\n        {\\n            count+=abs(oddtar[i] - oddnums[i])/2;\\n        }\\n        \\n        return count/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        vector<int>evennums,oddnums;\\n        vector<int>eventar,oddtar;\\n        \\n        int n = nums.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(nums[i]%2 == 0)evennums.push_back(nums[i]);\\n            else oddnums.push_back(nums[i]);\\n            \\n            if(target[i]%2 == 0) eventar.push_back(target[i]);\\n            else oddtar.push_back(target[i]);\\n        }\\n        \\n        long long count = 0;\\n        for(int i = 0;i<evennums.size();i++)\\n        {\\n            count+=abs(eventar[i] - evennums[i])/2;\\n            \\n        }\\n        \\n        for(int i = 0;i<oddnums.size();i++)\\n        {\\n            count+=abs(oddtar[i] - oddnums[i])/2;\\n        }\\n        \\n        return count/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883425,
                "title": "sorting-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncompare odd and even elements of both separately\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) sorting\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n=target.size();\\n        sort(nums.begin(),nums.end()); \\n        sort(target.begin(),target.end());\\n        long long ans=0;\\n        vector<int>onums,enums,otar,etar;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                enums.push_back(nums[i]);\\n            }\\n            else{\\n                onums.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(target[i]%2==0){\\n                etar.push_back(target[i]);\\n            }\\n            else{\\n                otar.push_back(target[i]);\\n            }\\n        }\\n        for(int i=0;i<onums.size();i++){\\n            if(onums[i]<otar[i]){\\n                ans+= (otar[i]-onums[i])/2;\\n            }\\n        }\\n        for(int i=0;i<enums.size();i++){\\n            if(enums[i]<etar[i]){\\n                ans+= (etar[i]-enums[i])/2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n=target.size();\\n        sort(nums.begin(),nums.end()); \\n        sort(target.begin(),target.end());\\n        long long ans=0;\\n        vector<int>onums,enums,otar,etar;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                enums.push_back(nums[i]);\\n            }\\n            else{\\n                onums.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(target[i]%2==0){\\n                etar.push_back(target[i]);\\n            }\\n            else{\\n                otar.push_back(target[i]);\\n            }\\n        }\\n        for(int i=0;i<onums.size();i++){\\n            if(onums[i]<otar[i]){\\n                ans+= (otar[i]-onums[i])/2;\\n            }\\n        }\\n        for(int i=0;i<enums.size();i++){\\n            if(enums[i]<etar[i]){\\n                ans+= (etar[i]-enums[i])/2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868373,
                "title": "c-split-odd-even-sort-two-pointer",
                "content": "The problem says that the answer is guaranteed, so it implies\\n1. the sum of two array are equal\\n2. numbers of odd and even elements in two arrays are equal\\n\\nThe problem can be solved by Greedy algorithm.\\nFirstly, we split the arrays with all odd elements preceed even elements.\\nSecondly, we sort the odd/even parts of the array separately.\\nFinally, we measure the positive gap between the first array and the second array and divide the number by two. Since the number of odd/even elements are guaranteed to be equal, the elementwise gap between the processed array is always multiple of two.(Difference between odd numbers is always divisible by two. Gap between even numbers is similar.) In addition, since the sum of the two arrays are equal, how much nums is greater than target is always equal to how much target is greater than nums.\\n\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int l, r;\\n        l = rearrange(nums);\\n        r = rearrange(target);\\n        ::sort(nums.begin(), nums.begin()+l);\\n        ::sort(nums.begin()+l, nums.end());\\n        ::sort(target.begin(), target.begin()+l);\\n        ::sort(target.begin()+l, target.end());\\n        \\n        long long a = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i] > target[i]) {\\n                a += (nums[i] - target[i])/2;\\n            }\\n        }\\n        return a;\\n    }\\n    \\n    int rearrange(vector<int> & a) {\\n        int n = a.size();\\n        int l = 0, r = n - 1;\\n        while (l < r) {\\n            // find first even number location\\n            while (l < r && (a[l] & 1) == 1) {++l;}\\n            // find last odd number location\\n            while (l < r && (a[r] & 1) == 0) {--r;}\\n            if (l < r) {\\n                ::swap(a[l], a[r]);\\n                ++l, --r;\\n            }\\n        }\\n        while (l <= r && (a[l] & 1) == 1) {\\n            ++l;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\nTime complexity: O(n log n) due to sorting for the worst case\\nSpace complexity: O(1)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int l, r;\\n        l = rearrange(nums);\\n        r = rearrange(target);\\n        ::sort(nums.begin(), nums.begin()+l);\\n        ::sort(nums.begin()+l, nums.end());\\n        ::sort(target.begin(), target.begin()+l);\\n        ::sort(target.begin()+l, target.end());\\n        \\n        long long a = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i] > target[i]) {\\n                a += (nums[i] - target[i])/2;\\n            }\\n        }\\n        return a;\\n    }\\n    \\n    int rearrange(vector<int> & a) {\\n        int n = a.size();\\n        int l = 0, r = n - 1;\\n        while (l < r) {\\n            // find first even number location\\n            while (l < r && (a[l] & 1) == 1) {++l;}\\n            // find last odd number location\\n            while (l < r && (a[r] & 1) == 0) {--r;}\\n            if (l < r) {\\n                ::swap(a[l], a[r]);\\n                ++l, --r;\\n            }\\n        }\\n        while (l <= r && (a[l] & 1) == 1) {\\n            ++l;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826348,
                "title": "c-easy-to-understand-separate-evens-and-odds",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        long long ans=0;\\n        \\n        vector<int> odd,even;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int n = nums.size();\\n        for(int i =0;i < n;i++)\\n        {\\n            if(nums[i]%2==0)even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        \\n        int k=0,j=0;\\n        \\n        sort(target.begin(),target.end());\\n        for(int i =0;i<target.size();i++)\\n        {\\n            if(target[i]%2==0)\\n            {\\n                ans+=(abs(target[i]-even[k++]))/2;\\n            }\\n            \\n            else\\n            {\\n                ans+=(abs(target[i]-odd[j++]))/2;\\n            }\\n        }\\n        \\n        return ans/2;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        long long ans=0;\\n        \\n        vector<int> odd,even;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int n = nums.size();\\n        for(int i =0;i < n;i++)\\n        {\\n            if(nums[i]%2==0)even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        \\n        int k=0,j=0;\\n        \\n        sort(target.begin(),target.end());\\n        for(int i =0;i<target.size();i++)\\n        {\\n            if(target[i]%2==0)\\n            {\\n                ans+=(abs(target[i]-even[k++]))/2;\\n            }\\n            \\n            else\\n            {\\n                ans+=(abs(target[i]-odd[j++]))/2;\\n            }\\n        }\\n        \\n        return ans/2;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824618,
                "title": "simple-java-solution-odd-and-even",
                "content": "# class Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        \\n        List<Integer> even=new ArrayList<>();\\n         List<Integer> eventarg=new ArrayList<>();\\n         List<Integer> odd=new ArrayList<>();\\n         List<Integer> oddtarg=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                even.add(nums[i]);\\n            }else{\\n                odd.add(nums[i]);\\n            }\\n             if(target[i]%2==0)\\n            {\\n                eventarg.add(target[i]);\\n            }else{\\n                oddtarg.add(target[i]);\\n            }\\n        }\\n        long c=0;\\n        for(int i=0;i<even.size();i++)\\n        {\\n            c+=(long)Math.abs(even.get(i)-eventarg.get(i))/2;\\n        }\\n        for(int i=0;i<odd.size();i++)\\n        {\\n            c+=(long)Math.abs(odd.get(i)-oddtarg.get(i))/2;\\n        }\\n        return (c/2);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        \\n        List<Integer> even=new ArrayList<>();\\n         List<Integer> eventarg=new ArrayList<>();\\n         List<Integer> odd=new ArrayList<>();\\n         List<Integer> oddtarg=new ArrayList<>();\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                even.add(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2819628,
                "title": "my-java-normal-solution",
                "content": "```\\npublic long makeSimilar(int[] nums, int[] target) {\\n        int n = nums.length;\\n        long res = 0;\\n       \\n        List<Integer> evenList1 = new ArrayList();\\n        List<Integer> evenList2 = new ArrayList();\\n        List<Integer> oddList1 = new ArrayList();\\n        List<Integer> oddList2 = new ArrayList();\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 0)\\n                evenList1.add(nums[i]);\\n            else \\n                oddList1.add(nums[i]);\\n            \\n            if(target[i] % 2 == 0)\\n                evenList2.add(target[i]);\\n            else\\n               oddList2.add(target[i]);\\n            \\n        }\\n        \\n         evenList1.sort(Comparator.comparingInt( o -> o));\\n         evenList2.sort(Comparator.comparingInt( o -> o));\\n         oddList1.sort(Comparator.comparingInt( o -> o));\\n         oddList2.sort(Comparator.comparingInt( o -> o));\\n        \\n        long sum1 = 0, sum2 = 0;\\n        \\n        for(int i = 0; i < evenList1.size(); i++)\\n            sum1 += Math.abs(evenList1.get(i) - evenList2.get(i));\\n        \\n        for(int i = 0; i < oddList1.size(); i++)\\n            sum1 += Math.abs(oddList1.get(i) - oddList2.get(i));\\n        \\n        return (sum1 + sum2)/4;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long makeSimilar(int[] nums, int[] target) {\\n        int n = nums.length;\\n        long res = 0;\\n       \\n        List<Integer> evenList1 = new ArrayList();\\n        List<Integer> evenList2 = new ArrayList();\\n        List<Integer> oddList1 = new ArrayList();\\n        List<Integer> oddList2 = new ArrayList();\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 0)\\n                evenList1.add(nums[i]);\\n            else \\n                oddList1.add(nums[i]);\\n            \\n            if(target[i] % 2 == 0)\\n                evenList2.add(target[i]);\\n            else\\n               oddList2.add(target[i]);\\n            \\n        }\\n        \\n         evenList1.sort(Comparator.comparingInt( o -> o));\\n         evenList2.sort(Comparator.comparingInt( o -> o));\\n         oddList1.sort(Comparator.comparingInt( o -> o));\\n         oddList2.sort(Comparator.comparingInt( o -> o));\\n        \\n        long sum1 = 0, sum2 = 0;\\n        \\n        for(int i = 0; i < evenList1.size(); i++)\\n            sum1 += Math.abs(evenList1.get(i) - evenList2.get(i));\\n        \\n        for(int i = 0; i < oddList1.size(); i++)\\n            sum1 += Math.abs(oddList1.get(i) - oddList2.get(i));\\n        \\n        return (sum1 + sum2)/4;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2811812,
                "title": "divide-into-even-and-odd-groups",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n = nums.size();\\n        vector<int> odd1, odd2, even1, even2;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] % 2) {\\n                odd1.emplace_back((nums[i] - 1) / 2);\\n            } else {\\n                even1.emplace_back(nums[i] / 2);\\n            }\\n            if (target[i] % 2) {\\n                odd2.emplace_back((target[i] - 1) / 2);\\n            } else {\\n                even2.emplace_back(target[i] / 2);\\n            }\\n        }\\n        sort(begin(odd1), end(odd1));\\n        sort(begin(odd2), end(odd2));\\n        sort(begin(even1), end(even1));\\n        sort(begin(even2), end(even2));\\n        long long ans = 0;\\n        int oddsize = odd1.size(), evensize = even1.size();\\n        for (int i = 0; i < oddsize; ++i) {\\n            if (odd1[i] > odd2[i]) {\\n                ans += odd1[i] - odd2[i];\\n            }\\n        }\\n        for (int i = 0; i < evensize; ++i) {\\n            if (even1[i] > even2[i]) {\\n                ans += even1[i] - even2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int n = nums.size();\\n        vector<int> odd1, odd2, even1, even2;\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[i] % 2) {\\n                odd1.emplace_back((nums[i] - 1) / 2);\\n            } else {\\n                even1.emplace_back(nums[i] / 2);\\n            }\\n            if (target[i] % 2) {\\n                odd2.emplace_back((target[i] - 1) / 2);\\n            } else {\\n                even2.emplace_back(target[i] / 2);\\n            }\\n        }\\n        sort(begin(odd1), end(odd1));\\n        sort(begin(odd2), end(odd2));\\n        sort(begin(even1), end(even1));\\n        sort(begin(even2), end(even2));\\n        long long ans = 0;\\n        int oddsize = odd1.size(), evensize = even1.size();\\n        for (int i = 0; i < oddsize; ++i) {\\n            if (odd1[i] > odd2[i]) {\\n                ans += odd1[i] - odd2[i];\\n            }\\n        }\\n        for (int i = 0; i < evensize; ++i) {\\n            if (even1[i] > even2[i]) {\\n                ans += even1[i] - even2[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805069,
                "title": "javascript-sort",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\nvar makeSimilar = function (nums, target) {\\n  nums.sort((a, b) => a - b);\\n  target.sort((a, b) => a - b);\\n\\n  const oddNums = [];\\n  const oddTarget = [];\\n  const evenNums = [];\\n  const evenTarget = [];\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    const currNums = nums[i] % 2 === 1 ? oddNums : evenNums;\\n    currNums.push(nums[i]);\\n\\n    const currTarget = target[i] % 2 === 1 ? oddTarget : evenTarget;\\n    currTarget.push(target[i]);\\n  }\\n\\n  const values = { ans: 0, carry: 0 };\\n  helper(oddNums, oddTarget, values);\\n  helper(evenNums, evenTarget, values);\\n\\n  return values.ans;\\n};\\n\\nfunction helper(nums, target, values) {\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] > target[i]) {\\n      const newCarry = nums[i] - target[i];\\n      values.ans += newCarry / 2;\\n      values.carry += newCarry;\\n    } else {\\n      const newCarry = nums[i] + values.carry - target[i];\\n      values.carry = newCarry;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\nvar makeSimilar = function (nums, target) {\\n  nums.sort((a, b) => a - b);\\n  target.sort((a, b) => a - b);\\n\\n  const oddNums = [];\\n  const oddTarget = [];\\n  const evenNums = [];\\n  const evenTarget = [];\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    const currNums = nums[i] % 2 === 1 ? oddNums : evenNums;\\n    currNums.push(nums[i]);\\n\\n    const currTarget = target[i] % 2 === 1 ? oddTarget : evenTarget;\\n    currTarget.push(target[i]);\\n  }\\n\\n  const values = { ans: 0, carry: 0 };\\n  helper(oddNums, oddTarget, values);\\n  helper(evenNums, evenTarget, values);\\n\\n  return values.ans;\\n};\\n\\nfunction helper(nums, target, values) {\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] > target[i]) {\\n      const newCarry = nums[i] - target[i];\\n      values.ans += newCarry / 2;\\n      values.carry += newCarry;\\n    } else {\\n      const newCarry = nums[i] + values.carry - target[i];\\n      values.carry = newCarry;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2796579,
                "title": "c-extra-space-odd-even-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int>no,ne,te,to;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0)ne.push_back(nums[i]);\\n            else no.push_back(nums[i]);\\n        }\\n        for(int i=0;i<target.size();i++){\\n            if(target[i]%2==0)te.push_back(target[i]);\\n            else to.push_back(target[i]);\\n        }\\n        sort(no.begin(),no.end());\\n        sort(ne.begin(),ne.end());\\n        sort(to.begin(),to.end());\\n        sort(te.begin(),te.end());\\n        long long ans=0,ans2=0;\\n        for(int i=0;i<no.size();i++)ans+=(long long)(max(0,no[i]-to[i])/2);\\n        for(int i=0;i<ne.size();i++)ans+=(long long)(max(0,ne[i]-te[i])/2);\\n        for(int i=0;i<no.size();i++)ans2+=(long long)(max(0,to[i]-no[i])/2);\\n        for(int i=0;i<ne.size();i++)ans2+=(long long)(max(0,te[i]-ne[i])/2);\\n        return max(ans,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int>no,ne,te,to;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0)ne.push_back(nums[i]);\\n            else no.push_back(nums[i]);\\n        }\\n        for(int i=0;i<target.size();i++){\\n            if(target[i]%2==0)te.push_back(target[i]);\\n            else to.push_back(target[i]);\\n        }\\n        sort(no.begin(),no.end());\\n        sort(ne.begin(),ne.end());\\n        sort(to.begin(),to.end());\\n        sort(te.begin(),te.end());\\n        long long ans=0,ans2=0;\\n        for(int i=0;i<no.size();i++)ans+=(long long)(max(0,no[i]-to[i])/2);\\n        for(int i=0;i<ne.size();i++)ans+=(long long)(max(0,ne[i]-te[i])/2);\\n        for(int i=0;i<no.size();i++)ans2+=(long long)(max(0,to[i]-no[i])/2);\\n        for(int i=0;i<ne.size();i++)ans2+=(long long)(max(0,te[i]-ne[i])/2);\\n        return max(ans,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769014,
                "title": "simple-python-solution",
                "content": "```\\ndef makeSimilar(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        target.sort()\\n        numseven = []\\n        numsodd = []\\n        targeteven = []\\n        targetodd = []\\n        evensum = 0\\n        oddsum = 0\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                numseven.append(nums[i])\\n            else:\\n                numsodd.append(nums[i])\\n            if target[i]%2 == 0:\\n                targeteven.append(target[i])\\n            else:\\n                targetodd.append(target[i])\\n        for j in range(len(numseven)):\\n            evensum += abs(numseven[j]-targeteven[j])\\n        for k in range(len(targetodd)):\\n            oddsum += abs(numsodd[k]-targetodd[k])\\n        total = (evensum+oddsum)\\n        return total/4\\n```",
                "solutionTags": [],
                "code": "```\\ndef makeSimilar(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        target.sort()\\n        numseven = []\\n        numsodd = []\\n        targeteven = []\\n        targetodd = []\\n        evensum = 0\\n        oddsum = 0\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                numseven.append(nums[i])\\n            else:\\n                numsodd.append(nums[i])\\n            if target[i]%2 == 0:\\n                targeteven.append(target[i])\\n            else:\\n                targetodd.append(target[i])\\n        for j in range(len(numseven)):\\n            evensum += abs(numseven[j]-targeteven[j])\\n        for k in range(len(targetodd)):\\n            oddsum += abs(numsodd[k]-targetodd[k])\\n        total = (evensum+oddsum)\\n        return total/4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2764244,
                "title": "c-greedy-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n          int n = nums.size();\\n          sort(nums.begin(),nums.end());\\n          sort(target.begin(),target.end());\\n        \\n          vector<int> even1,even2,odd1,odd2;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(nums[i]%2)\\n              {\\n                  odd1.push_back(nums[i]);\\n              }else{\\n                  even1.push_back(nums[i]);\\n              }\\n              \\n              if(target[i]%2)\\n              {\\n                  odd2.push_back(target[i]);\\n              }else{\\n                  even2.push_back(target[i]);\\n              }\\n          }\\n        \\n          long long ans = 0;\\n          \\n          for(int i=0;i<even1.size();i++)\\n          {\\n              if(even1[i]<even2[i])\\n              ans += (even2[i] - even1[i])/2;\\n          }\\n        \\n          for(int i=0;i<odd1.size();i++)\\n          {\\n              if(odd2[i]>odd1[i])\\n              ans += (odd2[i] - odd1[i])/2;\\n          }\\n        \\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n          int n = nums.size();\\n          sort(nums.begin(),nums.end());\\n          sort(target.begin(),target.end());\\n        \\n          vector<int> even1,even2,odd1,odd2;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(nums[i]%2)\\n              {\\n                  odd1.push_back(nums[i]);\\n              }else{\\n                  even1.push_back(nums[i]);\\n              }\\n              \\n              if(target[i]%2)\\n              {\\n                  odd2.push_back(target[i]);\\n              }else{\\n                  even2.push_back(target[i]);\\n              }\\n          }\\n        \\n          long long ans = 0;\\n          \\n          for(int i=0;i<even1.size();i++)\\n          {\\n              if(even1[i]<even2[i])\\n              ans += (even2[i] - even1[i])/2;\\n          }\\n        \\n          for(int i=0;i<odd1.size();i++)\\n          {\\n              if(odd2[i]>odd1[i])\\n              ans += (odd2[i] - odd1[i])/2;\\n          }\\n        \\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755317,
                "title": "c-o-nlogn-solution-using-greedy-approach",
                "content": "**C++ Code:**\\n\\n```\\n long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        vector<int>odd_nums,odd_target;\\n        vector<int>even_nums,even_target;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2!=0) odd_nums.push_back(nums[i]);\\n            else even_nums.push_back(nums[i]);\\n            \\n            if(target[i]%2!=0) odd_target.push_back(target[i]);\\n            else even_target.push_back(target[i]);\\n        }\\n        \\n       long long ans = 0;\\n       for(int i=0;i<odd_nums.size();i++){\\n           ans += abs(odd_nums[i]-odd_target[i])/2;\\n       }\\n        \\n       for(int i=0;i<even_nums.size();i++){\\n           ans += abs(even_nums[i]-even_target[i])/2;\\n       }\\n     return ans/2;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        vector<int>odd_nums,odd_target;\\n        vector<int>even_nums,even_target;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2!=0) odd_nums.push_back(nums[i]);\\n            else even_nums.push_back(nums[i]);\\n            \\n            if(target[i]%2!=0) odd_target.push_back(target[i]);\\n            else even_target.push_back(target[i]);\\n        }\\n        \\n       long long ans = 0;\\n       for(int i=0;i<odd_nums.size();i++){\\n           ans += abs(odd_nums[i]-odd_target[i])/2;\\n       }\\n        \\n       for(int i=0;i<even_nums.size();i++){\\n           ans += abs(even_nums[i]-even_target[i])/2;\\n       }\\n     return ans/2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2755055,
                "title": "sort-even-and-odd-separately",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector <ll> aeven,aodd,beven,bodd;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        for(auto p:nums)\\n            if(p%2)\\n                aodd.push_back(p);\\n        else\\n            aeven.push_back(p);\\n        for(auto p:target)\\n            if(p%2)\\n                bodd.push_back(p);\\n        else\\n            beven.push_back(p);\\n        ll ans=0;\\n        for(int i=0;i<aeven.size();i++)\\n        {\\n            ans+=abs(aeven[i]-beven[i])/2;\\n        }\\n        for(int i=0;i<aodd.size();i++)\\n        {\\n            ans+=abs(aodd[i]-bodd[i])/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector <ll> aeven,aodd,beven,bodd;\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        for(auto p:nums)\\n            if(p%2)\\n                aodd.push_back(p);\\n        else\\n            aeven.push_back(p);\\n        for(auto p:target)\\n            if(p%2)\\n                bodd.push_back(p);\\n        else\\n            beven.push_back(p);\\n        ll ans=0;\\n        for(int i=0;i<aeven.size();i++)\\n        {\\n            ans+=abs(aeven[i]-beven[i])/2;\\n        }\\n        for(int i=0;i<aodd.size();i++)\\n        {\\n            ans+=abs(aodd[i]-bodd[i])/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753767,
                "title": "c-sorting-of-both-arrays-tc-o-n-log-n-sc-o-1",
                "content": "Algo: \\n First Sort both gvn arrays\\n\\t Find 1st even in both sorted arrays if nums first ele is greater then only collect the diff. Iterate like this to find nxt     even num in both arrays.\\n\\t Now find 1st odd num for both arrays and if nums 1st ele is greater than target first odd num then also collect the diff.\\n\\t <br>\\n\\t<strong>Here we are finding First ele  in nums, which is greater than first ele of target array\\n\\t If we are able to find all ele where first ele of nums array is greater than target array ele then return it\\'s half. becoz 2 is getting added, after accumulating for both even and odd num. This is working becoz there is no fail case. Similar array will always form.</strong>\\n\\t <br>\\n\\t \\n\\t \\n\\t C++ code\\n\\t \\n\\tclass Solution {\\n\\tpublic:\\n\\t\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        int ind1 = 0, ind2 = 0;\\n        long long dif = 0;\\n\\t\\t\\n        while(ind1 < nums.size() && ind2 < target.size()) {\\n            while(ind1 < nums.size() &&  nums[ind1] & 1) {  //till the num is odd find even num from both array\\n                ind1++;\\n            } \\n            while(ind2 < target.size() && target[ind2] & 1) { \\n                ind2++;\\n            }\\n            \\n            if(ind1 < nums.size() && ind2 < target.size() && nums[ind1] > target[ind2]) { //if nums[ind1] > target[ind2] then add the diff\\n                dif += (nums[ind1] - target[ind2]);\\n            }\\n            ind1++;\\n            ind2++;\\n\\n        }\\n        \\n        ind1 = 0, ind2 = 0; //reseting indexes\\n        while(ind1 < nums.size() && ind2 < target.size()) {\\n            while(ind1 < nums.size() && nums[ind1] % 2 == 0) { //till the num is even find odd num\\n                ind1++;\\n            } \\n            while(ind2 < target.size() && target[ind2] % 2 == 0) {\\n                ind2++;\\n            }\\n            \\n            if(ind1 < nums.size() && ind2 < target.size() && nums[ind1] > target[ind2]) {\\n                dif += (nums[ind1] - target[ind2]);\\n            }\\n            ind1++;\\n            ind2++;\\n        }\\n        \\n        return dif / 2;\\n    }\\n};\\n\\n# DRY RUN\\n1. ***1st Test Case*: nums[6, 8, 12]   target[2, 10, 14]\\nOpern :  4 (6 - 2)  \\nso 4/2 =  2 which means 2 opern**\\n\\n2. ***2nd Test Case*: nums[1, 2, 5]    target[1, 3, 4]\\nOpern : 2 (5 - 3) \\nso 2/2 = 1 which means 1 opern only**\\n\\n\\t \\n\\t \\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        int ind1 = 0, ind2 = 0;\\n        long long dif = 0;\\n\\t\\t\\n        while(ind1 < nums.size() && ind2 < target.size()) {\\n            while(ind1 < nums.size() &&  nums[ind1] & 1) {  //till the num is odd find even num from both array\\n                ind1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2752973,
                "title": "a-few-solutions",
                "content": "Greedily \"consume\" the sorted `even` and `odd` values of input arrays `A` and `B` as \"closest pairs\" `a` and `b` correspondingly to return the accumulated `need` to transform `A` into `B`.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/95b358ff-d205-437f-9e8e-0e14dde5cdf6_1666966995.2908385.jpeg)\\n\\n---\\n\\n**Initial solution:** we can verbosely \"see\" what we `need` is based upon the `give` and `take` which is \"balanced\" such that we only need to consider the accumulated sum of `give` exclusive-or `take`, and we divide by `2` since we transform each difference in increments of `2` per the problem statement.  We can also observe the sorted arrays greedily minimize the difference via \"closest pairs\" `a` and `b`.\\n\\n*Python3*\\n```\\nclass Solution:\\n    def makeSimilar(self, A: List[int], T: List[int], cnt = 0) -> int:\\n        evens = lambda A: [x for x in A if not (x & 1)]\\n        odds = lambda A: [x for x in A if x & 1]\\n        A.sort()\\n        T.sort()\\n        evenA, evenT = evens(A), evens(T)\\n        oddA, oddT = odds(A), odds(T)\\n        give, take = 0, 0\\n        for a, b in zip(evenA, evenT):\\n            if b < a:\\n                give += a - b\\n            if a < b:\\n                take += b - a\\n        for a, b in zip(oddA, oddT):\\n            if b < a:\\n                give += a - b\\n            if a < b:\\n                take += b - a\\n        return give // 2\\n```\\n\\n---\\n\\n**Concise solutions:**\\n\\n*Kotlin*\\n```\\ntypealias VI = IntArray\\ntypealias VL = List<Long>\\nclass Solution {\\n    fun makeSimilar(A: VI, B: VI): Long {\\n        var even = { A: VI -> A.filter{ it % 2 == 0 }.map{ it.toLong() }.sorted() }\\n        var odd = { A: VI -> A.filter{ it % 2 == 1 }.map{ it.toLong() }.sorted() }\\n        var need = { A: VL, B: VL -> (A zip B).map{ (a, b) -> if (0 < a - b) a - b else 0 }.sum()!! / 2 }\\n        return need(even(A), even(B)) + need(odd(A), odd(B))\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet makeSimilar = (A, B, order = (a, b) => a - b) => {\\n    let even = A => A.filter(x => !(x & 1)).sort(order),\\n        odd = A => A.filter(x => x & 1).sort(order),\\n        need = (A, B) => Math.floor(_.sum(_.zip(A, B).map(([a, b]) => 0 < a - b ? a - b : 0)) / 2);\\n    return need(even(A), even(B)) + need(odd(A), odd(B));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def makeSimilar(self, A: List[int], B: List[int]) -> int:\\n        even = lambda A: sorted([x for x in A if not (x & 1)])\\n        odd = lambda A: sorted([x for x in A if x & 1])\\n        need = lambda A, B: sum(a - b for a, b in zip(A, B) if 0 < a - b) // 2\\n        return need(even(A), even(B)) + need(odd(A), odd(B))\\n```\\n\\n*Rust*\\n```\\n// TODO: how to pass predicate into closure for isEven + isOdd?\\ntype VI = Vec<i32>;\\ntype VL = Vec<i64>;\\nimpl Solution {\\n    pub fn make_similar(A: VI, B: VI) -> i64 {\\n        let even = (|A: &VI| {\\n            let mut T = A.clone().into_iter().filter(|x| x % 2 == 0).map(|x| x as i64).collect::<VL>();\\n            T.sort();\\n            T\\n        });\\n        let odd = (|A: &VI| {\\n            let mut T = A.clone().into_iter().filter(|x| x % 2 == 1).map(|x| x as i64).collect::<VL>();\\n            T.sort();\\n            T\\n        });\\n        let need = |A: VL, B: VL| -> i64 { A.iter().zip(B.iter()).map(|(a, b)| if 0 < a - b { a - b } else { 0 }).sum::<i64>() / 2 };\\n        need(even(&A), even(&B)) + need(odd(&A), odd(&B))\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL makeSimilar(VI& A, VI& B) {\\n        auto isEven = [](auto x) { return !(x & 1); };\\n        auto isOdd = [](auto x) { return x & 1; };\\n        auto f = [](auto& A, auto predicate) {\\n            VI T; copy_if(A.begin(), A.end(), back_inserter(T), [&](auto x) { return predicate(x); });\\n            sort(T.begin(), T.end());\\n            return T;\\n        };\\n        auto need = [](auto&& A, auto&& B) {\\n            auto t = 0LL;\\n            for (auto i{ 0 }; i < A.size(); ++i)\\n                if (0 < A[i] - B[i])\\n                    t += A[i] - B[i];\\n            return t / 2;\\n        };\\n        return need(f(A, isEven), f(B, isEven)) + need(f(A, isOdd), f(B, isOdd));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, A: List[int], T: List[int], cnt = 0) -> int:\\n        evens = lambda A: [x for x in A if not (x & 1)]\\n        odds = lambda A: [x for x in A if x & 1]\\n        A.sort()\\n        T.sort()\\n        evenA, evenT = evens(A), evens(T)\\n        oddA, oddT = odds(A), odds(T)\\n        give, take = 0, 0\\n        for a, b in zip(evenA, evenT):\\n            if b < a:\\n                give += a - b\\n            if a < b:\\n                take += b - a\\n        for a, b in zip(oddA, oddT):\\n            if b < a:\\n                give += a - b\\n            if a < b:\\n                take += b - a\\n        return give // 2\\n```\n```\\ntypealias VI = IntArray\\ntypealias VL = List<Long>\\nclass Solution {\\n    fun makeSimilar(A: VI, B: VI): Long {\\n        var even = { A: VI -> A.filter{ it % 2 == 0 }.map{ it.toLong() }.sorted() }\\n        var odd = { A: VI -> A.filter{ it % 2 == 1 }.map{ it.toLong() }.sorted() }\\n        var need = { A: VL, B: VL -> (A zip B).map{ (a, b) -> if (0 < a - b) a - b else 0 }.sum()!! / 2 }\\n        return need(even(A), even(B)) + need(odd(A), odd(B))\\n    }\\n}\\n```\n```\\nlet makeSimilar = (A, B, order = (a, b) => a - b) => {\\n    let even = A => A.filter(x => !(x & 1)).sort(order),\\n        odd = A => A.filter(x => x & 1).sort(order),\\n        need = (A, B) => Math.floor(_.sum(_.zip(A, B).map(([a, b]) => 0 < a - b ? a - b : 0)) / 2);\\n    return need(even(A), even(B)) + need(odd(A), odd(B));\\n};\\n```\n```\\nclass Solution:\\n    def makeSimilar(self, A: List[int], B: List[int]) -> int:\\n        even = lambda A: sorted([x for x in A if not (x & 1)])\\n        odd = lambda A: sorted([x for x in A if x & 1])\\n        need = lambda A, B: sum(a - b for a, b in zip(A, B) if 0 < a - b) // 2\\n        return need(even(A), even(B)) + need(odd(A), odd(B))\\n```\n```\\n// TODO: how to pass predicate into closure for isEven + isOdd?\\ntype VI = Vec<i32>;\\ntype VL = Vec<i64>;\\nimpl Solution {\\n    pub fn make_similar(A: VI, B: VI) -> i64 {\\n        let even = (|A: &VI| {\\n            let mut T = A.clone().into_iter().filter(|x| x % 2 == 0).map(|x| x as i64).collect::<VL>();\\n            T.sort();\\n            T\\n        });\\n        let odd = (|A: &VI| {\\n            let mut T = A.clone().into_iter().filter(|x| x % 2 == 1).map(|x| x as i64).collect::<VL>();\\n            T.sort();\\n            T\\n        });\\n        let need = |A: VL, B: VL| -> i64 { A.iter().zip(B.iter()).map(|(a, b)| if 0 < a - b { a - b } else { 0 }).sum::<i64>() / 2 };\\n        need(even(&A), even(&B)) + need(odd(&A), odd(&B))\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL makeSimilar(VI& A, VI& B) {\\n        auto isEven = [](auto x) { return !(x & 1); };\\n        auto isOdd = [](auto x) { return x & 1; };\\n        auto f = [](auto& A, auto predicate) {\\n            VI T; copy_if(A.begin(), A.end(), back_inserter(T), [&](auto x) { return predicate(x); });\\n            sort(T.begin(), T.end());\\n            return T;\\n        };\\n        auto need = [](auto&& A, auto&& B) {\\n            auto t = 0LL;\\n            for (auto i{ 0 }; i < A.size(); ++i)\\n                if (0 < A[i] - B[i])\\n                    t += A[i] - B[i];\\n            return t / 2;\\n        };\\n        return need(f(A, isEven), f(B, isEven)) + need(f(A, isOdd), f(B, isOdd));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752924,
                "title": "greedy-algorithm-c-sort-count-add-or-minus",
                "content": "![image](https://assets.leetcode.com/users/images/156f3451-c7fc-44d4-bdff-5f87282b9e2b_1666969514.4119825.png)\\n\\n\\n\\nclass Solution {\\npublic:\\n    int FindFirstEvenOrOdd(vector<int>& target, int flag, int begin){\\n        if(flag){\\n            while (begin < target.size() && (target[begin] % 2 != 1)){\\n                begin++;\\n            }\\n            return begin;    \\n        }\\n        else{\\n            while (begin < target.size() && (target[begin] % 2 != 0)){\\n                begin++;\\n            }\\n            return begin;\\n        }\\n    }\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        int size = nums.size();\\n        int i = 0;\\n        int oddbegin = 0, evenbegin = 0;\\n        long long addcount = 0, minuscount = 0;\\n        int minusresult = 0;\\n        while (i < size)\\n        {\\n            if(nums[i] % 2){\\n                oddbegin = FindFirstEvenOrOdd(target, 1, oddbegin);\\n                minusresult = nums[i] - target[oddbegin];\\n                oddbegin++;\\n            }\\n            else{\\n                evenbegin = FindFirstEvenOrOdd(target, 0, evenbegin);\\n                minusresult = nums[i] - target[evenbegin];\\n                evenbegin++;\\n            }\\n            if(minusresult < 0){\\n                minuscount += minusresult / 2;\\n            }\\n            else{\\n                addcount += minusresult / 2;\\n            }\\n            i++;\\n        }\\n        return addcount;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int FindFirstEvenOrOdd(vector<int>& target, int flag, int begin){\\n        if(flag){\\n            while (begin < target.size() && (target[begin] % 2 != 1)){\\n                begin++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2751828,
                "title": "sort-even-and-odd-wise",
                "content": "```\\nclass Solution {\\npublic:\\n     long long makeSimilar(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> AA(2), BB(2);\\n        for(int a: A) AA[a % 2].push_back(a);\\n        for(int b: B) BB[b % 2].push_back(b);\\n        sort(AA[0].begin(), AA[0].end());\\n        sort(AA[1].begin(), AA[1].end());\\n        sort(BB[0].begin(), BB[0].end());\\n        sort(BB[1].begin(), BB[1].end());\\n\\n        long long res = 0;\\n        for (int i = 0; i < AA[0].size(); ++i)\\n            res += abs(AA[0][i] - BB[0][i]) / 2;\\n        for (int i = 0; i < AA[1].size(); ++i)\\n            res += abs(AA[1][i] - BB[1][i]) / 2;\\n        return res / 2;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     long long makeSimilar(vector<int>& A, vector<int>& B) {\\n        vector<vector<int>> AA(2), BB(2);\\n        for(int a: A) AA[a % 2].push_back(a);\\n        for(int b: B) BB[b % 2].push_back(b);\\n        sort(AA[0].begin(), AA[0].end());\\n        sort(AA[1].begin(), AA[1].end());\\n        sort(BB[0].begin(), BB[0].end());\\n        sort(BB[1].begin(), BB[1].end());\\n\\n        long long res = 0;\\n        for (int i = 0; i < AA[0].size(); ++i)\\n            res += abs(AA[0][i] - BB[0][i]) / 2;\\n        for (int i = 0; i < AA[1].size(); ++i)\\n            res += abs(AA[1][i] - BB[1][i]) / 2;\\n        return res / 2;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751044,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long makeSimilar(const vector<int> &nums, const vector<int> &target) {\\n    vector<int> odd_nums;\\n    vector<int> even_nums;\\n    for (const int num : nums) {\\n      if (num % 2 == 0) {\\n        even_nums.emplace_back(num);\\n      } else {\\n        odd_nums.emplace_back(num);\\n      }\\n    }\\n    \\n    vector<int> odd_target;\\n    vector<int> even_target;\\n    for (const int t : target) {\\n      if (t % 2 == 0) {\\n        even_target.emplace_back(t);\\n      } else {\\n        odd_target.emplace_back(t);\\n      }\\n    }\\n    \\n    sort(odd_nums.begin(), odd_nums.end());\\n    sort(even_nums.begin(), even_nums.end());\\n    sort(odd_target.begin(), odd_target.end());\\n    sort(even_target.begin(), even_target.end());\\n    \\n    long long ret = 0LL;\\n    for (size_t i = 0; i < odd_nums.size(); ++i) {\\n      ret += abs(odd_nums[i] - odd_target[i]) / 2;\\n    }\\n    for (size_t i = 0; i < even_nums.size(); ++i) {\\n      ret += abs(even_nums[i] - even_target[i]) / 2;\\n    }\\n    return ret / 2;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long makeSimilar(const vector<int> &nums, const vector<int> &target) {\\n    vector<int> odd_nums;\\n    vector<int> even_nums;\\n    for (const int num : nums) {\\n      if (num % 2 == 0) {\\n        even_nums.emplace_back(num);\\n      } else {\\n        odd_nums.emplace_back(num);\\n      }\\n    }\\n    \\n    vector<int> odd_target;\\n    vector<int> even_target;\\n    for (const int t : target) {\\n      if (t % 2 == 0) {\\n        even_target.emplace_back(t);\\n      } else {\\n        odd_target.emplace_back(t);\\n      }\\n    }\\n    \\n    sort(odd_nums.begin(), odd_nums.end());\\n    sort(even_nums.begin(), even_nums.end());\\n    sort(odd_target.begin(), odd_target.end());\\n    sort(even_target.begin(), even_target.end());\\n    \\n    long long ret = 0LL;\\n    for (size_t i = 0; i < odd_nums.size(); ++i) {\\n      ret += abs(odd_nums[i] - odd_target[i]) / 2;\\n    }\\n    for (size_t i = 0; i < even_nums.size(); ++i) {\\n      ret += abs(even_nums[i] - even_target[i]) / 2;\\n    }\\n    return ret / 2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750914,
                "title": "java-sort-odd-and-even-explanatory-code",
                "content": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n    // What we did is segregated the nums and target array into even and odd. \\n    // Then counted number of iteration.\\n\\n        ArrayList<Integer> evenNums=new ArrayList<>();\\n        ArrayList<Integer> oddNums=new ArrayList<>();\\n        ArrayList<Integer> evenTar=new ArrayList<>();\\n        ArrayList<Integer> oddTar=new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0) evenNums.add(nums[i]);\\n            else oddNums.add(nums[i]);\\n            \\n            if(target[i]%2==0) evenTar.add(target[i]);\\n            else oddTar.add(target[i]);\\n        }\\n        \\n        long countPositiveIteration=0;\\n        long countNegativeIteration=0;\\n        \\n        for(int i=0;i<evenNums.size();i++){\\n            int num=evenNums.get(i);\\n            int tar=evenTar.get(i);\\n            \\n            long diff=(long)(num - tar);\\n            long iteration=diff/2;\\n            if(diff > 0) countNegativeIteration+=iteration;\\n            else if(diff < 0) countPositiveIteration+=Math.abs(iteration);\\n            \\n        }   \\n        \\n        for(int i=0;i<oddNums.size();i++){\\n            int num=oddNums.get(i);\\n            int tar=oddTar.get(i);\\n            \\n            long diff=(long)(num - tar);\\n            long iteration=diff/2;\\n            if(diff > 0) countNegativeIteration+=iteration;\\n            else if(diff < 0) countPositiveIteration+=Math.abs(iteration);\\n        }   \\n        \\n        long totalDifference=countPositiveIteration - countNegativeIteration;\\n        \\n        return totalDifference==0 ? countPositiveIteration : countPositiveIteration + Math.abs(totalDifference);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n    // What we did is segregated the nums and target array into even and odd. \\n    // Then counted number of iteration.\\n\\n        ArrayList<Integer> evenNums=new ArrayList<>();\\n        ArrayList<Integer> oddNums=new ArrayList<>();\\n        ArrayList<Integer> evenTar=new ArrayList<>();\\n        ArrayList<Integer> oddTar=new ArrayList<>();\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0) evenNums.add(nums[i]);\\n            else oddNums.add(nums[i]);\\n            \\n            if(target[i]%2==0) evenTar.add(target[i]);\\n            else oddTar.add(target[i]);\\n        }\\n        \\n        long countPositiveIteration=0;\\n        long countNegativeIteration=0;\\n        \\n        for(int i=0;i<evenNums.size();i++){\\n            int num=evenNums.get(i);\\n            int tar=evenTar.get(i);\\n            \\n            long diff=(long)(num - tar);\\n            long iteration=diff/2;\\n            if(diff > 0) countNegativeIteration+=iteration;\\n            else if(diff < 0) countPositiveIteration+=Math.abs(iteration);\\n            \\n        }   \\n        \\n        for(int i=0;i<oddNums.size();i++){\\n            int num=oddNums.get(i);\\n            int tar=oddTar.get(i);\\n            \\n            long diff=(long)(num - tar);\\n            long iteration=diff/2;\\n            if(diff > 0) countNegativeIteration+=iteration;\\n            else if(diff < 0) countPositiveIteration+=Math.abs(iteration);\\n        }   \\n        \\n        long totalDifference=countPositiveIteration - countNegativeIteration;\\n        \\n        return totalDifference==0 ? countPositiveIteration : countPositiveIteration + Math.abs(totalDifference);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749412,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<long long> even1, even2, odd1, odd2;\\n        for(int i=0;i<nums.size();i++)\\n            nums[i]%2 ? odd1.push_back(nums[i]) : even1.push_back(nums[i]);\\n        for(int i=0;i<target.size();i++)\\n            target[i]%2 ? odd2.push_back(target[i]) : even2.push_back(target[i]);\\n        \\n        sort(even1.begin(),even1.end());\\n        sort(even2.begin(),even2.end());\\n        sort(odd1.begin(),odd1.end());\\n        sort(odd2.begin(),odd2.end());\\n        \\n        long long res = 0;\\n        for(int i=0;i<even1.size();i++)\\n            res += abs(even1[i]-even2[i]);\\n        for(int i=0;i<odd1.size();i++)\\n            res += abs(odd1[i]-odd2[i]);\\n        res/=4;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<long long> even1, even2, odd1, odd2;\\n        for(int i=0;i<nums.size();i++)\\n            nums[i]%2 ? odd1.push_back(nums[i]) : even1.push_back(nums[i]);\\n        for(int i=0;i<target.size();i++)\\n            target[i]%2 ? odd2.push_back(target[i]) : even2.push_back(target[i]);\\n        \\n        sort(even1.begin(),even1.end());\\n        sort(even2.begin(),even2.end());\\n        sort(odd1.begin(),odd1.end());\\n        sort(odd2.begin(),odd2.end());\\n        \\n        long long res = 0;\\n        for(int i=0;i<even1.size();i++)\\n            res += abs(even1[i]-even2[i]);\\n        for(int i=0;i<odd1.size();i++)\\n            res += abs(odd1[i]-odd2[i]);\\n        res/=4;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749286,
                "title": "python-even-and-odd-o-n",
                "content": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        even_nums = []\\n        odd_nums = []\\n        even_target = []\\n        odd_target = []\\n        for num in nums:\\n            if num%2:\\n                odd_nums.append(num)\\n            else:\\n                even_nums.append(num)\\n        for num in target:\\n            if num%2:\\n                odd_target.append(num)\\n            else:\\n                even_target.append(num)\\n        even_nums.sort()\\n        odd_nums.sort()\\n        even_target.sort()\\n        odd_target.sort()\\n        res = 0\\n        for i in range(len(even_nums)):\\n            res += abs(even_nums[i]-even_target[i])\\n        for i in range(len(odd_nums)):\\n            res += abs(odd_nums[i]-odd_target[i])\\n        return res//4",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        even_nums = []\\n        odd_nums = []\\n        even_target = []\\n        odd_target = []\\n        for num in nums:\\n            if num%2:\\n                odd_nums.append(num)\\n            else:\\n                even_nums.append(num)\\n        for num in target:\\n            if num%2:\\n                odd_target.append(num)\\n            else:\\n                even_target.append(num)\\n        even_nums.sort()\\n        odd_nums.sort()\\n        even_target.sort()\\n        odd_target.sort()\\n        res = 0\\n        for i in range(len(even_nums)):\\n            res += abs(even_nums[i]-even_target[i])\\n        for i in range(len(odd_nums)):\\n            res += abs(odd_nums[i]-odd_target[i])\\n        return res//4",
                "codeTag": "Java"
            },
            {
                "id": 2749133,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        odd1=[]\\n        odd2=[]\\n        even1=[]\\n        even2=[]\\n        \\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                even1.append(nums[i])\\n            else:\\n                odd1.append(nums[i])\\n                \\n        for i in range(len(target)):\\n            if target[i]%2==0:\\n                even2.append(target[i])\\n            else:\\n                odd2.append(target[i])\\n                \\n        odd1.sort()\\n        odd2.sort()\\n        even1.sort()\\n        even2.sort()\\n        \\n        cnt=0\\n        for j in range(len(odd1)):\\n            cnt+=abs(odd1[j]-odd2[j])\\n            \\n        for k in range(len(even1)):\\n            cnt+=abs(even1[k]-even2[k])\\n            \\n        return cnt//4\\n```\\n\\nIf my solution was helpful, rate it ;)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        odd1=[]\\n        odd2=[]\\n        even1=[]\\n        even2=[]\\n        \\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                even1.append(nums[i])\\n            else:\\n                odd1.append(nums[i])\\n                \\n        for i in range(len(target)):\\n            if target[i]%2==0:\\n                even2.append(target[i])\\n            else:\\n                odd2.append(target[i])\\n                \\n        odd1.sort()\\n        odd2.sort()\\n        even1.sort()\\n        even2.sort()\\n        \\n        cnt=0\\n        for j in range(len(odd1)):\\n            cnt+=abs(odd1[j]-odd2[j])\\n            \\n        for k in range(len(even1)):\\n            cnt+=abs(even1[k]-even2[k])\\n            \\n        return cnt//4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748249,
                "title": "easy-python-solution-using-even-and-odd-trick",
                "content": "```class Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        target_even = []\\n        target_odd = []\\n        nums_even = []\\n        nums_odd = []\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                nums_even.append(nums[i])\\n            else:\\n                nums_odd.append(nums[i])\\n            if target[i]%2 == 0:\\n                target_even.append(target[i])\\n            else:\\n                target_odd.append(target[i])\\n        \\n        target_even.sort()\\n        target_odd.sort()\\n        nums_even.sort()\\n        nums_odd.sort()\\n        \\n        res = 0\\n        for k in range(len(nums_even)):\\n            if nums_even[k] - target_even[k] > 0:\\n                res+= nums_even[k] - target_even[k]\\n        for r in range(len(nums_odd)):\\n            if nums_odd[r] - target_odd[r] > 0:\\n                res+= nums_odd[r] - target_odd[r]\\n        return res//2\\n                \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        target_even = []\\n        target_odd = []\\n        nums_even = []\\n        nums_odd = []\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                nums_even.append(nums[i])\\n            else:\\n                nums_odd.append(nums[i])\\n            if target[i]%2 == 0:\\n                target_even.append(target[i])\\n            else:\\n                target_odd.append(target[i])\\n        \\n        target_even.sort()\\n        target_odd.sort()\\n        nums_even.sort()\\n        nums_odd.sort()\\n        \\n        res = 0\\n        for k in range(len(nums_even)):\\n            if nums_even[k] - target_even[k] > 0:\\n                res+= nums_even[k] - target_even[k]\\n        for r in range(len(nums_odd)):\\n            if nums_odd[r] - target_odd[r] > 0:\\n                res+= nums_odd[r] - target_odd[r]\\n        return res//2\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2747909,
                "title": "2449-minimum-number-of-operations-to-make-arrays-similar",
                "content": "class Solution(object):\\n    def makeSimilar(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        #separation of even and odd elements from src and target\\n        nodd = sorted(n for n in nums if     n&1 ) \\n        neven = sorted(n for n in nums if not(n&1)) \\n        \\n        todd = sorted(n for n in target if     n&1 ) \\n        teven = sorted(n for n in target if not(n&1))\\n        \\n       # print(nodd,neven)\\n       # print(todd,teven)\\n        \\n        def make(src, tgt):\\n            #print(src,tgt)\\n            sum1 = 0\\n            for s, t in zip(src, tgt):\\n                    tmp = max((s-t),0) #if(s-t) <0 do nothing \\n                    sum1 = sum1+tmp\\n                    print(s-t)\\n                    print(tmp)\\n            #print(sum1)\\n            return sum1//2       \\n        \\n        return(make(nodd, todd)+make(neven, teven))\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def makeSimilar(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        #separation of even and odd elements from src and target\\n        nodd = sorted(n for n in nums if     n&1 ) \\n        neven = sorted(n for n in nums if not(n&1)) \\n        \\n        todd = sorted(n for n in target if     n&1 ) \\n        teven = sorted(n for n in target if not(n&1))\\n        \\n       # print(nodd,neven)\\n       # print(todd,teven)\\n        \\n        def make(src, tgt):\\n            #print(src,tgt)\\n            sum1 = 0\\n            for s, t in zip(src, tgt):\\n                    tmp = max((s-t),0) #if(s-t) <0 do nothing \\n                    sum1 = sum1+tmp\\n                    print(s-t)\\n                    print(tmp)\\n            #print(sum1)\\n            return sum1//2       \\n        \\n        return(make(nodd, todd)+make(neven, teven))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2743416,
                "title": "python-using-odd-and-even-lists",
                "content": "\\tclass Solution:\\n\\t\\tdef makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n\\t\\t\\tnums.sort(); target.sort()\\n\\n\\t\\t\\teven_nums, odd_nums, even_target, odd_target = [], [], [], []\\n\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif i & 1: odd_nums.append(i)\\n\\t\\t\\t\\telse: even_nums.append(i)\\n\\n\\t\\t\\tfor i in target:\\n\\t\\t\\t\\tif i & 1: odd_target.append(i)\\n\\t\\t\\t\\telse: even_target.append(i)\\n\\n\\t\\t\\teven_sum = sum(abs(a - b) for a, b in zip(even_nums, even_target))\\n\\t\\t\\todd_sum = sum(abs(a - b) for a, b in zip(odd_nums, odd_target))\\n\\n\\t\\t\\treturn (even_sum + odd_sum)//4",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n\\t\\t\\tnums.sort(); target.sort()\\n\\n\\t\\t\\teven_nums, odd_nums, even_target, odd_target = [], [], [], []\\n\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif i & 1: odd_nums.append(i)\\n\\t\\t\\t\\telse: even_nums.append(i)\\n\\n\\t\\t\\tfor i in target:\\n\\t\\t\\t\\tif i & 1: odd_target.append(i)\\n\\t\\t\\t\\telse: even_target.append(i)\\n\\n\\t\\t\\teven_sum = sum(abs(a - b) for a, b in zip(even_nums, even_target))\\n\\t\\t\\todd_sum = sum(abs(a - b) for a, b in zip(odd_nums, odd_target))\\n\\n\\t\\t\\treturn (even_sum + odd_sum)//4",
                "codeTag": "Java"
            },
            {
                "id": 2742865,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int >nums1;\\n        vector<int>nums2;\\n        vector<int>nums3;\\n        vector<int>nums4;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0)nums1.push_back(nums[i]);\\n            else\\n                nums2.push_back(nums[i]);\\n        }\\n         for(int i=0;i<target.size();i++){\\n             if(target[i]%2==0)nums3.push_back(target[i]);\\n            else\\n                nums4.push_back(target[i]);\\n        }\\n        long long  ans=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums3.begin(),nums3.end());\\n        sort(nums2.begin(),nums2.end());\\n        sort(nums4.begin(),nums4.end());\\n        for(int i=0;i<nums1.size();i++){\\n            ans=ans+abs(nums1[i]-nums3[i])/2;\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            ans=ans+abs(nums2[i]-nums4[i])/2;\\n        }\\n        cout<<ans<<endl;\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int >nums1;\\n        vector<int>nums2;\\n        vector<int>nums3;\\n        vector<int>nums4;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0)nums1.push_back(nums[i]);\\n            else\\n                nums2.push_back(nums[i]);\\n        }\\n         for(int i=0;i<target.size();i++){\\n             if(target[i]%2==0)nums3.push_back(target[i]);\\n            else\\n                nums4.push_back(target[i]);\\n        }\\n        long long  ans=0;\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums3.begin(),nums3.end());\\n        sort(nums2.begin(),nums2.end());\\n        sort(nums4.begin(),nums4.end());\\n        for(int i=0;i<nums1.size();i++){\\n            ans=ans+abs(nums1[i]-nums3[i])/2;\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            ans=ans+abs(nums2[i]-nums4[i])/2;\\n        }\\n        cout<<ans<<endl;\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2742032,
                "title": "simple-explanation-cpp",
                "content": "Idea is sort and separate even and odd, then sum there difference return ans of that summation/4 \\nExample:\\n3 4 5 6\\n1 2 7 8\\nans=0\\nodd:  \\n\\t3 5\\n\\t1 7\\n\\tans+=(3-1)\\n\\tans+=(5-7) //mod value\\n\\tans=4\\neven:\\n\\t4 6\\n\\t2 8\\n\\tans+=(4-2)\\n\\tans+=(6-8)\\n\\tans=8;\\n\\treturn ans/4=2\\nwe divide ans/4 because for 1 operation 1 becomes 3 and other part of array 7 become 5 changes value by 4 \\nto calculate no. of opeaartion we divide ans by 4.\\n\\t\\n\\t\\n\\t\\nclass Solution \\n{\\npublic:\\n    long long makeSimilar(vector<int>& a, vector<int>& b) \\n    {\\n        long long  ans=0;\\n        vector<int>ae,ao,be,bo;\\n        int n=a.size();\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]%2==0)\\n                ae.push_back(a[i]);\\n            else\\n                ao.push_back(a[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(b[i]%2==0)\\n                be.push_back(b[i]);\\n            else\\n                bo.push_back(b[i]);\\n        }\\n        int n1=ae.size(),n2=ao.size();\\n        for(int i=0;i<n1;i++)\\n        {\\n            ans+=abs(ae[i]-be[i]);   \\n        }\\n        for(int i=0;i<n2;i++)\\n        {\\n            ans+=abs(ao[i]-bo[i]);\\n        }\\n        return ans/4;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\npublic:\\n    long long makeSimilar(vector<int>& a, vector<int>& b) \\n    {\\n        long long  ans=0;\\n        vector<int>ae,ao,be,bo;\\n        int n=a.size();\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]%2==0)\\n                ae.push_back(a[i]);\\n            else\\n                ao.push_back(a[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2741917,
                "title": "c-solution-grouping-with-reminders",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long int ans=0;\\n        sort(target.begin(), target.end());\\n        \\n        unordered_map<int,multiset<int>> m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]%2].insert(nums[i]);\\n        }\\n        for(int i=0;i<target.size();i++){\\n            auto ptr=m[target[i]%2].lower_bound(target[i]);\\n            int choice=1e9;\\n            if(ptr!=m[target[i]%2].end()){\\n                choice=*ptr;\\n            }\\n            if(ptr!=m[target[i]%2].begin()){\\n                ptr--;\\n                choice=min(choice, *ptr);\\n            }\\n            if(choice!=1e9){\\n                m[target[i]%2].erase(m[target[i]%2].find(choice));\\n                ans+=abs(target[i]-choice);   \\n            }\\n        }\\n        \\n        return (ans/4);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long int ans=0;\\n        sort(target.begin(), target.end());\\n        \\n        unordered_map<int,multiset<int>> m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]%2].insert(nums[i]);\\n        }\\n        for(int i=0;i<target.size();i++){\\n            auto ptr=m[target[i]%2].lower_bound(target[i]);\\n            int choice=1e9;\\n            if(ptr!=m[target[i]%2].end()){\\n                choice=*ptr;\\n            }\\n            if(ptr!=m[target[i]%2].begin()){\\n                ptr--;\\n                choice=min(choice, *ptr);\\n            }\\n            if(choice!=1e9){\\n                m[target[i]%2].erase(m[target[i]%2].find(choice));\\n                ans+=abs(target[i]-choice);   \\n            }\\n        }\\n        \\n        return (ans/4);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741576,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> even1;\\n        vector<int> odd1;\\n        vector<int> even2;\\n        vector<int> odd2;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n                even1.push_back(nums[i]);\\n            else\\n                odd1.push_back(nums[i]);\\n            if(target[i]%2==0)\\n                even2.push_back(target[i]);\\n            else\\n                odd2.push_back(target[i]);\\n        }\\n        long long int pos=0;\\n        long long int neg=0;\\n        for(int i=0;i<even1.size();i++)\\n        {\\n            if(even1[i]-even2[i]>0)\\n                pos+=((long long )even1[i]-(long long )even2[i]);\\n                \\n        }\\n        for(int i=0;i<odd1.size();i++)\\n        {\\n            if(odd1[i]-odd2[i]>0)\\n                pos+=((long long )odd1[i]-(long long )odd2[i]);\\n        }\\n        return pos/2;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> even1;\\n        vector<int> odd1;\\n        vector<int> even2;\\n        vector<int> odd2;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n                even1.push_back(nums[i]);\\n            else\\n                odd1.push_back(nums[i]);\\n            if(target[i]%2==0)\\n                even2.push_back(target[i]);\\n            else\\n                odd2.push_back(target[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2740752,
                "title": "rust-split-to-odds-and-evens-then-sort-o-n-log-n",
                "content": "```\\nimpl Solution {\\n    pub fn make_similar(mut nums: Vec<i32>, mut target: Vec<i32>) -> i64 {\\n        let mut ans: i64 = 0;\\n        let (mut a1, mut a2) = split(nums);\\n        let (mut b1, mut b2) = split(target);\\n        a1.sort();\\n        a2.sort();\\n        b1.sort();\\n        b2.sort();\\n        \\n        ans += cal(a1, b1);\\n        ans += cal(a2, b2);\\n        \\n        ans\\n    }\\n    \\n}\\n\\nfn cal(arr1: Vec<i32>, arr2: Vec<i32>) -> i64 {\\n    let mut ans: i64 = 0;\\n    let n = arr1.len();\\n    for i in 0..n {\\n        let a = arr1[i];\\n        let b = arr2[i];\\n        if b > a {\\n            ans += ((b-a)/2) as i64;\\n        }\\n    }\\n    ans\\n}\\nfn split(arr: Vec<i32>) -> (Vec<i32>, Vec<i32>) {\\n    let mut a1 = vec![];\\n    let mut a2 = vec![];\\n    for v in arr {\\n        if v & 1 == 1 {\\n            a1.push(v);\\n            continue\\n        }\\n        a2.push(v);\\n    }\\n    (a1, a2)\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_similar(mut nums: Vec<i32>, mut target: Vec<i32>) -> i64 {\\n        let mut ans: i64 = 0;\\n        let (mut a1, mut a2) = split(nums);\\n        let (mut b1, mut b2) = split(target);\\n        a1.sort();\\n        a2.sort();\\n        b1.sort();\\n        b2.sort();\\n        \\n        ans += cal(a1, b1);\\n        ans += cal(a2, b2);\\n        \\n        ans\\n    }\\n    \\n}\\n\\nfn cal(arr1: Vec<i32>, arr2: Vec<i32>) -> i64 {\\n    let mut ans: i64 = 0;\\n    let n = arr1.len();\\n    for i in 0..n {\\n        let a = arr1[i];\\n        let b = arr2[i];\\n        if b > a {\\n            ans += ((b-a)/2) as i64;\\n        }\\n    }\\n    ans\\n}\\nfn split(arr: Vec<i32>) -> (Vec<i32>, Vec<i32>) {\\n    let mut a1 = vec![];\\n    let mut a2 = vec![];\\n    for v in arr {\\n        if v & 1 == 1 {\\n            a1.push(v);\\n            continue\\n        }\\n        a2.push(v);\\n    }\\n    (a1, a2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740512,
                "title": "c-sorting-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        auto cmp = [&](int i1, int i2) {\\n            if((i1 & 1) == (i2 & 1)) return i1 < i2;\\n            return (i1 & 1) < (i2 & 1);\\n        };\\n        \\n        sort(nums.begin(), nums.end(), cmp);\\n        sort(target.begin(), target.end(), cmp);\\n        \\n        long long res = 0;\\n        for(int i = 0; i < nums.size(); i++) res += max(0, (target[i] - nums[i]) / 2);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        auto cmp = [&](int i1, int i2) {\\n            if((i1 & 1) == (i2 & 1)) return i1 < i2;\\n            return (i1 & 1) < (i2 & 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2739862,
                "title": "split-even-and-odd-numbers-python",
                "content": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums.sort()\\n        target.sort()\\n        ans = 0\\n        \\n        evenN = [n for n in nums if n % 2 == 0]\\n        evenT = [n for n in target if n % 2 == 0]\\n        for i in range(len(evenN)):\\n            ans += abs(evenN[i] - evenT[i])\\n        \\n        oddN = [n for n in nums if n % 2]\\n        oddT = [n for n in target if n % 2]\\n        for i in range(len(oddN)):\\n            ans += abs(oddN[i] - oddT[i])\\n            \\n        return ans // 4\\n    # Time: O(N * log(N)) where N is the length of nums and target\\n    # Space: O(N)\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums.sort()\\n        target.sort()\\n        ans = 0\\n        \\n        evenN = [n for n in nums if n % 2 == 0]\\n        evenT = [n for n in target if n % 2 == 0]\\n        for i in range(len(evenN)):\\n            ans += abs(evenN[i] - evenT[i])\\n        \\n        oddN = [n for n in nums if n % 2]\\n        oddT = [n for n in target if n % 2]\\n        for i in range(len(oddN)):\\n            ans += abs(oddN[i] - oddT[i])\\n            \\n        return ans // 4\\n    # Time: O(N * log(N)) where N is the length of nums and target\\n    # Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739825,
                "title": "basic-practice-observe-invariant-quantities-python",
                "content": "1- A solution format\\n```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        \\n        # 1. prep\\n        odd_nums = sorted([y for y in nums if y % 2 == 1])\\n        even_nums = sorted([y for y in nums if y % 2 == 0])\\n        odd_target = sorted([y for y in target if y % 2 == 1])\\n        even_target = sorted([y for y in target if y % 2 == 0])\\n        \\n        # 2. \"rough\" counting, // 2\\n        ops_odd = sum(abs(a - b) // 2 for a, b in zip(odd_nums, odd_target))\\n        ops_even = sum(abs(a - b) // 2 for a, b in zip(even_nums, even_target))\\n        \\n        return (ops_odd + ops_even) // 2\\n        \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/xP_mGBT7y-U;)\\n\\n3- Analysis or Summary\\n\\nMethod: separate even and odd numbers, and sort\\n\\nObservations:\\n\\n(1) If two arrays are similar in the sense of this problem, they have the same sum.\\n\\n(2) The operation in the problem statement does not change odd/even nature\\nof a number. More specifically, if y is odd, y + 2 or y - 2 remains odd.\\nSame if y is even. \\n\\nImplications:\\n\\nObs (2) means that we could consider even and odd numbers separately in nums and target respectively.\\n\\nObs (1) and (2) imply that we could do \"rough\" counting greedily and then divide by 2.\\n\\n\\nIf we look at Examples 1, 2, they involve only even numbers, odd numbers respectively. Example 3 covers the case that the number might have multiple appearances. Combing all three examples, in other words, let nums be the\\nconcatenation of three nums lists in the examples, similarly target, this\\nyields a generic example.\\n\\nWe just need to use Example-1 to fix the main idea of counting. After sorting,\\nnums   = [6, 8, 12]\\ntarget = [2, 10, 14]\\n\\nGreedily match: we could start matching from largest to smallest, or in\\nreverse order\\n\\n12, 14: need add 2 to 12, which corresponds to 1 ops\\n8, 10: need add 2 to 8, which corresponds to 1 ops\\n6, 2: need subtract 4 from 6, which corresponds to 2 ops\\n\\nIn total, there are \"4\" ops (counting both +, -), as we know \\n+ and - are in 1-1 correspondance, so the genuine ops needed is 4 // 2.\\n\\nComment: The former \"4\" gives us a convenient way of counting without the\\nneed to consider +, -. Overall, we just notice the # of + and # of - are equal. This is another invariance in this problem.\\n\\n\\nWe are going to write with some redundancy to make the idea clear.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        \\n        # 1. prep\\n        odd_nums = sorted([y for y in nums if y % 2 == 1])\\n        even_nums = sorted([y for y in nums if y % 2 == 0])\\n        odd_target = sorted([y for y in target if y % 2 == 1])\\n        even_target = sorted([y for y in target if y % 2 == 0])\\n        \\n        # 2. \"rough\" counting, // 2\\n        ops_odd = sum(abs(a - b) // 2 for a, b in zip(odd_nums, odd_target))\\n        ops_even = sum(abs(a - b) // 2 for a, b in zip(even_nums, even_target))\\n        \\n        return (ops_odd + ops_even) // 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739751,
                "title": "2449-minimum-number-of-operations-to-make-arrays-similar",
                "content": "```\\npublic class Solution {\\n    public long MakeSimilar(int[] nums, int[] target)\\n    {\\n        Array.Sort(nums);\\n        Array.Sort(target);\\n        var oA = new List<int>();\\n        var eA = new List<int>();\\n        var oB = new List<int>();\\n        var eB = new List<int>();\\n        foreach (var x in nums)\\n        {\\n            if (x % 2 == 1) oA.Add(x);\\n            else eA.Add(x);\\n        }\\n        foreach (var x in target)\\n        {\\n            if (x % 2 == 1) oB.Add(x);\\n            else eB.Add(x);\\n        }\\n        var ans = 0L;\\n        for (int i = 0; i < oA.Count(); i++)\\n            if (oA[i] > oB[i])\\n                ans += (oA[i] - oB[i]) / 2;\\n        for (int i = 0; i < eA.Count(); i++)\\n            if (eA[i] > eB[i])\\n                ans += (eA[i] - eB[i]) / 2;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long MakeSimilar(int[] nums, int[] target)\\n    {\\n        Array.Sort(nums);\\n        Array.Sort(target);\\n        var oA = new List<int>();\\n        var eA = new List<int>();\\n        var oB = new List<int>();\\n        var eB = new List<int>();\\n        foreach (var x in nums)\\n        {\\n            if (x % 2 == 1) oA.Add(x);\\n            else eA.Add(x);\\n        }\\n        foreach (var x in target)\\n        {\\n            if (x % 2 == 1) oB.Add(x);\\n            else eB.Add(x);\\n        }\\n        var ans = 0L;\\n        for (int i = 0; i < oA.Count(); i++)\\n            if (oA[i] > oB[i])\\n                ans += (oA[i] - oB[i]) / 2;\\n        for (int i = 0; i < eA.Count(); i++)\\n            if (eA[i] > eB[i])\\n                ans += (eA[i] - eB[i]) / 2;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739166,
                "title": "java-sorting-no-extra-memory-two-pointer",
                "content": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        int n = nums.length;\\n        long resp = 0;\\n        int en = 0;\\n        int et = 0;\\n        int on = 0;\\n        int ot = 0;\\n        while (en < n && nums[en] % 2 != 0) en++;\\n        while (et < n && target[et] % 2 != 0) et++;\\n        while (on < n && nums[on] % 2 == 0) on++;\\n        while (ot < n && target[ot] % 2 == 0) ot++;\\n        while (en < n) {\\n            resp += Math.abs(nums[en++]-target[et++]);\\n            while (en < n && nums[en] % 2 != 0) en++;\\n            while (et < n && target[et] % 2 != 0) et++;\\n        }\\n        while (on < n) {\\n            resp += Math.abs(nums[on++]-target[ot++]);\\n            while (on < n && nums[on] % 2 == 0) on++;\\n            while (ot < n && target[ot] % 2 == 0) ot++;\\n        }\\n        return resp / 4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        int n = nums.length;\\n        long resp = 0;\\n        int en = 0;\\n        int et = 0;\\n        int on = 0;\\n        int ot = 0;\\n        while (en < n && nums[en] % 2 != 0) en++;\\n        while (et < n && target[et] % 2 != 0) et++;\\n        while (on < n && nums[on] % 2 == 0) on++;\\n        while (ot < n && target[ot] % 2 == 0) ot++;\\n        while (en < n) {\\n            resp += Math.abs(nums[en++]-target[et++]);\\n            while (en < n && nums[en] % 2 != 0) en++;\\n            while (et < n && target[et] % 2 != 0) et++;\\n        }\\n        while (on < n) {\\n            resp += Math.abs(nums[on++]-target[ot++]);\\n            while (on < n && nums[on] % 2 == 0) on++;\\n            while (ot < n && target[ot] % 2 == 0) ot++;\\n        }\\n        return resp / 4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738877,
                "title": "c-sorting-greedy-faster-easy-to-understand",
                "content": "* ***Sorting && Greedy***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n\\n        int n = nums.size();\\n\\n        vector<int> odd_num;\\n\\n        vector<int> even_num;\\n\\n        vector<int> odd_target;\\n\\n        vector<int> even_target;\\n\\n        // segregate all the odd and even elements of nums and target\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2)\\n            {\\n                odd_num.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                even_num.push_back(nums[i]);\\n            }\\n\\n            if(target[i] % 2)\\n            {\\n                odd_target.push_back(target[i]);\\n            }\\n            else\\n            {\\n                even_target.push_back(target[i]);\\n            }\\n        }\\n\\n        // sort all the arrays\\n\\n        sort(odd_num.begin(), odd_num.end());\\n\\n        sort(odd_target.begin(), odd_target.end());\\n\\n        sort(even_num.begin(), even_num.end());\\n\\n        sort(even_target.begin(), even_target.end());\\n\\n        // now count no. of operations required\\n\\n        long long operations = 0;\\n\\n        // count the operations required for individual elements\\n\\n        // perform seperate operations for even\\n\\n        for(int i = 0; i < even_num.size(); i++)\\n        {\\n            int op = abs(even_num[i] - even_target[i]) / 2;\\n\\n            operations += op;\\n        }\\n\\n        // perform seperate operations for odd\\n\\n        for(int i = 0; i < odd_num.size(); i++)\\n        {\\n            int op = abs(odd_num[i] - odd_target[i]) / 2;\\n\\n            operations += op;\\n        }\\n\\n        // we can perform choose two elements at a time, so total no. of operations required will be operations / 2\\n\\n        return operations / 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n\\n        int n = nums.size();\\n\\n        vector<int> odd_num;\\n\\n        vector<int> even_num;\\n\\n        vector<int> odd_target;\\n\\n        vector<int> even_target;\\n\\n        // segregate all the odd and even elements of nums and target\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2)\\n            {\\n                odd_num.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                even_num.push_back(nums[i]);\\n            }\\n\\n            if(target[i] % 2)\\n            {\\n                odd_target.push_back(target[i]);\\n            }\\n            else\\n            {\\n                even_target.push_back(target[i]);\\n            }\\n        }\\n\\n        // sort all the arrays\\n\\n        sort(odd_num.begin(), odd_num.end());\\n\\n        sort(odd_target.begin(), odd_target.end());\\n\\n        sort(even_num.begin(), even_num.end());\\n\\n        sort(even_target.begin(), even_target.end());\\n\\n        // now count no. of operations required\\n\\n        long long operations = 0;\\n\\n        // count the operations required for individual elements\\n\\n        // perform seperate operations for even\\n\\n        for(int i = 0; i < even_num.size(); i++)\\n        {\\n            int op = abs(even_num[i] - even_target[i]) / 2;\\n\\n            operations += op;\\n        }\\n\\n        // perform seperate operations for odd\\n\\n        for(int i = 0; i < odd_num.size(); i++)\\n        {\\n            int op = abs(odd_num[i] - odd_target[i]) / 2;\\n\\n            operations += op;\\n        }\\n\\n        // we can perform choose two elements at a time, so total no. of operations required will be operations / 2\\n\\n        return operations / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738733,
                "title": "java-code-sorting",
                "content": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int j=0;\\n        List<Integer> evenNum = new ArrayList<>();\\n        List<Integer> event = new ArrayList<>();\\n        List<Integer> oddNum = new ArrayList<>();\\n        List<Integer> oddt = new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                evenNum.add(nums[i]);\\n            }\\n            else{\\n                oddNum.add(nums[i]);\\n            }\\n            \\n            if(target[i]%2==0){\\n                event.add(target[i]);\\n            }\\n            else{\\n                oddt.add(target[i]);\\n            }\\n        }\\n        \\n        Collections.sort(evenNum);\\n        Collections.sort(oddNum);\\n        Collections.sort(event);\\n        Collections.sort(oddt);\\n        \\n        long r1 = helper(evenNum,event);\\n        long r2 = helper(oddNum,oddt);\\n        \\n        return (r1+r2)/2;\\n    }\\n    \\n    long helper(List<Integer> l,List<Integer> t){\\n        long add=0;\\n        for(int i=0;i<l.size();i++){\\n            add += (Math.abs(l.get(i)-t.get(i))/2);\\n        }\\n        return add;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        int j=0;\\n        List<Integer> evenNum = new ArrayList<>();\\n        List<Integer> event = new ArrayList<>();\\n        List<Integer> oddNum = new ArrayList<>();\\n        List<Integer> oddt = new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                evenNum.add(nums[i]);\\n            }\\n            else{\\n                oddNum.add(nums[i]);\\n            }\\n            \\n            if(target[i]%2==0){\\n                event.add(target[i]);\\n            }\\n            else{\\n                oddt.add(target[i]);\\n            }\\n        }\\n        \\n        Collections.sort(evenNum);\\n        Collections.sort(oddNum);\\n        Collections.sort(event);\\n        Collections.sort(oddt);\\n        \\n        long r1 = helper(evenNum,event);\\n        long r2 = helper(oddNum,oddt);\\n        \\n        return (r1+r2)/2;\\n    }\\n    \\n    long helper(List<Integer> l,List<Integer> t){\\n        long add=0;\\n        for(int i=0;i<l.size();i++){\\n            add += (Math.abs(l.get(i)-t.get(i))/2);\\n        }\\n        return add;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738669,
                "title": "easy-sorting-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n\\n        \\n        vector<int> odd1;\\n        \\n        vector<int> even1;\\n        \\n        vector<int> odd2;\\n        \\n        vector<int> even2;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(nums[i]%2==0){\\n                even1.push_back(nums[i]);\\n            }\\n            \\n            else{\\n                odd1.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int i=0;i<target.size();i++){\\n            \\n            if(target[i]%2==0){\\n                even2.push_back(target[i]);\\n            }\\n            \\n            else{\\n                \\n                odd2.push_back(target[i]);\\n            }\\n        }\\n        \\n        long long sum=0;\\n        \\n        sort(odd1.begin(),odd1.end());\\n        \\n        sort(odd2.begin(),odd2.end());\\n        \\n        sort(even1.begin(),even1.end());\\n        \\n        sort(even2.begin(),even2.end());\\n        \\n        for(int i=0;i<even1.size();i++){\\n            \\n            if(even1[i]!=even2[i]){\\n                sum+=(abs(even1[i]-even2[i]));\\n            }\\n        }\\n        \\n        for(int i=0;i<odd1.size();i++){\\n            \\n            if(odd1[i]!=odd2[i]){\\n                sum+=(abs(odd1[i]-odd2[i]));\\n            }\\n        }\\n        \\n        long long ans = sum/4;\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n\\n        \\n        vector<int> odd1;\\n        \\n        vector<int> even1;\\n        \\n        vector<int> odd2;\\n        \\n        vector<int> even2;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(nums[i]%2==0){\\n                even1.push_back(nums[i]);\\n            }\\n            \\n            else{\\n                odd1.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int i=0;i<target.size();i++){\\n            \\n            if(target[i]%2==0){\\n                even2.push_back(target[i]);\\n            }\\n            \\n            else{\\n                \\n                odd2.push_back(target[i]);\\n            }\\n        }\\n        \\n        long long sum=0;\\n        \\n        sort(odd1.begin(),odd1.end());\\n        \\n        sort(odd2.begin(),odd2.end());\\n        \\n        sort(even1.begin(),even1.end());\\n        \\n        sort(even2.begin(),even2.end());\\n        \\n        for(int i=0;i<even1.size();i++){\\n            \\n            if(even1[i]!=even2[i]){\\n                sum+=(abs(even1[i]-even2[i]));\\n            }\\n        }\\n        \\n        for(int i=0;i<odd1.size();i++){\\n            \\n            if(odd1[i]!=odd2[i]){\\n                sum+=(abs(odd1[i]-odd2[i]));\\n            }\\n        }\\n        \\n        long long ans = sum/4;\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738663,
                "title": "python-greedy-on-sorted-items",
                "content": "```\\nclass Solution:       \\n    def makeSimilar(self, A: List[int], T: List[int]) -> int:        \\n        def calculate(a, t):\\n            minus = plus = 0        \\n            for aa, tt in zip(sorted(a), sorted(t)):\\n                minus += max(0, (aa - tt)) // 2\\n                plus += min(0, (aa - tt)) // 2        \\n            return max(minus, plus)\\n        return calculate([v for v in A if v % 2], [v for v in T if v % 2]) + calculate([v for v in A if v % 2 == 0], [v for v in T if v % 2 == 0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:       \\n    def makeSimilar(self, A: List[int], T: List[int]) -> int:        \\n        def calculate(a, t):\\n            minus = plus = 0        \\n            for aa, tt in zip(sorted(a), sorted(t)):\\n                minus += max(0, (aa - tt)) // 2\\n                plus += min(0, (aa - tt)) // 2        \\n            return max(minus, plus)\\n        return calculate([v for v in A if v % 2], [v for v in T if v % 2]) + calculate([v for v in A if v % 2 == 0], [v for v in T if v % 2 == 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738178,
                "title": "c-100-solution-concise-greedy-approach-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust review the performance of the code submitted during the contest, which shows beating 50%. So, what the codes beating 100% looks like.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe greedy approach is used here. Since the operation increase or decrease by 2. After one operation, odd still be odd and so do even.\\n\\nDuring the contest, we picked odd and even from \"nums\" and \"target\". Sort the 4 newly created arrays and count the number of operation. Of course, it is safe and accepted. However, 4 sorting is not a good idea in case we need concise solution and better performance. \\n\\nWe use lambda function to define a compare function, which significantly simplifies the codes.\\n \\n```\\nauto cmp=[](int a, int b) {\\n    return (a&1)<(b&1) || (a&1)==(b&1) && (a<b); \\n};\\n```\\n\\nBesides, we only count increasing operation which is sufficent.\\n\\n# Complexity\\n- Time complexity: O(N*LgN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Time 100% Solution\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long long n=nums.size(), ans=0;\\n        auto cmp=[](int a, int b) {\\n            return (a&1)<(b&1) || (a&1)==(b&1) && (a<b); \\n        };\\n        sort(nums.begin(), nums.end(), cmp);\\n        sort(target.begin(), target.end(), cmp);\\n        for(int i=0; i<n; ++i) {\\n            ans+=max(0, nums[i]-target[i])>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n// Time 50% Solution\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long long n=nums.size(), inc=0, dec=0;\\n        vector<int> src0, src1;\\n        vector<int> tgt0, tgt1;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i]&1) {\\n                src1.push_back(nums[i]);\\n            } else {\\n                src0.push_back(nums[i]);\\n            }\\n            if(target[i]&1) {\\n                tgt1.push_back(target[i]);\\n            } else {\\n                tgt0.push_back(target[i]);\\n            }\\n        }\\n        sort(src0.begin(), src0.end());\\n        sort(src1.begin(), src1.end());\\n        sort(tgt0.begin(), tgt0.end());\\n        sort(tgt1.begin(), tgt1.end());\\n        for(int i=0, m=src0.size(); i<m; ++i) {\\n            if(src0[i]<=tgt0[i]) {\\n                inc+=(tgt0[i]-src0[i])/2;\\n            } else {\\n                dec+=(src0[i]-tgt0[i])/2;\\n            }\\n        }\\n        for(int i=0, m=src1.size(); i<m; ++i) {\\n            if(src1[i]<=tgt1[i]) {\\n                inc+=(tgt1[i]-src1[i])/2;\\n            } else {\\n                dec+=(src1[i]-tgt1[i])/2;\\n            }\\n        }\\n        return max(inc, dec);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nauto cmp=[](int a, int b) {\\n    return (a&1)<(b&1) || (a&1)==(b&1) && (a<b); \\n};\\n```\n```\\n// Time 100% Solution\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long long n=nums.size(), ans=0;\\n        auto cmp=[](int a, int b) {\\n            return (a&1)<(b&1) || (a&1)==(b&1) && (a<b); \\n        };\\n        sort(nums.begin(), nums.end(), cmp);\\n        sort(target.begin(), target.end(), cmp);\\n        for(int i=0; i<n; ++i) {\\n            ans+=max(0, nums[i]-target[i])>>1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Time 50% Solution\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long long n=nums.size(), inc=0, dec=0;\\n        vector<int> src0, src1;\\n        vector<int> tgt0, tgt1;\\n        for(int i=0; i<n; ++i) {\\n            if(nums[i]&1) {\\n                src1.push_back(nums[i]);\\n            } else {\\n                src0.push_back(nums[i]);\\n            }\\n            if(target[i]&1) {\\n                tgt1.push_back(target[i]);\\n            } else {\\n                tgt0.push_back(target[i]);\\n            }\\n        }\\n        sort(src0.begin(), src0.end());\\n        sort(src1.begin(), src1.end());\\n        sort(tgt0.begin(), tgt0.end());\\n        sort(tgt1.begin(), tgt1.end());\\n        for(int i=0, m=src0.size(); i<m; ++i) {\\n            if(src0[i]<=tgt0[i]) {\\n                inc+=(tgt0[i]-src0[i])/2;\\n            } else {\\n                dec+=(src0[i]-tgt0[i])/2;\\n            }\\n        }\\n        for(int i=0, m=src1.size(); i<m; ++i) {\\n            if(src1[i]<=tgt1[i]) {\\n                inc+=(tgt1[i]-src1[i])/2;\\n            } else {\\n                dec+=(src1[i]-tgt1[i])/2;\\n            }\\n        }\\n        return max(inc, dec);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738137,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\n var makeSimilar = function(nums, target) {\\n    let res = 0;\\n    let [n1, n2] = trans(nums);\\n    let [t1, t2] = trans(target);\\n\\n    for(let i=0; i<n1.length; i++){\\n        let r = t1[i] - n1[i];\\n        if(r > 0){\\n            res += r / 2;\\n        }\\n    }\\n    for(let i=0; i<n2.length; i++){\\n        let r = t2[i] - n2[i];\\n        if(r > 0){\\n            res += r / 2;\\n        }\\n    }\\n\\n    return res;    \\n};\\n\\nfunction trans(arr){\\n    let res = [];\\n    let arr1 = [];\\n    let arr2 = [];\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(arr[i] % 2 === 0){\\n            arr1.push(arr[i]);\\n        }else{\\n            arr2.push(arr[i]);\\n        }\\n    }\\n    arr1.sort((a, b) => a-b);\\n    arr2.sort((a, b) => a-b);\\n    res = [arr1, arr2];\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} target\\n * @return {number}\\n */\\n var makeSimilar = function(nums, target) {\\n    let res = 0;\\n    let [n1, n2] = trans(nums);\\n    let [t1, t2] = trans(target);\\n\\n    for(let i=0; i<n1.length; i++){\\n        let r = t1[i] - n1[i];\\n        if(r > 0){\\n            res += r / 2;\\n        }\\n    }\\n    for(let i=0; i<n2.length; i++){\\n        let r = t2[i] - n2[i];\\n        if(r > 0){\\n            res += r / 2;\\n        }\\n    }\\n\\n    return res;    \\n};\\n\\nfunction trans(arr){\\n    let res = [];\\n    let arr1 = [];\\n    let arr2 = [];\\n\\n    for(let i=0; i<arr.length; i++){\\n        if(arr[i] % 2 === 0){\\n            arr1.push(arr[i]);\\n        }else{\\n            arr2.push(arr[i]);\\n        }\\n    }\\n    arr1.sort((a, b) => a-b);\\n    arr2.sort((a, b) => a-b);\\n    res = [arr1, arr2];\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738136,
                "title": "c-code-easy-explanation-commented-code",
                "content": "**Observation :**\\n1. The parity of the number will not change after any number of operations.\\n2. Odd numbers need to be matched with odd number in target array.\\n\\n**Approach**\\n\\nSince the parity does not change so we will handle odd and even number seperatly \\n\\n**Steps**\\n\\t`1. Put the odd number and even number in two different vectors for both the arrays`\\n\\t`2. Sort all the vectors (Let ev1,ev2 and od1,od2) `\\n\\t`3. Find the result by getting the sum of differences (sum(ev1 - ev2) + sum(od1-od2))/2\\n\\t(divided by 2 for a reason because we are approaching twice fast)`\\n\\t`4.Return the actual Result = res / 2`\\n\\t\\n**`Code`**\\n`\\n  \\t  \\n  \\n\\tlong long makeSimilar(vector<int>& A, vector<int>& B) {\\n\\t\\n\\t  // vector for storing the even values and odd values  of string A\\n\\t  vector<int> ev1,od1;\\n\\t  //vector for storing the even and odd values of string B\\n\\t  vector<int> eve2,od2;\\n\\t  \\n\\t  for(int i = 0;  i < A.size(); i++)\\n\\t  {\\n\\t\\t\\t  if(A[i] & 1)    od1.push_back(A[i]);\\n\\t\\t\\t  else  ev1.push_back(A[i]);\\n\\t  }\\n\\t  for(int i = 0;  i < B.size(); i++)\\n\\t  {\\n\\t\\t\\t  if(B[i] & 1)    od2.push_back(B[i]);\\n\\t\\t\\t  else  ev2.push_back(B[i]);\\n\\t  }\\n\\t  sort(ev1.begin(), ev1.end());\\n\\t  sort(od1.begin(), od1.end());\\n\\t  sort(ev2.begin(), ev2.end());\\n\\t  sort(od2.begin(), od2.end());\\n\\t  long long ans = 0;\\n\\t  \\n\\t  //Size of od1 and od2 will be equal . Why ? \\n\\t  for(int i = 0; i < od1.size(); i++)\\n\\t  {\\n\\t\\t  ans += (abs(od1[i] - od2[i])/2);\\n\\t  }\\n\\t  for(int i = 0; i < ev1.size(); i++)\\n\\t  {\\n\\t\\t  ans += (abs(ev1[i] - ev2[i])/2);\\n\\t  }\\n\\t  // Since our ans counts the action of adding and subtracting as 2 steps so we need to divide our answer by 2 \\n\\t  return ans/2; \\n\\t }\\n`\\n\\t\\n***Please Upvote incase you like it*** Comment down if you have any doubt",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "**Observation :**\\n1. The parity of the number will not change after any number of operations.\\n2. Odd numbers need to be matched with odd number in target array.\\n\\n**Approach**\\n\\nSince the parity does not change so we will handle odd and even number seperatly \\n\\n**Steps**\\n\\t`1. Put the odd number and even number in two different vectors for both the arrays`\\n\\t`2. Sort all the vectors (Let ev1,ev2 and od1,od2) `\\n\\t`3. Find the result by getting the sum of differences (sum(ev1 - ev2) + sum(od1-od2))/2\\n\\t(divided by 2 for a reason because we are approaching twice fast)`\\n\\t`4.Return the actual Result = res / 2`\\n\\t\\n**`Code`**\\n`\\n  \\t  \\n  \\n\\tlong long makeSimilar(vector<int>& A, vector<int>& B) {\\n\\t\\n\\t  // vector for storing the even values and odd values  of string A\\n\\t  vector<int> ev1,od1;\\n\\t  //vector for storing the even and odd values of string B\\n\\t  vector<int> eve2,od2;\\n\\t  \\n\\t  for(int i = 0;  i < A.size(); i++)\\n\\t  {\\n\\t\\t\\t  if(A[i] & 1)    od1.push_back(A[i]);\\n\\t\\t\\t  else  ev1.push_back(A[i]);\\n\\t  }\\n\\t  for(int i = 0;  i < B.size(); i++)\\n\\t  {\\n\\t\\t\\t  if(B[i] & 1)    od2.push_back(B[i]);\\n\\t\\t\\t  else  ev2.push_back(B[i]);\\n\\t  }\\n\\t  sort(ev1.begin(), ev1.end());\\n\\t  sort(od1.begin(), od1.end());\\n\\t  sort(ev2.begin(), ev2.end());\\n\\t  sort(od2.begin(), od2.end());\\n\\t  long long ans = 0;\\n\\t  \\n\\t  //Size of od1 and od2 will be equal . Why ? \\n\\t  for(int i = 0; i < od1.size(); i++)\\n\\t  {\\n\\t\\t  ans += (abs(od1[i] - od2[i])/2);\\n\\t  }\\n\\t  for(int i = 0; i < ev1.size(); i++)\\n\\t  {\\n\\t\\t  ans += (abs(ev1[i] - ev2[i])/2);\\n\\t  }\\n\\t  // Since our ans counts the action of adding and subtracting as 2 steps so we need to divide our answer by 2 \\n\\t  return ans/2; \\n\\t }\\n`\\n\\t\\n***Please Upvote incase you like it*** Comment down if you have any doubt",
                "codeTag": "Unknown"
            },
            {
                "id": 2737664,
                "title": "easy-o-logn-solution-in-c-odd-even",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int>nums0; // Even Elements in nums\\n        vector<int>nums1; // Odd Elements in nums\\n        vector<int>target0; // Even Elements in Target\\n        vector<int>target1; // Odd Elements in Target\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                nums0.push_back(nums[i]);\\n            else\\n                nums1.push_back(nums[i]);\\n            if(target[i]%2==0)\\n                target0.push_back(target[i]);\\n            else\\n                target1.push_back(target[i]);\\n        }\\n        // Sorting and then calculating absolute difference betweem nums and target \\n        sort(nums0.begin(),nums0.end());\\n        sort(nums1.begin(),nums1.end());\\n        sort(target0.begin(),target0.end());\\n        sort(target1.begin(),target1.end());\\n        long long int ans = 0;\\n        for(int i=0;i<nums0.size();i++)\\n            ans += abs(nums0[i]-target0[i]);\\n        for(int i=0;i<nums1.size();i++)\\n            ans += abs(nums1[i]-target1[i]);\\n        // Dividing the sum of differences by 4 (-2,+2)\\n        return ans/4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int>nums0; // Even Elements in nums\\n        vector<int>nums1; // Odd Elements in nums\\n        vector<int>target0; // Even Elements in Target\\n        vector<int>target1; // Odd Elements in Target\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                nums0.push_back(nums[i]);\\n            else\\n                nums1.push_back(nums[i]);\\n            if(target[i]%2==0)\\n                target0.push_back(target[i]);\\n            else\\n                target1.push_back(target[i]);\\n        }\\n        // Sorting and then calculating absolute difference betweem nums and target \\n        sort(nums0.begin(),nums0.end());\\n        sort(nums1.begin(),nums1.end());\\n        sort(target0.begin(),target0.end());\\n        sort(target1.begin(),target1.end());\\n        long long int ans = 0;\\n        for(int i=0;i<nums0.size();i++)\\n            ans += abs(nums0[i]-target0[i]);\\n        for(int i=0;i<nums1.size();i++)\\n            ans += abs(nums1[i]-target1[i]);\\n        // Dividing the sum of differences by 4 (-2,+2)\\n        return ans/4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737259,
                "title": "python3-one-liner-sort",
                "content": "# Intuition\\nForce sort order by adding a billion to odd numbers, then sorting\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        return sum(map(lambda p:abs(p[1]-p[0]), zip(list(sorted([i + 10**9 * (i%2) for i in nums])), list(sorted([j + 10**9 * (j%2) for j in target])))))>>2\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        return sum(map(lambda p:abs(p[1]-p[0]), zip(list(sorted([i + 10**9 * (i%2) for i in nums])), list(sorted([j + 10**9 * (j%2) for j in target])))))>>2\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737244,
                "title": "golang-195-ms-9-6-mb",
                "content": "```\\nfunc abs(a int) int {\\n\\tif a >= 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn -a\\n}\\n\\nfunc makeSimilar(nums []int, target []int) int64 {\\n\\tfor _, arr := range [...][]int{nums, target} {\\n\\t\\tsort.Slice(arr, func(i, j int) bool {\\n\\t\\t\\treturn arr[i]%2 == arr[j]%2 && arr[i] < arr[j] || arr[i]%2 < arr[j]%2\\n\\t\\t})\\n\\t}\\n\\n\\tresult := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tresult += abs(nums[i] - target[i])\\n\\t}\\n\\treturn int64(result / 4)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc abs(a int) int {\\n\\tif a >= 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn -a\\n}\\n\\nfunc makeSimilar(nums []int, target []int) int64 {\\n\\tfor _, arr := range [...][]int{nums, target} {\\n\\t\\tsort.Slice(arr, func(i, j int) bool {\\n\\t\\t\\treturn arr[i]%2 == arr[j]%2 && arr[i] < arr[j] || arr[i]%2 < arr[j]%2\\n\\t\\t})\\n\\t}\\n\\n\\tresult := 0\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tresult += abs(nums[i] - target[i])\\n\\t}\\n\\treturn int64(result / 4)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2737092,
                "title": "minimum-number-of-operations-to-make-arrays-similar-o-n-logn-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool isEven(int a) {\\n        return a % 2 == 0;\\n    }\\n    static bool comp(int a, int b) {\\n        if(isEven(a) && isEven(b)) {\\n            return a < b;\\n        }\\n        if(!isEven(a) && !isEven(b))\\n            return a < b;\\n        if(isEven(a))\\n            return false;\\n        return true;\\n    }\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        sort(nums.begin(), nums.end(), comp);\\n        sort(target.begin(), target.end(), comp);\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(target[i] > nums[i]) {\\n                res += (target[i] - nums[i]) / 2;\\n            }\\n        }        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool isEven(int a) {\\n        return a % 2 == 0;\\n    }\\n    static bool comp(int a, int b) {\\n        if(isEven(a) && isEven(b)) {\\n            return a < b;\\n        }\\n        if(!isEven(a) && !isEven(b))\\n            return a < b;\\n        if(isEven(a))\\n            return false;\\n        return true;\\n    }\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        sort(nums.begin(), nums.end(), comp);\\n        sort(target.begin(), target.end(), comp);\\n        \\n        long long res = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(target[i] > nums[i]) {\\n                res += (target[i] - nums[i]) / 2;\\n            }\\n        }        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737042,
                "title": "java-greedy-odd-even",
                "content": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        \\n        var ptr = new int[2]; \\n\\n        \\n        var count = 0L; \\n        \\n        for (var x: nums) {\\n            var p = x % 2; \\n\\n            while (target[ptr[p]] % 2 != p) {\\n\\n                ptr[p]++;\\n            }\\n\\n            count += Math.abs(target[ptr[p]] - x);\\n            ptr[p]++;\\n        }\\n        \\n        return count / 4;\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n\\n        \\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        \\n        var ptr = new int[2]; \\n\\n        \\n        var count = 0L; \\n        \\n        for (var x: nums) {\\n            var p = x % 2; \\n\\n            while (target[ptr[p]] % 2 != p) {\\n\\n                ptr[p]++;\\n            }\\n\\n            count += Math.abs(target[ptr[p]] - x);\\n            ptr[p]++;\\n        }\\n        \\n        return count / 4;\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737041,
                "title": "java-easy-approach-solution",
                "content": "```\\n// Here by question, we can see that, no. of odd and Even Elements in target and nums should be same for valid answer\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        int n = nums.length;\\n        List<Integer> evenTarget = new ArrayList<>();\\n        List<Integer> oddTarget = new ArrayList<>();\\n        List<Integer> evenEle = new ArrayList<>();\\n        List<Integer> oddEle = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            if(target[i]%2 == 0){\\n                evenTarget.add(target[i]);\\n            }else{\\n                oddTarget.add(target[i]);\\n            }\\n            \\n            if(nums[i]%2 == 0){\\n                evenEle.add(nums[i]);\\n            }else{\\n                oddEle.add(nums[i]);\\n            }\\n        }\\n        \\n        Collections.sort(evenTarget);\\n        Collections.sort(oddTarget);\\n        Collections.sort(evenEle);\\n        Collections.sort(oddEle);\\n        \\n        long neg = 0L;\\n        long pos = 0L;\\n        long moves = 0L;\\n        for(int i = 0; i < evenTarget.size(); i++){\\n            long u = evenEle.get(i);\\n            long v = evenTarget.get(i);\\n            if(pos > 0){\\n                // if ele < target, we can increase it by some pos\\n                if(u < v){\\n                    long min = Math.min(pos, v - u);\\n                    u += min;\\n                    pos -= min;\\n                }\\n            }\\n            \\n            if(neg > 0){\\n                if(u > v){\\n                    long min = Math.min(neg, u - v);\\n                    u -= min;\\n                    neg -= min;\\n                }\\n            }\\n            \\n            long diff = v - u;\\n            moves += Math.abs(diff/2);\\n            if(diff > 0){\\n                // target > ele.. \\n                // jaha par bhi ele > target, wala yeh add kar denge\\n                neg += diff;\\n            }else{\\n                pos += -diff;\\n            }\\n        }\\n        \\n        \\n        for(int i = 0; i < oddEle.size(); i++){\\n            long u = oddEle.get(i);\\n            long v = oddTarget.get(i);\\n            if(pos > 0){\\n                // if ele < target, we can increase it by some pos\\n                if(u < v){\\n                    long min = Math.min(pos, v - u);\\n                    u += min;\\n                    pos -= min;\\n                }\\n            }\\n            \\n            if(neg > 0){\\n                if(u > v){\\n                    long min = Math.min(neg, u - v);\\n                    u -= min;\\n                    neg -= min;\\n                }\\n            }\\n            \\n            long diff = v - u;\\n            moves += Math.abs(diff/2);\\n            if(diff > 0){\\n                // target > ele.. \\n                // jaha par bhi ele > target, wala yeh add kar denge\\n                neg += diff;\\n            }else{\\n                pos += -diff;\\n            }\\n        }\\n        \\n        if(pos != 0 || neg != 0){\\n            System.out.println(\" --> ohh \");\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n// Here by question, we can see that, no. of odd and Even Elements in target and nums should be same for valid answer\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        int n = nums.length;\\n        List<Integer> evenTarget = new ArrayList<>();\\n        List<Integer> oddTarget = new ArrayList<>();\\n        List<Integer> evenEle = new ArrayList<>();\\n        List<Integer> oddEle = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            if(target[i]%2 == 0){\\n                evenTarget.add(target[i]);\\n            }else{\\n                oddTarget.add(target[i]);\\n            }\\n            \\n            if(nums[i]%2 == 0){\\n                evenEle.add(nums[i]);\\n            }else{\\n                oddEle.add(nums[i]);\\n            }\\n        }\\n        \\n        Collections.sort(evenTarget);\\n        Collections.sort(oddTarget);\\n        Collections.sort(evenEle);\\n        Collections.sort(oddEle);\\n        \\n        long neg = 0L;\\n        long pos = 0L;\\n        long moves = 0L;\\n        for(int i = 0; i < evenTarget.size(); i++){\\n            long u = evenEle.get(i);\\n            long v = evenTarget.get(i);\\n            if(pos > 0){\\n                // if ele < target, we can increase it by some pos\\n                if(u < v){\\n                    long min = Math.min(pos, v - u);\\n                    u += min;\\n                    pos -= min;\\n                }\\n            }\\n            \\n            if(neg > 0){\\n                if(u > v){\\n                    long min = Math.min(neg, u - v);\\n                    u -= min;\\n                    neg -= min;\\n                }\\n            }\\n            \\n            long diff = v - u;\\n            moves += Math.abs(diff/2);\\n            if(diff > 0){\\n                // target > ele.. \\n                // jaha par bhi ele > target, wala yeh add kar denge\\n                neg += diff;\\n            }else{\\n                pos += -diff;\\n            }\\n        }\\n        \\n        \\n        for(int i = 0; i < oddEle.size(); i++){\\n            long u = oddEle.get(i);\\n            long v = oddTarget.get(i);\\n            if(pos > 0){\\n                // if ele < target, we can increase it by some pos\\n                if(u < v){\\n                    long min = Math.min(pos, v - u);\\n                    u += min;\\n                    pos -= min;\\n                }\\n            }\\n            \\n            if(neg > 0){\\n                if(u > v){\\n                    long min = Math.min(neg, u - v);\\n                    u -= min;\\n                    neg -= min;\\n                }\\n            }\\n            \\n            long diff = v - u;\\n            moves += Math.abs(diff/2);\\n            if(diff > 0){\\n                // target > ele.. \\n                // jaha par bhi ele > target, wala yeh add kar denge\\n                neg += diff;\\n            }else{\\n                pos += -diff;\\n            }\\n        }\\n        \\n        if(pos != 0 || neg != 0){\\n            System.out.println(\" --> ohh \");\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736901,
                "title": "c-easiest-approach-o-n-0ms-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int m=nums.size();\\n        int n=target.size();\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>evennums;\\n        vector<int>oddnums;\\n        vector<int>eventarget;\\n        vector<int>oddtarget;\\n        for(int i=0;i<m;i++){\\n            if(nums[i]%2==0){\\n                evennums.push_back(nums[i]);\\n            }\\n            else{\\n                oddnums.push_back(nums[i]);\\n            }\\n            if(target[i]%2==0){\\n                eventarget.push_back(target[i]);\\n            }else{\\n                oddtarget.push_back(target[i]);\\n            }\\n        }\\n        \\n        long ans=0;\\n        for(int i=0;i<evennums.size();i++){\\n            ans+=abs(evennums[i]-eventarget[i])/2;\\n        }\\n        for(int i=0;i<oddnums.size();i++){\\n            ans+=abs(oddnums[i]-oddtarget[i])/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        int m=nums.size();\\n        int n=target.size();\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int>evennums;\\n        vector<int>oddnums;\\n        vector<int>eventarget;\\n        vector<int>oddtarget;\\n        for(int i=0;i<m;i++){\\n            if(nums[i]%2==0){\\n                evennums.push_back(nums[i]);\\n            }\\n            else{\\n                oddnums.push_back(nums[i]);\\n            }\\n            if(target[i]%2==0){\\n                eventarget.push_back(target[i]);\\n            }else{\\n                oddtarget.push_back(target[i]);\\n            }\\n        }\\n        \\n        long ans=0;\\n        for(int i=0;i<evennums.size();i++){\\n            ans+=abs(evennums[i]-eventarget[i])/2;\\n        }\\n        for(int i=0;i<oddnums.size();i++){\\n            ans+=abs(oddnums[i]-oddtarget[i])/2;\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736864,
                "title": "c-even-odd-subarray-easy-to-understand",
                "content": "### Do upvote\\uD83D\\uDD3C if you find it useful :)\\n\\n# Complexity\\n- Time complexity: **O(nlogn)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> evennums;\\n        vector<int> oddnums;\\n        vector<int> eventarget;\\n        vector<int> oddtarget;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]&1){\\n                oddnums.push_back(nums[i]);    \\n            }\\n            else{\\n                evennums.push_back(nums[i]);\\n            }\\n            \\n        }\\n        for(int i=0 ; i<target.size() ; i++){\\n            if(target[i]&1){\\n                oddtarget.push_back(target[i]);    \\n            }\\n            else{\\n                eventarget.push_back(target[i]);\\n            }\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0 ; i<evennums.size() ; i++){\\n            ans+=abs(evennums[i]-eventarget[i]);\\n        }\\n        for(int i=0 ; i<oddnums.size() ; i++){\\n            ans+=abs(oddnums[i]-oddtarget[i]);\\n        }\\n        return (ans/4);   //divided by 2 since number can be decreased or increased by 2 \\n    }                      //and again divided by 2 as two numbers are selected at a time\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        vector<int> evennums;\\n        vector<int> oddnums;\\n        vector<int> eventarget;\\n        vector<int> oddtarget;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]&1){\\n                oddnums.push_back(nums[i]);    \\n            }\\n            else{\\n                evennums.push_back(nums[i]);\\n            }\\n            \\n        }\\n        for(int i=0 ; i<target.size() ; i++){\\n            if(target[i]&1){\\n                oddtarget.push_back(target[i]);    \\n            }\\n            else{\\n                eventarget.push_back(target[i]);\\n            }\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0 ; i<evennums.size() ; i++){\\n            ans+=abs(evennums[i]-eventarget[i]);\\n        }\\n        for(int i=0 ; i<oddnums.size() ; i++){\\n            ans+=abs(oddnums[i]-oddtarget[i]);\\n        }\\n        return (ans/4);   //divided by 2 since number can be decreased or increased by 2 \\n    }                      //and again divided by 2 as two numbers are selected at a time\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736851,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        vector<int> og_odd , og_even , tg_odd , tg_even;\\n        \\n        sort(nums.begin() , nums.end());\\n        sort(target.begin() , target.end());\\n        \\n        for(auto x : nums) {\\n            if(x % 2 == 0) {\\n                og_even.push_back(x);\\n            }\\n            else\\n                og_odd.push_back(x);\\n        }\\n        \\n        for(auto x : target) {\\n            if(x % 2 == 0) {\\n                tg_even.push_back(x);\\n            }\\n            else\\n                tg_odd.push_back(x);\\n        }\\n        \\n        long long step = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < tg_odd.size()) {\\n            if(og_odd[i] == tg_odd[i]) {\\n                i++;\\n            }\\n            else {\\n                step += abs(og_odd[i] - tg_odd[i])/2;\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        \\n        while(i < tg_even.size()) {\\n            if(og_even[i] == tg_even[i]) {\\n                i++;\\n            }\\n            else {\\n                step += abs(og_even[i] - tg_even[i])/2;\\n                i++;\\n            }\\n        }    \\n          \\n        return step/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        vector<int> og_odd , og_even , tg_odd , tg_even;\\n        \\n        sort(nums.begin() , nums.end());\\n        sort(target.begin() , target.end());\\n        \\n        for(auto x : nums) {\\n            if(x % 2 == 0) {\\n                og_even.push_back(x);\\n            }\\n            else\\n                og_odd.push_back(x);\\n        }\\n        \\n        for(auto x : target) {\\n            if(x % 2 == 0) {\\n                tg_even.push_back(x);\\n            }\\n            else\\n                tg_odd.push_back(x);\\n        }\\n        \\n        long long step = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < tg_odd.size()) {\\n            if(og_odd[i] == tg_odd[i]) {\\n                i++;\\n            }\\n            else {\\n                step += abs(og_odd[i] - tg_odd[i])/2;\\n                i++;\\n            }\\n        }\\n        \\n        i = 0;\\n        \\n        while(i < tg_even.size()) {\\n            if(og_even[i] == tg_even[i]) {\\n                i++;\\n            }\\n            else {\\n                step += abs(og_even[i] - tg_even[i])/2;\\n                i++;\\n            }\\n        }    \\n          \\n        return step/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736662,
                "title": "c-solution-sorting-approach",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        long long makeSimilar(vector<int> &nums, vector<int> &target)\\n        {\\n            sort(nums.begin(), nums.end());\\n            sort(target.begin(), target.end());\\n            vector<int> odd, even;\\n            int n = nums.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (nums[i] % 2)\\n                    odd.push_back(nums[i]);\\n                else even.push_back(nums[i]);\\n            }\\n            for (int i = 0; i < n; i++)\\n            {\\n\\n                if (target[i] % 2)\\n                    odd.push_back(target[i]);\\n                else even.push_back(target[i]);\\n            }\\n            long long diff = 0;\\n            cout << odd.size() << endl;\\n            for (int i = 0; i < odd.size() / 2; i++)\\n            {\\n\\n                diff += abs(odd[i] - odd[i + odd.size() / 2]) / 2;\\n            }\\n            for (int i = 0; i < even.size() / 2; i++)\\n            {\\n                diff += abs(even[i] - even[i + even.size() / 2]) / 2;\\n            }\\n            return diff / 2;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long makeSimilar(vector<int> &nums, vector<int> &target)\\n        {\\n            sort(nums.begin(), nums.end());\\n            sort(target.begin(), target.end());\\n            vector<int> odd, even;\\n            int n = nums.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (nums[i] % 2)\\n                    odd.push_back(nums[i]);\\n                else even.push_back(nums[i]);\\n            }\\n            for (int i = 0; i < n; i++)\\n            {\\n\\n                if (target[i] % 2)\\n                    odd.push_back(target[i]);\\n                else even.push_back(target[i]);\\n            }\\n            long long diff = 0;\\n            cout << odd.size() << endl;\\n            for (int i = 0; i < odd.size() / 2; i++)\\n            {\\n\\n                diff += abs(odd[i] - odd[i + odd.size() / 2]) / 2;\\n            }\\n            for (int i = 0; i < even.size() / 2; i++)\\n            {\\n                diff += abs(even[i] - even[i + even.size() / 2]) / 2;\\n            }\\n            return diff / 2;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2736557,
                "title": "easy-solution-using-odd-even-and-sorting",
                "content": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums.sort()\\n        target.sort()\\n        res=0\\n        numseven=[]\\n        numsodd=[]\\n        targeteven=[]\\n        targetodd=[]\\n        for i in nums:\\n            if i%2==0:\\n                numseven.append(i)\\n            else:\\n                numsodd.append(i)\\n                \\n        for i in target:\\n            if i%2==0:\\n                targeteven.append(i)\\n            else:\\n                targetodd.append(i)\\n        \\n        for i in range(len(numseven)):\\n            if numseven[i]-targeteven[i]>0:\\n                res+=numseven[i]-targeteven[i]\\n                \\n        for i in range(len(numsodd)):\\n            if numsodd[i]-targetodd[i]>0:\\n                res+=numsodd[i]-targetodd[i]\\n        return res//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums.sort()\\n        target.sort()\\n        res=0\\n        numseven=[]\\n        numsodd=[]\\n        targeteven=[]\\n        targetodd=[]\\n        for i in nums:\\n            if i%2==0:\\n                numseven.append(i)\\n            else:\\n                numsodd.append(i)\\n                \\n        for i in target:\\n            if i%2==0:\\n                targeteven.append(i)\\n            else:\\n                targetodd.append(i)\\n        \\n        for i in range(len(numseven)):\\n            if numseven[i]-targeteven[i]>0:\\n                res+=numseven[i]-targeteven[i]\\n                \\n        for i in range(len(numsodd)):\\n            if numsodd[i]-targetodd[i]>0:\\n                res+=numsodd[i]-targetodd[i]\\n        return res//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736552,
                "title": "simplest-solution-with-short-and-crisp-explanation",
                "content": "**\\u2B06\\uFE0F UPVOTE \\u2B06\\uFE0F**\\nOnly Simple thing to do in this problem is sorting the nums and the target arrays and then taking absolute differences.\\n\\nHere we first sort the nums vector keeping first the even elements increasing order and then the odd elements in increasing order.\\nSimilarly we sort the target vector.\\n\\n\\t   Now for each i from 0 to n-1, we take the absolute difference between nums and target element and keep adding it to the answer.\\n\\t Finally, we return ans/4 as the final answer (why ans/4?)....\\n\\t\\t\\t\\t because as given in the question, we do addition or subtraction of 2 from an\\n\\t\\t\\t\\t element of the nums vector, so that compensates for half of ans and next half is because \\n\\t\\t\\t\\t in one operation when we subtract 2 from an element of nums, \\n\\t\\t\\t\\t we add a 2 to some other element of nums as well, so this way two elements are getting covered. \\n \\n\\t\\tHence final output is ans/4.\\n\\t\\t\\nHere is the Code:\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end(),[](const int a,const int b){\\n            if(a%2==b%2)\\n            {\\n                return a<b;\\n            }\\n            return a%2==0;\\n        });\\n        sort(target.begin(),target.end(),[](const int a,const int b){\\n            if(a%2==b%2)\\n            {\\n                return a<b;\\n            }\\n            return a%2==0;\\n        });\\n\\n        int i=0,n=nums.size();\\n        \\n        while(i<n)\\n        {\\n            ans+=(abs(nums[i]-target[i]));\\n            i++;\\n        }\\n        return ans/4;\\n    }\\n};\\n```\\n***Please, please do \\u2B06\\uFE0F upvote \\u2B06\\uFE0F if you found it helpful, it keeps me motivated to post more of such solutions :*)** and feel free to ask in comments if you have any queries/doubts :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end(),[](const int a,const int b){\\n            if(a%2==b%2)\\n            {\\n                return a<b;\\n            }\\n            return a%2==0;\\n        });\\n        sort(target.begin(),target.end(),[](const int a,const int b){\\n            if(a%2==b%2)\\n            {\\n                return a<b;\\n            }\\n            return a%2==0;\\n        });\\n\\n        int i=0,n=nums.size();\\n        \\n        while(i<n)\\n        {\\n            ans+=(abs(nums[i]-target[i]));\\n            i++;\\n        }\\n        return ans/4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736471,
                "title": "easy-greedy-approach-sorting",
                "content": "# Complexity\\n- Time complexity: O(n log n) for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2 * n)  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        int n = nums.length, arr[] = new int[n];\\n        \\n        ArrayList<Integer> odd = new ArrayList<Integer>(n), even = new ArrayList<Integer>(n);\\n        \\n        for(int i=n-1; i>=0; --i) {\\n            if((nums[i]&1) == 0) even.add(i);\\n            else odd.add(i);\\n        }\\n        \\n        for(int i=n-1, idxeven = 0, idxodd = 0; i>=0; --i) {\\n            if((target[i]&1) == 0) \\n                arr[even.get(idxeven++)] = target[i];\\n            else \\n                arr[odd.get(idxodd++)] = target[i];\\n        }\\n        \\n        long sum=0;\\n        \\n        for(int i=0; i<n; ++i) \\n            if(arr[i] > nums[i]) sum += arr[i]-nums[i];\\n        \\n        return sum/2;\\n    }\\n}\\n```\\n\\nUpvote if u have liked!",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n        int n = nums.length, arr[] = new int[n];\\n        \\n        ArrayList<Integer> odd = new ArrayList<Integer>(n), even = new ArrayList<Integer>(n);\\n        \\n        for(int i=n-1; i>=0; --i) {\\n            if((nums[i]&1) == 0) even.add(i);\\n            else odd.add(i);\\n        }\\n        \\n        for(int i=n-1, idxeven = 0, idxodd = 0; i>=0; --i) {\\n            if((target[i]&1) == 0) \\n                arr[even.get(idxeven++)] = target[i];\\n            else \\n                arr[odd.get(idxodd++)] = target[i];\\n        }\\n        \\n        long sum=0;\\n        \\n        for(int i=0; i<n; ++i) \\n            if(arr[i] > nums[i]) sum += arr[i]-nums[i];\\n        \\n        return sum/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736271,
                "title": "o-nlogn-using-sorting-and-total-differences-examples",
                "content": "**Main Idea**:\\n+ A pair of elements in **nums** is increased / decrease by 2. Therfore, they keeps the odd / even attribute.\\n  + From there, we will sort array nums such that positions of even numbers are in front of positions of odd numbers.\\n+ A elemente is to increase by 2, and the other element is to decrease by 2. Therefore, the sum of total differences are zero.\\n+ For archiving the min number of operations, we sorted lower value in front of higher value.\\n+ Ans is total positive difference dividing 2\\n\\n**Examples**:\\n```\\nExample 1: nums = [8, 12, 6], target = [2, 14, 10]\\nsorted => nums = [6, 8, 12], target = [2, 10, 14]\\ndifferences ==>[+4, -2, -2] => total positive = 4 <-> total negative = -4 ==> total operation = 2\\n\\nExample 2: nums = [1, 2, 5], target = [4, 1, 3]\\nsorted => nums = [2, 1, 5], target = [4, 1, 3]\\ndifferences ==>[+2, 0, -2] => total positive = 2 <-> total negative = -2 ==> total operation = 1\\n```\\n\\n**Code**:\\n+ C++\\n```C++\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        auto op_cmp = [](int x1, int x2){ return x1%2 < x2%2 || (x1%2 == x2%2 && x1<x2); };\\n        \\n        std::sort(nums.begin(), nums.end(), op_cmp);\\n        std::sort(target.begin(), target.end(), op_cmp);\\n        \\n        long long ans = 0;\\n        for(int i=0;i < nums.size(); i++)\\n            if(nums[i]<target[i])\\n                ans += (target[i] - nums[i]) / 2;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n+ Python:\\n```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums = sorted(nums, key = lambda x: (x%2==1, x))\\n        target = sorted(target, key = lambda x: (x%2==1, x))\\n        \\n        ans = 0\\n        for i in range(len(nums)):\\n            if(nums[i]<target[i]):\\n                ans = ans + (target[i] - nums[i]) // 2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nExample 1: nums = [8, 12, 6], target = [2, 14, 10]\\nsorted => nums = [6, 8, 12], target = [2, 10, 14]\\ndifferences ==>[+4, -2, -2] => total positive = 4 <-> total negative = -4 ==> total operation = 2\\n\\nExample 2: nums = [1, 2, 5], target = [4, 1, 3]\\nsorted => nums = [2, 1, 5], target = [4, 1, 3]\\ndifferences ==>[+2, 0, -2] => total positive = 2 <-> total negative = -2 ==> total operation = 1\\n```\n```C++\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        auto op_cmp = [](int x1, int x2){ return x1%2 < x2%2 || (x1%2 == x2%2 && x1<x2); };\\n        \\n        std::sort(nums.begin(), nums.end(), op_cmp);\\n        std::sort(target.begin(), target.end(), op_cmp);\\n        \\n        long long ans = 0;\\n        for(int i=0;i < nums.size(); i++)\\n            if(nums[i]<target[i])\\n                ans += (target[i] - nums[i]) / 2;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums = sorted(nums, key = lambda x: (x%2==1, x))\\n        target = sorted(target, key = lambda x: (x%2==1, x))\\n        \\n        ans = 0\\n        for i in range(len(nums)):\\n            if(nums[i]<target[i]):\\n                ans = ans + (target[i] - nums[i]) // 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736207,
                "title": "java-sort-odds-evens-o-nlogn",
                "content": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        int n = nums.length;\\n        List<Integer> oddNums = new ArrayList<>();\\n        List<Integer> evenNums = new ArrayList<>();\\n        \\n        List<Integer> oddTarget = new ArrayList<>();\\n        List<Integer> evenTarget = new ArrayList<>();\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i] % 2 == 0){\\n                evenNums.add(nums[i]);\\n            }else{\\n                oddNums.add(nums[i]);\\n            }\\n            if(target[i] % 2 == 0){\\n                evenTarget.add(target[i]);\\n            }else{\\n                oddTarget.add(target[i]);\\n            }\\n        }\\n        \\n        Collections.sort(oddNums);\\n        Collections.sort(evenNums);\\n        Collections.sort(oddTarget);\\n        Collections.sort(evenTarget);\\n        \\n        return calculate(oddNums, oddTarget) + calculate(evenNums, evenTarget);\\n        \\n        \\n    }\\n    \\n    private long calculate(List<Integer> numList, List<Integer> targetList){\\n        \\n        long ops = 0;\\n        \\n        for(int i = 0 ; i < numList.size() ; i++){\\n            int a = numList.get(i);\\n            int b = targetList.get(i);\\n            if(a < b){\\n                ops += Math.abs(a - b) / 2;\\n            }\\n        }\\n        return ops;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        \\n        int n = nums.length;\\n        List<Integer> oddNums = new ArrayList<>();\\n        List<Integer> evenNums = new ArrayList<>();\\n        \\n        List<Integer> oddTarget = new ArrayList<>();\\n        List<Integer> evenTarget = new ArrayList<>();\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i] % 2 == 0){\\n                evenNums.add(nums[i]);\\n            }else{\\n                oddNums.add(nums[i]);\\n            }\\n            if(target[i] % 2 == 0){\\n                evenTarget.add(target[i]);\\n            }else{\\n                oddTarget.add(target[i]);\\n            }\\n        }\\n        \\n        Collections.sort(oddNums);\\n        Collections.sort(evenNums);\\n        Collections.sort(oddTarget);\\n        Collections.sort(evenTarget);\\n        \\n        return calculate(oddNums, oddTarget) + calculate(evenNums, evenTarget);\\n        \\n        \\n    }\\n    \\n    private long calculate(List<Integer> numList, List<Integer> targetList){\\n        \\n        long ops = 0;\\n        \\n        for(int i = 0 ; i < numList.size() ; i++){\\n            int a = numList.get(i);\\n            int b = targetList.get(i);\\n            if(a < b){\\n                ops += Math.abs(a - b) / 2;\\n            }\\n        }\\n        return ops;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736198,
                "title": "c-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(begin(nums), end(nums)), sort(begin(target), end(target));\\n        stable_partition(begin(nums), end(nums), [] (int x) { return x&1; });\\n        stable_partition(begin(target), end(target), [] (int x) { return x&1; });\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] > target[i]) ans += (nums[i] - target[i])/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(begin(nums), end(nums)), sort(begin(target), end(target));\\n        stable_partition(begin(nums), end(nums), [] (int x) { return x&1; });\\n        stable_partition(begin(target), end(target), [] (int x) { return x&1; });\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] > target[i]) ans += (nums[i] - target[i])/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736157,
                "title": "100-java-faster-soln",
                "content": "```\\n    public long makeSimilar(int[] a, int[] t) {\\n        \\n        Arrays.sort(a);       \\n        Arrays.sort(t);\\n        List<Integer> e1 = new ArrayList<>(),e2 = new ArrayList<>(),o1 = new ArrayList<>(),o2 = new ArrayList<>();\\n       \\n        for(int x : a)\\n        {\\n            if(x%2==0)e1.add(x);\\n            else o1.add(x);\\n        }\\n\\n        for(int x : t)\\n        {\\n            if(x%2==0)e2.add(x);\\n            else o2.add(x);\\n        }\\n        \\n        long dif  = 0;\\n        \\n        for(int i=0;i<e1.size();i++)\\n        {\\n            dif += Math.abs(e1.get(i)-e2.get(i));\\n        }\\n        \\n        for(int i=0;i<o1.size();i++)\\n        {\\n            dif += Math.abs(o1.get(i)-o2.get(i));\\n        }\\n        \\n        return dif/4;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long makeSimilar(int[] a, int[] t) {\\n        \\n        Arrays.sort(a);       \\n        Arrays.sort(t);\\n        List<Integer> e1 = new ArrayList<>(),e2 = new ArrayList<>(),o1 = new ArrayList<>(),o2 = new ArrayList<>();\\n       \\n        for(int x : a)\\n        {\\n            if(x%2==0)e1.add(x);\\n            else o1.add(x);\\n        }\\n\\n        for(int x : t)\\n        {\\n            if(x%2==0)e2.add(x);\\n            else o2.add(x);\\n        }\\n        \\n        long dif  = 0;\\n        \\n        for(int i=0;i<e1.size();i++)\\n        {\\n            dif += Math.abs(e1.get(i)-e2.get(i));\\n        }\\n        \\n        for(int i=0;i<o1.size();i++)\\n        {\\n            dif += Math.abs(o1.get(i)-o2.get(i));\\n        }\\n        \\n        return dif/4;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735991,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target)\\n    {\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        vector<int> onums, otarget, enums, etarget;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i] % 2 == 0)\\n                enums.push_back(nums[i]);\\n            else\\n                onums.push_back(nums[i]);\\n            \\n            if(target[i] % 2 == 0)\\n                etarget.push_back(target[i]);\\n            else\\n                otarget.push_back(target[i]);\\n        }\\n        \\n        long long ops=0;\\n        for(int i=0; i<enums.size(); i++) {\\n            if(etarget[i] > enums[i])\\n                ops += (etarget[i] - enums[i]) / 2;\\n        }\\n        for(int i=0; i<onums.size(); i++) {\\n            if(otarget[i] > onums[i])\\n                ops += (otarget[i] - onums[i]) / 2;\\n        }\\n        \\n        return ops;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target)\\n    {\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        vector<int> onums, otarget, enums, etarget;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i] % 2 == 0)\\n                enums.push_back(nums[i]);\\n            else\\n                onums.push_back(nums[i]);\\n            \\n            if(target[i] % 2 == 0)\\n                etarget.push_back(target[i]);\\n            else\\n                otarget.push_back(target[i]);\\n        }\\n        \\n        long long ops=0;\\n        for(int i=0; i<enums.size(); i++) {\\n            if(etarget[i] > enums[i])\\n                ops += (etarget[i] - enums[i]) / 2;\\n        }\\n        for(int i=0; i<onums.size(); i++) {\\n            if(otarget[i] > onums[i])\\n                ops += (otarget[i] - onums[i]) / 2;\\n        }\\n        \\n        return ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735929,
                "title": "python-easy-solution-odd-even",
                "content": "```\\n\\n```class Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        nums.sort()\\n        target.sort()\\n        \\n        count=0\\n        account=0\\n        \\n        def odds(x):\\n            return [c for c in x if c%2==1]\\n        \\n        def evens(x):\\n            return [c for c in x if c%2==0]\\n        \\n        for a,b in zip(odds(nums),odds(target)):\\n            if a==b:\\n                continue\\n                \\n            count+=abs(a-b)//2\\n            \\n        for a,b in zip(evens(nums),evens(target)):\\n            if a==b:\\n                continue\\n                \\n            count+=abs(a-b)//2\\n            \\n            \\n        return count//2",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735848,
                "title": "c-even-odd-partition-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long sum = 0;\\n        \\n        // splits odd and even numbers and targets\\n        vector<int> on, ot, en, et;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i]%2 == 0)\\n                en.push_back(nums[i]);\\n            else \\n                on.push_back(nums[i]);\\n            if(target[i]%2 == 0)\\n                et.push_back(target[i]);\\n            else \\n                ot.push_back(target[i]);\\n        }\\n        \\n        sort(on.begin(), on.end());\\n        sort(ot.begin(), ot.end());\\n        \\n        sort(en.begin(), en.end());\\n        sort(et.begin(), et.end());\\n        \\n        \\n        for(int i = 0; i < on.size(); i++) \\n            sum += abs(on[i]-ot[i]);\\n        \\n        for(int i = 0; i < en.size(); i++) \\n            sum += abs(en[i]-et[i]);\\n        \\n        return sum/4; \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        long long sum = 0;\\n        \\n        // splits odd and even numbers and targets\\n        vector<int> on, ot, en, et;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i]%2 == 0)\\n                en.push_back(nums[i]);\\n            else \\n                on.push_back(nums[i]);\\n            if(target[i]%2 == 0)\\n                et.push_back(target[i]);\\n            else \\n                ot.push_back(target[i]);\\n        }\\n        \\n        sort(on.begin(), on.end());\\n        sort(ot.begin(), ot.end());\\n        \\n        sort(en.begin(), en.end());\\n        sort(et.begin(), et.end());\\n        \\n        \\n        for(int i = 0; i < on.size(); i++) \\n            sum += abs(on[i]-ot[i]);\\n        \\n        for(int i = 0; i < en.size(); i++) \\n            sum += abs(en[i]-et[i]);\\n        \\n        return sum/4; \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735773,
                "title": "python-heap-even-odd-separately",
                "content": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        evenNums = []\\n        evenTargets = []\\n        oddNums = []\\n        oddTargets = []\\n        for num, tar in zip(nums, target):\\n            evenNums.append(num) if not num & 1 else oddNums.append(num)\\n            evenTargets.append(tar) if not tar & 1 else oddTargets.append(tar)\\n            \\n        heapify(evenNums)\\n        heapify(evenTargets)\\n        answer = 0\\n        while evenNums:\\n            first, second = heappop(evenNums), heappop(evenTargets)\\n            if first > second:\\n                answer += first - second\\n        \\n        heapify(oddNums)\\n        heapify(oddTargets)\\n        while oddNums:\\n            first, second = heappop(oddNums), heappop(oddTargets)\\n            if first > second:\\n                answer += first - second\\n        \\n        return answer // 2\\n\\n# time and space complexity\\n# time: O(nlog(n))\\n# space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def makeSimilar(self, nums: List[int], target: List[int]) -> int:\\n        evenNums = []\\n        evenTargets = []\\n        oddNums = []\\n        oddTargets = []\\n        for num, tar in zip(nums, target):\\n            evenNums.append(num) if not num & 1 else oddNums.append(num)\\n            evenTargets.append(tar) if not tar & 1 else oddTargets.append(tar)\\n            \\n        heapify(evenNums)\\n        heapify(evenTargets)\\n        answer = 0\\n        while evenNums:\\n            first, second = heappop(evenNums), heappop(evenTargets)\\n            if first > second:\\n                answer += first - second\\n        \\n        heapify(oddNums)\\n        heapify(oddTargets)\\n        while oddNums:\\n            first, second = heappop(oddNums), heappop(oddTargets)\\n            if first > second:\\n                answer += first - second\\n        \\n        return answer // 2\\n\\n# time and space complexity\\n# time: O(nlog(n))\\n# space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735746,
                "title": "c-7-line",
                "content": "```\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        auto v3 = vector(2, vector(2, vector<int>()));\\n        for(auto x:nums) v3[x%2][0].push_back(x);\\n        for(auto x:target) v3[x%2][1].push_back(x);\\n        for(auto& v2:v3) for(auto& v:v2) sort(v.begin(), v.end());\\n        long long diff = 0;\\n        for(auto& v2:v3) for(int i=0;i<v2[0].size();i++) diff += abs(v2[0][i] - v2[1][i]);\\n        return diff/4;\\n    }",
                "solutionTags": [],
                "code": "```\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        auto v3 = vector(2, vector(2, vector<int>()));\\n        for(auto x:nums) v3[x%2][0].push_back(x);\\n        for(auto x:target) v3[x%2][1].push_back(x);\\n        for(auto& v2:v3) for(auto& v:v2) sort(v.begin(), v.end());\\n        long long diff = 0;\\n        for(auto& v2:v3) for(int i=0;i<v2[0].size();i++) diff += abs(v2[0][i] - v2[1][i]);\\n        return diff/4;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2735733,
                "title": "100-beat-o-nlogn-time-o-n-space-break-into-even-odd",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> even1, even2;\\n        vector<int> odd1, odd2;\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        for (int i=0; i<nums.size(); i++) {\\n            if (nums[i]%2) odd1.push_back(nums[i]);\\n            else even1.push_back(nums[i]);\\n            \\n            if (target[i]%2) odd2.push_back(target[i]);\\n            else even2.push_back(target[i]);\\n        }\\n        \\n        long long res=0;\\n        for (int i=0; i<even1.size(); i++) {\\n            if (even1[i]<even2[i])\\n                res+=(even2[i]-even1[i])/2;\\n        }\\n        for (int i=0; i<odd1.size(); i++) {\\n            if (odd1[i]<odd2[i])\\n                res+=(odd2[i]-odd1[i])/2;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        vector<int> even1, even2;\\n        vector<int> odd1, odd2;\\n        \\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        \\n        for (int i=0; i<nums.size(); i++) {\\n            if (nums[i]%2) odd1.push_back(nums[i]);\\n            else even1.push_back(nums[i]);\\n            \\n            if (target[i]%2) odd2.push_back(target[i]);\\n            else even2.push_back(target[i]);\\n        }\\n        \\n        long long res=0;\\n        for (int i=0; i<even1.size(); i++) {\\n            if (even1[i]<even2[i])\\n                res+=(even2[i]-even1[i])/2;\\n        }\\n        for (int i=0; i<odd1.size(); i++) {\\n            if (odd1[i]<odd2[i])\\n                res+=(odd2[i]-odd1[i])/2;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735716,
                "title": "identify-why-the-answer-is-possible-from-testcases-odd-even",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& a, vector<int>& b) {\\n         vector<int> ao,bo,ae,be;\\n         for(int i=0; i<a.size(); i++) {\\n               if(a[i] % 2) {\\n                    ao.push_back(a[i]);\\n               }else if(a[i] % 2 == 0) {\\n                    ae.push_back(a[i]);\\n               }\\n               if(b[i] % 2) {\\n                    bo.push_back(b[i]);\\n               }else if(b[i] % 2 == 0) {\\n                    be.push_back(b[i]);\\n               }\\n         }\\n         sort(ao.begin(),ao.end());\\n         sort(ae.begin(),ae.end());\\n         sort(bo.begin(),bo.end());\\n         sort(be.begin(),be.end());\\n         long long ans = 0;\\n         for(int i=0; i<ao.size(); i++) ans+=abs(ao[i] - bo[i])/2;\\n         for(int i=0; i<ae.size(); i++) ans+=abs(ae[i] - be[i])/2;\\n         return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& a, vector<int>& b) {\\n         vector<int> ao,bo,ae,be;\\n         for(int i=0; i<a.size(); i++) {\\n               if(a[i] % 2) {\\n                    ao.push_back(a[i]);\\n               }else if(a[i] % 2 == 0) {\\n                    ae.push_back(a[i]);\\n               }\\n               if(b[i] % 2) {\\n                    bo.push_back(b[i]);\\n               }else if(b[i] % 2 == 0) {\\n                    be.push_back(b[i]);\\n               }\\n         }\\n         sort(ao.begin(),ao.end());\\n         sort(ae.begin(),ae.end());\\n         sort(bo.begin(),bo.end());\\n         sort(be.begin(),be.end());\\n         long long ans = 0;\\n         for(int i=0; i<ao.size(); i++) ans+=abs(ao[i] - bo[i])/2;\\n         for(int i=0; i<ae.size(); i++) ans+=abs(ae[i] - be[i])/2;\\n         return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735629,
                "title": "cxx-sort-and-stable-partition-accumlate",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        stable_partition(nums.begin(), nums.end(),[](int a){return (a%2)>0;});\\n        stable_partition(target.begin(), target.end(),[](int a){return (a%2)>0;});\\n\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n          ans += max(nums[i] - target[i], 0) / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(), nums.end());\\n        sort(target.begin(), target.end());\\n        stable_partition(nums.begin(), nums.end(),[](int a){return (a%2)>0;});\\n        stable_partition(target.begin(), target.end(),[](int a){return (a%2)>0;});\\n\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n          ans += max(nums[i] - target[i], 0) / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735621,
                "title": "java-special-sorting-two-pointers-easy-to-understand",
                "content": "Runtime: 48 ms, faster than 100.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\nMemory Usage: 58.7 MB, less than 100.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n```\\nclass Solution {\\n  public long makeSimilar(int[] nums, int[] t) {\\n    reconstruct(nums);\\n    reconstruct(t);\\n    \\n    for(int i = 0; i != nums.length; i++)\\n      t[i] -= nums[i];\\n    \\n    Arrays.sort(t);\\n    int l = 0;\\n    while(t[l] < 0) l++;\\n    \\n    if(l-- == 0) return 0;\\n    \\n    int r = l;\\n    while(t[r] <= 0) r++;\\n    \\n    long ans = 0;\\n    while(l != -1)\\n      if     (-t[l] == t[r]) {ans += t[r]; l--; r++;}\\n      else if(-t[l] <  t[r]) {ans -= t[l]; t[r] += t[l]; l--;}\\n      else                   {ans += t[r]; t[l] += t[r]; r++;}  \\n    \\n    return ans>>1;\\n  }\\n  \\n  void reconstruct(int[] arr){\\n    int l = 0, r = arr.length - 1;\\n    \\n    while(l < r)\\n      if     ( (arr[l]&1) == 1) l++;\\n      else if( (arr[r]&1) == 0) r--;\\n      else{\\n        int x = arr[l];\\n        arr[l++] = arr[r];\\n        arr[r--] = x;\\n      }\\n    \\n    if(l != arr.length && (arr[l]&1) == 1 ) l++;\\n    Arrays.sort(arr, 0, l);\\n    Arrays.sort(arr, l, arr.length);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long makeSimilar(int[] nums, int[] t) {\\n    reconstruct(nums);\\n    reconstruct(t);\\n    \\n    for(int i = 0; i != nums.length; i++)\\n      t[i] -= nums[i];\\n    \\n    Arrays.sort(t);\\n    int l = 0;\\n    while(t[l] < 0) l++;\\n    \\n    if(l-- == 0) return 0;\\n    \\n    int r = l;\\n    while(t[r] <= 0) r++;\\n    \\n    long ans = 0;\\n    while(l != -1)\\n      if     (-t[l] == t[r]) {ans += t[r]; l--; r++;}\\n      else if(-t[l] <  t[r]) {ans -= t[l]; t[r] += t[l]; l--;}\\n      else                   {ans += t[r]; t[l] += t[r]; r++;}  \\n    \\n    return ans>>1;\\n  }\\n  \\n  void reconstruct(int[] arr){\\n    int l = 0, r = arr.length - 1;\\n    \\n    while(l < r)\\n      if     ( (arr[l]&1) == 1) l++;\\n      else if( (arr[r]&1) == 0) r--;\\n      else{\\n        int x = arr[l];\\n        arr[l++] = arr[r];\\n        arr[r--] = x;\\n      }\\n    \\n    if(l != arr.length && (arr[l]&1) == 1 ) l++;\\n    Arrays.sort(arr, 0, l);\\n    Arrays.sort(arr, l, arr.length);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735619,
                "title": "rust-sort-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFollowing are facts that can be easily proved:\\n1) When both arrays are sorted, they will be the same after performing required operations.\\n2) They all have the same number of even numbers & the same number of odd numbers, as the operation does cause switching between an even number and an odd number.\\n3) Therefore, they could be dealt with separately.\\n4) In calculating, we only need to count \\'+\\' part, or the \\'-\\' part, not both, since they are cancelling out each other eventually in total.     \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Separate even numbers & odd numbers\\n2) Sort the new arrays    \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn make_similar(nums: Vec<i32>, target: Vec<i32>) -> i64 {\\n        let (mut v1_even, mut v1_odd) = (vec![], vec![]);\\n        let (mut v2_even, mut v2_odd) = (vec![], vec![]);\\n\\n        for a in nums {\\n            if a % 2 == 0 { v1_even.push(a); }\\n            else          { v1_odd.push(a); }\\n        }\\n        for a in target {\\n            if a % 2 == 0 { v2_even.push(a); }\\n            else          { v2_odd.push(a); }\\n        }\\n        \\n        v1_even.sort();\\n        v1_odd.sort();\\n        v2_even.sort();\\n        v2_odd.sort();\\n\\n        let mut ret = 0;\\n\\n        while v1_even.is_empty() == false {\\n            let b = v1_even[v1_even.len() - 1] - v2_even[v2_even.len() - 1];\\n            if b > 0 { ret += b as i64 / 2; }\\n            v1_even.pop();\\n            v2_even.pop();\\n        }\\n        while v1_odd.is_empty() == false {\\n            let b = v1_odd[v1_odd.len() - 1] - v2_odd[v2_odd.len() - 1];\\n            if b > 0 { ret += b as i64 / 2; }\\n            v1_odd.pop();\\n            v2_odd.pop();\\n        }\\n         \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_similar(nums: Vec<i32>, target: Vec<i32>) -> i64 {\\n        let (mut v1_even, mut v1_odd) = (vec![], vec![]);\\n        let (mut v2_even, mut v2_odd) = (vec![], vec![]);\\n\\n        for a in nums {\\n            if a % 2 == 0 { v1_even.push(a); }\\n            else          { v1_odd.push(a); }\\n        }\\n        for a in target {\\n            if a % 2 == 0 { v2_even.push(a); }\\n            else          { v2_odd.push(a); }\\n        }\\n        \\n        v1_even.sort();\\n        v1_odd.sort();\\n        v2_even.sort();\\n        v2_odd.sort();\\n\\n        let mut ret = 0;\\n\\n        while v1_even.is_empty() == false {\\n            let b = v1_even[v1_even.len() - 1] - v2_even[v2_even.len() - 1];\\n            if b > 0 { ret += b as i64 / 2; }\\n            v1_even.pop();\\n            v2_even.pop();\\n        }\\n        while v1_odd.is_empty() == false {\\n            let b = v1_odd[v1_odd.len() - 1] - v2_odd[v2_odd.len() - 1];\\n            if b > 0 { ret += b as i64 / 2; }\\n            v1_odd.pop();\\n            v2_odd.pop();\\n        }\\n         \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735564,
                "title": "sort-odds-and-evens-and-match-greedily",
                "content": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        ArrayList<Integer> oddnums = new ArrayList<>();\\n        ArrayList<Integer> evenums = new ArrayList<>();\\n        ArrayList<Integer> oddTarget = new ArrayList<>();\\n        ArrayList<Integer> evenTarget = new ArrayList<>();\\n        for(int a:nums){\\n            if(a%2==0)evenums.add(a);\\n            else oddnums.add(a);\\n        }\\n        for(int a:target){\\n            if(a%2==0)evenTarget.add(a);\\n            else oddTarget.add(a);\\n        }\\n        Collections.sort(oddnums);\\n        Collections.sort(evenums);\\n        Collections.sort(oddTarget);\\n        Collections.sort(evenTarget);\\n        int n = oddnums.size(),l = evenTarget.size();\\n        double ans = 0;\\n        for(int i = 0;i<n;i++)ans += (double)Math.abs((double)oddnums.get(i)-(double)oddTarget.get(i))/4;\\n        for(int i = 0;i<l;i++)ans += (double)Math.abs((double)evenums.get(i)-(double)evenTarget.get(i))/4;\\n        return (long)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long makeSimilar(int[] nums, int[] target) {\\n        ArrayList<Integer> oddnums = new ArrayList<>();\\n        ArrayList<Integer> evenums = new ArrayList<>();\\n        ArrayList<Integer> oddTarget = new ArrayList<>();\\n        ArrayList<Integer> evenTarget = new ArrayList<>();\\n        for(int a:nums){\\n            if(a%2==0)evenums.add(a);\\n            else oddnums.add(a);\\n        }\\n        for(int a:target){\\n            if(a%2==0)evenTarget.add(a);\\n            else oddTarget.add(a);\\n        }\\n        Collections.sort(oddnums);\\n        Collections.sort(evenums);\\n        Collections.sort(oddTarget);\\n        Collections.sort(evenTarget);\\n        int n = oddnums.size(),l = evenTarget.size();\\n        double ans = 0;\\n        for(int i = 0;i<n;i++)ans += (double)Math.abs((double)oddnums.get(i)-(double)oddTarget.get(i))/4;\\n        for(int i = 0;i<l;i++)ans += (double)Math.abs((double)evenums.get(i)-(double)evenTarget.get(i))/4;\\n        return (long)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735551,
                "title": "c-solution-with-dividing-array-to-even-and-odd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- at first the problem might seem complex but if u look carefully.\\n- when we add 2 or subtract 2 we get same type integer i.e odd-2 or odd+2 =odd (even+2 or even-2 =even).\\n- we got this information.then we can see add and subtract must be one operation.\\n- so when we add then we must subtract. lets count number of subtracts or addition i.e our answer.\\n\\n\\n\\nexample:  if we have evenNums[i]>=evenTarget[i] then we need decrease evenNums[i]-evenTarget[i] so we count in that.\\n        nums=[20,30,40,50]  target=[24,26,44,46]\\n\\ndo the following steps we get the answer.\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NLog(N) to sort + N to traverse)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N to store in even and odd)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        long long ans=0;\\n        \\n        long long sum=0,dif;\\n        int i=0,j=0;\\n        vector<int> even1,odd1,even2,odd2;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]%2)\\n                odd1.push_back(nums[i]);\\n            else\\n                even1.push_back(nums[i]);\\n\\n            if(target[i]%2)\\n                odd2.push_back(target[i]);\\n            else\\n                even2.push_back(target[i]);\\n            i++;\\n        }\\n        \\n        i=0,j=0;\\n        while(i<even1.size())\\n        {\\n            if(even1[i]>=even2[i])\\n            {\\n                ans+=(even1[i]-even2[i])/2;\\n            }\\n            i++;\\n        }\\n        i=0,j=0;\\n        while(i<odd1.size())\\n        {\\n            if(odd1[i]>=odd2[i])\\n            {\\n                ans+=(odd1[i]-odd2[i])/2;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//even  2, 6 8  3 5\\n//even  4  8 8  1 3\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        long long ans=0;\\n        \\n        long long sum=0,dif;\\n        int i=0,j=0;\\n        vector<int> even1,odd1,even2,odd2;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]%2)\\n                odd1.push_back(nums[i]);\\n            else\\n                even1.push_back(nums[i]);\\n\\n            if(target[i]%2)\\n                odd2.push_back(target[i]);\\n            else\\n                even2.push_back(target[i]);\\n            i++;\\n        }\\n        \\n        i=0,j=0;\\n        while(i<even1.size())\\n        {\\n            if(even1[i]>=even2[i])\\n            {\\n                ans+=(even1[i]-even2[i])/2;\\n            }\\n            i++;\\n        }\\n        i=0,j=0;\\n        while(i<odd1.size())\\n        {\\n            if(odd1[i]>=odd2[i])\\n            {\\n                ans+=(odd1[i]-odd2[i])/2;\\n            }\\n            i++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//even  2, 6 8  3 5\\n//even  4  8 8  1 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735485,
                "title": "java-2-solutions-sort-priorityqueue",
                "content": "# 2.sort\\n```\\n\\t//2.sort\\n    //Runtime: 52 ms, faster than 100.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    //Memory Usage: 60.1 MB, less than 100.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    //Time: O(N * logN); Space: O(N)\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n\\n        List<Integer> listEvenNums = new ArrayList<>();\\n        List<Integer> listOddNums = new ArrayList<>();\\n        List<Integer> listEvenTarget = new ArrayList<>();\\n        List<Integer> listOddTarget = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) listEvenNums.add(nums[i]);\\n            else listOddNums.add(nums[i]);\\n\\n            if (target[i] % 2 == 0) listEvenTarget.add(target[i]);\\n            else listOddTarget.add(target[i]);\\n        }\\n\\n        long res = 0L;\\n        for (int i = 0; i < listEvenNums.size(); i++)\\n            res += Math.abs(listEvenNums.get(i) - listEvenTarget.get(i));\\n\\n        for (int i = 0; i < listOddNums.size(); i++)\\n            res += Math.abs(listOddNums.get(i) - listOddTarget.get(i));\\n\\n        return res >> 2;\\n    }\\n```\\n# 1.PriorityQueue\\n```\\n    //1.PriorityQueue\\n    //Runtime: 334 ms, faster than 25.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    //Memory Usage: 94 MB, less than 75.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    public long makeSimilar_1(int[] nums, int[] target) {\\n\\n        Queue<Integer> queueEvenNums = new PriorityQueue<>();\\n        Queue<Integer> queueOddNums = new PriorityQueue<>();\\n        Queue<Integer> queueEvenTarget = new PriorityQueue<>();\\n        Queue<Integer> queueOddTarget = new PriorityQueue<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) queueEvenNums.add(nums[i]);\\n            else queueOddNums.add(nums[i]);\\n\\n            if (target[i] % 2 == 0) queueEvenTarget.add(target[i]);\\n            else queueOddTarget.add(target[i]);\\n        }\\n\\n        long res = 0l;\\n        while (!queueEvenNums.isEmpty()) {\\n            int x = queueEvenNums.poll() - queueEvenTarget.poll();\\n            if (x > 0) res += x >> 1;\\n        }\\n        while (!queueOddNums.isEmpty()) {\\n            int x = queueOddNums.poll() - queueOddTarget.poll();\\n            if (x > 0) res += x >> 1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\t//2.sort\\n    //Runtime: 52 ms, faster than 100.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    //Memory Usage: 60.1 MB, less than 100.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    //Time: O(N * logN); Space: O(N)\\n    public long makeSimilar(int[] nums, int[] target) {\\n        Arrays.sort(nums);\\n        Arrays.sort(target);\\n\\n        List<Integer> listEvenNums = new ArrayList<>();\\n        List<Integer> listOddNums = new ArrayList<>();\\n        List<Integer> listEvenTarget = new ArrayList<>();\\n        List<Integer> listOddTarget = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) listEvenNums.add(nums[i]);\\n            else listOddNums.add(nums[i]);\\n\\n            if (target[i] % 2 == 0) listEvenTarget.add(target[i]);\\n            else listOddTarget.add(target[i]);\\n        }\\n\\n        long res = 0L;\\n        for (int i = 0; i < listEvenNums.size(); i++)\\n            res += Math.abs(listEvenNums.get(i) - listEvenTarget.get(i));\\n\\n        for (int i = 0; i < listOddNums.size(); i++)\\n            res += Math.abs(listOddNums.get(i) - listOddTarget.get(i));\\n\\n        return res >> 2;\\n    }\\n```\n```\\n    //1.PriorityQueue\\n    //Runtime: 334 ms, faster than 25.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    //Memory Usage: 94 MB, less than 75.00% of Java online submissions for Minimum Number of Operations to Make Arrays Similar.\\n    public long makeSimilar_1(int[] nums, int[] target) {\\n\\n        Queue<Integer> queueEvenNums = new PriorityQueue<>();\\n        Queue<Integer> queueOddNums = new PriorityQueue<>();\\n        Queue<Integer> queueEvenTarget = new PriorityQueue<>();\\n        Queue<Integer> queueOddTarget = new PriorityQueue<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) queueEvenNums.add(nums[i]);\\n            else queueOddNums.add(nums[i]);\\n\\n            if (target[i] % 2 == 0) queueEvenTarget.add(target[i]);\\n            else queueOddTarget.add(target[i]);\\n        }\\n\\n        long res = 0l;\\n        while (!queueEvenNums.isEmpty()) {\\n            int x = queueEvenNums.poll() - queueEvenTarget.poll();\\n            if (x > 0) res += x >> 1;\\n        }\\n        while (!queueOddNums.isEmpty()) {\\n            int x = queueOddNums.poll() - queueOddTarget.poll();\\n            if (x > 0) res += x >> 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735459,
                "title": "rust-parity-sort",
                "content": "```\\nimpl Solution {\\n    pub fn make_similar(nums: Vec<i32>, target: Vec<i32>) -> i64 {\\n        let (mut n_odd, mut t_odd, mut n_even, mut t_even) = nums.into_iter().zip(target.into_iter())\\n            .fold((vec![], vec![], vec![], vec![]), |(mut n_odd, mut t_odd, mut n_even, mut t_even), (n, t)| {\\n                if n % 2 == 0 { n_even.push(n) } else { n_odd.push(n) }\\n                if t % 2 == 0 { t_even.push(t) } else { t_odd.push(t) }\\n                (n_odd, t_odd, n_even, t_even)\\n            });\\n            n_odd.sort_unstable();\\n            n_even.sort_unstable();\\n            t_odd.sort_unstable();\\n            t_even.sort_unstable();\\n            (n_odd.into_iter().zip(t_odd.into_iter()).map(|(n, t)| (n-t).abs() as i64).sum::<i64>()\\n            + n_even.into_iter().zip(t_even.into_iter()).map(|(n, t)| (n-t).abs() as i64).sum::<i64>()) / 4\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_similar(nums: Vec<i32>, target: Vec<i32>) -> i64 {\\n        let (mut n_odd, mut t_odd, mut n_even, mut t_even) = nums.into_iter().zip(target.into_iter())\\n            .fold((vec![], vec![], vec![], vec![]), |(mut n_odd, mut t_odd, mut n_even, mut t_even), (n, t)| {\\n                if n % 2 == 0 { n_even.push(n) } else { n_odd.push(n) }\\n                if t % 2 == 0 { t_even.push(t) } else { t_odd.push(t) }\\n                (n_odd, t_odd, n_even, t_even)\\n            });\\n            n_odd.sort_unstable();\\n            n_even.sort_unstable();\\n            t_odd.sort_unstable();\\n            t_even.sort_unstable();\\n            (n_odd.into_iter().zip(t_odd.into_iter()).map(|(n, t)| (n-t).abs() as i64).sum::<i64>()\\n            + n_even.into_iter().zip(t_even.into_iter()).map(|(n, t)| (n-t).abs() as i64).sum::<i64>()) / 4\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735440,
                "title": "c-o-nlogn-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider the two arrays are sorted. How much decrease and increase is required for each element in the first array with respect to the second array to make first array equal to second array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort both the arrays in increasing order. Separate odd and even element of each array into two  odd, even arrays for each.\\nNow find how much increase or decrease is required for each element.\\nLet inc=0 and dcr=0, represent increase and decrease value required.\\n<B> Traverse the even array for both nums and target as well as traverse the odd array for both nums and target. Calculate inc and dcr .</b>\\n\\n<b>Note : inc == dcr</b> //inc will always be equal to dcr as the there will always a way to make both arrays similar(equal).\\n\\n<b> Ans= inc/2 </b>\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        long long in=0,dc=0;\\n        vector<int> num_eve;\\n        vector<int> num_odd;\\n        vector<int> trg_eve;\\n        vector<int> trg_odd;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                num_eve.push_back(nums[i]);\\n            }\\n            else{\\n                num_odd.push_back(nums[i]);\\n            }\\n            \\n            if(target[i]%2==0){\\n                trg_eve.push_back(target[i]);\\n            }\\n            else{\\n                trg_odd.push_back(target[i]);\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<num_eve.size();i++){\\n            if(num_eve[i]>trg_eve[i]){\\n                dc+=num_eve[i]-trg_eve[i];\\n            }\\n            else if(num_eve[i]<trg_eve[i]){\\n                in+=trg_eve[i]-num_eve[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<num_odd.size();i++){\\n            if(num_odd[i]>trg_odd[i]){\\n                dc+=num_odd[i]-trg_odd[i];\\n            }\\n            else if(num_odd[i]<trg_odd[i]){\\n                in+=trg_odd[i]-num_odd[i];\\n            }\\n        }\\n        \\n        long long ans=max(in,dc);\\n        ans=ans/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeSimilar(vector<int>& nums, vector<int>& target) {\\n        \\n        sort(nums.begin(),nums.end());\\n        sort(target.begin(),target.end());\\n        \\n        long long in=0,dc=0;\\n        vector<int> num_eve;\\n        vector<int> num_odd;\\n        vector<int> trg_eve;\\n        vector<int> trg_odd;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                num_eve.push_back(nums[i]);\\n            }\\n            else{\\n                num_odd.push_back(nums[i]);\\n            }\\n            \\n            if(target[i]%2==0){\\n                trg_eve.push_back(target[i]);\\n            }\\n            else{\\n                trg_odd.push_back(target[i]);\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<num_eve.size();i++){\\n            if(num_eve[i]>trg_eve[i]){\\n                dc+=num_eve[i]-trg_eve[i];\\n            }\\n            else if(num_eve[i]<trg_eve[i]){\\n                in+=trg_eve[i]-num_eve[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<num_odd.size();i++){\\n            if(num_odd[i]>trg_odd[i]){\\n                dc+=num_odd[i]-trg_odd[i];\\n            }\\n            else if(num_odd[i]<trg_odd[i]){\\n                in+=trg_odd[i]-num_odd[i];\\n            }\\n        }\\n        \\n        long long ans=max(in,dc);\\n        ans=ans/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735390,
                "title": "p5-js-dynamic-visualization-of-the-solution",
                "content": "Did not solve this one . . . so making a visualization as self-discipline and to remember . . .\\n\\nVery straightforward, I guess no explanation is needed !\\n\\n![image](https://assets.leetcode.com/users/images/5513836a-a734-4e3e-8c8c-5e6619ef814c_1666516499.720374.gif)\\n\\nLive version is [here](https://editor.p5js.org/nitroglycerine/full/KgPDTSXbv)",
                "solutionTags": [],
                "code": "Did not solve this one . . . so making a visualization as self-discipline and to remember . . .\\n\\nVery straightforward, I guess no explanation is needed !\\n\\n![image](https://assets.leetcode.com/users/images/5513836a-a734-4e3e-8c8c-5e6619ef814c_1666516499.720374.gif)\\n\\nLive version is [here](https://editor.p5js.org/nitroglycerine/full/KgPDTSXbv)",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1783435,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "My first hard question . Took nearly 2 hours .... the happiness of me right now\\uD83E\\uDD70\\uD83D\\uDE0D!!\\n"
                    },
                    {
                        "username": "skhan75",
                        "content": "They asked this in Walmart? For real? "
                    },
                    {
                        "username": "bessadam",
                        "content": "Yep, every time you come shopping at the entrance they ask exactly this problem"
                    }
                ]
            },
            {
                "id": 1915293,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "My first hard question . Took nearly 2 hours .... the happiness of me right now\\uD83E\\uDD70\\uD83D\\uDE0D!!\\n"
                    },
                    {
                        "username": "skhan75",
                        "content": "They asked this in Walmart? For real? "
                    },
                    {
                        "username": "bessadam",
                        "content": "Yep, every time you come shopping at the entrance they ask exactly this problem"
                    }
                ]
            }
        ]
    }
]