[
    {
        "title": "Rearrange Array Elements by Sign",
        "question_content": "You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\nYou should rearrange the elements of nums such that the modified array follows the given conditions:\n\n\tEvery consecutive pair of integers have opposite signs.\n\tFor all integers with the same sign, the order in which they were present in nums is preserved.\n\tThe rearranged array begins with a positive integer.\n\nReturn the modified array after rearranging the elements to satisfy the aforementioned conditions.\n&nbsp;\nExample 1:\n\nInput: nums = [3,1,-2,-5,2,-4]\nOutput: [3,-2,1,-5,2,-4]\nExplanation:\nThe positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  \n\nExample 2:\n\nInput: nums = [-1,1]\nOutput: [1,-1]\nExplanation:\n1 is the only positive integer and -1 the only negative integer in nums.\nSo nums is rearranged to [1,-1].\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 2 * 105\n\tnums.length is even\n\t1 <= |nums[i]| <= 105\n\tnums consists of equal number of positive and negative integers.",
        "solutions": [
            {
                "id": 1711413,
                "title": "c-two-pointer-o-n",
                "content": "We know that all positive numbers will be on multiple of 2 indexes(0,2,4..) and negatives will be on odd(1,3,5...) indexes.\\n\\nTime complexity : O(n)\\nSpace Complexity : O(n)\\nNotice that extra array is part of algorithm.\\n\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                ans[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                ans[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                ans[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                ans[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169890,
                "title": "best-c-2-solution-two-pointers-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Two Approaches.\\n\\n1. Solved using Array with Extra Array Space.\\n2. Solved using Array + Two Pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array equal to two times. Where N is size of the array(nums).\\n\\n    Space Complexity: O(N), Array(neg and pos) space.\\n\\n    Solved using Array.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans, neg, pos;\\n        for(auto num : nums){\\n            if(num > 0){\\n                pos.push_back(num);\\n            }\\n            else if(num < 0){\\n                neg.push_back(num);\\n            }\\n        }\\n        for(int i=0; i<neg.size(); i++){\\n            ans.push_back(pos[i]);\\n            ans.push_back(neg[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array only ones. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space. Extra space is only allocated for the Array(ans) of size N, however\\n    the output does not count towards the space complexity.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int positiveElementIndex = 0, negativeElementIndex = 1;\\n\\n        for(auto num : nums){\\n            if(num > 0){\\n                ans[positiveElementIndex] = num;\\n                positiveElementIndex += 2;\\n            }\\n            else if(num < 0){\\n                ans[negativeElementIndex] = num;\\n                negativeElementIndex += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array equal to two times. Where N is size of the array(nums).\\n\\n    Space Complexity: O(N), Array(neg and pos) space.\\n\\n    Solved using Array.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans, neg, pos;\\n        for(auto num : nums){\\n            if(num > 0){\\n                pos.push_back(num);\\n            }\\n            else if(num < 0){\\n                neg.push_back(num);\\n            }\\n        }\\n        for(int i=0; i<neg.size(); i++){\\n            ans.push_back(pos[i]);\\n            ans.push_back(neg[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array only ones. Where N is size of the array(nums).\\n\\n    Space Complexity: O(1), Constant space. Extra space is only allocated for the Array(ans) of size N, however\\n    the output does not count towards the space complexity.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int positiveElementIndex = 0, negativeElementIndex = 1;\\n\\n        for(auto num : nums){\\n            if(num > 0){\\n                ans[positiveElementIndex] = num;\\n                positiveElementIndex += 2;\\n            }\\n            else if(num < 0){\\n                ans[negativeElementIndex] = num;\\n                negativeElementIndex += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724474,
                "title": "python3-easy-to-understand-more-optimized",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        a=[0]*len(nums)\\n        p=0\\n        n=1\\n        for i in nums:\\n            if i>0:\\n                a[p]=i\\n                p+=2\\n            else:\\n                a[n]=i\\n                n+=2\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        a=[0]*len(nums)\\n        p=0\\n        n=1\\n        for i in nums:\\n            if i>0:\\n                a[p]=i\\n                p+=2\\n            else:\\n                a[n]=i\\n                n+=2\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711267,
                "title": "java-simple-o-n",
                "content": "````\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int [] out = new int [nums.length];\\n        int j = 0;\\n        int k = 1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] >= 0){\\n                out[j] = nums[i];\\n                j += 2;\\n            }else {\\n                out[k] = nums[i];\\n                k += 2;\\n            }\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int [] out = new int [nums.length];\\n        int j = 0;\\n        int k = 1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] >= 0){\\n                out[j] = nums[i];\\n                j += 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1711329,
                "title": "two-pointers",
                "content": "We use one pointer to iterate through positive, and the other - through negative numbers.\\n\\nFor each iterator positions, we add a positive-negative pair to the result.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        return [i for t in zip([p for p in nums if p > 0], [n for n in nums if n < 0]) for i in t]\\n```\\n\\n**C++**\\nFor C++, we actually ovestep the pointers so that they point to elements after the ones we need (`n[i - 1], n[j - 1]`).\\n\\nIt makes the code shorter, and we do not need to do `++i, ++j` in our loop. I perhaps would not do it in the production code - but here - why not, just for fun.\\n\\n```cpp\\nvector<int> rearrangeArray(vector<int>& n) {\\n    vector<int> res;\\n    for (int i = 0, j = 0; max(i, j) < n.size(); ) {\\n        while (n[i++] < 0);\\n        while (n[j++] > 0);\\n        res.insert(end(res), {n[i - 1], n[j - 1]});\\n    }\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        return [i for t in zip([p for p in nums if p > 0], [n for n in nums if n < 0]) for i in t]\\n```\n```cpp\\nvector<int> rearrangeArray(vector<int>& n) {\\n    vector<int> res;\\n    for (int i = 0, j = 0; max(i, j) < n.size(); ) {\\n        while (n[i++] < 0);\\n        while (n[j++] > 0);\\n        res.insert(end(res), {n[i - 1], n[j - 1]});\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723009,
                "title": "c-o-n-time-o-n-0-5-space-solution",
                "content": "This approach was inspired by:\\n> Generic Algorithm for 0/1-Sorting\\n> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4547&rep=rep1&type=pdf\\n\\nThe paper proposed an algorithm using O(n) time and O(1) space, but it\\'s too complicated to be implemented here, hence here\\'s my simplified O(n) time O(n^0.5) space solution.\\n\\nFrom a high level of view, this approach divided the original array into chunks of size `sqrt(n)`, stable sort elements in each chunk using `O(sqrt(n))` space,\\n create all negative/negative chunks using a buffer of `O(sqrt(n))` size using the fact that for every two chunks either the sum of the number of negatives or positives in them exceed `chunk_size`, then reorder chunks to be `(PositiveChunk, NegativeChunk, PositiveChunk, NegativeChunk)` with `chunk_cnt = O(sqrt(n))` space using [Cyclic permutation](https://en.wikipedia.org/wiki/Cyclic_permutation) ([See also](https://emre.me/coding-patterns/cyclic-sort/)), and finally interleave elements in consecutive pairs of `(PositiveChunk, NegativeChunk)` to be `Positive, Negative, Positive, Negative, ...`.\\n\\n```\\nclass Solution {\\n// Uncomment/comment the below two lines for logs\\n// #define ENABLE_LOG(...) __VA_ARGS__\\n#define ENABLE_LOG(...)\\n\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        const int chunk_size = (int)(sqrt(nums.size())) / 2 * 2 + 2; // make it always an even number\\n        const int original_n = nums.size();\\n        constexpr int kPadPositive = 100006;\\n        constexpr int kPadNegative = -100006;\\n        // Pad the array to have size of a multiple of 4 * chunk_size\\n        for (int i=0; i<nums.size() % (4 * chunk_size); ++i) {\\n            nums.push_back(i % 2 == 0 ? kPadPositive : kPadNegative);\\n        }\\n        ENABLE_LOG(\\n            cout << \"chunk_size: \" << chunk_size << endl;\\n\\n            cout << \"padded array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        // Denotion:\\n        //   the i-th positive number in original array: P_i.\\n        //   the i-th negative number in original array: N_i\\n        \\n        \\n        // Step 1: Sort each chunk stably so that positive numbers appear before\\n        //   negative numbers\\n        vector<int> chunk_buffer(chunk_size); // stores sorted result\\n        for (int i=0; i < nums.size(); i += chunk_size) {\\n            chunk_buffer.clear();\\n            for (int j=i; j<i+chunk_size; ++j)\\n                if (nums[j] > 0)\\n                    chunk_buffer.push_back(nums[j]);\\n            for (int j=i; j<i+chunk_size; ++j)\\n                if (nums[j] < 0)\\n                    chunk_buffer.push_back(nums[j]);\\n            // Copy chunk_buffer back to nums[i:i+chunk_size]\\n            copy_n(chunk_buffer.cbegin(), chunk_size, nums.begin() + i);\\n        }\\n        ENABLE_LOG(\\n            cout << \"chunk-sorted array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        \\n        // Step 2: Merge every two chunks so that each chunk are either all positive numbers\\n        // or all negative numbers\\n        //\\n        // This is based on the observation that:\\n        // assuming chunk A having m positives followed by n negatives,\\n        // chunk B having p positives followed by q negatives,\\n        // a) if m+p >= chunk_size, we extract chunk_size positives into an all-positive chunk and put the remaining (m+p-chunk_size positives and n+q negatives) into the \"buffer\" chunk\\n        // b) if n+q >= chunk_size, we extract chunk_size negatives into an all-negative chunk and make the remaining (m+p positives and n+q-chunk_size negatives) the \"buffer\" chunk\\n        // Note that in either of the above two cases, the relative order for positive/negative numbers are unchanged\\n        \\n        chunk_buffer = vector<int>{nums.begin(), nums.begin() + chunk_size};\\n        for (int i = chunk_size; i<nums.size(); i+= chunk_size) {\\n            const int m = find_if(chunk_buffer.cbegin(), chunk_buffer.cend(), [](int v) {\\n                return v < 0;\\n            }) - chunk_buffer.cbegin();\\n            const int n = chunk_size - m;\\n            const int p = find_if(nums.cbegin() + i, nums.cbegin() + i + chunk_size, [](int v) {\\n                return v < 0;\\n            }) - (nums.cbegin() + i);\\n            const int q = chunk_size - p;\\n            \\n            if (m + p >= chunk_size) {\\n                // Copy positives to the previous chunk\\n                copy_n(chunk_buffer.cbegin(), m, nums.begin() + i - chunk_size);\\n                copy_n(nums.cbegin() + i, chunk_size - m, nums.begin() + i - chunk_size + m);\\n                vector<int> new_buffer;\\n                // the remaining positives (m+p-chunk_size) from this chunk\\n                copy_n(nums.cbegin() + i + (chunk_size - m),\\n                       p - (chunk_size - m),\\n                       back_inserter(new_buffer));\\n                // the remaining negatives in buffer\\n                copy_n(chunk_buffer.cbegin() + m, n, back_inserter(new_buffer));\\n                // the remaining negatives in this chunk\\n                copy_n(nums.cbegin() + i + p, q, back_inserter(new_buffer));\\n                chunk_buffer = move(new_buffer);\\n            } else {\\n                // Copy negatives to the previous chunk\\n                copy_n(chunk_buffer.cbegin() + m, n, nums.begin() + i - chunk_size);\\n                copy_n(nums.cbegin() + i + p, chunk_size - n, nums.begin() + i - chunk_size + n);\\n                vector<int> new_buffer;\\n                // the remaining positives in buffer\\n                copy_n(chunk_buffer.cbegin(), m, back_inserter(new_buffer));\\n                // the remaining positives in this chunk\\n                copy_n(nums.cbegin() + i, p, back_inserter(new_buffer));\\n                // the remaining negatives from this chunk\\n                copy_n(nums.cbegin() + i + p + chunk_size - n, q - (chunk_size - n),\\n                      back_inserter(new_buffer));\\n                chunk_buffer = move(new_buffer);\\n            }\\n        }\\n        copy_n(chunk_buffer.cbegin(), chunk_size, nums.begin() + nums.size() - chunk_size);\\n        \\n        ENABLE_LOG(\\n            cout << \"homonegeous array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        \\n        // Step 3:\\n        // After the above step, we will have sqrt(N) / 2 all-positive chunks and sqrt(N) / 2 all-negative chunks.\\n        // Their initial chunk location is at (0, 1, 2, ..., sqrt(N))\\n        // We want them to interleave each other, i.e., Positive Chunk1, Negative Chunk 1, Positive Chunk 2, Negative Chunk 2\\n        // which could be achieved via cyclic permutation using an additional array tracking the target location of each chunk\\n        \\n        \\n        // due to above padding, chunk_cnt is always a multiple of 4\\n        const int chunk_cnt = nums.size() / chunk_size;\\n        \\n        vector<int> target(chunk_cnt); // O(sqrt(N))\\n        int positive_chunks = 0, negative_chunks = 0;\\n        for (int i=0; i<chunk_cnt; ++i) {\\n            if (nums[i * chunk_size] > 0)\\n                target[i] = (positive_chunks++) * 2;\\n            else\\n                target[i] = (negative_chunks++) * 2 + 1;\\n        }\\n        for (int i=0; i<chunk_cnt; ++i) {\\n            while (target[i] != i) {\\n                swap_ranges(nums.begin() + i * chunk_size,\\n                            nums.begin() + i * chunk_size + chunk_size,\\n                            nums.begin() + target[i] * chunk_size);\\n                swap(target[target[i]], target[i]);\\n            }\\n        }\\n        ENABLE_LOG(\\n            cout << \"sorted array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        \\n        // Step 4:\\n        // Now we get Positive Chunk1, Negative Chunk 1, Positive Chunk 2, Negative Chunk 2, ...\\n        // For each pair of adjacent (positive, negative) chunks, we can reorder the elements inside \\n        // to make positive and negative numbers interleave each other\\n        vector<int> two_chunk_elements_interleaved; // O(2 * chunk_size) = O(sqrt(N))\\n        for (int i=0; i<nums.size(); i += 2 * chunk_size) {\\n            two_chunk_elements_interleaved.clear();\\n            for (int j=0; j<chunk_size; ++j)\\n            {\\n                two_chunk_elements_interleaved.push_back(nums[i + j]);\\n                two_chunk_elements_interleaved.push_back(nums[i + chunk_size + j]);\\n            }\\n            copy_n(two_chunk_elements_interleaved.cbegin(), 2 * chunk_size, nums.begin() + i);\\n        }\\n        // Remove paddings\\n        nums.resize(original_n);\\n        return nums;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n// Uncomment/comment the below two lines for logs\\n// #define ENABLE_LOG(...) __VA_ARGS__\\n#define ENABLE_LOG(...)\\n\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        const int chunk_size = (int)(sqrt(nums.size())) / 2 * 2 + 2; // make it always an even number\\n        const int original_n = nums.size();\\n        constexpr int kPadPositive = 100006;\\n        constexpr int kPadNegative = -100006;\\n        // Pad the array to have size of a multiple of 4 * chunk_size\\n        for (int i=0; i<nums.size() % (4 * chunk_size); ++i) {\\n            nums.push_back(i % 2 == 0 ? kPadPositive : kPadNegative);\\n        }\\n        ENABLE_LOG(\\n            cout << \"chunk_size: \" << chunk_size << endl;\\n\\n            cout << \"padded array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        // Denotion:\\n        //   the i-th positive number in original array: P_i.\\n        //   the i-th negative number in original array: N_i\\n        \\n        \\n        // Step 1: Sort each chunk stably so that positive numbers appear before\\n        //   negative numbers\\n        vector<int> chunk_buffer(chunk_size); // stores sorted result\\n        for (int i=0; i < nums.size(); i += chunk_size) {\\n            chunk_buffer.clear();\\n            for (int j=i; j<i+chunk_size; ++j)\\n                if (nums[j] > 0)\\n                    chunk_buffer.push_back(nums[j]);\\n            for (int j=i; j<i+chunk_size; ++j)\\n                if (nums[j] < 0)\\n                    chunk_buffer.push_back(nums[j]);\\n            // Copy chunk_buffer back to nums[i:i+chunk_size]\\n            copy_n(chunk_buffer.cbegin(), chunk_size, nums.begin() + i);\\n        }\\n        ENABLE_LOG(\\n            cout << \"chunk-sorted array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        \\n        // Step 2: Merge every two chunks so that each chunk are either all positive numbers\\n        // or all negative numbers\\n        //\\n        // This is based on the observation that:\\n        // assuming chunk A having m positives followed by n negatives,\\n        // chunk B having p positives followed by q negatives,\\n        // a) if m+p >= chunk_size, we extract chunk_size positives into an all-positive chunk and put the remaining (m+p-chunk_size positives and n+q negatives) into the \"buffer\" chunk\\n        // b) if n+q >= chunk_size, we extract chunk_size negatives into an all-negative chunk and make the remaining (m+p positives and n+q-chunk_size negatives) the \"buffer\" chunk\\n        // Note that in either of the above two cases, the relative order for positive/negative numbers are unchanged\\n        \\n        chunk_buffer = vector<int>{nums.begin(), nums.begin() + chunk_size};\\n        for (int i = chunk_size; i<nums.size(); i+= chunk_size) {\\n            const int m = find_if(chunk_buffer.cbegin(), chunk_buffer.cend(), [](int v) {\\n                return v < 0;\\n            }) - chunk_buffer.cbegin();\\n            const int n = chunk_size - m;\\n            const int p = find_if(nums.cbegin() + i, nums.cbegin() + i + chunk_size, [](int v) {\\n                return v < 0;\\n            }) - (nums.cbegin() + i);\\n            const int q = chunk_size - p;\\n            \\n            if (m + p >= chunk_size) {\\n                // Copy positives to the previous chunk\\n                copy_n(chunk_buffer.cbegin(), m, nums.begin() + i - chunk_size);\\n                copy_n(nums.cbegin() + i, chunk_size - m, nums.begin() + i - chunk_size + m);\\n                vector<int> new_buffer;\\n                // the remaining positives (m+p-chunk_size) from this chunk\\n                copy_n(nums.cbegin() + i + (chunk_size - m),\\n                       p - (chunk_size - m),\\n                       back_inserter(new_buffer));\\n                // the remaining negatives in buffer\\n                copy_n(chunk_buffer.cbegin() + m, n, back_inserter(new_buffer));\\n                // the remaining negatives in this chunk\\n                copy_n(nums.cbegin() + i + p, q, back_inserter(new_buffer));\\n                chunk_buffer = move(new_buffer);\\n            } else {\\n                // Copy negatives to the previous chunk\\n                copy_n(chunk_buffer.cbegin() + m, n, nums.begin() + i - chunk_size);\\n                copy_n(nums.cbegin() + i + p, chunk_size - n, nums.begin() + i - chunk_size + n);\\n                vector<int> new_buffer;\\n                // the remaining positives in buffer\\n                copy_n(chunk_buffer.cbegin(), m, back_inserter(new_buffer));\\n                // the remaining positives in this chunk\\n                copy_n(nums.cbegin() + i, p, back_inserter(new_buffer));\\n                // the remaining negatives from this chunk\\n                copy_n(nums.cbegin() + i + p + chunk_size - n, q - (chunk_size - n),\\n                      back_inserter(new_buffer));\\n                chunk_buffer = move(new_buffer);\\n            }\\n        }\\n        copy_n(chunk_buffer.cbegin(), chunk_size, nums.begin() + nums.size() - chunk_size);\\n        \\n        ENABLE_LOG(\\n            cout << \"homonegeous array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        \\n        // Step 3:\\n        // After the above step, we will have sqrt(N) / 2 all-positive chunks and sqrt(N) / 2 all-negative chunks.\\n        // Their initial chunk location is at (0, 1, 2, ..., sqrt(N))\\n        // We want them to interleave each other, i.e., Positive Chunk1, Negative Chunk 1, Positive Chunk 2, Negative Chunk 2\\n        // which could be achieved via cyclic permutation using an additional array tracking the target location of each chunk\\n        \\n        \\n        // due to above padding, chunk_cnt is always a multiple of 4\\n        const int chunk_cnt = nums.size() / chunk_size;\\n        \\n        vector<int> target(chunk_cnt); // O(sqrt(N))\\n        int positive_chunks = 0, negative_chunks = 0;\\n        for (int i=0; i<chunk_cnt; ++i) {\\n            if (nums[i * chunk_size] > 0)\\n                target[i] = (positive_chunks++) * 2;\\n            else\\n                target[i] = (negative_chunks++) * 2 + 1;\\n        }\\n        for (int i=0; i<chunk_cnt; ++i) {\\n            while (target[i] != i) {\\n                swap_ranges(nums.begin() + i * chunk_size,\\n                            nums.begin() + i * chunk_size + chunk_size,\\n                            nums.begin() + target[i] * chunk_size);\\n                swap(target[target[i]], target[i]);\\n            }\\n        }\\n        ENABLE_LOG(\\n            cout << \"sorted array: \";\\n            for (int v: nums) cout << v << \" \"; cout << endl;\\n        )\\n        \\n        // Step 4:\\n        // Now we get Positive Chunk1, Negative Chunk 1, Positive Chunk 2, Negative Chunk 2, ...\\n        // For each pair of adjacent (positive, negative) chunks, we can reorder the elements inside \\n        // to make positive and negative numbers interleave each other\\n        vector<int> two_chunk_elements_interleaved; // O(2 * chunk_size) = O(sqrt(N))\\n        for (int i=0; i<nums.size(); i += 2 * chunk_size) {\\n            two_chunk_elements_interleaved.clear();\\n            for (int j=0; j<chunk_size; ++j)\\n            {\\n                two_chunk_elements_interleaved.push_back(nums[i + j]);\\n                two_chunk_elements_interleaved.push_back(nums[i + chunk_size + j]);\\n            }\\n            copy_n(two_chunk_elements_interleaved.cbegin(), 2 * chunk_size, nums.begin() + i);\\n        }\\n        // Remove paddings\\n        nums.resize(original_n);\\n        return nums;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2257094,
                "title": "pyhton-faster-than-95-3-different-approaches-basics",
                "content": "IF THIS HELP U KINDLY UPVOTE THIS TO HELP OTHERS TO GET THIS SOLUTION\\nIF U DONT GET IT KINDLY COMMENT AND FEEL FREE TO ASK\\nAND CORRECT MEIF I AM WRONG\\n\\n\\nFIRST APPROACH\\n```\\n        a,b=list(filter(lambda x: x<0,nums)),list(filter(lambda x: x>0,nums))\\n        result=[]\\n        for i in range(len(a)):\\n          result.append(b[i])\\n          result.append(a[i])\\n        return (result)\\n\\n```\\nSECOND APPROACH AND BETTER ONE\\n```\\n        result = []\\n        for a,b in zip([n for n in nums if n > 0], [n for n in nums if n < 0]):\\n            result += [a,b]\\n        return result\\n```\\nTHIRD APPROACH\\n```\\n        if not nums:\\n            return nums\\n        \\n        newArray = [0] * len(nums)\\n        i, j = 0, 1\\n        for num in nums:\\n            if num > 0:\\n                newArray[i] = num\\n                i += 2\\n            else:\\n                newArray[j] = num\\n                j += 2\\n                \\n        return newArray\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        a,b=list(filter(lambda x: x<0,nums)),list(filter(lambda x: x>0,nums))\\n        result=[]\\n        for i in range(len(a)):\\n          result.append(b[i])\\n          result.append(a[i])\\n        return (result)\\n\\n```\n```\\n        result = []\\n        for a,b in zip([n for n in nums if n > 0], [n for n in nums if n < 0]):\\n            result += [a,b]\\n        return result\\n```\n```\\n        if not nums:\\n            return nums\\n        \\n        newArray = [0] * len(nums)\\n        i, j = 0, 1\\n        for num in nums:\\n            if num > 0:\\n                newArray[i] = num\\n                i += 2\\n            else:\\n                newArray[j] = num\\n                j += 2\\n                \\n        return newArray\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678355,
                "title": "o-1-space-complexity-explained",
                "content": "# Note before\\nThis solution is suboptimal in time complexity (Beats only 5%), so I highly advice to use it simply as an inspiration rather than final solution.\\n\\n# Intuition\\nWe have to check whether the number at current position has the right sign, and if it\\'s not, we need to find the nearest number with opposite index and put it before the current number.\\n\\n# Approach\\nI\\'ll try to explain as detailed as possible. Feel free to scroll down till the end of solution if you just want to read the full code.\\n\\n## Initial condition\\n\\nLet\\'s use [3, 11, -47, 29, 18, -4, -26, -47] as an example.\\n\\n![1.png](https://assets.leetcode.com/users/images/f45608ae-9adb-4b70-b90c-ad699aba8730_1665266492.251026.png)\\n\\nWe need to iterate through all the items\\n```\\nfor (i in nums.indices) {\\n    //...\\n}\\n```\\n\\n## Checking if number at the right position\\nWe start with iterating through each number and checking whether it\\'s at the right index or not.\\nThere might be two cases:\\n1. Current index is even and the number is negative\\n2. Current index is odd and the number is positive\\n\\n```\\nval isNegativeAtWrongPlace = i % 2 == 0 && nums[i] < 0\\nval isPositiveAtWrongPlace = i % 2 == 1 && nums[i] > 0\\n```\\n\\nFirst item at the wrong position is **11**.\\n\\nSo now that we found that there\\'s a number at a wrong position, we have to place the closest number with opposite sign before it.\\n\\n## Finding the closest number with opposite sign\\nBut first, we have to find it.\\nJust iterate from current index until we find the first suitable number.\\n```\\nif (isNegativeAtWrongPlace || isPositiveAtWrongPlace) {\\n    var nearestOppositeIndex = i\\n\\n    if (isNegativeAtWrongPlace) {\\n        while (nums[nearestOppositeIndex] < 0) {\\n            nearestOppositeIndex++\\n        }\\n    } else {\\n        while (nums[nearestOppositeIndex] >= 0) {\\n            nearestOppositeIndex++\\n        }\\n    }\\n}\\n```\\nFirst number with opposite sign is **-47**.\\nNow we have both the number that is at the wrong position and the number we have to place before it.\\n\\n![2.png](https://assets.leetcode.com/users/images/cd623f59-9eed-4621-876b-6033a21b4250_1665267550.2546885.png)\\n\\n## Moving opposite sign number before the target\\nWhan we want to do is somehow move **-47** before **11**, so both numbers would be at the correct positions.\\n\\n![3.png](https://assets.leetcode.com/users/images/d99def03-6df2-4e3e-b73d-d0ad12e7e93b_1665267707.7531343.png)\\n\\nTo achieve this, all we have to do is save the opposite sign number in temp variable, then shift all items between two indices one time right.\\n```\\nval nearestOpposite = nums[nearestOppositeIndex]\\n```\\n\\n## Shifting numbers right\\nSince we already saved opposite number, we don\\'t need to keep it in array during the shift. So, just iterate from `nearestOppositeIndex` down to `i+1` (index that is next to the element with wrong sign) and assign the value of previous item (i.e. `num[j] = num[j-1]`).\\n\\n```\\nfor (j in nearestOppositeIndex downTo i + 1) {\\n    nums[j] = nums[j - 1]\\n}\\n```\\nNow the array looks like this:\\n![4.png](https://assets.leetcode.com/users/images/83dd2ace-3f22-41e7-9a1f-11d5ee9882a4_1665268311.6663485.png)\\n\\n## Placing opposite sign number at the right place\\nNow all we need to do is place opposite sign number (that we store in temp variable) at the index of the original number that had wrong sign.\\n\\n```\\nnums[i] = nearestOpposite\\n```\\n\\nAnd after this the array looks like this:\\n![5.png](https://assets.leetcode.com/users/images/d044ad72-641b-4bb5-b78a-27621c84c56b_1665268552.00133.png)\\n\\n## Rest of the example\\nI don\\'t think repeating each step in depth is necessary, still there\\'s an interesting situation where we have three positive and then three negative numbers in a row. Let\\'s just visualize the rest of this approach.\\n\\n![rest.png](https://assets.leetcode.com/users/images/cae199a0-a7da-4aa7-b533-64f6ba323a55_1665269138.9656177.png)\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    fun rearrangeArray(nums: IntArray): IntArray {\\n        for (i in nums.indices) {\\n            val isNegativeAtWrongPlace = i % 2 == 0 && nums[i] < 0\\n            val isPositiveAtWrongPlace = i % 2 == 1 && nums[i] > 0\\n\\n            if (isNegativeAtWrongPlace || isPositiveAtWrongPlace) {\\n                var nearestOppositeIndex = i\\n\\n                if (isNegativeAtWrongPlace) {\\n                    while (nums[nearestOppositeIndex] < 0) {\\n                        nearestOppositeIndex++\\n                    }\\n                } else {\\n                    while (nums[nearestOppositeIndex] >= 0) {\\n                        nearestOppositeIndex++\\n                    }\\n                }\\n\\n                val temp = nums[nearestOppositeIndex]\\n\\n                for (j in nearestOppositeIndex downTo i + 1) {\\n                    nums[j] = nums[j - 1]\\n                }\\n\\n                nums[i] = temp\\n            }\\n        }\\n\\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfor (i in nums.indices) {\\n    //...\\n}\\n```\n```\\nval isNegativeAtWrongPlace = i % 2 == 0 && nums[i] < 0\\nval isPositiveAtWrongPlace = i % 2 == 1 && nums[i] > 0\\n```\n```\\nif (isNegativeAtWrongPlace || isPositiveAtWrongPlace) {\\n    var nearestOppositeIndex = i\\n\\n    if (isNegativeAtWrongPlace) {\\n        while (nums[nearestOppositeIndex] < 0) {\\n            nearestOppositeIndex++\\n        }\\n    } else {\\n        while (nums[nearestOppositeIndex] >= 0) {\\n            nearestOppositeIndex++\\n        }\\n    }\\n}\\n```\n```\\nval nearestOpposite = nums[nearestOppositeIndex]\\n```\n```\\nfor (j in nearestOppositeIndex downTo i + 1) {\\n    nums[j] = nums[j - 1]\\n}\\n```\n```\\nnums[i] = nearestOpposite\\n```\n```\\nclass Solution {\\n\\n    fun rearrangeArray(nums: IntArray): IntArray {\\n        for (i in nums.indices) {\\n            val isNegativeAtWrongPlace = i % 2 == 0 && nums[i] < 0\\n            val isPositiveAtWrongPlace = i % 2 == 1 && nums[i] > 0\\n\\n            if (isNegativeAtWrongPlace || isPositiveAtWrongPlace) {\\n                var nearestOppositeIndex = i\\n\\n                if (isNegativeAtWrongPlace) {\\n                    while (nums[nearestOppositeIndex] < 0) {\\n                        nearestOppositeIndex++\\n                    }\\n                } else {\\n                    while (nums[nearestOppositeIndex] >= 0) {\\n                        nearestOppositeIndex++\\n                    }\\n                }\\n\\n                val temp = nums[nearestOppositeIndex]\\n\\n                for (j in nearestOppositeIndex downTo i + 1) {\\n                    nums[j] = nums[j - 1]\\n                }\\n\\n                nums[i] = temp\\n            }\\n        }\\n\\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840164,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post. If there are any questions, kindly leave a comment below. Thank you and happy hacking!\\n```\\nvar rearrangeArray = function (nums) {\\n    let positiveNums = nums.filter(x => x > 0)\\n    let negativeNums = nums.filter(x => x < 0)\\n    let result = []\\n\\n    for (let i = 0; i < nums.length / 2; i++) {\\n        result.push(positiveNums[i], negativeNums[i])\\n    }\\n\\n    return result\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rearrangeArray = function (nums) {\\n    let positiveNums = nums.filter(x => x > 0)\\n    let negativeNums = nums.filter(x => x < 0)\\n    let result = []\\n\\n    for (let i = 0; i < nums.length / 2; i++) {\\n        result.push(positiveNums[i], negativeNums[i])\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226695,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] res = new int[n];\\n        int positive=0, negative=1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0){\\n                res[positive]=nums[i];\\n                positive += 2;\\n            }\\n            else{\\n                res[negative]=nums[i];\\n                negative += 2;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] res = new int[n];\\n        int positive=0, negative=1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0){\\n                res[positive]=nums[i];\\n                positive += 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1711407,
                "title": "c-simple-two-pointers-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> rearrangeArray(vector<int>& nums) {\\n\\t\\t\\tvector<int> res(nums.size(), 0);\\n\\t\\t\\tint pi = 0, ni = 1;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tif(nums[i] > 0){\\n\\t\\t\\t\\t\\tres[pi] = nums[i];\\n\\t\\t\\t\\t\\tpi += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tres[ni] = nums[i];\\n\\t\\t\\t\\t\\tni += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> rearrangeArray(vector<int>& nums) {\\n\\t\\t\\tvector<int> res(nums.size(), 0);\\n\\t\\t\\tint pi = 0, ni = 1;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t\\tif(nums[i] > 0){\\n\\t\\t\\t\\t\\tres[pi] = nums[i];\\n\\t\\t\\t\\t\\tpi += 2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3437580,
                "title": "c-easy-approach-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  Created two vectors. Pos(for storing positive number) and Neg(for storing negative numbers). Inserted positive elements into pos and negative into neg. Since, the first element should be positive so we will first push from pos then from neg in the same for loop.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans;\\n        // For storing positive and negative numbers\\n\\n        vector<int> pos;\\n        vector<int> neg;\\n        for(auto i : nums)\\n        {\\n            // Storing postive and negative numbers into pos and neg.\\n            if(i > 0) pos.push_back(i);\\n            if(i < 0) neg.push_back(i);\\n        }\\n\\n        // We can run the loop for pos.size() instead of neg.size()\\n        // as well because number of positive element is equal to \\n        // number of negative elements.\\n\\n        for(int i = 0 ; i < neg.size() ; i++)\\n        {\\n            ans.push_back(pos[i]);\\n            ans.push_back(neg[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans;\\n        // For storing positive and negative numbers\\n\\n        vector<int> pos;\\n        vector<int> neg;\\n        for(auto i : nums)\\n        {\\n            // Storing postive and negative numbers into pos and neg.\\n            if(i > 0) pos.push_back(i);\\n            if(i < 0) neg.push_back(i);\\n        }\\n\\n        // We can run the loop for pos.size() instead of neg.size()\\n        // as well because number of positive element is equal to \\n        // number of negative elements.\\n\\n        for(int i = 0 ; i < neg.size() ; i++)\\n        {\\n            ans.push_back(pos[i]);\\n            ans.push_back(neg[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760135,
                "title": "python-solution",
                "content": "In this solution we don\\'t have to think too much , we just have to place those values accordingly as told in the ques , that is as per their sign change and without tempering their orders.\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        l1=[0]*len(nums)\\n        a=1\\n        b=0\\n        for i in nums:\\n            if \"-\" in str(i):\\n                l1[a]=i\\n                a+=2\\n            else:\\n                l1[b]=i\\n                b+=2\\n        \\n        return(l1)\\n```\\nIf u understood the code then plz...UPVOTE....thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        l1=[0]*len(nums)\\n        a=1\\n        b=0\\n        for i in nums:\\n            if \"-\" in str(i):\\n                l1[a]=i\\n                a+=2\\n            else:\\n                l1[b]=i\\n                b+=2\\n        \\n        return(l1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711600,
                "title": "javascript-in-place-solution-o-1-space",
                "content": "```\\nvar rearrangeArray = function (nums) {\\n  let n = nums.length;\\n  let pos = 0;\\n  let neg = 0;\\n  let cur = -1; \\n  while (pos < n && nums[pos] < 0) pos++;\\n  while (neg < n && nums[neg] > 0) neg++;\\n  for (let i = 0; i < n; i++) {\\n    cur = cur === -1 ? 1 : -1;\\n    if (cur === 1 && nums[i] > 0) {\\n      pos++;\\n      while (pos < n && nums[pos] < 0) pos++;\\n      continue;\\n    }\\n    if (cur === -1 && nums[i] < 0) {\\n      neg++; \\n      while (neg < n && nums[neg] > 0) neg++;\\n      continue;\\n    }\\n\\n    let index = pos === i ? neg : pos;\\n    let tmp = nums[index];\\n    for (let k = index; k > i; k--) {\\n      nums[k] = nums[k - 1];\\n    }\\n    nums[i] = tmp;\\n\\n    neg = i + 1;\\n    pos = i + 1;\\n    while (neg < n && nums[neg] > 0) neg++;\\n    while (pos < n && nums[pos] < 0) pos++;\\n  }\\n  return nums;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar rearrangeArray = function (nums) {\\n  let n = nums.length;\\n  let pos = 0;\\n  let neg = 0;\\n  let cur = -1; \\n  while (pos < n && nums[pos] < 0) pos++;\\n  while (neg < n && nums[neg] > 0) neg++;\\n  for (let i = 0; i < n; i++) {\\n    cur = cur === -1 ? 1 : -1;\\n    if (cur === 1 && nums[i] > 0) {\\n      pos++;\\n      while (pos < n && nums[pos] < 0) pos++;\\n      continue;\\n    }\\n    if (cur === -1 && nums[i] < 0) {\\n      neg++; \\n      while (neg < n && nums[neg] > 0) neg++;\\n      continue;\\n    }\\n\\n    let index = pos === i ? neg : pos;\\n    let tmp = nums[index];\\n    for (let k = index; k > i; k--) {\\n      nums[k] = nums[k - 1];\\n    }\\n    nums[i] = tmp;\\n\\n    neg = i + 1;\\n    pos = i + 1;\\n    while (neg < n && nums[neg] > 0) neg++;\\n    while (pos < n && nums[pos] < 0) pos++;\\n  }\\n  return nums;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3676898,
                "title": "o-n-solution-beginner-friendly-beats-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int p = 0;\\n        int n = 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > 0) {\\n                arr[p] = nums[i];\\n                p += 2;\\n            }\\n            else {\\n                arr[n] = nums[i];\\n                n += 2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int p = 0;\\n        int n = 1;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] > 0) {\\n                arr[p] = nums[i];\\n                p += 2;\\n            }\\n            else {\\n                arr[n] = nums[i];\\n                n += 2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839787,
                "title": "time-o-n-space-o-1-tricky-yes-cheat-maybe-c",
                "content": "I know that many coders want to ask this question:\\n\\n**Is there a solution that can achieve O(n)-time-O(1)-space complexity?**\\n\\nAcademically this problem can be reduced to **stable in-place 0-1 sorting**. However, that\\'s too difficult and in general case, O(n)-time and O(1)-space can\\'t be achieved simultaneously.\\n\\nLuckily, after carefully observing the constraint of this problem, I found a rather **tricky way** that can achieve O(n)-time-O(1)-space solution in C++. That means, in my solution there will be no other array-like variables.\\n\\n# A simpler version of this problem\\n\\nSay, if we have O(n/2) extra space, how can we achieve the goal (positive and negative numbers appear in an interleaving manner, while keeping the original order)?\\n\\nIt can be simple: \\n\\n1. we can scan the array and store all negative numbers in this O(n/2) extra space (negative numbers occupy exactly half of the array ```nums```), and we know these negative numbers keep their relative orders. \\n2. Move all positive numbers to their targeted positions. It can be done in two scans: firstly from left to right, moving all positive numbers to the first half of the array ```nums```; then secondly from right to left, put each positive number to position ```n-2```, ```n-4```,```...```,```2```,```0```.\\n3. Fill the vacant places  in ```nums``` with negative numbers from the O(n/2) extra space.\\n\\n# Where does that O(n/2) extra space come from?\\n\\nLook at the constraint of this problem: each number will be in the range of ```[-1e5, +1e5]```. And we know ```2^17 < 2e5 < 2^18```, that means we need **18** binary bits to represent a number in array ```nums```. Nevertheless, in C++, ```nums``` has the type of ```vector<int>```, meaning each number has **32** bits. We can not waste the unused **14** bits! Luckily, to get O(n/2) extra spaces, we need only **9** extra bits for each number.\\n\\n# Solution\\n```\\nvector<int> rearrangeArray(vector<int>& nums)\\n{\\n    int n = (int)nums.size();\\n    const int L = 9;\\n    const int H = L * 2;\\n    const int mskL = (1 << L) - 1;\\n    const int mskH = (1 << H) - 1;\\n    const int msk = mskL << H;\\n    \\n    const int ZERO = 1e5;\\n    for(int i = 0; i < n; i++) nums[i] += ZERO;\\n    int c = 0;\\n    for(int i = 0; i < n; i++) if((nums[i] & mskH) < ZERO)\\n    {\\n        nums[c] |= (nums[i] & mskL) << H;\\n        nums[c + 1] |= ((nums[i] >> L) & mskL) << H;\\n        c += 2;\\n    }\\n    c = 0;\\n    for(int i = 0; i < n; i++) if((nums[i] & mskH) > ZERO)\\n    {\\n        nums[c] = (nums[c] & msk) + (nums[i] & mskH);\\n        c++;\\n    }\\n    c = n / 2 - 1;\\n    for(int i = n - 2; i >= 0; i -= 2)\\n        nums[i] = (nums[i] & msk) + (nums[c--] & mskH);\\n    for(int i = 1; i < n; i += 2)\\n        nums[i] = (nums[i - 1] >> H) + ((nums[i] >> H) << L);\\n        \\n    for(int i = 0; i < n; i++) nums[i] = (nums[i] & mskH) - ZERO;\\n    return nums;\\n}\\n```\\n\\nOnce you know how to solve the simpler version by O(n/2) extra space, and how to store a negative number in two numbers (each storing 9 bits), this tricky solution can work naturally!\\n\\nIt\\'s a bit tricky and even \"cheat\" for O(1) space. We learn from this problem that we should make full use of the space given by problem itself!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```nums```\n```nums```\n```n-2```\n```n-4```\n```...```\n```2```\n```0```\n```nums```\n```[-1e5, +1e5]```\n```2^17 < 2e5 < 2^18```\n```nums```\n```nums```\n```vector<int>```\n```\\nvector<int> rearrangeArray(vector<int>& nums)\\n{\\n    int n = (int)nums.size();\\n    const int L = 9;\\n    const int H = L * 2;\\n    const int mskL = (1 << L) - 1;\\n    const int mskH = (1 << H) - 1;\\n    const int msk = mskL << H;\\n    \\n    const int ZERO = 1e5;\\n    for(int i = 0; i < n; i++) nums[i] += ZERO;\\n    int c = 0;\\n    for(int i = 0; i < n; i++) if((nums[i] & mskH) < ZERO)\\n    {\\n        nums[c] |= (nums[i] & mskL) << H;\\n        nums[c + 1] |= ((nums[i] >> L) & mskL) << H;\\n        c += 2;\\n    }\\n    c = 0;\\n    for(int i = 0; i < n; i++) if((nums[i] & mskH) > ZERO)\\n    {\\n        nums[c] = (nums[c] & msk) + (nums[i] & mskH);\\n        c++;\\n    }\\n    c = n / 2 - 1;\\n    for(int i = n - 2; i >= 0; i -= 2)\\n        nums[i] = (nums[i] & msk) + (nums[c--] & mskH);\\n    for(int i = 1; i < n; i += 2)\\n        nums[i] = (nums[i - 1] >> H) + ((nums[i] >> H) << L);\\n        \\n    for(int i = 0; i < n; i++) nums[i] = (nums[i] & mskH) - ZERO;\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901780,
                "title": "two-pointers-on-js-ts",
                "content": "# Approach\\n- Using two pointers: for negative and positive indexes\\n- Iterate over `nums` and push current value to corresponding index\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```typescript []\\nfunction rearrangeArray(nums: number[]): number[] {\\n    const result: number[] = [];\\n    const index = {pos: 0, neg: 1};\\n\\n    for (const num of nums) {\\n        const sign = num >= 0 ? \\'pos\\' : \\'neg\\';\\n\\n        result[index[sign]] = num;\\n        index[sign] += 2;\\n    }\\n    return result;\\n}\\n```\\n\\n```javascript []\\nfunction rearrangeArray(nums) {\\n    const result = [];\\n    const index = {pos: 0, neg: 1};\\n\\n    for (const num of nums) {\\n        const sign = num >= 0 ? \\'pos\\' : \\'neg\\';\\n\\n        result[index[sign]] = num;\\n        index[sign] += 2;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```typescript []\\nfunction rearrangeArray(nums: number[]): number[] {\\n    const result: number[] = [];\\n    const index = {pos: 0, neg: 1};\\n\\n    for (const num of nums) {\\n        const sign = num >= 0 ? \\'pos\\' : \\'neg\\';\\n\\n        result[index[sign]] = num;\\n        index[sign] += 2;\\n    }\\n    return result;\\n}\\n```\n```javascript []\\nfunction rearrangeArray(nums) {\\n    const result = [];\\n    const index = {pos: 0, neg: 1};\\n\\n    for (const num of nums) {\\n        const sign = num >= 0 ? \\'pos\\' : \\'neg\\';\\n\\n        result[index[sign]] = num;\\n        index[sign] += 2;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1718212,
                "title": "java-one-pass-solution",
                "content": "if you like it pls upvote\\n\\nJAVA\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        int resIdx = 0;\\n        int posIdx = -1;\\n        int minusIdx = -1;\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(i % 2 == 0){\\n                posIdx++;\\n                while(nums[posIdx] <0 )posIdx++;\\n                res[resIdx++] = nums[posIdx]; \\n            }\\n            else{\\n                minusIdx++;\\n                while(nums[minusIdx] > 0 )minusIdx++;\\n                res[resIdx++] = nums[minusIdx]; \\n            }\\n        }\\n\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        int resIdx = 0;\\n        int posIdx = -1;\\n        int minusIdx = -1;\\n\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(i % 2 == 0){\\n                posIdx++;\\n                while(nums[posIdx] <0 )posIdx++;\\n                res[resIdx++] = nums[posIdx]; \\n            }\\n            else{\\n                minusIdx++;\\n                while(nums[minusIdx] > 0 )minusIdx++;\\n                res[resIdx++] = nums[minusIdx]; \\n            }\\n        }\\n\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713692,
                "title": "python3-runtime-o-n",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        x,y = 0,1\\n        ans=[]\\n        for i in range(len(nums)):\\n            ans.append(0)\\n        for i in nums:\\n            if i>=0:\\n                ans[x] = i\\n                x+=2\\n            else:\\n                ans[y] = i\\n                y+=2   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        x,y = 0,1\\n        ans=[]\\n        for i in range(len(nums)):\\n            ans.append(0)\\n        for i in nums:\\n            if i>=0:\\n                ans[x] = i\\n                x+=2\\n            else:\\n                ans[y] = i\\n                y+=2   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941044,
                "title": "superb-logic-two-approaches",
                "content": "# Brute Space approach\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos=[]\\n        neg=[]\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        ans=[]\\n        for i,j in zip(pos,neg):\\n            ans.append(i)\\n            ans.append(j)\\n        return ans\\n  ```\\n  # Space Optimization\\n  ```\\n  class Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        ans=[0]*n\\n        posindex=0\\n        negindex=1\\n        for i in nums:\\n            if i<0:\\n                ans[negindex]=i\\n                negindex+=2\\n            else:\\n                ans[posindex]=i\\n                posindex+=2\\n        return ans\\n  ```\\n  # please upvote me it would encourage me alot\\n\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos=[]\\n        neg=[]\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        ans=[]\\n        for i,j in zip(pos,neg):\\n            ans.append(i)\\n            ans.append(j)\\n        return ans\\n  ```\n```\\n  class Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        ans=[0]*n\\n        posindex=0\\n        negindex=1\\n        for i in nums:\\n            if i<0:\\n                ans[negindex]=i\\n                negindex+=2\\n            else:\\n                ans[posindex]=i\\n                posindex+=2\\n        return ans\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3089983,
                "title": "best-o-n-solution",
                "content": "# Approach\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            if ((i % 2 == 0 && nums[i] > 0) || (i % 2 != 0 && nums[i] < 0))\\n                continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if ((nums[i] > 0 && nums[j] < 0) || (nums[i] < 0 && nums[j] > 0)) {\\n                    swap (nums[i], nums[j]);\\n                    break;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n# Approach\\nBetter Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> Two Traversal\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int N = nums.size();\\n        vector <int> pos, neg;\\n        for (int i = 0; i < N; i++) {\\n            if (nums[i] > 0)\\n                pos.push_back(nums[i]);\\n            if (nums[i] < 0)\\n                neg.push_back(nums[i]);    \\n        }\\n        int m = 0, n = 0;\\n        for (int j = 0; j < N; j++) {\\n            if (j % 2 == 0) {\\n                nums[j] = pos[m];\\n                m++;\\n            }\\n            if (j % 2 != 0) {\\n                nums[j] = neg[n];\\n                n++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n# Approach\\nBest Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> One Traversal\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1;\\n        vector <int> ans (n, 0);\\n        for (int k = 0; k < n; k++) {\\n            if (nums[k] > 0) {\\n                ans[i] = nums[k];\\n                i = i + 2;\\n            }\\n            if (nums[k] < 0) {\\n                ans[j] = nums[k];\\n                j = j + 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            if ((i % 2 == 0 && nums[i] > 0) || (i % 2 != 0 && nums[i] < 0))\\n                continue;\\n            for (int j = i + 1; j < n; j++) {\\n                if ((nums[i] > 0 && nums[j] < 0) || (nums[i] < 0 && nums[j] > 0)) {\\n                    swap (nums[i], nums[j]);\\n                    break;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int N = nums.size();\\n        vector <int> pos, neg;\\n        for (int i = 0; i < N; i++) {\\n            if (nums[i] > 0)\\n                pos.push_back(nums[i]);\\n            if (nums[i] < 0)\\n                neg.push_back(nums[i]);    \\n        }\\n        int m = 0, n = 0;\\n        for (int j = 0; j < N; j++) {\\n            if (j % 2 == 0) {\\n                nums[j] = pos[m];\\n                m++;\\n            }\\n            if (j % 2 != 0) {\\n                nums[j] = neg[n];\\n                n++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1;\\n        vector <int> ans (n, 0);\\n        for (int k = 0; k < n; k++) {\\n            if (nums[k] > 0) {\\n                ans[i] = nums[k];\\n                i = i + 2;\\n            }\\n            if (nums[k] < 0) {\\n                ans[j] = nums[k];\\n                j = j + 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861129,
                "title": "beats-98-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        p_numbers = [num for num in nums if num >= 0]\\n        n_numbers = [num for num in nums if num < 0]\\n        result = []\\n        for p_num, n_num in zip(p_numbers, n_numbers):\\n            result += [p_num, n_num]\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        p_numbers = [num for num in nums if num >= 0]\\n        n_numbers = [num for num in nums if num < 0]\\n        result = []\\n        for p_num, n_num in zip(p_numbers, n_numbers):\\n            result += [p_num, n_num]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468396,
                "title": "python-easy-solution",
                "content": "```\\ndef rearrangeArray(self, nums: List[int]) -> List[int]: # nums = [3,1,-2,-5,2,-4]\\n        pos_arr = [num for num in nums if num > 0] # [3, 1, 2]\\n        neg_arr = [num for num in nums if num < 0] # [-2, -5, -4]\\n        output = list()\\n        for i in range(len(pos_arr)):\\n            output.append(pos_arr[i])\\n            output.append(neg_arr[i])\\n        return output # [3,-2,1,-5,2,-4]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef rearrangeArray(self, nums: List[int]) -> List[int]: # nums = [3,1,-2,-5,2,-4]\\n        pos_arr = [num for num in nums if num > 0] # [3, 1, 2]\\n        neg_arr = [num for num in nums if num < 0] # [-2, -5, -4]\\n        output = list()\\n        for i in range(len(pos_arr)):\\n            output.append(pos_arr[i])\\n            output.append(neg_arr[i])\\n        return output # [3,-2,1,-5,2,-4]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2366170,
                "title": "c-6-lines-code",
                "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        vector<int>ans(nums.size(),0);\\n        \\n        int idx1 = -2, idx2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > 0) ans[idx1 += 2] = nums[i];\\n            else ans[idx2 += 2] = nums[i]; \\n        }        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        vector<int>ans(nums.size(),0);\\n        \\n        int idx1 = -2, idx2 = -1;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] > 0) ans[idx1 += 2] = nums[i];\\n            else ans[idx2 += 2] = nums[i]; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1729673,
                "title": "4-solutions",
                "content": "**Auxillary space/two pointers**\\n**time: `O(N)`; space: `O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/820ca5bf-f52d-41a2-b4c6-905b4d76a470_1643584779.924888.png)\\n\\n```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n\\tvector<int> out(size(n));\\n\\tfor(int i{}, j{}, k{}; k<size(n); )\\n\\t{\\n\\t\\tfor( ; n[i]<0; ++i);\\n\\t\\tfor( ; n[j]>0; ++j);\\n\\t\\tout[k++]=n[i++];\\n\\t\\tout[k++]=n[j++];    \\n\\t}                \\n\\treturn out; \\n}\\n```\\n**Insertion sort (TLE)**\\n**time: `O(N^2)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/dd4078e5-8f1d-4ebb-8f27-4d8686f90a10_1643585367.4899266.png)\\n\\n```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n\\tfor(int i{}, j{}, k{}, t{}; k<size(n); ++i, ++j)\\n\\t{\\n\\t\\tfor( ; n[i]<0; ++i);\\n\\t\\tt = n[i];\\n\\t\\tfor(int x{i}; x>k; n[x]=n[x-1], --x);\\n\\t\\tn[k++] = t;\\n\\n\\t\\tfor( ; n[j]>0; ++j);\\n\\t\\tt = n[j];\\n\\t\\tfor(int y{j}; y>k; n[y]=n[y-1], --y);\\n\\t\\tn[k++] = t;           \\n\\t}\\n\\treturn n; \\n}\\n```\\n**`stable_partition`+permutation cycles**\\nEither **time: `O(NlogN)`; space: `O(1)`** or **time: `O(N)`; space: `O(N)`** (see https://en.cppreference.com/w/cpp/algorithm/stable_partition for more info)\\n```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n\\tstable_partition(begin(n), end(n), bind2nd(greater_equal<int>(), 0));\\n\\n\\tfor(int i{0}; i<size(n); )\\n\\t{\\n\\t\\tint j{i}, t{n[i]};\\n\\t\\tdo\\n\\t\\t{\\n\\t\\t\\tj = 2*j % (int(size(n))-1);     \\n\\t\\t\\tt = exchange(n[j],t); \\n\\t\\t}while(i!=j);\\n\\n\\t\\tfor( ; i<size(n) and i&1^n[i]>0; ++i);\\n\\t}\\n\\treturn n;\\n}\\n```\\n**Custom \"stable_partition\"(divide and conquer) + permutation cycles**\\n**time: `O(NlogN)`; space: `O(1)`**\\n\\nExample of stable partition of array `{-1,1,2,3,-2,-3,-4,4}` :\\n\\n![image](https://assets.leetcode.com/users/images/00602a77-6192-46bb-b833-75306dee4136_1643582796.8632696.png)\\n\\nExample of the rotate algo:\\n\\n![image](https://assets.leetcode.com/users/images/086160bc-b9e3-410d-836a-cd01d697bb02_1643645964.5701823.png)\\n\\nExamples of permutation cycles for the following arrays\\n* `{1,2,-1,-2}`;\\n* `{1,2,3,-1,-2,-3}`;\\n* `{1,2,3,4,-1,-2,-3,-4}`;\\n* `{1,2,3,4,5,-1,-2,-3,-4,-5}`;\\n* `{1,2,3,4,5,6,-1,-2,-3,-4,-5,-6}`.\\n\\n![image](https://assets.leetcode.com/users/images/d5c197e0-ea28-4629-8467-4f427bbc2cae_1643583834.2154624.png)\\n\\n```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n    for(int d{2}; d<2*size(n); d<<=1)\\n\\t\\tfor(auto b{begin(n)}, m{b}, e{b}; b<end(n); b=e)\\n\\t\\t{\\n\\t\\t\\tm = min(b+d/2, end(n)),\\n\\t\\t\\te = min(b+d,   end(n));\\n\\t\\t\\tauto i = lower_bound(b, m, 0, greater<int>{}),\\n\\t\\t\\t\\t k = upper_bound(m, e, 0, greater<int>{});\\n\\t\\t\\trotate(i, m, k);\\n\\t\\t}\\n\\n\\tfor(int i{}; i<size(n); )\\n\\t{\\n\\t\\tint j{i}, t{n[i]};\\n\\t\\tdo\\n\\t\\t{\\n\\t\\t\\tj = 2*j % (int(size(n))-1);     \\n\\t\\t\\tt = exchange(n[j],t); \\n\\t\\t}while(i!=j);\\n\\n\\t\\tfor( ; i<size(n) and i&1^n[i]>0; ++i);\\n\\t}\\n\\treturn n;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n\\tvector<int> out(size(n));\\n\\tfor(int i{}, j{}, k{}; k<size(n); )\\n\\t{\\n\\t\\tfor( ; n[i]<0; ++i);\\n\\t\\tfor( ; n[j]>0; ++j);\\n\\t\\tout[k++]=n[i++];\\n\\t\\tout[k++]=n[j++];    \\n\\t}                \\n\\treturn out; \\n}\\n```\n```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n\\tfor(int i{}, j{}, k{}, t{}; k<size(n); ++i, ++j)\\n\\t{\\n\\t\\tfor( ; n[i]<0; ++i);\\n\\t\\tt = n[i];\\n\\t\\tfor(int x{i}; x>k; n[x]=n[x-1], --x);\\n\\t\\tn[k++] = t;\\n\\n\\t\\tfor( ; n[j]>0; ++j);\\n\\t\\tt = n[j];\\n\\t\\tfor(int y{j}; y>k; n[y]=n[y-1], --y);\\n\\t\\tn[k++] = t;           \\n\\t}\\n\\treturn n; \\n}\\n```\n```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n\\tstable_partition(begin(n), end(n), bind2nd(greater_equal<int>(), 0));\\n\\n\\tfor(int i{0}; i<size(n); )\\n\\t{\\n\\t\\tint j{i}, t{n[i]};\\n\\t\\tdo\\n\\t\\t{\\n\\t\\t\\tj = 2*j % (int(size(n))-1);     \\n\\t\\t\\tt = exchange(n[j],t); \\n\\t\\t}while(i!=j);\\n\\n\\t\\tfor( ; i<size(n) and i&1^n[i]>0; ++i);\\n\\t}\\n\\treturn n;\\n}\\n```\n```\\nvector<int> rearrangeArray(vector<int>& n)\\n{\\n    for(int d{2}; d<2*size(n); d<<=1)\\n\\t\\tfor(auto b{begin(n)}, m{b}, e{b}; b<end(n); b=e)\\n\\t\\t{\\n\\t\\t\\tm = min(b+d/2, end(n)),\\n\\t\\t\\te = min(b+d,   end(n));\\n\\t\\t\\tauto i = lower_bound(b, m, 0, greater<int>{}),\\n\\t\\t\\t\\t k = upper_bound(m, e, 0, greater<int>{});\\n\\t\\t\\trotate(i, m, k);\\n\\t\\t}\\n\\n\\tfor(int i{}; i<size(n); )\\n\\t{\\n\\t\\tint j{i}, t{n[i]};\\n\\t\\tdo\\n\\t\\t{\\n\\t\\t\\tj = 2*j % (int(size(n))-1);     \\n\\t\\t\\tt = exchange(n[j],t); \\n\\t\\t}while(i!=j);\\n\\n\\t\\tfor( ; i<size(n) and i&1^n[i]>0; ++i);\\n\\t}\\n\\treturn n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940975,
                "title": "5-lines-of-code-with-explaination",
                "content": "# Article: Rearranging Positive and Negative Integers in an Array - C++ Solution\\n\\nRearranging elements in an array is a common task in programming that often requires careful consideration of the problem\\'s constraints and the use of creative algorithms. In this article, we\\'ll explore a C++ solution that rearranges positive and negative integers in an array while maintaining a specific pattern. We\\'ll break down the code step by step and discuss its functionality, focusing on its approach to organizing elements in a unique way.\\n\\n## The Problem\\n\\nGiven an array of integers containing both positive and negative numbers, our goal is to rearrange the array in such a way that positive integers occupy even indices, and negative integers occupy odd indices. The order of elements should be preserved within their respective categories (positive and negative).\\n\\nFor example, if the input array is `[-1, 2, -3, 4, -5]`, the desired output would be `[2, -1, 4, -3, -5]`.\\n\\n## The Solution\\n\\nTo achieve the desired rearrangement, the solution employs two index pointers: one for positive integers and one for negative integers. The code iterates through the input array and places positive numbers at even indices and negative numbers at odd indices in the output array. Let\\'s dive into the code and understand how it works:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0); // Stores the rearranged array\\n        int posIndex = 0; // Index for positive integers\\n        int negIndex = 1; // Index for negative integers\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else {\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n## How It Works\\n\\n1. We initialize a vector named `ans` to store the rearranged array. The vector is initialized with zeros and will later hold the elements in the desired order.\\n\\n2. We use two index pointers, `posIndex` and `negIndex`, which start at even and odd positions respectively. These pointers keep track of where positive and negative numbers should be placed in the `ans` vector.\\n\\n3. The loop iterates through each element of the input array `nums`.\\n\\n4. For positive numbers encountered during the iteration, we place them at the index pointed to by `posIndex` in the `ans` vector, and then increment `posIndex` by 2 to move it to the next even index.\\n\\n5. For negative numbers encountered, we place them at the index pointed to by `negIndex` in the `ans` vector, and then increment `negIndex` by 2 to move it to the next odd index.\\n\\n6. Once all elements have been processed, the `ans` vector contains the rearranged array according to the specified pattern.\\n\\n## Complexity Analysis\\n\\nThe solution iterates through the input array once, which takes **O(n)** time, where **n** is the number of elements in the array. The space complexity is **O(n)** due to the additional space required for the `ans` vector.\\n\\n## Conclusion\\n\\nThe provided C++ solution creatively rearranges an array of positive and negative integers while adhering to a specific pattern. By utilizing index pointers and maintaining the pattern as elements are inserted into the new array, the solution demonstrates an efficient and effective approach to solving this particular problem.\\n\\nThis problem-solving approach showcases the importance of algorithmic thinking and data manipulation in crafting elegant solutions. It serves as a reminder that understanding problem constraints and devising strategies to handle them can lead to innovative and efficient solutions in the realm of programming.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0); // Stores the rearranged array\\n        int posIndex = 0; // Index for positive integers\\n        int negIndex = 1; // Index for negative integers\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > 0) {\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else {\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502591,
                "title": "c-solution-in-o-1-space-two-pointers-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n      int p1=0,p2=0;\\n      vector<int>l;\\n            while(l.size()!=nums.size())\\n            {\\n                for(int i=p1;i<nums.size();i++)\\n                {if(nums[i]>0){p1=i;break;}}\\n                for(int i=p2;i<nums.size();i++)\\n                {if(nums[i]<0){p2=i;break;}}\\n                l.push_back(nums[p1++]);\\n                l.push_back(nums[p2++]);\\n            }\\n            return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n      int p1=0,p2=0;\\n      vector<int>l;\\n            while(l.size()!=nums.size())\\n            {\\n                for(int i=p1;i<nums.size();i++)\\n                {if(nums[i]>0){p1=i;break;}}\\n                for(int i=p2;i<nums.size();i++)\\n                {if(nums[i]<0){p2=i;break;}}\\n                l.push_back(nums[p1++]);\\n                l.push_back(nums[p2++]);\\n            }\\n            return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160643,
                "title": "85-faster-time-o-n-space-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i=0,j=1;\\n        vector<int> ans(nums.size());\\n        for(auto &x: nums){\\n            if(x>0){\\n                ans[i] = x;\\n                i += 2;\\n            }else{\\n                ans[j] = x;\\n                j += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i=0,j=1;\\n        vector<int> ans(nums.size());\\n        for(auto &x: nums){\\n            if(x>0){\\n                ans[i] = x;\\n                i += 2;\\n            }else{\\n                ans[j] = x;\\n                j += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109515,
                "title": "java-and-python-simple-and-easy-solution",
                "content": "Please upvote if understood \\n\\n**Java **\\n\\n    public int[] rearrangeArray(int[] nums) {\\n        int e= 0; // Even indices \\n        int o = 1 ; // odd indices \\n        int n = nums.length;\\n        int [] ans = new int [n];\\n        \\n       for(int elem :nums){\\n           if(elem >=0){\\n               ans[e]=elem;\\n               e+=2;\\n           }else{\\n               ans[o]=elem;\\n               o+=2;\\n           }\\n       }\\n        return ans;\\n    }\\n\\n**Python **\\n\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        ans=[0]*len(nums);\\n        e =0 ;  o=1 ; \\n        for x in nums:\\n            if(x>=0):\\n                ans[e]=x;\\n                e+=2;\\n            else:\\n                ans[o]=x;\\n                o+=2;\\n        return ans;",
                "solutionTags": [
                    "Array"
                ],
                "code": "Please upvote if understood \\n\\n**Java **\\n\\n    public int[] rearrangeArray(int[] nums) {\\n        int e= 0; // Even indices \\n        int o = 1 ; // odd indices \\n        int n = nums.length;\\n        int [] ans = new int [n];\\n        \\n       for(int elem :nums){\\n           if(elem >=0){\\n               ans[e]=elem;\\n               e+=2;\\n           }else{\\n               ans[o]=elem;\\n               o+=2;\\n           }\\n       }\\n        return ans;\\n    }\\n\\n**Python **\\n\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        ans=[0]*len(nums);\\n        e =0 ;  o=1 ; \\n        for x in nums:\\n            if(x>=0):\\n                ans[e]=x;\\n                e+=2;\\n            else:\\n                ans[o]=x;\\n                o+=2;\\n        return ans;",
                "codeTag": "Python3"
            },
            {
                "id": 2641078,
                "title": "java-simple-100-faster",
                "content": "class Solution {\\n\\n    public int[] rearrangeArray(int[] nums) {\\n        int s = nums.length;\\n        int [] arr = new int[s];\\n        \\n        int p = 0;\\n        int n = 1;\\n        for(int i =0;i < s;i++)\\n        {\\n            if(nums[i] > 0){\\n                arr[p] =nums[i];\\n                p =p+2;\\n            }else{\\n                arr[n] = nums[i];\\n                n = n+2;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\n    public int[] rearrangeArray(int[] nums) {\\n        int s = nums.length;\\n        int [] arr = new int[s];\\n        \\n        int p = 0;\\n        int n = 1;\\n        for(int i =0;i < s;i++)\\n        {\\n            if(nums[i] > 0){\\n                arr[p] =nums[i];\\n                p =p+2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2106556,
                "title": "c-short-solution-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n       int neg=1;\\n        int pos=0;\\n        vector<int> ans(n,0);\\n        for(int x:nums){\\n            if(x>0){\\n                ans[pos]=x;\\n                pos+=2;\\n            }\\n            if(x<0){\\n                ans[neg]=x;\\n                neg+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n       int neg=1;\\n        int pos=0;\\n        vector<int> ans(n,0);\\n        for(int x:nums){\\n            if(x>0){\\n                ans[pos]=x;\\n                pos+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2106538,
                "title": "c-easy-sol-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n     vector<int>ans;\\n        vector<int>pos;\\n        vector<int>neg;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                pos.push_back(nums[i]);\\n            }\\n            if(nums[i]<0){\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n            int j=0;\\n            int k=0;\\n            for(int i=0;i<nums.size();i++){\\n                if(i%2==0){\\n                    ans.push_back(pos[j]);\\n                    j++;\\n                }\\n                else{\\n                    ans.push_back(neg[k]);\\n                    k++;\\n                }\\n            }\\n return ans;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n     vector<int>ans;\\n        vector<int>pos;\\n        vector<int>neg;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                pos.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1711318,
                "title": "c-most-easy-implementation-naive-approach",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* Store pos. and neg. alternatively and start should be with pos number according to question.\\n#### \\u2714\\uFE0F **Solution - I (Naive Approach)**\\n##### **Intuition :-**\\n* As we know both `pos. `and `neg.` values are in equally present in the given vector.\\n* Create vector for `storing pos`. element.\\n* Create vector for `storing neg`. element.\\n*  Insert in the given array alternatively. Its easy you all can do it right \\uD83D\\uDE0E.\\n##### **Code :-**\\n```\\nclass Solution\\n{\\npublic:\\n     vector<int> rearrangeArray(vector<int> &nums)\\n     {\\n          vector<int> pos(nums.size() / 2), neg(nums.size() / 2);\\n          int l = 0, m = 0;\\n          for (int i = 0; i < nums.size(); i++)\\n               nums[i] < 0 ? neg[l++] = nums[i] : pos[m++] = nums[i];\\n          for (int i = 0; i < nums.size() / 2; i++)\\n               nums[2 * i] = pos[i], nums[2 * i + 1] = neg[i];\\n          return nums;\\n     }\\n};\\n```\\n**Time Complexity** : `O(n)`, \\n**Space Complexity** : `O(n)`, \\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n     vector<int> rearrangeArray(vector<int> &nums)\\n     {\\n          vector<int> pos(nums.size() / 2), neg(nums.size() / 2);\\n          int l = 0, m = 0;\\n          for (int i = 0; i < nums.size(); i++)\\n               nums[i] < 0 ? neg[l++] = nums[i] : pos[m++] = nums[i];\\n          for (int i = 0; i < nums.size() / 2; i++)\\n               nums[2 * i] = pos[i], nums[2 * i + 1] = neg[i];\\n          return nums;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038271,
                "title": "best-2-c-solutions-using-array-and-queues-beats-100",
                "content": "# Code\\n```\\n// Solution 1 - Using extra array\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size(), 0);\\n        int pos = 0, neg = 1;\\n        for(int num : nums){\\n            if(num > 0){\\n                ans[pos] = num;\\n                pos += 2;\\n            }\\n            else{\\n                ans[neg] = num;\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 - Using queues\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        queue<int> pos, neg;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] > 0)\\n                pos.push(nums[i]);\\n            else\\n                neg.push(nums[i]);\\n        }\\n        for(int i = 0; i<nums.size(); i+=2){\\n            nums[i] = pos.front();\\n            pos.pop();\\n        }\\n        for(int i=1; i<nums.size(); i+=2){\\n            nums[i] = neg.front();\\n            neg.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\n// Solution 1 - Using extra array\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size(), 0);\\n        int pos = 0, neg = 1;\\n        for(int num : nums){\\n            if(num > 0){\\n                ans[pos] = num;\\n                pos += 2;\\n            }\\n            else{\\n                ans[neg] = num;\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Solution 2 - Using queues\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        queue<int> pos, neg;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] > 0)\\n                pos.push(nums[i]);\\n            else\\n                neg.push(nums[i]);\\n        }\\n        for(int i = 0; i<nums.size(); i+=2){\\n            nums[i] = pos.front();\\n            pos.pop();\\n        }\\n        for(int i=1; i<nums.size(); i+=2){\\n            nums[i] = neg.front();\\n            neg.pop();\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889063,
                "title": "simple-java-solution-with-detailed-explanation-time-and-space-complexity",
                "content": "# Intuition\\nThe main idea behind this code is to rearrange the elements of the input array in a specific pattern: positive numbers followed by negative numbers, while maintaining their relative order. The rearranged array alternates between positive and negative numbers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. **Separating Positive and Negative Numbers:**\\n   The first loop iterates through each element in the input array `nums`. It separates the positive numbers from the negative numbers and stores them in two separate ArrayLists, `listP` for positive numbers and `listN` for negative numbers. This separation is achieved by checking the sign of each number and adding it to the respective ArrayList.\\n\\n2. **Reconstructing the Array with Alternating Pattern:**\\n   The second loop iterates through the entire `nums` array. For each position `i` in the array, it uses an alternating pattern to reconstruct the array. If `i` is an even index (0-based), it takes the next positive number from `listP` and places it at position `i` in the `nums` array. If `i` is an odd index, it takes the next negative number from `listN` and places it at position `i` in the `nums` array.\\n\\n3. **Maintaining Relative Order:**\\n   Since the numbers are taken from `listP` and `listN` in the order they appear in those ArrayLists, the relative order of positive and negative numbers is preserved. This ensures that the rearranged array follows the desired pattern of alternating positive and negative numbers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        ArrayList<Integer> listP = new ArrayList<>();  \\n        ArrayList<Integer> listN = new ArrayList<>();\\n\\n        for(int i : nums){\\n            if(i > 0){\\n                listP.add(i);\\n            } else{\\n                listN.add(i);\\n            }\\n        }\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(i % 2 == 0){\\n                nums[i] = listP.get(i/2);\\n            }else{\\n                nums[i] = listN.get(i/2);\\n            }\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        ArrayList<Integer> listP = new ArrayList<>();  \\n        ArrayList<Integer> listN = new ArrayList<>();\\n\\n        for(int i : nums){\\n            if(i > 0){\\n                listP.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3847583,
                "title": "java-simple-solution-beginner-friendly-100-beats-easy-to-understand-with-explanation",
                "content": "# Approach\\n\\n**Approach and Logic:**\\n\\n1. We are given an array `nums` of even length containing an equal number of positive and negative integers.\\n2. The task is to rearrange the elements of `nums` such that:\\n   a. Every consecutive pair of integers have opposite signs.\\n   b. The order of integers with the same sign is preserved.\\n   c. The rearranged array begins with a positive integer.\\n\\n3. To achieve this, we initialize two pointers, `p` and `n`, to 0 and 1, respectively. These pointers will help us place positive and negative integers at alternate even and odd indices in the result array.\\n\\n4. We then loop through each element in the input array `nums`.\\n\\n5. If the current element is positive, we place it at the `p`th index of the result array and increment `p` by 2. This ensures that positive integers are placed at even indices.\\n\\n6. If the current element is negative, we place it at the `n`th index of the result array and increment `n` by 2. This ensures that negative integers are placed at odd indices.\\n\\n7. Since the input array `nums` has an equal number of positive and negative integers, the above steps ensure that we can place all the positive integers at even indices and all the negative integers at odd indices, satisfying the condition of having opposite signs in consecutive pairs.\\n\\n8. The order of the positive and negative integers is preserved because we are iterating through the input array in the same order.\\n\\n9. Finally, we return the resulting array `res`, which contains the rearranged elements following the given conditions.\\n\\n**Example:**\\n\\nLet\\'s take the example from the problem statement: `nums = [3, 1, -2, -5, 2, -4]`\\n\\n- The positive integers in `nums` are [3, 1, 2], and the negative integers are [-2, -5, -4].\\n- We start with `p = 0` and `n = 1`.\\n- We place the positive integers at even indices: `res[0] = 3`, `res[2] = 1`, and `res[4] = 2`.\\n- We place the negative integers at odd indices: `res[1] = -2`, `res[3] = -5`, and `res[5] = -4`.\\n\\nThe resulting array `res` is `[3, -2, 1, -5, 2, -4]`, satisfying all the given conditions.\\n\\n**Time Complexity:**\\n\\nThe time complexity of this solution is O(N), where N is the length of the input array `nums`. We loop through the entire array once to rearrange the elements.\\n\\n**Space Complexity:**\\n\\nThe space complexity of this solution is O(N) as we create a new array `res` of the same size as the input array `nums`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        int p = 0;\\n        int n = 1;\\n\\n        for(int num : nums) {\\n            if(num > 0){\\n                res[p] = num;\\n                p += 2;\\n            } else {\\n                res[n] = num;\\n                n += 2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        int p = 0;\\n        int n = 1;\\n\\n        for(int num : nums) {\\n            if(num > 0){\\n                res[p] = num;\\n                p += 2;\\n            } else {\\n                res[n] = num;\\n                n += 2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797586,
                "title": "2149-rearrange-array-elements-by-sign-in-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI have created 2 arraylist in which i stored +ve and -ve numbers respectively. Then i made another array in which i added elements consecutively from the arraylist & finally returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n1 = nums.length / 2;\\n        ArrayList<Integer> s1 = new ArrayList<>(n1);\\n        ArrayList<Integer> s2 = new ArrayList<>(n1);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] >= 0) {\\n                s1.add(nums[i]);\\n            } else if (nums[i] < 0) {\\n                s2.add(nums[i]);\\n            }\\n        }\\n\\n        int[] arr1 = new int[nums.length];\\n\\n        for (int i = 0, j = 0; i < nums.length; i = i + 2) {\\n            arr1[i] = s1.get(j);\\n            j++;\\n        }\\n\\n        for (int i = 1, j = 0; i < nums.length; i = i + 2) {\\n            arr1[i] = s2.get(j);\\n            j++;\\n        }\\n\\n        return arr1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n1 = nums.length / 2;\\n        ArrayList<Integer> s1 = new ArrayList<>(n1);\\n        ArrayList<Integer> s2 = new ArrayList<>(n1);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] >= 0) {\\n                s1.add(nums[i]);\\n            } else if (nums[i] < 0) {\\n                s2.add(nums[i]);\\n            }\\n        }\\n\\n        int[] arr1 = new int[nums.length];\\n\\n        for (int i = 0, j = 0; i < nums.length; i = i + 2) {\\n            arr1[i] = s1.get(j);\\n            j++;\\n        }\\n\\n        for (int i = 1, j = 0; i < nums.length; i = i + 2) {\\n            arr1[i] = s2.get(j);\\n            j++;\\n        }\\n\\n        return arr1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688436,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://takeuforward.org/arrays/rearrange-array-elements-by-sign/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos=0;int neg=1;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n             ans[neg]=nums[i];\\n             neg+=2;\\n            }else{\\n             ans[pos]=nums[i];\\n             pos+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos=0;int neg=1;\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n             ans[neg]=nums[i];\\n             neg+=2;\\n            }else{\\n             ans[pos]=nums[i];\\n             pos+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619424,
                "title": "easiest-c-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Here we created 2 vectors: One to store +ve elements and other to store -ive elements.\\nThen we erased the given nums vector.\\nAfter this we   pushed elements from +ve array and then from -ve array  till the nums array size doesnt becomes to its actual size**\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>nums1;\\n        vector<int>nums2;\\n        int n=nums.size();\\n        for(auto it: nums)\\n        {\\n            if(it>0)\\n            {\\n                nums1.push_back(it);\\n            }\\n            else if(it<0)\\n            {\\n                nums2.push_back(it);\\n            }\\n        }\\n        // nums[0]=nums1[0];\\n        nums.clear();\\n        int i=0;\\n        while(nums.size()!=n)\\n        {\\n\\n        \\n            nums.push_back(nums1[i]);\\n            nums.push_back(nums2[i]);\\n            i++;\\n        }\\n            \\n\\n        \\n\\nreturn nums;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# **Please upvote if you like.**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>nums1;\\n        vector<int>nums2;\\n        int n=nums.size();\\n        for(auto it: nums)\\n        {\\n            if(it>0)\\n            {\\n                nums1.push_back(it);\\n            }\\n            else if(it<0)\\n            {\\n                nums2.push_back(it);\\n            }\\n        }\\n        // nums[0]=nums1[0];\\n        nums.clear();\\n        int i=0;\\n        while(nums.size()!=n)\\n        {\\n\\n        \\n            nums.push_back(nums1[i]);\\n            nums.push_back(nums2[i]);\\n            i++;\\n        }\\n            \\n\\n        \\n\\nreturn nums;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# **Please upvote if you like.**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599873,
                "title": "easiest-approach-striver-s-method-brute-optimal-fully-explained-beats-100",
                "content": "# Intuition\\nOkay, so the problem is very simple to understand and easy to approach too. We can achieve the solution by two methods shown below.\\n\\n# Approach\\n**1. Brute Force**\\n- In this simple approach, since the number of positive and negative elements are the same, we put positives into an array called \\u201Cpos\\u201D and negatives into an array called \\u201Cneg\\u201D.\\n- After segregating each of the positive and negative elements, we start putting them alternatively back into array A.\\n- Since the array must begin with a positive number and the start index is 0, so all the positive numbers would be placed at even indices (2\\\\*i) and negatives at the odd indices (2\\\\*i+1), where i is the index of the pos or neg array while traversing them simultaneously.\\n- This approach uses O(N+N/2) of running time due to multiple traversals which we\\u2019ll try to optimize in the optimized approach given below.\\n\\n##### Code\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n = nums.size();\\n        vector<int> pos, neg;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=0) pos.push_back(nums[i]);\\n            else neg.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n/2;i++){\\n            nums[2*i] = pos[i];\\n            nums[2*i + 1] = neg[i];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n##### Complexity\\n- **Time Complexity:** O(N+N/2) { O(N) for traversing the array once for segregating positives and negatives and another O(N/2) for adding those elements alternatively to the array, where N = size of the array A}.\\n\\n- **Space Complexity:**  O(N/2 + N/2) = O(N) { N/2 space required for each of the positive and negative element arrays, where N = size of the array A}.\\n\\n**2. Optimal**\\n- In this optimal approach, we will try to solve the problem in a single pass and try to arrange the array elements in the correct order in that pass only.\\n- We know that the resultant array must start from a positive element so we initialize the positive index as 0 and negative index as 1 and start traversing the array such that whenever we see the first positive element, it occupies the space at 0 and then posIndex increases by 2 (alternate places).\\n- Similarly, when we encounter the first negative element, it occupies the position at index 1, and then each time we find a negative number, we put it on the negIndex and it increments by 2.\\n- When both the negIndex and posIndex exceed the size of the array, we see that the whole array is now rearranged alternatively according to the sign.\\n\\n##### Code\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int pos = 0, neg = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] >= 0){\\n                ans[pos] = nums[i];\\n                pos+=2;\\n            }\\n            else{\\n                ans[neg] = nums[i];\\n                neg+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n##### Complexity\\n- **Time Complexity:** O(N) { O(N) for traversing the array once and substituting positives and negatives simultaneously using pointers, where N = size of the array A}.\\n\\n- **Space Complexity:**  O(N) { Extra Space used to store the rearranged elements separately in an array, where N = size of array A}.\\n\\n\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/4df3f3bc-3402-42e7-817c-0df3351e1e56_1690651490.4634397.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Simulation"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n = nums.size();\\n        vector<int> pos, neg;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=0) pos.push_back(nums[i]);\\n            else neg.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n/2;i++){\\n            nums[2*i] = pos[i];\\n            nums[2*i + 1] = neg[i];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int pos = 0, neg = 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i] >= 0){\\n                ans[pos] = nums[i];\\n                pos+=2;\\n            }\\n            else{\\n                ans[neg] = nums[i];\\n                neg+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386441,
                "title": "short-and-clean-code-with-optimal-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int  n = nums.size();\\n        int pos = 0, neg = 1;\\n        vector<int> ans(n,0);\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < 0){\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n            else{\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int  n = nums.size();\\n        int pos = 0, neg = 1;\\n        vector<int> ans(n,0);\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < 0){\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n            else{\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251604,
                "title": "beats-97-in-tc-ands-98-in-sc-simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size() , 0);\\n        int l =0,m=1;\\n        for(int i =0 ; i<nums.size();i++){\\n            if(nums[i]>0){\\n                ans[l] = nums[i];\\n                l+=2;\\n            }\\n            else{\\n                ans[m] = nums[i];\\n                m+=2;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size() , 0);\\n        int l =0,m=1;\\n        for(int i =0 ; i<nums.size();i++){\\n            if(nums[i]>0){\\n                ans[l] = nums[i];\\n                l+=2;\\n            }\\n            else{\\n                ans[m] = nums[i];\\n                m+=2;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147542,
                "title": "simple-c-code-using-for-loop-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int a=nums.size();\\n        vector<int>vn,vp;\\n        for(int i=0;i<a;i++){\\n            if(nums[i]<0){vn.emplace_back(nums[i]);}\\n            else {vp.emplace_back(nums[i]);}\\n        }\\n        int j=0,m=0;\\n        vector<int>v;\\n        for(int i=0;i<a;i++){\\n            if(i%2==0){\\n                v.emplace_back(vp[j]);\\n                j++;\\n            }\\n            else{\\n                v.emplace_back(vn[m]);\\n                m++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int a=nums.size();\\n        vector<int>vn,vp;\\n        for(int i=0;i<a;i++){\\n            if(nums[i]<0){vn.emplace_back(nums[i]);}\\n            else {vp.emplace_back(nums[i]);}\\n        }\\n        int j=0,m=0;\\n        vector<int>v;\\n        for(int i=0;i<a;i++){\\n            if(i%2==0){\\n                v.emplace_back(vp[j]);\\n                j++;\\n            }\\n            else{\\n                v.emplace_back(vn[m]);\\n                m++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046696,
                "title": "easiest-c-solution-using-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n         vector<int> ans(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                ans[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                ans[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n         vector<int> ans(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                ans[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                ans[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033426,
                "title": "easy-and-understandable-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n];\\n        int start = 0, end = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                arr[start] = nums[i];\\n                start += 2;\\n            }\\n            else if(nums[i] < 0){\\n                arr[end] = nums[i];\\n                end += 2;\\n            }           \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n];\\n        int start = 0, end = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                arr[start] = nums[i];\\n                start += 2;\\n            }\\n            else if(nums[i] < 0){\\n                arr[end] = nums[i];\\n                end += 2;\\n            }           \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638259,
                "title": "simple-o-n-time-o-n-space-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) \\n    {\\n        int even_idx =0,odd_idx =1;\\n        int[] ans = new int[nums.length];\\n        \\n        for(int i=0; i<nums.length;i++)\\n        {\\n            if(nums[i] >= 0)\\n            {\\n                ans[even_idx] = nums[i];\\n                even_idx += 2;\\n            }\\n            \\n            else\\n            {\\n                ans[odd_idx] = nums[i];\\n                odd_idx += 2;\\n            }\\n        }\\n        return ans;            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) \\n    {\\n        int even_idx =0,odd_idx =1;\\n        int[] ans = new int[nums.length];\\n        \\n        for(int i=0; i<nums.length;i++)\\n        {\\n            if(nums[i] >= 0)\\n            {\\n                ans[even_idx] = nums[i];\\n                even_idx += 2;\\n            }\\n            \\n            else\\n            {\\n                ans[odd_idx] = nums[i];\\n                odd_idx += 2;\\n            }\\n        }\\n        return ans;            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346819,
                "title": "python-easy-to-understand-solution-brute-force",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        neg = []\\n        pos = []\\n        ans = []\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        for j in range(len(nums)//2):\\n            ans.append(pos[j])\\n            ans.append(neg[j])\\n        return ans\\n```\\n**.\\n.\\n.\\n.\\n.\\n.\\n<<< Please Up-vote if you find this useful >>>**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        neg = []\\n        pos = []\\n        ans = []\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        for j in range(len(nums)//2):\\n            ans.append(pos[j])\\n            ans.append(neg[j])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233805,
                "title": "using-queue-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& arr) {\\n      // create queues for storing postive and negative numbers\\n        queue<int> pos;\\n        queue<int> neg;\\n        int size=arr.size();\\n        // push (+)ve and (-)ve elements into the queue\\n        for (int i=0;i<size;i++)\\n        {\\n            if (arr[i]>0)\\n                pos.push(arr[i]);\\n            else \\n                neg.push(arr[i]);\\n        }\\n        \\n            int ind=0;\\n        \\n        // in place storing postive and negative \\n        // one by one alternatively\\n           while(ind<size)\\n            {\\n                arr[ind++]=pos.front();\\n                pos.pop();\\n                arr[ind++]=neg.front();\\n                neg.pop();\\n            }\\n\\t\\t\\t\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& arr) {\\n      // create queues for storing postive and negative numbers\\n        queue<int> pos;\\n        queue<int> neg;\\n        int size=arr.size();\\n        // push (+)ve and (-)ve elements into the queue\\n        for (int i=0;i<size;i++)\\n        {\\n            if (arr[i]>0)\\n                pos.push(arr[i]);\\n            else \\n                neg.push(arr[i]);\\n        }\\n        \\n            int ind=0;\\n        \\n        // in place storing postive and negative \\n        // one by one alternatively\\n           while(ind<size)\\n            {\\n                arr[ind++]=pos.front();\\n                pos.pop();\\n                arr[ind++]=neg.front();\\n                neg.pop();\\n            }\\n\\t\\t\\t\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187903,
                "title": "c-optimal-solution-beginner-s-friendly-easy-to-understand",
                "content": "**Please Upvote the solution if it helped you because a single upvote motivate the creator\\'s like us to create more content...........**\\n\\nCODE->\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<int> res(n,0);\\n        int even=0,odd=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                res[even]=nums[i];\\n                even=even+2;\\n                }\\n            else\\n            {\\n                res[odd]=nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<int> res(n,0);\\n        int even=0,odd=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                res[even]=nums[i];\\n                even=even+2;\\n                }\\n            else\\n            {\\n                res[odd]=nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106517,
                "title": "c-easy-vector-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        // given 0 indexed integer array\\n        //consecutive pairs have opposite signs\\n        vector<int>ans;\\n        vector<int> neg;//\\n        vector<int> pos;//\\n        for(int x:nums){\\n            if(x<0){\\n                neg.push_back(x);// -2 -5 -4\\n            }\\n            else pos.push_back(x);// 3 1 2\\n        }\\n        int j=0;\\n        int k=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                ans.push_back(pos[j]);\\n                j++;\\n            }\\n            else{\\n                ans.push_back(neg[k]);\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        // given 0 indexed integer array\\n        //consecutive pairs have opposite signs\\n        vector<int>ans;\\n        vector<int> neg;//\\n        vector<int> pos;//\\n        for(int x:nums){\\n            if(x<0){\\n                neg.push_back(x);// -2 -5 -4\\n            }\\n            else pos.push_back(x);// 3 1 2\\n        }\\n        int j=0;\\n        int k=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2==0){\\n                ans.push_back(pos[j]);\\n                j++;\\n            }\\n            else{\\n                ans.push_back(neg[k]);\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093279,
                "title": "best-c-sol-solved-using-2-diff-approach",
                "content": "**if we try to optimize space we end up in increasing time complexity\\nand if we optimize time ,we end up increasing space utilization**\\n![image](https://assets.leetcode.com/users/images/4e0a97cf-8ec2-41f3-8f9b-a1c47deb310e_1653976284.2826552.jpeg)\\nOR \\nWe know that all positive numbers will be on multiple of 2 indexes(0,2,4..) and negatives will be on odd(1,3,5...) indexes.\\n\\nTime complexity : O(n)\\nSpace Complexity : O(n)\\nNotice that extra array is part of algorithm.\\n\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                ans[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                ans[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "**if we try to optimize space we end up in increasing time complexity\\nand if we optimize time ,we end up increasing space utilization**\\n![image](https://assets.leetcode.com/users/images/4e0a97cf-8ec2-41f3-8f9b-a1c47deb310e_1653976284.2826552.jpeg)\\nOR \\nWe know that all positive numbers will be on multiple of 2 indexes(0,2,4..) and negatives will be on odd(1,3,5...) indexes.\\n\\nTime complexity : O(n)\\nSpace Complexity : O(n)\\nNotice that extra array is part of algorithm.\\n\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                ans[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                ans[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2001875,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] n) {\\n        int k=n.length,j=0,f=1;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]<0)\\n            {\\n                b[f]=n[i];\\n                f+=2;\\n            }\\n            else\\n            {\\n                b[j]=n[i];\\n                j+=2;\\n            }\\n        }\\n        return b;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] n) {\\n        int k=n.length,j=0,f=1;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]<0)\\n            {\\n                b[f]=n[i];\\n                f+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1832479,
                "title": "c-beginner-friendly-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> vec(nums.begin(),nums.end());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]>0)\\n          {\\n              vec[even]=nums[i];\\n              even=even+2;\\n          }\\n            else\\n            {\\n                vec[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> vec(nums.begin(),nums.end());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]>0)\\n          {\\n              vec[even]=nums[i];\\n              even=even+2;\\n          }\\n            else\\n            {\\n                vec[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746050,
                "title": "python-clean-o-n-space-and-time-complexity",
                "content": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def rearrangeArray(self, nums: list[int]) -> list[int]:\\n        pos, neg = deque(), deque()\\n\\n        for e in nums:\\n            if e > 0:\\n                pos.append(e)\\n            else:\\n                neg.append(e)\\n\\n        for i in range(0, len(nums), 2):\\n            nums[i], nums[i + 1] = pos.popleft(), pos.popleft()\\n\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def rearrangeArray(self, nums: list[int]) -> list[int]:\\n        pos, neg = deque(), deque()\\n\\n        for e in nums:\\n            if e > 0:\\n                pos.append(e)\\n            else:\\n                neg.append(e)\\n\\n        for i in range(0, len(nums), 2):\\n            nums[i], nums[i + 1] = pos.popleft(), pos.popleft()\\n\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725859,
                "title": "c-two-pointer-easy-explanation-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n,0);\\n\\t\\t\\n        int pos = 0; //taking 1st Pointer for Positive value and set at 0th Index.\\n        int neg = 1; //taking 2nd Pointer for Negetive value and set at 1st Index.\\n        \\n        for(int i = 0; i < n ; i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                ans[neg] =  nums[i];\\n                neg += 2;\\n            }\\n            else\\n            {\\n                ans[pos] = nums[i];\\n                 pos+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you Find This solution easy to understand Then Please Upvote. **",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n,0);\\n\\t\\t\\n        int pos = 0; //taking 1st Pointer for Positive value and set at 0th Index.\\n        int neg = 1; //taking 2nd Pointer for Negetive value and set at 1st Index.\\n        \\n        for(int i = 0; i < n ; i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                ans[neg] =  nums[i];\\n                neg += 2;\\n            }\\n            else\\n            {\\n                ans[pos] = nums[i];\\n                 pos+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724453,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in nums:\\n            if i>0:\\n                a.append(i)\\n            else:\\n                b.append(i)\\n        \\n        c=[]\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in nums:\\n            if i>0:\\n                a.append(i)\\n            else:\\n                b.append(i)\\n        \\n        c=[]\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713068,
                "title": "python-o-n-space-solution",
                "content": "* **TIME: O(2N)**\\n* **SPACE: O(N)**\\n\\nSIMPLE TRAVELS THROUGH ARRAY IF YOU  GOT NEGATIVE ADD IN `neg` LIST ELSE ADD IN `pos` LIST\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos,neg=[],[]\\n        \\n        for i in nums:\\n            if i <0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        res = []\\n        for i in range(len(neg)):\\n            res.append(pos[i])\\n            res.append(neg[i])\\n        return res\\n```\\n# TWO POINTERS\\n* **TIME: O(N)**\\n* **SPACE: O(N)**\\n\\nINITIALSE TWO POINTES `pos=0` and `neg =1` then TRAVELS THROUGH ARRAY IF YOU  GOT NEGATIVE ADD IN `res[neg]` increase `neg` by 2  ELSE ADD IN `res[pos]` increase `pos` by 2\\n\\n\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        res = [0]*len(nums)\\n        pos,neg=0,1\\n        for i in nums:\\n            if i <0:\\n                res[neg] = i\\n                neg += 2\\n            else:\\n                res[pos] = i\\n                pos += 2\\n        return res\\n```\\n\\n* IF YOU HAVE ANY QUERY PLZ FEEL FREE TO ASK IF YOU FIND IT HELPFUL PLZ  **UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos,neg=[],[]\\n        \\n        for i in nums:\\n            if i <0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        res = []\\n        for i in range(len(neg)):\\n            res.append(pos[i])\\n            res.append(neg[i])\\n        return res\\n```\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        res = [0]*len(nums)\\n        pos,neg=0,1\\n        for i in nums:\\n            if i <0:\\n                res[neg] = i\\n                neg += 2\\n            else:\\n                res[pos] = i\\n                pos += 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711371,
                "title": "c-two-lines-o-n-time-space",
                "content": "```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums)\\n    {\\n        var lookup = nums.ToLookup(x => x > 0);\\n        return lookup[true].Zip(lookup[false], (p, n) => new int[] { p, n }).SelectMany(_ => _).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums)\\n    {\\n        var lookup = nums.ToLookup(x => x > 0);\\n        return lookup[true].Zip(lookup[false], (p, n) => new int[] { p, n }).SelectMany(_ => _).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711302,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        ans, positives, negatives = [], [], []\\n        for val in nums:\\n            if val >= 0:\\n                positives.append(val)\\n            else:\\n                negatives.append(val)\\n        for i in range(len(positives)):\\n            ans.append(positives[i])\\n            ans.append(negatives[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        ans, positives, negatives = [], [], []\\n        for val in nums:\\n            if val >= 0:\\n                positives.append(val)\\n            else:\\n                negatives.append(val)\\n        for i in range(len(positives)):\\n            ans.append(positives[i])\\n            ans.append(negatives[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711281,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>pos,neg,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos.push_back(nums[i]);\\n            else neg.push_back(nums[i]);\\n        }\\n        for(int i=0;i<pos.size();i++)\\n        {\\n            ans.push_back(pos[i]);\\n            ans.push_back(neg[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>pos,neg,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos.push_back(nums[i]);\\n            else neg.push_back(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1711255,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int pos=0, neg=1;\\n        for(int n : nums)\\n        {\\n            if(n<0)\\n            {\\n                ans[neg]=n;\\n                neg+=2;\\n            }\\n            else\\n            {\\n                ans[pos]=n;\\n                pos+=2;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int pos=0, neg=1;\\n        for(int n : nums)\\n        {\\n            if(n<0)\\n            {\\n                ans[neg]=n;\\n                neg+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4001880,
                "title": "layman-s-solution-rearrange-array-elements-by-sign",
                "content": "\\n\\n# Approach\\nIn this simple approach, since the number of positive and negative elements are the same, we put positives into an array called \\u201Cpos\\u201D and negatives into an array called \\u201Cneg\\u201D.\\nAfter segregating each of the positive and negative elements, we start putting them alternatively back into array A.\\nSince the array must begin with a positive number and the start index is 0, so all the positive numbers would be placed at even indices (2*i) and negatives at the odd indices (2*i+1), where i is the index of the pos or neg array while traversing them simultaneously.\\n\\n# Complexity\\n- Time complexity:\\nO(n)+O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int m = nums.length;\\n        int pos[]=new int[m/2];\\n        int neg[]=new int[m/2];\\n        int p=0,n=0;\\n        for(int i=0 ; i<m ; i++){\\n            if(nums[i]>0){\\n                pos[p]=nums[i];\\n                p++;\\n            }else{\\n                neg[n]=nums[i];\\n                n++;\\n            }    \\n            \\n        }\\n        \\n        for(int i=0 ; i<m/2 ; i++){\\n            nums[2*i]=pos[i];\\n            nums[2*i+1]=neg[i];\\n        }  \\n\\n        return nums;      \\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int m = nums.length;\\n        int pos[]=new int[m/2];\\n        int neg[]=new int[m/2];\\n        int p=0,n=0;\\n        for(int i=0 ; i<m ; i++){\\n            if(nums[i]>0){\\n                pos[p]=nums[i];\\n                p++;\\n            }else{\\n                neg[n]=nums[i];\\n                n++;\\n            }    \\n            \\n        }\\n        \\n        for(int i=0 ; i<m/2 ; i++){\\n            nums[2*i]=pos[i];\\n            nums[2*i+1]=neg[i];\\n        }  \\n\\n        return nums;      \\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988489,
                "title": "easy-to-understand-java-solution-in-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPlace every positive element at even indexes and negative elemts at odd indexes.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] a) {\\n        int even=0;\\n        int odd=1;\\n        int ans[]=new int[a.length];\\n        int p=0;\\n        while(p<a.length){\\n            if (a[p]>0){\\n                ans[even]=a[p];\\n                even+=2;\\n            }\\n            else{\\n                ans[odd]=a[p];\\n                odd+=2;\\n            }\\n            p++;\\n        } \\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] a) {\\n        int even=0;\\n        int odd=1;\\n        int ans[]=new int[a.length];\\n        int p=0;\\n        while(p<a.length){\\n            if (a[p]>0){\\n                ans[even]=a[p];\\n                even+=2;\\n            }\\n            else{\\n                ans[odd]=a[p];\\n                odd+=2;\\n            }\\n            p++;\\n        } \\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942271,
                "title": "99-9-faster-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >ans(n,0);\\n        int evenIndex =0 ,oddInd=1;\\n        for(auto x :nums){\\n            if(x>0){\\n                ans[evenIndex]=x;\\n                evenIndex+=2;\\n            }else if( x<0){\\n                ans[oddInd]=x;\\n                oddInd+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int >ans(n,0);\\n        int evenIndex =0 ,oddInd=1;\\n        for(auto x :nums){\\n            if(x>0){\\n                ans[evenIndex]=x;\\n                evenIndex+=2;\\n            }else if( x<0){\\n                ans[oddInd]=x;\\n                oddInd+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892899,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int posIdx=0,negIdx=1;\\n        vector<int> ans(nums.size(),0);\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                ans[negIdx]=nums[i];\\n                negIdx+=2;\\n            }\\n            else{\\n                ans[posIdx]=nums[i];\\n                posIdx+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {        \\n        vector<int> pos,neg;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.size()/2;i++){\\n            nums[2*i]=pos[i];\\n            nums[2*i+1]=neg[i];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int posIdx=0,negIdx=1;\\n        vector<int> ans(nums.size(),0);\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                ans[negIdx]=nums[i];\\n                negIdx+=2;\\n            }\\n            else{\\n                ans[posIdx]=nums[i];\\n                posIdx+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {        \\n        vector<int> pos,neg;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<nums.size()/2;i++){\\n            nums[2*i]=pos[i];\\n            nums[2*i+1]=neg[i];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876968,
                "title": "easy-to-understand-beginner-friendly-cpp-solution-beats-100",
                "content": "UPVOTE PLEASE\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=0)\\n            pos.push_back(nums[i]);\\n            else\\n            neg.push_back(nums[i]);\\n        }\\n        int j=0;\\n        for(int i=0;i<nums.size()/2;i++){\\n            ans.push_back(pos[j]);\\n            ans.push_back(neg[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=0)\\n            pos.push_back(nums[i]);\\n            else\\n            neg.push_back(nums[i]);\\n        }\\n        int j=0;\\n        for(int i=0;i<nums.size()/2;i++){\\n            ans.push_back(pos[j]);\\n            ans.push_back(neg[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808808,
                "title": "simple-c-solution-brute-force-to-most-optimal-approach-easy-to-understand-85-faster",
                "content": "# Intuition\\nBasic Brute force approach\\n\\n# Approach\\n- In this simple approach, from the question itself we can clearly see that number of positive and negative elements are the same, we put positives into an array called \\u201Cpos\\u201D and negatives into an array called \\u201Cneg\\u201D.\\n- After putting that element in the \"pos\" and \"neg\" array, we now need to put them alternatively back into array A.\\n- Now in the question we can clearly see that array must begin with a positive number and the start index is 0, so all the positive numbers would be placed at even indices i.e [2*i] and negatives at the odd indices (2*i+1), where i is the index of the pos or neg array while traversing them simultaneously.\\n\\n# Complexity\\n- Time complexity: o(N) + o(N) = o(2N)\\n\\n- Space complexity: o(N) as we have taken two array i.e \"pos\" and  \"neg\" i.e both of size N/2 \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> neg,pos;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] >= 0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i = 0;i<nums.size()/2;i++){\\n            nums[2*i] = pos[i];\\n            nums[2*i+1] = neg[i];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# Intuition\\nOptimal solution\\n\\n# Approach\\n- In this optimal approach, we will try to solve the problem in a single iteration and try to arrange the array elements in the correct order in that pass only.\\n- Now as We know that the resultant array must start from a positive element so we initialize the positive index as 0(this means that positive element will stored at index 0,2,4...) and negative index as 1(this means that negative element will stored at index 1,3,5...) and start traversing the array such that whenever we see the first positive element, it occupies the space at 0 and then posIndex increases by 2 (alternate places).\\n- Similarly, when we encounter the first negative element, it occupies the position at index 1, and then each time we find a negative number, we put it on the negIndex and it increments by 2.\\n\\n\\n# Complexity\\n- Time complexity: o(N)\\n\\n- Space complexity: o(N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans(nums.size(),0);\\n        int pos = 0,neg = 1;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] < 0){\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n            else{\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n        }\\n    return ans;   // t.c = o(n)  // s.c = o(n)\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> neg,pos;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i] >= 0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i = 0;i<nums.size()/2;i++){\\n            nums[2*i] = pos[i];\\n            nums[2*i+1] = neg[i];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777012,
                "title": "c-code-using-tc-o-n-sc-o-n",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> v(nums.size(), 0);\\n        int x = 0 , y = 1;\\n        for(int i = 0; i<nums.size() ; i++){\\n            if(nums[i] < 0){\\n                v[y] = nums[i];\\n                y += 2;\\n            }else{\\n                v[x] = nums[i];\\n                x += 2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> v(nums.size(), 0);\\n        int x = 0 , y = 1;\\n        for(int i = 0; i<nums.size() ; i++){\\n            if(nums[i] < 0){\\n                v[y] = nums[i];\\n                y += 2;\\n            }else{\\n                v[x] = nums[i];\\n                x += 2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755222,
                "title": "c-solution-easy-to-understand",
                "content": "# Approach\\nLet\\'s seperate positive and negative numbers into different arrays and then merge it\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> nums1;\\n        vector<int> nums2;\\n        for(int i = 0;i < nums.size();i++){\\n            if(nums[i] < 0) nums1.push_back(nums[i]);\\n            else nums2.push_back(nums[i]);\\n        }\\n        int j = 0,k = 0;\\n        for(int i = 0;i < nums.size();i++){\\n            if(i % 2 == 0) nums[i] = nums2[k++];\\n            else  nums[i] = nums1[j++];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> nums1;\\n        vector<int> nums2;\\n        for(int i = 0;i < nums.size();i++){\\n            if(nums[i] < 0) nums1.push_back(nums[i]);\\n            else nums2.push_back(nums[i]);\\n        }\\n        int j = 0,k = 0;\\n        for(int i = 0;i < nums.size();i++){\\n            if(i % 2 == 0) nums[i] = nums2[k++];\\n            else  nums[i] = nums1[j++];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748365,
                "title": "two-pointer-method-easy-optimal-solution-with-comments-c",
                "content": "- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        // creating a result array \\n        vector<int> result;\\n\\n        // initializing two pointers \\n        int pos = 0, neg = 0;\\n\\n        // iterating until the end of array\\n        while(pos != nums.size() && neg != nums.size())\\n        {\\n            // search for the positive number\\n            // and insert that number in resultant array when found\\n            while(nums[pos] <= 0)\\n            {\\n                pos++;\\n            }\\n            result.push_back(nums[pos++]);\\n\\n            // search for the negative number\\n            // and insert that number in resultant array when found\\n            while(nums[neg] > 0)\\n            {\\n                neg++;\\n            }\\n            result.push_back(nums[neg++]);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        // creating a result array \\n        vector<int> result;\\n\\n        // initializing two pointers \\n        int pos = 0, neg = 0;\\n\\n        // iterating until the end of array\\n        while(pos != nums.size() && neg != nums.size())\\n        {\\n            // search for the positive number\\n            // and insert that number in resultant array when found\\n            while(nums[pos] <= 0)\\n            {\\n                pos++;\\n            }\\n            result.push_back(nums[pos++]);\\n\\n            // search for the negative number\\n            // and insert that number in resultant array when found\\n            while(nums[neg] > 0)\\n            {\\n                neg++;\\n            }\\n            result.push_back(nums[neg++]);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642215,
                "title": "c-super-easy-self-explanatory-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int pos = 0;\\n        int neg = 1;\\n        vector<int> ans(nums.size());\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] > 0){\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else{\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        int pos = 0;\\n        int neg = 1;\\n        vector<int> ans(nums.size());\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] > 0){\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else{\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3640675,
                "title": "easy-c-solution-t-c-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> neg;\\n        vector<int> pos;\\n        for(int i=0; i<nums.size();i++){\\n            if(nums[i]>=0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n\\n        vector<int> ans;\\n        int i=0; int j=0;\\n        while(i<pos.size() && j<neg.size()){\\n            ans.push_back(pos[i]);\\n            \\n            ans.push_back(neg[j]);\\n            i++;\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> neg;\\n        vector<int> pos;\\n        for(int i=0; i<nums.size();i++){\\n            if(nums[i]>=0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n\\n        vector<int> ans;\\n        int i=0; int j=0;\\n        while(i<pos.size() && j<neg.size()){\\n            ans.push_back(pos[i]);\\n            \\n            ans.push_back(neg[j]);\\n            i++;\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639794,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int pos=0,neg=1;\\n        int ans[]=new int[nums.length];\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]>0){\\n               ans[pos]=nums[i];\\n               pos+=2;\\n           }\\n           else{\\n               ans[neg]=nums[i];\\n               neg+=2;\\n           }\\n           \\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int pos=0,neg=1;\\n        int ans[]=new int[nums.length];\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]>0){\\n               ans[pos]=nums[i];\\n               pos+=2;\\n           }\\n           else{\\n               ans[neg]=nums[i];\\n               neg+=2;\\n           }\\n           \\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434530,
                "title": "rearrange-array-elements-by-sign-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake 2 arrays. One for positive integers and other for negative integers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make a pos_arr to store positive integers and a neg_arr to store negative integers.\\n2. Traverse the \\'nums\\' array and store positive and negative arrays in their respective new arrays.Then empty the nums array.\\n3. Now make a for loop to run for half the length of nums array and add the elements alternatively from pos_arr and neg_arr starting from pos_arr.\\n4. Return nums array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i;\\n        vector<int> neg_arr;\\n        vector<int> pos_arr;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                neg_arr.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                pos_arr.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n        for(i=0 ; i<pos_arr.size() ; i++)\\n        {\\n            nums.push_back(pos_arr[i]);\\n            nums.push_back(neg_arr[i]);\\n        }\\n        return nums;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b471e485-ba5c-46d8-8563-d76c7d787551_1682613144.4603813.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i;\\n        vector<int> neg_arr;\\n        vector<int> pos_arr;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                neg_arr.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                pos_arr.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n        for(i=0 ; i<pos_arr.size() ; i++)\\n        {\\n            nums.push_back(pos_arr[i]);\\n            nums.push_back(neg_arr[i]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345861,
                "title": "java-solution-using-queue-interface-accepted",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) \\n    {\\n        //add positive elements of array in queue.\\n        Queue<Integer> pos = new LinkedList<>();\\n        for(int i : nums)\\n        {\\n            if(i>=0) pos.add(i);\\n        }\\n        //add negative elements of array in queue.\\n        Queue<Integer> neg = new LinkedList<>();\\n        for(int i : nums)\\n        {\\n            if(i<0) neg.add(i);\\n        }\\n        //adding positive and negative elements sequentially\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(i%2==0) nums[i]=pos.poll();\\n\\n            else\\n            {\\n                nums[i]=neg.poll();\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```\\n# \\u2B06\\uFE0FUpvote if you like the solution",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) \\n    {\\n        //add positive elements of array in queue.\\n        Queue<Integer> pos = new LinkedList<>();\\n        for(int i : nums)\\n        {\\n            if(i>=0) pos.add(i);\\n        }\\n        //add negative elements of array in queue.\\n        Queue<Integer> neg = new LinkedList<>();\\n        for(int i : nums)\\n        {\\n            if(i<0) neg.add(i);\\n        }\\n        //adding positive and negative elements sequentially\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(i%2==0) nums[i]=pos.poll();\\n\\n            else\\n            {\\n                nums[i]=neg.poll();\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209480,
                "title": "c-simple-solution-using-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n      vector<int> res(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                res[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                res[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n      vector<int> res(n,0);\\n        int indexpos = 0, indexneg=1;\\n        for(auto num: nums){\\n            if(num>0){\\n                res[indexpos] = num;\\n                indexpos+=2;\\n            }\\n            if(num<0){\\n                res[indexneg] = num;\\n                indexneg += 2;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185895,
                "title": "two-pointers-and-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar rearrangeArray = function(nums) {\\n    let i=0, j=1;\\n    let res=[];\\n\\n    for(let n of nums){\\n        if(n>0){//if n is positive number new arrary res[] first number is n\\n            res[i]=n\\n            i+=2;\\n        } else{\\n            res[j]=n;\\n            j+=2;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar rearrangeArray = function(nums) {\\n    let i=0, j=1;\\n    let res=[];\\n\\n    for(let n of nums){\\n        if(n>0){//if n is positive number new arrary res[] first number is n\\n            res[i]=n\\n            i+=2;\\n        } else{\\n            res[j]=n;\\n            j+=2;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3021410,
                "title": "c-solution-easy-to-understand-array",
                "content": "Runtime: 228 ms, faster than 92.58% of C++ online submissions for Rearrange Array Elements by Sign.\\nMemory Usage: 123.8 MB, less than 94.97% of C++ online submissions for Rearrange Array Elements by Sign.\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n            int pi=0,i2=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                ans[pi]=nums[i];\\n                pi=pi+2;\\n            }\\n             else {\\n                 ans[i2]=nums[i];\\n                 i2=i2+2;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n            int pi=0,i2=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                ans[pi]=nums[i];\\n                pi=pi+2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2902119,
                "title": "3-down-to-up-stage-solution",
                "content": "@LEE BOSS\\n        After Solving qustions i watch @Lee submittion...Everytime i got something new and i tried to implement this in my code gives me a lot of confidence. Thanks @Lee Sir\\n\\n\\n        \\'\\'\\'    1st ONE\\n        pos=[po for po in nums if po > 0]\\n        neg=[ne for ne in nums if ne < 0]\\n        res=[]\\n        for p, n in zip_longest(pos, neg):\\n            res += [p, n]\\n        return res\\n        \\'\\'\\'\\n        ZIP_LONGEST:-\\n                     Res stores the value of iterables alternatively in sequence. If one of the iterables is stored fully, the remaining values are filled by the values assigned to fillvalue parameter.\\n        \\n\\'\\'\\'\\n@Coder_Harshit  \\n...2nd One...\\n        res=[0]*len(nums)\\n        pos,neg=0,1\\n        for i in nums:\\n            if i > 0:\\n                res[pos]=i\\n                pos+=2\\n            else:\\n                res[neg]=i\\n                neg+=2\\n        return res\\n        \\'\\'\\'\\n        \\'\\'\\'\\n...3rd One.....\\n        neg,pos,res=[],[],[]\\n        for i in nums:\\n            if i < 0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        i=0\\n        while i < len(neg) and i < len(pos):\\n            res.append(pos[i])\\n            res.append(neg[i])\\n            i+=1\\n        while i < len(pos):\\n            res.append(pos[i])\\n            i+=1\\n        while(i < len(neg)):\\n            res.append(neg[i])\\n            i+=1\\n        return res\\n        \\'\\'\\'",
                "solutionTags": [
                    "Python3"
                ],
                "code": "@LEE BOSS\\n        After Solving qustions i watch @Lee submittion...Everytime i got something new and i tried to implement this in my code gives me a lot of confidence. Thanks @Lee Sir\\n\\n\\n        \\'\\'\\'    1st ONE\\n        pos=[po for po in nums if po > 0]\\n        neg=[ne for ne in nums if ne < 0]\\n        res=[]\\n        for p, n in zip_longest(pos, neg):\\n            res += [p, n]\\n        return res\\n        \\'\\'\\'\\n        ZIP_LONGEST:-\\n                     Res stores the value of iterables alternatively in sequence. If one of the iterables is stored fully, the remaining values are filled by the values assigned to fillvalue parameter.\\n        \\n\\'\\'\\'\\n@Coder_Harshit  \\n...2nd One...\\n        res=[0]*len(nums)\\n        pos,neg=0,1\\n        for i in nums:\\n            if i > 0:\\n                res[pos]=i\\n                pos+=2\\n            else:\\n                res[neg]=i\\n                neg+=2\\n        return res\\n        \\'\\'\\'\\n        \\'\\'\\'\\n...3rd One.....\\n        neg,pos,res=[],[],[]\\n        for i in nums:\\n            if i < 0:\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        i=0\\n        while i < len(neg) and i < len(pos):\\n            res.append(pos[i])\\n            res.append(neg[i])\\n            i+=1\\n        while i < len(pos):\\n            res.append(pos[i])\\n            i+=1\\n        while(i < len(neg)):\\n            res.append(neg[i])\\n            i+=1\\n        return res\\n        \\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2863509,
                "title": "c-o-n-stack-approach-easy-to-understand",
                "content": "# Intuition\\nAccording to the condition a think strike the mind which ds is better for operation.Tried for a new approach\\n# Approach\\nBy using stack it helps me to not to voilate the condition you can go through\\n\\nfirstly , I store pos values in stack & then neg values from end\\nThen i traverse from start and Since to place with Pos number i start placing numbers accordingly\\n\\nKindly Give Ur Reviews...ThankYou\\n\\n# Complexity\\n- Time complexity:\\nO(N) Approx\\n\\n- Space complexity:\\nO(N) Approx\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        stack<int> pos;\\n        stack<int> neg;\\n        int n = nums.size();\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(nums[i] > 0) pos.push(nums[i]);\\n            else neg.push(nums[i]);\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n            if(i%2==0){nums[i] = pos.top(); pos.pop();}\\n            else {nums[i] = neg.top();neg.pop();}\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        stack<int> pos;\\n        stack<int> neg;\\n        int n = nums.size();\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(nums[i] > 0) pos.push(nums[i]);\\n            else neg.push(nums[i]);\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n            if(i%2==0){nums[i] = pos.top(); pos.pop();}\\n            else {nums[i] = neg.top();neg.pop();}\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760087,
                "title": "java-solution-very-happy",
                "content": "# class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        ArrayList<Integer> a=new ArrayList<>();\\n        ArrayList<Integer> b=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=0)\\n            {\\n                a.add(nums[i]);\\n            }else{\\n                b.add(nums[i]);\\n            }\\n        }\\n        int k=0,l=0;\\n        for(int i=0;i<ans.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                ans[i]=a.get(k);\\n                k++;\\n            }else{\\n                ans[i]=b.get(l);\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        ArrayList<Integer> a=new ArrayList<>();\\n        ArrayList<Integer> b=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]>=0)\\n            {\\n                a.add(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2747572,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        int j=0,k=1;\\n        for(int i:nums)\\n        {\\n           if(i>0)\\n           {\\n               ans[j]=i;\\n               j=j+2;\\n           }\\n            else\\n            {\\n                ans[k]=i;\\n                k=k+2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        int j=0,k=1;\\n        for(int i:nums)\\n        {\\n           if(i>0)\\n           {\\n               ans[j]=i;\\n               j=j+2;\\n           }\\n            else\\n            {\\n                ans[k]=i;\\n                k=k+2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687253,
                "title": "java-2-solutions",
                "content": "### **Please Upvote** :D\\n##### 1. Using arraylists (TLE - 290/291 passed):\\nStore negative and positive elements in order in separate arraylists and put them back in order in ans array.\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        List<Integer> neg = new ArrayList<>(),\\n        pos = new ArrayList<>();\\n\\n        for (int n : nums) {\\n            if (n > 0) pos.add(n);\\n            else neg.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = pos.remove(0);\\n            else nums[i] = neg.remove(0);\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) => O(n ^ 2) - arraylist remove() takes O(n) complexity\\n// SC: O(n + n) => O(n)\\n```\\n##### 2. Optimal Solution:\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int positiveIdx = 0, negativeIdx = 1;\\n\\n        for (int n : nums) {\\n            if (n > 0) {\\n                ans[positiveIdx] = n;\\n                positiveIdx += 2;\\n            }\\n            else {\\n                ans[negativeIdx] = n;\\n                negativeIdx += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        List<Integer> neg = new ArrayList<>(),\\n        pos = new ArrayList<>();\\n\\n        for (int n : nums) {\\n            if (n > 0) pos.add(n);\\n            else neg.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = pos.remove(0);\\n            else nums[i] = neg.remove(0);\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) => O(n ^ 2) - arraylist remove() takes O(n) complexity\\n// SC: O(n + n) => O(n)\\n```\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int positiveIdx = 0, negativeIdx = 1;\\n\\n        for (int n : nums) {\\n            if (n > 0) {\\n                ans[positiveIdx] = n;\\n                positiveIdx += 2;\\n            }\\n            else {\\n                ans[negativeIdx] = n;\\n                negativeIdx += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648203,
                "title": "python-easy-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        n=len(nums)//2\\n        for i in nums:\\n            if i>0:\\n                a.append(i)\\n            else:\\n                b.append(i)\\n        for i in range(n):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        n=len(nums)//2\\n        for i in nums:\\n            if i>0:\\n                a.append(i)\\n            else:\\n                b.append(i)\\n        for i in range(n):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611675,
                "title": "runtime-o-n-python-solution",
                "content": "*using the fact that all the positive values will be at even indexes and negative values at odd indexes  or vice versa \\n*the number of positives and negatives is equal \\nwe put  the first  positive value at index 0 in order in which they appear and increment the pointer by 2 to point at the positon of the next positive number\\nsame for negative values starting with index 1.\\n\\nTime complexity-O(n)\\nspace complexity-O(n) for the list to be returned(ret)\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        i=0\\n        j =1\\n        n =len(nums)\\n        ret =[0]*n\\n        for x in nums:\\n            if x>0:\\n                ret[i]=x\\n                i+=2 \\n            else:\\n                ret[j]=x\\n                j+=2\\n        return ret\\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        i=0\\n        j =1\\n        n =len(nums)\\n        ret =[0]*n\\n        for x in nums:\\n            if x>0:\\n                ret[i]=x\\n                i+=2 \\n            else:\\n                ret[j]=x\\n                j+=2\\n        return ret\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561538,
                "title": "java-solution-easy-approach",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tpublic int[] rearrangeArray(int[] nums) {\\n\\t\\t\\t\\tint n = nums.length;\\n\\t\\t\\t\\tint arr[] = new int[n];\\n\\t\\t\\t\\tint p = 0;//positive values\\n\\t\\t\\t\\tint ng = 1;//negatives value\\n\\t\\t\\t\\tint i = 0;\\n\\t\\t\\t\\twhile(i < n){\\n\\t\\t\\t\\t\\tif(nums[i] >0){\\n\\t\\t\\t\\t\\t\\tarr[p] = nums[i];\\n\\t\\t\\t\\t\\t\\tp=p+2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tarr[ng]= nums[i];\\n\\t\\t\\t\\t\\t\\tng=ng +2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn arr;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic int[] rearrangeArray(int[] nums) {\\n\\t\\t\\t\\tint n = nums.length;\\n\\t\\t\\t\\tint arr[] = new int[n];\\n\\t\\t\\t\\tint p = 0;//positive values\\n\\t\\t\\t\\tint ng = 1;//negatives value\\n\\t\\t\\t\\tint i = 0;\\n\\t\\t\\t\\twhile(i < n){\\n\\t\\t\\t\\t\\tif(nums[i] >0){\\n\\t\\t\\t\\t\\t\\tarr[p] = nums[i];\\n\\t\\t\\t\\t\\t\\tp=p+2;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2484965,
                "title": "easy-to-understand-solved-using-indexes-java-code",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        int ix=0,ix1=1;\\n        for(int num:nums){\\n            if(num>0){\\n                ans[ix]=num;\\n                ix+=2;\\n            }else{\\n                ans[ix1]=num;\\n                ix1+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        int ix=0,ix1=1;\\n        for(int num:nums){\\n            if(num>0){\\n                ans[ix]=num;\\n                ix+=2;\\n            }else{\\n                ans[ix1]=num;\\n                ix1+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482789,
                "title": "c-brute-force-method",
                "content": "**Store values in positive and negative vectors and push in the resultant vector.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        vector<int> res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n                pos.push_back(nums[i]);\\n            else if(nums[i]<0)\\n                neg.push_back(nums[i]);\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<nums.size())\\n        {\\n            if(i%2==0){\\n                res.push_back(pos[j]);\\n                j++;\\n            }\\n            else\\n            {\\n                res.push_back(neg[k]);\\n                k++;    \\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> pos;\\n        vector<int> neg;\\n        vector<int> res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n                pos.push_back(nums[i]);\\n            else if(nums[i]<0)\\n                neg.push_back(nums[i]);\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<nums.size())\\n        {\\n            if(i%2==0){\\n                res.push_back(pos[j]);\\n                j++;\\n            }\\n            else\\n            {\\n                res.push_back(neg[k]);\\n                k++;    \\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341521,
                "title": "java-easiest-solution-5ms-runtime-o-n-approach-without-pointers",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] posit = new int[nums.length/2];\\n        int[] negit = new int[nums.length/2];\\n        int p=0,n=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] < 0){\\n                negit[n] = nums[i];\\n                n++;\\n            }\\n            else{\\n                posit[p] = nums[i];\\n                p++;\\n            }\\n        }\\n        boolean last = true;\\n        p=0;n=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(last){\\n                nums[i] = posit[p];\\n                p++;\\n                last = false;\\n            }\\n            else{\\n                nums[i] = negit[n];\\n                n++;\\n                last= true;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] posit = new int[nums.length/2];\\n        int[] negit = new int[nums.length/2];\\n        int p=0,n=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] < 0){\\n                negit[n] = nums[i];\\n                n++;\\n            }\\n            else{\\n                posit[p] = nums[i];\\n                p++;\\n            }\\n        }\\n        boolean last = true;\\n        p=0;n=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(last){\\n                nums[i] = posit[p];\\n                p++;\\n                last = false;\\n            }\\n            else{\\n                nums[i] = negit[n];\\n                n++;\\n                last= true;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253476,
                "title": "javascript-two-pointers",
                "content": "```\\nvar rearrangeArray = function(nums) {\\n   let result = Array(nums.length).fill(0);\\n    let posIdx = 0, negIdx = 1;\\n   for(let i=0;i<nums.length;i++) {\\n       if(nums[i]>0) {\\n           result[posIdx] = nums[i]\\n           posIdx +=2;\\n       } else {\\n            result[negIdx] = nums[i]\\n           negIdx +=2;\\n       }\\n   }\\n    return result;\\n };\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar rearrangeArray = function(nums) {\\n   let result = Array(nums.length).fill(0);\\n    let posIdx = 0, negIdx = 1;\\n   for(let i=0;i<nums.length;i++) {\\n       if(nums[i]>0) {\\n           result[posIdx] = nums[i]\\n           posIdx +=2;\\n       } else {\\n            result[negIdx] = nums[i]\\n           negIdx +=2;\\n       }\\n   }\\n    return result;\\n };\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231255,
                "title": "c-o-n-two-pointers-easy-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        // take an array to store final ans of size equal to that of original array.\\n        vector<int> ans(nums.size());\\n\\t\\t// create two pointers to track next positive and negative positions in \\'ans\\' array.\\n        int pos = 0; // first positive pointer in ans array will be index 0. \\n\\t\\tint neg = 1; // first negative pointer in ans array will be index 1.\\n\\t\\t\\n\\t\\t// iterate over all elements of original array and the check if it is positive or negative.\\n\\t\\t// if it is positive, place it at the positive index else at negative index in \\'ans\\' array.\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i] < 0) {\\n                ans[neg] = nums[i];\\n                neg += 2; // next negative index will be after one positive index in ans array.\\n            }else {\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        // take an array to store final ans of size equal to that of original array.\\n        vector<int> ans(nums.size());\\n\\t\\t// create two pointers to track next positive and negative positions in \\'ans\\' array.\\n        int pos = 0; // first positive pointer in ans array will be index 0. \\n\\t\\tint neg = 1; // first negative pointer in ans array will be index 1.\\n\\t\\t\\n\\t\\t// iterate over all elements of original array and the check if it is positive or negative.\\n\\t\\t// if it is positive, place it at the positive index else at negative index in \\'ans\\' array.\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i] < 0) {\\n                ans[neg] = nums[i];\\n                neg += 2; // next negative index will be after one positive index in ans array.\\n            }else {\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175407,
                "title": "java-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] arr) {\\n        int n = arr.length;\\n        int [] ans = new int[n];\\n        int start =0;\\n        int end = 1;\\n        for(int i=0; i<n; i++){\\n            if(arr[i] >=0){\\n                ans[start] = arr[i];\\n                start+=2;\\n                \\n            }\\n            else{\\n                ans[end] = arr[i];\\n                end+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] arr) {\\n        int n = arr.length;\\n        int [] ans = new int[n];\\n        int start =0;\\n        int end = 1;\\n        for(int i=0; i<n; i++){\\n            if(arr[i] >=0){\\n                ans[start] = arr[i];\\n                start+=2;\\n                \\n            }\\n            else{\\n                ans[end] = arr[i];\\n                end+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991002,
                "title": "python3-runtime-1756ms-64-56-memory-45-2mb-54-13",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        \\n        newArray = [0] * len(nums)\\n        i, j = 0, 1\\n        for num in nums:\\n            if num > 0:\\n                newArray[i] = num\\n                i += 2\\n            else:\\n                newArray[j] = num\\n                j += 2\\n                \\n        return newArray\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        \\n        newArray = [0] * len(nums)\\n        i, j = 0, 1\\n        for num in nums:\\n            if num > 0:\\n                newArray[i] = num\\n                i += 2\\n            else:\\n                newArray[j] = num\\n                j += 2\\n                \\n        return newArray\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902831,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int[] rearrangeArray(int[] n) {\\n        int k=n.length,j=0,f=1;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]<0)\\n            {\\n                b[f]=n[i];\\n                f+=2;\\n            }\\n            else\\n            {\\n                b[j]=n[i];\\n                j+=2;\\n            }\\n        }\\n        return b;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] rearrangeArray(int[] n) {\\n        int k=n.length,j=0,f=1;\\n        int b[]=new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            if(n[i]<0)\\n            {\\n                b[f]=n[i];\\n                f+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1830026,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        positive = []\\n        negative = []\\n        \\n        for num in nums:\\n            if num > 0:\\n                positive.append(num)\\n            else:\\n                negative.append(num)\\n                \\n        result = [None] * len(nums)\\n        result[::2] = positive\\n        result[1::2] = negative\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        positive = []\\n        negative = []\\n        \\n        for num in nums:\\n            if num > 0:\\n                positive.append(num)\\n            else:\\n                negative.append(num)\\n                \\n        result = [None] * len(nums)\\n        result[::2] = positive\\n        result[1::2] = negative\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820957,
                "title": "c-beats-80-of-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       vector<int> posi;\\n       vector<int> negi;\\n       for(int i = 0;i<nums.size();i++){\\n           if(nums[i]>0) posi.push_back(nums[i]);\\n           else if(nums[i]<0) negi.push_back(nums[i]);\\n       }\\n        vector<int> ans;\\n        int cnt = 0;\\n        for(int i = 0;i<nums.size();i++){\\n         if(i%2==0) ans.push_back(posi[cnt]);\\n         if(i%2!=0) {\\n             ans.push_back(negi[cnt]);\\n             cnt++;\\n         }\\n       }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       vector<int> posi;\\n       vector<int> negi;\\n       for(int i = 0;i<nums.size();i++){\\n           if(nums[i]>0) posi.push_back(nums[i]);\\n           else if(nums[i]<0) negi.push_back(nums[i]);\\n       }\\n        vector<int> ans;\\n        int cnt = 0;\\n        for(int i = 0;i<nums.size();i++){\\n         if(i%2==0) ans.push_back(posi[cnt]);\\n         if(i%2!=0) {\\n             ans.push_back(negi[cnt]);\\n             cnt++;\\n         }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747887,
                "title": "c-two-pointer-solution-o-n",
                "content": "**Upvote if you found solution helpful for you**\\n```C++\\nclass Solution\\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int> &nums)\\n    {\\n        vector<int> res = nums;\\n        int pos = 0, neg = 1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 0)\\n            {\\n                res[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else\\n            {\\n                res[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int> &nums)\\n    {\\n        vector<int> res = nums;\\n        int pos = 0, neg = 1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 0)\\n            {\\n                res[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else\\n            {\\n                res[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727092,
                "title": "c-easy-2-pointer-solution-85-runtime",
                "content": "```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums) {\\n        int[] ret = new int[nums.Length];\\n        int positive=0;\\n        int negative = 1;\\n        \\n        foreach(int num in nums){\\n            if(num>0){\\n                ret[positive]=num;\\n                positive+=2;\\n            }else{\\n                ret[negative]=num;\\n                negative+=2;\\n            }\\n        }\\n        return ret;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] RearrangeArray(int[] nums) {\\n        int[] ret = new int[nums.Length];\\n        int positive=0;\\n        int negative = 1;\\n        \\n        foreach(int num in nums){\\n            if(num>0){\\n                ret[positive]=num;\\n                positive+=2;\\n            }else{\\n                ret[negative]=num;\\n                negative+=2;\\n            }\\n        }\\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712489,
                "title": "javascript-intutive-solution",
                "content": "**Please upvote If you find this solution useful :))**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar rearrangeArray = function(nums) {\\n    let result = [];\\n    let l=0;\\n    let r=0;\\n    while(result.length !== nums.length){\\n         while( nums[l]< 0){\\n              l++\\n          }\\n        while( nums[r]> 0){\\n              r++\\n         }\\n        \\n        result.push(nums[l], nums[r]);\\n        l++;\\n        r++;\\n    }\\n    return result\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar rearrangeArray = function(nums) {\\n    let result = [];\\n    let l=0;\\n    let r=0;\\n    while(result.length !== nums.length){\\n         while( nums[l]< 0){\\n              l++\\n          }\\n        while( nums[r]> 0){\\n              r++\\n         }\\n        \\n        result.push(nums[l], nums[r]);\\n        l++;\\n        r++;\\n    }\\n    return result\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1712045,
                "title": "c-o-n-easy",
                "content": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int x=0,y=1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0){\\n               res[x] = nums[i]; x+=2;\\n            }\\n            else {\\n                res[y] = nums[i]; y+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int x=0,y=1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i]>0){\\n               res[x] = nums[i]; x+=2;\\n            }\\n            else {\\n                res[y] = nums[i]; y+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711346,
                "title": "python-o-n-with-2-pointers",
                "content": "```\\nclass Solution:    \\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        L = len(nums)\\n        pIdx, nIdx = 0, 0\\n        idx = 0\\n        ans = [0] * L\\n        while pIdx < L and nIdx <L:\\n            while nums[pIdx] < 0:\\n                pIdx += 1\\n            ans[idx] = nums[pIdx]\\n            pIdx += 1\\n            idx += 1\\n            while nums[nIdx] > 0:\\n                nIdx += 1\\n            ans[idx] = nums[nIdx]\\n            nIdx += 1\\n            idx +=1\\n        return ans  \\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:    \\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        L = len(nums)\\n        pIdx, nIdx = 0, 0\\n        idx = 0\\n        ans = [0] * L\\n        while pIdx < L and nIdx <L:\\n            while nums[pIdx] < 0:\\n                pIdx += 1\\n            ans[idx] = nums[pIdx]\\n            pIdx += 1\\n            idx += 1\\n            while nums[nIdx] > 0:\\n                nIdx += 1\\n            ans[idx] = nums[nIdx]\\n            nIdx += 1\\n            idx +=1\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060619,
                "title": "java-for-beginners-easy-approach",
                "content": "# PLEASE UPVOTE\\n# Complexity\\n- Time complexity:O(n)+O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int []plus=new int[nums.length/2];\\n        int []minus=new int[nums.length/2];\\n        int a=0,b=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=0){\\n                plus[a++]=nums[i];\\n            }\\n            if(nums[i]<0){\\n                minus[b++]=nums[i];\\n            }\\n        }\\n        a=0;\\n        for(int j=0;j<nums.length;j+=2){\\n            nums[j]=plus[a];\\n            nums[j+1]=minus[a];\\n            a++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int []plus=new int[nums.length/2];\\n        int []minus=new int[nums.length/2];\\n        int a=0,b=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=0){\\n                plus[a++]=nums[i];\\n            }\\n            if(nums[i]<0){\\n                minus[b++]=nums[i];\\n            }\\n        }\\n        a=0;\\n        for(int j=0;j<nums.length;j+=2){\\n            nums[j]=plus[a];\\n            nums[j+1]=minus[a];\\n            a++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919813,
                "title": "best-approach-t-c-o-n-s-c-o-n-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<int>ans(n,0);\\n        int posIndex=0;\\n        int negIndex=1;\\n        for(auto it:nums){\\n            if(it>0){\\n                ans[posIndex]=it;\\n                posIndex+=2;\\n            }\\n            else{\\n                 ans[negIndex]=it;\\n                negIndex+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n        vector<int>ans(n,0);\\n        int posIndex=0;\\n        int negIndex=1;\\n        for(auto it:nums){\\n            if(it>0){\\n                ans[posIndex]=it;\\n                posIndex+=2;\\n            }\\n            else{\\n                 ans[negIndex]=it;\\n                negIndex+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896335,
                "title": "c-easy-solution",
                "content": "# Approach \\n-   In this approach we are going to create an empty vector and fill it up.\\n\\n\\n\\n-   We are going to fill it up by using 2 indexes one is a positve index and another is a negative index. Positive index will be initalised as 0 and negative index will be initalised by 1.\\n- Whenever a positve element is encountered we update the postive index of new vector and increment it by 2. Same operation is done with negative index whenever negative element is encounterd. \\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(N)** Traversal done in a single sweep. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)** A new Vector is created.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n\\n        int pos = 0; \\n        int neg = 1;\\n        int n = nums.size();\\n        //Declare a vector of size n and empty values 0.\\n        vector<int> v(n,0); \\n\\n        for(int i = 0; n > i; i++) \\n        {\\n            if(nums[i] >= 0)\\n            {\\n                v[pos] = nums[i];\\n                pos += 2; \\n            }\\n            else \\n            {\\n                v[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n\\n        int pos = 0; \\n        int neg = 1;\\n        int n = nums.size();\\n        //Declare a vector of size n and empty values 0.\\n        vector<int> v(n,0); \\n\\n        for(int i = 0; n > i; i++) \\n        {\\n            if(nums[i] >= 0)\\n            {\\n                v[pos] = nums[i];\\n                pos += 2; \\n            }\\n            else \\n            {\\n                v[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866637,
                "title": "easy-to-understand-99-beats-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos=0;int neg=1;\\n        vector<int> ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n             ans[neg]=nums[i];\\n             neg+=2;\\n            }\\n            else{\\n             ans[pos]=nums[i];\\n             pos+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos=0;int neg=1;\\n        vector<int> ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n             ans[neg]=nums[i];\\n             neg+=2;\\n            }\\n            else{\\n             ans[pos]=nums[i];\\n             pos+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865160,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> rearrangeArray(vector<int>& nums) {\\n    vector<int> negative;\\n    vector<int> positive;\\n    vector<int> ans;\\n    \\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) {\\n            negative.push_back(nums[i]);\\n        } else {\\n            positive.push_back(nums[i]);\\n        }\\n    }\\n    int negIndex = 0;\\n    int posIndex = 0;\\n    while (negIndex < negative.size() && posIndex < positive.size()) {\\n        ans.push_back(positive[posIndex++]);\\n        ans.push_back(negative[negIndex++]);\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> rearrangeArray(vector<int>& nums) {\\n    vector<int> negative;\\n    vector<int> positive;\\n    vector<int> ans;\\n    \\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) {\\n            negative.push_back(nums[i]);\\n        } else {\\n            positive.push_back(nums[i]);\\n        }\\n    }\\n    int negIndex = 0;\\n    int posIndex = 0;\\n    while (negIndex < negative.size() && posIndex < positive.size()) {\\n        ans.push_back(positive[posIndex++]);\\n        ans.push_back(negative[negIndex++]);\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794137,
                "title": "simple-and-easy-to-understand-like-if-you-got-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> num1(n/2);\\n        vector <int> num2(n/2);\\n        int j=0,k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n                if(nums[i]>=0)\\n                {\\n                    num1[j++]=nums[i];\\n                }\\n                else\\n                {\\n                    num2[k++]=nums[i];\\n                }\\n        }\\n\\n        vector<int>num3(n);\\n        int p=0,q=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                num3[i]=num1[p++];\\n            }\\n            if(i%2!=0)\\n            {\\n                num3[i]=num2[q++];\\n            }\\n        }\\n        return num3;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> num1(n/2);\\n        vector <int> num2(n/2);\\n        int j=0,k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n                if(nums[i]>=0)\\n                {\\n                    num1[j++]=nums[i];\\n                }\\n                else\\n                {\\n                    num2[k++]=nums[i];\\n                }\\n        }\\n\\n        vector<int>num3(n);\\n        int p=0,q=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                num3[i]=num1[p++];\\n            }\\n            if(i%2!=0)\\n            {\\n                num3[i]=num2[q++];\\n            }\\n        }\\n        return num3;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703136,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* rearrangeArray(int* nums, int numsSize, int* returnSize){\\nint* new=(int*)malloc(numsSize*sizeof(int));\\nint i,p=0,n=1;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>0)\\n    {\\n        new[p]=nums[i];\\n        p=p+2;\\n\\n    }\\n    else if(nums[i]<0)\\n    {\\n        new[n]=nums[i];\\n        n=n+2;\\n    }\\n}\\n*returnSize= numsSize;\\nreturn new;\\nfree(new);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* rearrangeArray(int* nums, int numsSize, int* returnSize){\\nint* new=(int*)malloc(numsSize*sizeof(int));\\nint i,p=0,n=1;\\nfor(i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>0)\\n    {\\n        new[p]=nums[i];\\n        p=p+2;\\n\\n    }\\n    else if(nums[i]<0)\\n    {\\n        new[n]=nums[i];\\n        n=n+2;\\n    }\\n}\\n*returnSize= numsSize;\\nreturn new;\\nfree(new);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671204,
                "title": "easy-beginner-friendly-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->first of all we have to seperate the positive and negative terms from the given array...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->then after seperating them we see that  positive terms are on even places and negative terms are on odd places...\\n\\nso for even terms we use nums[2*i] and for odd terms we use [2*i+1]\\nand traverse the nums array till n/2 because we are using the inner variables in array 2i and 2i+1  .... Hope this helps\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N+N/2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N/2 + N/2) = O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n = nums.size();\\n        vector<int>pos;\\n        vector<int>neg;\\n        int posSize=pos.size();\\n        int negSize=neg.size();\\n// Seperating positive and negative indices\\n        for (int i=0;i<n;i++){\\n\\n            if(nums[i]>0){\\n\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n        // Now putting positive in even places and negative in odd places\\n        for(int i =0;i<n/2;i++){\\n\\n            nums[2*i]=pos[i];\\n            nums[2*i+1]=neg[i];\\n        }\\n\\n\\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n = nums.size();\\n        vector<int>pos;\\n        vector<int>neg;\\n        int posSize=pos.size();\\n        int negSize=neg.size();\\n// Seperating positive and negative indices\\n        for (int i=0;i<n;i++){\\n\\n            if(nums[i]>0){\\n\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n        // Now putting positive in even places and negative in odd places\\n        for(int i =0;i<n/2;i++){\\n\\n            nums[2*i]=pos[i];\\n            nums[2*i+1]=neg[i];\\n        }\\n\\n\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575819,
                "title": "beginners-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    separate positive and negative numbers in different array \\n    and join them together\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res= new int[nums.length];\\n        int[] p= new int[nums.length/2];\\n        int[] n= new int[nums.length/2];\\n        int i,j;\\n        i=j=0;\\n\\n         for(int num:nums){\\n            if(num>0){\\n                p[i++]=num;\\n                \\n            }else n[j++]=num;\\n        }\\n        int k=0;\\n        for(int l=0;l<nums.length;l+=2){\\n            res[l]=p[k];\\n            res[l+1]=n[k];\\n            k++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] res= new int[nums.length];\\n        int[] p= new int[nums.length/2];\\n        int[] n= new int[nums.length/2];\\n        int i,j;\\n        i=j=0;\\n\\n         for(int num:nums){\\n            if(num>0){\\n                p[i++]=num;\\n                \\n            }else n[j++]=num;\\n        }\\n        int k=0;\\n        for(int l=0;l<nums.length;l+=2){\\n            res[l]=p[k];\\n            res[l+1]=n[k];\\n            k++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515563,
                "title": "easy-two-pointer-approach-o-1-space-complexity",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake two pinters pos & neg and update them when countered positive and negative elements in the array.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int pos = 0, neg = 1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] >= 0){\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else{\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# PLEASE UPVOTE\\u2B06\\uFE0F\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int pos = 0, neg = 1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] >= 0){\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else{\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441068,
                "title": "easy-peasy-by-using-two-vectors",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> p;\\n        vector<int> n;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>0) p.push_back(nums[i]);\\n            else n.push_back(nums[i]);\\n        }\\n        nums.clear();\\n        for(int j=0; j<p.size(); j++){\\n            nums.push_back(p[j]);\\n            nums.push_back(n[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> p;\\n        vector<int> n;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>0) p.push_back(nums[i]);\\n            else n.push_back(nums[i]);\\n        }\\n        nums.clear();\\n        for(int j=0; j<p.size(); j++){\\n            nums.push_back(p[j]);\\n            nums.push_back(n[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320617,
                "title": "simplest-beginner-friendly-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        p, n = [x for x in nums if x > 0], [x for x in nums if x < 0]\\n        a = []\\n        for i in range(len(p)):\\n            a.append(p[i])\\n            a.append(n[i])\\n        return a    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        p, n = [x for x in nums if x > 0], [x for x in nums if x < 0]\\n        a = []\\n        for i in range(len(p)):\\n            a.append(p[i])\\n            a.append(n[i])\\n        return a    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271350,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ne;\\n        vector<int>po;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>0){\\n                po.push_back(nums[i]);\\n\\n            }\\n            else{\\n                ne.push_back(nums[i]);\\n            }\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(i%2==0){\\n                ans.push_back(po[k]);\\n                k++;\\n            }\\n            else{\\n                ans.push_back(ne[l]);\\n                l++;\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ne;\\n        vector<int>po;\\n        vector<int>ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]>0){\\n                po.push_back(nums[i]);\\n\\n            }\\n            else{\\n                ne.push_back(nums[i]);\\n            }\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(i%2==0){\\n                ans.push_back(po[k]);\\n                k++;\\n            }\\n            else{\\n                ans.push_back(ne[l]);\\n                l++;\\n            }\\n        }\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237474,
                "title": "simple-solution-for-begginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>v1,v2;\\n        int n=nums.size()/2;\\n        for(auto it:nums) {\\n            if(it>0) v1.push_back(it);\\n        }\\n        for(auto it:nums){\\n            if(it<0)v2.push_back(it);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(v1[i]);\\n             ans.push_back(v2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>v1,v2;\\n        int n=nums.size()/2;\\n        for(auto it:nums) {\\n            if(it>0) v1.push_back(it);\\n        }\\n        for(auto it:nums){\\n            if(it<0)v2.push_back(it);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(v1[i]);\\n             ans.push_back(v2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091137,
                "title": "precise-concise-and-most-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> v1,v2,v3;\\n        for(auto i:nums){\\n            if(i<0) v1.push_back(i);\\n            else v2.push_back(i);\\n        }\\n        for(int i=0;i<v1.size();i++){\\n            v3.push_back(v2[i]);\\n            v3.push_back(v1[i]);\\n        }\\n        return v3;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> v1,v2,v3;\\n        for(auto i:nums){\\n            if(i<0) v1.push_back(i);\\n            else v2.push_back(i);\\n        }\\n        for(int i=0;i<v1.size();i++){\\n            v3.push_back(v2[i]);\\n            v3.push_back(v1[i]);\\n        }\\n        return v3;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074285,
                "title": "terse-python-solution-with-slicing-beats-96",
                "content": "I see a lot of solutions in Python using 2 pointers or zip to solve this problem. I quickly came with this short solution using slicing that is as fast. I personally find this easier to understand if you are familiar with slicing.\\n\\nFor those who arent, [::2] means all indexes starting from 0 until the end of the array in steps of 2 (even), and [1::2] is all indexes starting from 1 until the end in steps of 2 (odd).\\n\\n# Code\\n```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        result = [0]*len(nums)\\n        result[::2] = [n for n in nums if n > 0]\\n        result[1::2] = [n for n in nums if n < 0]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        result = [0]*len(nums)\\n        result[::2] = [n for n in nums if n > 0]\\n        result[1::2] = [n for n in nums if n < 0]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067045,
                "title": "simple-and-optimized-and-easy-to-understand-solution-in-java",
                "content": "...\\nSimple Java Code:-\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int posindex=0,negindex=1;\\n        int n=nums.length;\\n        int[] a=new int[n+1];\\n        int m=a.length;\\n     for(int i=0;i<n;i++)  {         \\n            if(nums[i]>0){\\n                a[posindex]=nums[i];\\n                posindex+=2;}\\n            else if(nums[i]<0){\\n                a[negindex]=nums[i];\\n                negindex+=2;\\n            }}\\n         System.arraycopy(a,0,nums,0,m-1);\\n                \\n            \\n\\n        \\n     return nums;\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int posindex=0,negindex=1;\\n        int n=nums.length;\\n        int[] a=new int[n+1];\\n        int m=a.length;\\n     for(int i=0;i<n;i++)  {         \\n            if(nums[i]>0){\\n                a[posindex]=nums[i];\\n                posindex+=2;}",
                "codeTag": "Java"
            },
            {
                "id": 2971567,
                "title": "simple-and-easy-o-n-extra-space-in-1-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>vec(n,0);\\n        int pos = 0 , neg = 1;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<0){\\n                vec[neg] = nums[i];\\n                neg+=2;\\n            }\\n            else{\\n                vec[pos] = nums[i];\\n                pos+=2;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>vec(n,0);\\n        int pos = 0 , neg = 1;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<0){\\n                vec[neg] = nums[i];\\n                neg+=2;\\n            }\\n            else{\\n                vec[pos] = nums[i];\\n                pos+=2;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842543,
                "title": "o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& a) {\\n        int n  = a.size();\\n        int m  = n/2;\\n        vector<int> e,o;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<0)\\n            {\\n                o.push_back(a[i]);\\n            }\\n            else\\n                e.push_back(a[i]);\\n        }\\n        \\n        \\n        int i,j,k;\\n        i=j=k=0;\\n        bool f = true;\\n        while(i<m || j<m)\\n        {\\n            if(f)\\n            {\\n                a[k] = e[i];\\n                i++;\\n                k++;\\n                f=false;\\n            }\\n            else\\n            {\\n                a[k] = o[j];\\n                j++;\\n                k++;\\n                f= true;\\n            }\\n        }\\n        \\n        return a;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& a) {\\n        int n  = a.size();\\n        int m  = n/2;\\n        vector<int> e,o;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]<0)\\n            {\\n                o.push_back(a[i]);\\n            }\\n            else\\n                e.push_back(a[i]);\\n        }\\n        \\n        \\n        int i,j,k;\\n        i=j=k=0;\\n        bool f = true;\\n        while(i<m || j<m)\\n        {\\n            if(f)\\n            {\\n                a[k] = e[i];\\n                i++;\\n                k++;\\n                f=false;\\n            }\\n            else\\n            {\\n                a[k] = o[j];\\n                j++;\\n                k++;\\n                f= true;\\n            }\\n        }\\n        \\n        return a;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754799,
                "title": "java-simple-solution-using-constant-space",
                "content": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int len=(nums.length)/2;\\n        int posarr[]=new int[len];\\n        int negarr[]=new int[len];\\n\\n        int l=0;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                posarr[l++]=nums[i];\\n            }else{\\n                negarr[m++]=nums[i];\\n            }\\n        }\\n        l=0;\\n        m=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(i%2==0){\\n                nums[i]=posarr[l++];\\n            }else{\\n                nums[i]=negarr[m++];\\n            }\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int len=(nums.length)/2;\\n        int posarr[]=new int[len];\\n        int negarr[]=new int[len];\\n\\n        int l=0;\\n        int m=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                posarr[l++]=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2619858,
                "title": "python-solution-runtime-1547-ms-memory-usage-45-5-mb",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        result = [0] * len(nums)\\n        i, j = 0, 1\\n        \\n        for num in nums:\\n            if num >= 0:\\n                result[i] = num\\n                i += 2\\n            else:\\n                result[j] = num\\n                j += 2\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \\n        result = [0] * len(nums)\\n        i, j = 0, 1\\n        \\n        for num in nums:\\n            if num >= 0:\\n                result[i] = num\\n                i += 2\\n            else:\\n                result[j] = num\\n                j += 2\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613553,
                "title": "c-o-1-space-o-n-2-time-129-133-test-cases-passed",
                "content": "#### Everytime an element out of place is found, right rotate the sub array from the wrong number to the next requred number. \\n\\n##### {1, **2, 3, -4**, -1, 4} -> {1, **-4, 2, 3**, -1, -4} -> {1, -4, 2, **-4, 3, -1**)\\n```\\nclass Solution {\\npublic:\\n    \\n    void rot(vector<int>& nums, int i, bool fl)\\n    {\\n        int j;\\n        for( j=i+1;j<nums.size();j++) // Find the next required number\\n        {\\n            if(fl==true&&nums[j]>=0)\\n                break;\\n            else if(fl==false&&nums[j]<0)\\n                break;\\n        }\\n        \\n        if(j<nums.size())\\n        {\\n            int l = nums[j];\\n            for(int k = j-1;k>=i;k--)\\n            {\\n                nums[k+1] = nums[k];\\n            }\\n            nums[i] = l;\\n        }\\n    }\\n    \\n    \\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        bool fl = true; // To check if we need a positive or negative number.\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0&&nums[i]<0)\\n                rot(nums, i, fl);\\n            \\n            else if(i%2!=0&&nums[i]>=0)\\n                rot(nums, i, !fl);\\n        }\\n        \\n        return nums;\\n        \\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void rot(vector<int>& nums, int i, bool fl)\\n    {\\n        int j;\\n        for( j=i+1;j<nums.size();j++) // Find the next required number\\n        {\\n            if(fl==true&&nums[j]>=0)\\n                break;\\n            else if(fl==false&&nums[j]<0)\\n                break;\\n        }\\n        \\n        if(j<nums.size())\\n        {\\n            int l = nums[j];\\n            for(int k = j-1;k>=i;k--)\\n            {\\n                nums[k+1] = nums[k];\\n            }\\n            nums[i] = l;\\n        }\\n    }\\n    \\n    \\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        bool fl = true; // To check if we need a positive or negative number.\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0&&nums[i]<0)\\n                rot(nums, i, fl);\\n            \\n            else if(i%2!=0&&nums[i]>=0)\\n                rot(nums, i, !fl);\\n        }\\n        \\n        return nums;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611720,
                "title": "best-method-ever-easiest-faster-than-100-of-solutions",
                "content": "class Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos=[]\\n        neg=[]\\n        for i in nums:\\n            if(i<0):\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        ans=[]\\n        n=len(pos)\\n        for i in range(n):\\n            ans.append(pos[i])\\n            ans.append(neg[i])\\n        return ans    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        pos=[]\\n        neg=[]\\n        for i in nums:\\n            if(i<0):\\n                neg.append(i)\\n            else:\\n                pos.append(i)\\n        ans=[]\\n        n=len(pos)\\n        for i in range(n):\\n            ans.append(pos[i])\\n            ans.append(neg[i])\\n        return ans    \\n",
                "codeTag": "Java"
            },
            {
                "id": 2604490,
                "title": "with-explanation-comments-time-226-ms-97-78-space-123-7-mb-94-61",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\nTC: O(n)   //iterate the array\\nSC: O(2)   //initialize a new array\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        //initialize a new array with the same size of the given one & with initial values of 0s\\n        vector<int> res(nums.size(), 0);\\n        //initialize two pointers-> one for positive index & one for the negative\\n        int posInd=0, negInd=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            \\n            //check if the current element is positive\\n            if(num>0){\\n                //replace it by its correct position in the new array\\n                res[posInd]=num;\\n                //incremeant the positive pointer by 2\\n                posInd+=2;\\n            }\\n            else{\\n                //replace it by its correct position in the new array\\n                res[negInd]=num;\\n                //incremeant the positive pointer by 2\\n                negInd+=2;\\n            }\\n        }\\n        \\n        //return the new array values\\n        return res;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        //initialize a new array with the same size of the given one & with initial values of 0s\\n        vector<int> res(nums.size(), 0);\\n        //initialize two pointers-> one for positive index & one for the negative\\n        int posInd=0, negInd=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            \\n            //check if the current element is positive\\n            if(num>0){\\n                //replace it by its correct position in the new array\\n                res[posInd]=num;\\n                //incremeant the positive pointer by 2\\n                posInd+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2582567,
                "title": "java-solution",
                "content": "```\\npublic int[] rearrangeArray(int[] nums) {\\n        int pos = 0;\\n        int neg = 1;\\n        \\n        int[] res = new int[nums.length];\\n        \\n        for(var i : nums)\\n        {\\n            if(i>0)\\n            {\\n                res[pos] = i;\\n                pos=pos+2;\\n            }\\n            else\\n            {\\n                res[neg] = i;\\n                neg = neg + 2;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] rearrangeArray(int[] nums) {\\n        int pos = 0;\\n        int neg = 1;\\n        \\n        int[] res = new int[nums.length];\\n        \\n        for(var i : nums)\\n        {\\n            if(i>0)\\n            {\\n                res[pos] = i;\\n                pos=pos+2;\\n            }\\n            else\\n            {\\n                res[neg] = i;\\n                neg = neg + 2;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575482,
                "title": "easy-to-understand-using-basic-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> a(nums.size(),0);\\n        int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=0){\\n                a[k]=nums[i];\\n                k+=2;\\n            }\\n        }\\n        k=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                a[k]=nums[i];\\n                k+=2;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> a(nums.size(),0);\\n        int k=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=0){\\n                a[k]=nums[i];\\n                k+=2;\\n            }\\n        }\\n        k=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                a[k]=nums[i];\\n                k+=2;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569317,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        p = [i for i in nums if i > 0]\\n        q = [i for i in nums if i < 0]\\n        l,r = 0, len(nums)//2 - 1\\n        ans = []\\n        while l <= r:\\n            ans.append(p[l])\\n            ans.append(q[l])\\n            l += 1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        p = [i for i in nums if i > 0]\\n        q = [i for i in nums if i < 0]\\n        l,r = 0, len(nums)//2 - 1\\n        ans = []\\n        while l <= r:\\n            ans.append(p[l])\\n            ans.append(q[l])\\n            l += 1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555839,
                "title": "2149-rearrange-array-elements-by-sign",
                "content": "class Solution {\\npublic:\\n    /*--------------------------------------------------------\\n    Brute force technique\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>minus;\\n        vector<int>plus;\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n                minus.push_back(nums[i]);\\n            else\\n                plus.push_back(nums[i]);\\n        }\\n        int k=0, l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                ans.push_back(plus[k++]);\\n            }\\n            else\\n                ans.push_back(minus[l++]);\\n        }\\n        return ans;\\n    }\\n    ------------------------------------------------------------*/\\n    \\n    /*----------Solution 2 -------------------------*/\\n    \\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ans(nums.size());\\n        int plus=0;\\n        int minus=1;\\n        int n=nums.size();\\n        for(auto x:nums)\\n        {\\n            if(x>=0)\\n            {   ans[plus]=x;\\n                plus+=2;\\n            }\\n            else\\n            {    ans[minus]=x;\\n                 minus+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    /*--------------------------------------------------------\\n    Brute force technique\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>minus;\\n        vector<int>plus;\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n                minus.push_back(nums[i]);\\n            else\\n                plus.push_back(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2552238,
                "title": "easy-two-pointer-approach-c-solution",
                "content": "\\n    int n=nums.size(); // First we are checking the lenght of the given array\\n        \\n    vector<int> v(n); // also we have created one array to store +ve and -ve elements\\n     \\n    int positive = 0;    \\n    int negative = 1;\\n    \\n        for(int i=0;i<nums.size();i++){\\n        if(nums[i]>0){\\n            v[positive]=nums[i]; \\n            positive+=2; // now for every +ve element we will be moving its position to +2 \\n        }\\n        else{\\n            v[negative]=nums[i];\\n            negative+=2; //// now for every -ve element we will be moving its position to +2\\n        }   \\n    }\\n    return v;\\n\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "\\n    int n=nums.size(); // First we are checking the lenght of the given array\\n        \\n    vector<int> v(n); // also we have created one array to store +ve and -ve elements\\n     \\n    int positive = 0;    \\n    int negative = 1;\\n    \\n        for(int i=0;i<nums.size();i++){\\n        if(nums[i]>0){\\n            v[positive]=nums[i]; \\n            positive+=2; // now for every +ve element we will be moving its position to +2 \\n        }\\n        else{\\n            v[negative]=nums[i];\\n            negative+=2; //// now for every -ve element we will be moving its position to +2\\n        }   \\n    }\\n    return v;\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2530646,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n     int[] arr = new int[nums.length];\\n     int positive = 0;\\n     int negative = 1;\\n     for(int i = 0; i < nums.length; i++) {\\n         if(nums[i] > 0) {\\n             arr[positive] = nums[i];\\n             positive+=2;\\n         }else{\\n             arr[negative] = nums[i];\\n             negative+=2;\\n         }\\n     } \\n        return arr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n     int[] arr = new int[nums.length];\\n     int positive = 0;\\n     int negative = 1;\\n     for(int i = 0; i < nums.length; i++) {\\n         if(nums[i] > 0) {\\n             arr[positive] = nums[i];\\n             positive+=2;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2529982,
                "title": "java-easy-code-for-beginners-easy-to-understand",
                "content": "\"\\' This code is preferrably is for the beginners\"\\'\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int k = 0;\\n        int x = (nums.length-1)/2;\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                arr[k] = nums[i];\\n                k++;\\n            }\\n        }\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                arr[k] = nums[i];\\n                k++;\\n            }\\n        }\\n        for(int i = 0,j = 0;i<nums.length;i+=2,j++){\\n            nums[i] = arr[j];\\n        }\\n        for(int i = 1,j = x+1;i<nums.length;i+=2,j++){\\n            nums[i] = arr[j];\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        int k = 0;\\n        int x = (nums.length-1)/2;\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                arr[k] = nums[i];\\n                k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2526568,
                "title": "two-pointer-solution",
                "content": "class Solution\\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int> &nums)\\n    {\\n        vector<int> arrangedArray(nums.size());\\n        int pos = 0, neg = 1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] > 0)\\n            {\\n                arrangedArray[pos] = nums[i];\\n                pos = pos + 2;\\n            }\\n            else\\n            {\\n                arrangedArray[neg] = nums[i];\\n                neg = neg + 2;\\n            }\\n        }\\n        return arrangedArray;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution\\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int> &nums)\\n    {\\n        vector<int> arrangedArray(nums.size());\\n        int pos = 0, neg = 1;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] > 0)\\n            {\\n                arrangedArray[pos] = nums[i];\\n                pos = pos + 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2513838,
                "title": "python-4-lines-easy-to-read",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        positives = [num for num in nums if num > 0]\\n        negatives = [num for num in nums if num < 0]\\n        \\n        res = zip(positives, negatives)\\n        \\n        return chain(*res)\\n```\\n    \\nChain is an iterator and thereby allowed as return value.\\nA iterable data structure like a list is also OK like:\\n`return list(chain(*res))`",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        positives = [num for num in nums if num > 0]\\n        negatives = [num for num in nums if num < 0]\\n        \\n        res = zip(positives, negatives)\\n        \\n        return chain(*res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513559,
                "title": "c-solution-using-two-pointer-approach",
                "content": "Simple two pointer approach in O(n) time complexity and O(1) space.\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i=0,j=0,n=nums.size();\\n        vector<int> res(n);\\n        for(int k=0;k<n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                while(i<n && nums[i]<0)\\n                    i++;\\n                res[k] = nums[i++];\\n            }\\n            else\\n            {\\n                while(j<n && nums[j]>0)\\n                    j++;\\n                res[k] = nums[j++];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i=0,j=0,n=nums.size();\\n        vector<int> res(n);\\n        for(int k=0;k<n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                while(i<n && nums[i]<0)\\n                    i++;\\n                res[k] = nums[i++];\\n            }\\n            else\\n            {\\n                while(j<n && nums[j]>0)\\n                    j++;\\n                res[k] = nums[j++];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469423,
                "title": "easy-to-understand",
                "content": "**Easy Approach**\\n**133 / 133 test cases passed.**\\n**faster than 87.45% of C++ online submissions**\\n\\n\\n\\n**Runtime : 253 ms**\\n**Memory : 135 MB**\\n**c++ code:**\\n```\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>pos;\\n        vector<int>neg;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n        int k = nums.size();\\n        nums.clear();\\n        for(int i=0;i<k/2;i++){\\n            nums.push_back(pos[i]);\\n            nums.push_back(neg[i]);\\n        }\\n        return nums;\\n    }\\n```\\n\\n**Please upvote**",
                "solutionTags": [],
                "code": "```\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>pos;\\n        vector<int>neg;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                pos.push_back(nums[i]);\\n            }\\n            else{\\n                neg.push_back(nums[i]);\\n            }\\n        }\\n        int k = nums.size();\\n        nums.clear();\\n        for(int i=0;i<k/2;i++){\\n            nums.push_back(pos[i]);\\n            nums.push_back(neg[i]);\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437193,
                "title": "c-easy",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int> &nums)\\n    {\\n        vector<int> pos;\\n        vector<int> neg;\\n\\n        for (auto i : nums)\\n        {\\n            if (i >= 0)\\n                pos.push_back(i);\\n\\n            else\\n                neg.push_back(i);\\n        }\\n\\n        int i = 0, j = 0, k = 0;\\n        bool flag = true;\\n\\n        while (i < pos.size() || j < neg.size())\\n        {\\n            if (flag)\\n            {\\n                nums[k++] = pos[i++];\\n            }\\n            else\\n            {\\n                nums[k++] = neg[j++];\\n            }\\n            flag = !flag;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> rearrangeArray(vector<int> &nums)\\n    {\\n        vector<int> pos;\\n        vector<int> neg;\\n\\n        for (auto i : nums)\\n        {\\n            if (i >= 0)\\n                pos.push_back(i);\\n\\n            else\\n                neg.push_back(i);\\n        }\\n\\n        int i = 0, j = 0, k = 0;\\n        bool flag = true;\\n\\n        while (i < pos.size() || j < neg.size())\\n        {\\n            if (flag)\\n            {\\n                nums[k++] = pos[i++];\\n            }\\n            else\\n            {\\n                nums[k++] = neg[j++];\\n            }\\n            flag = !flag;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428989,
                "title": "java-comments-easy-o-n-time",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        \\n        int positiveIt = -1;\\n        int negativeIt = -1;\\n        \\n        // Get the first index of positive and negative numbers in the array\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > 0 && positiveIt == -1) {\\n                positiveIt = i;\\n            } else if(nums[i] < 0 && negativeIt == -1) {\\n                negativeIt = i;\\n            }\\n        }\\n        \\n        int[] rearrangedArr = new int[nums.length];\\n        \\n        // Re arrange elements in the new answer array\\n        for(int i=0;i<nums.length;i++) {\\n            // If index is even that means +ve element should be assigned\\n            if(i%2==0) {\\n                // Assign the positive element using the positiveIt index\\n                rearrangedArr[i] = nums[positiveIt++];                \\n                \\n                // Look for the next positive element after assignment in the\\n                // original array\\n                while(positiveIt < nums.length && nums[positiveIt] < 0) {\\n                    positiveIt++;\\n                }\\n            } else {\\n                // Assign the negative element using the negativeIt index\\n                rearrangedArr[i] = nums[negativeIt++];\\n                \\n                // Look for the next negative element after assignment in the\\n                // original array\\n                while(negativeIt < nums.length && nums[negativeIt] > 0) {\\n                    negativeIt++;\\n                }\\n            }\\n        }\\n        \\n        return rearrangedArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        \\n        int positiveIt = -1;\\n        int negativeIt = -1;\\n        \\n        // Get the first index of positive and negative numbers in the array\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] > 0 && positiveIt == -1) {\\n                positiveIt = i;\\n            } else if(nums[i] < 0 && negativeIt == -1) {\\n                negativeIt = i;\\n            }\\n        }\\n        \\n        int[] rearrangedArr = new int[nums.length];\\n        \\n        // Re arrange elements in the new answer array\\n        for(int i=0;i<nums.length;i++) {\\n            // If index is even that means +ve element should be assigned\\n            if(i%2==0) {\\n                // Assign the positive element using the positiveIt index\\n                rearrangedArr[i] = nums[positiveIt++];                \\n                \\n                // Look for the next positive element after assignment in the\\n                // original array\\n                while(positiveIt < nums.length && nums[positiveIt] < 0) {\\n                    positiveIt++;\\n                }\\n            } else {\\n                // Assign the negative element using the negativeIt index\\n                rearrangedArr[i] = nums[negativeIt++];\\n                \\n                // Look for the next negative element after assignment in the\\n                // original array\\n                while(negativeIt < nums.length && nums[negativeIt] > 0) {\\n                    negativeIt++;\\n                }\\n            }\\n        }\\n        \\n        return rearrangedArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369342,
                "title": "c-o-n",
                "content": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> answer(nums.size(),0);\\n        int sign=0;\\n        for(auto& it:nums)\\n            if(it>0)\\n            {\\n                answer[sign]=it;\\n                sign+=2;\\n            }\\n        sign=1;\\n        for(auto& it:nums)\\n            if(it<0)\\n            {\\n                answer[sign]=it;\\n                sign+=2;\\n            }\\n        return answer;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> answer(nums.size(),0);\\n        int sign=0;\\n        for(auto& it:nums)\\n            if(it>0)\\n            {\\n                answer[sign]=it;\\n                sign+=2;\\n            }\\n        sign=1;\\n        for(auto& it:nums)\\n            if(it<0)\\n            {\\n                answer[sign]=it;\\n                sign+=2;\\n            }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336250,
                "title": "sleek-o-n-space-and-time-in-c-6-lines",
                "content": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ans(nums.size(),0);\\n        int j=-2,k=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)ans[k+=2]=nums[i];\\n            else ans[j+=2]=nums[i];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ans(nums.size(),0);\\n        int j=-2,k=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)ans[k+=2]=nums[i];\\n            else ans[j+=2]=nums[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332339,
                "title": "rearrange-array-elements-by-sign",
                "content": "Time complexity : O(n)\\nSpace Complexity : O(n)\\n\\n```\\n   int n = nums.length/2;\\n        \\n        int[] arr1 = new int[n];\\n        int[] arr2 = new int[n];\\n        int k = 0;\\n        int c = 0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0)\\n            {\\n                arr1[c++] = nums[i];\\n            }else{\\n                arr2[k++] = nums[i];\\n            }\\n        }\\n       \\n         c = 0;\\n         k = 0;\\n        int i=0;\\n        for(int p=0;p<n;p++){\\n            nums[i++] = arr2[k++];\\n            nums[i++] = arr1[c++];\\n            \\n        }\\n        \\n        \\n        return nums;\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   int n = nums.length/2;\\n        \\n        int[] arr1 = new int[n];\\n        int[] arr2 = new int[n];\\n        int k = 0;\\n        int c = 0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0)\\n            {\\n                arr1[c++] = nums[i];\\n            }else{\\n                arr2[k++] = nums[i];\\n            }\\n        }\\n       \\n         c = 0;\\n         k = 0;\\n        int i=0;\\n        for(int p=0;p<n;p++){\\n            nums[i++] = arr2[k++];\\n            nums[i++] = arr1[c++];\\n            \\n        }\\n        \\n        \\n        return nums;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317049,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ans,v1,v2;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]>0)\\n                v1.push_back(nums[i]);\\n            else\\n                v2.push_back(nums[i]);\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            ans.push_back(v1[i]);\\n            ans.push_back(v2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ans,v1,v2;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]>0)\\n                v1.push_back(nums[i]);\\n            else\\n                v2.push_back(nums[i]);\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            ans.push_back(v1[i]);\\n            ans.push_back(v2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314758,
                "title": "c-easy-solution-using-2-arrays",
                "content": "ALGO TO SOLVE THIS QUESTION \\n\\n \\n\\nwe will take positive and negative temp array in which we will insert positive and negative elements repectivally\\n\\n \\n\\nnow the procees will be like merge sort \\n\\nbut only diggerenc is when k is even positive elements will be inserted and when k is odd negative elements will be inserted \\n\\n \\n\\nlets discuss time and space complexity \\n\\nhence we are using 2 temp array \\n\\nso space complexity will be o(n)+o(n) =  o(n)\\n\\nand time complextiy also would be o(n) we are just treversing the array twice\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n        \\n\\n   \\n    vector<int>positive;\\n    \\n    vector<int>negative;\\n  //  vector<int>mix;\\n    for(int i = 0;i<n;i++)\\n    {\\n       if(nums[i]>=0)\\n       {\\n           positive.push_back(nums[i]);\\n       }\\n        if(nums[i]<0)\\n        {\\n            negative.push_back(nums[i]);\\n        }\\n    }\\n    \\n    int positivesize = positive.size();\\n    int negativesize = negative.size();\\n    \\n    \\n          int k =0;\\n          int i =0;\\n          int j = 0;\\n          while(i<positivesize&&j<negativesize)\\n          {\\n              if(k%2 == 0)\\n              {\\n                  nums[k] = positive[i];\\n                //  cout<<positive[i]<<endl;\\n                  k++;\\n                  i++;\\n              }\\n              if(k%2!=0)\\n              {\\n                  nums[k] = negative[j];\\n                  j++;\\n                  k++;\\n                 // cout<<negative[j]<<endl;\\n              }\\n              \\n          }\\n         \\n         while(i<positivesize)\\n         {\\n                 nums[k] = positive[i];\\n                  k++;\\n                  i++;\\n         }\\n         \\n         while(j<negativesize)\\n         {\\n                  nums[k] = negative[j];\\n                  j++;\\n                  k++;\\n         }\\n    \\n    \\n     return nums;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n    int n=nums.size();\\n        \\n\\n   \\n    vector<int>positive;\\n    \\n    vector<int>negative;\\n  //  vector<int>mix;\\n    for(int i = 0;i<n;i++)\\n    {\\n       if(nums[i]>=0)\\n       {\\n           positive.push_back(nums[i]);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2288134,
                "title": "c-solution-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size(),0);\\n        int p=0,n=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                ans[p]=nums[i];\\n                p+=2;\\n            }\\n            else{\\n                ans[n]=nums[i];\\n                n+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size(),0);\\n        int p=0,n=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                ans[p]=nums[i];\\n                p+=2;\\n            }\\n            else{\\n                ans[n]=nums[i];\\n                n+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267314,
                "title": "c-solution-easy-and-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        int pos=0,neg=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                ans[pos]=nums[i];\\n                pos+=2;\\n            }else{\\n                ans[neg]=nums[i];\\n                neg+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        int pos=0,neg=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                ans[pos]=nums[i];\\n                pos+=2;\\n            }else{\\n                ans[neg]=nums[i];\\n                neg+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266963,
                "title": "c-solution-o-n-time-bi-indexing-method",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        vector<int> v(nums.size(), INT_MAX-1);\\n        int p = 0, n = 1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                v[p] = nums[i];\\n                p += 2;\\n            }\\n            \\n            if(nums[i] < 0)\\n            {\\n                v[n] = nums[i];\\n                n += 2;\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        \\n        vector<int> v(nums.size(), INT_MAX-1);\\n        int p = 0, n = 1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i] > 0)\\n            {\\n                v[p] = nums[i];\\n                p += 2;\\n            }\\n            \\n            if(nums[i] < 0)\\n            {\\n                v[n] = nums[i];\\n                n += 2;\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266239,
                "title": "python-for-beginners-1-simple-approach-2-two-pointer",
                "content": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        # Simple approach for beginners \\n        # Runtime : 2331ms\\n        lis1,lis2,lis3=[],[],[]\\n        for i in nums:\\n            if(i>0):\\n                lis1.append(i)\\n            else:\\n                lis2.append(i)\\n        for i in range(len(nums)//2):\\n            lis3.append(lis1[i])\\n            lis3.append(lis2[i])\\n        return lis3       \\n        \"\"\"        \\n        # Optimization of the above code\\n        # Two-Pointer Runtime: 2096ms\\n        x,y,a=0,1,[0]*len(nums)\\n        for i in nums:\\n            if(i>0):\\n                a[x]=i\\n                x=x+2\\n            else:\\n                a[y]=i\\n                y=y+2\\n        return a        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        # Simple approach for beginners \\n        # Runtime : 2331ms\\n        lis1,lis2,lis3=[],[],[]\\n        for i in nums:\\n            if(i>0):\\n                lis1.append(i)\\n            else:\\n                lis2.append(i)\\n        for i in range(len(nums)//2):\\n            lis3.append(lis1[i])\\n            lis3.append(lis2[i])\\n        return lis3       \\n        \"\"\"        \\n        # Optimization of the above code\\n        # Two-Pointer Runtime: 2096ms\\n        x,y,a=0,1,[0]*len(nums)\\n        for i in nums:\\n            if(i>0):\\n                a[x]=i\\n                x=x+2\\n            else:\\n                a[y]=i\\n                y=y+2\\n        return a        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263897,
                "title": "java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int pos=0,neg=0,i=0;\\n        int res[]=new int[nums.length];    \\n        while(i<nums.length)\\n        {\\n            while(nums[pos]<0)\\n                pos++;\\n            while(nums[neg]>0)\\n                neg++;\\n            res[i]=nums[pos];\\n            res[i+1]=nums[neg];\\n            i=i+2;\\n            pos++;\\n            neg++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int pos=0,neg=0,i=0;\\n        int res[]=new int[nums.length];    \\n        while(i<nums.length)\\n        {\\n            while(nums[pos]<0)\\n                pos++;\\n            while(nums[neg]>0)\\n                neg++;\\n            res[i]=nums[pos];\\n            res[i+1]=nums[neg];\\n            i=i+2;\\n            pos++;\\n            neg++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206485,
                "title": "python-soln-faster-than-98",
                "content": "```\\ndef rearrangeArray(self, nums: List[int]) -> List[int]:\\n\\tp=[x for x in nums if x>0]\\n\\tn=[x for x in nums if x<0]\\n\\tres=[]\\n\\tfor i in range(len(p)):\\n\\t\\tres+=[p[i],n[i]]\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef rearrangeArray(self, nums: List[int]) -> List[int]:\\n\\tp=[x for x in nums if x>0]\\n\\tn=[x for x in nums if x<0]\\n\\tres=[]\\n\\tfor i in range(len(p)):\\n\\t\\tres+=[p[i],n[i]]\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2146049,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> output(nums.size());\\n        int p = 0, n = 1;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(nums[i] > -1)\\n            {\\n                output[p] = nums[i];\\n                p += 2;\\n            }else\\n            {\\n                output[n] = nums[i];\\n                n += 2;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int> output(nums.size());\\n        int p = 0, n = 1;\\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(nums[i] > -1)\\n            {\\n                output[p] = nums[i];\\n                p += 2;\\n            }else\\n            {\\n                output[n] = nums[i];\\n                n += 2;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565111,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1567099,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1945199,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1922212,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 2047582,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1973227,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1957659,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1937212,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1833220,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 2039432,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1565111,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1567099,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1945199,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1922212,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 2047582,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1973227,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1957659,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1937212,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 1833220,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 2039432,
                "content": [
                    {
                        "username": "meta_fever",
                        "content": "I wasted nearly 45 minutes on this problem, trying to find a solution to do this in-place. i.e., no extra array to store the result and to do it in O(n) time. Is it even possible?"
                    },
                    {
                        "username": "ChaitanyaAnand1202",
                        "content": "Thanks to your comment, I was able to save some time at least."
                    },
                    {
                        "username": "Xshubham",
                        "content": "You can do it in O(1) Space and O(1) time but for that the order will not be preserved. In similiar problem of sorting evens and odds we can do it in these complexities."
                    },
                    {
                        "username": "spookie886",
                        "content": "I wish I read this sooner I also wasted a lot of time on this oh my lorddddddd this sucks so much"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@Rohit_8448](/Rohit_8448) well i am not as luck as you because i also wasted a lot of time on this line of thought\\uD83D\\uDE2D"
                    },
                    {
                        "username": "Riyad-Hossain",
                        "content": "Actually, you can\\'t optimize the space better than O(n). However, time complexity can be optimized to O(n). \\nHere is how:\\n```\\nvector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n\\n        int posIndex = 0, negIndex = 1;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > 0){\\n                ans[posIndex] = nums[i];\\n                posIndex += 2;\\n            } else{\\n                ans[negIndex] = nums[i];\\n                negIndex += 2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "[@sushruta19](/sushruta19) class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int pos[n/2];\\n        int neg[n/2];\\n        for(int i=0,p=0,n=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                pos[p]=nums[i];\\n                p++;\\n            }\\n            else\\n            {\\n                neg[n]=nums[i];\\n                n++;\\n            }\\n        }\\n        int i=0,j=0,k=0;\\n        while(i<n/2 && j<n/2)\\n        {\\n            nums[k]=pos[i];\\n            k++;i++;\\n            nums[k]=neg[j];\\n            k++; j++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "thank god , I come here and read your post otherwise i was also going to do same mistake  LOL . thanks"
                    },
                    {
                        "username": "sushruta19",
                        "content": "[@YusenPeng](/YusenPeng) Share the code pls"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": "[@YusenPeng](/YusenPeng)  Can u plz share the code"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "I implemented it successfully but I got \"time limit exceeded\" lol"
                    },
                    {
                        "username": "lakshyasaharan",
                        "content": "Same here"
                    },
                    {
                        "username": "thecriticalhippo",
                        "content": "Most of the solutions that I have seen create extra arrays. Either they \\n1) Create a neg and pos array that store the negative and postive numbers in order\\n2) Create a \"result\" array and use a pos and neg pointer to fill the array.\\n\\nIs there any way to solve the problem by rearranging the elements in the array without creating any other arrays?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "the tough part in the question is to identify that you can\\'t solve it in O(1) space."
                    },
                    {
                        "username": "niketsrivastav",
                        "content": "Wasted about an hour to do it in 0(1) space  :("
                    },
                    {
                        "username": "anshusorrot",
                        "content": "SAME BRO"
                    },
                    {
                        "username": "grey7",
                        "content": "maybe by using  recursion\\n"
                    },
                    {
                        "username": "askshivansh",
                        "content": "Maturity is when you got to know you can\\'t solve this question without extra space \\uD83D\\uDE24."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "spend extra Space not extra Time than required ! Go Easy..."
                    },
                    {
                        "username": "mochiball",
                        "content": "Should be an easy problem "
                    },
                    {
                        "username": "Anisha2123",
                        "content": "ThankGod I read the discussion, otherwise  I would have wasted another hour to get O(1) solution. "
                    },
                    {
                        "username": "Shoupadhyay",
                        "content": "[@sinha4438](/sinha4438) it does yahi toh diktat hai bawaaaa\\n"
                    },
                    {
                        "username": "sinha4438",
                        "content": "we can use the two pointer approach if order doesn\\'t matter."
                    },
                    {
                        "username": "hsayy",
                        "content": "Don\\'t waste time on this. The description of the question makes it seem like we need to get a solution in O(1) space but that is impossible. LC please fix the description"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "Just a quick reminder: you\\'ll not be able to solve it in O(1) space but can do it with TC: O(n).\\nIf you can please add a comment."
                    }
                ]
            },
            {
                "id": 2028875,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 2015934,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1997571,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1988510,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1945715,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1934319,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1903923,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1771361,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1767719,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            },
            {
                "id": 1767315,
                "content": [
                    {
                        "username": "gaurav_098765",
                        "content": "literally wasted around 1 hour trying to solve in O(1) space , ended up by solving using three vectors , one for positive one for negative and a final vector for output"
                    },
                    {
                        "username": "layyy",
                        "content": "follow up: partition array according to given pivot"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I directly came up with solution without thinking that hey I need to do it O (1).\\nSome problems can\\'t be done."
                    },
                    {
                        "username": "VamC",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(i&1){\\n                int j=i+1;\\n                while(nums[i]>0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n\\n            }\\n            else{\\n                int j=i+1;\\n                while(nums[i]<0){\\n                    swap(nums[i],nums[j]);\\n                    j++;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};   why Im getting TLE at 129 testcase"
                    },
                    {
                        "username": "dhruv_gupta_1015",
                        "content": "class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n       int n=nums.size();\\n       vector<int>ans(n,0);\\n       int posindex=0;int negindex=1;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]<0){\\n               ans[negindex]=nums[i];\\n               negindex+=2;\\n           }\\n           else{\\n               ans[posindex]=nums[i];\\n                posindex+=2;\\n           }\\n       } return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ig_rocker",
                        "content": "Is it possible  to complete this problem this problem in O(N) time complexity and O(1) space??"
                    },
                    {
                        "username": "Msey",
                        "content": "you can\\'t optimize the space better than O(n)"
                    },
                    {
                        "username": "jaikumarverma",
                        "content": "You can assume equal number of positive and negative elements"
                    },
                    {
                        "username": "fluturandra2",
                        "content": "yes\\n"
                    },
                    {
                        "username": "__vaibhu07",
                        "content": "Passes 129/133 test cases . Whats the error here and is there any other way than mine to do it in O(1) space\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums , int start , int end){\\n        int temp = nums[end];\\n        for(int i = end -1 ; i >= start ; i--)nums[i+1] = nums[i];\\n        nums[start] = temp;\\n    }\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int i = 0 , j = 0 , k = 0 , n = nums.size();\\n        while(i < n and j < n and k < n){\\n            if(i % 2 == 0 and nums[i] < 0){\\n                k = i; j = i;\\n                while(nums[k] < 0 and k < n)k++;\\n                if(k >= n)break;\\n                rotate(nums , j , k);\\n\\n            }else if(i % 2 == 1 and nums[i] >= 0){\\n                j = i; k = i;\\n                while(nums[j] >= 0 and j < n)j++;\\n                if(j >= n)break;\\n                rotate(nums , k , j);\\n            }\\n            i++;\\n        }\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "That shoulde be an easy question!"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "yah, until you get to know  the space complexity  can\\'t be optimized to constant :)"
                    },
                    {
                        "username": "Rohit_8448",
                        "content": "agree"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\nwhat these line of code does?"
                    },
                    {
                        "username": "aliakseibrown",
                        "content": "ios_base::sync_with_stdio(false) - turns off the synchronisation between C and C++ streams( where the input goes)\\ncin.tie(NULL) - unties the connection between COUT and CIN( when one of them is written, the other is flushes the garbage that was in use of COUT/CIN)"
                    }
                ]
            }
        ]
    }
]