[
    {
        "title": "Maximize the Confusion of an Exam",
        "question_content": "A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).\nYou are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:\n\n\tChange the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').\n\nReturn the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.\n&nbsp;\nExample 1:\n\nInput: answerKey = \"TTFF\", k = 2\nOutput: 4\nExplanation: We can replace both the 'F's with 'T's to make answerKey = \"TTTT\".\nThere are four consecutive 'T's.\n\nExample 2:\n\nInput: answerKey = \"TFFT\", k = 1\nOutput: 3\nExplanation: We can replace the first 'T' with an 'F' to make answerKey = \"FFFT\".\nAlternatively, we can replace the second 'T' with an 'F' to make answerKey = \"TFFF\".\nIn both cases, there are three consecutive 'F's.\n\nExample 3:\n\nInput: answerKey = \"TTFTTFTT\", k = 1\nOutput: 5\nExplanation: We can replace the first 'F' to make answerKey = \"TTTTTFTT\"\nAlternatively, we can replace the second 'F' to make answerKey = \"TTFTTTTT\". \nIn both cases, there are five consecutive 'T's.\n\n&nbsp;\nConstraints:\n\n\tn == answerKey.length\n\t1 <= n <= 5 * 104\n\tanswerKey[i] is either 'T' or 'F'\n\t1 <= k <= n",
        "solutions": [
            {
                "id": 1499005,
                "title": "c-sliding-window-with-explanation",
                "content": "**This is a sliding window problem.**\\n**Idea :-** Problems ask you to find maximum substring of \\'T\\' which contains at most k \\'F\\' or maximum  substring of \\'F\\' which contains at most k \\'T\\'.\\nI just used two seprate sliding windows for this.\\nBelow is the implementation.\\n***Similar Problem:-***\\n[Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int size=s.size(),left=0,res=0,cnt=0;\\n      //  maximum substring of \\'T\\' which contains k \\'F\\'\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'F\\')\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==\\'F\\')\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n    //maximum  substring of \\'F\\' which contains k \\'T\\'\\n      cnt=0;left=0;\\n      for(int i=0;i<size;i++){\\n            if(s[i]==\\'T\\')\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==\\'T\\')\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n        return res;       \\n    }\\n};\\n```\\n**Same idea as above but shorter version:-**\\n```\\n\\nclass Solution {\\npublic:\\n    int solve(string &s,char b,int &k){\\n       int left=0,res=0,size=s.size(),cnt=0;\\n      for(int i=0;i<size;i++){\\n            if(s[i]==b)\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==b)\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n        return res;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {\\n      return max(solve(s,\\'F\\',k),solve(s,\\'T\\',k));  \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps you :)\\nIf you have any question or suggestion then please ask in comment section.\\nThanks.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int size=s.size(),left=0,res=0,cnt=0;\\n      //  maximum substring of \\'T\\' which contains k \\'F\\'\\n        for(int i=0;i<size;i++){\\n            if(s[i]==\\'F\\')\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==\\'F\\')\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n    //maximum  substring of \\'F\\' which contains k \\'T\\'\\n      cnt=0;left=0;\\n      for(int i=0;i<size;i++){\\n            if(s[i]==\\'T\\')\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==\\'T\\')\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n        return res;       \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int solve(string &s,char b,int &k){\\n       int left=0,res=0,size=s.size(),cnt=0;\\n      for(int i=0;i<size;i++){\\n            if(s[i]==b)\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==b)\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n        return res;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {\\n      return max(solve(s,\\'F\\',k),solve(s,\\'T\\',k));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499049,
                "title": "java-c-python-sliding-window-strict-o-n",
                "content": "# Intuition\\nOpen lee215\\'s old post in [424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/discuss/278271/JavaC%2B%2BPython-Sliding-Window-just-O(n)),\\nUPVOTE and COPY the exact same solution.\\nHomework: update the function name to `maxConsecutiveAnswers`.\\n<br>\\n\\n# Explanation\\n`maxf` means the max frequency of the same character in the sliding window.\\nTo better understand the solution,\\nyou can firstly replace `maxf` with `max(count.values())`,\\nNow I improve from `O(26n)` to `O(n)` using a just variable `maxf`.\\n<br>\\n\\n# Complexity\\nTime `O(n)`\\nSpace `O(128)`\\n<br>\\n\\n**Java**\\n```java\\n    public int characterReplacement(String s, int k) {\\n        int res = 0, maxf = 0, count[] = new int[128];\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = Math.max(maxf, ++count[s.charAt(i)]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s.charAt(i - res)]--;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = res = 0\\n        count = collections.Counter()\\n        for i in range(len(s)):\\n            count[s[i]] += 1\\n            maxf = max(maxf, count[s[i]])\\n            if res - maxf < k:\\n                res += 1\\n            else:\\n                count[s[i - res]] -= 1\\n        return res\\n```\\n\\n# Solution 2\\nAnother version of same idea.\\nIn a more standard format of sliding window.\\nMaybe easier to understand\\n\\nTime `O(N)`\\nSpace `O(26)`\\n\\n**Java**\\n```java\\n    public int characterReplacement(String s, int k) {\\n        int maxf = 0, i = 0, n = s.length(), count[] = new int[26];\\n        for (int j = 0; j < n; ++j) {\\n            maxf = Math.max(maxf, ++count[s.charAt(j) - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s.charAt(i++) - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\\n**C++**\\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int maxf = 0, i = 0, n = s.length();\\n        vector<int> count(26);\\n        for (int j = 0; j < n; ++j) {\\n            maxf = max(maxf, ++count[s[j] - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s[i++] - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = i = 0\\n        count = collections.Counter()\\n        for j in range(len(s)):\\n            count[s[j]] += 1\\n            maxf = max(maxf, count[s[j]])\\n            if j - i + 1 > maxf + k:\\n                count[s[i]] -= 1\\n                i += 1\\n        return len(s) - i\\n```\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int characterReplacement(String s, int k) {\\n        int res = 0, maxf = 0, count[] = new int[128];\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = Math.max(maxf, ++count[s.charAt(i)]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s.charAt(i - res)]--;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int res = 0, maxf = 0;\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < s.length(); ++i) {\\n            maxf = max(maxf, ++count[s[i]]);\\n            if (res - maxf < k)\\n                res++;\\n            else\\n                count[s[i - res]]--;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = res = 0\\n        count = collections.Counter()\\n        for i in range(len(s)):\\n            count[s[i]] += 1\\n            maxf = max(maxf, count[s[i]])\\n            if res - maxf < k:\\n                res += 1\\n            else:\\n                count[s[i - res]] -= 1\\n        return res\\n```\n```java\\n    public int characterReplacement(String s, int k) {\\n        int maxf = 0, i = 0, n = s.length(), count[] = new int[26];\\n        for (int j = 0; j < n; ++j) {\\n            maxf = Math.max(maxf, ++count[s.charAt(j) - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s.charAt(i++) - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\n```cpp\\n    int characterReplacement(string s, int k) {\\n        int maxf = 0, i = 0, n = s.length();\\n        vector<int> count(26);\\n        for (int j = 0; j < n; ++j) {\\n            maxf = max(maxf, ++count[s[j] - \\'A\\']);\\n            if (j - i + 1 > maxf + k)\\n                --count[s[i++] - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n```\n```py\\n    def characterReplacement(self, s, k):\\n        maxf = i = 0\\n        count = collections.Counter()\\n        for j in range(len(s)):\\n            count[s[j]] += 1\\n            maxf = max(maxf, count[s[j]])\\n            if j - i + 1 > maxf + k:\\n                count[s[i]] -= 1\\n                i += 1\\n        return len(s) - i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1581341,
                "title": "detailed-explanation-multiple-approaches-explained-c-clean-code",
                "content": "**Approach 1: Binary Search + Sliding Window**\\n-----------------------------\\n-----------------------------\\nIdea is use **Binary Search** concept. \\n\\nWe first take a window size and then how many max. consecutive T or F can be there. \\n\\nFollow the below algorithm : \\n\\n* `mid = (lo + hi) / 2;` , here mid is the window size.\\n\\n* Now count the `# of T\\'s and F\\'s`\\n* Then we check if we can replace at most k answers to get max consecutive T\\'s or F\\'s\\n\\t* this is only possible if `count of T <= k` or `count of F <= k`\\n\\t* We check for every window from i=0 to answerKey.size()\\n\\t* If possible return true or else false\\n* Now, if it is not possible, then we shrink the size of window \\n\\t* i.e `hi = mid-1`\\n* Else, if possible, we store current window size and check for a larger window \\n\\t* i.e `lo = mid+1`\\n\\nLets do a dry run on a sample : \\n\\t\\n\\t\\tanswerKey = \" T F T T F \"  ,  k = 1\\n\\t\\t\\n\\t\\t1. lo = 1, hi = 5 => window length = mid = 3\\n\\n\\t\\t\\t\\ti. [\" T F T \"] T F :  t_count = 2  ,  f_count = 1 \\n\\t\\t\\t\\t-> Since, f_count <= k (= 1). Thus we can replace \\'F\\' with \\'T\\'\\n\\t\\t\\t\\t-> and return true\\n\\t\\t\\n\\t\\t-> answerKey : [\" T T T \"] T F (one of the possible way) & \\n\\t\\t-> no. of consecutive T\\'s i.e ans = 3 (mid)\\n\\t\\t-> lo = mid+1 = 4\\n\\t\\t\\n\\t\\t2. lo = 4, hi = 5 => window length = mid = 4\\n\\n\\t\\t\\t\\ti. [\" T F T T \"]  F :  t_count = 3  ,  f_count = 1 \\n\\t\\t\\t\\t-> Since, f_count <= k (= 1). Thus we can replace \\'F\\' with \\'T\\'\\n\\t\\t\\t\\t-> and return true\\n\\t\\t\\t\\t\\n\\t\\t-> answerKey : [\" T T T T \"] F (one of the possible way) & \\n\\t\\t-> no. of consecutive T\\'s i.e ans = 4 (mid)\\n\\t\\t-> lo = mid+1 = 5\\n\\t\\t\\n\\t\\t2. lo = 5, hi = 5 => window length = mid = 5\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ti. [\" T F T T F \"] :  t_count = 3  ,  f_count = 2 \\n\\t\\t\\t\\t-> Since, both t_count and f_count > k (= 1). Thus we cannot replace \\'F\\' with \\'T\\'\\n\\t\\t\\t\\t-> and return false\\n\\t\\t\\t\\t\\n\\t\\t-> no. of consecutive T\\'s i.e ans = 4 (mid)  [No change]\\n\\t\\t-> hi = mid-1 = 4, lo = 5\\n\\t\\t\\n\\t\\tSince, hi < lo, while loop will end. We have max consecutive answer = 4. \\n\\t\\tThus, return ans. (= 1) \\n\\t\\n-----------------------------\\n# Code: \\n\\n```\\nclass Solution {\\n    \\n    bool canReplace(string& s, int len, int k) {\\n        int f_count = 0, t_count = 0;\\n        for(int i=0; i<len; i++) {\\n            t_count += (s[i] == \\'T\\');\\n            f_count += (s[i] == \\'F\\'); \\n        }\\n        \\n        if(t_count <= k || f_count <= k) return true;\\n        \\n        int lo = 0, hi = len-1;\\n        while(hi < s.size()-1) {\\n            t_count -= (s[lo] == \\'T\\');\\n            f_count -= (s[lo] == \\'F\\');\\n            \\n            lo++, hi++;\\n            \\n            t_count += (s[hi] == \\'T\\');\\n            f_count += (s[hi] == \\'F\\');\\n            \\n            if(t_count <= k || f_count <= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n        \\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.size();\\n        int lo = 1, hi = n, ans = 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (hi+lo) >> 1;\\n            \\n            if(canReplace(answerKey, mid, k)) {\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else hi = mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n-----------------------------\\n**Complexity:**\\n\\n* Time : `O(N * log N)` , \\n\\n\\t* `N` : Traverse over the answerKey in `canReplace()`, to count T\\'s and F\\'s\\n\\t* `log N` : Binary Search over space i.e to find window size \\n\\n* Space : `O(1)`\\n-----------------------------\\n-----------------------------\\n**Approach 2: using Two Pointers**\\n-----------------------------\\n-----------------------------\\nIdea is similar to [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/). \\n\\n* We take two pointers, and window is between these two. \\n* Keep count of the number of T\\'s and F\\'s found in the current window.\\n* If the count of both `T` and `F` is > `k` , then :\\n\\t* First reduce count of current item i.e at `low` index \\n\\t* And increment `low` pointer until the count of either `T` or `F` <= `k` .\\n* At each iteration find the max window length.\\n\\n-----------------------------\\n# Code: \\n\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        \\n        int n = answerKey.size();\\n        \\n        int count_T = 0, count_F = 0, low = 0, maxConsecutive = 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            count_T += (answerKey[i] == \\'T\\');\\n            count_F += (answerKey[i] == \\'F\\');\\n            \\n            while(min(count_T, count_F) > k) {\\n                // move low ahead\\n                count_T -= (answerKey[low] == \\'T\\');\\n                count_F -= (answerKey[low] == \\'F\\');\\n                \\n                low++;\\n            }\\n            \\n            maxConsecutive = max(maxConsecutive, i - low + 1);\\n        }\\n        \\n        return maxConsecutive;\\n    }\\n};\\n```\\n\\n-----------------------------\\n\\n**Complexity :**\\n\\n* Time : `O(2N)` , Since we traverse every item in string twice. Thus N+N = 2N\\n* Space : `O(1)`\\n\\n -----------------------------\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool canReplace(string& s, int len, int k) {\\n        int f_count = 0, t_count = 0;\\n        for(int i=0; i<len; i++) {\\n            t_count += (s[i] == \\'T\\');\\n            f_count += (s[i] == \\'F\\'); \\n        }\\n        \\n        if(t_count <= k || f_count <= k) return true;\\n        \\n        int lo = 0, hi = len-1;\\n        while(hi < s.size()-1) {\\n            t_count -= (s[lo] == \\'T\\');\\n            f_count -= (s[lo] == \\'F\\');\\n            \\n            lo++, hi++;\\n            \\n            t_count += (s[hi] == \\'T\\');\\n            f_count += (s[hi] == \\'F\\');\\n            \\n            if(t_count <= k || f_count <= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n        \\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.size();\\n        int lo = 1, hi = n, ans = 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (hi+lo) >> 1;\\n            \\n            if(canReplace(answerKey, mid, k)) {\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else hi = mid-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        \\n        int n = answerKey.size();\\n        \\n        int count_T = 0, count_F = 0, low = 0, maxConsecutive = 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            count_T += (answerKey[i] == \\'T\\');\\n            count_F += (answerKey[i] == \\'F\\');\\n            \\n            while(min(count_T, count_F) > k) {\\n                // move low ahead\\n                count_T -= (answerKey[low] == \\'T\\');\\n                count_F -= (answerKey[low] == \\'F\\');\\n                \\n                low++;\\n            }\\n            \\n            maxConsecutive = max(maxConsecutive, i - low + 1);\\n        }\\n        \\n        return maxConsecutive;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729844,
                "title": "detailed-line-by-line-explanation-c-java-python",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language)\\nhttps://youtu.be/jyeXpd2FSlQ\\n or link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes. \\n   or\\n search \\uD83D\\uDC49`Maximise the Confusion of an Exam by Let\\'s Code Together`\\n\\n1. The `solve` function takes three parameters: the input string `a`, the limit `k`, and the character `c` (\\'T\\' or \\'F\\') for which the maximum length of the substring is to be found.\\n\\n2. Initialize variables `i` and `j` to 0, representing the start and end indices of the current substring.\\n\\n3. Initialize a variable `cnt` to 0 to keep track of the number of occurrences of the character `c` within the current substring.\\n\\n4. Initialize a variable `n` to store the size of the input string `a`.\\n\\n5. Initialize a variable `ans` to 0, which will hold the maximum length of the substring satisfying the given conditions.\\n\\n6. Start a while loop that iterates until the end of the string `a` (represented by `j < n`).\\n\\n7. Inside the loop, check if the character at index `j` in string `a` is equal to the character `c`. If it is, increment `cnt` by 1.\\n\\n8. Enter another while loop that checks if the current substring violates the limit `k`. If `cnt` is greater than `k`, it means there are more occurrences of character `c` than allowed, so we need to move the window\\'s start index (`i`) to the right and decrement `cnt` accordingly. Increment `i` by 1 and decrement `cnt` by 1 for each occurrence of character `c` until `cnt` becomes less than or equal to `k`.\\n\\n9. After exiting the inner while loop, calculate the length of the current valid substring (`j - i + 1`) and update `ans` to the maximum value between the current `ans` and the length of the substring.\\n\\n10. Move the window\\'s end index (`j`) to the right by incrementing it by 1.\\n\\n11. Finally, return the maximum value between `ans1` and `ans2`, which are the results of calling the `solve` function twice with the characters \\'T\\' and \\'F\\', respectively.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string a, int k,char c){\\n         int i=0;\\n        int j=0;\\n        int cnt=0;\\n        int n=a.size();\\n        int ans=0;\\n          while(j<n){\\n          if(a[j]==c)\\n          cnt++;\\n          while(i<n&&cnt>k){\\n           if(a[i]==c)\\n           cnt--;\\n           i++;\\n          }  \\n          ans=max(j-i+1,ans);\\n          j++;\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string a, int k) {\\n       \\n        int ans1=solve(a,k,\\'T\\');\\n        int ans2=solve(a,k,\\'F\\');\\n         return max(ans1,ans2);\\n    }\\n};\\n```\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/b730d6f2-b0f1-453a-89c2-e9974d1bba04_1688701185.815538.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string a, int k,char c){\\n         int i=0;\\n        int j=0;\\n        int cnt=0;\\n        int n=a.size();\\n        int ans=0;\\n          while(j<n){\\n          if(a[j]==c)\\n          cnt++;\\n          while(i<n&&cnt>k){\\n           if(a[i]==c)\\n           cnt--;\\n           i++;\\n          }  \\n          ans=max(j-i+1,ans);\\n          j++;\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string a, int k) {\\n       \\n        int ans1=solve(a,k,\\'T\\');\\n        int ans2=solve(a,k,\\'F\\');\\n         return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588019,
                "title": "beginner-friendly-c-sliding-window-one-traversal",
                "content": "**Intution -** \\n\\nIf we carefully observe the problem , then we can see that we need to **find the length of the longest substring in which min(number of True , number of False) should be <= k.**\\n\\n**Why?**\\n\\nBecause we can invert true and false both to make all the chars similar in a window , so we can do so by inverting the one among true and false which are present in less number means we should try to flip the char whose frequency is less , if and only if it\\'s frequency is less than k.\\n\\n**Consider an example** - \\n\\nstr = \"TTFTF\"\\nk=1\\n\\nwindow  -> \"T\"   count of T = 1   count of F = 0   minCount = 0   which is <= k  acceptable window\\n\\nwindow  -> \"TT\" count of T = 2   count of F = 0   minCount = 0   which is <= k  acceptable window\\n\\nwindow -> \"TTF\" count of T = 2  count of F = 1   minCount = 1   which is <= k  acceptable window\\nNow in above window F is less in count and it <=k so can flip F to T\\n\\nwindow -> \"TTFT\" count of T = 3  count of F = 1   minCount = 1   which is <= k  acceptable window\\n\\nwindow -> \"TTFTF\" count of T = 3  count of F = 2   minCount = 2   which is > k  not acceptable window\\nNow we need to shrink the window\\n\\nwindow -> \"TFTF\" count of T = 2  count of F = 2   minCount = 2   which is > k  not acceptable window\\n\\nwindow -> \"FTF\" count of T = 1  count of F = 2   minCount = 1   which is <= k  acceptable window\\n**here you can see that now T is less in number so we can flip T to F in this case** \\n\\nHope the Dry Run clears the Approach and intution\\n\\nCode - \\n\\n```\\nint maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0 , j = 0 , nT = 0 , nF = 0 , n = answerKey.size() , len = 0;\\n        \\n        while(j<n)\\n        {\\n            answerKey[j]==\\'T\\'?nT++:nF++;\\n\\t\\t\\t//minimum among T and F\\n            int count = min(nT,nF);\\n            \\n\\t\\t\\t//update the length if condition holds good\\n            if(count<=k)\\n                len = max(len , j-i+1);\\n            else{\\n\\t\\t\\t   //shrink the window\\n                while(count>k)\\n                {\\n                    answerKey[i]==\\'T\\'?nT--:nF--;\\n                    count = min(nT,nF);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return len;\\n    }\\n```\\n\\nHope you like the Approach , Do upvote if it helped you and you like the concept.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0 , j = 0 , nT = 0 , nF = 0 , n = answerKey.size() , len = 0;\\n        \\n        while(j<n)\\n        {\\n            answerKey[j]==\\'T\\'?nT++:nF++;\\n\\t\\t\\t//minimum among T and F\\n            int count = min(nT,nF);\\n            \\n\\t\\t\\t//update the length if condition holds good\\n            if(count<=k)\\n                len = max(len , j-i+1);\\n            else{\\n\\t\\t\\t   //shrink the window\\n                while(count>k)\\n                {\\n                    answerKey[i]==\\'T\\'?nT--:nF--;\\n                    count = min(nT,nF);\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499033,
                "title": "c-sliding-window-cheat-sheet",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Sliding Window\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\" which can help you solve all sliding window problems.\\n\\n**Intuition**: Use a sliding window to get the longest substring with at most `k` `\\'T\\'` (or `\\'F\\'`).\\n\\n**Algorithm**: Implement a function `count(c)` which gets the longest substring with at most `k` character `c`. The answer is `max(count(\\'T\\'), count(\\'F\\'))`\\n\\nWe can use a shrinkable sliding window:\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int count(string &s, int k, char c) {\\n        int N = s.size(), cnt = 0, i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j) {\\n            cnt += s[j] == c;\\n            while (cnt > k) cnt -= s[i++] == c; // if there are more than `k` `c` characters, shrink the window until the `cnt` drops back to `k`.\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n```\\n\\nOr use non-shrinkable sliding window:\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int count(string &s, int k, char c) {\\n        int N = s.size(), cnt = 0, i = 0, j = 0;\\n        for (; j < N; ++j) {\\n            cnt += s[j] == c;\\n            if (cnt > k) cnt -= s[i++] == c; // If `cnt > k` we shift the window.\\n        }\\n        return j - i;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int count(string &s, int k, char c) {\\n        int N = s.size(), cnt = 0, i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j) {\\n            cnt += s[j] == c;\\n            while (cnt > k) cnt -= s[i++] == c; // if there are more than `k` `c` characters, shrink the window until the `cnt` drops back to `k`.\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-62/problems/maximize-the-confusion-of-an-exam/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int count(string &s, int k, char c) {\\n        int N = s.size(), cnt = 0, i = 0, j = 0;\\n        for (; j < N; ++j) {\\n            cnt += s[j] == c;\\n            if (cnt > k) cnt -= s[i++] == c; // If `cnt > k` we shift the window.\\n        }\\n        return j - i;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499992,
                "title": "1004-max-consecutive-ones-iii",
                "content": "This is exactly the same as [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/). \\n\\nThe only difference is that we need to do it twice - once for \\'T\\' and once for \\'F\\'.\\n\\n**C++**\\n```cpp\\nint window(string &key, int k, char ans) {\\n    int j = 0;\\n    for (int i = 0; i < key.size(); ++i) {\\n        k -= key[i] != ans;\\n        if (k < 0)\\n            k += key[j++] != ans;\\n    }\\n    return key.size() - j;\\n}\\nint maxConsecutiveAnswers(string answerKey, int k) {\\n    return max(window(answerKey, k, \\'T\\'), window(answerKey, k, \\'F\\'));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint window(string &key, int k, char ans) {\\n    int j = 0;\\n    for (int i = 0; i < key.size(); ++i) {\\n        k -= key[i] != ans;\\n        if (k < 0)\\n            k += key[j++] != ans;\\n    }\\n    return key.size() - j;\\n}\\nint maxConsecutiveAnswers(string answerKey, int k) {\\n    return max(window(answerKey, k, \\'T\\'), window(answerKey, k, \\'F\\'));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729861,
                "title": "c-easy-explanation-beginner-friendly",
                "content": "# Approach\\n1. Initialize variables to keep track of the window boundaries, character counts, and the maximum substring length.\\n\\n2. Iterate through the string and update the counts of `T` and `F` characters within the window.\\n3. If both count exceeds the allowed limit `k`, move the window\\'s `start` to the right until the counts are within the limit.\\n4. Update the maximum substring length seen so far. Move the window\\'s `end` to the right to consider the next character.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = 0;\\n        int t = 0, f = 0; // Counters for \\'T\\' and \\'F\\' characters\\n        int ans = 0; // Maximum consecutive answers\\n\\n        while (end < n) {\\n            // Update counters based on the current character\\n            t += (s[end] == \\'T\\');\\n            f += (s[end] == \\'F\\');\\n\\n            while (t > k && f > k) {\\n                // If both counters exceed \\'k\\', move the start pointer and adjust counters\\n                if (s[start] == \\'T\\')\\n                    t--;\\n                else\\n                    f--;\\n                start++;\\n            }\\n\\n            ans = max(ans, end - start + 1); // Update the maximum consecutive answers\\n            end++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = 0;\\n        int t = 0, f = 0; // Counters for \\'T\\' and \\'F\\' characters\\n        int ans = 0; // Maximum consecutive answers\\n\\n        while (end < n) {\\n            // Update counters based on the current character\\n            t += (s[end] == \\'T\\');\\n            f += (s[end] == \\'F\\');\\n\\n            while (t > k && f > k) {\\n                // If both counters exceed \\'k\\', move the start pointer and adjust counters\\n                if (s[start] == \\'T\\')\\n                    t--;\\n                else\\n                    f--;\\n                start++;\\n            }\\n\\n            ans = max(ans, end - start + 1); // Update the maximum consecutive answers\\n            end++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499047,
                "title": "python-3-sliding-window-o-n-while-loop-vs-if",
                "content": "Move left pointer if both T and F exceed k, otherwise the window is valid.\\n```\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        d = collections.Counter()\\n        max_window = 0\\n        i = 0\\n        for j in range(len(answerKey)):\\n            d[answerKey[j]] += 1\\n            \\n            while d[\\'T\\'] > k and d[\\'F\\'] > k:\\n                d[answerKey[i]] -= 1\\n                i += 1\\n                \\n            max_window = max(max_window, j-i+1)\\n            \\n        return max_window\\n```\\n\\n#### Without while loop\\nWe never need to shrink the window size because even if a valid smaller window is found, it doesn\\'t change the max window size. So we can just move left pointer by 1 step if window is invalid (thus next window is still the same length).\\n```\\ndef maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        d = collections.Counter()\\n        max_window = 0\\n        i = 0\\n        for j in range(len(answerKey)):\\n            d[answerKey[j]] += 1\\n            \\n            if d[\\'T\\'] > k and d[\\'F\\'] > k:    # invalid - just move 1 step\\n                d[answerKey[i]] -= 1\\n                i += 1\\n            else:    # valid\\n                max_window = max(max_window, j-i+1)\\n            \\n        return max_window\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        d = collections.Counter()\\n        max_window = 0\\n        i = 0\\n        for j in range(len(answerKey)):\\n            d[answerKey[j]] += 1\\n            \\n            while d[\\'T\\'] > k and d[\\'F\\'] > k:\\n                d[answerKey[i]] -= 1\\n                i += 1\\n                \\n            max_window = max(max_window, j-i+1)\\n            \\n        return max_window\\n```\n```\\ndef maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        d = collections.Counter()\\n        max_window = 0\\n        i = 0\\n        for j in range(len(answerKey)):\\n            d[answerKey[j]] += 1\\n            \\n            if d[\\'T\\'] > k and d[\\'F\\'] > k:    # invalid - just move 1 step\\n                d[answerKey[i]] -= 1\\n                i += 1\\n            else:    # valid\\n                max_window = max(max_window, j-i+1)\\n            \\n        return max_window\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3729974,
                "title": "c-sliding-window-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int extra=0,mx=0;\\n        int i=0,j=0;\\n        while(j<s.size()){ //For consecutive TRUE\\n            if(s[j]==\\'F\\'){\\n                extra++;\\n                while(extra>k){\\n                    if(s[i]==\\'F\\')extra--;\\n                    i++;\\n                }\\n            }\\n            mx = max(mx,j-i+1);\\n            j++;\\n        }\\n        i=0;j=0;\\n        extra=0;\\n        while(j<s.size()){ //For consecutive FALSE\\n            if(s[j]==\\'T\\'){\\n                extra++;\\n                while(extra>k){\\n                    if(s[i]==\\'T\\')extra--;\\n                    i++;\\n                }\\n            }\\n            mx = max(mx,j-i+1);\\n            j++;\\n        }\\n        return mx;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/af9c096e-0e2a-4935-9b2a-82dca61efd0d_1688702231.7919717.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int extra=0,mx=0;\\n        int i=0,j=0;\\n        while(j<s.size()){ //For consecutive TRUE\\n            if(s[j]==\\'F\\'){\\n                extra++;\\n                while(extra>k){\\n                    if(s[i]==\\'F\\')extra--;\\n                    i++;\\n                }\\n            }\\n            mx = max(mx,j-i+1);\\n            j++;\\n        }\\n        i=0;j=0;\\n        extra=0;\\n        while(j<s.size()){ //For consecutive FALSE\\n            if(s[j]==\\'T\\'){\\n                extra++;\\n                while(extra>k){\\n                    if(s[i]==\\'T\\')extra--;\\n                    i++;\\n                }\\n            }\\n            mx = max(mx,j-i+1);\\n            j++;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729656,
                "title": "video-solution-sliding-window-2-pointers",
                "content": "1. We want to find the longest stretch of consecutive characters . \\n2. We can change up to k characters (either \\'T\\' to \\'F\\' or \\'F\\' to \\'T\\') within that stretch. \\n3. keep track of the counts of \\'F\\' and \\'T\\' characters using countF and countT. If we exceed the limit of allowed changes (k) for the minimum character count, we shrink the window from the left side. \\n4. Store length of longest stretch in the ans variable. Whenever we find a longer stretch, we update the ans value.\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/157I9vQ_ZsM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int countF = 0; int countT=0;\\n        int i = 0; int j = 0;\\n        int ans = 0;\\n        while(j<answerKey.length()){\\n            if(answerKey.charAt(j)==\\'F\\')countF++;\\n            else countT++;\\n            while (Math.min(countF,countT)>k){\\n                if(answerKey.charAt(i)==\\'F\\')countF--;\\n                else countT--;\\n                i++;\\n            }\\n            ans = Math.max(ans,countF+countT);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(std::string answerKey, int k) {\\n        int countF = 0;\\n        int countT = 0;\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        \\n        while (j < answerKey.length()) {\\n            if (answerKey[j] == \\'F\\')\\n                countF++;\\n            else\\n                countT++;\\n            \\n            while (std::min(countF, countT) > k) {\\n                if (answerKey[i] == \\'F\\')\\n                    countF--;\\n                else\\n                    countT--;\\n                \\n                i++;\\n            }\\n            \\n            ans = std::max(ans, countF + countT);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        countF = 0\\n        countT = 0\\n        i = 0\\n        j = 0\\n        ans = 0\\n        \\n        while j < len(answerKey):\\n            if answerKey[j] == \\'F\\':\\n                countF += 1\\n            else:\\n                countT += 1\\n            \\n            while min(countF, countT) > k:\\n                if answerKey[i] == \\'F\\':\\n                    countF -= 1\\n                else:\\n                    countT -= 1\\n                \\n                i += 1\\n            \\n            ans = max(ans, countF + countT)\\n            j += 1\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int countF = 0; int countT=0;\\n        int i = 0; int j = 0;\\n        int ans = 0;\\n        while(j<answerKey.length()){\\n            if(answerKey.charAt(j)==\\'F\\')countF++;\\n            else countT++;\\n            while (Math.min(countF,countT)>k){\\n                if(answerKey.charAt(i)==\\'F\\')countF--;\\n                else countT--;\\n                i++;\\n            }\\n            ans = Math.max(ans,countF+countT);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(std::string answerKey, int k) {\\n        int countF = 0;\\n        int countT = 0;\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        \\n        while (j < answerKey.length()) {\\n            if (answerKey[j] == \\'F\\')\\n                countF++;\\n            else\\n                countT++;\\n            \\n            while (std::min(countF, countT) > k) {\\n                if (answerKey[i] == \\'F\\')\\n                    countF--;\\n                else\\n                    countT--;\\n                \\n                i++;\\n            }\\n            \\n            ans = std::max(ans, countF + countT);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        countF = 0\\n        countT = 0\\n        i = 0\\n        j = 0\\n        ans = 0\\n        \\n        while j < len(answerKey):\\n            if answerKey[j] == \\'F\\':\\n                countF += 1\\n            else:\\n                countT += 1\\n            \\n            while min(countF, countT) > k:\\n                if answerKey[i] == \\'F\\':\\n                    countF -= 1\\n                else:\\n                    countT -= 1\\n                \\n                i += 1\\n            \\n            ans = max(ans, countF + countT)\\n            j += 1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730589,
                "title": "java-sliding-window-easy",
                "content": "# Please upvote for your support!!!\\n\\n![image](https://assets.leetcode.com/users/images/d9c991aa-178d-42a7-aeca-b6caa063fa37_1688710363.2037354.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        char [] arr = answerKey.toCharArray();\\n        int ans =0;\\n        int st =0, c =0;\\n        for(int i =0;i <arr.length;i ++){\\n\\n            if(arr[i]==\\'F\\'){\\n                c++;\\n            }\\n            while(c>k){\\n\\n                if(arr[st]==\\'F\\')\\n                    c--;\\n                st++;\\n\\n            }\\n            ans =Math.max(ans,i-st+1);\\n\\n\\n        }\\n        st =0;\\n        c =0;\\n        for(int i =0;i <arr.length;i ++){\\n\\n            if(arr[i]==\\'T\\'){\\n                c++;\\n            }\\n            while(c>k){\\n\\n                if(arr[st]==\\'T\\')\\n                    c--;\\n                st++;\\n\\n            }\\n            ans =Math.max(ans,i-st+1);\\n\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        char [] arr = answerKey.toCharArray();\\n        int ans =0;\\n        int st =0, c =0;\\n        for(int i =0;i <arr.length;i ++){\\n\\n            if(arr[i]==\\'F\\'){\\n                c++;\\n            }\\n            while(c>k){\\n\\n                if(arr[st]==\\'F\\')\\n                    c--;\\n                st++;\\n\\n            }\\n            ans =Math.max(ans,i-st+1);\\n\\n\\n        }\\n        st =0;\\n        c =0;\\n        for(int i =0;i <arr.length;i ++){\\n\\n            if(arr[i]==\\'T\\'){\\n                c++;\\n            }\\n            while(c>k){\\n\\n                if(arr[st]==\\'T\\')\\n                    c--;\\n                st++;\\n\\n            }\\n            ans =Math.max(ans,i-st+1);\\n\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730567,
                "title": "amazon-2-variable-size-sliding-window-with-proper-explanation-of-approach-and-complexities",
                "content": "# Intuition\\nmaximize the number of consecutive questions with same answer->it gives intuition of sliding window becuse we need consecutive(contiguous sub-array) and optimal solution needed from the window(sub-array) i.e. **find maximum substring of \\'T\\' which contains at most k \\'F\\' or maximum substring of \\'F\\' which contains at most k \\'T\\'.** It is a variable sized sliding window question\\n\\n# Approach\\n- We can also think like find count of \\'T\\' and \\'F\\' in the substring and find which is minimum from them and compare it with k to change the minimum one as it will be optimal to transform the minimum one.\\n- maintain count of true and false while iterating. \\n- The condition of sliding the window is when the minimum of count of true or false exceeds k then shift until it satisfies the condition. Maintain the maxi variable throughout to find maximum size of sliding window when it is satisfying the condition of k.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\nsliding window from 0 to n-1. In worst condition it will be O(2n) precisely O(n) for outer loop + O(n) for inner loop (because it is not always running n times for every outer loop, it is in total running for n for eg first time it run for 1 time then 2 and so one i.e 1+2+3+..+n ,still its submission is n so add the complexity). \\n\\n- Space complexity:\\nO(1)\\nAlthough hashmap is used but it is storing count of just two elements i.e. true and false so precisely O(2) i.e. constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        unordered_map<char,int>mp;\\n        int i=0,j=0;\\n        int maxi=0;\\n        while(j<answerKey.size())\\n        {\\n            mp[answerKey[j]]++;\\n            while(min(mp[\\'T\\'],mp[\\'F\\'])>k)\\n            {\\n                mp[answerKey[i]]--;\\n                i++;\\n            }\\n            maxi=max(maxi,j-i+1);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        unordered_map<char,int>mp;\\n        int i=0,j=0;\\n        int maxi=0;\\n        while(j<answerKey.size())\\n        {\\n            mp[answerKey[j]]++;\\n            while(min(mp[\\'T\\'],mp[\\'F\\'])>k)\\n            {\\n                mp[answerKey[i]]--;\\n                i++;\\n            }\\n            maxi=max(maxi,j-i+1);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729597,
                "title": "c-o-n-2-pointer-sliding-window",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int count(string s, int k, char ch){\\n        int n=s.length();\\n        \\n        int maxlen=0, bad=0; // count of opposite parity character\\n        \\n        int i=0, j=0;\\n        while(j<n){\\n            if(s[j]!=ch) bad++; // check if we are acquiring a bad character at rear end\\n            \\n            while(i<=j && bad>k){\\n                char cur=s[i];\\n                if(cur!=ch) bad--; // releasing bad characters acquired from front end\\n                i++;\\n            }\\n            \\n            maxlen=max(maxlen,j-i+1);\\n            j++;\\n        }\\n        return maxlen;\\n    }\\n    \\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s,k,\\'T\\'),count(s,k,\\'F\\')); // max number of consecutive \\'T\\'s or \\'F\\'s\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count(string s, int k, char ch){\\n        int n=s.length();\\n        \\n        int maxlen=0, bad=0; // count of opposite parity character\\n        \\n        int i=0, j=0;\\n        while(j<n){\\n            if(s[j]!=ch) bad++; // check if we are acquiring a bad character at rear end\\n            \\n            while(i<=j && bad>k){\\n                char cur=s[i];\\n                if(cur!=ch) bad--; // releasing bad characters acquired from front end\\n                i++;\\n            }\\n            \\n            maxlen=max(maxlen,j-i+1);\\n            j++;\\n        }\\n        return maxlen;\\n    }\\n    \\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s,k,\\'T\\'),count(s,k,\\'F\\')); // max number of consecutive \\'T\\'s or \\'F\\'s\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501080,
                "title": "java-solution-explanation",
                "content": "We have 2 cases:\\n1. When T sequence is the longest \\n2. When F sequence is the longest \\n\\nSo we compare both cases and return max \\n\\nFlipper function \\nLet\\'s observe 1st case as an example\\n- If we encounter T, then we increment counter \\n- If we encounter F, then we decrement k counter. It means that we flipped F->T and then increment counter. We save index.\\n\\tIf k==0 we take first encountered F and take away values befpre it\\n\\n```\\npublic int maxConsecutiveAnswers(String answerKey, int k) {\\n\\treturn Math.max(flipper(answerKey, k, \\'F\\'), flipper(answerKey, k, \\'T\\'));\\n}\\n\\npublic int flipper(String answerKey, int k, char countLetter) {\\n\\tint max = 0;\\n\\tint count = 0;\\n\\tLinkedList<Integer> queue = new LinkedList<>();\\n\\tfor (int i = 0; i < answerKey.length(); i++) {\\n\\t\\tchar letter = answerKey.charAt(i);\\n\\t\\tif (letter == countLetter) count++;\\n\\t\\telse if (k > 0) {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t\\tk--;\\n\\t\\t\\tcount++;\\n\\t\\t} else {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t\\tmax = Math.max(count, max);\\n\\t\\t\\tInteger firstEncountered = queue.removeFirst();\\n\\t\\t\\tcount = i - firstEncountered;\\n\\t\\t}\\n\\t}\\n\\tmax = Math.max(count, max);\\n\\treturn max;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic int maxConsecutiveAnswers(String answerKey, int k) {\\n\\treturn Math.max(flipper(answerKey, k, \\'F\\'), flipper(answerKey, k, \\'T\\'));\\n}\\n\\npublic int flipper(String answerKey, int k, char countLetter) {\\n\\tint max = 0;\\n\\tint count = 0;\\n\\tLinkedList<Integer> queue = new LinkedList<>();\\n\\tfor (int i = 0; i < answerKey.length(); i++) {\\n\\t\\tchar letter = answerKey.charAt(i);\\n\\t\\tif (letter == countLetter) count++;\\n\\t\\telse if (k > 0) {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t\\tk--;\\n\\t\\t\\tcount++;\\n\\t\\t} else {\\n\\t\\t\\tqueue.add(i);\\n\\t\\t\\tmax = Math.max(count, max);\\n\\t\\t\\tInteger firstEncountered = queue.removeFirst();\\n\\t\\t\\tcount = i - firstEncountered;\\n\\t\\t}\\n\\t}\\n\\tmax = Math.max(count, max);\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499054,
                "title": "java-python-3-longest-sliding-window-w-at-most-k-t-or-f",
                "content": "We can respectively replace at most `k`\\n1. `T`s;\\n2. `F`s.\\n\\nIn either of the above `2` cases we use sliding window algorithm to find the longest substring that contains at most `k` `T`s / `F`s, then return the greater one.\\n\\n```java\\t\\n    public int maxConsecutiveAnswers(String key, int k) {\\n        return Math.max(longestWin(key, \\'T\\', k), longestWin(key, \\'F\\', k));\\n    }\\n    private int longestWin(String key, char c, int k) {\\n        int win = 0;\\n        for (int lo = -1, hi = 0; hi < key.length(); ++hi) {\\n            k -= key.charAt(hi) == c ? 1 : 0;\\n            while (k < 0) {\\n                k += key.charAt(++lo) == c ? 1 : 0;\\n            }\\n            win = Math.max(win, hi - lo);\\n        }\\n        return win;\\n    }\\n```\\n```python\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        \\n        def longestWin(c: str, k: int) -> int:\\n            lo, win = -1, 0\\n            for hi in range(len(answerKey)):\\n                k -= answerKey[hi] == c\\n                while k < 0:\\n                    lo += 1\\n                    k += answerKey[lo] == c\\n                win = max(win, hi - lo)\\n            return win     \\n\\n        return max(longestWin(\\'T\\', k), longestWin(\\'F\\', k))\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = answerKey.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\t\\n    public int maxConsecutiveAnswers(String key, int k) {\\n        return Math.max(longestWin(key, \\'T\\', k), longestWin(key, \\'F\\', k));\\n    }\\n    private int longestWin(String key, char c, int k) {\\n        int win = 0;\\n        for (int lo = -1, hi = 0; hi < key.length(); ++hi) {\\n            k -= key.charAt(hi) == c ? 1 : 0;\\n            while (k < 0) {\\n                k += key.charAt(++lo) == c ? 1 : 0;\\n            }\\n            win = Math.max(win, hi - lo);\\n        }\\n        return win;\\n    }\\n```\n```python\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        \\n        def longestWin(c: str, k: int) -> int:\\n            lo, win = -1, 0\\n            for hi in range(len(answerKey)):\\n                k -= answerKey[hi] == c\\n                while k < 0:\\n                    lo += 1\\n                    k += answerKey[lo] == c\\n                win = max(win, hi - lo)\\n            return win     \\n\\n        return max(longestWin(\\'T\\', k), longestWin(\\'F\\', k))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1499425,
                "title": "c-easy-5-lines-sliding-window-solution",
                "content": "```\\nint maxConsecutiveAnswers(string s, int k) {\\n\\tint l = 0, r = 0, T = 0, F = 0, ans = 0;\\n\\twhile(r < s.length()) {\\n\\t\\ts[r] == \\'T\\' ? T++ : F++;\\n\\t\\twhile(min(T, F) > k) s[l++] == \\'T\\' ? T-- : F--;\\n\\t\\tans = max(ans, r - l + 1), r++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxConsecutiveAnswers(string s, int k) {\\n\\tint l = 0, r = 0, T = 0, F = 0, ans = 0;\\n\\twhile(r < s.length()) {\\n\\t\\ts[r] == \\'T\\' ? T++ : F++;\\n\\t\\twhile(min(T, F) > k) s[l++] == \\'T\\' ? T-- : F--;\\n\\t\\tans = max(ans, r - l + 1), r++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731354,
                "title": "simple-intuitive-approach",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        def getMaxCons(ansToChange):\\n            maxCons = 1\\n            numAnsToChange = 0\\n            p1 = 0\\n            for p2 in range(len(answerKey)):\\n                if answerKey[p2] == ansToChange:\\n                    numAnsToChange += 1\\n                    while numAnsToChange > k:\\n                        if answerKey[p1] == ansToChange:\\n                            numAnsToChange -= 1\\n                        p1 += 1\\n                maxCons = max(maxCons, p2-p1+1)\\n            return maxCons\\n\\n        return max(getMaxCons(\\'F\\'), getMaxCons(\\'T\\'))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        def getMaxCons(ansToChange):\\n            maxCons = 1\\n            numAnsToChange = 0\\n            p1 = 0\\n            for p2 in range(len(answerKey)):\\n                if answerKey[p2] == ansToChange:\\n                    numAnsToChange += 1\\n                    while numAnsToChange > k:\\n                        if answerKey[p1] == ansToChange:\\n                            numAnsToChange -= 1\\n                        p1 += 1\\n                maxCons = max(maxCons, p2-p1+1)\\n            return maxCons\\n\\n        return max(getMaxCons(\\'F\\'), getMaxCons(\\'T\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730026,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->When approaching the problem of finding the maximum number of consecutive characters in a string with at most \\'k\\' changes allowed, my initial thoughts would be to use a sliding window approach.\\n\\nHere\\'s a high-level outline of how I would approach the problem:\\n\\n1. Define two pointers, \\'i\\' and \\'j\\', to represent the start and end of the window, respectively.\\n2. Initialize variables \\'maxlen\\' and \\'bad\\' to keep track of the maximum length of consecutive characters and the count of opposite parity characters within the window.\\n3. Iterate through the string using the \\'j\\' pointer, moving it one character at a time.\\n4. If the current character at \\'j\\' is different from the desired character \\'ch\\', increment the \\'bad\\' count.\\n5. Check if the \\'bad\\' count exceeds the given limit \\'k\\'.\\n6. If \\'bad\\' is greater than \\'k\\', move the \\'i\\' pointer forward and decrement the \\'bad\\' count by releasing the bad characters from the front end of the window.\\n7. Calculate the length of the current window as \\'j - i + 1\\' and update \\'maxlen\\' if necessary.\\n8. Repeat steps 4-7 until the end of the string is reached.\\n9. Return the maximum length \\'maxlen\\' obtained.\\n\\nBy using this sliding window approach, we can efficiently traverse the string and keep track of the maximum length of consecutive characters while considering the given constraints.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem of finding the maximum number of consecutive characters in a string with at most \\'k\\' changes allowed, I would follow the approach outlined below:\\n\\n1. Define a helper function called `count` that takes three parameters: the input string \\'s\\', the maximum number of allowed changes \\'k\\', and the desired character \\'ch\\'. This function will calculate the maximum length of consecutive characters \\'ch\\' in \\'s\\' with at most \\'k\\' changes allowed.\\n2. Initialize variables \\'maxlen\\' and \\'bad\\' to 0. These variables will store the maximum length of consecutive characters and the count of opposite parity characters within the window, respectively.\\n3. Initialize two pointers, \\'i\\' and \\'j\\', to 0. These pointers represent the start and end of the window, respectively.\\n4. Iterate through the string \\'s\\' using the \\'j\\' pointer. At each step:\\n   - If the character at \\'j\\' is different from the desired character \\'ch\\', increment the \\'bad\\' count.\\n   - Enter a nested while loop that checks if the \\'bad\\' count exceeds the given limit \\'k\\'. If it does, move the \\'i\\' pointer forward and decrement the \\'bad\\' count by releasing the bad characters from the front end of the window.\\n   - Calculate the length of the current window as \\'j - i + 1\\' and update \\'maxlen\\' if necessary.\\n   - Increment the \\'j\\' pointer to move the window forward.\\n5. Return the final value of \\'maxlen\\' obtained.\\n6. In the main function, \\'maxConsecutiveAnswers\\', call the \\'count\\' function twice: once for character \\'T\\' and once for character \\'F\\'. Return the maximum value between the two counts.\\n\\nBy using this approach, we can effectively track the maximum length of consecutive characters \\'ch\\' in the string while considering the constraint of at most \\'k\\' changes. The sliding window technique helps in efficiently traversing the string and maintaining the maximum length.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Counts the maximum length of consecutive characters \\'ch\\' in \\'s\\' with at most \\'k\\' changes allowed\\n    int count(string s, int k, char ch) {\\n        int n = s.length();\\n        int maxlen = 0, bad = 0; // Count of opposite parity character\\n\\n        int i = 0, j = 0;\\n        while (j < n) {\\n            if (s[j] != ch)\\n                bad++; // Check if we are acquiring a bad character at the rear end\\n\\n            while (i <= j && bad > k) {\\n                char cur = s[i];\\n                if (cur != ch)\\n                    bad--; // Releasing bad characters acquired from the front end\\n                i++;\\n            }\\n\\n            maxlen = max(maxlen, j - i + 1);\\n            j++;\\n        }\\n\\n        return maxlen;\\n    }\\n\\n    // Returns the maximum number of consecutive \\'T\\'s or \\'F\\'s in \\'s\\' with at most \\'k\\' changes allowed\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/697d47c7-3167-4c33-8a7a-42da464de718_1688702760.0931206.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Counts the maximum length of consecutive characters \\'ch\\' in \\'s\\' with at most \\'k\\' changes allowed\\n    int count(string s, int k, char ch) {\\n        int n = s.length();\\n        int maxlen = 0, bad = 0; // Count of opposite parity character\\n\\n        int i = 0, j = 0;\\n        while (j < n) {\\n            if (s[j] != ch)\\n                bad++; // Check if we are acquiring a bad character at the rear end\\n\\n            while (i <= j && bad > k) {\\n                char cur = s[i];\\n                if (cur != ch)\\n                    bad--; // Releasing bad characters acquired from the front end\\n                i++;\\n            }\\n\\n            maxlen = max(maxlen, j - i + 1);\\n            j++;\\n        }\\n\\n        return maxlen;\\n    }\\n\\n    // Returns the maximum number of consecutive \\'T\\'s or \\'F\\'s in \\'s\\' with at most \\'k\\' changes allowed\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499170,
                "title": "c-sliding-window-2-pointer",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** We need to find longest substring either of \\'T\\' or \\'F\\' containing at most k charcters of other type.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int count(string s, int k, char ch){\\n        int n=s.length();\\n        int maxlen=0, bad=0;\\n        int i=0, j=0;\\n        while(j<n){\\n            if(s[j]!=ch) bad++; // we can include at most K charcters of other type in our current substring\\n            while(i<=j && bad>k){\\n                char cur=s[i];\\n                if(cur!=ch) bad--;\\n                i++;\\n            }\\n\\t\\t\\tint len=j-i+1;\\n            maxlen=max(maxlen,len);\\n            j++;\\n        }\\n        return maxlen;\\n    }\\n    \\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s,k,\\'T\\'),count(s,k,\\'F\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count(string s, int k, char ch){\\n        int n=s.length();\\n        int maxlen=0, bad=0;\\n        int i=0, j=0;\\n        while(j<n){\\n            if(s[j]!=ch) bad++; // we can include at most K charcters of other type in our current substring\\n            while(i<=j && bad>k){\\n                char cur=s[i];\\n                if(cur!=ch) bad--;\\n                i++;\\n            }\\n\\t\\t\\tint len=j-i+1;\\n            maxlen=max(maxlen,len);\\n            j++;\\n        }\\n        return maxlen;\\n    }\\n    \\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(count(s,k,\\'T\\'),count(s,k,\\'F\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730006,
                "title": "c-no-binary-search-just-do-what-it-says",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        vector<pair<int,int>> v;\\n        pair<int,int> prev={0,0};\\n        int maxi=0;\\n        for(int i = 0; i<answerKey.length(); i++){\\n            if(answerKey[i]==\\'T\\'){\\n                prev.first++;\\n                v.push_back(prev);\\n            }\\n            else{\\n                prev.second++;\\n                v.push_back(prev);\\n            }\\n            if(min(prev.first,prev.second)<=k)maxi=i+1;\\n        }\\n        prev={0,0};\\n        int i=0;\\n        int index=0;\\n        \\n        while(i<v.size()){\\n            if(min(v[i].first-prev.first,v[i].second-prev.second)<=k){\\n                \\n                i++;\\n            }\\n            else{\\n                maxi=max(maxi,i-index);\\n                \\n                prev=v[index];\\n                index++;\\n            }\\n        }\\n        \\n        return max(maxi,i-index);\\n    }\\n};\\n```\\n```  \\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        vector<pair<int,int>> v;\\n        pair<int,int> prev={0,0};\\n        int maxi=0;\\n        for(int i = 0; i<answerKey.length(); i++){\\n            if(answerKey[i]==\\'T\\'){\\n                prev.first++;\\n                v.push_back(prev);\\n            }\\n            else{\\n                prev.second++;\\n                v.push_back(prev);\\n            }\\n            if(min(prev.first,prev.second)<=k)maxi=i+1;\\n        }\\n        prev={0,0};\\n        int i=0;\\n        int index=0;\\n        \\n        while(i<v.size()){\\n            if(min(v[i].first-prev.first,v[i].second-prev.second)<=k){\\n                \\n                i++;\\n            }\\n            else{\\n                maxi=max(maxi,i-index);\\n                \\n                prev=v[index];\\n                index++;\\n            }\\n        }\\n        \\n        return max(maxi,i-index);\\n    }\\n};\\n```\n```  \\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865245,
                "title": "javascript-o-n-sliding-window-solution-faster-than-95-easy-to-read-and-understand",
                "content": "```\\nvar maxConsecutiveAnswers = function(answerKey, k) {\\n    let [left, right, numOfTrue, numOfFalse, max] = new Array(5).fill(0);\\n    const moreChanges = () => numOfTrue > k && numOfFalse > k;\\n    while (right < answerKey.length) {\\n        if(answerKey[right] === \\'T\\') numOfTrue++;\\n        if(answerKey[right] === \\'F\\') numOfFalse++;\\n        while(moreChanges()) {\\n            if(answerKey[left] === \\'T\\') numOfTrue--;\\n            if(answerKey[left] === \\'F\\') numOfFalse--;    \\n            left++;    \\n        }\\n        max = Math.max(max, right - left + 1);\\n        right++;\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar maxConsecutiveAnswers = function(answerKey, k) {\\n    let [left, right, numOfTrue, numOfFalse, max] = new Array(5).fill(0);\\n    const moreChanges = () => numOfTrue > k && numOfFalse > k;\\n    while (right < answerKey.length) {\\n        if(answerKey[right] === \\'T\\') numOfTrue++;\\n        if(answerKey[right] === \\'F\\') numOfFalse++;\\n        while(moreChanges()) {\\n            if(answerKey[left] === \\'T\\') numOfTrue--;\\n            if(answerKey[left] === \\'F\\') numOfFalse--;    \\n            left++;    \\n        }\\n        max = Math.max(max, right - left + 1);\\n        right++;\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732296,
                "title": "sliding-window-java-python-c",
                "content": "# Simple Sliding Window Technique : \\n> #### There are two options where we can achieve max length using consecutive F\\'s or consecutive T\\'s so maintain a sliding window and calculate consecutive T\\'s with replacement of atmost k and also calculate consecutive F\\'s with k replacement and return the maximum of these two. \\n\\n```java []\\nclass Solution {\\n\\t\\tpublic int getAnswer(String str,int k,char ch)\\n\\t\\t{\\n\\t\\t\\t\\tint left = 0;\\n\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int i = 0;i<str.length();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(str.charAt(i) == ch)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\twhile(count > k)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(str.charAt(left) == ch)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tans = Math.max(ans,i-left+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n    public int maxConsecutiveAnswers(String str, int k) {\\n        return Math.max(getAnswer(str,k,\\'T\\'),getAnswer(str,k,\\'F\\'));\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def getAnswer(self, string, k, ch):\\n        left = 0\\n        ans = 0\\n        count = 0\\n        for i in range(len(string)):\\n            if string[i] == ch:\\n                count += 1\\n            while count > k:\\n                if string[left] == ch:\\n                    count -= 1\\n                left += 1\\n            ans = max(ans, i - left + 1)\\n        return ans\\n\\n    def maxConsecutiveAnswers(self, string, k):\\n        return max(self.getAnswer(string, k, \\'T\\'), self.getAnswer(string, k, \\'F\\'))\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int getAnswer(string str, int k, char ch) {\\n        int left = 0;\\n        int ans = 0;\\n        int count = 0;\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str[i] == ch) {\\n                count++;\\n            }\\n            while (count > k) {\\n                if (str[left] == ch) {\\n                    count--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, i - left + 1);\\n        }\\n        return ans;\\n    }\\n\\n    int maxConsecutiveAnswers(string str, int k) {\\n        return max(getAnswer(str, k, \\'T\\'), getAnswer(str, k, \\'F\\'));\\n    }\\n};\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\uD83C\\uDF40\\n---\\n>####  \\u26A0\\uFE0F *This problem is similar to leetcode 424 : Longest Repeating Character Replacement . If you\\'re interested try this too.* \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```java []\\nclass Solution {\\n\\t\\tpublic int getAnswer(String str,int k,char ch)\\n\\t\\t{\\n\\t\\t\\t\\tint left = 0;\\n\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int i = 0;i<str.length();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(str.charAt(i) == ch)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\twhile(count > k)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(str.charAt(left) == ch)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tans = Math.max(ans,i-left+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n    public int maxConsecutiveAnswers(String str, int k) {\\n        return Math.max(getAnswer(str,k,\\'T\\'),getAnswer(str,k,\\'F\\'));\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def getAnswer(self, string, k, ch):\\n        left = 0\\n        ans = 0\\n        count = 0\\n        for i in range(len(string)):\\n            if string[i] == ch:\\n                count += 1\\n            while count > k:\\n                if string[left] == ch:\\n                    count -= 1\\n                left += 1\\n            ans = max(ans, i - left + 1)\\n        return ans\\n\\n    def maxConsecutiveAnswers(self, string, k):\\n        return max(self.getAnswer(string, k, \\'T\\'), self.getAnswer(string, k, \\'F\\'))\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int getAnswer(string str, int k, char ch) {\\n        int left = 0;\\n        int ans = 0;\\n        int count = 0;\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str[i] == ch) {\\n                count++;\\n            }\\n            while (count > k) {\\n                if (str[left] == ch) {\\n                    count--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, i - left + 1);\\n        }\\n        return ans;\\n    }\\n\\n    int maxConsecutiveAnswers(string str, int k) {\\n        return max(getAnswer(str, k, \\'T\\'), getAnswer(str, k, \\'F\\'));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730925,
                "title": "5-lines-of-clean-and-optimized-code-detailed-explanation",
                "content": "# Intuition\\nUpon first reading the problem, my initial thoughts are to find the maximum number of consecutive answers of the same type (either \"T\" or \"F\") with at most k allowed flips.\\n\\n# Approach\\nTo solve this problem, I would iterate through the answerKey string using two pointers, i and j, where i represents the current position and j represents the starting position of the current consecutive sequence.\\n\\nI would also maintain a count of the number of occurrences of each answer type (\"T\" and \"F\") using the cnt object.\\n\\nFor each position i, I would increment the count of the respective answer type in cnt. Then, I would check if the minimum count between \"T\" and \"F\" (i.e., Math.min(cnt.T, cnt.F)) is less than or equal to k. If it is, I would update the maximum length j by incrementing it.\\n\\nHowever, if the minimum count exceeds k, it means we have used up all the allowed flips. In that case, I need to decrement the count of the answer type at position i - j (i.e., the answer type at the starting position of the current sequence) in order to consider the possibility of flipping it later. Then, I would continue the process by moving the starting position j one step forward.\\n\\nFinally, I would return the maximum length j, which represents the maximum number of consecutive answers with at most k allowed flips.\\n\\n# Complexity\\n- Time complexity: The algorithm iterates through the answerKey string once, so the time complexity is O(n), where n is the length of the answerKey string.\\n- Space complexity: The algorithm uses a constant amount of extra space for the cnt object, so the space complexity is O(1).\\n\\n# Code\\n```\\nfunction maxConsecutiveAnswers(answerKey: string, k: number): number {\\n    let j = 0 , cnt = { T : 0 , F : 0}, n = answerKey.length;\\n    for( let i = 0 ; i < n ; i++ )\\n        cnt[answerKey[i]]++ ,\\n        Math.min( cnt.T , cnt.F ) <= k ? j++ : cnt[answerKey[i - j]]--;\\n    return j\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nfunction maxConsecutiveAnswers(answerKey: string, k: number): number {\\n    let j = 0 , cnt = { T : 0 , F : 0}, n = answerKey.length;\\n    for( let i = 0 ; i < n ; i++ )\\n        cnt[answerKey[i]]++ ,\\n        Math.min( cnt.T , cnt.F ) <= k ? j++ : cnt[answerKey[i - j]]--;\\n    return j\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730127,
                "title": "c-o-n-using-sliding-window",
                "content": "# Approach\\n1. Initialize two pointers `i` and `j` to track the start and end of the current window and `trueCount`, `falseCount` variables to keep track of the counts of consecutive \\'T\\' and \\'F\\' characters in the window and a `maxConsecutive` variable to store the maximum length of consecutive answers.\\n2. Iterate through the `answerKey` string using the `j` pointer:\\n- If the current character at index `j` is \\'T\\', increment `trueCount` by 1; otherwise, increment `falseCount` by 1.\\n- Check if both `trueCount` and `falseCount` are greater than `k`. If so, it means the number of replacements has exceeded the limit and we need to move the window.\\n- Enter the while loop to shrink the window and maintain the counts within the allowed limit:\\n  - Check the character at index `i` and decrement either `trueCount` or `falseCount` based on the character.\\n   - Increment `i` to move the window\\'s start by 1.\\n   - Update the maxConsecutive value by taking the maximum between the current `maxConsecutive` and the length of the current window `(j - i + 1)`.\\n- After the iteration, the `maxConsecutive` value stores the maximum length of consecutive answers. So, we return it.\\n\\nThe main idea behind the above algorithm is to utilize the sliding window technique to find the maximum length of consecutive answers while adjusting the window based on the number of replacements allowed (k).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k)\\n    {\\n        int i = 0, j = 0, trueCount = 0, falseCount = 0, maxConsecutive = INT_MIN;\\n\\n        for(int j=0; j<answerKey.size(); j++)\\n        {\\n            if(answerKey[j] == \\'T\\')\\n                trueCount++;\\n            else\\n                falseCount++;\\n\\n            while(trueCount > k && falseCount > k)\\n            {\\n                if (answerKey[i++] == \\'T\\')\\n                    trueCount--;\\n                else\\n                    falseCount--;\\n            }\\n\\n            maxConsecutive = max(maxConsecutive, j-i+1);\\n        }\\n\\n        return maxConsecutive;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k)\\n    {\\n        int i = 0, j = 0, trueCount = 0, falseCount = 0, maxConsecutive = INT_MIN;\\n\\n        for(int j=0; j<answerKey.size(); j++)\\n        {\\n            if(answerKey[j] == \\'T\\')\\n                trueCount++;\\n            else\\n                falseCount++;\\n\\n            while(trueCount > k && falseCount > k)\\n            {\\n                if (answerKey[i++] == \\'T\\')\\n                    trueCount--;\\n                else\\n                    falseCount--;\\n            }\\n\\n            maxConsecutive = max(maxConsecutive, j-i+1);\\n        }\\n\\n        return maxConsecutive;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729501,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        maxf=0\\n        ans=0\\n        count=collections.Counter()\\n        n=len(answerKey)\\n        for i in range(n):\\n            count[answerKey[i]]+=1\\n            maxf=max(maxf,count[answerKey[i]])\\n            if ans-maxf<k:\\n                ans+=1\\n\\n            else:\\n                count[answerKey[i-ans]]-=1\\n\\n        return ans            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        maxf=0\\n        ans=0\\n        count=collections.Counter()\\n        n=len(answerKey)\\n        for i in range(n):\\n            count[answerKey[i]]+=1\\n            maxf=max(maxf,count[answerKey[i]])\\n            if ans-maxf<k:\\n                ans+=1\\n\\n            else:\\n                count[answerKey[i-ans]]-=1\\n\\n        return ans            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499212,
                "title": "c-easy-binary-search-solution",
                "content": "The solution must lie between 1 and length of the array,\\nso we can apply binary search on it and check if we can make mid consecutive true or false by changing k or less then k answerkey element by sliding window\\n\\nEvery time we are taking slinding window of length mid and finding out the minimum no of change that we have to make to make the mid consecutive true or false\\n\\n## Solution \\n\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int low=0,high=answerKey.size(),ans=0,n=answerKey.size();\\n        while(high>=low)\\n        {\\n            int mid=low+(high-low)/2;\\n            int i=0,j=0,nt=0,nf=0,mi;\\n            for(i=0;i<mid;i++)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    nt++;\\n                else\\n                    nf++;\\n            }\\n            mi=min(nt,nf);  //assign minimum number of change to be made in these mid no of elements to make all element same\\n            while(i<n)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    nt++;\\n                else nf++;\\n                if(answerKey[j]==\\'T\\')\\n                    nt--;\\n                else nf--;\\n                mi=min(mi,min(nt,nf));\\n                i++;\\n                j++;\\n            }\\n            if(mi>k)\\n                high=mid-1;\\n            else {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int low=0,high=answerKey.size(),ans=0,n=answerKey.size();\\n        while(high>=low)\\n        {\\n            int mid=low+(high-low)/2;\\n            int i=0,j=0,nt=0,nf=0,mi;\\n            for(i=0;i<mid;i++)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    nt++;\\n                else\\n                    nf++;\\n            }\\n            mi=min(nt,nf);  //assign minimum number of change to be made in these mid no of elements to make all element same\\n            while(i<n)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    nt++;\\n                else nf++;\\n                if(answerKey[j]==\\'T\\')\\n                    nt--;\\n                else nf--;\\n                mi=min(mi,min(nt,nf));\\n                i++;\\n                j++;\\n            }\\n            if(mi>k)\\n                high=mid-1;\\n            else {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499017,
                "title": "c-easy-sliding-window-o-n",
                "content": "The question is same as \"https://leetcode.com/problems/max-consecutive-ones-iii/\"\\n\\nWe have to find the longest subarray which have at-most \"K\" False or \"K\" True.\\n\\nBelow is my code - \\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(longestTrue(s,k),longestFalse(s,k));\\n    }\\n\\n    // at most \"k\" false allowed\\n    int longestTrue(string a, int k) {\\n        int n = a.size();\\n        int left = 0 ;\\n        int maxi = -1;\\n        int False=0;\\n        for(int right = 0 ;right<n;right++)\\n        {\\n            False+=(a[right]==\\'F\\');\\n            while(False>k)\\n            {\\n                False-=(a[left++]==\\'F\\');\\n            }\\n            maxi = max(maxi , right-left+1);\\n        }\\n        return maxi;\\n    }\\n    \\n    // at most \"k\" True allowed\\n    int longestFalse(string a, int k) {\\n        int n = a.size();\\n        int left = 0 ;\\n        int maxi = -1;\\n        int True=0;\\n        for(int right = 0 ;right<n;right++)\\n        {\\n            True+=(a[right]==\\'T\\');\\n            while(True>k)\\n            {\\n                True-=(a[left++]==\\'T\\');\\n            }\\n            maxi = max(maxi , right-left+1);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(longestTrue(s,k),longestFalse(s,k));\\n    }\\n\\n    // at most \"k\" false allowed\\n    int longestTrue(string a, int k) {\\n        int n = a.size();\\n        int left = 0 ;\\n        int maxi = -1;\\n        int False=0;\\n        for(int right = 0 ;right<n;right++)\\n        {\\n            False+=(a[right]==\\'F\\');\\n            while(False>k)\\n            {\\n                False-=(a[left++]==\\'F\\');\\n            }\\n            maxi = max(maxi , right-left+1);\\n        }\\n        return maxi;\\n    }\\n    \\n    // at most \"k\" True allowed\\n    int longestFalse(string a, int k) {\\n        int n = a.size();\\n        int left = 0 ;\\n        int maxi = -1;\\n        int True=0;\\n        for(int right = 0 ;right<n;right++)\\n        {\\n            True+=(a[right]==\\'T\\');\\n            while(True>k)\\n            {\\n                True-=(a[left++]==\\'T\\');\\n            }\\n            maxi = max(maxi , right-left+1);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732149,
                "title": "easy-cpp-solution-with-hint-with-detailed-stepwise-explanation-using-sliding-window-approach",
                "content": "# Hint\\nThe window becomes invalid when the minimum of these 2 counts exceeds k.\\n# Approach\\nThe approach of the code is to use a sliding window technique to find the maximum consecutive subsequence length. The window expands by adding characters and updating the counts of \\'T\\' and \\'F\\'. If the difference between the counts exceeds `k`, the window shrinks from the left side by moving the `start` index and adjusting the counts. The length of the window is updated at each step, and the maximum value is stored in `longwindow`.\\n# Stepwise explanation\\n1. Initialize variables `start` and `longwindow` to track the starting index and the maximum consecutive window size, respectively. Set both to 0.\\n\\n2. Initialize variables `countT` and `countF` to keep track of the count of \\'T\\' and \\'F\\' characters encountered so far. Set both to 0.\\n\\n3. Iterate over the `answerKey` string using a for loop.\\n\\n4. Inside the loop, check the current character `answerKey[i]`:\\n   - If it is \\'F\\', increment `countF` by 1.\\n   - If it is \\'T\\', increment `countT` by 1.\\n\\n5. Check if the minimum of `countF` and `countT` is greater than `k`. If it is, enter the while loop.\\n\\n6. Inside the while loop, adjust the window by moving the `start` index to the right and updating the counts:\\n   - If `answerKey[start]` is \\'T\\', decrement `countT` by 1.\\n   - If `answerKey[start]` is \\'F\\', decrement `countF` by 1.\\n   - Increment `start` by 1.\\n\\n7. Calculate the length of the current window using `i - start + 1` and update `longwindow` by taking the maximum between its current value and the calculated length.\\n\\n8. Repeat steps 4-7 until all characters in `answerKey` are processed.\\n\\n9. Return the `longwindow`, which represents the length of the maximum consecutive subsequence with at most `k` characters different from the majority.\\n\\n# Complexity\\n- Time complexity:\\n- O(n*m)\\n\\n# Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int start=0, longwindow=0, countT=0,countF=0;\\n        for(int i=0;i<answerKey.size();++i)\\n        {\\n           if(answerKey[i]==\\'F\\') countF++;\\n           else countT++;\\n           while(min(countF,countT)>k)\\n           {   \\n              if(answerKey[start]==\\'T\\')countT-=1;\\n              else countF-=1;\\n               start+=1;\\n           }  \\n                longwindow=max(longwindow,i-start+1);\\n        } \\n        return longwindow;\\n    }\\n};\\n```\\n# Please upvote and ask if you have any doubt.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int start=0, longwindow=0, countT=0,countF=0;\\n        for(int i=0;i<answerKey.size();++i)\\n        {\\n           if(answerKey[i]==\\'F\\') countF++;\\n           else countT++;\\n           while(min(countF,countT)>k)\\n           {   \\n              if(answerKey[start]==\\'T\\')countT-=1;\\n              else countF-=1;\\n               start+=1;\\n           }  \\n                longwindow=max(longwindow,i-start+1);\\n        } \\n        return longwindow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731064,
                "title": "sliding-window-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        count = {\"T\":0,\"F\":0}\\n        i = 0\\n        ans = 0\\n        for j in range(len(answerKey)):\\n            count[answerKey[j]] += 1\\n            while count[\"T\"] > k and count[\"F\"] > k:\\n                count[answerKey[i]] -= 1\\n                i += 1\\n            ans = max(ans,j-i + 1)\\n        return ans\\n            \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        count = {\"T\":0,\"F\":0}\\n        i = 0\\n        ans = 0\\n        for j in range(len(answerKey)):\\n            count[answerKey[j]] += 1\\n            while count[\"T\"] > k and count[\"F\"] > k:\\n                count[answerKey[i]] -= 1\\n                i += 1\\n            ans = max(ans,j-i + 1)\\n        return ans\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730169,
                "title": "easy-simple-o-n-python-solution-using-sliding-windows",
                "content": "# Intuition\\n    Using sliding window and hashmap...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        l = 0\\n        hmap = dict()\\n        max_len = 0\\n        curr_val = False if answerKey[0] == \\'T\\' else True\\n        if len(answerKey) == 1 and k == 1:\\n            return 1\\n        for r, r_val in enumerate(answerKey):\\n            hmap[r_val] = 1 + hmap.get(r_val ,0)\\n            if (\\'T\\' in hmap and \\'F\\' in hmap):\\n                if (hmap[\\'T\\'] <= k or hmap[\\'F\\'] <= k):\\n                    max_len = max(max_len, r - l + 1)\\n                if (hmap[\\'T\\'] > k and hmap[\\'F\\'] > k):\\n                    hmap[answerKey[l]] -= 1\\n                    l += 1\\n            else:\\n                max_len = max(max_len, r - l + 1)\\n        return max_len\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        l = 0\\n        hmap = dict()\\n        max_len = 0\\n        curr_val = False if answerKey[0] == \\'T\\' else True\\n        if len(answerKey) == 1 and k == 1:\\n            return 1\\n        for r, r_val in enumerate(answerKey):\\n            hmap[r_val] = 1 + hmap.get(r_val ,0)\\n            if (\\'T\\' in hmap and \\'F\\' in hmap):\\n                if (hmap[\\'T\\'] <= k or hmap[\\'F\\'] <= k):\\n                    max_len = max(max_len, r - l + 1)\\n                if (hmap[\\'T\\'] > k and hmap[\\'F\\'] > k):\\n                    hmap[answerKey[l]] -= 1\\n                    l += 1\\n            else:\\n                max_len = max(max_len, r - l + 1)\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694758,
                "title": "sliding-window-easy-c-beats-90",
                "content": "# if it Helps You, Please Upvote me...\\uD83E\\uDDE1\\uD83E\\uDD0D\\uD83D\\uDC9A\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to find the **max window substring** with at most k occurrences of **\\'T\\' and \\'F\\'** and return the max of them.\\n\\n**Ex:-string :- TTFFTF\\n    k = 2**\\n1. Window Substring with at most k occurrence of \\'F\\'\\n    TTFFT\\n    TFFT\\n     FFT\\n      FTF\\n       TF\\n        F\\nMaximum1 = TTFFT\\n2. Window Substring with at most k occurrence of \\'T\\'\\n  T\\n  TT\\n  TTF\\n  TTFF\\n   TFFT\\n    FFTF\\n     FTF\\n      TF\\n       F\\nMaximum2  = TTFF\\n\\n**Return Max(Maximum1,Maximum2);**\\n\\n    \\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string str,int k,char c)\\n    {\\n       int n = str.size(),i = 0,j = 0,count = 0,maxwindow = 0;\\n       while(j<n)\\n        {\\n           if(str[j]==c) count++;\\n           while(i<j && count>k)\\n           {\\n             if(str[i]==c) count--;\\n             i++;\\n           }\\n           maxwindow = max(maxwindow,j-i+1);\\n           j++;\\n        }\\n        return maxwindow;\\n    }\\n    int maxConsecutiveAnswers(string str, int k) {\\n      return max(solve(str,k,\\'F\\'),solve(str,k,\\'T\\'));\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/cb9047d5-a178-4cb6-bced-5745b2211638_1688004472.5705998.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string str,int k,char c)\\n    {\\n       int n = str.size(),i = 0,j = 0,count = 0,maxwindow = 0;\\n       while(j<n)\\n        {\\n           if(str[j]==c) count++;\\n           while(i<j && count>k)\\n           {\\n             if(str[i]==c) count--;\\n             i++;\\n           }\\n           maxwindow = max(maxwindow,j-i+1);\\n           j++;\\n        }\\n        return maxwindow;\\n    }\\n    int maxConsecutiveAnswers(string str, int k) {\\n      return max(solve(str,k,\\'F\\'),solve(str,k,\\'T\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804613,
                "title": "python-3-7-lines-sliding-window-w-example-and-explanation-t-m-95-85",
                "content": "Here\\'s how the code works:\\n\\nWe initialize two variables: `l` to track the left boundary of the window and `d `as a dictionary to store the counts of *T*s and *F*s.\\n\\nWE use a sliding window approach to iterate over`answerkey`string from left to right. The window represents the current substring of consecutive *T*s or *F*s. For each character at index`r`,we increment the count`d`for the corresponding element of `answerkey`.\\n\\nWe check whether the maximum count of *T*s or *F*s is less than `(r - l + 1) `minus the maximum number of changes allowed (`k`).\\n\\nAfter iterating through all elements of `answerkey`, the maximum number of consecutive *T*s or *F*s is given by the length of the final window, which is calculated as `r - l + 1`.\\n\\nFinally, we return the maximum number of consecutive *T*s or *F*s.\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        \\n        l, d = 0, {\\'T\\':0,\\'F\\':0}                     #   Ex: answerKey = TTFTTFTT\\n                                                    #                   01234567\\n        for r in range(len(answerKey)):             #   l    r      d        r-l+1\\n            d[answerKey[r]] += 1                    #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #   0    0   {T:1,F:0}     1\\n            if max(d.values()) < r - l - k + 1:     #   0    1   {T:2,F:0}     2   \\n                d[answerKey[l]] -= 1                #   0    2   {T:2,F:1}     3\\n                l += 1                              #   2    3   {T:3,F:1}     4\\n                                                    #   2    4   {T:4,F:1}     5\\n        return r - l + 1                            #   1    5   {T:3,F:2}     5\\n                                                    #   2    6   {T:3,F:2}     5\\n                                                    #   3    7   {T:4,F:1}     5  <-- answer\\n```\\n[https://leetcode.com/submissions/detail/841531101/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(answerKey)`.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        \\n        l, d = 0, {\\'T\\':0,\\'F\\':0}                     #   Ex: answerKey = TTFTTFTT\\n                                                    #                   01234567\\n        for r in range(len(answerKey)):             #   l    r      d        r-l+1\\n            d[answerKey[r]] += 1                    #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #   0    0   {T:1,F:0}     1\\n            if max(d.values()) < r - l - k + 1:     #   0    1   {T:2,F:0}     2   \\n                d[answerKey[l]] -= 1                #   0    2   {T:2,F:1}     3\\n                l += 1                              #   2    3   {T:3,F:1}     4\\n                                                    #   2    4   {T:4,F:1}     5\\n        return r - l + 1                            #   1    5   {T:3,F:2}     5\\n                                                    #   2    6   {T:3,F:2}     5\\n                                                    #   3    7   {T:4,F:1}     5  <-- answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499555,
                "title": "c-sliding-window-o-n-solution-without-inner-loop",
                "content": "Firstly, We check k variable, if k is greater than half of the size of the string, then answer is n, because If count of \\u2018F\\u2019 is greater than or equal to \\u2018T\\u2019 then count of \\'T\\' must be less than or equal to \\'F\\' and vice versa.\\n\\nNow we call our function count two times,\\nIn first call, we try to find the maximum count of consecutive T\\u2019s.\\nIn second call, we try to find the maximum count of consecutive F\\u2019s\\n\\nImplementation of count Function:\\nIn the count function, begin variable shows the first index from which consecutive string starts.\\n\\nNow, we implement a loop in which if character ch not equal to string element then two condition will be formed: \\nif m equals to k, then we update begin variable which means ,we remove first modified character of string and modified current character.\\nIf m not equals to k, modified current character and also increment m.\\nAnd for every iteration update ans;\\n\\n\\n**Source Code**\\n\\n    int maxConsecutiveAnswers(string key, int k) {\\n        \\n        int n=key.size();\\n        if(k>=((n+1)/2))\\n            return n;\\n        \\n        int a,b;\\n        a=count(key,k,\\'T\\');\\n        b=count(key,k,\\'F\\');\\n        return max(a,b);\\n    }\\n    \\n    int count(string key,int k,char ch)\\n    {\\n          int ans=0,begin=0,n=key.size();\\n          vector <int> v(n); // stores the indexes of the modified character of the string  \\n        \\n          int f=0; //first variable which is modified \\n          int l=0; //last variable which is modified\\n          int m=0; //m variable indicated number of variable modified in string\\n        \\n          for(int i=0;i<n;i++)\\n          {\\n            if(key[i]!=ch)\\n            {\\n                if(k==m)\\n                 {\\n                   begin=v[f++]+1;\\n                   v[l++]=i;\\n                 }\\n                 else\\n                 {\\n                   v[l++]=i;\\n                   m++;\\n                 }\\n            }\\n            ans=max(ans,i-begin+1);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "Firstly, We check k variable, if k is greater than half of the size of the string, then answer is n, because If count of \\u2018F\\u2019 is greater than or equal to \\u2018T\\u2019 then count of \\'T\\' must be less than or equal to \\'F\\' and vice versa.\\n\\nNow we call our function count two times,\\nIn first call, we try to find the maximum count of consecutive T\\u2019s.\\nIn second call, we try to find the maximum count of consecutive F\\u2019s\\n\\nImplementation of count Function:\\nIn the count function, begin variable shows the first index from which consecutive string starts.\\n\\nNow, we implement a loop in which if character ch not equal to string element then two condition will be formed: \\nif m equals to k, then we update begin variable which means ,we remove first modified character of string and modified current character.\\nIf m not equals to k, modified current character and also increment m.\\nAnd for every iteration update ans;\\n\\n\\n**Source Code**\\n\\n    int maxConsecutiveAnswers(string key, int k) {\\n        \\n        int n=key.size();\\n        if(k>=((n+1)/2))\\n            return n;\\n        \\n        int a,b;\\n        a=count(key,k,\\'T\\');\\n        b=count(key,k,\\'F\\');\\n        return max(a,b);\\n    }\\n    \\n    int count(string key,int k,char ch)\\n    {\\n          int ans=0,begin=0,n=key.size();\\n          vector <int> v(n); // stores the indexes of the modified character of the string  \\n        \\n          int f=0; //first variable which is modified \\n          int l=0; //last variable which is modified\\n          int m=0; //m variable indicated number of variable modified in string\\n        \\n          for(int i=0;i<n;i++)\\n          {\\n            if(key[i]!=ch)\\n            {\\n                if(k==m)\\n                 {\\n                   begin=v[f++]+1;\\n                   v[l++]=i;\\n                 }\\n                 else\\n                 {\\n                   v[l++]=i;\\n                   m++;\\n                 }\\n            }\\n            ans=max(ans,i-begin+1);\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1499401,
                "title": "c-two-pointer-easy-to-understand-fully-explained",
                "content": "/*\\n1. Check for maximum length of sub-string that can be formed by \\'T\\' and \\'F\\'.\\n2. For doing this ,traverse whole string and whenever  find a different character,  increase the count.\\n3. If count becomes greater than k (at right index), Start again from 0th index and if  different character is found , decrease the count.\\n4. When count will be equal to k (at left index) then at that point the length will be \"rightIndex-leftIndex+1\".\\n5. Repeat this process until  the end of string and at that point , return the maximum length.\\n6. Do this for all characters and finally return the maximum length.\\n*/\\n\\n//Code \\n\\n    int solve(string& s, int n, int k, char ch)\\n    {\\n        int maxl = 1;\\n        int c = 0;\\n        int l = 0, r = 0;\\n     \\n    \\n        while (r < n) \\n        {\\n            if (s[r] != ch)\\n                ++c;\\n            while (c > k)\\n            {\\n                if (s[l] != ch)\\n                    --c;\\n                ++l;\\n            }\\n            maxl = max(maxl, r - l + 1);\\n            ++r;\\n        }\\n        return maxl;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n\\t\\t\\n        int a=solve(answerKey, n, k,\\'T\\');\\n        int b=solve(answerKey, n, k,\\'F\\');\\n\\t\\t\\n        return max(a,b);\\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "/*\\n1. Check for maximum length of sub-string that can be formed by \\'T\\' and \\'F\\'.\\n2. For doing this ,traverse whole string and whenever  find a different character,  increase the count.\\n3. If count becomes greater than k (at right index), Start again from 0th index and if  different character is found , decrease the count.\\n4. When count will be equal to k (at left index) then at that point the length will be \"rightIndex-leftIndex+1\".\\n5. Repeat this process until  the end of string and at that point , return the maximum length.\\n6. Do this for all characters and finally return the maximum length.\\n*/\\n\\n//Code \\n\\n    int solve(string& s, int n, int k, char ch)\\n    {\\n        int maxl = 1;\\n        int c = 0;\\n        int l = 0, r = 0;\\n     \\n    \\n        while (r < n) \\n        {\\n            if (s[r] != ch)\\n                ++c;\\n            while (c > k)\\n            {\\n                if (s[l] != ch)\\n                    --c;\\n                ++l;\\n            }\\n            maxl = max(maxl, r - l + 1);\\n            ++r;\\n        }\\n        return maxl;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n\\t\\t\\n        int a=solve(answerKey, n, k,\\'T\\');\\n        int b=solve(answerKey, n, k,\\'F\\');\\n\\t\\t\\n        return max(a,b);\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1499105,
                "title": "c-slidiing-window-beginner-easy-2-pass-solution",
                "content": "# ***Approach***\\n```\\nIdea : we will use sliding window \\nCore Logic : in a window we can only allow k number of T\\'s or F\\'s\\nFirstly we do this for all T\\'s and then for all F\\'s\\neach valid window size is recorded\\n\\nwhile(window exists)\\n{\\n    if(element to be added is target)\\n        make space for its addition as only k target chars are allowed in a window\\n    \\n    include element to window\\n    record size of current window\\n}\\n\\ndo this twice once for T and then for F as target char\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int res = 0;\\n        for(char target : {\\'T\\' , \\'F\\'})\\n        {\\n            int left = 0 , right = 0;\\n            int target_count = 0;\\n            \\n            while(right != s.size())\\n            {\\n                if(s[right] == target)\\n                    while(target_count >= k)\\n                    {\\n                        if(s[left] == target)\\n                            --target_count;\\n                        ++left;\\n                    }\\n\\n                if(s[right] == target)\\n                    ++target_count;\\n                res = max(res , right - left + 1);\\n                ++right;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```\\n# ***If you liked the Solution , Give it an Upvote :)***",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nIdea : we will use sliding window \\nCore Logic : in a window we can only allow k number of T\\'s or F\\'s\\nFirstly we do this for all T\\'s and then for all F\\'s\\neach valid window size is recorded\\n\\nwhile(window exists)\\n{\\n    if(element to be added is target)\\n        make space for its addition as only k target chars are allowed in a window\\n    \\n    include element to window\\n    record size of current window\\n}\\n\\ndo this twice once for T and then for F as target char\\n```\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int res = 0;\\n        for(char target : {\\'T\\' , \\'F\\'})\\n        {\\n            int left = 0 , right = 0;\\n            int target_count = 0;\\n            \\n            while(right != s.size())\\n            {\\n                if(s[right] == target)\\n                    while(target_count >= k)\\n                    {\\n                        if(s[left] == target)\\n                            --target_count;\\n                        ++left;\\n                    }\\n\\n                if(s[right] == target)\\n                    ++target_count;\\n                res = max(res , right - left + 1);\\n                ++right;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732010,
                "title": "java-accepted-clean-time-o-n-space-o-1-solution",
                "content": "This question is similar to max consecutive 1 iii where we find max consecutive ones k zeroes are allowed. Here we maintain a window using two pointer second pointer ensures acquisition of 1 in window untill the number of 0 is less than or equal to k and first release the 0 when we acquired the 1 more than k.\\nThis question is also something like that\\nCase i  -> Treat each T as 0 where k T will be allowed and find max consecutive F as max1 by max Consecutive 1 iii logic\\nCase ii -> Treat  each F as 0 and find max consecutive T as max 2\\nMax of max1 and max2 will be required answer\\nTime O(n) and Space O(1)\\n```\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        \\n        int max1 = findMaxConsecutiveLength(answerKey,\\'T\\',k);\\n        int max2 = findMaxConsecutiveLength(answerKey,\\'F\\',k);\\n        \\n        return Math.max(max1,max2);\\n    }\\n    \\n    public int findMaxConsecutiveLength(String str,char ch,int k){\\n        int i=-1;\\n        int j=-1;\\n        int n=str.length();\\n        \\n        int max=0;\\n        int cnt=0;\\n        \\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            \\n            while(i<n-1 && cnt<=k){                 // acquisition of elements in window untill count<=k\\n                max=Math.max(max,i-j);\\n                \\n                if(str.charAt(++i)==ch){\\n                    cnt++;\\n                }\\n                \\n                f1=false;\\n            }\\n            \\n            while(cnt>k){                          //  release of elements in window untill count<=k\\n                j++;\\n                \\n                if(str.charAt(j)==ch){\\n                    cnt--;\\n                }\\n                \\n                f2=false;\\n            }\\n            \\n            if(f1 && f2){\\n                break;\\n            }\\n        }\\n        \\n        max=Math.max(max,i-j);\\n        \\n        return max;\\n    }\\n```\\nIf you have any doubt comment down \\uD83D\\uDE4F.\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        \\n        int max1 = findMaxConsecutiveLength(answerKey,\\'T\\',k);\\n        int max2 = findMaxConsecutiveLength(answerKey,\\'F\\',k);\\n        \\n        return Math.max(max1,max2);\\n    }\\n    \\n    public int findMaxConsecutiveLength(String str,char ch,int k){\\n        int i=-1;\\n        int j=-1;\\n        int n=str.length();\\n        \\n        int max=0;\\n        int cnt=0;\\n        \\n        while(true){\\n            boolean f1=true;\\n            boolean f2=true;\\n            \\n            while(i<n-1 && cnt<=k){                 // acquisition of elements in window untill count<=k\\n                max=Math.max(max,i-j);\\n                \\n                if(str.charAt(++i)==ch){\\n                    cnt++;\\n                }\\n                \\n                f1=false;\\n            }\\n            \\n            while(cnt>k){                          //  release of elements in window untill count<=k\\n                j++;\\n                \\n                if(str.charAt(j)==ch){\\n                    cnt--;\\n                }\\n                \\n                f2=false;\\n            }\\n            \\n            if(f1 && f2){\\n                break;\\n            }\\n        }\\n        \\n        max=Math.max(max,i-j);\\n        \\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731739,
                "title": "beat-97-easy-understand-with-sliding-window-approach",
                "content": "# Intuition\\nThe problem can be restated as finding the longest substring that does not repeat **T** or **F** more than $$k$$ times\\n\\nFor example, let\\'s say we have the answer key string \"TFFT\" and $$k$$=1. We need to find the longest substring that:\\n- Does not have more than $$1$$ times **T**: \"TFF\", \"FFT\"\\n- Does not have more than $$1$$ times **F**: \"TF\", \"FT\"\\n\\nAnd the length of the longest one in these possible substring is $$3$$\\n\\n# Approach\\nTo solve this problem, we can use a sliding window approach. We maintain a window of consecutive \\'T\\'s or \\'F\\'s and slide it over the string answerKey. At each step, we update the window to include the next character and calculate the length of the window. If we can change at most k answers, we can continue to slide the window. If we need to change more than k answers to continue sliding the window, we move the window\\'s left endpoint to exclude the first character of the current window and update the count of the excluded character accordingly.\\n\\nWe repeat this process until we have covered the entire string answerKey. The maximum length of the window we encountered during the process is the desired result, which represents the longest substring of consecutive \\'T\\'s or \\'F\\'s that we can obtain after performing the operation at most k times.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the answer key string. We iterate through the string once.\\n\\n- Space complexity: $$O(1)$$, since we use a constant amount of extra space to store variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int cntT = 0, cntF = 0;\\n\\n        int ans = 0;\\n\\n        int lT = 0;\\n        int lF = 0;\\n        for(int r = 0; r < answerKey.size(); r++) {\\n            if(answerKey[r] == \\'T\\') {\\n                cntT++;\\n                if(cntT > k) {\\n                    while(answerKey[lT] != \\'T\\') lT++;\\n                    lT++;\\n                    cntT--;\\n                }\\n            }\\n\\n            if(answerKey[r] == \\'F\\') {\\n                cntF++;\\n                if(cntF > k) {\\n                    while(answerKey[lF] != \\'F\\') lF++;\\n                    lF++;\\n                    cntF--;\\n                }\\n            }\\n\\n            ans = max(ans, r-lF+1);\\n            ans = max(ans, r-lT+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int cntT = 0, cntF = 0;\\n\\n        int ans = 0;\\n\\n        int lT = 0;\\n        int lF = 0;\\n        for(int r = 0; r < answerKey.size(); r++) {\\n            if(answerKey[r] == \\'T\\') {\\n                cntT++;\\n                if(cntT > k) {\\n                    while(answerKey[lT] != \\'T\\') lT++;\\n                    lT++;\\n                    cntT--;\\n                }\\n            }\\n\\n            if(answerKey[r] == \\'F\\') {\\n                cntF++;\\n                if(cntF > k) {\\n                    while(answerKey[lF] != \\'F\\') lF++;\\n                    lF++;\\n                    cntF--;\\n                }\\n            }\\n\\n            ans = max(ans, r-lF+1);\\n            ans = max(ans, r-lT+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731141,
                "title": "binary-search-with-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we can make the maximum consecutive T = n than surely we can make the maximum consecutive = n-1. This signifies that the task is linear and we can apply binary search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet us consider the maximum length is = mid, now if we count the number of T and F on every subarray of length =mid, we can determine if maximum length is possible or not.\\n\\n\\nThe number of T in length=mid can be counted using prefix sum. and number of F will be mid-T. we have to convert the minimum one for optimal solution.\\n\\nNow we check for every mid if it is possible or not using binary search.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(int mid, int k,vector<int>&count){\\n        for(int i=mid;i<count.size();i++){\\n            int T=count[i]-count[i-mid];\\n            int F=mid-T;\\n            if(min(T,F)<=k) return 1;\\n        }\\n        return 0;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n        vector<int>count(n+1,0);\\n        for(int i=0;i<n;i++){\\n            count[i+1]=count[i]+(answerKey[i]==\\'T\\');\\n        }\\n        int l=0,r=n+1,ans=0;\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(check(mid,k,count)){\\n                ans=mid;\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(int mid, int k,vector<int>&count){\\n        for(int i=mid;i<count.size();i++){\\n            int T=count[i]-count[i-mid];\\n            int F=mid-T;\\n            if(min(T,F)<=k) return 1;\\n        }\\n        return 0;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n        vector<int>count(n+1,0);\\n        for(int i=0;i<n;i++){\\n            count[i+1]=count[i]+(answerKey[i]==\\'T\\');\\n        }\\n        int l=0,r=n+1,ans=0;\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(check(mid,k,count)){\\n                ans=mid;\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731020,
                "title": "easy-c-o-n-time-solution-without-extra-space-100-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find subarray with maximum T\\'s or subarray with maximum F\\'s in each iteration and return the maximum among them.\\n\\n# Complexity\\n- Time complexity:$$O(2N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i=0,n=answerKey.size(),ans=0;\\n        int T=0,F=0;\\n        //subarray with maximum F\\'s\\n        for(int j=0;j<n;j++)\\n        {\\n            if(answerKey[j]==\\'T\\')\\n                T++;\\n            while(T>k)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    T--;\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        //subarray with maximum T\\'s\\n        i=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            if(answerKey[j]==\\'F\\')\\n                F++;\\n            while(F>k)\\n            {\\n                if(answerKey[i]==\\'F\\')\\n                    F--;\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i=0,n=answerKey.size(),ans=0;\\n        int T=0,F=0;\\n        //subarray with maximum F\\'s\\n        for(int j=0;j<n;j++)\\n        {\\n            if(answerKey[j]==\\'T\\')\\n                T++;\\n            while(T>k)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    T--;\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        //subarray with maximum T\\'s\\n        i=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            if(answerKey[j]==\\'F\\')\\n                F++;\\n            while(F>k)\\n            {\\n                if(answerKey[i]==\\'F\\')\\n                    F--;\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730977,
                "title": "sliding-window-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxConsecutiveAnswers = function(answerKey, k) {\\n  //We have to count the maxLength of consequtive windows of T with atmost k F\\'s (as they can be replaced with k )\\n  //and vice-versa for F and then return the max out of the both\\n\\n  const maxConsequtive = (char) => {\\n       let left = 0, charCount = 0, max = 0\\n       //Iterating over the answer key using right pointer\\n       for(let right = 0; right < answerKey.length; right++){\\n           //if currentChar is the char that should be atmost k times increment charCount\\n           if(answerKey[right] === char) charCount++\\n\\n           //if any point we have more than k chars we have to shrink the window\\n           while(charCount > k){\\n               if(answerKey[left++] === char) charCount--\\n           }\\n           //Once we are sure that the current window has only atmost k chars we keep track of maxLength \\n           max = Math.max(max,right-left+1)\\n       }\\n       return max\\n  }  \\n\\n  return Math.max(maxConsequtive(\\'T\\'),maxConsequtive(\\'F\\'))\\n};\\n```\\nIf you guys think it\\'s useful kindly upvote.\\nThanks \\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxConsecutiveAnswers = function(answerKey, k) {\\n  //We have to count the maxLength of consequtive windows of T with atmost k F\\'s (as they can be replaced with k )\\n  //and vice-versa for F and then return the max out of the both\\n\\n  const maxConsequtive = (char) => {\\n       let left = 0, charCount = 0, max = 0\\n       //Iterating over the answer key using right pointer\\n       for(let right = 0; right < answerKey.length; right++){\\n           //if currentChar is the char that should be atmost k times increment charCount\\n           if(answerKey[right] === char) charCount++\\n\\n           //if any point we have more than k chars we have to shrink the window\\n           while(charCount > k){\\n               if(answerKey[left++] === char) charCount--\\n           }\\n           //Once we are sure that the current window has only atmost k chars we keep track of maxLength \\n           max = Math.max(max,right-left+1)\\n       }\\n       return max\\n  }  \\n\\n  return Math.max(maxConsequtive(\\'T\\'),maxConsequtive(\\'F\\'))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729995,
                "title": "c-solution-for-maximize-the-confusion-of-an-exam-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use a sliding window approach to find the maximum consecutive count of the same answer in the given string. We maintain two counts (trueCount and falseCount) to keep track of the consecutive \\'T\\'s and \\'F\\'s respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize variables maxCount, trueCount, and falseCount to 0.\\n- Use a sliding window represented by two pointers, left and right.\\n- Move the right pointer to the right and update the corresponding count (trueCount or falseCount) based on the current character in the string.\\n- If the number of changes required to maintain the window within the limit k exceeds k, move the left pointer to the right and adjust the counts accordingly.\\n- Update the maxCount with the maximum consecutive count found so far.\\n- Repeat steps 3-5 until the right pointer reaches the end of the string.\\n- Return the maxCount as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the input string. This is because we iterate through the string once using the sliding window approach.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we only use a constant amount of extra space to store the counts and variables.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.Length;\\n        int maxCount = 0;  // Maximum consecutive count of the same answer\\n        int trueCount = 0;  // Count of consecutive \\'T\\'s\\n        int falseCount = 0;  // Count of consecutive \\'F\\'s\\n        \\n        // Sliding window approach\\n        int left = 0;\\n        int right = 0;\\n        \\n        while (right < n) {\\n            if (answerKey[right] == \\'T\\') {\\n                trueCount++;\\n            } else {\\n                falseCount++;\\n            }\\n            \\n            // If the number of changes required exceeds k, move the left pointer\\n            if (Math.Min(trueCount, falseCount) > k) {\\n                if (answerKey[left] == \\'T\\') {\\n                    trueCount--;\\n                } else {\\n                    falseCount--;\\n                }\\n                left++;\\n            }\\n            \\n            // Update the maxCount\\n            maxCount = Math.Max(maxCount, right - left + 1);\\n            \\n            right++;\\n        }\\n        \\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.Length;\\n        int maxCount = 0;  // Maximum consecutive count of the same answer\\n        int trueCount = 0;  // Count of consecutive \\'T\\'s\\n        int falseCount = 0;  // Count of consecutive \\'F\\'s\\n        \\n        // Sliding window approach\\n        int left = 0;\\n        int right = 0;\\n        \\n        while (right < n) {\\n            if (answerKey[right] == \\'T\\') {\\n                trueCount++;\\n            } else {\\n                falseCount++;\\n            }\\n            \\n            // If the number of changes required exceeds k, move the left pointer\\n            if (Math.Min(trueCount, falseCount) > k) {\\n                if (answerKey[left] == \\'T\\') {\\n                    trueCount--;\\n                } else {\\n                    falseCount--;\\n                }\\n                left++;\\n            }\\n            \\n            // Update the maxCount\\n            maxCount = Math.Max(maxCount, right - left + 1);\\n            \\n            right++;\\n        }\\n        \\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729793,
                "title": "simple-c-general-case-with-any-k-values",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int x) {\\n         int i = 0, j, k = x;\\n        for (j = 0; j < answerKey.size(); ++j) {\\n            if (answerKey[j] == \\'F\\') k--;\\n            if (k < 0 && answerKey[i++] == \\'F\\') k++;\\n        }\\n        int ans=j-i;\\n        i=0;\\n        k=x;\\n          for (j = 0; j < answerKey.size(); ++j) {\\n            if (answerKey[j] == \\'T\\') k--;\\n            if (k < 0 && answerKey[i++] == \\'T\\') k++;\\n        }\\n        ans=max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int x) {\\n         int i = 0, j, k = x;\\n        for (j = 0; j < answerKey.size(); ++j) {\\n            if (answerKey[j] == \\'F\\') k--;\\n            if (k < 0 && answerKey[i++] == \\'F\\') k++;\\n        }\\n        int ans=j-i;\\n        i=0;\\n        k=x;\\n          for (j = 0; j < answerKey.size(); ++j) {\\n            if (answerKey[j] == \\'T\\') k--;\\n            if (k < 0 && answerKey[i++] == \\'T\\') k++;\\n        }\\n        ans=max(ans,j-i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729609,
                "title": "fastest-c-beat-100-o-n-time-and-o-1-space-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Sliding window\\n\\n# Complexity\\n- Time complexity: O(N)  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0); wcin.tie(0);\\n        int n=s.size();int nT=0,nF=0,ans=0,i=0,j=0;\\n        while(j<n){\\n            if(s[j] == \\'T\\') nT++;\\n            else nF++;\\n            if(nT<=k|| nF<=k) ans=max(ans,j-i+1);\\n            else{\\n                if(s[i++] == \\'T\\') nT--;\\n                else nF--;\\n            }\\n            j++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0); wcin.tie(0);\\n        int n=s.size();int nT=0,nF=0,ans=0,i=0,j=0;\\n        while(j<n){\\n            if(s[j] == \\'T\\') nT++;\\n            else nF++;\\n            if(nT<=k|| nF<=k) ans=max(ans,j-i+1);\\n            else{\\n                if(s[i++] == \\'T\\') nT--;\\n                else nF--;\\n            }\\n            j++;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729570,
                "title": "c-python-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code calculates the maximum number of consecutive \\'T\\'s or \\'F\\'s in the answer key by sliding a window and adjusting it based on the number of allowed changes. It returns the maximum count among \\'T\\'s and \\'F\\'s.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxW(string list, int n, char c, int k) {\\n        int ans = 0;\\n        int flip = 0, l = 0;\\n        for (int r = 0; r < n; r++) {\\n            flip += (list[r] != c);\\n            if (flip > k) {\\n                while (list[l] == c)\\n                    l++;\\n                l++;\\n                flip--;\\n            }\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.size();\\n        return max(maxW(answerKey, n, \\'T\\', k), maxW(answerKey, n, \\'F\\', k));\\n    }\\n};\\n\\n\\n```\\n# Python code with Comments\\n\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        n=len(answerKey)\\n        \\n        # Define a helper function maxW that calculates the maximum number of consecutive\\n        # answers for a given character c (\\'T\\' or \\'F\\')\\n        def maxW(c):\\n            ans=0\\n            flip=0\\n            l=0\\n            for r in range(n):\\n                if answerKey[r]!=c:  # If the current answer is not equal to c, increment flip\\n                    flip+=1\\n                if flip>k:  # If flip exceeds k, adjust the window by moving l\\n                    while answerKey[l]==c:  # Skip all consecutive occurrences of c\\n                        l+=1\\n                    l+=1  # Move l to the next position after skipping\\n                    flip-=1  # Decrement flip since we have adjusted the window\\n                ans=max(ans, r-l+1)  # Update ans with the maximum consecutive count\\n            return ans\\n        \\n        # Return the maximum of maxW(\\'T\\') and maxW(\\'F\\') as the result\\n        return max(maxW(\\'T\\'), maxW(\\'F\\'))\\n\\n```\\n# 2nd Solution\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int n = s.size();\\n        if (n == 1) return 1;   \\n        vector<int> TF(2, 0);\\n        int ans = 0;\\n        int maxCount = 0;\\n        int l = 0;\\n        for (int r = 0; r < n; r++) {\\n            s[r]==\\'T\\'?TF[0]++:TF[1]++;\\n            maxCount = max({maxCount, TF[0], TF[1]});\\n            if ((r - l + 1) - maxCount > k) {\\n                s[l]==\\'T\\'?TF[0]--:TF[1]--;\\n                l++;\\n            }\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxW(string list, int n, char c, int k) {\\n        int ans = 0;\\n        int flip = 0, l = 0;\\n        for (int r = 0; r < n; r++) {\\n            flip += (list[r] != c);\\n            if (flip > k) {\\n                while (list[l] == c)\\n                    l++;\\n                l++;\\n                flip--;\\n            }\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.size();\\n        return max(maxW(answerKey, n, \\'T\\', k), maxW(answerKey, n, \\'F\\', k));\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        n=len(answerKey)\\n        \\n        # Define a helper function maxW that calculates the maximum number of consecutive\\n        # answers for a given character c (\\'T\\' or \\'F\\')\\n        def maxW(c):\\n            ans=0\\n            flip=0\\n            l=0\\n            for r in range(n):\\n                if answerKey[r]!=c:  # If the current answer is not equal to c, increment flip\\n                    flip+=1\\n                if flip>k:  # If flip exceeds k, adjust the window by moving l\\n                    while answerKey[l]==c:  # Skip all consecutive occurrences of c\\n                        l+=1\\n                    l+=1  # Move l to the next position after skipping\\n                    flip-=1  # Decrement flip since we have adjusted the window\\n                ans=max(ans, r-l+1)  # Update ans with the maximum consecutive count\\n            return ans\\n        \\n        # Return the maximum of maxW(\\'T\\') and maxW(\\'F\\') as the result\\n        return max(maxW(\\'T\\'), maxW(\\'F\\'))\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int n = s.size();\\n        if (n == 1) return 1;   \\n        vector<int> TF(2, 0);\\n        int ans = 0;\\n        int maxCount = 0;\\n        int l = 0;\\n        for (int r = 0; r < n; r++) {\\n            s[r]==\\'T\\'?TF[0]++:TF[1]++;\\n            maxCount = max({maxCount, TF[0], TF[1]});\\n            if ((r - l + 1) - maxCount > k) {\\n                s[l]==\\'T\\'?TF[0]--:TF[1]--;\\n                l++;\\n            }\\n            ans = max(ans, r - l + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401241,
                "title": "beats-90-of-cpp-solution",
                "content": "# **If you like the solution pls upvoate Me\\uD83E\\uDD79\\u2764\\uFE0F**\\n\\n# Approach\\nThis is a simple problem of sliding window, your task is to find the maximum substirng of \\'T\\' with atmost k \\'F\\' or The maximum substring of \\'F\\' with atmost k \\'T\\'\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string str, int k) {\\n        // The problem wants u to find the maximum substring of \\'T\\' with atmost k \\'F\\'\\n        // or\\n        // The maximum substring of \\'F\\' with atmost k \\'T\\'\\n\\n        // This is a simple sliding window problem \\n        int left = 0;\\n        int count = 0;\\n        int ans = 0;\\n\\n        // Finding the maximum substring of \\'T\\' with atmost k \\'F\\'\\n        for(int i = 0; i<str.size(); i++){\\n            if(str[i] == \\'F\\'){\\n                count++;\\n            }\\n\\n            while(count > k){\\n                if(str[left] == \\'F\\'){\\n                    count--;\\n                }\\n                left++;\\n            }\\n\\n            ans = max(ans, i-left+1);\\n        }\\n\\n        // finding the maximum substirng of \\'F\\' with atmost k \\'T\\' and updating the final ans\\n        left = 0;\\n        count = 0;\\n        for(int i = 0; i<str.size(); i++){\\n            if(str[i] == \\'T\\'){\\n                count++;\\n            }\\n            while(count > k){\\n                if(str[left]==\\'T\\'){\\n                    count--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, i-left+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string str, int k) {\\n        // The problem wants u to find the maximum substring of \\'T\\' with atmost k \\'F\\'\\n        // or\\n        // The maximum substring of \\'F\\' with atmost k \\'T\\'\\n\\n        // This is a simple sliding window problem \\n        int left = 0;\\n        int count = 0;\\n        int ans = 0;\\n\\n        // Finding the maximum substring of \\'T\\' with atmost k \\'F\\'\\n        for(int i = 0; i<str.size(); i++){\\n            if(str[i] == \\'F\\'){\\n                count++;\\n            }\\n\\n            while(count > k){\\n                if(str[left] == \\'F\\'){\\n                    count--;\\n                }\\n                left++;\\n            }\\n\\n            ans = max(ans, i-left+1);\\n        }\\n\\n        // finding the maximum substirng of \\'F\\' with atmost k \\'T\\' and updating the final ans\\n        left = 0;\\n        count = 0;\\n        for(int i = 0; i<str.size(); i++){\\n            if(str[i] == \\'T\\'){\\n                count++;\\n            }\\n            while(count > k){\\n                if(str[left]==\\'T\\'){\\n                    count--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, i-left+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727068,
                "title": "python-easy-and-detailed-explanation-with-example-using-binary-search-no-pointer",
                "content": "**Idea:** Use the concept of binary search. We will first tak window size and then check how many maximum consecutive T or F can be possible.\\n\\n**Approach:**\\n* start with window size equal to mid. mid = (low+high) /2\\n* Now count the number of \\'T\\' and \\'F\\' in given window size.\\n* Then check if we can get maximum consecutive T or F by replacing atmost k position.\\n* If this is possible we increase the window size to find next maximum possible consecutive T or F.\\n* If this is not possible we decrease window size.\\n\\n**Example:**\\n```\\nstring = \" T F T T F \"  ,  k = 1\\n\\t\\n\\t1. low = 1, high = 5\\n\\t\\t window length = mid = 3\\n\\n\\t\\t\\t[\" T F T \"] T F :  count_t = 2  ,  count_f = 1 \\n\\t\\t\\t-> Since, count_f <= k . we can replace \\'F\\' with \\'T\\'\\n\\t\\t\\t-> This means we can fill whole window with same character that is \\'T\\' \\n\\t\\n\\t-> string : [\" T T T \"] T F (one of the possible way) & \\n\\t-> no. of consecutive T\\'s i.e ans = 3 (mid)\\n\\t-> Now we will increase window size to get maximum possible answer\\n\\t-> low = mid+1 = 4\\n\\t\\n\\t2. low = 4, high = 5 \\n\\t\\t window length = mid = 4\\n\\n\\t\\t\\t[\" T F T T \"]  F :  count_t  = 3  ,  count_f = 1 \\n\\t\\t\\t-> Since, count_f <= k. we can replace \\'F\\' with \\'T\\'\\n\\t\\t\\t-> This means we can fill whole window with same character that is \\'T\\'\\n\\t\\t\\t\\n\\t-> string : [\" T T T T \"] F (one of the possible way) & \\n\\t-> no. of consecutive T\\'s i.e ans = 4 (mid)\\n\\t-> Now we will increase window size to get maximum possible answer\\n\\t-> low = mid+1 = 5\\n\\t\\n\\t3. low = 5, high = 5 \\n\\t\\t window length = mid = 5\\n\\t\\t\\t\\n\\t\\t\\t[\" T F T T F \"] :  count_f = 3  ,  count_f = 2 \\n\\t\\t\\t-> Since, both count_t and count_f > k. Thus we cannot replace \\'F\\' with \\'T\\'\\n\\t\\t\\t-> so return false\\n\\t\\t\\t\\n\\t-> no. of consecutive T\\'s i.e ans = 4 (mid)  [No change]\\n\\t-> high = mid-1 = 4, low = 5\\n\\t\\n\\tSince, high < low, while loop will end. We have max consecutive answer = 4. \\n\\tThus, return ans. \\n```\\n\\n**Code:**\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        \\n\\t\\tdef replace(s,win,k):\\n            # count number of \\'T\\' and \\'F\\' in window size\\n            count_t,count_f=s[0:win].count(\\'T\\'),s[:win].count(\\'F\\')    \\n            \\n\\t\\t\\tif count_t<=k or count_f<=k:   # check if we can fill given window with same character either \\'T\\' or \\'F\\'\\n                return True\\n            \\n\\t\\t\\tstart=0     # if no then check for other index in answerkey\\n            end=win-1\\n            \\n\\t\\t\\twhile end<len(s)-1:     # we will check for all index in answerkey untill we found one\\n                if s[start]==\\'T\\':       # first remove count of index that we previously checked\\n                    count_t-=1\\n                else:\\n                    count_f-=1\\n                \\n\\t\\t\\t\\tstart+=1    # increase the index by 1   means we will now check for next index in answerkey\\n                end+=1\\n                \\n\\t\\t\\t\\tif s[end]==\\'T\\': # adjust the count of \\'T\\' and \\'F\\' accordingly\\n                    count_t+=1\\n                else:\\n                    count_f+=1\\n                \\n\\t\\t\\t\\tif count_t<=k or count_f<=k:   # check if we can fill given window with same character either \\'T\\' or \\'F\\'\\n                    return True\\n            \\n\\t\\t\\treturn False\\n        \\n        n=len(answerKey)\\n        l,h=1,n     \\n        ans=1\\n\\t\\t\\n        while l<=h:            \\n\\t\\t\\tmid=(l+h)//2    # window size\\n            \\n\\t\\t\\tif replace(answerKey,mid,k):           # check if we can fill whole window with same character\\n                l=mid+1           # if yes increase window size by 1 and again check for it\\n                ans=mid\\n            else:\\n                h=mid-1           # if not the decrease window size by 1 and check for it\\n        return ans\\n```\\n\\nUpvote if you find it helpful.",
                "solutionTags": [],
                "code": "```\\nstring = \" T F T T F \"  ,  k = 1\\n\\t\\n\\t1. low = 1, high = 5\\n\\t\\t window length = mid = 3\\n\\n\\t\\t\\t[\" T F T \"] T F :  count_t = 2  ,  count_f = 1 \\n\\t\\t\\t-> Since, count_f <= k . we can replace \\'F\\' with \\'T\\'\\n\\t\\t\\t-> This means we can fill whole window with same character that is \\'T\\' \\n\\t\\n\\t-> string : [\" T T T \"] T F (one of the possible way) & \\n\\t-> no. of consecutive T\\'s i.e ans = 3 (mid)\\n\\t-> Now we will increase window size to get maximum possible answer\\n\\t-> low = mid+1 = 4\\n\\t\\n\\t2. low = 4, high = 5 \\n\\t\\t window length = mid = 4\\n\\n\\t\\t\\t[\" T F T T \"]  F :  count_t  = 3  ,  count_f = 1 \\n\\t\\t\\t-> Since, count_f <= k. we can replace \\'F\\' with \\'T\\'\\n\\t\\t\\t-> This means we can fill whole window with same character that is \\'T\\'\\n\\t\\t\\t\\n\\t-> string : [\" T T T T \"] F (one of the possible way) & \\n\\t-> no. of consecutive T\\'s i.e ans = 4 (mid)\\n\\t-> Now we will increase window size to get maximum possible answer\\n\\t-> low = mid+1 = 5\\n\\t\\n\\t3. low = 5, high = 5 \\n\\t\\t window length = mid = 5\\n\\t\\t\\t\\n\\t\\t\\t[\" T F T T F \"] :  count_f = 3  ,  count_f = 2 \\n\\t\\t\\t-> Since, both count_t and count_f > k. Thus we cannot replace \\'F\\' with \\'T\\'\\n\\t\\t\\t-> so return false\\n\\t\\t\\t\\n\\t-> no. of consecutive T\\'s i.e ans = 4 (mid)  [No change]\\n\\t-> high = mid-1 = 4, low = 5\\n\\t\\n\\tSince, high < low, while loop will end. We have max consecutive answer = 4. \\n\\tThus, return ans. \\n```\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        \\n\\t\\tdef replace(s,win,k):\\n            # count number of \\'T\\' and \\'F\\' in window size\\n            count_t,count_f=s[0:win].count(\\'T\\'),s[:win].count(\\'F\\')    \\n            \\n\\t\\t\\tif count_t<=k or count_f<=k:   # check if we can fill given window with same character either \\'T\\' or \\'F\\'\\n                return True\\n            \\n\\t\\t\\tstart=0     # if no then check for other index in answerkey\\n            end=win-1\\n            \\n\\t\\t\\twhile end<len(s)-1:     # we will check for all index in answerkey untill we found one\\n                if s[start]==\\'T\\':       # first remove count of index that we previously checked\\n                    count_t-=1\\n                else:\\n                    count_f-=1\\n                \\n\\t\\t\\t\\tstart+=1    # increase the index by 1   means we will now check for next index in answerkey\\n                end+=1\\n                \\n\\t\\t\\t\\tif s[end]==\\'T\\': # adjust the count of \\'T\\' and \\'F\\' accordingly\\n                    count_t+=1\\n                else:\\n                    count_f+=1\\n                \\n\\t\\t\\t\\tif count_t<=k or count_f<=k:   # check if we can fill given window with same character either \\'T\\' or \\'F\\'\\n                    return True\\n            \\n\\t\\t\\treturn False\\n        \\n        n=len(answerKey)\\n        l,h=1,n     \\n        ans=1\\n\\t\\t\\n        while l<=h:            \\n\\t\\t\\tmid=(l+h)//2    # window size\\n            \\n\\t\\t\\tif replace(answerKey,mid,k):           # check if we can fill whole window with same character\\n                l=mid+1           # if yes increase window size by 1 and again check for it\\n                ans=mid\\n            else:\\n                h=mid-1           # if not the decrease window size by 1 and check for it\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707072,
                "title": "max-consecutive-ones-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string s, int k,char ans){\\n        int i=0,j=0;\\n        int count=0,maxlen=0;\\n        while(j<s.length()){\\n            if(s[j]==ans) count++;\\n            if(count<=k){\\n                maxlen=max(maxlen,j-i+1);\\n                j++;\\n            }\\n          else  if(count>k){\\n                while(count>k){\\n                    if(s[i]==ans)\\n                    {\\n                        count--;}\\n                    i++;\\n                }\\n            j++;}\\n        }\\n        return maxlen;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {   \\n        return max(solve(s,k,\\'F\\'),solve(s,k,\\'T\\'));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string s, int k,char ans){\\n        int i=0,j=0;\\n        int count=0,maxlen=0;\\n        while(j<s.length()){\\n            if(s[j]==ans) count++;\\n            if(count<=k){\\n                maxlen=max(maxlen,j-i+1);\\n                j++;\\n            }\\n          else  if(count>k){\\n                while(count>k){\\n                    if(s[i]==ans)\\n                    {\\n                        count--;}\\n                    i++;\\n                }\\n            j++;}\\n        }\\n        return maxlen;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {   \\n        return max(solve(s,k,\\'F\\'),solve(s,k,\\'T\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633113,
                "title": "c-sliding-window-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(helper(answerKey,k,\\'T\\'),helper(answerKey,k,\\'F\\'));\\n    }\\n    \\n    int helper(string answerKey, int k,char c){\\n        int start = 0;\\n        int end = 0;\\n        int count = 0;\\n        int ans = 0;\\n        while(end<answerKey.length()){\\n            if(answerKey[end]==c)count++;\\n            while(count>k){\\n                if(answerKey[start]==c)count--;\\n                start++;\\n            }\\n            ans = max(ans,end-start+1);\\n            end++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(helper(answerKey,k,\\'T\\'),helper(answerKey,k,\\'F\\'));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1624131,
                "title": "python-sliding-window-with-explanation",
                "content": "One left and one right pointer to determine a window, calculate the amount of T and F in that window, when one of them is less than k, we can change all those letters to another, so that all the letters in the window are the same, then the window size is an alternative answer. Traverse the entire string to get maximum value.\\n1) Slide the right pointer to calculate the number of T and F in the window\\n2) If the number of T and F are both greater than k, that is, all letters in the window cannot be changed to be the same by modifying one letter, and the left pointer needs to be moved\\n3) After the left pointer is moved, the window size can be used as the answer, compared with the current maximum value and updated\\n\\nRuntime: 332 ms, faster than 82.95% of Python3 online submissions for Maximize the Confusion of an Exam.\\nMemory Usage: 14.4 MB, less than 83.16% of Python3 online submissions for Maximize the Confusion of an Exam.\\n\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        n = len(answerKey)\\n        left = ret = numT = numF = 0\\n        \\n        for right in range(n):\\n            if answerKey[right]==\\'T\\':\\n                numT+=1\\n            else:\\n                numF+=1\\n            while numT>k and numF>k:\\n                if answerKey[left]==\\'T\\':\\n                    numT-=1\\n                else:\\n                    numF-=1\\n                left+=1\\n            ret = max(ret, right-left+1)\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        n = len(answerKey)\\n        left = ret = numT = numF = 0\\n        \\n        for right in range(n):\\n            if answerKey[right]==\\'T\\':\\n                numT+=1\\n            else:\\n                numF+=1\\n            while numT>k and numF>k:\\n                if answerKey[left]==\\'T\\':\\n                    numT-=1\\n                else:\\n                    numF-=1\\n                left+=1\\n            ret = max(ret, right-left+1)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521886,
                "title": "python-same-problem-as-longest-consecutive-subarray-of-1-s-with-k-deletions",
                "content": "Replace \"T\" as 1 and \"F\" as 0. The problem is reduced to finding max length of subarray(substring) of consecutive 1\\'s(True here) where k deletions are allowed which is a typical sliding widow problem. In addition we shall also calculate max length of consecutive 0\\'s(False here) where k deletions are allowed as the required answer may have consecutive \"T\" or \"F\".  Finally we will return the bigger length of two calculated lengths.\\nMaintain a pointer \"left\" at begining of window and expand the window using right pointer with condition that k >= 0. Whenever we find a \"T\" or \"F\" (depending upon for which case we are calculating) we shall decrement the value of k by 1. Now, if the condition (k >= 0) becomes false we shall update the length of max size substring calculated till now and start shrinking the window till k >= 0 becomes valid again.\\n\\nTime Complexity: O(n)\\nSpaceComplexity: O(1)\\nIf it helps, give an upvote\\n\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        ifTrueIsAnswer = self.confuseStudents(answerKey, k, \"T\")\\n        ifFalseIsAnswer = self.confuseStudents(answerKey, k, \"F\")\\n        return max(ifTrueIsAnswer, ifFalseIsAnswer)\\n    \\n    def confuseStudents(self, array, k, key):\\n        left, result = 0, 0\\n        for right in range(len(array)):\\n            if array[right] == key:\\n                k -= 1\\n            if k < 0:\\n                result = max(result, right-left)\\n                while k < 0:\\n                    if array[left] == key:\\n                        k += 1\\n                    left += 1\\n        return max(result, right+1-left)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "Replace \"T\" as 1 and \"F\" as 0. The problem is reduced to finding max length of subarray(substring) of consecutive 1\\'s(True here) where k deletions are allowed which is a typical sliding widow problem. In addition we shall also calculate max length of consecutive 0\\'s(False here) where k deletions are allowed as the required answer may have consecutive \"T\" or \"F\".  Finally we will return the bigger length of two calculated lengths.\\nMaintain a pointer \"left\" at begining of window and expand the window using right pointer with condition that k >= 0. Whenever we find a \"T\" or \"F\" (depending upon for which case we are calculating) we shall decrement the value of k by 1. Now, if the condition (k >= 0) becomes false we shall update the length of max size substring calculated till now and start shrinking the window till k >= 0 becomes valid again.\\n\\nTime Complexity: O(n)\\nSpaceComplexity: O(1)\\nIf it helps, give an upvote\\n\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        ifTrueIsAnswer = self.confuseStudents(answerKey, k, \"T\")\\n        ifFalseIsAnswer = self.confuseStudents(answerKey, k, \"F\")\\n        return max(ifTrueIsAnswer, ifFalseIsAnswer)\\n    \\n    def confuseStudents(self, array, k, key):\\n        left, result = 0, 0\\n        for right in range(len(array)):\\n            if array[right] == key:\\n                k -= 1\\n            if k < 0:\\n                result = max(result, right-left)\\n                while k < 0:\\n                    if array[left] == key:\\n                        k += 1\\n                    left += 1\\n        return max(result, right+1-left)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1504169,
                "title": "c-sliding-window-easy-to-understand",
                "content": "This question is extention of https://leetcode.com/problems/max-consecutive-ones-iii/\\nHere we can rewrite the problem as to find the longest window of \\'T\\' with atmost k \\'F\\' or longest window of \\'F\\' with atmost k , \\'T\\'. \\nTo do so, we will run 2 for loop, one for \\'T\\' and for \\'F\\'.\\nIn first loop we will find the longest substring with at most k, \\'F\\', here f is keeping count of frequency of \\'F\\', if it exceed k than we will increase i till f become <=k, and store result in cntF.\\nSimilarly for \\'T\\' in second loop.\\n\\n````\\n\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        \\n        //Initialyzing the variables, f- keep count of \\'F\\' and \\'T\\'\\n        int n=s.size(),cntT=0,cntF=0,i=0,f=0;\\n        \\n        //Checking for longest window with at most k \\'F\\' \\n        for(int j=0; j<n; j++)\\n        {\\n            if(s[j]==\\'F\\')\\n                f++;\\n            for( ;i<=j && f>k; i++)\\n            {\\n                if(s[i]==\\'F\\')\\n                    f--;\\n            }\\n            cntF=max(cntF,j-i+1);\\n        }\\n        \\n        i=0,f=0;\\n        //Checking for longest window with at most k \\'F\\'\\n        for(int j=0;j<n;j++)\\n        {\\n            if(s[j]==\\'T\\')\\n                f++;\\n            for( ;i<=j && f>k; i++)\\n            {\\n                if(s[i]==\\'T\\')\\n                    f--;\\n            }\\n            cntT=max(cntT,j-i+1);\\n        }\\n        \\n       return max(cntT,cntF); \\n    }\\n};\\n\\n````",
                "solutionTags": [],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        \\n        //Initialyzing the variables, f- keep count of \\'F\\' and \\'T\\'\\n        int n=s.size(),cntT=0,cntF=0,i=0,f=0;\\n        \\n        //Checking for longest window with at most k \\'F\\' \\n        for(int j=0; j<n; j++)\\n        {\\n            if(s[j]==\\'F\\')\\n                f++;\\n            for( ;i<=j && f>k; i++)\\n            {\\n                if(s[i]==\\'F\\')\\n                    f--;\\n            }\\n            cntF=max(cntF,j-i+1);\\n        }\\n        \\n        i=0,f=0;\\n        //Checking for longest window with at most k \\'F\\'\\n        for(int j=0;j<n;j++)\\n        {\\n            if(s[j]==\\'T\\')\\n                f++;\\n            for( ;i<=j && f>k; i++)\\n            {\\n                if(s[i]==\\'T\\')\\n                    f--;\\n            }\\n            cntT=max(cntT,j-i+1);\\n        }\\n        \\n       return max(cntT,cntF); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499251,
                "title": "easy-to-understand-c-solution",
                "content": "This problem is similar to \\nhttps://leetcode.com/problems/max-consecutive-ones-iii/\\n\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int> nums,int k){\\n        int i = 0,j = 0;\\n        int n = nums.size();\\n        int cur_len = 0,max_len = 0;\\n        while(i<n){\\n            if(nums[i] == 0) k--;\\n            while(k<0 && j<=i){\\n                if(nums[j++] == 0) k++;\\n            }\\n            cur_len = (i-j+1);\\n            i++;\\n            max_len = max(max_len,cur_len);\\n        }\\n        return max_len;\\n    }\\n    int maxConsecutiveAnswers(string str, int k) {\\n        vector<int> arr;\\n        for(auto i: str){\\n            if(i == \\'T\\') arr.push_back(1);\\n            else arr.push_back(0);\\n        }\\n        \\n        int ans = func(arr,k);\\n        for(int i = 0;i<arr.size();i++) arr[i] = abs(arr[i]-1);\\n        ans = max(ans,func(arr,k));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int> nums,int k){\\n        int i = 0,j = 0;\\n        int n = nums.size();\\n        int cur_len = 0,max_len = 0;\\n        while(i<n){\\n            if(nums[i] == 0) k--;\\n            while(k<0 && j<=i){\\n                if(nums[j++] == 0) k++;\\n            }\\n            cur_len = (i-j+1);\\n            i++;\\n            max_len = max(max_len,cur_len);\\n        }\\n        return max_len;\\n    }\\n    int maxConsecutiveAnswers(string str, int k) {\\n        vector<int> arr;\\n        for(auto i: str){\\n            if(i == \\'T\\') arr.push_back(1);\\n            else arr.push_back(0);\\n        }\\n        \\n        int ans = func(arr,k);\\n        for(int i = 0;i<arr.size();i++) arr[i] = abs(arr[i]-1);\\n        ans = max(ans,func(arr,k));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499009,
                "title": "python-easy-to-understand",
                "content": "```\\n\\'\\'\\'\\nthis question is similar to maximum continous one\\'s with atmost k zero\\'s\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/\\nin this question we will find max consecutive True with atmost k False and \\nmax consecutive False with atmost k True and return maximum of both .\\n\\'\\'\\'\\nclass Solution:\\n    \\n    #we find longest consecutive True with atmost k False\\n    def longestTrue(self, nums, k):\\n        N=len(nums)\\n        mx=0\\n        j=0\\n        for i in range(N):\\n            if nums[i]==\"F\":\\n                k-=1\\n            if k<0:\\n                while k<0:\\n                    if nums[j]==\"F\":\\n                        k+=1\\n                    j+=1\\n            mx=max(mx,i-j+1)\\n        return mx\\n    \\n    #we find longest consecutive False with atmost k False\\n    def longestFalse(self, nums, k):\\n        N=len(nums)\\n        mx=0\\n        j=0\\n        for i in range(N):\\n            if nums[i]==\"T\":\\n                k-=1\\n            if k<0:\\n                while k<0:\\n                    if nums[j]==\"T\":\\n                        k+=1\\n                    j+=1\\n            mx=max(mx,i-j+1)\\n        return mx\\n    \\n    def maxConsecutiveAnswers(self, find: str, k: int) -> int:\\n        return max(self.longestTrue(find,k),self.longestFalse(find,k))",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nthis question is similar to maximum continous one\\'s with atmost k zero\\'s\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/\\nin this question we will find max consecutive True with atmost k False and \\nmax consecutive False with atmost k True and return maximum of both .\\n\\'\\'\\'\\nclass Solution:\\n    \\n    #we find longest consecutive True with atmost k False\\n    def longestTrue(self, nums, k):\\n        N=len(nums)\\n        mx=0\\n        j=0\\n        for i in range(N):\\n            if nums[i]==\"F\":\\n                k-=1\\n            if k<0:\\n                while k<0:\\n                    if nums[j]==\"F\":\\n                        k+=1\\n                    j+=1\\n            mx=max(mx,i-j+1)\\n        return mx\\n    \\n    #we find longest consecutive False with atmost k False\\n    def longestFalse(self, nums, k):\\n        N=len(nums)\\n        mx=0\\n        j=0\\n        for i in range(N):\\n            if nums[i]==\"T\":\\n                k-=1\\n            if k<0:\\n                while k<0:\\n                    if nums[j]==\"T\":\\n                        k+=1\\n                    j+=1\\n            mx=max(mx,i-j+1)\\n        return mx\\n    \\n    def maxConsecutiveAnswers(self, find: str, k: int) -> int:\\n        return max(self.longestTrue(find,k),self.longestFalse(find,k))",
                "codeTag": "Java"
            },
            {
                "id": 3741996,
                "title": "easiest-c-solution-simple-two-pointer-approach-beats-90",
                "content": "This problem is the same as [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/solutions/3742002/easiest-c-solution-simple-two-pointer-approach-beats-100/)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &s,char b,int &k){\\n        int left=0,res=0,size=s.size(),cnt=0;\\n        for(int i=0;i<size;i++){\\n            if(s[i]==b)\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==b)\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n        return res;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(solve(s,\\'F\\',k),solve(s,\\'T\\',k));  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,char b,int &k){\\n        int left=0,res=0,size=s.size(),cnt=0;\\n        for(int i=0;i<size;i++){\\n            if(s[i]==b)\\n                cnt++;\\n            while(cnt>k){\\n                if(s[left]==b)\\n                    cnt--;\\n                left++;\\n            }\\n            res=max(i-left+1,res);\\n        }\\n        return res;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {\\n        return max(solve(s,\\'F\\',k),solve(s,\\'T\\',k));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740395,
                "title": "1-pass-sliding-window",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string ans, int k) {\\n        int n=size(ans);\\n        int i=0,j=0,result=0;\\n\\n        unordered_map<char,int> mp;\\n        while(j<n)\\n        {\\n            mp[ans[j]]++;\\n\\n            while(min(mp[\\'T\\'], mp[\\'F\\']) > k)\\n            {\\n                mp[ans[i]]--;\\n                i++;\\n            }\\n\\n            result = max(result, j-i+1);\\n\\n            j++;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return result;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/9c9d25a5-591a-42e0-acd2-c285bd5349b0_1688896423.0135567.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string ans, int k) {\\n        int n=size(ans);\\n        int i=0,j=0,result=0;\\n\\n        unordered_map<char,int> mp;\\n        while(j<n)\\n        {\\n            mp[ans[j]]++;\\n\\n            while(min(mp[\\'T\\'], mp[\\'F\\']) > k)\\n            {\\n                mp[ans[i]]--;\\n                i++;\\n            }\\n\\n            result = max(result, j-i+1);\\n\\n            j++;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734475,
                "title": "c-o-1-space-o-n-time-easy-approach-beginner-friendly",
                "content": "# Intuition\\nFind max window size with atmost k \\'F\\' and k \\'T\\'\\nthen take the maximum of both.\\n\\n# Complexity\\n- Time complexity: O(n) Linear Time\\n\\n- Space complexity: O(1) constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string key, int k, char ch){\\n        int i=0,j=0,count=0,ans=0;\\n        while(j<key.size()){\\n            if(key[j]!=ch) count++;\\n            if(count<=k) ans=max(ans,j-i+1);\\n            else{\\n                while(count>k){\\n                    if(key[i]!=ch) count--;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(solve(answerKey,k,\\'T\\'),solve(answerKey,k,\\'F\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string key, int k, char ch){\\n        int i=0,j=0,count=0,ans=0;\\n        while(j<key.size()){\\n            if(key[j]!=ch) count++;\\n            if(count<=k) ans=max(ans,j-i+1);\\n            else{\\n                while(count>k){\\n                    if(key[i]!=ch) count--;\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(solve(answerKey,k,\\'T\\'),solve(answerKey,k,\\'F\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733702,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n      int i=0, j=0, ans=0, res=0;\\n        unordered_map<char, int>mp;\\n        for(i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n            ans=max(ans,mp[s[i]]);\\n            if(i-j+1-ans>k){\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            res=max(res, i-j+1);\\n        }\\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n      int i=0, j=0, ans=0, res=0;\\n        unordered_map<char, int>mp;\\n        for(i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n            ans=max(ans,mp[s[i]]);\\n            if(i-j+1-ans>k){\\n                mp[s[j]]--;\\n                j++;\\n            }\\n            res=max(res, i-j+1);\\n        }\\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733018,
                "title": "python-simple-sliding-window-solution-w-comments-beats-90",
                "content": "# Explanation:\\n\\n---\\n- At a high level, we are iterating the answer key and counting the number of T\\'s and F\\'s as we expand the window size (right ptr moving right).\\n- Once we reach too many T\\'s and F\\'s, the inner while loop moves the left pointer in (rightwards), thus reducing the window size, and getting the subarray to be valid again.\\n- Once this is done, we save the max size achieved if it is greater than our current max \\n\\n---\\n\\nI hope this is helpful -- please upvote if you are feeling generous! :)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n\\n        tcount = 0\\n        fcount = 0\\n\\n        n = len(answerKey)\\n\\n        left = 0\\n        window_sz = 0\\n\\n        for right in range(n):\\n            if answerKey[right] == \\'T\\':\\n                tcount += 1\\n            else:\\n                fcount += 1\\n\\n            while tcount > k and fcount > k:\\n\\n                if answerKey[left] == \\'T\\':\\n                    tcount -= 1\\n                else:\\n                    fcount -= 1\\n                left += 1\\n            \\n            window_sz = max(window_sz, right-left+1)\\n\\n        return window_sz\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n\\n        tcount = 0\\n        fcount = 0\\n\\n        n = len(answerKey)\\n\\n        left = 0\\n        window_sz = 0\\n\\n        for right in range(n):\\n            if answerKey[right] == \\'T\\':\\n                tcount += 1\\n            else:\\n                fcount += 1\\n\\n            while tcount > k and fcount > k:\\n\\n                if answerKey[left] == \\'T\\':\\n                    tcount -= 1\\n                else:\\n                    fcount -= 1\\n                left += 1\\n            \\n            window_sz = max(window_sz, right-left+1)\\n\\n        return window_sz\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732891,
                "title": "optimal-solution-using-sliding-windows-c-and-java-code",
                "content": "\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.length();\\n        int maxConsecutive = 0;\\n        int maxCount = 0;\\n        int left = 0;\\n        int counts[26] = {0}; \\n        for (int right = 0; right < n; right++) {\\n            counts[answerKey[right] - \\'A\\']++;\\n            maxCount = max(maxCount, counts[answerKey[right] - \\'A\\']);\\n            while (right - left + 1 - maxCount > k) {\\n                counts[answerKey[left] - \\'A\\']--;\\n                left++;\\n            }\\n            maxConsecutive = max(maxConsecutive, right - left + 1);\\n        }\\n        return maxConsecutive;\\n    }\\n};\\n\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int n = answerKey.length();\\n        int maxConsecutive = 0;\\n        int maxCount = 0;\\n        int left = 0;\\n        int[] counts = new int[26];\\n        \\n        for (int right = 0; right < n; right++) {\\n            counts[answerKey.charAt(right) - \\'A\\']++;\\n            maxCount = Math.max(maxCount, counts[answerKey.charAt(right) - \\'A\\']);\\n            \\n            while (right - left + 1 - maxCount > k) {\\n                counts[answerKey.charAt(left) - \\'A\\']--;\\n                left++;\\n            }\\n            \\n            maxConsecutive = Math.max(maxConsecutive, right - left + 1);\\n        }\\n        \\n        return maxConsecutive;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.length();\\n        int maxConsecutive = 0;\\n        int maxCount = 0;\\n        int left = 0;\\n        int counts[26] = {0}; \\n        for (int right = 0; right < n; right++) {\\n            counts[answerKey[right] - \\'A\\']++;\\n            maxCount = max(maxCount, counts[answerKey[right] - \\'A\\']);\\n            while (right - left + 1 - maxCount > k) {\\n                counts[answerKey[left] - \\'A\\']--;\\n                left++;\\n            }\\n            maxConsecutive = max(maxConsecutive, right - left + 1);\\n        }\\n        return maxConsecutive;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int n = answerKey.length();\\n        int maxConsecutive = 0;\\n        int maxCount = 0;\\n        int left = 0;\\n        int[] counts = new int[26];\\n        \\n        for (int right = 0; right < n; right++) {\\n            counts[answerKey.charAt(right) - \\'A\\']++;\\n            maxCount = Math.max(maxCount, counts[answerKey.charAt(right) - \\'A\\']);\\n            \\n            while (right - left + 1 - maxCount > k) {\\n                counts[answerKey.charAt(left) - \\'A\\']--;\\n                left++;\\n            }\\n            \\n            maxConsecutive = Math.max(maxConsecutive, right - left + 1);\\n        }\\n        \\n        return maxConsecutive;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731804,
                "title": "c-aditya-verma-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0, j = 0, t = 0, f = 0;\\n        int mx = 0, n = answerKey.size();\\n        while (j < n)\\n        {\\n            if (answerKey[j] == \\'T\\')\\n                t++;\\n            else\\n                f++;\\n            if (min(t, f) <= k)\\n            {\\n                mx = max(mx, j - i + 1);\\n                j++;\\n            }\\n            else\\n            {\\n                while (min(t, f) > k)\\n                {\\n                    if (answerKey[i] == \\'T\\')\\n                        t--;\\n                    else\\n                        f--;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/97be77b7-08f4-43a9-b2f9-2b286967bfcf_1688726844.9400396.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0, j = 0, t = 0, f = 0;\\n        int mx = 0, n = answerKey.size();\\n        while (j < n)\\n        {\\n            if (answerKey[j] == \\'T\\')\\n                t++;\\n            else\\n                f++;\\n            if (min(t, f) <= k)\\n            {\\n                mx = max(mx, j - i + 1);\\n                j++;\\n            }\\n            else\\n            {\\n                while (min(t, f) > k)\\n                {\\n                    if (answerKey[i] == \\'T\\')\\n                        t--;\\n                    else\\n                        f--;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731560,
                "title": "java-easy-tc-o-n-sc-o-1-explanation-with-images",
                "content": "# Explanation \\n\\nWe can solve this question using a `sliding window`. Each window will have `atmost k flips`. We will breakdown the problem into two parts:\\n\\n1. First we will find the longest run of `T` after **flipping** **atmost k** `F`. \\n2. Then we will find the longest run of `F` after **flipping** **atmost k** `T`. \\n\\n\\n\\nLet\\'t take an example to understand this. Suppose our `answer key =  FFTTFTFFFT` and `k = 2`. \\n\\nLet\\'s find the longest run of `T`\\n\\n---\\n\\nInitially, `i = 0`, `j = 0`, `k = 2`.\\n\\n![image.png](https://assets.leetcode.com/users/images/6ede4059-92a1-4ba0-b048-a00c5d096296_1688722131.2773287.png)\\n\\nWe will add the first character of the key. Since it is `F`, we will flip it.\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/3c167196-66af-4393-bb90-c17d96c86e7d_1688722183.904474.png)\\n\\nNow, we have `i = 0`, `j = 1`, `k = 1`.\\n\\nNow, we will add the next character of the key. Since it is `F`, we will flip it.\\n\\n---\\n\\nNow, we have `i = 0`, `j = 2`, `k = 1`.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/c49b8dce-7c20-4dee-acb9-333cdd839365_1688722249.8512912.png)\\n\\nNow, we will add the next character of the key. Since it is `T`, we can add them directly. Same for the next character.\\n\\n---\\n\\nNow, we have `i = 0`, `j = 4`, `k = 1`.\\n\\n![image.png](https://assets.leetcode.com/users/images/961621ab-6c86-4918-82f8-2664958e5529_1688722285.976512.png)\\n\\nNow, we will add the next character of the key. Since it is `F`, we will have to flip it but `k = 0`. This means we will have to reduce the size of window from left until we reach a character we flipped we flipped.\\n\\n---\\n\\nWe will continue like this for the whole length of our string.\\n\\n![image.png](https://assets.leetcode.com/users/images/36ce7038-a61e-40cd-9492-ddb043d9527c_1688722417.3071287.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/3fbba79b-952b-450e-b115-74247838709e_1688722515.6915238.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/5f76758b-cb1b-4457-a274-862f3adb089d_1688722714.3753521.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/0f30d523-24db-4f45-b6ae-11ce4e6d8c12_1688723256.2375982.png)\\n\\n---\\n\\nSimilarly, we can do this for longest run of `F` and flip any `T` we encounter.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int solve(String answerKey, int k, char c) {\\n        int i = 0, j = 0;\\n        int ans = 1;\\n        while(j < answerKey.length()) {\\n            if(answerKey.charAt(j) == c) {\\n                j ++;\\n            }\\n            else {\\n                if(k == 0) {\\n                    while(i <= j) {\\n                        if(answerKey.charAt(i) != c) {\\n                            i ++;\\n                            k ++;\\n                            break;\\n                        }\\n                        i ++;\\n                    }\\n                }\\n                k --;\\n                j ++;\\n            }\\n            ans = Math.max(ans, j - i);\\n        }\\n        return ans;\\n    }\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int ans = solve(answerKey, k, \\'T\\');\\n        ans = Math.max(ans, solve(answerKey, k, \\'F\\'));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(String answerKey, int k, char c) {\\n        int i = 0, j = 0;\\n        int ans = 1;\\n        while(j < answerKey.length()) {\\n            if(answerKey.charAt(j) == c) {\\n                j ++;\\n            }\\n            else {\\n                if(k == 0) {\\n                    while(i <= j) {\\n                        if(answerKey.charAt(i) != c) {\\n                            i ++;\\n                            k ++;\\n                            break;\\n                        }\\n                        i ++;\\n                    }\\n                }\\n                k --;\\n                j ++;\\n            }\\n            ans = Math.max(ans, j - i);\\n        }\\n        return ans;\\n    }\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int ans = solve(answerKey, k, \\'T\\');\\n        ans = Math.max(ans, solve(answerKey, k, \\'F\\'));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730964,
                "title": "beat-100-solution-in-c-easily-understandable-variable-names-used",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MaxConsecutiveAnswers(string answerKey, int k) {\\n        int longestConsecutiveCount = 0;  // Maximum number of consecutive \\'T\\'s or \\'F\\'s\\n        int left = 0;  // Left pointer of the sliding window\\n        int maxChanges = k;  // Maximum changes allowed\\n        int tCount = 0;  // Count of consecutive \\'T\\'s\\n        int fCount = 0;  // Count of consecutive \\'F\\'s\\n        \\n        // Iterate through the answerKey using the right pointer\\n        for (int right = 0; right < answerKey.Length; right++) {\\n            char currentAnswer = answerKey[right];\\n            \\n            // Increment the count of the current answer\\n            if (currentAnswer == \\'T\\') {\\n                tCount++;\\n            } else {\\n                fCount++;\\n            }\\n            \\n            // If the number of changes needed exceeds the maximum changes allowed,\\n            // move the left pointer and update the counts\\n            while (Math.Min(tCount, fCount) > maxChanges) {\\n                char leftAnswer = answerKey[left];\\n                \\n                // Decrement the count of the left answer and move the left pointer\\n                if (leftAnswer == \\'T\\') {\\n                    tCount--;\\n                } else {\\n                    fCount--;\\n                }\\n                \\n                left++;  // Move the left pointer\\n            }\\n            \\n            // Update the longest consecutive count\\n            longestConsecutiveCount = Math.Max(longestConsecutiveCount, right - left + 1);\\n        }\\n        \\n        return longestConsecutiveCount;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxConsecutiveAnswers(string answerKey, int k) {\\n        int longestConsecutiveCount = 0;  // Maximum number of consecutive \\'T\\'s or \\'F\\'s\\n        int left = 0;  // Left pointer of the sliding window\\n        int maxChanges = k;  // Maximum changes allowed\\n        int tCount = 0;  // Count of consecutive \\'T\\'s\\n        int fCount = 0;  // Count of consecutive \\'F\\'s\\n        \\n        // Iterate through the answerKey using the right pointer\\n        for (int right = 0; right < answerKey.Length; right++) {\\n            char currentAnswer = answerKey[right];\\n            \\n            // Increment the count of the current answer\\n            if (currentAnswer == \\'T\\') {\\n                tCount++;\\n            } else {\\n                fCount++;\\n            }\\n            \\n            // If the number of changes needed exceeds the maximum changes allowed,\\n            // move the left pointer and update the counts\\n            while (Math.Min(tCount, fCount) > maxChanges) {\\n                char leftAnswer = answerKey[left];\\n                \\n                // Decrement the count of the left answer and move the left pointer\\n                if (leftAnswer == \\'T\\') {\\n                    tCount--;\\n                } else {\\n                    fCount--;\\n                }\\n                \\n                left++;  // Move the left pointer\\n            }\\n            \\n            // Update the longest consecutive count\\n            longestConsecutiveCount = Math.Max(longestConsecutiveCount, right - left + 1);\\n        }\\n        \\n        return longestConsecutiveCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730787,
                "title": "sliding-window-very-simple-c-solution-easy-to-understand",
                "content": "\\'\\'\\'\\n\\n\\nclass Solution {\\npublic:\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size(), cntT=0, cntF=0;\\n        int l=0, r=0, maxi=INT_MIN;\\n        \\n        while(r<n){\\n            if(answerKey[r]==\\'T\\') cntT++;\\n            else cntF++;\\n            \\n            while(cntT>k && cntF>k){\\n                if(answerKey[l]==\\'T\\') cntT--;\\n                else cntF--;\\n                l++;\\n            }\\n            \\n            maxi=max(maxi, r-l+1);\\n            r++;\\n        }\\n        \\n        return maxi;  \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size(), cntT=0, cntF=0;\\n        int l=0, r=0, maxi=INT_MIN;\\n        \\n        while(r<n){\\n            if(answerKey[r]==\\'T\\') cntT++;\\n            else cntF++;\\n            \\n            while(cntT>k && cntF>k){\\n                if(answerKey[l]==\\'T\\') cntT--;\\n                else cntF--;\\n                l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3730662,
                "title": "easy-code-run-sliding-window-2-times-explained-and-commented-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you think of the problem , it can be divided into two sub problems, max count with T or max count with F, and ultimately we have to return the max of both these sub problems. I have done it with two pass , you can do it recursively too but it will involve some recursive stack space!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep two pointers at the start , i and j , create a copy of the limit k, in the first iteration we check for max number of \\'T\\' we can achieve, if we encounter a \\'F\\' we simply reduce k, and increment our pointer j, now if at anytime we find k<0 then we simply need to check at the back(or start as you must like to call) of the sliding window, if we encounter any \\'F\\' which we dont want as we are checking for max Trues, so just increase our limit k and keep increasing i.\\n\\nAt the end of the iteration just keep the count of the max lenght stored in our cnt variable. (Note cnt is common in both iterations as we just need max of all)\\n\\nIn the second while loop a similar iteration is done now this time for max number of F.\\n\\nhope you get the approach, just have a look at the code for better understanding\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       O(2N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n       O(1)\\n# It takes a lot of effort to form solutions and explain in the simplist way possible , please do upvote ^_^\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int cnt=0; //keeps count of max length\\n        int i=0; //i and j to keep sliding window\\n        int j=0;\\n        int limit=k; //creating a copy of k so as it doesnt get lost\\n        int n=answerKey.size();\\n        //checking for max Ts\\n        while(j<n){\\n            if(answerKey[j]==\\'F\\'){ //just use k to change to T\\n                k--;\\n            }\\n            j++; //after change increment the window with j\\n            if(k<0){ //if we exhaust our limit k, move sliding window\\n                if(answerKey[i]==\\'F\\'){\\n                    k++;\\n                }\\n                i++;\\n            }\\n            cnt=max(cnt,j-i);\\n        }\\n        i=0,j=0,k=limit; //reset variables for next iteration\\n        //checking for max Fs now\\n        while(j<n){\\n            if(answerKey[j]==\\'T\\'){ //we dont want T, change it till \\n                k--;               //we can use k\\n            }\\n            j++; //window increase\\n            if(k<0){ //exhauseted our limit so\\n                if(answerKey[i]==\\'T\\'){ \\n                    k++;\\n                }\\n                i++; //shift window from back\\n            }\\n            cnt=max(cnt,j-i);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int cnt=0; //keeps count of max length\\n        int i=0; //i and j to keep sliding window\\n        int j=0;\\n        int limit=k; //creating a copy of k so as it doesnt get lost\\n        int n=answerKey.size();\\n        //checking for max Ts\\n        while(j<n){\\n            if(answerKey[j]==\\'F\\'){ //just use k to change to T\\n                k--;\\n            }\\n            j++; //after change increment the window with j\\n            if(k<0){ //if we exhaust our limit k, move sliding window\\n                if(answerKey[i]==\\'F\\'){\\n                    k++;\\n                }\\n                i++;\\n            }\\n            cnt=max(cnt,j-i);\\n        }\\n        i=0,j=0,k=limit; //reset variables for next iteration\\n        //checking for max Fs now\\n        while(j<n){\\n            if(answerKey[j]==\\'T\\'){ //we dont want T, change it till \\n                k--;               //we can use k\\n            }\\n            j++; //window increase\\n            if(k<0){ //exhauseted our limit so\\n                if(answerKey[i]==\\'T\\'){ \\n                    k++;\\n                }\\n                i++; //shift window from back\\n            }\\n            cnt=max(cnt,j-i);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730602,
                "title": "cpp-sliding-window-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The code maintains two variables, `ct` and `cf`, which represent the counts of \\'T\\' (true) and \\'F\\' (false) in the `nums` string, respectively. These variables are updated as the code iterates through the string.\\n\\n2. The code uses a sliding window approach to find the maximum consecutive sequence of \\'T\\' or \\'F\\' characters, given the constraint `k`. The variable `ans` keeps track of the maximum length found so far. If the current window violates the constraint (i.e., `mn > k`), the code slides the window by incrementing `i` until the constraint is satisfied again. This ensures that the window always contains the maximum number of \\'T\\' or \\'F\\' characters within the constraint. The variable `ans` is updated accordingly.\\n3. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint maxConsecutiveAnswers(string nums, int k) {\\n    int ct = 0, cf = 0, ans = INT_MIN, n = nums.size();\\n    int i = 0, j = 0;\\n\\n    while (j < n) {\\n        // Count the occurrences of \\'T\\' and \\'F\\'\\n        if (nums[j] == \\'T\\')\\n            ct++;\\n        else\\n            cf++;\\n\\n        // Calculate the minimum count between \\'T\\' and \\'F\\'\\n        int mn = min(ct, cf);\\n\\n        if (mn <= k) {\\n            // If the minimum count is less than or equal to k, update the answer\\n            ans = max(ans, j - i + 1);\\n        } else if (mn > k) {\\n            // If the minimum count is greater than k, slide the window\\n            while (mn > k) {\\n                // Decrement the count based on the character at the left end of the window\\n                if (nums[i] == \\'T\\')\\n                    ct--;\\n                else if (nums[i] == \\'F\\')\\n                    cf--;\\n\\n                // Recalculate the minimum count\\n                mn = min(ct, cf);\\n                i++; // Slide the window by incrementing the left pointer\\n            }\\n\\n            // Update the answer after the window is adjusted\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        j++; // Move the right pointer to expand the window\\n    }\\n\\n    // Return the maximum consecutive sequence length found\\n    return ans;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nint maxConsecutiveAnswers(string nums, int k) {\\n    int ct = 0, cf = 0, ans = INT_MIN, n = nums.size();\\n    int i = 0, j = 0;\\n\\n    while (j < n) {\\n        // Count the occurrences of \\'T\\' and \\'F\\'\\n        if (nums[j] == \\'T\\')\\n            ct++;\\n        else\\n            cf++;\\n\\n        // Calculate the minimum count between \\'T\\' and \\'F\\'\\n        int mn = min(ct, cf);\\n\\n        if (mn <= k) {\\n            // If the minimum count is less than or equal to k, update the answer\\n            ans = max(ans, j - i + 1);\\n        } else if (mn > k) {\\n            // If the minimum count is greater than k, slide the window\\n            while (mn > k) {\\n                // Decrement the count based on the character at the left end of the window\\n                if (nums[i] == \\'T\\')\\n                    ct--;\\n                else if (nums[i] == \\'F\\')\\n                    cf--;\\n\\n                // Recalculate the minimum count\\n                mn = min(ct, cf);\\n                i++; // Slide the window by incrementing the left pointer\\n            }\\n\\n            // Update the answer after the window is adjusted\\n            ans = max(ans, j - i + 1);\\n        }\\n\\n        j++; // Move the right pointer to expand the window\\n    }\\n\\n    // Return the maximum consecutive sequence length found\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730515,
                "title": "simple-solution",
                "content": "# Upvote Please!\\n# Code\\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int countT = 0, countF = 0, res = 0; \\n        \\n        for(int i = 0, j = 0; j < answerKey.length(); j++) {\\n            if(answerKey.charAt(j) == \\'T\\') \\n                countT++;\\n            else\\n                countF++;\\n            \\n            while(Math.min(countT, countF) > k) {\\n                if(answerKey.charAt(i++) == \\'T\\') \\n                    countT--;\\n                else\\n                    countF--;\\n            }\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int countT = 0, countF = 0, res = 0; \\n        \\n        for(int i = 0, j = 0; j < answerKey.length(); j++) {\\n            if(answerKey.charAt(j) == \\'T\\') \\n                countT++;\\n            else\\n                countF++;\\n            \\n            while(Math.min(countT, countF) > k) {\\n                if(answerKey.charAt(i++) == \\'T\\') \\n                    countT--;\\n                else\\n                    countF--;\\n            }\\n            res = Math.max(res, j - i + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730273,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string st, int k) {\\n        int sz = (int)st.size();\\n        int res = 0;\\n\\n        auto LeetCode = [&] (char c) {\\n            int ret = 0, curr = 0, beg = 0;\\n            for (int i = 0; i < sz; i++) {\\n                if (st[i] == c){\\n                    curr++;\\n                }\\n                while (curr > k) {\\n                    if (st[beg] == c) {\\n                        curr--;\\n                    }\\n                    beg++;\\n                }\\n                ret = max(i - beg + 1, ret);\\n            }\\n            return ret;\\n        };\\n        \\n        res = max(LeetCode(\\'T\\'), LeetCode(\\'F\\'));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string st, int k) {\\n        int sz = (int)st.size();\\n        int res = 0;\\n\\n        auto LeetCode = [&] (char c) {\\n            int ret = 0, curr = 0, beg = 0;\\n            for (int i = 0; i < sz; i++) {\\n                if (st[i] == c){\\n                    curr++;\\n                }\\n                while (curr > k) {\\n                    if (st[beg] == c) {\\n                        curr--;\\n                    }\\n                    beg++;\\n                }\\n                ret = max(i - beg + 1, ret);\\n            }\\n            return ret;\\n        };\\n        \\n        res = max(LeetCode(\\'T\\'), LeetCode(\\'F\\'));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730267,
                "title": "maximize-the-confusion-of-an-exam",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nfunction maxConsecutiveAnswers(answerKey, k) {\\n  let maxLength = 0;\\n  let maxCount = 0;\\n  let counts = { \\'T\\': 0, \\'F\\': 0 };\\n  let left = 0;\\n\\n  for (let right = 0; right < answerKey.length; right++) {\\n    counts[answerKey[right]]++;\\n    maxCount = Math.max(maxCount, counts[answerKey[right]]);\\n\\n    if ((right - left + 1) - maxCount > k) {\\n      counts[answerKey[left]]--;\\n      left++;\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1);\\n  }\\n\\n  return maxLength;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nfunction maxConsecutiveAnswers(answerKey, k) {\\n  let maxLength = 0;\\n  let maxCount = 0;\\n  let counts = { \\'T\\': 0, \\'F\\': 0 };\\n  let left = 0;\\n\\n  for (let right = 0; right < answerKey.length; right++) {\\n    counts[answerKey[right]]++;\\n    maxCount = Math.max(maxCount, counts[answerKey[right]]);\\n\\n    if ((right - left + 1) - maxCount > k) {\\n      counts[answerKey[left]]--;\\n      left++;\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1);\\n  }\\n\\n  return maxLength;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730185,
                "title": "not-detailed-very-short-explanation-modifying-the-question-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Think like, you want the longest substring of \\'T\\' after flipping k \\'F\\'s to \\'T\\'s.\\n2. Similarly think for \\'F\\'.\\n3. Return max( step(1) , step(2) ).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //This is same as Max Consecutive Ones III\\n\\n    int Tto1(string answerKey, int k)\\n    {\\n        int right = 0;\\n        int left = 0;\\n        int cnt = 0;\\n        int ans = 0;\\n\\n        for(right = 0; right < answerKey.size(); right++)\\n        {\\n            if(answerKey[right] == \\'F\\')\\n            {\\n                cnt++;\\n            }\\n            if(cnt > k)\\n            {\\n                if(answerKey[left] == \\'F\\')\\n                {\\n                    cnt--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n    int Fto1(string answerKey, int k)\\n    {\\n        int right = 0;\\n        int left = 0;\\n        int cnt = 0;\\n        int ans = 0;\\n\\n        for(right = 0; right < answerKey.size(); right++)\\n        {\\n            if(answerKey[right] == \\'T\\')\\n            {\\n                cnt++;\\n            }\\n            if(cnt > k)\\n            {\\n                if(answerKey[left] == \\'T\\')\\n                {\\n                    cnt--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(Tto1(answerKey, k), Fto1(answerKey, k));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //This is same as Max Consecutive Ones III\\n\\n    int Tto1(string answerKey, int k)\\n    {\\n        int right = 0;\\n        int left = 0;\\n        int cnt = 0;\\n        int ans = 0;\\n\\n        for(right = 0; right < answerKey.size(); right++)\\n        {\\n            if(answerKey[right] == \\'F\\')\\n            {\\n                cnt++;\\n            }\\n            if(cnt > k)\\n            {\\n                if(answerKey[left] == \\'F\\')\\n                {\\n                    cnt--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n    int Fto1(string answerKey, int k)\\n    {\\n        int right = 0;\\n        int left = 0;\\n        int cnt = 0;\\n        int ans = 0;\\n\\n        for(right = 0; right < answerKey.size(); right++)\\n        {\\n            if(answerKey[right] == \\'T\\')\\n            {\\n                cnt++;\\n            }\\n            if(cnt > k)\\n            {\\n                if(answerKey[left] == \\'T\\')\\n                {\\n                    cnt--;\\n                }\\n                left++;\\n            }\\n            ans = max(ans, right - left + 1);\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(Tto1(answerKey, k), Fto1(answerKey, k));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730089,
                "title": "java-approach-with-proper-explanation-of-sliding-window-concept",
                "content": "**Here is an explanation to sliding window approach**\\n![image](https://assets.leetcode.com/users/images/ce737225-6858-43ae-aa67-d567640fe9bd_1688703953.3755102.png)\\n\\n**Sub part of the problem**\\n![image](https://assets.leetcode.com/users/images/a24d4797-d801-44f8-bdbd-b5e22b6ec984_1688703970.7884166.png)\\n\\n\\n**Obeservation**\\nThe maximum ans possible could be found out in two cases\\n* By changing some T to F\\n* By changins some F to T\\n* We return the max possible out of the two\\n**Code**\\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String s, int k) {\\n        int start=0,end=0,ans=0,count=0,n=s.length();\\n        \\n        //Checking the max consecutive F possible if we can change at max K \\'T\\'\\n        while(end<n)\\n        {\\n            char ch=s.charAt(end);\\n            if(ch==\\'T\\')//Count the number of \\'T\\'encountered\\n                ++count;\\n            while(count>k)//If count>\\'T\\'then we need to move start and decrease \\n                            // the number of \\'T\\'so that count<=K\\n                if(s.charAt(start++)==\\'T\\')\\n                    --count;\\n            ans=Math.max(ans,end-start+1);//We update the length of the ans\\n            ++end;\\n        }\\n        end=0;\\n        start=0;\\n        count=0;\\n        //Cheching the max consecutive T possible if we can change at max K\\'F\\'\\n        while(end<n)\\n        {\\n            char ch=s.charAt(end);\\n            if(ch==\\'F\\')\\n                ++count;\\n            while(count>k)\\n                if(s.charAt(start++)==\\'F\\')\\n                    --count;\\n            ans=Math.max(ans,end-start+1);\\n            ++end;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String s, int k) {\\n        int start=0,end=0,ans=0,count=0,n=s.length();\\n        \\n        //Checking the max consecutive F possible if we can change at max K \\'T\\'\\n        while(end<n)\\n        {\\n            char ch=s.charAt(end);\\n            if(ch==\\'T\\')//Count the number of \\'T\\'encountered\\n                ++count;\\n            while(count>k)//If count>\\'T\\'then we need to move start and decrease \\n                            // the number of \\'T\\'so that count<=K\\n                if(s.charAt(start++)==\\'T\\')\\n                    --count;\\n            ans=Math.max(ans,end-start+1);//We update the length of the ans\\n            ++end;\\n        }\\n        end=0;\\n        start=0;\\n        count=0;\\n        //Cheching the max consecutive T possible if we can change at max K\\'F\\'\\n        while(end<n)\\n        {\\n            char ch=s.charAt(end);\\n            if(ch==\\'F\\')\\n                ++count;\\n            while(count>k)\\n                if(s.charAt(start++)==\\'F\\')\\n                    --count;\\n            ans=Math.max(ans,end-start+1);\\n            ++end;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730000,
                "title": "easy-java-solution-100",
                "content": "\\n# Complexity\\n- Time complexity: `O(n)`\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic int maxConsecutiveAnswers(String answerKey, int k) {\\n\\t\\t     int ans = 0;\\n        int max_count = 0;\\n        int[] count = new int[2];\\n        for(int l = 0,r=0;r<answerKey.length();r++)\\n        {\\n            max_count = Math.max(max_count,++count[answerKey.charAt(r) == \\'T\\' ? 1: 0]);\\n            while(max_count + k < r-l+1)\\n            {\\n                --count[answerKey.charAt(l++) == \\'T\\'? 1 : 0];\\n            }\\n            ans = Math.max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int maxConsecutiveAnswers(String answerKey, int k) {\\n\\t\\t     int ans = 0;\\n        int max_count = 0;\\n        int[] count = new int[2];\\n        for(int l = 0,r=0;r<answerKey.length();r++)\\n        {\\n            max_count = Math.max(max_count,++count[answerKey.charAt(r) == \\'T\\' ? 1: 0]);\\n            while(max_count + k < r-l+1)\\n            {\\n                --count[answerKey.charAt(l++) == \\'T\\'? 1 : 0];\\n            }\\n            ans = Math.max(ans,r-l+1);\\n        }\\n        return ans;\\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729915,
                "title": "easy-c-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind maximum number of \"T\" by changing K characters, let it be t.\\nFind maximum number of \\'F\" by changing K characters, let it be f.\\nanswer is the maximum of t and f.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string a, int k) {\\n        int l=0,c=0,m1=0;\\n        for(int i=0;i<a.size();i++){\\n             if(a[i]==\\'F\\'){c++;}\\n             while(c>k){\\n                 if(a[l]==\\'F\\'){c--;}\\n                 l++;\\n             }\\n              m1=max(m1,i-l+1);\\n        }\\n        l=0,c=0;\\n        int m2=0;\\n        for(int i=0;i<a.size();i++){\\n             if(a[i]==\\'T\\'){c++;}\\n             while(c>k){\\n                 if(a[l]==\\'T\\'){c--;}\\n                 l++;\\n             }\\n              m2=max(m2,i-l+1);\\n        }\\n        return max(m1,m2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string a, int k) {\\n        int l=0,c=0,m1=0;\\n        for(int i=0;i<a.size();i++){\\n             if(a[i]==\\'F\\'){c++;}\\n             while(c>k){\\n                 if(a[l]==\\'F\\'){c--;}\\n                 l++;\\n             }\\n              m1=max(m1,i-l+1);\\n        }\\n        l=0,c=0;\\n        int m2=0;\\n        for(int i=0;i<a.size();i++){\\n             if(a[i]==\\'T\\'){c++;}\\n             while(c>k){\\n                 if(a[l]==\\'T\\'){c--;}\\n                 l++;\\n             }\\n              m2=max(m2,i-l+1);\\n        }\\n        return max(m1,m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729891,
                "title": "easy-sliding-window-hashmap-solution-c",
                "content": "# Approach\\nKeep a sliding window and maintain a count of the character with max frequency in the window. Check if the current window is valid and update the window length.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string ans, int k) {\\n        unordered_map<char, int> mp;\\n        int l = 0, r = 0, len = 0, mx = 0;\\n\\n        while(r < ans.size()){\\n            char curr = ans[r];\\n            mp[curr]++;\\n            mx = max(mx, mp[curr]);\\n\\n            while(r-l+1 - mx > k){\\n                mp[ans[l]]--;\\n                l++;\\n            }\\n\\n            len = max(len, r-l+1);\\n            r++;\\n        }\\n\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string ans, int k) {\\n        unordered_map<char, int> mp;\\n        int l = 0, r = 0, len = 0, mx = 0;\\n\\n        while(r < ans.size()){\\n            char curr = ans[r];\\n            mp[curr]++;\\n            mx = max(mx, mp[curr]);\\n\\n            while(r-l+1 - mx > k){\\n                mp[ans[l]]--;\\n                l++;\\n            }\\n\\n            len = max(len, r-l+1);\\n            r++;\\n        }\\n\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729536,
                "title": "c-solution-with-explaination-using-sliding-window-technique",
                "content": "# Intuition\\nThe intuition of the approach is to use SLIDING WINDOW TECHNIQUE to maintain the consecutive answers. \\n\\n# Approach\\n1. Declare i and j be 0. T and F will store the number of true and false in the window.\\n2. If min(T,F) exceeds k, i.e. toggle operation we are going to perform( k times) on either True or False exceeds k value, Then increase make sure to remove the ith element in your window because we will decrease the size of window i.e. i++ increase the i pointer.\\n3. Store the maximum answer in ans variable and return it after traversing.\\n\\n# Complexity\\n- Time complexity:\\nO(N), we are traversing the string.\\n\\n- Space complexity:\\nO(1), we didn\\'t take extra space.\\n\\nUpvote if you like the solution :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans=0,T=0,F=0,i=0;\\n        for(int j=0;j<answerKey.size();j++){\\n            if(answerKey[j]==\\'T\\') T++;\\n            else F++;\\n            if(min(T,F)>k){\\n                if(answerKey[i]==\\'T\\') T--;\\n                else F--;\\n                i++;\\n            }\\n            ans=max(ans,T+F);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans=0,T=0,F=0,i=0;\\n        for(int j=0;j<answerKey.size();j++){\\n            if(answerKey[j]==\\'T\\') T++;\\n            else F++;\\n            if(min(T,F)>k){\\n                if(answerKey[i]==\\'T\\') T--;\\n                else F--;\\n                i++;\\n            }\\n            ans=max(ans,T+F);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729533,
                "title": "c-sliding-window-queue",
                "content": "# Approach\\nUse two sliding windows, one for T and one for F. Expand and contract based on number of ```T or F``` in the window. Update ```result``` based on size of the windows. \\n\\nWe initialize ```tLeft``` and ```fLeft``` to ```-1``` to prevent needing to ```+1``` on every window size check.\\n\\nQueue optimization inspired by [bytchenko](https://leetcode.com/bytchenko/) and his solution [here](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3644871/c-sliding-window/).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxConsecutiveAnswers(string answerKey, int k)\\n    {\\n        Queue<int> tQueue = new(), fQueue = new();\\n        int tLeft = -1, fLeft = -1;\\n        int result = 0;\\n\\n        for (int right = 0; right < answerKey.Length; right++)\\n        {\\n            if (answerKey[right] == \\'T\\')\\n            {\\n                tQueue.Enqueue(right);\\n                if (tQueue.Count > k)\\n                    tLeft = tQueue.Dequeue();\\n            }\\n            else\\n            {\\n                fQueue.Enqueue(right);\\n                if (fQueue.Count > k)\\n                    fLeft = fQueue.Dequeue();\\n            }\\n            result = Math.Max(result, right - tLeft);\\n            result = Math.Max(result, right - fLeft);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```T or F```\n```result```\n```tLeft```\n```fLeft```\n```-1```\n```+1```\n```\\npublic class Solution {\\n    public int MaxConsecutiveAnswers(string answerKey, int k)\\n    {\\n        Queue<int> tQueue = new(), fQueue = new();\\n        int tLeft = -1, fLeft = -1;\\n        int result = 0;\\n\\n        for (int right = 0; right < answerKey.Length; right++)\\n        {\\n            if (answerKey[right] == \\'T\\')\\n            {\\n                tQueue.Enqueue(right);\\n                if (tQueue.Count > k)\\n                    tLeft = tQueue.Dequeue();\\n            }\\n            else\\n            {\\n                fQueue.Enqueue(right);\\n                if (fQueue.Count > k)\\n                    fLeft = fQueue.Dequeue();\\n            }\\n            result = Math.Max(result, right - tLeft);\\n            result = Math.Max(result, right - fLeft);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854318,
                "title": "99-03-faster-easy-to-understand-linear-solution",
                "content": "```\\nclass Solution\\n{\\n    private:\\n    int count(string &s, int k, char c)\\n    {\\n        int N = s.size(), cnt = 0, i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j)\\n        {\\n            cnt += s[j] == c;\\n            while (cnt > k)\\n                cnt -= s[i++] == c; \\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int maxConsecutiveAnswers(string s, int k)\\n    {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\n    private:\\n    int count(string &s, int k, char c)\\n    {\\n        int N = s.size(), cnt = 0, i = 0, ans = 0;\\n        for (int j = 0; j < N; ++j)\\n        {\\n            cnt += s[j] == c;\\n            while (cnt > k)\\n                cnt -= s[i++] == c; \\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int maxConsecutiveAnswers(string s, int k)\\n    {\\n        return max(count(s, k, \\'T\\'), count(s, k, \\'F\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538361,
                "title": "c-sliding-window-intuition-explained",
                "content": "THE KEY FACTOR HERE IS IN REALISING THAT WE NEED A STRING FULL OF \"T\" WITH AT MOST K \"F\", OR STRING FULL OF  \"F\" WITH AT MOST K \"T\".\\nSO THEN WE CALCULATE FOR BOTH CASES AND THEN RETURN THE MAXIMUM OF THESE .\\nWE\\'LL  CREATE A SLIDING WINDOW FUNCTION TO CALCULATE THE CONSECUTIVE CHAR .\\nSO THE FUNCTION WOULD BE THE BELOW ONE.\\n```\\nint atmostofchar(string s,char a,int k){\\n        int l=0,cnt=0,res=INT_MIN,n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==a)cnt++;\\n            while(cnt>k){/*THIS IS TO ENSURE THAT THERE WONT BE MORE THAN \\'K\\' CHARS CONSECUTIVELY i.e AT-MOST \\'K\\' CHAR A */\\n                if(s[l]==a)cnt--;\\n                l++;\\n            }\\n            res=max(res,i-l+1);// MAXIMUM WINDOW\\n        }\\n        return res;\\n    }\\n```\\nNOW ALL WE NEED TO DO IS RETURN THE RESULT OF MAXIMUM OF BOTH  CASES.\\n```\\n int maxConsecutiveAnswers(string s, int k) {\\n       return max(atmostofchar(s,\\'F\\',k),atmostofchar(s,\\'T\\',k));\\n    }\\n```\\nHOPE YOU UNDERSTOOD THE  SOLUTION , DO UPVOTE IF THIS WAS HELPFUL.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint atmostofchar(string s,char a,int k){\\n        int l=0,cnt=0,res=INT_MIN,n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==a)cnt++;\\n            while(cnt>k){/*THIS IS TO ENSURE THAT THERE WONT BE MORE THAN \\'K\\' CHARS CONSECUTIVELY i.e AT-MOST \\'K\\' CHAR A */\\n                if(s[l]==a)cnt--;\\n                l++;\\n            }\\n            res=max(res,i-l+1);// MAXIMUM WINDOW\\n        }\\n        return res;\\n    }\\n```\n```\\n int maxConsecutiveAnswers(string s, int k) {\\n       return max(atmostofchar(s,\\'F\\',k),atmostofchar(s,\\'T\\',k));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2380272,
                "title": "o-n-sliding-window-in-generic-format",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answer, int k) \\n    {\\n        int n=answer.size();\\n        int i=0;\\n        int maxctr=0;\\n        int tctr=0;\\n        int fctr=0;\\n        \\n        for(int j=0; j<n; j++)\\n        {\\n            if(answer[j]==\\'T\\')\\n            {\\n                tctr++;\\n                maxctr=max(maxctr, tctr);\\n            }\\n            else\\n            {\\n                fctr++;\\n                maxctr=max(maxctr, fctr);\\n            }\\n            \\n            if(j-i+1-maxctr>k)\\n            {\\n                if(answer[i]==\\'T\\')\\n                    tctr--;\\n                else\\n                    fctr--;\\n                i++;\\n            }\\n        }\\n        return n-i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answer, int k) \\n    {\\n        int n=answer.size();\\n        int i=0;\\n        int maxctr=0;\\n        int tctr=0;\\n        int fctr=0;\\n        \\n        for(int j=0; j<n; j++)\\n        {\\n            if(answer[j]==\\'T\\')\\n            {\\n                tctr++;\\n                maxctr=max(maxctr, tctr);\\n            }\\n            else\\n            {\\n                fctr++;\\n                maxctr=max(maxctr, fctr);\\n            }\\n            \\n            if(j-i+1-maxctr>k)\\n            {\\n                if(answer[i]==\\'T\\')\\n                    tctr--;\\n                else\\n                    fctr--;\\n                i++;\\n            }\\n        }\\n        return n-i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160637,
                "title": "c-sliding-window-binary-search-prefix-count",
                "content": "**Sliding Window**\\nTC: O(2N)\\nSC: O(1)\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int maxConsecutiveAnswers(string s, int k) {\\n        //acquire till my k is invalid\\n        //release untill my k is valid\\n        \\n        \\n        //this is for T\\n        int n = s.size();\\n        int counter = 0;\\n        int j=0;\\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'F\\'){\\n                counter++;\\n            }\\n            while(j<i and counter > k){//i dont have any k remaining\\n                if(s[j]==\\'F\\'){\\n                    counter--;\\n                }\\n                j++;\\n            }\\n            \\n            if(counter <= k){\\n                int len = i-j+1;\\n                ans = max(ans,len);\\n            }\\n            \\n        }\\n        \\n        //this is for F\\n        j=0;\\n        int ans2 = 1;\\n        counter = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'T\\'){\\n                counter++;\\n            }\\n            while(j<i and counter > k){//i dont have any k remaining\\n                if(s[j]==\\'T\\'){\\n                    counter--;\\n                }\\n                j++;\\n            }\\n            \\n            if(counter <= k){\\n                int len = i-j+1;\\n                ans2 = max(ans2,len);\\n            }\\n            \\n        }\\n        \\n        return max(ans,ans2);\\n    }\\n};\\n\\n\\n/*\\n\\ni am allowed to change only k times\\n\\n*/\\n```\\n\\n**Binary Search**\\nTC: O(n+nlogn + nlogn) =~ O(n+2nlogn)\\nSC: O(2n) -> for prefix count\\n\\n```\\nclass Solution {\\npublic:\\n    #define pii pair<int,int>\\n    #define f first\\n    #define s second\\n    //returns idx which satisfies\\n    //TTTTTTFFFFFF\\n    int bs (int i,string &s,int k,int n,vector<pii> &ps){\\n        \\n        int idx = -1;\\n        \\n        int lo = i;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            int fv = i==0 ? ps[mid].s : ps[mid].s-ps[i-1].s;\\n            \\n            if(fv <= k){//true\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        \\n        if(idx == -1){\\n            return -1;\\n        }\\n        \\n        return idx;\\n    }\\n    \\n    int bs2 (int i,string &s,int k,int n,vector<pii> &ps){\\n        \\n        int idx = -1;\\n        \\n        int lo = i;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            int tv = i==0 ? ps[mid].f : ps[mid].f-ps[i-1].f;\\n            \\n            if(tv <= k){//true\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        \\n        if(idx == -1){\\n            return -1;\\n        }\\n        \\n        return idx;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int n = s.size();\\n        int ans = 1;\\n        vector<pii> ps(n);//{T,F}\\n        \\n        if(s[0]==\\'T\\'){\\n            ps[0].f = 1;\\n            ps[0].s = 0;\\n        }\\n        else{\\n            ps[0].f = 0;\\n            ps[0].s = 1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'T\\'){\\n                ps[i].f = ps[i-1].f + 1;\\n                ps[i].s = ps[i-1].s;\\n            }\\n            else{\\n                ps[i].f = ps[i-1].f;\\n                ps[i].s = ps[i-1].s + 1;\\n            }\\n        }\\n        \\n        //on true\\n        for(int i=0;i<n;i++){\\n            \\n            int idx = bs(i,s,k,n,ps);\\n            \\n            if(idx != -1){//idx is valid\\n                int len = idx-i+1;\\n                ans = max(ans,len);\\n            }\\n        }\\n        \\n        \\n        //on false\\n        int ans2=1;\\n        for(int i=0;i<n;i++){\\n            \\n            int idx = bs2(i,s,k,n,ps);\\n            \\n            if(idx != -1){//idx is valid\\n                int len = idx-i+1;\\n                ans2 = max(ans2,len);\\n            }\\n        }\\n        \\n        return max(ans,ans2);\\n    }\\n};\\n\\n\\n/*\\n\\n\\n*/\\n```\\n\\n**Binary Search + Fixed Sized Sliding Window**\\nTC : O(log(n)*n) =~ O(nlogn)\\nSC : O(1)\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(int len,string s,int n,int k){\\n        int t=0,f=0;\\n        for(int i=0;i<len;i++){\\n            if(s[i]==\\'T\\'){\\n                t+=1;\\n            }\\n            else{\\n                f+=1;\\n            }\\n        }\\n        \\n        // int t = min(nt,nf);\\n        if(t <= k or f<=k){\\n            return true;\\n        }\\n        \\n        for(int i=1;i+len<=n;i++){\\n            int j=i+len-1;\\n            t-=(s[i-1]==\\'T\\');\\n            f-=(s[i-1]==\\'F\\');\\n            \\n            t+=(s[j]==\\'T\\');\\n            f+=(s[j]==\\'F\\');\\n            \\n            if(t<=k or f <= k){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    //0 1 2 3 4 5 6\\n    int maxConsecutiveAnswers(string s, int k) {\\n        //binary Search + Fixed sized sliding window\\n        \\n        int n = s.size();\\n        int lo = 1;\\n        int hi = n;\\n        int ans = lo;\\n        //TTTTTTTTTTFFFFF\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(check(mid,s,n,k) == true){//true\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int maxConsecutiveAnswers(string s, int k) {\\n        //acquire till my k is invalid\\n        //release untill my k is valid\\n        \\n        \\n        //this is for T\\n        int n = s.size();\\n        int counter = 0;\\n        int j=0;\\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'F\\'){\\n                counter++;\\n            }\\n            while(j<i and counter > k){//i dont have any k remaining\\n                if(s[j]==\\'F\\'){\\n                    counter--;\\n                }\\n                j++;\\n            }\\n            \\n            if(counter <= k){\\n                int len = i-j+1;\\n                ans = max(ans,len);\\n            }\\n            \\n        }\\n        \\n        //this is for F\\n        j=0;\\n        int ans2 = 1;\\n        counter = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'T\\'){\\n                counter++;\\n            }\\n            while(j<i and counter > k){//i dont have any k remaining\\n                if(s[j]==\\'T\\'){\\n                    counter--;\\n                }\\n                j++;\\n            }\\n            \\n            if(counter <= k){\\n                int len = i-j+1;\\n                ans2 = max(ans2,len);\\n            }\\n            \\n        }\\n        \\n        return max(ans,ans2);\\n    }\\n};\\n\\n\\n/*\\n\\ni am allowed to change only k times\\n\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    #define pii pair<int,int>\\n    #define f first\\n    #define s second\\n    //returns idx which satisfies\\n    //TTTTTTFFFFFF\\n    int bs (int i,string &s,int k,int n,vector<pii> &ps){\\n        \\n        int idx = -1;\\n        \\n        int lo = i;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            int fv = i==0 ? ps[mid].s : ps[mid].s-ps[i-1].s;\\n            \\n            if(fv <= k){//true\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        \\n        if(idx == -1){\\n            return -1;\\n        }\\n        \\n        return idx;\\n    }\\n    \\n    int bs2 (int i,string &s,int k,int n,vector<pii> &ps){\\n        \\n        int idx = -1;\\n        \\n        int lo = i;\\n        int hi = n-1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            \\n            int tv = i==0 ? ps[mid].f : ps[mid].f-ps[i-1].f;\\n            \\n            if(tv <= k){//true\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        \\n        if(idx == -1){\\n            return -1;\\n        }\\n        \\n        return idx;\\n    }\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int n = s.size();\\n        int ans = 1;\\n        vector<pii> ps(n);//{T,F}\\n        \\n        if(s[0]==\\'T\\'){\\n            ps[0].f = 1;\\n            ps[0].s = 0;\\n        }\\n        else{\\n            ps[0].f = 0;\\n            ps[0].s = 1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'T\\'){\\n                ps[i].f = ps[i-1].f + 1;\\n                ps[i].s = ps[i-1].s;\\n            }\\n            else{\\n                ps[i].f = ps[i-1].f;\\n                ps[i].s = ps[i-1].s + 1;\\n            }\\n        }\\n        \\n        //on true\\n        for(int i=0;i<n;i++){\\n            \\n            int idx = bs(i,s,k,n,ps);\\n            \\n            if(idx != -1){//idx is valid\\n                int len = idx-i+1;\\n                ans = max(ans,len);\\n            }\\n        }\\n        \\n        \\n        //on false\\n        int ans2=1;\\n        for(int i=0;i<n;i++){\\n            \\n            int idx = bs2(i,s,k,n,ps);\\n            \\n            if(idx != -1){//idx is valid\\n                int len = idx-i+1;\\n                ans2 = max(ans2,len);\\n            }\\n        }\\n        \\n        return max(ans,ans2);\\n    }\\n};\\n\\n\\n/*\\n\\n\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(int len,string s,int n,int k){\\n        int t=0,f=0;\\n        for(int i=0;i<len;i++){\\n            if(s[i]==\\'T\\'){\\n                t+=1;\\n            }\\n            else{\\n                f+=1;\\n            }\\n        }\\n        \\n        // int t = min(nt,nf);\\n        if(t <= k or f<=k){\\n            return true;\\n        }\\n        \\n        for(int i=1;i+len<=n;i++){\\n            int j=i+len-1;\\n            t-=(s[i-1]==\\'T\\');\\n            f-=(s[i-1]==\\'F\\');\\n            \\n            t+=(s[j]==\\'T\\');\\n            f+=(s[j]==\\'F\\');\\n            \\n            if(t<=k or f <= k){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    //0 1 2 3 4 5 6\\n    int maxConsecutiveAnswers(string s, int k) {\\n        //binary Search + Fixed sized sliding window\\n        \\n        int n = s.size();\\n        int lo = 1;\\n        int hi = n;\\n        int ans = lo;\\n        //TTTTTTTTTTFFFFF\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(check(mid,s,n,k) == true){//true\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160320,
                "title": "java-binary-search-sliding-window-fixed",
                "content": "```\\n\\nclass Solution {\\n    \\n    // Binary Search + Sliding Window fixed\\n    \\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        \\n\\t\\tint start = 1 ;\\n\\t\\tint end = answerKey.length();\\n\\t\\tint max_length = 0 ;\\n\\t\\t\\n\\t\\twhile(start <= end) {\\n\\t\\t\\tint mid = start+(end-start)/2 ;\\n\\t\\t\\tif(isMax(answerKey , k , mid)) {\\n\\t\\t\\t\\tmax_length = mid ;\\n\\t\\t\\t\\tstart = mid+1 ;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tend = mid-1 ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn max_length ;\\n    }\\n\\t\\n\\tpublic boolean isMax(String answerKey , int k , int max_val) {\\n\\t\\t\\n\\t\\tint T_count = 0 ;\\n\\t\\tint F_count = 0 ;\\n\\t\\t\\n\\t\\tint i = 0 ;\\n\\t\\tint j = 0 ;\\n\\t\\t\\n\\t\\twhile(j < answerKey.length()) {\\n\\t\\t\\t\\n\\t\\t\\tif(answerKey.charAt(j) == \\'T\\') {\\n\\t\\t\\t\\tT_count++ ;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tF_count++ ;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(j-i+1 == max_val) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(Math.max(T_count, F_count)+k >= max_val) {\\n\\t\\t\\t\\t\\treturn true ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(answerKey.charAt(i) == \\'T\\') {\\n\\t\\t\\t\\t\\tT_count-- ;\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tF_count-- ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ti++ ;\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tj++ ;\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false ;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    // Binary Search + Sliding Window fixed\\n    \\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        \\n\\t\\tint start = 1 ;\\n\\t\\tint end = answerKey.length();\\n\\t\\tint max_length = 0 ;\\n\\t\\t\\n\\t\\twhile(start <= end) {\\n\\t\\t\\tint mid = start+(end-start)/2 ;\\n\\t\\t\\tif(isMax(answerKey , k , mid)) {\\n\\t\\t\\t\\tmax_length = mid ;\\n\\t\\t\\t\\tstart = mid+1 ;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tend = mid-1 ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn max_length ;\\n    }\\n\\t\\n\\tpublic boolean isMax(String answerKey , int k , int max_val) {\\n\\t\\t\\n\\t\\tint T_count = 0 ;\\n\\t\\tint F_count = 0 ;\\n\\t\\t\\n\\t\\tint i = 0 ;\\n\\t\\tint j = 0 ;\\n\\t\\t\\n\\t\\twhile(j < answerKey.length()) {\\n\\t\\t\\t\\n\\t\\t\\tif(answerKey.charAt(j) == \\'T\\') {\\n\\t\\t\\t\\tT_count++ ;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tF_count++ ;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(j-i+1 == max_val) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(Math.max(T_count, F_count)+k >= max_val) {\\n\\t\\t\\t\\t\\treturn true ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(answerKey.charAt(i) == \\'T\\') {\\n\\t\\t\\t\\t\\tT_count-- ;\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tF_count-- ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ti++ ;\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tj++ ;\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false ;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123233,
                "title": "c-tc-o-nlog-n-clean-and-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(string s,int target,int k,vector<int>&dp)\\n    {\\n        for(int i=target;i<=(int)s.size();i++)\\n        {\\n            int t=dp[i]-dp[i-target];\\n            int f=target-t;\\n            if(t<=k || f<=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maxConsecutiveAnswers(string a, int k) {\\n       int n=a.size();\\n        int st=0,en=n,mid,ans=0;\\n        vector<int>dp(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==\\'T\\') dp[i+1]=dp[i]+1;\\n            else dp[i+1]=dp[i];\\n        }\\n        while(st<=en)\\n        {\\n            mid=(st+en)/2;\\n            if(isValid(a,mid,k,dp))\\n            {\\n                ans=mid;\\n                st=mid+1;\\n            }\\n            else en=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(string s,int target,int k,vector<int>&dp)\\n    {\\n        for(int i=target;i<=(int)s.size();i++)\\n        {\\n            int t=dp[i]-dp[i-target];\\n            int f=target-t;\\n            if(t<=k || f<=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maxConsecutiveAnswers(string a, int k) {\\n       int n=a.size();\\n        int st=0,en=n,mid,ans=0;\\n        vector<int>dp(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==\\'T\\') dp[i+1]=dp[i]+1;\\n            else dp[i+1]=dp[i];\\n        }\\n        while(st<=en)\\n        {\\n            mid=(st+en)/2;\\n            if(isValid(a,mid,k,dp))\\n            {\\n                ans=mid;\\n                st=mid+1;\\n            }\\n            else en=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022245,
                "title": "python-sliding-window-93-fast-simple",
                "content": "```\\n\\t\\tleft = 0\\n        Tcount = 0\\n        Fcount = 0\\n        maxcount = 0\\n        for right in range(len(answerKey)):\\n                if answerKey[right] == \\'T\\':\\n                        Tcount += 1\\n                else:\\n                        Fcount += 1\\n                while Tcount > k and Fcount > k:\\n                        if answerKey[left] == \\'T\\':\\n                                Tcount-=1\\n                        else:\\n                                Fcount-=1\\n                        left+=1\\n                maxcount=max(maxcount,right-left+1)\\n        return maxcount",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n\\t\\tleft = 0\\n        Tcount = 0\\n        Fcount = 0\\n        maxcount = 0\\n        for right in range(len(answerKey)):\\n                if answerKey[right] == \\'T\\':\\n                        Tcount += 1\\n                else:\\n                        Fcount += 1\\n                while Tcount > k and Fcount > k:\\n                        if answerKey[left] == \\'T\\':\\n                                Tcount-=1\\n                        else:\\n                                Fcount-=1\\n                        left+=1\\n                maxcount=max(maxcount,right-left+1)\\n        return maxcount",
                "codeTag": "Unknown"
            },
            {
                "id": 1951750,
                "title": "weeb-does-python-c-sliding-window",
                "content": "There are 2 choices we can take\\n**1st choice: Apply sliding window, we use our k to change \"T\"\\n2nd choice: Apply sliding window, we use our k  to change \"F\"**\\n\\nfrom both choices, we take the maximum length, and return it as the result\\n\\n**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maxConsecutiveAnswers(self, string: str, k: int) -> int:\\n\\t\\t\\tresult = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\tcount1 = k\\n\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\tif count1 == 0 and string[i] == \"F\":\\n\\t\\t\\t\\t\\twhile string[j] != \"F\":\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\tcount1+=1 \\n\\t\\t\\t\\t\\tj+=1\\n\\n\\t\\t\\t\\tif string[i] == \"F\":\\n\\t\\t\\t\\t\\tif count1 > 0:\\n\\t\\t\\t\\t\\t\\tcount1-=1\\n\\n\\t\\t\\t\\tif i - j + 1 > result:\\n\\t\\t\\t\\t\\tresult = i - j + 1\\n\\n\\t\\t\\tj = 0\\n\\t\\t\\tcount2 = k\\n\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\tif count2 == 0 and string[i] == \"T\":\\n\\t\\t\\t\\t\\twhile string[j] != \"T\":\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\tcount2+=1 \\n\\t\\t\\t\\t\\tj+=1\\n\\n\\t\\t\\t\\tif string[i] == \"T\":\\n\\t\\t\\t\\t\\tif count2 > 0:\\n\\t\\t\\t\\t\\t\\tcount2-=1\\n\\n\\t\\t\\t\\tif i - j + 1 > result:\\n\\t\\t\\t\\t\\tresult = i - j + 1\\n\\n\\t\\t\\treturn result\\n\\n**C++** \\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxConsecutiveAnswers(string s, int k) {\\n\\t\\t\\tint result = 0, j = 0;\\n\\t\\t\\tint count1 = k;\\n\\n\\t\\t\\tfor (int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif (count1 == 0 && s[i] == \\'F\\'){\\n\\t\\t\\t\\t\\twhile (s[j] != \\'F\\') j++;\\n\\t\\t\\t\\t\\tcount1+=1;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (s[i] == \\'F\\'){\\n\\t\\t\\t\\t\\tif (count1 > 0) count1--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (i - j + 1 > result) result = i - j + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\tint count2 = k;\\n\\t\\t\\tcout << result;\\n\\t\\t\\tfor (int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif (count2 == 0 && s[i] == \\'T\\'){\\n\\t\\t\\t\\t\\twhile (s[j] != \\'T\\') j++;\\n\\t\\t\\t\\t\\tcount2+=1;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (s[i] == \\'T\\'){\\n\\t\\t\\t\\t\\tif (count2 > 0) count2--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (i - j + 1 > result) result = i - j + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n\\nAlright, take a break, you deserve it.\\nWatch some anime instead, check out **\\u30A2\\u30DE\\u30AC\\u30DFSS (Amagami SS)**\\n\\n# Episodes: (25 + 1 OVA + 1 Specia)[1st Season] + (13 + 6 Special)[2nd Season]\\n# Genres: Comedy, Romance, Slice of Life\\n\\nThere is another sequel, called **\\u30BB\\u30A4\\u30EC\\u30F3 (Seiren)**, but the characters are different as it follows another timeline.\\nNonetheless, watch this show, its pretty good, and if you like it, then try Seiren.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n\\t\\tdef maxConsecutiveAnswers(self, string: str, k: int) -> int:\\n\\t\\t\\tresult = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\tcount1 = k\\n\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\tif count1 == 0 and string[i] == \"F\":\\n\\t\\t\\t\\t\\twhile string[j] != \"F\":\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\tcount1+=1 \\n\\t\\t\\t\\t\\tj+=1\\n\\n\\t\\t\\t\\tif string[i] == \"F\":\\n\\t\\t\\t\\t\\tif count1 > 0:\\n\\t\\t\\t\\t\\t\\tcount1-=1\\n\\n\\t\\t\\t\\tif i - j + 1 > result:\\n\\t\\t\\t\\t\\tresult = i - j + 1\\n\\n\\t\\t\\tj = 0\\n\\t\\t\\tcount2 = k\\n\\t\\t\\tfor i in range(len(string)):\\n\\t\\t\\t\\tif count2 == 0 and string[i] == \"T\":\\n\\t\\t\\t\\t\\twhile string[j] != \"T\":\\n\\t\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\t\\tcount2+=1 \\n\\t\\t\\t\\t\\tj+=1\\n\\n\\t\\t\\t\\tif string[i] == \"T\":\\n\\t\\t\\t\\t\\tif count2 > 0:\\n\\t\\t\\t\\t\\t\\tcount2-=1\\n\\n\\t\\t\\t\\tif i - j + 1 > result:\\n\\t\\t\\t\\t\\tresult = i - j + 1\\n\\n\\t\\t\\treturn result\\n\\n**C++** \\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxConsecutiveAnswers(string s, int k) {\\n\\t\\t\\tint result = 0, j = 0;\\n\\t\\t\\tint count1 = k;\\n\\n\\t\\t\\tfor (int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif (count1 == 0 && s[i] == \\'F\\'){\\n\\t\\t\\t\\t\\twhile (s[j] != \\'F\\') j++;\\n\\t\\t\\t\\t\\tcount1+=1;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1689158,
                "title": "maximize-the-confusion-of-an-exam-c-sliding-windows-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int ans = 0, T = 0, F = 0;\\n        \\n        for(int i = 0, j = 0; j < s.size(); j++){\\n            s[j] == \\'T\\' ? T++ : F++;\\n            \\n            while(j - i + 1 - max(T, F) > k){\\n                s[i++] == \\'T\\' ? T-- : F--;\\n            }\\n            \\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int ans = 0, T = 0, F = 0;\\n        \\n        for(int i = 0, j = 0; j < s.size(); j++){\\n            s[j] == \\'T\\' ? T++ : F++;\\n            \\n            while(j - i + 1 - max(T, F) > k){\\n                s[i++] == \\'T\\' ? T-- : F--;\\n            }\\n            \\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504297,
                "title": "c-sliding-window-evaluate-both-true-and-false",
                "content": "```\\nint solve(string str,int k,bool find){\\n    int i=0; int j=0;\\n    int ans=0;\\n    while(j<(int)str.length()){\\n        if(str[j]==\\'T\\' && find){\\n            ans=max(ans,j-i+1);\\n            j++;\\n        } else if(str[j]==\\'F\\' && !find){\\n            ans=max(ans,j-i+1);\\n            j++;\\n        } else{\\n            if(find){\\n                if(k==0){\\n                    while(k==0){\\n                        if(str[i]==\\'F\\')\\n                            k++;\\n                        i++;\\n                    }\\n                }\\n                k--;\\n                ans=max(ans,j-i+1);\\n                j++;\\n            } else{\\n                if(k==0){\\n                    while(k==0){\\n                        if(str[i]==\\'T\\')\\n                            k++;\\n                        i++;\\n                    }\\n                }\\n                k--;\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string str, int k) {\\n        return max(solve(str,k,true),solve(str,k,false));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(string str,int k,bool find){\\n    int i=0; int j=0;\\n    int ans=0;\\n    while(j<(int)str.length()){\\n        if(str[j]==\\'T\\' && find){\\n            ans=max(ans,j-i+1);\\n            j++;\\n        } else if(str[j]==\\'F\\' && !find){\\n            ans=max(ans,j-i+1);\\n            j++;\\n        } else{\\n            if(find){\\n                if(k==0){\\n                    while(k==0){\\n                        if(str[i]==\\'F\\')\\n                            k++;\\n                        i++;\\n                    }\\n                }\\n                k--;\\n                ans=max(ans,j-i+1);\\n                j++;\\n            } else{\\n                if(k==0){\\n                    while(k==0){\\n                        if(str[i]==\\'T\\')\\n                            k++;\\n                        i++;\\n                    }\\n                }\\n                k--;\\n                ans=max(ans,j-i+1);\\n                j++;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string str, int k) {\\n        return max(solve(str,k,true),solve(str,k,false));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500555,
                "title": "c-24ms-100-simple-easy-small",
                "content": "Runtime: 24 ms, faster than 100.00% of C++ online submissions for Maximize the Confusion of an Exam.\\nMemory Usage: 10 MB, less than 100.00% of C++ online submissions for Maximize the Confusion of an Exam.\\n```\\nclass Solution {\\npublic:\\n  int helper(string &answerKey, int k, char ch){\\n    int n = answerKey.size(), m = 0, l = -1, r = 0, ans = 0;\\n    \\n    while(r < n){\\n      if(answerKey[r] == ch) m++;\\n      while(m > k) if(answerKey[++l] == ch) m--;\\n      ans = max<int>(ans, r++ - l);      \\n    }\\n    \\n    return ans;\\n  }\\n  \\n  int maxConsecutiveAnswers(string answerKey, int k) {\\n    return max(helper(answerKey, k, \\'T\\'), helper(answerKey, k, \\'F\\'));    \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int helper(string &answerKey, int k, char ch){\\n    int n = answerKey.size(), m = 0, l = -1, r = 0, ans = 0;\\n    \\n    while(r < n){\\n      if(answerKey[r] == ch) m++;\\n      while(m > k) if(answerKey[++l] == ch) m--;\\n      ans = max<int>(ans, r++ - l);      \\n    }\\n    \\n    return ans;\\n  }\\n  \\n  int maxConsecutiveAnswers(string answerKey, int k) {\\n    return max(helper(answerKey, k, \\'T\\'), helper(answerKey, k, \\'F\\'));    \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499282,
                "title": "easy-sliding-window-solution",
                "content": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n    return Math.max(slide(answerKey,\\'T\\',k) , slide(answerKey,\\'F\\',k));    \\n    }\\n    public int slide(String str,char ch,int k){\\n        int count=0;\\n        int l=0;\\n        int max=0;\\n        \\n        for(int i=0;i<str.length();i++){\\n            if(str.charAt(i)!=ch) count++;\\n            while(count>k){\\n                if(str.charAt(l)!=ch) count--;\\n                l++;\\n            }\\n            max=Math.max(max,(i-l)+1);\\n        }\\n        return max;\\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n    return Math.max(slide(answerKey,\\'T\\',k) , slide(answerKey,\\'F\\',k));    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1499260,
                "title": "simple-and-easy-to-understand-in-o-n-sliding-window",
                "content": "here Ihave store the index value of true and false in array initially have store index as -1 then  append the array. if size of array where we store index of truth and false value -1 is less than k then we can say size of string is max size.\\nthen i have traversed as sliding window..\\n**c++ **\\n```\\n\\n```simple and easy to understand o(n) \\nclass Solution {\\npublic:\\n        int maxConsecutiveAnswers(string s, int k) {\\n             vector<int>t,f;\\n        t.push_back(-1);\\n        f.push_back(-1);\\n        for(int i=0;i<s.size();i++)\\n1.         {\\n            if(s[i]==\\'T\\')\\n            {\\n                t.push_back(i);\\n            }\\n            else{\\n              f.push_back(i);\\n            }\\n        }\\n        if(t.size()-1<=k||f.size()-1<=k) //if needed swap is less than k;\\n        {\\n           return s.size();\\n        }\\n        t.push_back(s.size());\\n        f.push_back(s.size());\\n        int ans=0;\\n        for(int i=1;i<t.size()-k;i++)\\n        {\\n            ans=max(ans,t[i+k]-t[i-1]-1);//t[i+k]-t[i-1]-1 is the length of continuous string after changes in k character..\\n        }\\n        //cout<<f.size();\\n        for(int i=1;i<f.size()-k;i++)\\n        {\\n            ans=max(ans,f[i+k]-f[i-1]-1);\\n        }\\n       return  ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499153,
                "title": "c-very-easy-to-understand-using-sliding-window",
                "content": "```\\nint solve(string s,char ch,int k)\\n    {\\n        int i=0;\\n        int count=0;\\n        int ans=0;\\n        for(int j=0; j<s.size(); j++)\\n        {\\n            if(ch == s[j])\\n                count++;\\n            while(count > k)\\n            {\\n                if(s[i++] == ch)\\n                    count--;\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int option1=solve(answerKey,\\'T\\',k);\\n        int option2=solve(answerKey,\\'F\\',k);\\n        return max(option1,option2);        \\n    }",
                "solutionTags": [],
                "code": "```\\nint solve(string s,char ch,int k)\\n    {\\n        int i=0;\\n        int count=0;\\n        int ans=0;\\n        for(int j=0; j<s.size(); j++)\\n        {\\n            if(ch == s[j])\\n                count++;\\n            while(count > k)\\n            {\\n                if(s[i++] == ch)\\n                    count--;\\n            }\\n            ans=max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n    \\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int option1=solve(answerKey,\\'T\\',k);\\n        int option2=solve(answerKey,\\'F\\',k);\\n        return max(option1,option2);        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1499126,
                "title": "easy-o-n-solution-c",
                "content": "class Solution {\\npublic:\\n    int flipFalse(string key,int k,int n){\\n    int fc = 0;\\n        int ans=0;\\n       int i=0;\\n        int j=0;\\n    while (i < n && j<n)\\n    {\\n        if(fc<=k){\\n             if(key[j]==\\'F\\') fc++;\\n            j++;\\n        }\\n        if(fc>k){\\n            if(key[i]==\\'F\\'){\\n                fc--;\\n            }\\n            i++;\\n        }\\n        if(fc<=k){\\n            ans=max(ans,(j-i));\\n        }  \\n    }\\n        return ans;    \\n}\\n      int flipTrue(string key,int k,int n){\\n    int tc = 0;\\n        int ans=0;\\n       int i=0;\\n        int j=0;\\n    while (i < n && j<n)\\n    {\\n        if(tc<=k){\\n             if(key[j]==\\'T\\') tc++;\\n            j++;\\n        }\\n        if(tc>k){\\n            if(key[i]==\\'T\\'){\\n                tc--;\\n            }\\n            i++;\\n        }\\n        if(tc<=k){\\n            ans=max(ans,(j-i));\\n        }  \\n    }\\n        return ans;    \\n}\\n    \\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.length();\\n        int x=flipFalse(answerKey,k,n);\\n        int y=flipTrue(answerKey,k,n);\\n        return max(x,y);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int flipFalse(string key,int k,int n){\\n    int fc = 0;\\n        int ans=0;\\n       int i=0;\\n        int j=0;\\n    while (i < n && j<n)\\n    {\\n        if(fc<=k){\\n             if(key[j]==\\'F\\') fc++;\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1499056,
                "title": "using-binary-search",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string key, int k) {\\n        int n = key.length();\\n        vector<int>cntT(n,0);\\n        vector<int>cntF(n,0);\\n        for(int i = 0;i<n;i++){\\n            if(key[i] == \\'T\\'){\\n               cntT[i]++;\\n            }else{\\n                cntF[i]++;\\n            }\\n            if(i!=0){\\n               cntT[i] += cntT[i-1];\\n               cntF[i] += cntF[i-1];\\n            }\\n        }\\n        \\n        int l = 0;int r = n+1;\\n        while(l+1 < r){\\n            int m = (l+r)/2;\\n            bool check = false;\\n            for(int i = m-1; i < n ; i++){\\n                if(i == m-1){\\n                    if(cntF[i] <= k){\\n                        check = true;\\n                    }\\n                    if(cntT[i] <= k){\\n                        check = true;\\n                    }\\n                }else{\\n                     if(cntF[i] - cntF[i - m] <= k){\\n                        check = true;\\n                    }\\n                    if(cntT[i] - cntT[i-m] <= k){\\n                        check = true;\\n                    }\\n                }\\n            }\\n            \\n            if(check){\\n                l = m;\\n            }else{\\n                r = m;\\n            }\\n        }\\n        return l;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string key, int k) {\\n        int n = key.length();\\n        vector<int>cntT(n,0);\\n        vector<int>cntF(n,0);\\n        for(int i = 0;i<n;i++){\\n            if(key[i] == \\'T\\'){\\n               cntT[i]++;\\n            }else{\\n                cntF[i]++;\\n            }\\n            if(i!=0){\\n               cntT[i] += cntT[i-1];\\n               cntF[i] += cntF[i-1];\\n            }\\n        }\\n        \\n        int l = 0;int r = n+1;\\n        while(l+1 < r){\\n            int m = (l+r)/2;\\n            bool check = false;\\n            for(int i = m-1; i < n ; i++){\\n                if(i == m-1){\\n                    if(cntF[i] <= k){\\n                        check = true;\\n                    }\\n                    if(cntT[i] <= k){\\n                        check = true;\\n                    }\\n                }else{\\n                     if(cntF[i] - cntF[i - m] <= k){\\n                        check = true;\\n                    }\\n                    if(cntT[i] - cntT[i-m] <= k){\\n                        check = true;\\n                    }\\n                }\\n            }\\n            \\n            if(check){\\n                l = m;\\n            }else{\\n                r = m;\\n            }\\n        }\\n        return l;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990931,
                "title": "simple-sliding-window-faster-than-most",
                "content": "class Solution {\\npublic:\\n\\n    int maxConsecutiveAnswers(string str, int k) {\\n        int n= str.size();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        int ans=0;\\n        \\n        int tc=0;\\n        int fc=0;\\n        \\n        while(j<n)\\n        {\\n            if(str[j]==\\'T\\')\\n                tc++;\\n            else\\n                fc++;\\n            \\n            while(min(tc,fc)>k)\\n            {\\n                if(str[i]==\\'T\\')\\n                    tc--;\\n                else\\n                    fc--;\\n                \\n                i++;\\n            }\\n            ans= max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxConsecutiveAnswers(string str, int k) {\\n        int n= str.size();\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        int ans=0;\\n        \\n        int tc=0;\\n        int fc=0;\\n        \\n        while(j<n)\\n        {\\n            if(str[j]==\\'T\\')\\n                tc++;\\n            else\\n                fc++;\\n            \\n            while(min(tc,fc)>k)\\n            {\\n                if(str[i]==\\'T\\')\\n                    tc--;\\n                else\\n                    fc--;\\n                \\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3818912,
                "title": "beats-90-cpp-sol",
                "content": "# Approach\\nApproach is written in code in the form of comments just go through the comments once and i am sure u will definately understand the logic \\n\\n# **Pls Upvote me If you Found Helpful !**\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string nums, int k) {\\n        // we will return the maximum of the \\n        // i. finding maximum T with atmost k F\\n        // ii. finding maximum F with atmost k T\\n\\n        // solving ist part, finding maximum T with atmost k F\\n        int front = 0;\\n        int back = 0;\\n        int count = 0;\\n        int ans = 0;\\n        while(front < nums.size()){\\n            if(nums[front] == \\'F\\'){\\n                count++;\\n            }\\n\\n            while(count > k){\\n                if(nums[back] == \\'F\\'){\\n                    count--;\\n                }\\n                back++;\\n            }\\n            ans = max(ans, front-back+1);\\n            front++;\\n        }\\n\\n        front = 0;\\n        back = 0;\\n        count = 0;\\n        while(front < nums.size()){\\n            if(nums[front] == \\'T\\'){\\n                count++;\\n            }\\n\\n            while(count > k){\\n                if(nums[back] == \\'T\\'){\\n                    count--;\\n                }\\n                back++;\\n            }\\n            ans = max(ans, front-back+1);\\n            front++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string nums, int k) {\\n        // we will return the maximum of the \\n        // i. finding maximum T with atmost k F\\n        // ii. finding maximum F with atmost k T\\n\\n        // solving ist part, finding maximum T with atmost k F\\n        int front = 0;\\n        int back = 0;\\n        int count = 0;\\n        int ans = 0;\\n        while(front < nums.size()){\\n            if(nums[front] == \\'F\\'){\\n                count++;\\n            }\\n\\n            while(count > k){\\n                if(nums[back] == \\'F\\'){\\n                    count--;\\n                }\\n                back++;\\n            }\\n            ans = max(ans, front-back+1);\\n            front++;\\n        }\\n\\n        front = 0;\\n        back = 0;\\n        count = 0;\\n        while(front < nums.size()){\\n            if(nums[front] == \\'T\\'){\\n                count++;\\n            }\\n\\n            while(count > k){\\n                if(nums[back] == \\'T\\'){\\n                    count--;\\n                }\\n                back++;\\n            }\\n            ans = max(ans, front-back+1);\\n            front++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791837,
                "title": "c-using-sliding-window-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int res = 0, start = 0, end = 0;\\n        int trueC = 0, falseC = 0;\\n        \\n        while(end < answerKey.length()){\\n            if(answerKey[end] == \\'T\\'){\\n                trueC++;\\n            }else{\\n                falseC++;\\n            }\\n            \\n            while((end-start+1)-max(trueC, falseC) > k){\\n                if(answerKey[start] == \\'T\\'){\\n                    trueC--;\\n                }else{\\n                    falseC--;\\n                }\\n                start++;\\n            }\\n            \\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int res = 0, start = 0, end = 0;\\n        int trueC = 0, falseC = 0;\\n        \\n        while(end < answerKey.length()){\\n            if(answerKey[end] == \\'T\\'){\\n                trueC++;\\n            }else{\\n                falseC++;\\n            }\\n            \\n            while((end-start+1)-max(trueC, falseC) > k){\\n                if(answerKey[start] == \\'T\\'){\\n                    trueC--;\\n                }else{\\n                    falseC--;\\n                }\\n                start++;\\n            }\\n            \\n            res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744087,
                "title": "c-easy-to-understand-sliding-window",
                "content": "# Approach\\n1. Maintain counts for number of true(s) and false(s) in the current window.\\n2. Keep increasing the length of the window until the minimum of the two counts exceeds k.\\n3. When it does, decrease the length of the window from the left side and keep updating counts and check if the minimum of the two counts exceeds k.\\n4. Update the maxLen at the end of the loop.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int countT =0;\\n        int countF =0;\\n        int maxLen =0;\\n        int i=0, j=0;\\n        while(j<answerKey.size()){\\n            if(answerKey[j]==\\'T\\'){\\n                countT++;\\n            }\\n            else{\\n                countF++;\\n            }\\n            int diff = min(countT, countF);\\n            while(diff>k ){\\n                if(answerKey[i]==\\'T\\'){\\n                    countT--;\\n                }\\n                else{\\n                    countF--;\\n                }\\n                diff = min(countT, countF);\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n            j++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int countT =0;\\n        int countF =0;\\n        int maxLen =0;\\n        int i=0, j=0;\\n        while(j<answerKey.size()){\\n            if(answerKey[j]==\\'T\\'){\\n                countT++;\\n            }\\n            else{\\n                countF++;\\n            }\\n            int diff = min(countT, countF);\\n            while(diff>k ){\\n                if(answerKey[i]==\\'T\\'){\\n                    countT--;\\n                }\\n                else{\\n                    countF--;\\n                }\\n                diff = min(countT, countF);\\n                i++;\\n            }\\n            maxLen = max(maxLen, j-i+1);\\n            j++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739352,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, answerKey, k):\\n        start=0\\n        end=0\\n        length=0\\n        count_of_true=0\\n        count_of_false=0\\n\\n        while end<len(answerKey):\\n            if answerKey[end]==\\'T\\':\\n                count_of_true+=1 \\n            else:\\n                count_of_false+=1 \\n            \\n            \\n            while(min(count_of_false,count_of_true)>k):\\n                if answerKey[start]==\\'T\\':\\n                    count_of_true-=1 \\n                else:\\n                    count_of_false-=1 \\n                start+=1 \\n            \\n            end+=1 \\n            length =max(length,count_of_true+count_of_false)\\n\\n        return(length)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, answerKey, k):\\n        start=0\\n        end=0\\n        length=0\\n        count_of_true=0\\n        count_of_false=0\\n\\n        while end<len(answerKey):\\n            if answerKey[end]==\\'T\\':\\n                count_of_true+=1 \\n            else:\\n                count_of_false+=1 \\n            \\n            \\n            while(min(count_of_false,count_of_true)>k):\\n                if answerKey[start]==\\'T\\':\\n                    count_of_true-=1 \\n                else:\\n                    count_of_false-=1 \\n                start+=1 \\n            \\n            end+=1 \\n            length =max(length,count_of_true+count_of_false)\\n\\n        return(length)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734014,
                "title": "pratice-sols",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLike a clown, I first attempted to do a dp solution. Spend a whole lot of time, and it didn\\'t even fully work. I looked at the solutions, then realized a sliding window appraoch works fine, because we only need to know the longest sequence we can make by changing k items, not which items to change. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep a start and end pointer (i,j). Keep track of T count and F count. Iterate the end pointer j, adding whatever is at that index to the count. When the count of T or F is less than k, we have a window which can be made into entirely T or F using k or less swaps. Otherwise, we have to decrement the window by removing the item at i from the count and moving i forward until the window is good again. We keep track of the largest value obtained and return it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) because we go through each item once with end, and at most once with start pointer\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) extra space because we only store the two counter variables for T/F, the index i var, and the max_len variable\\n\\n# Code\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n\\n        #indices\\n        i = 0\\n\\n        #dict for T/F count\\n        count = {\\'T\\':0, \\'F\\':0}\\n\\n        max_len = 0\\n\\n        for j in range(len(answerKey)):\\n            count[answerKey[j]] += 1\\n            while not (count[\\'T\\'] <= k or count[\\'F\\'] <= k):\\n                count[answerKey[i]] -= 1\\n                i += 1\\n\\n            max_len = max(max_len, j-i+1)\\n        \\n        return max_len\\n            \\n\\n\\n            \\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n\\n        #indices\\n        i = 0\\n\\n        #dict for T/F count\\n        count = {\\'T\\':0, \\'F\\':0}\\n\\n        max_len = 0\\n\\n        for j in range(len(answerKey)):\\n            count[answerKey[j]] += 1\\n            while not (count[\\'T\\'] <= k or count[\\'F\\'] <= k):\\n                count[answerKey[i]] -= 1\\n                i += 1\\n\\n            max_len = max(max_len, j-i+1)\\n        \\n        return max_len\\n            \\n\\n\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733886,
                "title": "java-100-faster-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int maxf = 0, i = 0, n = answerKey.length(), count[] = new int[26];\\n        for(int j = 0; j < n; j ++) {\\n            maxf = Math.max(maxf, ++ count[answerKey.charAt(j) - \\'A\\']);\\n            if(j - i + 1 > maxf + k)\\n            -- count[answerKey.charAt(i ++) - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int maxf = 0, i = 0, n = answerKey.length(), count[] = new int[26];\\n        for(int j = 0; j < n; j ++) {\\n            maxf = Math.max(maxf, ++ count[answerKey.charAt(j) - \\'A\\']);\\n            if(j - i + 1 > maxf + k)\\n            -- count[answerKey.charAt(i ++) - \\'A\\'];\\n        }\\n        return n - i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733484,
                "title": "simple-c-solution-sliding-window-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int checkMaxconsecutives(string answerKey, int k, char ch)\\n    {\\n        int start=0, count=0, maxi=0;\\n        for(int i=0; i<answerKey.length(); i++)\\n        {\\n            if(answerKey[i]!=ch)\\n                count++;\\n            while(count>k)\\n            {\\n                if(answerKey[start]!=ch)\\n                count--;\\n\\n                start++;\\n            }\\n            int length=(i-start+1);\\n            if(length>maxi)\\n            maxi=length;   \\n        }\\n        return maxi;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n\\n        int maxi1= checkMaxconsecutives(answerKey, k, \\'T\\');\\n        int maxi2= checkMaxconsecutives(answerKey, k, \\'F\\');\\n\\n        if(maxi1>=maxi2)\\n        return maxi1;\\n\\n        return maxi2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int checkMaxconsecutives(string answerKey, int k, char ch)\\n    {\\n        int start=0, count=0, maxi=0;\\n        for(int i=0; i<answerKey.length(); i++)\\n        {\\n            if(answerKey[i]!=ch)\\n                count++;\\n            while(count>k)\\n            {\\n                if(answerKey[start]!=ch)\\n                count--;\\n\\n                start++;\\n            }\\n            int length=(i-start+1);\\n            if(length>maxi)\\n            maxi=length;   \\n        }\\n        return maxi;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n\\n        int maxi1= checkMaxconsecutives(answerKey, k, \\'T\\');\\n        int maxi2= checkMaxconsecutives(answerKey, k, \\'F\\');\\n\\n        if(maxi1>=maxi2)\\n        return maxi1;\\n\\n        return maxi2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733447,
                "title": "python-easy-solution-using-collections",
                "content": "\\n# Code\\n```\\nimport collections\\n\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n\\n        max_freq = i = 0\\n        char_count = collections.Counter()\\n\\n        for j in range(len(answerKey)):\\n            char_count[answerKey[j]] += 1\\n            max_freq = max(max_freq, char_count[answerKey[j]])\\n\\n            if j - i + 1 > max_freq + k:\\n                char_count[answerKey[i]] -= 1\\n                i += 1\\n        return len(answerKey) - i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n\\n        max_freq = i = 0\\n        char_count = collections.Counter()\\n\\n        for j in range(len(answerKey)):\\n            char_count[answerKey[j]] += 1\\n            max_freq = max(max_freq, char_count[answerKey[j]])\\n\\n            if j - i + 1 > max_freq + k:\\n                char_count[answerKey[i]] -= 1\\n                i += 1\\n        return len(answerKey) - i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733379,
                "title": "simple-c-solution-self-explanatory-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.size();\\n        int maxFreq=0;\\n        int windowStart=0;\\n        unordered_map<char,int> charFreq;\\n        for(int windowEnd = 0; windowEnd<n; windowEnd++){\\n            char rightChar = answerKey[windowEnd];\\n            charFreq[rightChar]++;\\n            maxFreq = max(maxFreq,charFreq[rightChar]);\\n\\n            if(windowEnd-windowStart+1 > maxFreq+k){\\n                int leftChar = answerKey[windowStart];\\n                charFreq[leftChar]--;\\n                windowStart++;\\n            }\\n        }\\n\\n        return n - windowStart;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.size();\\n        int maxFreq=0;\\n        int windowStart=0;\\n        unordered_map<char,int> charFreq;\\n        for(int windowEnd = 0; windowEnd<n; windowEnd++){\\n            char rightChar = answerKey[windowEnd];\\n            charFreq[rightChar]++;\\n            maxFreq = max(maxFreq,charFreq[rightChar]);\\n\\n            if(windowEnd-windowStart+1 > maxFreq+k){\\n                int leftChar = answerKey[windowStart];\\n                charFreq[leftChar]--;\\n                windowStart++;\\n            }\\n        }\\n\\n        return n - windowStart;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733343,
                "title": "clean-c-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int max_confusion(char target, int k, string& answerKey) {\\n        int other = 0, n = answerKey.size(), confusion = 0;\\n        for (int l = 0, r = 0; r < n; r++) {\\n            other += answerKey[r] != target;\\n\\n            while (other > k) {\\n                other -= answerKey[l++] != target;\\n            }\\n            \\n            confusion = max(confusion, r - l + 1);\\n        }\\n        return confusion;\\n    }\\n    \\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(max_confusion(\\'T\\', k, answerKey), max_confusion(\\'F\\', k, answerKey));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_confusion(char target, int k, string& answerKey) {\\n        int other = 0, n = answerKey.size(), confusion = 0;\\n        for (int l = 0, r = 0; r < n; r++) {\\n            other += answerKey[r] != target;\\n\\n            while (other > k) {\\n                other -= answerKey[l++] != target;\\n            }\\n            \\n            confusion = max(confusion, r - l + 1);\\n        }\\n        return confusion;\\n    }\\n    \\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(max_confusion(\\'T\\', k, answerKey), max_confusion(\\'F\\', k, answerKey));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733245,
                "title": "sliding-window-c",
                "content": "```\\nclass Solution {\\n    int solve(char c, string s, int k) {\\n        int n = s.size(), ans = 0, i = 0;\\n\\n        for(int j=0; j<n; j++) {\\n            if(s[j] != c) k--;\\n\\n            while(k < 0) {\\n                if(s[i] != c) k++;\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(solve(\\'T\\', answerKey, k), solve(\\'F\\', answerKey, k));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    int solve(char c, string s, int k) {\\n        int n = s.size(), ans = 0, i = 0;\\n\\n        for(int j=0; j<n; j++) {\\n            if(s[j] != c) k--;\\n\\n            while(k < 0) {\\n                if(s[i] != c) k++;\\n                i++;\\n            }\\n            ans = max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(solve(\\'T\\', answerKey, k), solve(\\'F\\', answerKey, k));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732586,
                "title": "sliding-window-detailed-explanation-c",
                "content": "# Similar problem to form the basics : \\nQuestion : [https://leetcode.com/problems/max-consecutive-ones-iii/description/]()\\n\\nApproach : [https://leetcode.com/problems/max-consecutive-ones-iii/solutions/3732301/step-by-step-commented-c-code-easily-understandable/]()\\n\\n# Approach\\nThe solution uses two helper functions: `solve` and `maxConsecutiveAnswers`. \\n\\nThe \\'solve\\' function takes the answer key, the maximum number of allowed changes (k), and the answer value (\\'T\\' or \\'F\\') as inputs. It initializes variables to keep track of the start and end indices of the current window, the count of consecutive answers, and the maximum length encountered so far. The function uses two nested while loops to expand the window and adjust it according to the given constraints.\\n\\nThe \\'maxConsecutiveAnswers\\' function utilizes the \\'solve\\' function twice, once for \\'T\\' and once for \\'F\\', and returns the maximum value between the two results.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Helper function to find the longest substring with at most \\'key\\' occurrences of character \\'c\\'\\n    int solve(string s, int key, char c) {\\n        int start = 0, end = 0; // Pointers to track the current window\\n        int count = 0; // Count of occurrences of character \\'c\\' within the window\\n        int ans = 0; // Length of the longest substring\\n        int size = s.size(); // Size of the input string \\'s\\'\\n\\n        while (end < size) {\\n            // Expand the window while count is within the limit\\n            while (end < size && count <= key) {\\n                if (s[end] == c)\\n                    count++; // Increment count if character \\'c\\' is encountered\\n                if (count <= key)\\n                    ans = max(ans, end - start + 1); // Update ans if current window is longer\\n                end++; // Move the end pointer to the right\\n            }\\n\\n            // Shrink the window if count exceeds the limit\\n            while (start <= end && count > key) {\\n                if (s[start] == c)\\n                    count--; // Decrement count if character \\'c\\' is encountered\\n                start++; // Move the start pointer to the right\\n            }\\n        }\\n\\n        return ans; // Return the length of the longest substring with at most \\'key\\' occurrences of \\'c\\'\\n    }\\n\\n    // Function to find the maximum length of consecutive \\'T\\' or \\'F\\' answers\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // Find the longest substring of consecutive \\'T\\' with at most \\'k\\' flips to \\'F\\'\\n        int ans1 = solve(answerKey, k, \\'T\\');\\n        // Find the longest substring of consecutive \\'F\\' with at most \\'k\\' flips to \\'T\\'\\n        int ans2 = solve(answerKey, k, \\'F\\');\\n        // Return the maximum length among the two cases\\n        return max(ans1, ans2);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to find the longest substring with at most \\'key\\' occurrences of character \\'c\\'\\n    int solve(string s, int key, char c) {\\n        int start = 0, end = 0; // Pointers to track the current window\\n        int count = 0; // Count of occurrences of character \\'c\\' within the window\\n        int ans = 0; // Length of the longest substring\\n        int size = s.size(); // Size of the input string \\'s\\'\\n\\n        while (end < size) {\\n            // Expand the window while count is within the limit\\n            while (end < size && count <= key) {\\n                if (s[end] == c)\\n                    count++; // Increment count if character \\'c\\' is encountered\\n                if (count <= key)\\n                    ans = max(ans, end - start + 1); // Update ans if current window is longer\\n                end++; // Move the end pointer to the right\\n            }\\n\\n            // Shrink the window if count exceeds the limit\\n            while (start <= end && count > key) {\\n                if (s[start] == c)\\n                    count--; // Decrement count if character \\'c\\' is encountered\\n                start++; // Move the start pointer to the right\\n            }\\n        }\\n\\n        return ans; // Return the length of the longest substring with at most \\'key\\' occurrences of \\'c\\'\\n    }\\n\\n    // Function to find the maximum length of consecutive \\'T\\' or \\'F\\' answers\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // Find the longest substring of consecutive \\'T\\' with at most \\'k\\' flips to \\'F\\'\\n        int ans1 = solve(answerKey, k, \\'T\\');\\n        // Find the longest substring of consecutive \\'F\\' with at most \\'k\\' flips to \\'T\\'\\n        int ans2 = solve(answerKey, k, \\'F\\');\\n        // Return the maximum length among the two cases\\n        return max(ans1, ans2);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732426,
                "title": "c-super-easy-clean-sliding-window-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int largestWindow(string& s, int k){\\n        int low = 0;\\n        int high = 0;\\n        int maxi = 1;\\n        int n = s.size();\\n        int cntT = 0, cntF = 0;\\n        while(high < n){\\n            if(s[high] == \\'T\\') cntT++;\\n            else cntF++;\\n\\n            while(min(cntT,cntF) > k){\\n                if(s[low] == \\'T\\') cntT--;\\n                else cntF--;\\n                low++;\\n            }\\n            maxi = max(maxi,high-low+1);\\n            high++;\\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        \\n        return largestWindow(answerKey,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int largestWindow(string& s, int k){\\n        int low = 0;\\n        int high = 0;\\n        int maxi = 1;\\n        int n = s.size();\\n        int cntT = 0, cntF = 0;\\n        while(high < n){\\n            if(s[high] == \\'T\\') cntT++;\\n            else cntF++;\\n\\n            while(min(cntT,cntF) > k){\\n                if(s[low] == \\'T\\') cntT--;\\n                else cntF--;\\n                low++;\\n            }\\n            maxi = max(maxi,high-low+1);\\n            high++;\\n        }\\n        return maxi;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        \\n        return largestWindow(answerKey,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732334,
                "title": "sliding-window",
                "content": "# Approach: Sliding Window \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int len = answerKey.length(), lptr = 0, ans = 0, cnt = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (answerKey.charAt(i) == \\'F\\') {\\n                cnt++;\\n            }\\n            while (cnt > k) {\\n                if (answerKey.charAt(lptr) == \\'F\\') {\\n                    cnt--;\\n                }\\n                lptr++;\\n            }\\n            ans = Math.max(ans, i - lptr + 1);\\n        }\\n        lptr = 0;\\n        cnt = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (answerKey.charAt(i) == \\'T\\') {\\n                cnt++;\\n            }\\n            while (cnt > k) {\\n                if (answerKey.charAt(lptr) == \\'T\\') {\\n                    cnt--;\\n                }\\n                lptr++;\\n            }\\n            ans = Math.max(ans, i - lptr + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int len = answerKey.length(), lptr = 0, ans = 0, cnt = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (answerKey.charAt(i) == \\'F\\') {\\n                cnt++;\\n            }\\n            while (cnt > k) {\\n                if (answerKey.charAt(lptr) == \\'F\\') {\\n                    cnt--;\\n                }\\n                lptr++;\\n            }\\n            ans = Math.max(ans, i - lptr + 1);\\n        }\\n        lptr = 0;\\n        cnt = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (answerKey.charAt(i) == \\'T\\') {\\n                cnt++;\\n            }\\n            while (cnt > k) {\\n                if (answerKey.charAt(lptr) == \\'T\\') {\\n                    cnt--;\\n                }\\n                lptr++;\\n            }\\n            ans = Math.max(ans, i - lptr + 1);\\n        }\\n        return ans;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732325,
                "title": "two-pointer-sliding-window-easy-approach-easiest-logic",
                "content": "# Intuition\\nThis algorithm aims to find the maximum length of consecutive `T` or `F` characters in the answer key with the option to change `k` characters to the opposite value. By iterating through the answer key, we maintain two pointers `i` and `j` to track the current window. We use a sliding window approach to adjust the window size based on the number of remaining character changes `k`. We update the maximum length whenever a longer consecutive sequence is found.\\n\\n# Approach\\n1. Initialize variables: `temp` to keep track of remaining character changes, `maxLen` to store the maximum length, `i` and `j` as pointers for the sliding window.\\n2. Iterate through the answer key using `i`.\\n3. If `temp` is non-zero and the character at `j` is `F` or `T`,adjust the window by decrementing `temp` and incrementing `j`.\\n4. Otherwise, adjust the window by incrementing `i` and `j` if `i` is greater than or equal to `j`, and incrementing `temp` if the character at `i` is `F`.\\n5. Update `maxLen` by taking the maximum between the current maximum length and the difference between `j` and `i`.\\n6. Repeat steps 2-5 with the opposite conditions to handle the case of switching characters.\\n7. Return the maximum length `maxLen`.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n> IF YOU LIKE IT GIVE IT A `UPVOTE \\u2B06` SO THAT OTHER PEOPLES ALSO CAN FIND IT EASILY. \\n> THANK YOU FOR YOUR TIME \\u231A\\n\\n# Javascript Code\\n```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxConsecutiveAnswers = function (answerKey, k) {\\n    let temp = k;\\n    let maxLen = 0;\\n    let i = 0, j = 0;\\n    while (i < answerKey.length && j < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `F`) ||\\n            answerKey[j] === `T`\\n        ) {\\n            if (answerKey[j] === `F`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `F`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    i = 0, j = 0, temp = k;\\n    while (i < answerKey.length && j < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `T`) ||\\n            answerKey[j] === `F`\\n        ) {\\n            if (answerKey[j] === `T`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `T`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    return maxLen;\\n};\\n```\\n\\n---\\n\\n# Typescript Code\\n```\\nfunction maxConsecutiveAnswers(answerKey: string, k: number): number {\\n    let temp:number = k;\\n    let maxLen:number = 0;\\n    let i:number = 0, j:number = 0;\\n    while (i < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `F`) ||\\n            answerKey[j] === `T`\\n        ) {\\n            if (answerKey[j] === `F`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `F`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    i = 0, j = 0, temp = k;\\n    while (i < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `T`) ||\\n            answerKey[j] === `F`\\n        ) {\\n            if (answerKey[j] === `T`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `T`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxConsecutiveAnswers = function (answerKey, k) {\\n    let temp = k;\\n    let maxLen = 0;\\n    let i = 0, j = 0;\\n    while (i < answerKey.length && j < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `F`) ||\\n            answerKey[j] === `T`\\n        ) {\\n            if (answerKey[j] === `F`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `F`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    i = 0, j = 0, temp = k;\\n    while (i < answerKey.length && j < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `T`) ||\\n            answerKey[j] === `F`\\n        ) {\\n            if (answerKey[j] === `T`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `T`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    return maxLen;\\n};\\n```\n```\\nfunction maxConsecutiveAnswers(answerKey: string, k: number): number {\\n    let temp:number = k;\\n    let maxLen:number = 0;\\n    let i:number = 0, j:number = 0;\\n    while (i < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `F`) ||\\n            answerKey[j] === `T`\\n        ) {\\n            if (answerKey[j] === `F`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `F`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    i = 0, j = 0, temp = k;\\n    while (i < answerKey.length) {\\n        if (\\n            (temp && answerKey[j] === `T`) ||\\n            answerKey[j] === `F`\\n        ) {\\n            if (answerKey[j] === `T`) temp--;\\n            j++;\\n        } else {\\n            if (answerKey[i] === `T`) temp++;\\n            if (i >= j) j++;\\n            i++;\\n        }\\n        maxLen = Math.max(maxLen, (j - i))\\n    }\\n\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732305,
                "title": "solution-python-easy-to-understand-line-by-line-explanation",
                "content": "# Intuition\\nTo maximize the number of consecutive questions with the same answer, we can use a sliding window approach. The window will represent the range of questions where we can change the answer to match the majority within that window.\\n\\n# Approach\\nHere\\'s an algorithm to solve the problem:\\n\\n1. Initialize two pointers, left and right, to 0. \\n2. Initialize a variable, maxConsecutive, to 0 to keep track of the maximum consecutive questions with the same answer.\\n3. Initialize a variable, maxCount, to 0 to keep track of the maximum count of a single answer within the window.\\n4. Initialize a dictionary, count, to store the count of each answer (\\'T\\' or \\'F\\') within the window.\\n5. While the right pointer is less than the length of the answerKey:\\nIncrement the count of answerKey[right] in the count dictionary.\\nUpdate maxCount with the maximum value between maxCount and count[answerKey[right]].\\n6. If the length of the window (right - left + 1) minus maxCount is greater than k (i.e., the number of allowed changes), move the left pointer and update the count dictionary accordingly.\\n7. Increment the right pointer.\\n8. Update maxConsecutive with the maximum value between maxConsecutive and the length of the window (right - left).\\n9. Return maxConsecutive.\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity is o(n)\\n\\n- Space complexity:\\nSpace Complexity is o(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, answerKey, k):\\n        \"\"\"\\n        :type answerKey: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        left = 0\\n        maxConsecutive = 0\\n        maxCount = 0\\n        count = {}\\n\\n        for right in range(len(answerKey)):\\n            count[answerKey[right]] = count.get(answerKey[right], 0) + 1\\n            maxCount = max(maxCount, count[answerKey[right]])\\n\\n            if (right - left + 1) - maxCount > k:\\n                count[answerKey[left]] -= 1\\n                left += 1\\n\\n            maxConsecutive = max(maxConsecutive, right - left + 1)\\n\\n        return maxConsecutive\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, answerKey, k):\\n        \"\"\"\\n        :type answerKey: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        left = 0\\n        maxConsecutive = 0\\n        maxCount = 0\\n        count = {}\\n\\n        for right in range(len(answerKey)):\\n            count[answerKey[right]] = count.get(answerKey[right], 0) + 1\\n            maxCount = max(maxCount, count[answerKey[right]])\\n\\n            if (right - left + 1) - maxCount > k:\\n                count[answerKey[left]] -= 1\\n                left += 1\\n\\n            maxConsecutive = max(maxConsecutive, right - left + 1)\\n\\n        return maxConsecutive\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732229,
                "title": "easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string aKey,int k,char c){\\n        int ans=INT_MIN;\\n        int i=0,j=0;\\n        int n=aKey.size();\\n        int ct=0;\\n        while(j<n){\\n            if(aKey[j]==c)ct++;\\n            \\n            while(ct>k){\\n                if(aKey[i]==c)ct--;\\n                i++;\\n            }\\n            ans=max(j-i+1,ans);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int temp1=solve(answerKey,k,\\'T\\');\\n        int temp2=solve(answerKey,k,\\'F\\');\\n\\n        return max(temp1,temp2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string aKey,int k,char c){\\n        int ans=INT_MIN;\\n        int i=0,j=0;\\n        int n=aKey.size();\\n        int ct=0;\\n        while(j<n){\\n            if(aKey[j]==c)ct++;\\n            \\n            while(ct>k){\\n                if(aKey[i]==c)ct--;\\n                i++;\\n            }\\n            ans=max(j-i+1,ans);\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int temp1=solve(answerKey,k,\\'T\\');\\n        int temp2=solve(answerKey,k,\\'F\\');\\n\\n        return max(temp1,temp2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732130,
                "title": "tc-o-n-sc-o-1-c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string a, int k) {\\n\\n        int i=0,j=0,ans=0,n=a.size();\\n        unordered_map<char , int>mp;\\n        while(i<n and j<=n){\\n            if(min(mp[\\'T\\'],mp[\\'F\\'])<= k ){\\n                ans= max(ans,j-i);\\n                mp[a[j]] ++;\\n                j++;\\n            }\\n            else {\\n                mp[a[i]]--;\\n                i++;\\n            }\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string a, int k) {\\n\\n        int i=0,j=0,ans=0,n=a.size();\\n        unordered_map<char , int>mp;\\n        while(i<n and j<=n){\\n            if(min(mp[\\'T\\'],mp[\\'F\\'])<= k ){\\n                ans= max(ans,j-i);\\n                mp[a[j]] ++;\\n                j++;\\n            }\\n            else {\\n                mp[a[i]]--;\\n                i++;\\n            }\\n          }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732045,
                "title": "c-easy-solution-unordered-map-sliding-window-stepwise-explanation",
                "content": "\\n\\n# Approach\\n\\n1. An unordered map `mpp` is created to store the count of each character in the `answerKey` string.\\n\\n2. Two variables `maxi`, `i`, and `j` are initialized to 0. `maxi` will store the maximum number of consecutive answers, `i` and `j` are pointers used to traverse the `answerKey` string.\\n\\n3. The while loop iterates until `j` reaches the end of the `answerKey` string:\\n\\n   a. The character at index `j` in `answerKey` is accessed, and its count in the `mpp` map is incremented.\\n   \\n   b. `j` is incremented to move to the next character in `answerKey`.\\n   \\n   c. The `max` function is used to calculate the maximum value between `maxi` and the sum of the counts of \\'F\\' and \\'T\\' in the `mpp` map. This ensures that `maxi` always holds the maximum number of consecutive answers seen so far.\\n   \\n   d. If the minimum count between \\'F\\' and \\'T\\' in the `mpp` map is greater than `k`, it means that the maximum number of incorrect answers allowed (`k`) has been exceeded. In this case, a while loop is executed to reduce the count of characters from the beginning of the `answerKey` string until the minimum count between \\'F\\' and \\'T\\' becomes less than or equal to `k`.\\n   \\n   e. Inside the while loop, the character at index `i` in `answerKey` is accessed, and its count in the `mpp` map is decremented. Then, `i` is incremented to move to the next character in `answerKey`.\\n   \\n4. Finally, when the while loop ends, the maximum number of consecutive answers (`maxi`) is returned as the result.\\n\\n![36pwb5.jpg](https://assets.leetcode.com/users/images/948a15dd-61a9-4845-86f4-c49191ea4167_1692374140.8364537.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        unordered_map<char,int>mpp;\\n        int maxi=0,i=0,j=0;\\n        while(j<answerKey.size()){\\n                mpp[answerKey[j]]++;\\n                j++;\\n\\n    if(min(mpp[\\'T\\'],mpp[\\'F\\'])<=k) maxi=max(maxi,mpp[\\'F\\']+mpp[\\'T\\']);\\n                else{\\n                    while(min(mpp[\\'T\\'],mpp[\\'F\\'])>k){\\n                        mpp[answerKey[i]]--;\\n                        i++;\\n                    }\\n                }             \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        unordered_map<char,int>mpp;\\n        int maxi=0,i=0,j=0;\\n        while(j<answerKey.size()){\\n                mpp[answerKey[j]]++;\\n                j++;\\n\\n    if(min(mpp[\\'T\\'],mpp[\\'F\\'])<=k) maxi=max(maxi,mpp[\\'F\\']+mpp[\\'T\\']);\\n                else{\\n                    while(min(mpp[\\'T\\'],mpp[\\'F\\'])>k){\\n                        mpp[answerKey[i]]--;\\n                        i++;\\n                    }\\n                }             \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731987,
                "title": "fast-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxConsecutiveAnswers = function(answerKey, k) {\\n    //F\\n    let n = answerKey.length;\\n    let lenF = 0, r = -1, c = 0;\\n    for(let l = 0; l < n; ++l){\\n        if(l > r){\\n            r = l;\\n        }\\n        while(r < n){\\n            if(answerKey[r] == \\'F\\'){\\n                r++;\\n            }\\n            else if(c < k){\\n                c++;\\n                r++;\\n            }\\n            else break;\\n        }\\n        lenF = Math.max(lenF,r-l);\\n        if(answerKey[l] == \\'T\\') c--;\\n    }\\n\\n    let lenR = 0;\\n    r = -1; c = 0;\\n    for(let l = 0; l < n; ++l){\\n        if(l > r){\\n            r = l;\\n        }\\n        while(r < n){\\n            if(answerKey[r] == \\'T\\'){\\n                r++;\\n            }\\n            else if(c < k){\\n                c++;\\n                r++;\\n            }\\n            else break;\\n        }\\n        lenR = Math.max(lenR,r-l);\\n        if(answerKey[l] == \\'F\\') c--;\\n    }\\n\\n    return Math.max(lenR,lenF);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} answerKey\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxConsecutiveAnswers = function(answerKey, k) {\\n    //F\\n    let n = answerKey.length;\\n    let lenF = 0, r = -1, c = 0;\\n    for(let l = 0; l < n; ++l){\\n        if(l > r){\\n            r = l;\\n        }\\n        while(r < n){\\n            if(answerKey[r] == \\'F\\'){\\n                r++;\\n            }\\n            else if(c < k){\\n                c++;\\n                r++;\\n            }\\n            else break;\\n        }\\n        lenF = Math.max(lenF,r-l);\\n        if(answerKey[l] == \\'T\\') c--;\\n    }\\n\\n    let lenR = 0;\\n    r = -1; c = 0;\\n    for(let l = 0; l < n; ++l){\\n        if(l > r){\\n            r = l;\\n        }\\n        while(r < n){\\n            if(answerKey[r] == \\'T\\'){\\n                r++;\\n            }\\n            else if(c < k){\\n                c++;\\n                r++;\\n            }\\n            else break;\\n        }\\n        lenR = Math.max(lenR,r-l);\\n        if(answerKey[l] == \\'F\\') c--;\\n    }\\n\\n    return Math.max(lenR,lenF);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731911,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string& s, int k, char ele){\\n        int count=0;\\n        int ans=0;\\n        int i=0,j=0,n=s.size();\\n        while(j<n){\\n            if(s[j]!=ele){  //just like for 1 we check 0 in max consective ones 3 problem that\\'s why \\'!=\\' is used\\n                count++;\\n            }\\n            while(count>k){\\n                if(s[i]!=ele){\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int res= max(solve(answerKey,k,\\'T\\'),solve(answerKey,k,\\'F\\'));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s, int k, char ele){\\n        int count=0;\\n        int ans=0;\\n        int i=0,j=0,n=s.size();\\n        while(j<n){\\n            if(s[j]!=ele){  //just like for 1 we check 0 in max consective ones 3 problem that\\'s why \\'!=\\' is used\\n                count++;\\n            }\\n            while(count>k){\\n                if(s[i]!=ele){\\n                    count--;\\n                }\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int res= max(solve(answerKey,k,\\'T\\'),solve(answerKey,k,\\'F\\'));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731905,
                "title": "c-java-sliding-window-two-pointers-easy-explanation",
                "content": "## Problem Description\\n\\nThe problem at hand is to find the maximum number of consecutive answers in a given answer key string, with the option to flip at most `k` incorrect answers. The answer key string consists of \\'T\\' and \\'F\\' characters, representing true and false answers, respectively.\\n\\n## Approach\\n\\nTo solve the problem efficiently, we can use a sliding window technique. The idea is to maintain a window of consecutive answers and slide it through the answer key string while keeping track of the count of incorrect answers (\\'T\\' or \\'F\\') within the window. By flipping at most `k` incorrect answers, we can find the maximum number of consecutive answers.\\n\\n## Helper Function\\n\\nWe define a helper function `helper` that takes three parameters: the answer key string `s`, the maximum number of flips `k`, and the target character `x`. This function calculates the maximum number of consecutive answers when the target character is flipped at most `k` times.\\n\\n1. Initialize variables:\\n   - `ans` to store the maximum number of consecutive answers.\\n   - `cntX` to keep track of the count of target character `x` within the window.\\n   - `n` as the length of the answer key string `s`.\\n   - `left` and `right` as the indices of the window.\\n\\n2. Iterate through the answer key string using the right pointer `right`:\\n   - If the character at `right` is equal to the target character `x`:\\n     - If the count of `x` within the window `cntX` is less than `k`, increment `cntX`.\\n     - Otherwise, find the leftmost occurrence of `x` within the window by incrementing the `left` pointer until `s[left]` becomes equal to `x`.\\n\\n   - Calculate the length of the current window `(right - left + 1)` and update `ans` if it is greater than the previous maximum.\\n\\n3. Return the maximum number of consecutive answers `ans`.\\n\\n## Main Function\\n\\nIn the main function `maxConsecutiveAnswers`, we find the maximum number of consecutive answers considering both \\'T\\' and \\'F\\' characters.\\n\\n1. Initialize `ans` to store the final result.\\n\\n2. Call the `helper` function twice with different target characters:\\n   - `helper(answerKey, k, \\'T\\')` to get the maximum number of consecutive \\'T\\' answers.\\n   - `helper(answerKey, k, \\'F\\')` to get the maximum number of consecutive \\'F\\' answers.\\n\\n3. Update `ans` by taking the maximum value of the two results obtained from the `helper` function calls.\\n\\n4. Return the final result `ans`.\\n\\n## Complexity Analysis\\n\\n- The time complexity of the solution is O(N), where N is the length of the answer key string. We iterate through the string only once using the sliding window technique.\\n\\n- The space complexity is O(1) as we use a constant amount of extra space to store variables\\n---\\n## Code in C++\\n```\\nclass Solution {\\nprivate:\\n    int helper(string s, int k, char x) {\\n        int ans = 0;\\n        int cntX = 0;\\n        int n = s.size();\\n        int left = 0, right = 0;\\n        while(right < n)\\n        {\\n            if(s[right] == x)\\n            {\\n                if(cntX < k)\\n                {\\n                    cntX++;\\n                }\\n                else\\n                {\\n                    while(s[left] != x)\\n                    {\\n                        left++;\\n                    }\\n                    left++;\\n                }\\n            }\\n            ans = max(ans, right-left+1);\\n            right++;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans = 0;\\n        ans = max(helper(answerKey, k, \\'T\\'), helper(answerKey, k, \\'F\\'));\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n## Code in Java\\n\\n```\\nclass Solution {\\n    private int helper(String s, int k, char x) {\\n        int ans = 0;\\n        int cntX = 0;\\n        int n = s.length();\\n        int left = 0, right = 0;\\n        while (right < n) {\\n            if (s.charAt(right) == x) {\\n                if (cntX < k) {\\n                    cntX++;\\n                } else {\\n                    while (s.charAt(left) != x) {\\n                        left++;\\n                    }\\n                    left++;\\n                }\\n            }\\n            ans = Math.max(ans, right - left + 1);\\n            right++;\\n        }\\n        return ans;\\n    }\\n\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int ans = 0;\\n        ans = Math.max(helper(answerKey, k, \\'T\\'), helper(answerKey, k, \\'F\\'));\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(string s, int k, char x) {\\n        int ans = 0;\\n        int cntX = 0;\\n        int n = s.size();\\n        int left = 0, right = 0;\\n        while(right < n)\\n        {\\n            if(s[right] == x)\\n            {\\n                if(cntX < k)\\n                {\\n                    cntX++;\\n                }\\n                else\\n                {\\n                    while(s[left] != x)\\n                    {\\n                        left++;\\n                    }\\n                    left++;\\n                }\\n            }\\n            ans = max(ans, right-left+1);\\n            right++;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans = 0;\\n        ans = max(helper(answerKey, k, \\'T\\'), helper(answerKey, k, \\'F\\'));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int helper(String s, int k, char x) {\\n        int ans = 0;\\n        int cntX = 0;\\n        int n = s.length();\\n        int left = 0, right = 0;\\n        while (right < n) {\\n            if (s.charAt(right) == x) {\\n                if (cntX < k) {\\n                    cntX++;\\n                } else {\\n                    while (s.charAt(left) != x) {\\n                        left++;\\n                    }\\n                    left++;\\n                }\\n            }\\n            ans = Math.max(ans, right - left + 1);\\n            right++;\\n        }\\n        return ans;\\n    }\\n\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int ans = 0;\\n        ans = Math.max(helper(answerKey, k, \\'T\\'), helper(answerKey, k, \\'F\\'));\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731875,
                "title": "sliding-window-python-code",
                "content": "# Intuition - Sliding Window\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep track of Count of True or False.\\nJust when minimum of count of True or False , exceeded `k` , shrink the window. \\n\\nUpvote krdo Yrrr \\uD83D\\uDE0A\\uD83D\\uDE0A\\n# Code\\n```\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, word, k):\\n        l = 0\\n        word = list(word)\\n        Tcount , Fcount = 0 , 0\\n        ans = 0\\n        for r in range(len(word)):\\n            if word[r] == \\'T\\' : Tcount +=1\\n            elif word[r] == \\'F\\' : Fcount +=1\\n\\n            while min(Tcount,Fcount) > k :\\n                if word[l] == \\'T\\' : Tcount -= 1\\n                elif word[l] == \\'F\\' : Fcount -= 1\\n                l +=1\\n\\n            ans = max(r - l + 1, ans)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, word, k):\\n        l = 0\\n        word = list(word)\\n        Tcount , Fcount = 0 , 0\\n        ans = 0\\n        for r in range(len(word)):\\n            if word[r] == \\'T\\' : Tcount +=1\\n            elif word[r] == \\'F\\' : Fcount +=1\\n\\n            while min(Tcount,Fcount) > k :\\n                if word[l] == \\'T\\' : Tcount -= 1\\n                elif word[l] == \\'F\\' : Fcount -= 1\\n                l +=1\\n\\n            ans = max(r - l + 1, ans)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731712,
                "title": "c-binary-search-on-answer-with-sliding-window-simple-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public:\\n    bool isPossible(int mid,int k,string& str){\\n        unordered_map<char,int> m;\\n        int i=0,j=0;\\n        while(j<str.size()){\\n            m[str[j]]++;\\n            if((j-i+1)==mid){\\n                if(m[\\'T\\']+k>=mid)return true;\\n                else if(m[\\'F\\']+k>=mid) return true;\\n                m[str[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n        int low=1,high=n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=low+((high-low)/2);\\n\\n            if(isPossible(mid,k,answerKey)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    bool isPossible(int mid,int k,string& str){\\n        unordered_map<char,int> m;\\n        int i=0,j=0;\\n        while(j<str.size()){\\n            m[str[j]]++;\\n            if((j-i+1)==mid){\\n                if(m[\\'T\\']+k>=mid)return true;\\n                else if(m[\\'F\\']+k>=mid) return true;\\n                m[str[i]]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n        int low=1,high=n;\\n        int ans=0;\\n        while(low<=high){\\n            int mid=low+((high-low)/2);\\n\\n            if(isPossible(mid,k,answerKey)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731674,
                "title": "c-beginner-friendly-one-pass-constant-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem can be simplified as maximum length subarray with same element and you are allowed to change only k element.\\n\\nThe simple approach will be to count the number of true and false\\nAs you can change only k elements if both truecnt and falsecnt are greater than k in a window you will not able change to same type \\n\\non the other hand if you have if truecnt or falsecnt is less than k you could simply change the respective elements and the window still contain the same elments \\n\\nIf the both count greater than k subtract the jth index element count\\nthis will decrease one of the count (falsecnt or truecnt) which will become less than k\\nthis way you will always able to change the k elements and get maximum \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- if find usefull consider upvoting\\uD83D\\uDE0A\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n\\n        int falsecnt=0,truecnt=0,ans=0;\\n\\n        for(int i=0,j=0;i<s.size();i++){\\n            if(s[i]==\\'T\\'){\\n                truecnt++;\\n            }else{\\n                falsecnt++;\\n            }\\n            \\n            if((truecnt>k)&&(falsecnt>k)){\\n                if(s[j]==\\'T\\')truecnt--;\\n                else falsecnt--;\\n                j++;\\n            }\\n            \\n            ans=max(ans,i-j+1);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n\\n        int falsecnt=0,truecnt=0,ans=0;\\n\\n        for(int i=0,j=0;i<s.size();i++){\\n            if(s[i]==\\'T\\'){\\n                truecnt++;\\n            }else{\\n                falsecnt++;\\n            }\\n            \\n            if((truecnt>k)&&(falsecnt>k)){\\n                if(s[j]==\\'T\\')truecnt--;\\n                else falsecnt--;\\n                j++;\\n            }\\n            \\n            ans=max(ans,i-j+1);\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731641,
                "title": "c-2-pointer-sliding-window-100-time-8ms-96-space-9-9mb",
                "content": "To solve this problem we will have to keep two pointers `i` and `j` as the extremes of a window we are considering; we will try to expand advancing the right one (ie: `j`) as much as we can, shrinking the window by advancing the left one (ie; `i`) to shrink the window only when we have too many diverging characters (either the `\\'T\\'`s or the `\\'F\\'`s are `> k`).\\n\\nNow, to code this, we will start by declaring our support variables first:\\n* `i` and `j` are going to be our pointers, both initially set to the position of the first character (`0`);\\n* `len` will store the length of `keys`;\\n* `res` is our usual result variable, initially set to `1` (we will always get at least a character);\\n* `ts` and `fs` will be the counter for how many `\\'T\\'`s and `\\'F\\'`s we have in our current window - both initialised to be `0`.\\n\\nWe will then parse `keys` advancing `j` up to its upper limit (ie: `while` it is `< len`) and:\\n* check if the current character pointed by `j` is a `\\'T\\'`, and if so, increase `ts` by `1`;\\n* if not, increase `fs` by `1`;\\n* advance `j` by `1`;\\n* `while` we are outside of the boundaries of our requirements (ie: either `ts` or `fs` is `> k`, so we cannot replace those many characters), we will, specularly to above:\\n    * check if the current character pointed by `i` is a `\\'T\\'`, and if so, decrease `ts` by `1`;\\n    * if not, decrease `fs` by `1`;\\n    * advance `i` by `1`;\\n* update `res` to be the maximum between its current value and the current size of the window (ie: `j - i`).\\n\\nFinally, we will `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string keys, int k) {\\n        // support variables\\n        int i = 0, j = 0, len = keys.size(), res = 1, ts = 0, fs = 0;\\n        // parsing keys\\n        while (j < len) {\\n            // extending the window right\\n            if (keys[j++] == \\'T\\') ts++;\\n            else fs++;\\n            // restricting the window left, if necessary\\n            while (min(ts, fs) > k) {\\n                if (keys[i++] == \\'T\\') ts--;\\n                else fs--;\\n            }\\n            res = max(res, j - i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative form, refactoring by replacing `ts` and `fs` with `grades` in order to streamline and reduce our code bloat a bit; the performance, unsurprisingly, is still exactly the same:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string keys, int k) {\\n        // support variables\\n        int i = 0, j = 0, len = keys.size(), res = 1, grades[2] = {};\\n        // parsing keys\\n        while (j < len) {\\n            // extending the window right\\n            grades[keys[j++] == \\'T\\']++;\\n            // restricting the window left, if necessary\\n            while (min(grades[0], grades[1]) > k) {\\n                grades[keys[i++] == \\'T\\']--;\\n            }\\n            res = max(res, j - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string keys, int k) {\\n        // support variables\\n        int i = 0, j = 0, len = keys.size(), res = 1, ts = 0, fs = 0;\\n        // parsing keys\\n        while (j < len) {\\n            // extending the window right\\n            if (keys[j++] == \\'T\\') ts++;\\n            else fs++;\\n            // restricting the window left, if necessary\\n            while (min(ts, fs) > k) {\\n                if (keys[i++] == \\'T\\') ts--;\\n                else fs--;\\n            }\\n            res = max(res, j - i);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string keys, int k) {\\n        // support variables\\n        int i = 0, j = 0, len = keys.size(), res = 1, grades[2] = {};\\n        // parsing keys\\n        while (j < len) {\\n            // extending the window right\\n            grades[keys[j++] == \\'T\\']++;\\n            // restricting the window left, if necessary\\n            while (min(grades[0], grades[1]) > k) {\\n                grades[keys[i++] == \\'T\\']--;\\n            }\\n            res = max(res, j - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731630,
                "title": "the-easiest-you-can-ever-get-just-not-telling-got-proof-here-check-the-solution-here",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Will follow the intution of Sliding window.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    - We try both ways, such that changing the F char and T char,Then will use sliding window function to check the most consecutive len.\\n    - In this function will maintain a left and right pointer.\\n    - Where ever there is a neccessary of changing our char, will increase the count of cnt variable.\\n    - If the count of cnt varaible get more than the k, Then will need to move left pointer ahead and also if any odd chars comes then will decrease the count of cnt, such that we can use it in further traversing of right pointer.\\n    - will make sure that at each movement of right, will be generating max lenght, will store this in ans variable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    int count(string str, int k, char ch){\\n        int left = 0;\\n        int n = str.size();\\n        int cnt = 0;\\n        int len = 0, ans = 0;\\n        //Sliding window approach.\\n        for(int right = 0;right<n;right++){\\n            if(str[right] == ch){\\n                cnt++;\\n            }\\n            while(cnt>k){\\n                if(str[left]== ch){\\n                    cnt--;\\n                }\\n                left++;\\n            }\\n            ans = max(right-left+1,ans);\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int left = 0;\\n        int n =  answerKey.size();\\n        //need to try for both F and T.\\n        int a = count(answerKey,k,\\'T\\');\\n        int b = count(answerKey,k,\\'F\\');\\n        return max(a,b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int count(string str, int k, char ch){\\n        int left = 0;\\n        int n = str.size();\\n        int cnt = 0;\\n        int len = 0, ans = 0;\\n        //Sliding window approach.\\n        for(int right = 0;right<n;right++){\\n            if(str[right] == ch){\\n                cnt++;\\n            }\\n            while(cnt>k){\\n                if(str[left]== ch){\\n                    cnt--;\\n                }\\n                left++;\\n            }\\n            ans = max(right-left+1,ans);\\n        }\\n        return ans;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int left = 0;\\n        int n =  answerKey.size();\\n        //need to try for both F and T.\\n        int a = count(answerKey,k,\\'T\\');\\n        int b = count(answerKey,k,\\'F\\');\\n        return max(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731595,
                "title": "c-easy-solution-2-pointers-approach-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string arr, int k) {\\n        int i=0,j=0,x=0;int n=arr.length();int maxi=INT_MIN;\\n        while(i<n)\\n        {\\n            if(arr[i]==\\'F\\')x++;\\n            while(x>k)\\n            {\\n                if(arr[j]==\\'F\\')\\n                x--;\\n                j++;\\n            }\\n            \\n            maxi=max(maxi,i-j+1);\\n            i++;\\n        }\\n        i=0,j=0,x=0;\\n        while(i<n)\\n        {\\n            if(arr[i]==\\'T\\')x++;\\n            while(x>k)\\n            {\\n                if(arr[j]==\\'T\\')\\n                x--;\\n                j++;\\n            }\\n            maxi=max(maxi,i-j+1);\\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string arr, int k) {\\n        int i=0,j=0,x=0;int n=arr.length();int maxi=INT_MIN;\\n        while(i<n)\\n        {\\n            if(arr[i]==\\'F\\')x++;\\n            while(x>k)\\n            {\\n                if(arr[j]==\\'F\\')\\n                x--;\\n                j++;\\n            }\\n            \\n            maxi=max(maxi,i-j+1);\\n            i++;\\n        }\\n        i=0,j=0,x=0;\\n        while(i<n)\\n        {\\n            if(arr[i]==\\'T\\')x++;\\n            while(x>k)\\n            {\\n                if(arr[j]==\\'T\\')\\n                x--;\\n                j++;\\n            }\\n            maxi=max(maxi,i-j+1);\\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731546,
                "title": "very-very-easy-to-understand-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n\\t\\n        //INITIALISING THE VARIABLES\\n        int c1 = 0,c2 = 0;\\n        int ans = 0;\\n        int i,j=0;\\n        \\n        // INCREMENTING THE COUNT AND HANDLING THE EXCEED LIMIT OF K\\n        for(i = 0; i<answerKey.size(); i++){\\n            if(answerKey[i]==\\'T\\') c1++;\\n            else c2++;\\n            \\n            while(c1>k && c2>k){\\n                if(answerKey[j]==\\'T\\')  c1-- , j++;\\n                else c2-- , j++;\\n            }\\n            \\n            //CALCULATING THE MAX LENGTH AND STORING IN FINAL ANS \\n            if(c1<=k || c2<=k) ans = max(i-j+1,ans);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "String",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n\\t\\n        //INITIALISING THE VARIABLES\\n        int c1 = 0,c2 = 0;\\n        int ans = 0;\\n        int i,j=0;\\n        \\n        // INCREMENTING THE COUNT AND HANDLING THE EXCEED LIMIT OF K\\n        for(i = 0; i<answerKey.size(); i++){\\n            if(answerKey[i]==\\'T\\') c1++;\\n            else c2++;\\n            \\n            while(c1>k && c2>k){\\n                if(answerKey[j]==\\'T\\')  c1-- , j++;\\n                else c2-- , j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3731419,
                "title": "o-n-sliding-window-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(2*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string key, int k) {\\n        int n=key.length();\\n        int ans=0;\\n        int st=0;\\n        int en=0;\\n        int k1=k;\\n        //first convet all to f\\n        while(en<n){\\n            if(key[en]==\\'T\\'&&k1>0){\\n                en++;\\n                k1--;\\n            }\\n            else if(key[en]==\\'F\\')en++;\\n            else{\\n                while(k1==0){\\n                    if(key[st]==\\'T\\'){\\n                        st++;\\n                        k1++;\\n                    }\\n                    else st++;\\n                }\\n            }\\n            ans=max(ans,en-st);\\n        }\\n\\n        st=0;\\n        en=0;\\n        //first convet all to T\\n        while(en<n){\\n            if(key[en]==\\'F\\'&&k>0){\\n                en++;\\n                k--;\\n            }\\n            else if(key[en]==\\'T\\')en++;\\n            else{\\n                while(k==0){\\n                    if(key[st]==\\'F\\'){\\n                        st++;\\n                        k++;\\n                    }\\n                    else st++;\\n                }\\n            }\\n            ans=max(ans,en-st);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string key, int k) {\\n        int n=key.length();\\n        int ans=0;\\n        int st=0;\\n        int en=0;\\n        int k1=k;\\n        //first convet all to f\\n        while(en<n){\\n            if(key[en]==\\'T\\'&&k1>0){\\n                en++;\\n                k1--;\\n            }\\n            else if(key[en]==\\'F\\')en++;\\n            else{\\n                while(k1==0){\\n                    if(key[st]==\\'T\\'){\\n                        st++;\\n                        k1++;\\n                    }\\n                    else st++;\\n                }\\n            }\\n            ans=max(ans,en-st);\\n        }\\n\\n        st=0;\\n        en=0;\\n        //first convet all to T\\n        while(en<n){\\n            if(key[en]==\\'F\\'&&k>0){\\n                en++;\\n                k--;\\n            }\\n            else if(key[en]==\\'T\\')en++;\\n            else{\\n                while(k==0){\\n                    if(key[st]==\\'F\\'){\\n                        st++;\\n                        k++;\\n                    }\\n                    else st++;\\n                }\\n            }\\n            ans=max(ans,en-st);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731411,
                "title": "easy-c-two-pointer-solution-using-two-traversal",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int solve(string s, int k, char ch) {\\n        int j = 0;\\n        int ans = 0;\\n        int count = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == ch) {\\n                count++;\\n            }\\n\\n            while(count > k) {\\n                if(s[j] == ch) {\\n                    count--;\\n                }\\n                j++;\\n            }\\n            ans = max(ans, i-j+1);\\n        }\\n\\n        return ans;\\n\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans1 = solve(answerKey, k, \\'T\\');\\n        int ans2 = solve(answerKey, k, \\'F\\');\\n        //cout << ans1 << \", \"<< ans2 << endl;\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string s, int k, char ch) {\\n        int j = 0;\\n        int ans = 0;\\n        int count = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == ch) {\\n                count++;\\n            }\\n\\n            while(count > k) {\\n                if(s[j] == ch) {\\n                    count--;\\n                }\\n                j++;\\n            }\\n            ans = max(ans, i-j+1);\\n        }\\n\\n        return ans;\\n\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans1 = solve(answerKey, k, \\'T\\');\\n        int ans2 = solve(answerKey, k, \\'F\\');\\n        //cout << ans1 << \", \"<< ans2 << endl;\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3731389,
                "title": "maximize-the-confusion-of-an-exam-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.length();\\n        int ans=0;\\n        int right=0,left=0;\\n        int F=0,T=0;\\n        while(right<n)\\n        {\\n            if(right==n)\\n            {\\n                ans=max(ans,right-left);\\n                break;\\n            }\\n            if(min(F,T)<k)\\n            {\\n                if(answerKey[right]==\\'T\\')\\n                {\\n                    T++;\\n                    right++;\\n                }\\n                else if(answerKey[right]==\\'F\\')\\n                {\\n                    F++;\\n                    right++;\\n                }\\n            }\\n            else if(min(F,T)==k)\\n            {\\n                if(min(T,F)==F&&answerKey[right]==\\'T\\')\\n                {\\n                    T++;\\n                    right++;\\n                }\\n                else if(min(T,F)==T&&answerKey[right]==\\'F\\')\\n                {\\n                    F++;\\n                    right++;\\n                }\\n\\n                else\\n                {\\n                    ans=max(ans,right-left);\\n                    if(answerKey[left]==\\'T\\')\\n                    {\\n                        T--;\\n                    }\\n                    else if(answerKey[left]==\\'F\\')\\n                    {\\n                        F--;\\n                    }\\n                    left++;\\n                }\\n                \\n            }\\n           \\n           }\\n           ans=max(ans,right-left);\\n           return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.length();\\n        int ans=0;\\n        int right=0,left=0;\\n        int F=0,T=0;\\n        while(right<n)\\n        {\\n            if(right==n)\\n            {\\n                ans=max(ans,right-left);\\n                break;\\n            }\\n            if(min(F,T)<k)\\n            {\\n                if(answerKey[right]==\\'T\\')\\n                {\\n                    T++;\\n                    right++;\\n                }\\n                else if(answerKey[right]==\\'F\\')\\n                {\\n                    F++;\\n                    right++;\\n                }\\n            }\\n            else if(min(F,T)==k)\\n            {\\n                if(min(T,F)==F&&answerKey[right]==\\'T\\')\\n                {\\n                    T++;\\n                    right++;\\n                }\\n                else if(min(T,F)==T&&answerKey[right]==\\'F\\')\\n                {\\n                    F++;\\n                    right++;\\n                }\\n\\n                else\\n                {\\n                    ans=max(ans,right-left);\\n                    if(answerKey[left]==\\'T\\')\\n                    {\\n                        T--;\\n                    }\\n                    else if(answerKey[left]==\\'F\\')\\n                    {\\n                        F--;\\n                    }\\n                    left++;\\n                }\\n                \\n            }\\n           \\n           }\\n           ans=max(ans,right-left);\\n           return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731386,
                "title": "java-python-sliding-windows-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the question, and if we have a little practice, we can make out the question is a typical `Sliding Window` question.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe would be maintaining a window using two pointer, `start` and `end` which would be pointing at the start of the window and end of the window respectively. Using a while loop, we would be traversing the array, and we would maintain an array `a` of length 2 which would be storing the number of true and false in the window  \\n> 0 index of the array `a` would store the number of false in the window and 1 index would store the number of true in the window\\n\\nNow at every iteration we would increase the window length and according to the character at the end position of the window (which would be either `F` or `T` ) we would increament either index 0 or 1 accordingly. Now after incrementing we would chech whether the `min(a[0],a[1])>k`, which is the main condition of the question. If it is so, we will increment the value of start and update the values in array a accordingly\\n```\\n while(Math.min(a[0],a[1])>k){\\n                if(answerKey.charAt(start)==\\'F\\') a[0]-=1;\\n                else a[1]-=1;\\n                start+=1;}\\n```\\nAfter this, we will check the window length using `end-start+1`, and if it is greater than the previously stored max length than we update it.\\n(Do upvote if you liked the explanation as it motivates me to post more solutions)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int a[]={0,0};\\n        int start=0,end=0,count=0;\\n        while(end<answerKey.length()){\\n            if(answerKey.charAt(end)==\\'F\\') a[0]+=1;\\n            else a[1]+=1;\\n            while(Math.min(a[0],a[1])>k){\\n                if(answerKey.charAt(start)==\\'F\\') a[0]-=1;\\n                else a[1]-=1;\\n                start+=1;}\\n            int count1=end-start+1;\\n            if(count1>count) count=count1;\\n            end+=1;}\\n            return count;\\n            }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, answerKey, k):\\n        start=0\\n        end=0\\n        count=0\\n        a=[0,0]\\n        while end<len(answerKey):\\n            if answerKey[end]==\\'F\\':\\n                a[0]+=1\\n            else:\\n                a[1]+=1\\n            while min(a[0],a[1])>k:\\n                if answerKey[start]==\\'F\\':\\n                    a[0]-=1\\n                else:\\n                    a[1]-=1\\n                start+=1\\n            if(end-start+1>count):\\n                count=end-start+1\\n            end+=1\\n        return count\\n    \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n while(Math.min(a[0],a[1])>k){\\n                if(answerKey.charAt(start)==\\'F\\') a[0]-=1;\\n                else a[1]-=1;\\n                start+=1;}\\n```\n```java []\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int a[]={0,0};\\n        int start=0,end=0,count=0;\\n        while(end<answerKey.length()){\\n            if(answerKey.charAt(end)==\\'F\\') a[0]+=1;\\n            else a[1]+=1;\\n            while(Math.min(a[0],a[1])>k){\\n                if(answerKey.charAt(start)==\\'F\\') a[0]-=1;\\n                else a[1]-=1;\\n                start+=1;}\\n            int count1=end-start+1;\\n            if(count1>count) count=count1;\\n            end+=1;}\\n            return count;\\n            }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def maxConsecutiveAnswers(self, answerKey, k):\\n        start=0\\n        end=0\\n        count=0\\n        a=[0,0]\\n        while end<len(answerKey):\\n            if answerKey[end]==\\'F\\':\\n                a[0]+=1\\n            else:\\n                a[1]+=1\\n            while min(a[0],a[1])>k:\\n                if answerKey[start]==\\'F\\':\\n                    a[0]-=1\\n                else:\\n                    a[1]-=1\\n                start+=1\\n            if(end-start+1>count):\\n                count=end-start+1\\n            end+=1\\n        return count\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731329,
                "title": "simple-python-o-n-concise-two-pointers",
                "content": "# Approach\\n> Calculating the minimum of the number of `T`s and `F`s. And, Trying to keep it smaller than `K`.\\n\\n> If it is greater than `K`, the size of the window is decreased.\\nHere, the sliding window starts at `i` and ends at `j-1`\\n# Code\\n```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        res=0; i=0; j=0; ans={\\'T\\':0, \\'F\\':0}\\n        while j<len(answerKey):\\n            while min(ans[\\'T\\'], ans[\\'F\\'])>k:\\n                ans[answerKey[i]]-=1\\n                i+=1\\n            ans[answerKey[j]]+=1\\n            j+=1\\n            if min(ans[\\'T\\'], ans[\\'F\\'])<=k:\\n                res=max(res, j-i)\\n            \\n        return res\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/0c022a46-709c-44e0-bb34-eb5239f55ab8_1688719323.2345.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\\n        res=0; i=0; j=0; ans={\\'T\\':0, \\'F\\':0}\\n        while j<len(answerKey):\\n            while min(ans[\\'T\\'], ans[\\'F\\'])>k:\\n                ans[answerKey[i]]-=1\\n                i+=1\\n            ans[answerKey[j]]+=1\\n            j+=1\\n            if min(ans[\\'T\\'], ans[\\'F\\'])<=k:\\n                res=max(res, j-i)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731299,
                "title": "c-easy-to-understand-28ms-2024-maximize-the-confusion-of-an-exam-medium-problem",
                "content": "# C++ | Easy to Understand | <28ms | 2024. Maximize the Confusion of an Exam | Medium Problem\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0;\\n        int j = 0;\\n\\n        int countF = 0;\\n        int countT = 0;\\n        int ans = 0;\\n        while(j < answerKey.length()) {\\n            char ch = answerKey[j];\\n            if(ch == \\'T\\') {\\n                countT++;\\n            } else {\\n                countF++;\\n            }\\n\\n            while(min(countT, countF) > k) {\\n                ch = answerKey[i];\\n                if(ch == \\'T\\') {\\n                    countT--;\\n                } else {\\n                    countF--;\\n                }\\n                i++;\\n            }\\n            ans = max(ans, (j-i+1));\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0;\\n        int j = 0;\\n\\n        int countF = 0;\\n        int countT = 0;\\n        int ans = 0;\\n        while(j < answerKey.length()) {\\n            char ch = answerKey[j];\\n            if(ch == \\'T\\') {\\n                countT++;\\n            } else {\\n                countF++;\\n            }\\n\\n            while(min(countT, countF) > k) {\\n                ch = answerKey[i];\\n                if(ch == \\'T\\') {\\n                    countT--;\\n                } else {\\n                    countF--;\\n                }\\n                i++;\\n            }\\n            ans = max(ans, (j-i+1));\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731213,
                "title": "c-easy-sliding-window-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int head,tail=0,len=1,ct=0,cf=0;\\n        \\n        //1. itterate through the string\\n        for(head=0;head<answerKey.size();head++)\\n        {    \\n            //2. if the string is NULL then return 0 \\n             if(answerKey.size()==0) return 0;\\n            \\n            //3.count the number of T and F \\n            //4. keep increasing till the min(ct,cf)<=k\\n            //{in a substring if any of T or F is equal or less than k }\\n             if(answerKey[head]==\\'T\\')\\n                 ct++;\\n             else \\n                cf++;\\n            \\n            //5.as soon as both ct and cf gets greater than k , substring cant be changed\\n            //therefore, strat shrinking the window from the tail\\n            //till any one of ct or cf becomes <=k\\n            while(min(ct,cf)>k)\\n            {\\n                if(answerKey[tail]==\\'T\\')\\n                    ct--;\\n                else \\n                    cf--;\\n               tail++;\\n            }\\n           \\n            //6. calculate the value of len that is max\\n            len=max(len,head-tail+1);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int head,tail=0,len=1,ct=0,cf=0;\\n        \\n        //1. itterate through the string\\n        for(head=0;head<answerKey.size();head++)\\n        {    \\n            //2. if the string is NULL then return 0 \\n             if(answerKey.size()==0) return 0;\\n            \\n            //3.count the number of T and F \\n            //4. keep increasing till the min(ct,cf)<=k\\n            //{in a substring if any of T or F is equal or less than k }\\n             if(answerKey[head]==\\'T\\')\\n                 ct++;\\n             else \\n                cf++;\\n            \\n            //5.as soon as both ct and cf gets greater than k , substring cant be changed\\n            //therefore, strat shrinking the window from the tail\\n            //till any one of ct or cf becomes <=k\\n            while(min(ct,cf)>k)\\n            {\\n                if(answerKey[tail]==\\'T\\')\\n                    ct--;\\n                else \\n                    cf--;\\n               tail++;\\n            }\\n           \\n            //6. calculate the value of len that is max\\n            len=max(len,head-tail+1);\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731178,
                "title": "o-n-90-o-1-100-java-easiest-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int max = 0;\\n        int t = 0, f = 0;\\n        int l = 0, r = 0;\\n        while (true) {\\n            if (Math.min(t, f) <= k) {\\n                max = Math.max(max, t + f);\\n                if (r >= answerKey.length()) {\\n                    break;\\n                }\\n                if (answerKey.charAt(r) == \\'T\\') {\\n                    t++;\\n                } else {\\n                    f++;\\n                }\\n                r++;\\n            } else {\\n                if (answerKey.charAt(l) == \\'T\\') {\\n                    t--;\\n                } else {\\n                    f--;\\n                }\\n                l++;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int max = 0;\\n        int t = 0, f = 0;\\n        int l = 0, r = 0;\\n        while (true) {\\n            if (Math.min(t, f) <= k) {\\n                max = Math.max(max, t + f);\\n                if (r >= answerKey.length()) {\\n                    break;\\n                }\\n                if (answerKey.charAt(r) == \\'T\\') {\\n                    t++;\\n                } else {\\n                    f++;\\n                }\\n                r++;\\n            } else {\\n                if (answerKey.charAt(l) == \\'T\\') {\\n                    t--;\\n                } else {\\n                    f--;\\n                }\\n                l++;\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731162,
                "title": "sliding-window-short-and-efficient-solution-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe maintain the count of true and false in a window. In a particular window, either the number of `true` or the number of `false` should be `<=k`. \\nIf both of these exceed `k` at any point we increase the `start` pointer by one and decrease the count of the character at the `start` index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int start=0, end=0, t=0, f=0, ans=0;\\n\\n        while(end < s.size())\\n        {\\n            s[end]==\\'T\\'? t++ : f++;\\n            if(t>k && f>k)\\n                s[start++]==\\'T\\'? t-- : f--;\\n\\n            ans = max(ans, end-start+1);\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        int start=0, end=0, t=0, f=0, ans=0;\\n\\n        while(end < s.size())\\n        {\\n            s[end]==\\'T\\'? t++ : f++;\\n            if(t>k && f>k)\\n                s[start++]==\\'T\\'? t-- : f--;\\n\\n            ans = max(ans, end-start+1);\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731083,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Sliding window again :)) No need to switch, just keep count of F and T.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->So sliding window means you are checking substrings inside of the string by updating the right and left border of your substring.\\n\\nHere I start my loop by moving my right border to the right as long as I have **less than k times T and F ** in my substring.\\n\\nWhen this is not the case anymore (t_count > k && f_count > k), I move the left border of my window to the right and decrement the count of \\'T\\'s and \\'F\\'s as I go.\\n\\nIf the current length of my Substring is bigger than the one I have already, I update it and I return it in the end.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nint maxConsecutiveAnswers(char *answerKey, int k) {\\n    int len = strlen(answerKey);\\n    int max_len = 0;\\n    int t_count = 0;\\n    int f_count = 0;\\n    int left = 0;\\n    \\n    \\n    for (int right = 0; right < len; right++) \\n    {\\n        if (answerKey[right] == \\'T\\')\\n            t_count++;\\n        else if (answerKey[right] == \\'F\\')\\n            f_count++;\\n        while (t_count > k && f_count > k)\\n        {\\n            if (answerKey[left] == \\'T\\')\\n                t_count--;\\n            else if (answerKey[left] == \\'F\\')\\n                f_count--;\\n            left++;\\n        }\\n        int curr_len = right - left + 1;\\n        if (curr_len > max_len)\\n            max_len = curr_len;\\n    }\\n    \\n    return max_len;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxConsecutiveAnswers(char *answerKey, int k) {\\n    int len = strlen(answerKey);\\n    int max_len = 0;\\n    int t_count = 0;\\n    int f_count = 0;\\n    int left = 0;\\n    \\n    \\n    for (int right = 0; right < len; right++) \\n    {\\n        if (answerKey[right] == \\'T\\')\\n            t_count++;\\n        else if (answerKey[right] == \\'F\\')\\n            f_count++;\\n        while (t_count > k && f_count > k)\\n        {\\n            if (answerKey[left] == \\'T\\')\\n                t_count--;\\n            else if (answerKey[left] == \\'F\\')\\n                f_count--;\\n            left++;\\n        }\\n        int curr_len = right - left + 1;\\n        if (curr_len > max_len)\\n            max_len = curr_len;\\n    }\\n    \\n    return max_len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731065,
                "title": "o-n-solution-to-maximize-the-confusion-of-an-exam-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i=0, j, trues=0, falses=0, maxs=0;\\n        for(j=0 ; j<answerKey.length() ; j++)\\n        {\\n            if(answerKey[j]==\\'T\\')\\n            {\\n                trues++;\\n                maxs = max(maxs, trues);\\n            }\\n            else\\n            {\\n                falses++;\\n                maxs = max(maxs, falses);\\n            }\\n            if(j-i+1>maxs+k)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    trues--;\\n                else\\n                    falses--;\\n                i++;\\n            }\\n        }\\n        return answerKey.length()-i;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/e9be3dad-f373-4482-91e7-f7a0cbb8d1be_1688715874.0074415.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i=0, j, trues=0, falses=0, maxs=0;\\n        for(j=0 ; j<answerKey.length() ; j++)\\n        {\\n            if(answerKey[j]==\\'T\\')\\n            {\\n                trues++;\\n                maxs = max(maxs, trues);\\n            }\\n            else\\n            {\\n                falses++;\\n                maxs = max(maxs, falses);\\n            }\\n            if(j-i+1>maxs+k)\\n            {\\n                if(answerKey[i]==\\'T\\')\\n                    trues--;\\n                else\\n                    falses--;\\n                i++;\\n            }\\n        }\\n        return answerKey.length()-i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731033,
                "title": "shrinking-sliding-window",
                "content": "# Intuition\\nUse Sliding Window to get max window size having min(T,F) == K.\\n\\n# Approach\\nKeep count of T\\'s and F\\'s and when the min(T,F) > K shrink the window from start till we get the required condition of min(T,F) == K.\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        long long t = 0, f = 0, ans = 0;\\n        long long i = 0, j = 0, n = s.size();\\n        while(j<n) {\\n            s[j] == \\'T\\' ? t++ : f++;\\n            while(min(t,f) > k && i<j) {\\n                s[i] == \\'T\\' ? t-- : f--;\\n                i++;\\n            }\\n            ans = max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n        long long t = 0, f = 0, ans = 0;\\n        long long i = 0, j = 0, n = s.size();\\n        while(j<n) {\\n            s[j] == \\'T\\' ? t++ : f++;\\n            while(min(t,f) > k && i<j) {\\n                s[i] == \\'T\\' ? t-- : f--;\\n                i++;\\n            }\\n            ans = max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731019,
                "title": "c-solution-sliding-window-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**$$Sliding Window$$**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function first initializes some variables: `n` to store the length of the `answerKey` string, `res` to k as an initial maximum consecutive answer count, and mp as an unordered map to keep track of the frequency of each answer `\\'T\\'` or `\\'F\\'`.\\n\\n2. The function then enters a for loop that runs `k` times. In each iteration, it increments the count of the answer `answerKey[i]` in the mp map.\\n\\n3. After populating the mp map, the function sets the variable `l` to 0, which represents the left pointer of the current consecutive sequence.\\n\\n4. The function then enters another for loop that starts from r = k and runs until r reaches n. This loop is responsible for finding the maximum consecutive answer count.\\n\\n5. In each iteration of the loop, it increments the count of the answer at index r in the mp map.\\n\\n6. Inside the loop, there is a while loop that runs as long as the minimum count of `\\'T\\'` and `\\'F\\'` answers in the mp map is greater than k. This loop is responsible for maintaining the constraint of allowing at most k flips.\\n\\n7. In the while loop, it decrements the count of the answer at index l in the mp map and increments l by 1 to move the left pointer of the consecutive sequence forward.\\n\\n8. After the while loop, it calculates the length of the current consecutive sequence `r - l + 1` and updates the `res` variable with the maximum of its current value and the length.\\n\\n9. Finally, the function returns the maximum consecutive answer count `res`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        \\n        int n=answerKey.length();\\n        int res=k;\\n\\n         unordered_map<char,int> mp;\\n\\n         for(int i=0;i<k;i++){\\n             mp[answerKey[i]]++;\\n         }\\n\\n         int l=0;\\n\\n         for(int r=k;r<n;r++){\\n             mp[answerKey[r]]++;\\n        //responsible for maintaining the constraint of allowing at most k flips\\n            while(min(mp[\\'T\\'],mp[\\'F\\'])>k){\\n                mp[answerKey[l]]--;\\n                l++;\\n            } \\n\\n            res=max(res,r-l+1);\\n         }\\n\\n\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        \\n        int n=answerKey.length();\\n        int res=k;\\n\\n         unordered_map<char,int> mp;\\n\\n         for(int i=0;i<k;i++){\\n             mp[answerKey[i]]++;\\n         }\\n\\n         int l=0;\\n\\n         for(int r=k;r<n;r++){\\n             mp[answerKey[r]]++;\\n        //responsible for maintaining the constraint of allowing at most k flips\\n            while(min(mp[\\'T\\'],mp[\\'F\\'])>k){\\n                mp[answerKey[l]]--;\\n                l++;\\n            } \\n\\n            res=max(res,r-l+1);\\n         }\\n\\n\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730959,
                "title": "short-crisp-sliding-window-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string s,int k,char ch)\\n    {\\n        int sp=0;\\n        int ep=0;\\n        int ans=0;\\n        while(ep<s.length())\\n        {\\n            if(s[ep]!=ch)\\n            {\\n                k--;\\n            }\\n            while(k<0)\\n            {\\n                if(s[sp]!=ch)\\n                k++;\\n                sp++;\\n            }\\n            ep++;\\n            ans=max(ans,ep-sp+1);\\n        }\\n        return ans-1;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(solve(answerKey,k,\\'T\\'),solve(answerKey,k,\\'F\\'));  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string s,int k,char ch)\\n    {\\n        int sp=0;\\n        int ep=0;\\n        int ans=0;\\n        while(ep<s.length())\\n        {\\n            if(s[ep]!=ch)\\n            {\\n                k--;\\n            }\\n            while(k<0)\\n            {\\n                if(s[sp]!=ch)\\n                k++;\\n                sp++;\\n            }\\n            ep++;\\n            ans=max(ans,ep-sp+1);\\n        }\\n        return ans-1;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        return max(solve(answerKey,k,\\'T\\'),solve(answerKey,k,\\'F\\'));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730764,
                "title": "2-c-solutions-time-o-26-n-o-n-sliding-window-hash-map",
                "content": "This Problem is same as [424. Longest Repeating Character Replacement\\n](https://leetcode.com/problems/longest-repeating-character-replacement/)\\n# Approach\\nWell, The only catch is to find the valid window(substring) to perform the operation. Maximum window size would be the answer\\n\\nIf we observe, a window is valid if this condition is met :\\n`window size - frequency of most frequent character <= k`\\n\\nSo expand the window while the condition is met.\\nIf the condition fails, start reducing the windoe from the left untill the condition is again valid\\n\\n# Complexity\\n- Time complexity:\\n$$O(26*n)$$\\n\\n- Space complexity:\\n$$O(26)$$ ~ $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int maxFreq(unordered_map<char, int>&mp)\\n    {\\n        int ans = 0;\\n\\n        for(auto &it : mp)\\n        {\\n            ans = max(ans, it.second);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        int l = 0;\\n        int ans = -1;\\n\\n        for(int r = 0; r<n; r++)\\n        {\\n            char ch = s[r];\\n\\n            mp[ch]++;\\n\\n            while((r-l+1) - maxFreq(mp) > k)\\n            {\\n                mp[s[l]]--;\\n                l++;\\n            }\\n\\n            ans = max(ans, (r-l+1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nBut There is way to reduce the time from$$ O(26 * n)$$ to $$O(n)$$\\nEach time we have to look into the map to find the most frequency.\\n\\nBut we can store the frequency in variable and if the frequency increments, we need to update the $$mfreq$$ variable.\\n\\nWhat if frequency decreases ? Do we need to update it ?\\nWell, No. Take a look again on the condition\\n\\n`window size - frequency of most frequent character <= k`\\n\\nSince window size is increasing, if frequency also increases, them only this condition will be valid and will reflect in our answer.\\nIf frequenct decreases  => maxFreq still remains same => as if wont affect our answer(which is max length of the window).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(26)$$ ~ $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        int l = 0;\\n        int ans = -1;\\n\\n        int mfreq = 0;\\n\\n        for(int r = 0; r<n; r++)\\n        {\\n            char ch = s[r];\\n\\n            mp[ch]++;\\n\\n            // update the frequency to the maximum\\n\\n            mfreq = max(mfreq, mp[ch]);\\n\\n            while((r-l+1) - mfreq > k)\\n            {\\n                mp[s[l]]--;\\n                l++;\\n            }\\n\\n            ans = max(ans, (r-l+1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# **Hope it helps!**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int maxFreq(unordered_map<char, int>&mp)\\n    {\\n        int ans = 0;\\n\\n        for(auto &it : mp)\\n        {\\n            ans = max(ans, it.second);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        int l = 0;\\n        int ans = -1;\\n\\n        for(int r = 0; r<n; r++)\\n        {\\n            char ch = s[r];\\n\\n            mp[ch]++;\\n\\n            while((r-l+1) - maxFreq(mp) > k)\\n            {\\n                mp[s[l]]--;\\n                l++;\\n            }\\n\\n            ans = max(ans, (r-l+1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string s, int k) {\\n\\n        unordered_map<char, int> mp;\\n        int n = s.size();\\n        int l = 0;\\n        int ans = -1;\\n\\n        int mfreq = 0;\\n\\n        for(int r = 0; r<n; r++)\\n        {\\n            char ch = s[r];\\n\\n            mp[ch]++;\\n\\n            // update the frequency to the maximum\\n\\n            mfreq = max(mfreq, mp[ch]);\\n\\n            while((r-l+1) - mfreq > k)\\n            {\\n                mp[s[l]]--;\\n                l++;\\n            }\\n\\n            ans = max(ans, (r-l+1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730763,
                "title": "sliding-window-concept-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int evaluate(string s,int k, char ch){\\n        int j=0,i=0,ans=INT_MIN;\\n        while(j<s.size()){\\n            if(s[j]==ch)\\n            k--;\\n            if(k<0){\\n                if(s[i]==ch)\\n                k++;\\n                i++;\\n            }\\n            j++;\\n            ans=max(ans,j-i);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxConsecutiveAnswers(string ans, int k) {\\n        \\n        int t=evaluate(ans,k,\\'T\\');\\n        int f=evaluate(ans,k,\\'F\\');\\n        return max(t,f);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string s,int k, char ch){\\n        int j=0,i=0,ans=INT_MIN;\\n        while(j<s.size()){\\n            if(s[j]==ch)\\n            k--;\\n            if(k<0){\\n                if(s[i]==ch)\\n                k++;\\n                i++;\\n            }\\n            j++;\\n            ans=max(ans,j-i);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxConsecutiveAnswers(string ans, int k) {\\n        \\n        int t=evaluate(ans,k,\\'T\\');\\n        int f=evaluate(ans,k,\\'F\\');\\n        return max(t,f);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730712,
                "title": "c-code-sliding-window-simple-and-beginner-s-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.length();\\n        int left = 0;\\n        int right = 0;\\n        int cnt_t = 0;\\n        int cnt_f = 0;\\n        int maxi = 0;\\n        for(;right<n;right++){\\n            if(answerKey[right]==\\'T\\') cnt_t++;\\n            else cnt_f++;\\n            if(cnt_t>=cnt_f){\\n               if(cnt_f<=k)\\n               maxi = max(maxi, right-left+1);\\n               else{\\n                    if(answerKey[left]==\\'T\\') cnt_t--;\\n                     else cnt_f--;\\n                     left++;\\n               }\\n            }else{\\n               if(cnt_t<=k)\\n               maxi = max(maxi, right-left+1);\\n               else{\\n                   if(answerKey[left]==\\'T\\') cnt_t--;\\n                     else cnt_f--;\\n                     left++;\\n               }\\n            }\\n\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n = answerKey.length();\\n        int left = 0;\\n        int right = 0;\\n        int cnt_t = 0;\\n        int cnt_f = 0;\\n        int maxi = 0;\\n        for(;right<n;right++){\\n            if(answerKey[right]==\\'T\\') cnt_t++;\\n            else cnt_f++;\\n            if(cnt_t>=cnt_f){\\n               if(cnt_f<=k)\\n               maxi = max(maxi, right-left+1);\\n               else{\\n                    if(answerKey[left]==\\'T\\') cnt_t--;\\n                     else cnt_f--;\\n                     left++;\\n               }\\n            }else{\\n               if(cnt_t<=k)\\n               maxi = max(maxi, right-left+1);\\n               else{\\n                   if(answerKey[left]==\\'T\\') cnt_t--;\\n                     else cnt_f--;\\n                     left++;\\n               }\\n            }\\n\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730631,
                "title": "sliding-window-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can perform constant number of operations, we need to create packages in which we can perform those constant operations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthe approach used is sliding window.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*k) \\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        unordered_map<char,int> m,mp;\\n        int ans = 0;\\n        int j = 0;\\n        int s = 0;\\n\\n        for (int i=0;i<answerKey.size();i++){\\n            m[answerKey[i]]++;\\n            while (m[\\'T\\']>k){\\n                m[answerKey[j]]--;\\n                if(m[answerKey[j]]==0){\\n                    m.erase(answerKey[j]);\\n                }\\n                j++;\\n            }\\n            ans = max(i-j+1,ans);\\n        }\\n\\n        for (int i = 0; i < answerKey.size(); i++) {\\n        mp[answerKey[i]]++;\\n        while (mp[\\'F\\'] > k) {\\n        mp[answerKey[s]]--;\\n        if (mp[answerKey[s]] == 0) {\\n            mp.erase(answerKey[s]);\\n        }\\n        s++;\\n        }\\n        ans = max(i - s + 1, ans);\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        unordered_map<char,int> m,mp;\\n        int ans = 0;\\n        int j = 0;\\n        int s = 0;\\n\\n        for (int i=0;i<answerKey.size();i++){\\n            m[answerKey[i]]++;\\n            while (m[\\'T\\']>k){\\n                m[answerKey[j]]--;\\n                if(m[answerKey[j]]==0){\\n                    m.erase(answerKey[j]);\\n                }\\n                j++;\\n            }\\n            ans = max(i-j+1,ans);\\n        }\\n\\n        for (int i = 0; i < answerKey.size(); i++) {\\n        mp[answerKey[i]]++;\\n        while (mp[\\'F\\'] > k) {\\n        mp[answerKey[s]]--;\\n        if (mp[answerKey[s]] == 0) {\\n            mp.erase(answerKey[s]);\\n        }\\n        s++;\\n        }\\n        ans = max(i - s + 1, ans);\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730626,
                "title": "typescript-javascript-sliding-window-o-n-runtime-80-ms",
                "content": "# Approach\\nCalc current \\'T\\' & \\'F\\' count\\nif one of the min count greater than ```k``` => sliding window\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction maxConsecutiveAnswers(answerKey: string, k: number): number {\\n    let left = 0\\n    let right = 0\\n    let res = -Infinity\\n\\n    let tCnt = 0\\n    let fCnt = 0\\n\\n    for (right = 0; right < answerKey.length; right++) {\\n        const ans = answerKey[right]\\n\\n        if (ans === \\'T\\') tCnt++\\n        if (ans === \\'F\\') fCnt++\\n        \\n        while (Math.min(tCnt, fCnt) > k) {\\n            const prevW = answerKey[left]\\n\\n            if (prevW === \\'T\\') {\\n                tCnt--\\n            }\\n\\n            if (prevW === \\'F\\') {\\n                fCnt--\\n            }\\n\\n            left++\\n        }\\n\\n        let currentLen = right - left + 1\\n        res = Math.max(res, currentLen)\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sliding Window"
                ],
                "code": "```k```\n```\\nfunction maxConsecutiveAnswers(answerKey: string, k: number): number {\\n    let left = 0\\n    let right = 0\\n    let res = -Infinity\\n\\n    let tCnt = 0\\n    let fCnt = 0\\n\\n    for (right = 0; right < answerKey.length; right++) {\\n        const ans = answerKey[right]\\n\\n        if (ans === \\'T\\') tCnt++\\n        if (ans === \\'F\\') fCnt++\\n        \\n        while (Math.min(tCnt, fCnt) > k) {\\n            const prevW = answerKey[left]\\n\\n            if (prevW === \\'T\\') {\\n                tCnt--\\n            }\\n\\n            if (prevW === \\'F\\') {\\n                fCnt--\\n            }\\n\\n            left++\\n        }\\n\\n        let currentLen = right - left + 1\\n        res = Math.max(res, currentLen)\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730531,
                "title": "java-easy-sliding-window-understandable-solution",
                "content": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int ans = 0, tru = 0, fals = 0;\\n        int i = 0,  j = 0, n = answerKey.length();\\n        while( j < n ){\\n            char c = answerKey.charAt(j);\\n            if( c == \\'T\\' ) tru++;\\n            else fals++;\\n//              true is occuring less than k times, so false is more than k times, we can change only trues\\n            if( tru <= k ){\\n                ans = Math.max(ans, j-i + 1);\\n                j++;\\n            }\\n//              false is occuring less than k times, so true is more than k times, we can change only false\\n            else if( fals <= k){\\n                ans = Math.max(ans, j-i + 1);\\n                j++;    \\n            }\\n//             if both true and false are occuring more than k times , then compress the size of window untill we have either true or false less k times so that we can change that\\n            else {\\n                while( tru > k && fals > k && i <= j){\\n                    char ch = answerKey.charAt(i++);\\n                    if( ch == \\'T\\') tru--;\\n                    else fals--;\\n                }\\n                ans = Math.max(ans, j-i+1);\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxConsecutiveAnswers(String answerKey, int k) {\\n        int ans = 0, tru = 0, fals = 0;\\n        int i = 0,  j = 0, n = answerKey.length();\\n        while( j < n ){\\n            char c = answerKey.charAt(j);\\n            if( c == \\'T\\' ) tru++;\\n            else fals++;\\n//              true is occuring less than k times, so false is more than k times, we can change only trues\\n            if( tru <= k ){\\n                ans = Math.max(ans, j-i + 1);\\n                j++;\\n            }\\n//              false is occuring less than k times, so true is more than k times, we can change only false\\n            else if( fals <= k){\\n                ans = Math.max(ans, j-i + 1);\\n                j++;    \\n            }\\n//             if both true and false are occuring more than k times , then compress the size of window untill we have either true or false less k times so that we can change that\\n            else {\\n                while( tru > k && fals > k && i <= j){\\n                    char ch = answerKey.charAt(i++);\\n                    if( ch == \\'T\\') tru--;\\n                    else fals--;\\n                }\\n                ans = Math.max(ans, j-i+1);\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730501,
                "title": "easy-to-understand-c-sliding-window",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting number of \"T\" & \"F\" for each window by verifying the min(t, f) <= k and storing maximum answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int t = 0, f = 0, i = 0, j = 0;\\n        int ans = 0;\\n        while(i < answerKey.length() && j < answerKey.length()){\\n            (answerKey[j++] == \\'T\\') ? t++ : f++;\\n            if(min(t, f) > k) (answerKey[i++] == \\'T\\') ? t-- : f--;\\n            ans = max(ans, t + f);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Upvote ^ if Helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int t = 0, f = 0, i = 0, j = 0;\\n        int ans = 0;\\n        while(i < answerKey.length() && j < answerKey.length()){\\n            (answerKey[j++] == \\'T\\') ? t++ : f++;\\n            if(min(t, f) > k) (answerKey[i++] == \\'T\\') ? t-- : f--;\\n            ans = max(ans, t + f);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730451,
                "title": "simple-c-code-using-sliding-window",
                "content": "# Approach\\nSliding Window\\n\\n# Complexity\\n- Time complexity: O(n) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0, j = 0, ans = 0, n = answerKey.size(), t = 0, f = 0;\\n//converting F to T and counting consecutive Ts\\n        while(i < n)\\n        {\\n            if(answerKey[i] == \\'F\\')\\n                f++;\\n            while(j <= i && f > k)\\n            {\\n                if(answerKey[j] == \\'F\\')\\n                    f--;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n\\n        }\\n        i = 0, j = 0, f = 0;\\n//converting T to F and counting consecutive Fs\\n        while(i < n)\\n        {\\n            if(answerKey[i] == \\'T\\')\\n                t++;\\n            while(j <= i && t > k)\\n            {\\n                if(answerKey[j] == \\'T\\')\\n                    t--;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int i = 0, j = 0, ans = 0, n = answerKey.size(), t = 0, f = 0;\\n//converting F to T and counting consecutive Ts\\n        while(i < n)\\n        {\\n            if(answerKey[i] == \\'F\\')\\n                f++;\\n            while(j <= i && f > k)\\n            {\\n                if(answerKey[j] == \\'F\\')\\n                    f--;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n\\n        }\\n        i = 0, j = 0, f = 0;\\n//converting T to F and counting consecutive Fs\\n        while(i < n)\\n        {\\n            if(answerKey[i] == \\'T\\')\\n                t++;\\n            while(j <= i && t > k)\\n            {\\n                if(answerKey[j] == \\'T\\')\\n                    t--;\\n                j++;\\n            }\\n            ans = max(ans,i-j+1);\\n            i++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730412,
                "title": "c-binary-search-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n        int start=0;\\n        int end=0;\\n        int ans=INT_MIN;\\n        int t=0;\\n        int f=0;\\n        \\n        while(end<n)\\n        {\\n            if(answerKey[end]==\\'T\\') t++;\\n            else f++;\\n            \\n            while(t>k && f>k)\\n            {\\n                if(answerKey[start]==\\'T\\') t--;\\n                else f--;\\n                start++;\\n            }\\n            ans=max(ans,end-start+1);\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int n=answerKey.size();\\n        int start=0;\\n        int end=0;\\n        int ans=INT_MIN;\\n        int t=0;\\n        int f=0;\\n        \\n        while(end<n)\\n        {\\n            if(answerKey[end]==\\'T\\') t++;\\n            else f++;\\n            \\n            while(t>k && f>k)\\n            {\\n                if(answerKey[start]==\\'T\\') t--;\\n                else f--;\\n                start++;\\n            }\\n            ans=max(ans,end-start+1);\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730398,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int st = 0;\\n        int en = 0;\\n        int ans = 0;\\n        int trueCount =0;\\n        int falseCount =0;\\n        while(en<answerKey.size()){\\n            if(answerKey[en]==\\'T\\')  trueCount++;\\n            if(answerKey[en]==\\'F\\')  falseCount++;\\n            while(st<en && k<min(trueCount,falseCount))\\n            {\\n                if(answerKey[st]==\\'T\\')  trueCount--;\\n                if(answerKey[st]==\\'F\\')  falseCount--;\\n                st++;\\n            }\\n            ans = max(ans,en-st+1);\\n            en++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int st = 0;\\n        int en = 0;\\n        int ans = 0;\\n        int trueCount =0;\\n        int falseCount =0;\\n        while(en<answerKey.size()){\\n            if(answerKey[en]==\\'T\\')  trueCount++;\\n            if(answerKey[en]==\\'F\\')  falseCount++;\\n            while(st<en && k<min(trueCount,falseCount))\\n            {\\n                if(answerKey[st]==\\'T\\')  trueCount--;\\n                if(answerKey[st]==\\'F\\')  falseCount--;\\n                st++;\\n            }\\n            ans = max(ans,en-st+1);\\n            en++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730343,
                "title": "sliding-window-easy-c-with-approach",
                "content": "# Intuition\\nthe first thought came into my mind that is sliding window. but how can i apply on this. i just did dry run on given test case after dry run i got the solution using sliding window but here i have to calculate the result from both scenario for true and for false.\\n\\n# Approach\\nLet\\'s Discuss the approach\\n# for case true\\ni initialize my both pointer to index zero. i just traversing the window whenever i got \\'F\\' then decrement the count of k, at any case if i encountered k==0 and the current char is \\'F\\' that means this window can be our possible answer so i calculate the answer and move window from left pointer untill i found \\'F\\'. And then did the same thing whenever K count zero, i have to calculate the result and move the window from left pointer. \\n\\nSTEP BY STEP:-\\n- first i counted truecount and falsecount if k is greater than or equal to that return length of the string beacuse in this case our answer will be lebgth of whole string.\\n- Traversing the window did same thing that i discussed earlier in approach.\\n- In last after the loop calculate the result because if any window that is in the last it can be our possible answer so we calculate the result at last.\\n\\n# for case False\\n\\nSame thing did only change the Char \\'F\\' to \\'T\\'.\\n\\ncode seems like lengthy but its too easy.\\n\\n# if you have any doubt just comment it!\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int res = INT_MIN;\\n        int i=0,j=0;\\n        \\n        int c=0;\\n        int t =k;\\n        int fcount =0;\\n        int tcount = 0;\\n        for(int i=0;i<answerKey.length();i++){\\n            if(answerKey[i]==\\'T\\')tcount++;\\n            else\\n            fcount++;\\n        }\\n        if(fcount<=k)return answerKey.length();\\n        if(tcount<=k)return answerKey.length();\\n        #for true\\n        while(j<answerKey.length()){\\n            if(t==0 && answerKey[j]==\\'F\\'){\\n                res = max(res,j-i);\\n                while(t==0&&i<j){\\n                    if(answerKey[i]==\\'F\\')\\n                    t++;\\n\\n                    res = max(res,j-i);\\n                    i++;\\n\\n                }\\n\\n            }\\n            if(answerKey[j]==\\'F\\')\\n                t--;\\n         \\n            j++;\\n        }\\n        res = max(res,j-i);\\n\\n        #for false\\n        i=0,j=0;\\n        t=k;\\n          while(j<answerKey.length()){\\n            if(t==0 && answerKey[j]==\\'T\\'){\\n                res = max(res,j-i);\\n                while(t==0&&i<j){\\n                    if(answerKey[i]==\\'T\\')\\n                    t++;\\n\\n                    res = max(res,j-i);\\n                    i++;\\n\\n                }\\n\\n            }\\n            if(answerKey[j]==\\'T\\')\\n                t--;\\n               \\n            j++;\\n        }\\n        res = max(res,j-i);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int res = INT_MIN;\\n        int i=0,j=0;\\n        \\n        int c=0;\\n        int t =k;\\n        int fcount =0;\\n        int tcount = 0;\\n        for(int i=0;i<answerKey.length();i++){\\n            if(answerKey[i]==\\'T\\')tcount++;\\n            else\\n            fcount++;\\n        }\\n        if(fcount<=k)return answerKey.length();\\n        if(tcount<=k)return answerKey.length();\\n        #for true\\n        while(j<answerKey.length()){\\n            if(t==0 && answerKey[j]==\\'F\\'){\\n                res = max(res,j-i);\\n                while(t==0&&i<j){\\n                    if(answerKey[i]==\\'F\\')\\n                    t++;\\n\\n                    res = max(res,j-i);\\n                    i++;\\n\\n                }\\n\\n            }\\n            if(answerKey[j]==\\'F\\')\\n                t--;\\n         \\n            j++;\\n        }\\n        res = max(res,j-i);\\n\\n        #for false\\n        i=0,j=0;\\n        t=k;\\n          while(j<answerKey.length()){\\n            if(t==0 && answerKey[j]==\\'T\\'){\\n                res = max(res,j-i);\\n                while(t==0&&i<j){\\n                    if(answerKey[i]==\\'T\\')\\n                    t++;\\n\\n                    res = max(res,j-i);\\n                    i++;\\n\\n                }\\n\\n            }\\n            if(answerKey[j]==\\'T\\')\\n                t--;\\n               \\n            j++;\\n        }\\n        res = max(res,j-i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730298,
                "title": "c-sliding-window-simple-and-fast-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\nThis problem is same as that of another problem \"**1493. Longest Subarray of 1\\'s After Deleting One Element**\"\\nthe difference is that\\n1) In this problem we are considering \\'1\\' as \\'T\\' and \\'0\\' as \\'F\\'.\\n\\n2) In previous problem we can consider at max single \\'0\\' in our sub_array for finding max length of the subarray with only \\'1\\' and at max one \\'0\\'. like 1111011111111, 101111, 11111, etc are the required sub arrays of that question \\n\\nIn this problem instead of at_max single \\'F\\', we can take at max \\'k\\' number of \\'F\\' , when we are finding the max length of subarray containing at max \\'k\\' number of \\'F\\' and any number of \\'T\\'\\n\\nand when we are also finding the max length of subarray containing at max \\'k\\' number of \\'T\\' and any number of \\'F\\'.\\n\\n\\nAfter that we are returning max length among the two.\\n\\n# Approach\\nApproach is same as this solution-->\\nhttps://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/solutions/3719568/beat-s-100-c-java-python-beginner-friendly/\\n\\n# Complexity\\n- Time complexity:\\nO[N]\\n- Space complexity:\\nO[1]\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int max_len_sub_array(string& anskey, char tar, char n_tar, int k)\\n    {\\n        int max_len=0, len=0;\\n        int i=0, j=0;\\n\\n        while(j<anskey.size())\\n        {\\n            if(anskey[j]==n_tar && k>0)\\n            {\\n                k--;\\n                j++;\\n                continue;\\n            }\\n            else if(anskey[j]==tar)\\n            {\\n                j++;\\n                continue;\\n            }\\n\\n            max_len=max(max_len, (j-1)-i+1);\\n\\n            while(k==0)\\n            {\\n                if(anskey[i]==n_tar)\\n                {\\n                    k++;\\n                    i++;\\n                    break;\\n                }\\n\\n                i++;\\n            }\\n        }\\n\\n        max_len=max(max_len, (j-1)-i+1);\\n        return max_len;\\n    }\\n\\n    int maxConsecutiveAnswers(string anskey, int k) \\n    {\\n        int len_T=max_len_sub_array(anskey, \\'T\\', \\'F\\', k);\\n        int len_F=max_len_sub_array(anskey, \\'F\\', \\'T\\', k);\\n\\n        return max(len_T, len_F);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_len_sub_array(string& anskey, char tar, char n_tar, int k)\\n    {\\n        int max_len=0, len=0;\\n        int i=0, j=0;\\n\\n        while(j<anskey.size())\\n        {\\n            if(anskey[j]==n_tar && k>0)\\n            {\\n                k--;\\n                j++;\\n                continue;\\n            }\\n            else if(anskey[j]==tar)\\n            {\\n                j++;\\n                continue;\\n            }\\n\\n            max_len=max(max_len, (j-1)-i+1);\\n\\n            while(k==0)\\n            {\\n                if(anskey[i]==n_tar)\\n                {\\n                    k++;\\n                    i++;\\n                    break;\\n                }\\n\\n                i++;\\n            }\\n        }\\n\\n        max_len=max(max_len, (j-1)-i+1);\\n        return max_len;\\n    }\\n\\n    int maxConsecutiveAnswers(string anskey, int k) \\n    {\\n        int len_T=max_len_sub_array(anskey, \\'T\\', \\'F\\', k);\\n        int len_F=max_len_sub_array(anskey, \\'F\\', \\'T\\', k);\\n\\n        return max(len_T, len_F);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730225,
                "title": "c-sliding-window-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(string &s,int k,char c)\\n    {\\n        int sz=s.size(),temp=k;\\n        int i=0,start=0;\\n        int cnt=0,maxm=0;\\n        while(i<sz)\\n        {   \\n            if(s[i]==c)cnt++;\\n            else\\n            {\\n                cnt++,k--;\\n                while(k<0)\\n                {\\n                    if(s[start]!=c)k++;\\n                    start++;\\n                    cnt--;\\n                }\\n                \\n            }\\n            i++;\\n           maxm=max(maxm,cnt);\\n        }\\n        return maxm;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans=0;\\n        ans=max(ans,helper(answerKey,k,\\'T\\'));\\n        ans=max(ans,helper(answerKey,k,\\'F\\'));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &s,int k,char c)\\n    {\\n        int sz=s.size(),temp=k;\\n        int i=0,start=0;\\n        int cnt=0,maxm=0;\\n        while(i<sz)\\n        {   \\n            if(s[i]==c)cnt++;\\n            else\\n            {\\n                cnt++,k--;\\n                while(k<0)\\n                {\\n                    if(s[start]!=c)k++;\\n                    start++;\\n                    cnt--;\\n                }\\n                \\n            }\\n            i++;\\n           maxm=max(maxm,cnt);\\n        }\\n        return maxm;\\n    }\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        int ans=0;\\n        ans=max(ans,helper(answerKey,k,\\'T\\'));\\n        ans=max(ans,helper(answerKey,k,\\'F\\'));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730215,
                "title": "cakewalk-easy-to-understand-solution-using-two-pointers-approach",
                "content": "**Intuition :**\\nWe can observe that the maximum continous subarray will be either of F or T and we will try to find out for both the possibilities . We will use the K given to us to change the element other than the target one in the window.\\n**Approach :**\\nFirst Try to find out maximum consecutive elements of character T by considering F as the element which you can change with a cost  and then try similar for character F . Our answer will be maximum of those two . \\n**Algorithm :**\\n1. Since we can observe that we have to find out the maximum sized window , we will use two pointers for that and maintain a variable cnt which will cnt the element other than the target one .\\n2. We will increment the cnt if we encounter the element other than the target and if the cnt of the current window(subarray) exceeds k we will start decreasing the size of the window .\\n3. We will take maximum of both possibilites and return as anwer .  \\n\\n**Time and Space Complexity :** TC is O(n) and SC is O(1). \\n\\n```\\nclass Solution {\\npublic:\\n    int func(string &s , int k , char ch){\\n        int n = s.size();\\n        int ans = 0 ;\\n        int cnt = 0 ;\\n        int l=0 , r = 0 ;\\n        while(r < n){\\n            if(s[r] != ch) cnt++;\\n            while(l <= r && cnt > k){\\n                if(s[l]!=ch) cnt--;\\n                l++;\\n            }\\n            ans = max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans ;\\n    }\\n    \\n    \\n    \\n    \\n    int maxConsecutiveAnswers(string s , int k) {\\n        int ans = max(func(s,k,\\'T\\'),func(s,k,\\'F\\'));\\n        return ans ;\\n    }\\n};\\n```\\n\\nIf You want to pratice similar problems and understand the concept further :\\nhttps://codeforces.com/edu/course/2/lesson/9\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(string &s , int k , char ch){\\n        int n = s.size();\\n        int ans = 0 ;\\n        int cnt = 0 ;\\n        int l=0 , r = 0 ;\\n        while(r < n){\\n            if(s[r] != ch) cnt++;\\n            while(l <= r && cnt > k){\\n                if(s[l]!=ch) cnt--;\\n                l++;\\n            }\\n            ans = max(ans,r-l+1);\\n            r++;\\n        }\\n        return ans ;\\n    }\\n    \\n    \\n    \\n    \\n    int maxConsecutiveAnswers(string s , int k) {\\n        int ans = max(func(s,k,\\'T\\'),func(s,k,\\'F\\'));\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1959351,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1903060,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959404,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959315,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959293,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959305,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1825044,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959388,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959294,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959365,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959351,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1903060,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959404,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959315,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959293,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959305,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1825044,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959388,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959294,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959365,
                "content": [
                    {
                        "username": "aceanojjj",
                        "content": "We are all becoming masters of \\'sliding window\\' after this week \\uD83E\\uDD23"
                    },
                    {
                        "username": "Pranav_84",
                        "content": "Yes true words ! "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It was needed actually. Sliding window is easy topic but we don\\'t pay much attention to it individually though. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@cecilia5](/cecilia5) I still like it, usually it\\'s not a big hint that you have to use a certain technique, and it is good to practice the same thing a couple of days in a row. Granted that in a competitive setting you won\\'t get any hints, but you can do the competitions in the weekend, or do some random problems as well."
                    },
                    {
                        "username": "cecilia5",
                        "content": "This is almost annoying - the fact that Leetcode always pack problems of similar types together is no different from feeding me with the hint that this is sliding window again. I don\\'t want hint! This is not what I will get in a competition or an interview."
                    },
                    {
                        "username": "Saptarshi_Bose123-7",
                        "content": "I can definitely see that."
                    },
                    {
                        "username": "Ultron03",
                        "content": "hahahaha.."
                    },
                    {
                        "username": "barnik_b",
                        "content": "Typical sliding window problem. An intuitive way to solve this to keep track of the count of Ts and Fs. The window becomes invalid when the minimum of these 2 counts exceeds k."
                    },
                    {
                        "username": "pranayrv12",
                        "content": "One line change, and the whole code worked, thank you!"
                    },
                    {
                        "username": "flshdrcrd",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "aitachii",
                        "content": "This tip was more efficient than my solution. Thank you."
                    },
                    {
                        "username": "thammayya",
                        "content": "thanks for tip\\n"
                    },
                    {
                        "username": "matthew106",
                        "content": "Literally once I saw this comment it clicked... I was almost there, but the \"minimum of these 2 counts exceeds k\" part clicked everything into place."
                    },
                    {
                        "username": "Lynross",
                        "content": "Thanks!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you this helped me solve the problem!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Leet Code writing daily challenges by maximizing the number of consecutive questions with sliding window.. :-)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "I\\'m getting better on sliding window questions. Thanks LeetCode."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This time, Leetcode is the teacher who gives an unclear test. The students must guess what the question really means."
                    },
                    {
                        "username": "AhmadAQ",
                        "content": "same question as:\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@ALS_Venky](/ALS_Venky) \n\n[Check this](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730510/c-java-sliding-window-similar-problems/)\n\nIts still similar because we could keep two characters as\n1 - The character we consider for longest substring\n2 - All the other characters.\n\nIts pretty similar as the solution follows exact sliding window approach"
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "no, because that question doesn\\'t have only 2 characters.\\nits more similar to https://leetcode.com/problems/max-consecutive-ones-iii/ this question"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Also very similar to [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/description/) in disguise."
                    },
                    {
                        "username": "sushilrawat1720",
                        "content": "We either have to make largest T(true) string or largest F(false) string after performing maximum k operation.\\n\\nTip : Think of as sliding window."
                    },
                    {
                        "username": "psionl0",
                        "content": "I was pretty sure that I had tackled a similar problem before:\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Yaa its the same problem, its just we have to find max between consecutive zeroes and consecutive ones"
                    },
                    {
                        "username": "natitati",
                        "content": "Lmao this is relatable"
                    },
                    {
                        "username": "iamvikash",
                        "content": "I just used sliding window two times, one for finding longest string with \\'T\\'  after k operation and then tried for \\'F\" returned the max len possible from both. \\nsimilar to : https://leetcode.com/problems/longest-repeating-character-replacement/"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "How to just go once over it:\\nAssume smaller count is swapcount, bigger is len of elems unswapped.\\n\\nHere a bit more detailed if needed: https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733128/easiest-slidingwin-w-o-binsearch-purec-python/"
                    },
                    {
                        "username": "hammeramr",
                        "content": "Thats the hint that made it click for me without giving the answer - kudos ( already had sliding window implemented before reading this)"
                    }
                ]
            },
            {
                "id": 1959984,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1959970,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1960261,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1959767,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1959576,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1959327,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1987940,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1960464,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1960454,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1960433,
                "content": [
                    {
                        "username": "santanusen",
                        "content": "Damn! I struggled trying to solve it with DP and hit all sorts of limit exceeded."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "It's possible to use a shortcut\n```if (k >= answerKey.count / 2) { return answerKey.count }```\nbecause in this case we can always get a homogenous string by changing those answer keys that are fewer."
                    },
                    {
                        "username": "rohithKarnati",
                        "content": "Yeah I think I\\'m getting better using Sliding Window"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "isn\\'t this similar to 0\\'s and 1\\'s problem\\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Think...\\n\\'Consecutive Entries\\' -> Strikes a Chord ? -> Sliding Window Problem \\nWhenever we encounter terms like \\'longest consecutive\\', \\'longest contiguous\\', \\'subarray\\', \\'substring\\', give Sliding Window a shot.\\n\\nNow a hint for the Sliding Window :\\nFor each Window, that contains T,F, values,\\nHow many contradicting values can we afford?\\nFor example \\nIf Window is TTFTT and K =2,\\nHow many more F can you afford to add?\\nThe answer is you can always afford to have min(T,F) count as contradicting variables. Because then we can replace min count in final step to get longest consecutive substring of all Ts, or all Fs.\\n\\nIn short, for any window, when Minimum of T/F Count exceeds K,\\nThe Window becomes Invalid.\\n\\nAdjust the Window Accordingly !"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "Three sliding window in a row"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "We are trying to maximize the window\\'s size."
                    },
                    {
                        "username": "eduard92",
                        "content": "Too tired at this moment for this one, doesn\\'t seem hard but sure it will drag me 1h "
                    },
                    {
                        "username": "sradmard",
                        "content": "How long is this supposed to take to figure out?"
                    },
                    {
                        "username": "hanelliotn",
                        "content": "3 days 3 sliding window problems in a row lol~ Guess this week\\'s contest will have them all"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn. I\\'m shocked with how simple this is if you understand sliding window."
                    }
                ]
            },
            {
                "id": 1960418,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1960239,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1960237,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1960206,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1960161,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1960035,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1959976,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1959943,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1959924,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1959815,
                "content": [
                    {
                        "username": "simply_arko",
                        "content": "**Critical Observation:** If you think carefully, the `min(true_count, false_count)` should always be less than `k` for the current window.\\nCheck out this [solution](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3733935/clean-o-n-beginner-friendly-sliding-window/) after trying out yourself."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "before looking at constraints i thought its again a DP problem but later realize the sliding window looking at the constraints but do we really need binary search here?"
                    },
                    {
                        "username": "pkjha0102",
                        "content": "Just solve independently for max T\\'s and max F\\'s in two independent passes and return max of both.\\nSame concept as https://leetcode.com/problems/max-consecutive-ones-iii/ "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Stucked at TC 82\\nclass Solution {\\npublic:\\n    int maxConsecutiveAnswers(string answerKey, int k) {\\n        // if(k>answerKey.size())return answerKey.size();\\n        // return 0;\\n        int tt=0;\\n        int tf=0;\\n        for(auto i:answerKey){\\n            if(i==\\'T\\')tt++;\\n            else tf++;\\n        }\\n        char ch = tt>tf?\\'T\\':\\'F\\';\\n        int n=answerKey.size();\\n        int s=0,e=0;\\n        int c=0,m=1;\\n        int other=0;\\n        while(e<n){\\n            if(answerKey[e]==ch)\\n            {c++;e++;}\\n            else if(other<k){\\n                c++;\\n                e++;\\n                other++;\\n            }else{\\n                while(answerKey[s]==ch)s++;\\n                s++;\\n                other--;\\n                c=e-s;\\n            }\\n            m=max(c,m);\\n        }\\n\\n        return m;\\n    }\\n};\\n\\nany suggestion \\n\\n"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Post the TC here"
                    },
                    {
                        "username": "Neo_codes",
                        "content": "How to practice more on Sliding window ?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Filter question with SLIDING WINDOW tags."
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to **Sliding Window** week \\uD83D\\uDC4D"
                    },
                    {
                        "username": "Ultron03",
                        "content": "leetcode crush now-a-days..\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "whyprax",
                        "content": "sliding window is weird"
                    },
                    {
                        "username": "SG-C",
                        "content": "same question as tomorrow even Solution also same just little condition change "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "Try :-\n1) Longest Repeating Character Replacement : https://leetcode.com/problems/longest-repeating-character-replacement/\n\n\n2) Max Consecutive Ones III : https://leetcode.com/problems/max-consecutive-ones-iii/\n\nbefore solving this."
                    }
                ]
            },
            {
                "id": 1959810,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959763,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959717,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959692,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959673,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959670,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959668,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959648,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959642,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959598,
                "content": [
                    {
                        "username": "saadkhan123456789",
                        "content": "OH...the edge cases....\\n"
                    },
                    {
                        "username": "Lsfhv",
                        "content": "I feel like atleast one of my teachers has done this before lmao"
                    },
                    {
                        "username": "rohit_2345",
                        "content": "come here after solving this question\\nhttps://leetcode.com/problems/max-consecutive-ones-iii/"
                    },
                    {
                        "username": "j0sal",
                        "content": "Here i can confidently say that previous questions were helpful."
                    },
                    {
                        "username": "maanyagarg",
                        "content": "sliding window week?\\n"
                    },
                    {
                        "username": "Shubh2407",
                        "content": "I guess we are gonna have only windows this week\\n\\nHINT(I recommend doing 1493 first): \\n\\n1493. Longest Subarray of 1\\'s After Deleting One Element -> here we need to find max window of consecutive one\\'s with at most 1 zero.\\n\\nIn current problem just check for both T and F separately and find max of both ans.\\n\\ncheck my solution here:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730982/easy-solution-beats-80-on/"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\nApply sliding window. \\nRun from 0 to n for 2 times . for both True and False.\\n\\n# Complexity\\n- Time complexity:\\nT.C=O(2n) two time function call which run till n. for \\'T\\' and \\'F\\'.\\n\\n- Space complexity:\\nS.C=O(1)\\n----------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730985/c-easy-sliding-window/"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Oh wow so many sliding windows...why is leetcode being so generous \\uD83D\\uDC80 "
                    },
                    {
                        "username": "vivek_arora",
                        "content": "Day after day sliding window :)"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Did it using binary search  XD then realised it is simple sliding window"
                    }
                ]
            },
            {
                "id": 1959595,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1959558,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1959551,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1959525,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1959471,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1959393,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1959370,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1959316,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1738028,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            },
            {
                "id": 1691771,
                "content": [
                    {
                        "username": "poorvi-vaish",
                        "content": "class Solution {\npublic:\n    int maxConsecutiveAnswers(string a, int k) {\n        int t=0, f=0, l=0, r=0, ans=0;\n        while(r < a.length()){\n            if (a[r] == 'T') t++;\n            else f++;\n            if (min(t, f) > k){\n                ans = max(ans, t+f-1);\n                t=0;\n                f=0;\n                r=l+1;\n                l++;\n                continue;\n            }\n            r++;\n        }\n        if(min(t,f) <= k) ans = max(ans, t+f);\n        if (ans == 0) return a.length();\n        return ans;\n    }\n};\nCan anyone help me with this one? I'm getting TLE on some edge cases."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "try better naming convention for your variables or you will forget your own code logic after few days. I did the same mistake. Or simply try commenting before taking short variables."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "it is n^2 in worst case , try not changing right pointer to start over"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Sliding window watching us from distance :)"
                    },
                    {
                        "username": "jason3410",
                        "content": "I do it with sliding window for two loop, one is T-based ie. trying to remove F, and another loop is F-base,then just select the longer one. It is naive but quite intuitive."
                    },
                    {
                        "username": "ayush1505",
                        "content": "Sliding Window Week :)"
                    },
                    {
                        "username": "sigmale",
                        "content": "Max Consecutive ones III, the almost same problem"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Took me a while to realize it was sliding window. There is this edge case, sometimes `min(true, false) > k` is true after the inner loop and sometimes its not."
                    },
                    {
                        "username": "_vedant",
                        "content": "Sliding window in a row "
                    },
                    {
                        "username": "balcortex",
                        "content": "3 consecutive days of sliding window problems, and 3 days of streak ."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "I guess the question is bit incomplete, could any one explain?"
                    },
                    {
                        "username": "Prabhash_Varma_3_6",
                        "content": "[@vmikhieienko](/vmikhieienko)  It should be longest subarray*"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Basically, you need to find the longest subsequence of `T` or `F` in the input, considering you may replace any element you want with the opposite one `k` times or less."
                    },
                    {
                        "username": "Vishalpatel_",
                        "content": "Didn\\'t understand the question properly.\\nCan anyone help?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Make the longest consecutive \"T\" or \"F\" string by changing K amount of characters in the string.\\n\\nInputs: \"TTFTT\", k = 1\\nLongest string I can make is \"TTTTT\" by changing the F in the middle.\\nSo output is 5\\n\\nInputs: \"TTFTFTFTTFT, k = 2\\nLongest string I can make is \"TTFTFTTTTTT by changing the last two F\\'s to be Ts.\\nSo output is 6\\n"
                    },
                    {
                        "username": "spieles21",
                        "content": "Your Goal is to find the longest row of ever \\'T\\'s or \\'F\\'s. You are allowed to change X times a Char to the opposed one.\\n\\n\\'answerKey\\' is your input string\\n\\'k\\' is how often you could change a char"
                    }
                ]
            }
        ]
    }
]