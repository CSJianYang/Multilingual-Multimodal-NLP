[
    {
        "title": "Minimum Operations to Halve Array Sum",
        "question_content": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\nReturn the minimum number of operations to reduce the sum of nums by at least half.\n&nbsp;\nExample 1:\n\nInput: nums = [5,19,8,1]\nOutput: 3\nExplanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 19 and reduce it to 9.5.\nPick the number 9.5 and reduce it to 4.75.\nPick the number 8 and reduce it to 4.\nThe final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \nThe sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\nExample 2:\n\nInput: nums = [3,8,20]\nOutput: 3\nExplanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 20 and reduce it to 10.\nPick the number 10 and reduce it to 5.\nPick the number 3 and reduce it to 1.5.\nThe final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. \nThe sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 107",
        "solutions": [
            {
                "id": 1863899,
                "title": "python3-java-c-priority-queue-o-nlogn",
                "content": "* First find sum of array\\n* Put all the elements in a Max heap or a priority queue such that popping the queue gives you the max element\\n* `k` is current sum of halved elements\\n* While sum of array - `k` > sum of array / 2, pop an element out of the `pq`, half it, add it to `k` and `pq`\\n<iframe src=\"https://leetcode.com/playground/mKaXTnzp/shared\" frameBorder=\"0\" width=\"620\" height=\"310\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "* First find sum of array\\n* Put all the elements in a Max heap or a priority queue such that popping the queue gives you the max element\\n* `k` is current sum of halved elements\\n* While sum of array - `k` > sum of array / 2, pop an element out of the `pq`, half it, add it to `k` and `pq`\\n<iframe src=\"https://leetcode.com/playground/mKaXTnzp/shared\" frameBorder=\"0\" width=\"620\" height=\"310\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1863888,
                "title": "java-python-3-priorityqueue-heap-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\n*Q1:* Why in `PriorityQueue<Double> pq=new PriorityQueue<>((a,b)->b-a);` the lambda expression does not work with `double`?\\n*A1:*  Not very sure, but I guess it is because that in Java `Comparator` interface there is only one `int compare(T o1, T o2)` method, of which the return type is `int`. Please refer to [Java 8 Comparator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html).\\n\\nYou can use `Math.signum` to convert `double` to `int` as follows:\\n```java\\n        PriorityQueue<Double> pq = new PriorityQueue<Double>((a, b) -> (int)Math.signum(b - a));\\n```\\n\\n\\n*Q2:* `Math.signum()` returns only 3 values(double) i.e `1.0, -1.0, 0.0`. Then how exactly sorting is happening in above lambda expression `(a, b) -> (int)Math.signum(b - a)`?\\n*A2:*  The returning 3 values are enough for comparing `2` elements in the array.\\n\\n`Arrays.sort(Object[])` uses Tim sort. The sorting algorithms like Tim Sort, Merge Sort, Quick Sort, and Heap Sort, etc.,  are comparison (of `2` elements) based. Therefore, we only need to know the result of each comparison between `2` elements: `<`, `=`, `>`, which we can get conclusion from the returning values `-1.0`, `0.0`, `1.0`.\\n\\n\\n*Q3:* How does this work?\\n```java\\nPriorityQueue pq = new PriorityQueue((a, b) -> b.compareTo(a));\\n```\\n*A3:* `compareTo` is the method in `Comparable` interface and you can refer to [Java 8 Comparable Interface](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html).\\n\\n`int compareTo(T o)`\\n\\n\"Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\\n\\n...\"\\n\\n\\n*Q4:* And when to use `(b-a)` and when to use `b.compareTo(a)` in lambda expressions?\\n*A4:* I would choose `b.compareTo(a)` if `(b - a)` could cause overflow. e.g, `a` and `b` are both `int` or `long` and `a = Integer.MIN_VALUE or Long.MIN_VALUE`.\\n\\nHowever, in case of no overflow, either is good to use.\\n\\n**Correct me if I am wrong.**\\n\\n\\n**End of Q & A**\\n\\n----\\n\\nAlways reduce current max value by half.\\n\\n1. Compute the `half` of the sum of the input `nums`;\\n2. Put all `nums` into a PriorityQueue/heap by reverse order;\\n3. Poll out and cut the current max value by half and add it back to PriorityQueue/ heap, deduct the `half` of the sum accordingly and increase the counter `ops` by 1;\\n4. Repeat 3 till `half <= 0`, then return `ops`.\\n```java\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());    \\n        double half = IntStream.of(nums).mapToLong(i -> i).sum() / 2d;\\n        for (int n : nums) {\\n            pq.offer((double)n);\\n        }\\n        int ops = 0;\\n        while (half > 0) {\\n            double d = pq.poll();\\n            d /= 2;\\n            half -= d;\\n            pq.offer(d);\\n            ++ops;\\n        }\\n        return ops;\\n    }\\n```\\n\\n```python\\n    def halveArray(self, nums: List[int]) -> int:\\n        half, ops = sum(nums) / 2, 0\\n        heap = [-num for num in nums]\\n        heapify(heap)\\n        while half > 0:\\n            num = -heappop(heap)\\n            num /= 2.0\\n            half -= num\\n            heappush(heap, -num)\\n            ops += 1\\n        return ops\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n        PriorityQueue<Double> pq = new PriorityQueue<Double>((a, b) -> (int)Math.signum(b - a));\\n```\n```java\\nPriorityQueue pq = new PriorityQueue((a, b) -> b.compareTo(a));\\n```\n```java\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());    \\n        double half = IntStream.of(nums).mapToLong(i -> i).sum() / 2d;\\n        for (int n : nums) {\\n            pq.offer((double)n);\\n        }\\n        int ops = 0;\\n        while (half > 0) {\\n            double d = pq.poll();\\n            d /= 2;\\n            half -= d;\\n            pq.offer(d);\\n            ++ops;\\n        }\\n        return ops;\\n    }\\n```\n```python\\n    def halveArray(self, nums: List[int]) -> int:\\n        half, ops = sum(nums) / 2, 0\\n        heap = [-num for num in nums]\\n        heapify(heap)\\n        while half > 0:\\n            num = -heappop(heap)\\n            num /= 2.0\\n            half -= num\\n            heappush(heap, -num)\\n            ops += 1\\n        return ops\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1863943,
                "title": "max-heap",
                "content": "I was thinking that a straightforward solution will get TLE, and we need some clever way to halve large numbers.\\n\\nThen I realized that large numbers would also reduce `sum` quite a lot, so I went for the straightforward one.\\n\\n**C++**\\n```cpp\\nint halveArray(vector<int>& nums) {\\n    double sum = accumulate(begin(nums), end(nums), 0.0), orig = sum, cnt = 0;\\n    priority_queue<double> pq(begin(nums), end(nums));\\n    for (; sum * 2 > orig; ++cnt) {\\n        double n = pq.top(); pq.pop();\\n        sum -= n / 2; \\n        pq.push(n / 2);     \\n    }\\n    return cnt;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint halveArray(vector<int>& nums) {\\n    double sum = accumulate(begin(nums), end(nums), 0.0), orig = sum, cnt = 0;\\n    priority_queue<double> pq(begin(nums), end(nums));\\n    for (; sum * 2 > orig; ++cnt) {\\n        double n = pq.top(); pq.pop();\\n        sum -= n / 2; \\n        pq.push(n / 2);     \\n    }\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864074,
                "title": "c-python-explained-easy-to-understand-clean-concise-greedy-solution-tc-nlogn",
                "content": "**Intuition**\\n* On observing example cases first idea is to use greedy approach use the maximum value to subtract, because that will help us to attin the goal faster.\\n* for example, [5,19,8,1]\\n* maximum is 19, so subtract its half, 19-19/2 = 9.5\\n* Now array is [5, 9.5, 8, 1]\\n* Now maximum is 9.5 so subtract its half, 9.5 - 9.5/2 = 4.75\\n* Now array is [5, 4.5, 8, 1], maximum is 8, so now choose 8 and subtract its half\\n* Now array is [5, 4, 4, 1]\\n* Now as the sum of array becomes at least half of the initial sum so return number of steps\\n\\n   **C++**\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n\\t\\tpriority_queue<double> pq;\\n        double totalSum = 0;\\n        double requiredSum = 0;\\n        for(auto x: nums){\\n            totalSum += x;\\n            pq.push(x);\\n        }\\n        \\n        requiredSum = totalSum/2;\\n        int minOps = 0;\\n        while(totalSum > requiredSum){\\n            double currtop = pq.top();\\n            pq.pop();\\n            currtop = currtop/2;\\n            totalSum -= currtop;\\n            pq.push(currtop);\\n            minOps++;\\n        }\\n        return minOps;\\n\\t}\\n}\\n\\t\\t\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        # Creating empty heap\\n        maxHeap = []\\n        heapify(maxHeap) # Creates minHeap \\n        \\n        totalSum = 0\\n        for i in nums:\\n            # Adding items to the heap using heappush\\n            # for maxHeap, function by multiplying them with -1\\n            heappush(maxHeap, -1*i) \\n            totalSum += i\\n        \\n        requiredSum = totalSum / 2\\n        minOps = 0\\n        \\n        while totalSum > requiredSum:\\n            x = -1*heappop(maxHeap) # Got negative value make it positive\\n            x /= 2\\n            totalSum -= x\\n            heappush(maxHeap, -1*x) \\n            minOps += 1\\n        \\n        return minOps\\n```\\n\\n**Upvote if you like and comment if you have doubt**",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n\\t\\tpriority_queue<double> pq;\\n        double totalSum = 0;\\n        double requiredSum = 0;\\n        for(auto x: nums){\\n            totalSum += x;\\n            pq.push(x);\\n        }\\n        \\n        requiredSum = totalSum/2;\\n        int minOps = 0;\\n        while(totalSum > requiredSum){\\n            double currtop = pq.top();\\n            pq.pop();\\n            currtop = currtop/2;\\n            totalSum -= currtop;\\n            pq.push(currtop);\\n            minOps++;\\n        }\\n        return minOps;\\n\\t}\\n}\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        # Creating empty heap\\n        maxHeap = []\\n        heapify(maxHeap) # Creates minHeap \\n        \\n        totalSum = 0\\n        for i in nums:\\n            # Adding items to the heap using heappush\\n            # for maxHeap, function by multiplying them with -1\\n            heappush(maxHeap, -1*i) \\n            totalSum += i\\n        \\n        requiredSum = totalSum / 2\\n        minOps = 0\\n        \\n        while totalSum > requiredSum:\\n            x = -1*heappop(maxHeap) # Got negative value make it positive\\n            x /= 2\\n            totalSum -= x\\n            heappush(maxHeap, -1*x) \\n            minOps += 1\\n        \\n        return minOps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864039,
                "title": "c-heap-straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0;\\n\\t    priority_queue<double> p;\\n        for(auto x : nums) {\\n\\t\\t     sum += x;\\n             p.push(x);\\n\\t\\t}\\n        double ans = sum;\\n        int cnt = 0;\\n        while(sum > ans/2.0){\\n            cnt++;\\n            double top = p.top();\\n            p.pop();\\n            sum -= top/2.0;\\n            top = top/2.0;\\n            p.push(top);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0;\\n\\t    priority_queue<double> p;\\n        for(auto x : nums) {\\n\\t\\t     sum += x;\\n             p.push(x);\\n\\t\\t}\\n        double ans = sum;\\n        int cnt = 0;\\n        while(sum > ans/2.0){\\n            cnt++;\\n            double top = p.top();\\n            p.pop();\\n            sum -= top/2.0;\\n            top = top/2.0;\\n            p.push(top);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864110,
                "title": "java-priority-queue",
                "content": "```\\n    public static int halveArray(int[] nums) {\\n        Queue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum = 0, cur = 0;\\n        for(int val : nums){\\n            sum += val;\\n            pq.add((double)val);\\n        }\\n        int count = 0;\\n        while(cur < sum/2) {\\n            double val = pq.poll()/2;\\n            cur += val;\\n            pq.add(val);\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int halveArray(int[] nums) {\\n        Queue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum = 0, cur = 0;\\n        for(int val : nums){\\n            sum += val;\\n            pq.add((double)val);\\n        }\\n        int count = 0;\\n        while(cur < sum/2) {\\n            double val = pq.poll()/2;\\n            cur += val;\\n            pq.add(val);\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864164,
                "title": "c-solution-priority-queue",
                "content": "At each iteration, we should perform the operation on the maximum element. Because if the element is maximum, it\\'s half will also be maximum among all halves. Thus reducing the sum by maximum possible.\\n\\n- Insert all values in the priotiy queue\\n- In each iteration, Pop the maximum element, removed it\\'s half from sum. Add back the halved value to PQ if it\\'s not zero.\\n-  Keep repeating untill the half of initial sum becomes zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        long long sum = 0;\\n        for (int x : nums) {\\n            sum += x;\\n            pq.push(x);\\n        }\\n        \\n        double half = (double)sum / 2.0;\\n        int answer = 0;\\n        \\n        while (half > 0) {\\n            double max = pq.top();\\n            pq.pop();\\n            \\n            max /= 2.0;\\n            half -= max;\\n            \\n            if (max > 0) {\\n                pq.push(max);\\n            }\\n            \\n            answer++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        long long sum = 0;\\n        for (int x : nums) {\\n            sum += x;\\n            pq.push(x);\\n        }\\n        \\n        double half = (double)sum / 2.0;\\n        int answer = 0;\\n        \\n        while (half > 0) {\\n            double max = pq.top();\\n            pq.pop();\\n            \\n            max /= 2.0;\\n            half -= max;\\n            \\n            if (max > 0) {\\n                pq.push(max);\\n            }\\n            \\n            answer++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864016,
                "title": "intuition-explained-priority-queue-c-clean-code",
                "content": "**Intuition :**\\n\\n* In order to reduce sum to half in minimum operations, we need to reduce **largest elements first**.\\n\\n* So that sum can be reduced significantly, in less number of operations.\\n* And to get largest elements first, we can use **Max Heap / Priority Queue**.\\n\\n# Code : \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        double sum = accumulate(nums.begin(), nums.end(), 0.00);\\n        double halfSum = sum / 2;\\n        \\n        priority_queue<double> pq;\\n        \\n        for(auto& num : nums) pq.push((double)num);\\n        \\n        int operations = 0;\\n        \\n        while(pq.size() and sum > halfSum) {\\n            double item = pq.top(); pq.pop();\\n            \\n            sum -= item/2.00;\\n            \\n            item /= 2.00;\\n            \\n            operations++;\\n            \\n            if(item>0) pq.push(item);\\n        }\\n        return operations;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(NlogN)`\\n* Space : `O(N)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        double sum = accumulate(nums.begin(), nums.end(), 0.00);\\n        double halfSum = sum / 2;\\n        \\n        priority_queue<double> pq;\\n        \\n        for(auto& num : nums) pq.push((double)num);\\n        \\n        int operations = 0;\\n        \\n        while(pq.size() and sum > halfSum) {\\n            double item = pq.top(); pq.pop();\\n            \\n            sum -= item/2.00;\\n            \\n            item /= 2.00;\\n            \\n            operations++;\\n            \\n            if(item>0) pq.push(item);\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963396,
                "title": "max-heap-easy-to-understand-80-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> p;\\n        double sum=0.0;\\n        for(auto it:nums)\\n        {\\n            p.push(it);\\n            sum+=it;\\n        }\\n        double req=sum/2.0;\\n        double currsum=0.0;\\n        int c=0;\\n        while(currsum<req)\\n        {\\n            double x=p.top();\\n            p.pop();\\n            double m=x/2.0;\\n            p.push(m);\\n            c++;\\n            currsum+=m;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> p;\\n        double sum=0.0;\\n        for(auto it:nums)\\n        {\\n            p.push(it);\\n            sum+=it;\\n        }\\n        double req=sum/2.0;\\n        double currsum=0.0;\\n        int c=0;\\n        while(currsum<req)\\n        {\\n            double x=p.top();\\n            p.pop();\\n            double m=x/2.0;\\n            p.push(m);\\n            c++;\\n            currsum+=m;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881432,
                "title": "java-priority-queue",
                "content": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> q = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int i:nums){\\n            sum+=(double)i;\\n            q.add((double)i);\\n        }\\n        int res=0;\\n        double req = sum;\\n        while(sum > req/2){\\n            double curr = q.poll();\\n            q.add(curr/2);\\n            res++;\\n            sum -= curr/2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> q = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int i:nums){\\n            sum+=(double)i;\\n            q.add((double)i);\\n        }\\n        int res=0;\\n        double req = sum;\\n        while(sum > req/2){\\n            double curr = q.poll();\\n            q.add(curr/2);\\n            res++;\\n            sum -= curr/2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864544,
                "title": "java-heap-max-simple-easy-clean-readable-code",
                "content": "\\nDONT FORGET TO USE **DOUBLE**.\\n```MY DUMB A** HAD TO REVISE ABOUT LONG VS DOUBLE VS FLOAT IN JAVA \\uD83E\\uDD72```\\n\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        int minimumOperation = 0;\\n        double sum = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for (int x : nums) {\\n            sum += x;\\n            pq.add((double) x);\\n        }\\n\\n        double tempSum = sum;\\n        double requiredSum = sum / 2;\\n        while (tempSum > requiredSum) {\\n\\n            double peekElement = pq.poll();\\n            peekElement /= 2;\\n            tempSum -= peekElement;\\n            pq.offer(peekElement);\\n            minimumOperation++;\\n        }\\n\\n        return minimumOperation;\\n    }\\n}\\n```\\n**HOPE YOU LIKED IT\\nUPVOTE IF HELPFUL\\uD83D\\uDE4F \\uD83C\\uDFFB**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```MY DUMB A** HAD TO REVISE ABOUT LONG VS DOUBLE VS FLOAT IN JAVA \\uD83E\\uDD72```\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        int minimumOperation = 0;\\n        double sum = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for (int x : nums) {\\n            sum += x;\\n            pq.add((double) x);\\n        }\\n\\n        double tempSum = sum;\\n        double requiredSum = sum / 2;\\n        while (tempSum > requiredSum) {\\n\\n            double peekElement = pq.poll();\\n            peekElement /= 2;\\n            tempSum -= peekElement;\\n            pq.offer(peekElement);\\n            minimumOperation++;\\n        }\\n\\n        return minimumOperation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864123,
                "title": "c-max-heap-explained-with-example-well-commented",
                "content": "### **Intuition:** \\nWe will follow greedy approach: find the largest number present in the array and reduce it by half. \\nIf you observe, we need to keep track of the largest number after every reduce-operation. The data structure that fits this description is max-heap. \\n\\n### **Example:**\\nnums = [3,8,20,10]\\nsum= 3+8+20+10 =41\\n\\ntarget = 41/2 =20.5\\n\\n* Make a priority queue: \\npq= [20,10,8,3]\\n\\n* Now, we\\'ll loop over the priority-queue and perform the reduce operation until sum becomes less than or equal to target\\n\\t1. top = 20\\n\\thalf = 20/10 =10\\n\\tsum =41-10 = 31\\n\\tpq = [10,10,8,3]\\n\\t\\n\\t2. top =10\\n\\thalf =10/2 = 5\\n\\tsum = 31-5 = 26\\n\\tpq = [10,8,5,3]\\n\\t\\n\\t3. top = 10\\n\\thalf = 10/2 = 5\\n\\tsum=26-5=21\\n\\tpq = [8,5,5,3]\\n\\t\\n\\t4. top = 8\\n\\thalf = 8/2 = 4\\n\\tsum = 21-4 = 17\\n\\tpq = [5,5,4,3]\\n\\t\\nAs the sum is less than 21.5, the minimum number of operations is **4** for the above example.\\n\\t\\n### **Code**\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;  // to store the highest number\\n        double sum=0;\\n        for(int n:nums){\\n            pq.push(n); // push all the elements in the priority queue\\n            sum+=n; // calculate the total sum\\n        }\\n        double target=sum/2;  // the target sum should be atleast sum/2\\n        int ans=0;\\n        while(sum>target){\\n            double tp=pq.top();  // the current largest element\\n            double np=tp/2.0;  // reducing the current largest element to its half\\n            sum-=np;   // update the sum \\n            pq.pop();   \\n            pq.push(np);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nA similar question: [Remove Stones to Minimize the Total](http://leetcode.com/problems/remove-stones-to-minimize-the-total)",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;  // to store the highest number\\n        double sum=0;\\n        for(int n:nums){\\n            pq.push(n); // push all the elements in the priority queue\\n            sum+=n; // calculate the total sum\\n        }\\n        double target=sum/2;  // the target sum should be atleast sum/2\\n        int ans=0;\\n        while(sum>target){\\n            double tp=pq.top();  // the current largest element\\n            double np=tp/2.0;  // reducing the current largest element to its half\\n            sum-=np;   // update the sum \\n            pq.pop();   \\n            pq.push(np);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864006,
                "title": "priorityqueue-easy-to-understand-explanation-with-commented-code",
                "content": "Intuituion: Greedily take the largest number at every point and add half of it to the sum. Put back half in array as well.\\n\\nPrrof: The closest you can get to reaching sum/2 in one turn is by choosing the largest number. We will not gain anything by taking any other number as *whatever sequence of moves we will do after taking another number, we can do after picking the largest number.* \\n\\nA priority queue allows us to fetch the max number, remove it and add back half of it all in O(log(n)). we will not require more than n steps (as simply taking every number in the original array and halving it will give sum/2).\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)\\n\\nCode:\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int count = 0;\\n        double sum = 0;\\n\\t\\t\\n\\t\\t//finding the sum of the array and queueing every element in the PriorityQueue\\n        for(int i : nums) {\\n            sum += i;\\n            pq.add((double)i);\\n        }\\n        double half_of_sum = sum / 2;\\n\\t\\t\\n        while(true) {\\n            double cur = pq.poll();        // get the max in the pq\\n            double halved = cur / 2;     // half of max\\n            sum -= (halved);                 // remove halved from tot sum\\n            count ++;                           // one more step has been done\\n            if(half_of_sum >= sum) {   // if the tot sum has been reduced to half_of_sum or less, we are done\\n                return count;\\n            }\\n            pq.add(halved);                // add back half of max\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int count = 0;\\n        double sum = 0;\\n\\t\\t\\n\\t\\t//finding the sum of the array and queueing every element in the PriorityQueue\\n        for(int i : nums) {\\n            sum += i;\\n            pq.add((double)i);\\n        }\\n        double half_of_sum = sum / 2;\\n\\t\\t\\n        while(true) {\\n            double cur = pq.poll();        // get the max in the pq\\n            double halved = cur / 2;     // half of max\\n            sum -= (halved);                 // remove halved from tot sum\\n            count ++;                           // one more step has been done\\n            if(half_of_sum >= sum) {   // if the tot sum has been reduced to half_of_sum or less, we are done\\n                return count;\\n            }\\n            pq.add(halved);                // add back half of max\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874274,
                "title": "c-without-priority-queue-optimized-o-nlogn",
                "content": "Please make a comment if you have any confusion. Thanks.\\n\\n```\\npublic int HalveArray(int[] nums)\\n        {\\n            double sum = 0;\\n            SortedDictionary<double, int> pq = new SortedDictionary<double, int>(Comparer<double>\\n                                                                        .Create((x,y) => y.CompareTo(x)));\\n            foreach (int n in nums)\\n            {\\n                sum += n;\\n                if (!pq.ContainsKey(n))\\n                    pq.Add(n, 1);\\n                else pq[n]++;\\n            }\\n\\n            double halfSum = (double)sum / 2;\\n            double curSum = 0;\\n\\n            int count = 0;\\n            double num = 0;\\n            while (pq.Count > 0 && curSum < halfSum)\\n            {\\n                num = pq.First().Key;\\n\\n                if (--pq[num] <= 0)\\n                    pq.Remove(num);\\n                num = num / 2;\\n                if (!pq.ContainsKey(num))\\n                    pq.Add(num, 1);\\n                else pq[num]++;\\n\\n                curSum += num;\\n                count++;\\n            }\\n\\n            return count;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int HalveArray(int[] nums)\\n        {\\n            double sum = 0;\\n            SortedDictionary<double, int> pq = new SortedDictionary<double, int>(Comparer<double>\\n                                                                        .Create((x,y) => y.CompareTo(x)));\\n            foreach (int n in nums)\\n            {\\n                sum += n;\\n                if (!pq.ContainsKey(n))\\n                    pq.Add(n, 1);\\n                else pq[n]++;\\n            }\\n\\n            double halfSum = (double)sum / 2;\\n            double curSum = 0;\\n\\n            int count = 0;\\n            double num = 0;\\n            while (pq.Count > 0 && curSum < halfSum)\\n            {\\n                num = pq.First().Key;\\n\\n                if (--pq[num] <= 0)\\n                    pq.Remove(num);\\n                num = num / 2;\\n                if (!pq.ContainsKey(num))\\n                    pq.Add(num, 1);\\n                else pq[num]++;\\n\\n                curSum += num;\\n                count++;\\n            }\\n\\n            return count;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864427,
                "title": "2208-c-easy-o-nlogn-solution-priority-queue",
                "content": "**Please upvote if you find this solution helpful**\\n**Approach:** \\n* Use priority queue to store elements and get maximum element at the top of the queue.\\n* Iterate over the elements put into queue and add into sum.\\n* then iterate while sum is less than half of total sum.\\n* while iterating we pick top most element, do half of it, subtract it from sum, add it into the queue, and increment count by 1.\\n* At the end,  return count\\n\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        //use priority queue to get max element at the top\\n        priority_queue<double> pq;      \\n        double sum = 0;\\n        int count = 0;\\n        \\n        //storing elements into queue\\n        for(int it : nums) {\\n            pq.push(it);\\n            sum += it;\\n        }\\n        \\n\\t\\t\\n        double goal = sum / 2;   \\n        while (sum > goal) \\n        {\\n            //get max element, divide it by 2, subtract from sum, and increase count till we get half of the sum\\n            auto num = pq.top();    \\n            pq.pop();\\n            sum -= num/2;           \\n            pq.push(num / 2);     \\n            count++;                    \\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        //use priority queue to get max element at the top\\n        priority_queue<double> pq;      \\n        double sum = 0;\\n        int count = 0;\\n        \\n        //storing elements into queue\\n        for(int it : nums) {\\n            pq.push(it);\\n            sum += it;\\n        }\\n        \\n\\t\\t\\n        double goal = sum / 2;   \\n        while (sum > goal) \\n        {\\n            //get max element, divide it by 2, subtract from sum, and increase count till we get half of the sum\\n            auto num = pq.top();    \\n            pq.pop();\\n            sum -= num/2;           \\n            pq.push(num / 2);     \\n            count++;                    \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864251,
                "title": "easy-c-priority-queue",
                "content": "Easy create a heap always pop the max and continue till given condition satisfies.\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double cur_sum = 0;\\n        for (auto x: nums)\\n            cur_sum += x;\\n        double original_sum = cur_sum;\\n        priority_queue<double> help;\\n        for(auto x: nums)\\n            help.push(x);\\n        \\n        long long ans = 0;\\n        \\n        while((original_sum - cur_sum)<(original_sum)/2){\\n            ans += 1;\\n            double temp = help.top();\\n            help.pop();\\n            cur_sum -= temp;\\n            cur_sum += (temp)/2;\\n            help.push((temp)/2);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double cur_sum = 0;\\n        for (auto x: nums)\\n            cur_sum += x;\\n        double original_sum = cur_sum;\\n        priority_queue<double> help;\\n        for(auto x: nums)\\n            help.push(x);\\n        \\n        long long ans = 0;\\n        \\n        while((original_sum - cur_sum)<(original_sum)/2){\\n            ans += 1;\\n            double temp = help.top();\\n            help.pop();\\n            cur_sum -= temp;\\n            cur_sum += (temp)/2;\\n            help.push((temp)/2);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864057,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum1=0 , sum2=0;\\n        priority_queue<double>q;\\n        for(auto x : nums){\\n            sum1+=x;\\n            q.push(x);\\n        }\\n        sum1= sum1/2;\\n        int count=0;\\n        while(sum2<sum1){\\n            double x= q.top();\\n            x=x/2;\\n            q.pop();\\n            q.push(x);\\n            sum2+=x;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum1=0 , sum2=0;\\n        priority_queue<double>q;\\n        for(auto x : nums){\\n            sum1+=x;\\n            q.push(x);\\n        }\\n        sum1= sum1/2;\\n        int count=0;\\n        while(sum2<sum1){\\n            double x= q.top();\\n            x=x/2;\\n            q.pop();\\n            q.push(x);\\n            sum2+=x;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863946,
                "title": "c-priority-queue-simple-and-easy-code",
                "content": "Pick the greatest element greedily and divide by 2.0 and substract the depleted value i.e `a-a/2.0` from `s/2` and push the remaining value back to the heap until s becomes less than 0.\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& v) {\\n        priority_queue<double> pq(v.begin(),v.end());\\n        double s=0;\\n        s=accumulate(v.begin(),v.end(),s);\\n        s/=2.0;\\n        int ans=0;\\n        while(!pq.empty() && s>0){\\n            double a=pq.top();\\n            pq.pop();\\n            double half=a/2.0;\\n            if(half>0)pq.push(half);\\n            s-=a-half;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time complexity: O(nlogn)**\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& v) {\\n        priority_queue<double> pq(v.begin(),v.end());\\n        double s=0;\\n        s=accumulate(v.begin(),v.end(),s);\\n        s/=2.0;\\n        int ans=0;\\n        while(!pq.empty() && s>0){\\n            double a=pq.top();\\n            pq.pop();\\n            double half=a/2.0;\\n            if(half>0)pq.push(half);\\n            s-=a-half;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863924,
                "title": "c-heap-with-logic-and-intuition",
                "content": "To make the **sum <=  half of sum** in **minimum number of operations** we need to **make the largest numbers half**.\\n**To get largest number use Priority Queue**\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        double sum(0);\\n        int n(size(nums)), count(0);\\n        priority_queue<double> pq;\\n        \\n        for (auto& num : nums) {\\n            sum += num;\\n            pq.push(num);\\n        }\\n        double reqSum = sum / 2.0;\\n        \\n        while (sum > reqSum) {\\n            double top = pq.top() / 2; pq.pop();\\n            if (top != 0)   pq.push(top);\\n            sum -= top; // reduce the sum after making the largest number half.\\n            count++;    // increase number of operation\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Upvote if it helps ;)**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        double sum(0);\\n        int n(size(nums)), count(0);\\n        priority_queue<double> pq;\\n        \\n        for (auto& num : nums) {\\n            sum += num;\\n            pq.push(num);\\n        }\\n        double reqSum = sum / 2.0;\\n        \\n        while (sum > reqSum) {\\n            double top = pq.top() / 2; pq.pop();\\n            if (top != 0)   pq.push(top);\\n            sum -= top; // reduce the sum after making the largest number half.\\n            count++;    // increase number of operation\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863911,
                "title": "easy-c-o-n-solution-using-priority-queue",
                "content": "\\n\\t\\n\\t\\n\\tpriority_queue<double>q;\\n       \\n        double sum=0;\\n        for(auto it:nums){\\n            sum+=double(it);\\n            q.push(double(it));\\n        }\\n        double h=sum/2;\\n        int count=0;\\n        while(sum>h){\\n            double temp=q.top();\\n            q.pop();\\n            temp=temp/2;\\n            sum-=temp;\\n            q.push(temp);\\n            count++;\\n        }\\n        return count;",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n\\t\\n\\t\\n\\tpriority_queue<double>q;\\n       \\n        double sum=0;\\n        for(auto it:nums){\\n            sum+=double(it);\\n            q.push(double(it));\\n        }\\n        double h=sum/2;\\n        int count=0;\\n        while(sum>h){\\n            double temp=q.top();\\n            q.pop();\\n            temp=temp/2;\\n            sum-=temp;\\n            q.push(temp);\\n            count++;\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3119064,
                "title": "c-15-line-easy-code-with-explanation-priority-queue",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int halveArray(vector<int>& nums) \\n    {\\n        // use priority Queue to store elements in assending order\\n        // So Biggest element is always on top of Queue\\n        priority_queue<double>Q;\\n\\n        double sum=0;   //Total sum of element\\n\\n        //store all elments in Queue\\n        for(auto ele : nums)\\n        {\\n            sum+=ele;\\n            Q.push(ele);\\n            \\n        }\\n        \\n        //half of total\\n        double half=sum/2;\\n\\n        //count operations until sum is greater than half \\n        int count=0;\\n        while(sum>half)\\n        { \\n            double max=Q.top();     //maximum emement of Queue\\n            Q.pop();                //remove it from Queue\\n\\n            max/=2;                 \\n            Q.push(max);            //add half of that element\\n            count++;                //count accurance of operation\\n\\n            sum-=max;               //substarct half of element from sum \\n        }\\n       \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int halveArray(vector<int>& nums) \\n    {\\n        // use priority Queue to store elements in assending order\\n        // So Biggest element is always on top of Queue\\n        priority_queue<double>Q;\\n\\n        double sum=0;   //Total sum of element\\n\\n        //store all elments in Queue\\n        for(auto ele : nums)\\n        {\\n            sum+=ele;\\n            Q.push(ele);\\n            \\n        }\\n        \\n        //half of total\\n        double half=sum/2;\\n\\n        //count operations until sum is greater than half \\n        int count=0;\\n        while(sum>half)\\n        { \\n            double max=Q.top();     //maximum emement of Queue\\n            Q.pop();                //remove it from Queue\\n\\n            max/=2;                 \\n            Q.push(max);            //add half of that element\\n            count++;                //count accurance of operation\\n\\n            sum-=max;               //substarct half of element from sum \\n        }\\n       \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349524,
                "title": "java-priority-queue",
                "content": "**PRIORITY QUEUE IS LIKE A SIMPLE QUEUE BUT THE DATA IN IT IS AUTOMATICALLY SORTED IN ASCENDING ORDER. IHAVE USED reverseOrder FUNCTION TO MAKE IT IN DESCENDING ORDER AS PER NEED OF THE QUESTION**\\n**USE DOUBLE BECAUSE PROBLEM STATES DECIMALS WHEN SUMMING.THESE VALUES  CAN BE LOST IF WE USE INT DATATYPE**\\nIn this we basically store our array in priority queue and our sum in our double variable.\\nThen we poll the largest element from our priority queue and remove it from the sum, half it and add it back to check whether  the difference bw original sum and this new sum is at least half of the initial sum.We update our result(r) variable and return it.\\n\\n\\n\\n```\\nclass Solution \\n{\\n    public int halveArray(int[] nums)\\n    {\\n         double sum=0.00;\\n        PriorityQueue<Double>pq= new PriorityQueue<Double>(Collections.reverseOrder());\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pq.add((double)nums[i]);\\n            sum=sum+(double)nums[i];\\n        }\\n        double f=sum;\\n        int r=0;\\n        int is=0;\\n        while(sum>f/2)\\n        {\\n            \\n            double a=pq.poll();\\n            sum=sum-a;\\n            a=a/2;\\n            pq.add(a);\\n            sum=sum+a;\\n            r++;\\n        }\\n        \\n        return r;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int halveArray(int[] nums)\\n    {\\n         double sum=0.00;\\n        PriorityQueue<Double>pq= new PriorityQueue<Double>(Collections.reverseOrder());\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pq.add((double)nums[i]);\\n            sum=sum+(double)nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1984994,
                "title": "python-3-priority-queue",
                "content": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        goal = s / 2\\n        res = 0\\n        \\n        for i, num in enumerate(nums):\\n            nums[i] = -num\\n        heapq.heapify(nums)\\n        \\n        while s > goal:\\n            halfLargest = -heapq.heappop(nums) / 2\\n            s -= halfLargest\\n            heapq.heappush(nums, -halfLargest)\\n            res += 1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        goal = s / 2\\n        res = 0\\n        \\n        for i, num in enumerate(nums):\\n            nums[i] = -num\\n        heapq.heapify(nums)\\n        \\n        while s > goal:\\n            halfLargest = -heapq.heappop(nums) / 2\\n            s -= halfLargest\\n            heapq.heappush(nums, -halfLargest)\\n            res += 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1867998,
                "title": "c-greedy-max-heap-based-solution-explained-80-time-182ms-40-space-89-4mb",
                "content": "This problem was surprisingly easy and straightforward, the main challenge here being not to fall into overflows or conversion/precision traps.\\n\\nIn order to solve this problem, we need to be able to quickly/efficiently pick the current largest element we have (because it will of course give us the bigger bang for our bucks), halve it, reduce our current sum by that value and then put it back in our container with all the values we can decide to halve.\\n\\nA heap really sounds the ideal candidate for this logic, so let\\'s go and put it all in practice, starting with a few support variables:\\n* `tot`, `target` and `tmp` will all be double that will respectively store our current total, our target total and the number we are currently consider to halve;\\n* `res` is our counter variable, initialised to `0` and that will store how many steps we need to do in order to achieve our desired reduction;\\n* `pq` is going to be our (max) heap of values.\\n\\nWe will then proceed and for each value `n` in `nums` we will:\\n* increase `tot` by `n` (so that at the end we will have the initial sum of all the values stored in it);\\n* add `n` to `pq`.\\n\\nWe can now set `target` as well, defined as half of `tot`; we will then loop `while` `tot > target` and:\\n* take the currently largest value stored in `pq.top()` and assign its half to `tmp`;\\n* pop the top value we just extracted out of `pq`;\\n* decrease `tot` by `tmp`;\\n* reinsert `tmp` into `pq`;\\n* increase `res` by `1`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        // support variables\\n        double tot = 0, target, tmp;\\n        int res = 0;\\n        priority_queue<double> pq;\\n        // computing tot and populating pq\\n        for (int n: nums) {\\n            tot += n;\\n            pq.push(n);\\n        }\\n        // getting our goal\\n        target = tot / 2;\\n        // computing the minimum amount of steps required to get to the goal\\n        while (tot > target) {\\n            // extracting the larger value...\\n            tmp = pq.top() / 2;\\n            pq.pop();\\n            // ...and getting half of it out of sum and the rest back into pq\\n            tot -= tmp;\\n            pq.push(tmp);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nMicro-optimised version for when we have a rather large big number separated from the rest and we want to avoid the cost of pushing and popping too many times from a heap:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        // edge case:\\n        if (nums.size() == 1) return 1;\\n        // support variables\\n        double tot = 0, target, tmp;\\n        int res = 0;\\n        priority_queue<double> pq;\\n        // computing tot and populating pq\\n        for (int n: nums) {\\n            tot += n;\\n            pq.push(n);\\n        }\\n        // getting our goal\\n        target = tot / 2;\\n        // computing the minimum amount of steps required to get to the goal\\n        while (tot > target) {\\n            // extracting the larger value...\\n            tmp = pq.top();\\n            pq.pop();\\n            // ...and getting half of the current value of tmp out of sum while tmp >= pq.top()\\n            while (tmp >= pq.top() && tot > target) {\\n                tmp /= 2;\\n                tot -= tmp;\\n                res++;\\n            }\\n            // putting back what is left of tmp into pq\\n            pq.push(tmp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        // support variables\\n        double tot = 0, target, tmp;\\n        int res = 0;\\n        priority_queue<double> pq;\\n        // computing tot and populating pq\\n        for (int n: nums) {\\n            tot += n;\\n            pq.push(n);\\n        }\\n        // getting our goal\\n        target = tot / 2;\\n        // computing the minimum amount of steps required to get to the goal\\n        while (tot > target) {\\n            // extracting the larger value...\\n            tmp = pq.top() / 2;\\n            pq.pop();\\n            // ...and getting half of it out of sum and the rest back into pq\\n            tot -= tmp;\\n            pq.push(tmp);\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        // edge case:\\n        if (nums.size() == 1) return 1;\\n        // support variables\\n        double tot = 0, target, tmp;\\n        int res = 0;\\n        priority_queue<double> pq;\\n        // computing tot and populating pq\\n        for (int n: nums) {\\n            tot += n;\\n            pq.push(n);\\n        }\\n        // getting our goal\\n        target = tot / 2;\\n        // computing the minimum amount of steps required to get to the goal\\n        while (tot > target) {\\n            // extracting the larger value...\\n            tmp = pq.top();\\n            pq.pop();\\n            // ...and getting half of the current value of tmp out of sum while tmp >= pq.top()\\n            while (tmp >= pq.top() && tot > target) {\\n                tmp /= 2;\\n                tot -= tmp;\\n                res++;\\n            }\\n            // putting back what is left of tmp into pq\\n            pq.push(tmp);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866787,
                "title": "c-easy-to-understand-solution",
                "content": "Observation:\\n\\nIf we want to reduce a sum from a numbers to atleast sum/2 then we can do this fastly(in minimum operations) by updating all the biggest element and applying the divide by 2 operation to them again and again.\\n\\nAfter this max heap first came to my mind. Here is the code of my approach simply pushing the elements in max heap and then halving the biggest element in heap and uptating the sum till we reach the point that sum is atleast half its original value;\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        int n = nums.size();\\n        double sum = 0;\\n        double newSum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            q.push(nums[i]);\\n        }\\n        newSum = sum/2;\\n        int ct = 0;\\n        while(q.size()){\\n            double val = q.top();\\n            q.pop();\\n            sum-=val/2;\\n            q.push(val/2);\\n            ct++;\\n            if(sum <= newSum){\\n                return ct;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        int n = nums.size();\\n        double sum = 0;\\n        double newSum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            q.push(nums[i]);\\n        }\\n        newSum = sum/2;\\n        int ct = 0;\\n        while(q.size()){\\n            double val = q.top();\\n            q.pop();\\n            sum-=val/2;\\n            q.push(val/2);\\n            ct++;\\n            if(sum <= newSum){\\n                return ct;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866044,
                "title": "c-easy-to-understand-using-priority-queue-beginners-friendly-o-n",
                "content": "**Please Upvote If It Helps**\\n\\n**Algorithm**\\n* initialize a **priority queue** that will help to gave us a **max element** among all\\n\\n* after it we will keep a var **sum** that will store the s**um of all elements**\\n* as we know we have to reduce the given array **just by half** , so for that we will keep a var **goal** that will store **half of sum**\\n* now we will keep iterating till our **goal is less than from the sum** and each time we will extract the **top most element** and reduce the **sum by top_most_element/2**  and push again that element **into the queue**\\n* For each iteration we will incraese the **count of our final result** and at the end we will **return** that\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        // it will give the highest frequency element on top automatically\\n        priority_queue<double> pq;\\n        double sum = 0;                      // it will store the current sum\\n        \\n        \\n        // pushing the elements into the queue \\n        // and couting the sum of elements\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        // declaring the goal by half of sum\\n        // and ans will store the number of operations\\n        double goal = sum/2;\\n        int ans = 0;\\n        \\n        // we will iterate till we did not achieve our goal\\n        while(sum>goal)\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            \\n            sum -= (it/2);              // each time reduce the sum by half of top most element\\n            pq.push(it/2);              // pushing that it/2 to into queue beacuse it can also be our next subtracting element\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote If It Helps**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        // it will give the highest frequency element on top automatically\\n        priority_queue<double> pq;\\n        double sum = 0;                      // it will store the current sum\\n        \\n        \\n        // pushing the elements into the queue \\n        // and couting the sum of elements\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        // declaring the goal by half of sum\\n        // and ans will store the number of operations\\n        double goal = sum/2;\\n        int ans = 0;\\n        \\n        // we will iterate till we did not achieve our goal\\n        while(sum>goal)\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            \\n            sum -= (it/2);              // each time reduce the sum by half of top most element\\n            pq.push(it/2);              // pushing that it/2 to into queue beacuse it can also be our next subtracting element\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1864459,
                "title": "priority-queue-o-nlognn-easy-and-simple-explanation-c",
                "content": "## Minimum Operations to Halve Array Sum\\n\\n* The idea is to pick the maximum element and divide it by 2\\n* Priority Queue can help us provide the maximum element at the top in O(nlogn) time complexity\\n\\n\\n* First Calculate the sum of the array and add all the numbers in the priority queue\\n* loop through the priority queue until the sum of the updated array is greater than actual sum of the original array\\n* pop the top of the array and divide it by 2 and then push it again into the queue ( keep track of steps)\\n\\n\\n### C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double>P;\\n        int n=nums.size();\\n        double sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            P.push(nums[i]);\\n            sum+=nums[i];\\n        }\\n        \\n        double s=sum;\\n        int step=0;\\n        \\n        while(!P.empty() && s>sum/2)\\n        {\\n            double x = P.top();\\n            P.pop();\\n            double y = x/2;\\n            s-=y;\\n            P.push(y);\\n            step++;\\n        }\\n        \\n        return step;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double>P;\\n        int n=nums.size();\\n        double sum=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            P.push(nums[i]);\\n            sum+=nums[i];\\n        }\\n        \\n        double s=sum;\\n        int step=0;\\n        \\n        while(!P.empty() && s>sum/2)\\n        {\\n            double x = P.top();\\n            P.pop();\\n            double y = x/2;\\n            s-=y;\\n            P.push(y);\\n            step++;\\n        }\\n        \\n        return step;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864281,
                "title": "c-use-priority-queue-to-store-max-element-on-top-approach-explanation-and-example",
                "content": "Approach: We need to minimize the number of operations to reduce the sum of array by half so for doing so if we select max element every time and reduce it by half then we can achieve our target.\\n\\n**SO to find this max element we are using priority queue**\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;      //to store max element on top\\n        double sum = 0;\\n        int ans = 0;\\n        \\n        for (int it : nums) {\\n            pq.push(it);\\n            sum += it;\\n        }\\n        \\n\\t\\t//exmple: 3, 8, 20\\n\\t\\t\\n        double goal = sum / 2;   // goal = 31/2 = 15.5\\n        while (sum > goal) {\\n            auto num = pq.top();    //20\\n            pq.pop();\\n            sum -= num/2;           //31-10 = 21\\n            pq.push(num / 2);     //nums: 3, 8, 10\\n            ans++;                    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;      //to store max element on top\\n        double sum = 0;\\n        int ans = 0;\\n        \\n        for (int it : nums) {\\n            pq.push(it);\\n            sum += it;\\n        }\\n        \\n\\t\\t//exmple: 3, 8, 20\\n\\t\\t\\n        double goal = sum / 2;   // goal = 31/2 = 15.5\\n        while (sum > goal) {\\n            auto num = pq.top();    //20\\n            pq.pop();\\n            sum -= num/2;           //31-10 = 21\\n            pq.push(num / 2);     //nums: 3, 8, 10\\n            ans++;                    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864248,
                "title": "python-using-sorted-list",
                "content": "The idea is to keep picking the highest element until the required sum is not reached.\\n\\n1. Pick the max element, remove from list\\n2. Update it by half and add again \\n3. Increment count\\n4. Decrement sum\\n\\n- Using sorted list, max element is always at the last\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        \\n        nums = SortedList(nums)\\n        cnt = 0\\n        \\n        init_sum = sum(nums)\\n        req_sum = init_sum / 2\\n        \\n        cur_num = 0\\n        \\n        while init_sum > req_sum:\\n            cur_num = nums[-1]\\n            \\n            nums.remove(cur_num)\\n            \\n            cur_num /= 2\\n            cnt += 1\\n            \\n            nums.add(cur_num)\\n            \\n            init_sum -= cur_num\\n        return cnt\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        \\n        nums = SortedList(nums)\\n        cnt = 0\\n        \\n        init_sum = sum(nums)\\n        req_sum = init_sum / 2\\n        \\n        cur_num = 0\\n        \\n        while init_sum > req_sum:\\n            cur_num = nums[-1]\\n            \\n            nums.remove(cur_num)\\n            \\n            cur_num /= 2\\n            cnt += 1\\n            \\n            nums.add(cur_num)\\n            \\n            init_sum -= cur_num\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788412,
                "title": "simple-java-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Using PriorityQueue Interface with Comparator constuctor, create a heap with elements in descending order. Also keep track of the sum of elements in the array\\nLoop through and and track the number of times the sum is less than its half:\\n   - if it\\'s not..remove and half the highest number from the heap\\n   - Add back the half to the heap and get the remaining sum\\n   - increment count\\n   - Continue until sum of elments is less than its half\\nreturn the number of operations(count).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    0(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    0(n)\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> heap = new PriorityQueue<>(Comparator.reverseOrder());\\n        int count = 0;\\n\\n        double sum = 0.0;\\n\\n        for(double num: nums) {\\n            heap.add(num);\\n            sum += num;\\n        }\\n         \\n         double halfSum = sum / 2;\\n\\n        while(sum > halfSum) {\\n            double halfHighestNum = heap.remove() / 2;\\n            heap.add(halfHighestNum);\\n            sum -= halfHighestNum;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> heap = new PriorityQueue<>(Comparator.reverseOrder());\\n        int count = 0;\\n\\n        double sum = 0.0;\\n\\n        for(double num: nums) {\\n            heap.add(num);\\n            sum += num;\\n        }\\n         \\n         double halfSum = sum / 2;\\n\\n        while(sum > halfSum) {\\n            double halfHighestNum = heap.remove() / 2;\\n            heap.add(halfHighestNum);\\n            sum -= halfHighestNum;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425366,
                "title": "simple-priority-queue-implementation",
                "content": "# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HalveArray(int[] nums) {\\n        PriorityQueue<double, double> maxPriortyQueue = new PriorityQueue<double, double>();\\n        double givenSum = 0;\\n        foreach(int num in nums)\\n            givenSum += num;\\n\\n        double currSum = givenSum;\\n        givenSum /= 2;\\n        int operations = 0;\\n\\n        foreach(int num in nums)\\n            maxPriortyQueue.Enqueue(num, -num);\\n\\n        while(maxPriortyQueue.Count != 0){\\n            ++operations;\\n            double currMaxNum = maxPriortyQueue.Dequeue();\\n            currMaxNum /= 2;\\n            currSum -= (double)currMaxNum;\\n            maxPriortyQueue.Enqueue(currMaxNum, -currMaxNum);\\n            if(currSum <= givenSum)\\n                return operations;\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int HalveArray(int[] nums) {\\n        PriorityQueue<double, double> maxPriortyQueue = new PriorityQueue<double, double>();\\n        double givenSum = 0;\\n        foreach(int num in nums)\\n            givenSum += num;\\n\\n        double currSum = givenSum;\\n        givenSum /= 2;\\n        int operations = 0;\\n\\n        foreach(int num in nums)\\n            maxPriortyQueue.Enqueue(num, -num);\\n\\n        while(maxPriortyQueue.Count != 0){\\n            ++operations;\\n            double currMaxNum = maxPriortyQueue.Dequeue();\\n            currMaxNum /= 2;\\n            currSum -= (double)currMaxNum;\\n            maxPriortyQueue.Enqueue(currMaxNum, -currMaxNum);\\n            if(currSum <= givenSum)\\n                return operations;\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236792,
                "title": "c-easy-to-understand-simple-solution-using-max-heap-heap-priority-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> maxHeap;\\n        double cur_sum = 0;\\n        double sum = 0;\\n        int count = 0;\\n        for (auto &num:nums){\\n            sum += num;\\n            maxHeap.push(num);\\n        }\\n        double partial_sum = sum / 2;\\n        cur_sum = sum;\\n        while (cur_sum > partial_sum) {\\n            double cur = maxHeap.top();\\n            cur_sum -= cur;\\n            cur /= 2;\\n            cur_sum += cur;\\n            maxHeap.pop();\\n            maxHeap.push(cur);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> maxHeap;\\n        double cur_sum = 0;\\n        double sum = 0;\\n        int count = 0;\\n        for (auto &num:nums){\\n            sum += num;\\n            maxHeap.push(num);\\n        }\\n        double partial_sum = sum / 2;\\n        cur_sum = sum;\\n        while (cur_sum > partial_sum) {\\n            double cur = maxHeap.top();\\n            cur_sum -= cur;\\n            cur /= 2;\\n            cur_sum += cur;\\n            maxHeap.pop();\\n            maxHeap.push(cur);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168475,
                "title": "max-heap-python3-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first thought you can notice that you constantly want to be picking the largest possible number after each halving to minimize the number of operations. The brute force solution would be to sort the list and then pop the last element and the add that halved element back into the list again and then resort it. However, with all that resorting the algorithm becomes efficient when all you are really looking for is just the max element. This is where the max heap becomes useful. We can use a max heap to heapify our nums list and then just pop out the max from that which is more efficient.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this approach you have to first calculate the total sum as this is when you want your while loop to stop. Then, in python the heapq library is supported for minHeap however, by multiplying every value by negative one you essentially turn it into a maxHeap you just have to remember to multiply the -1 back when actually using the data.  The while loop will run as long as the current sum is greater than the totalSum/2. You want to pop out the largest element and store that number. Make sure to push the largest element/2 back in so you arent forgetting about any largest values. Then subtract half of the largest element so you account for popping it out of the heap. Don\\'t forget to multiply this by -1 as we are actually processing the data. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) -> heapify runtime\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) -> space that the heap will take\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        arraySum = currSum = sum(nums)\\n        nums = [-1*num for num in nums]\\n        heapq.heapify(nums)\\n        minOperations = 0\\n\\n        while currSum > arraySum/2:\\n            largestNum = heapq.heappop(nums)\\n            heapq.heappush(nums, largestNum/2)\\n            currSum -= (-1 * largestNum)/2\\n            minOperations += 1\\n\\n        return minOperations\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        arraySum = currSum = sum(nums)\\n        nums = [-1*num for num in nums]\\n        heapq.heapify(nums)\\n        minOperations = 0\\n\\n        while currSum > arraySum/2:\\n            largestNum = heapq.heappop(nums)\\n            heapq.heappush(nums, largestNum/2)\\n            currSum -= (-1 * largestNum)/2\\n            minOperations += 1\\n\\n        return minOperations\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963801,
                "title": "python3-o-nlogn-solution-max-heap",
                "content": "# Complexity\\n- Time complexity:\\nO(N logN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        heap = []\\n        for num in nums:\\n            heappush(heap,-1 * num)\\n\\n        initalSum = sum(nums)\\n        targetSum = initalSum / 2\\n        k = 0\\n\\n        while  initalSum > targetSum:\\n            val = heappop(heap)\\n            heappush(heap,val / 2)\\n            initalSum -= (-1 * (val / 2))\\n            k = k + 1\\n            \\n        return k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        heap = []\\n        for num in nums:\\n            heappush(heap,-1 * num)\\n\\n        initalSum = sum(nums)\\n        targetSum = initalSum / 2\\n        k = 0\\n\\n        while  initalSum > targetSum:\\n            val = heappop(heap)\\n            heappush(heap,val / 2)\\n            initalSum -= (-1 * (val / 2))\\n            k = k + 1\\n            \\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961774,
                "title": "c-intuition-and-explanation-priority-queue",
                "content": "# Intuition\\nSince we have to reduce the sum of array elements by atleast half using minimum number of operation, where in each operation we can reduce the sum by half of any array element present, we must always choose the maximum element from the array for this operation.\\n\\n# Approach\\nWe can use priority queue (max-heap) for simulating the above process.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        long double sum = 0;\\n        priority_queue<long double> pq;\\n        int ans=0;\\n        for(auto i : nums)\\n            pq.push(i), sum += i;\\n        long double init_sum = sum;\\n        while(2*sum > init_sum){\\n            long double k = pq.top()/2.00;\\n            sum -= k;\\n            pq.pop();\\n            pq.push(k);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        long double sum = 0;\\n        priority_queue<long double> pq;\\n        int ans=0;\\n        for(auto i : nums)\\n            pq.push(i), sum += i;\\n        long double init_sum = sum;\\n        while(2*sum > init_sum){\\n            long double k = pq.top()/2.00;\\n            sum -= k;\\n            pq.pop();\\n            pq.push(k);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961431,
                "title": "using-priority-queue-easy-to-understand-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        //priority queue \\n        double sum = accumulate(nums.begin() , nums.end() , 0LL) ; \\n        double required_sum = sum/2.0 ;\\n        int operation=0;\\n//this declares a priority queue and pushes all elements from nums in it\\n        priority_queue<double>pq(nums.begin() , nums.end()) ; \\n\\n        /*\\n        while(!pq.empty()) {\\n         cout<<pq.top()<<\" \";\\n         pq.pop();\\n        }\\n        */\\n\\n        while(sum>required_sum){\\n            double max_sum = pq.top()/2.0 ;\\n            pq.pop();\\n            pq.push(max_sum);\\n            sum-=max_sum;\\n            operation++;\\n        }\\n        return operation;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        //priority queue \\n        double sum = accumulate(nums.begin() , nums.end() , 0LL) ; \\n        double required_sum = sum/2.0 ;\\n        int operation=0;\\n//this declares a priority queue and pushes all elements from nums in it\\n        priority_queue<double>pq(nums.begin() , nums.end()) ; \\n\\n        /*\\n        while(!pq.empty()) {\\n         cout<<pq.top()<<\" \";\\n         pq.pop();\\n        }\\n        */\\n\\n        while(sum>required_sum){\\n            double max_sum = pq.top()/2.0 ;\\n            pq.pop();\\n            pq.push(max_sum);\\n            sum-=max_sum;\\n            operation++;\\n        }\\n        return operation;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2729155,
                "title": "max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n  {\\n       double sum=0;\\n       vector<double>v;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n          sum=sum+nums[i];\\n          v.push_back(nums[i]);\\t\\n       }        \\n       double currsum = sum;\\n       priority_queue<double>pq;\\n       for(int i=0;i<v.size();i++)\\n       {\\n           pq.push(v[i]);\\n       }\\n       int count=0;\\n       while(true)\\n       {\\n          double ele = pq.top();\\n          pq.pop();\\n\\n          double newele =  ele /2;\\n          pq.push(newele);\\n\\n          currsum = currsum - ele;\\n          currsum = currsum + newele;\\n\\n          count++;\\n\\n          if(currsum <= (sum/2))\\n          {\\n              break;    \\t\\n          }\\n\\n       }\\n       return count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n  {\\n       double sum=0;\\n       vector<double>v;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n          sum=sum+nums[i];\\n          v.push_back(nums[i]);\\t\\n       }        \\n       double currsum = sum;\\n       priority_queue<double>pq;\\n       for(int i=0;i<v.size();i++)\\n       {\\n           pq.push(v[i]);\\n       }\\n       int count=0;\\n       while(true)\\n       {\\n          double ele = pq.top();\\n          pq.pop();\\n\\n          double newele =  ele /2;\\n          pq.push(newele);\\n\\n          currsum = currsum - ele;\\n          currsum = currsum + newele;\\n\\n          count++;\\n\\n          if(currsum <= (sum/2))\\n          {\\n              break;    \\t\\n          }\\n\\n       }\\n       return count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729149,
                "title": "c-314ms-faster-than-90-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=0;\\n        double s;\\n        priority_queue<double>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            pq.push(nums[i]);\\n        }\\n        s=sum;\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            double ele=pq.top();\\n            pq.pop();\\n            s=s-(ele/2);\\n            if(s<=(sum/2))\\n            {\\n                ans++;\\n                break;\\n            }\\n            ans++;\\n            pq.push(ele/2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=0;\\n        double s;\\n        priority_queue<double>pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum=sum+nums[i];\\n            pq.push(nums[i]);\\n        }\\n        s=sum;\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            double ele=pq.top();\\n            pq.pop();\\n            s=s-(ele/2);\\n            if(s<=(sum/2))\\n            {\\n                ans++;\\n                break;\\n            }\\n            ans++;\\n            pq.push(ele/2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654829,
                "title": "c-314ms-faster-than-90-priority-queue-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums){\\n\\n         priority_queue<double>pq;\\n\\n         double sum = 0;\\n\\n         for(auto it : nums)\\n         {\\n             pq.push(it);\\n             sum+=it;\\n         }\\n\\n         double target = (sum*1.0000)/2.0000000;\\n       \\n         int cnt=0;\\n         \\n         while(sum>target)\\n         {\\n             double temp = pq.top();\\n             temp/=2.000000;\\n             pq.pop();\\n             pq.push(temp);\\n             sum-=temp;\\n             cnt++;\\n         }\\n         \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums){\\n\\n         priority_queue<double>pq;\\n\\n         double sum = 0;\\n\\n         for(auto it : nums)\\n         {\\n             pq.push(it);\\n             sum+=it;\\n         }\\n\\n         double target = (sum*1.0000)/2.0000000;\\n       \\n         int cnt=0;\\n         \\n         while(sum>target)\\n         {\\n             double temp = pq.top();\\n             temp/=2.000000;\\n             pq.pop();\\n             pq.push(temp);\\n             sum-=temp;\\n             cnt++;\\n         }\\n         \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397768,
                "title": "java-priority-queue-detailed-comments",
                "content": "\\tclass Solution {\\n\\t\\tpublic int halveArray(int[] nums) {\\n\\n\\t\\t\\tPriorityQueue<Double> pq = new PriorityQueue<>((a, b) -> Double.compare(b, a));\\n\\n\\t\\t\\tdouble sum = 0;\\n\\n\\t\\t\\t// initialize queue and sum\\n\\t\\t\\tfor (int n : nums) {\\n\\t\\t\\t\\tpq.add(Double.valueOf(n));\\n\\t\\t\\t\\tsum += n;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// get half of sum\\n\\t\\t\\tdouble half = sum / 2;\\n\\n\\t\\t\\t// count variable for the answer\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\t// use sum > half so the count will not add an extra value, also takes care of  \\n\\t\\t\\t// other cases like [1, 2] where the sum is near the half\\n\\t\\t\\twhile (sum > half) {\\n\\t\\t\\t\\tdouble currMax = pq.poll(); // get curr max\\n\\t\\t\\t\\tcurrMax /= 2; // get half of curr max\\n\\t\\t\\t\\tsum -= currMax; // subtract the curr max to the sum\\n\\t\\t\\t\\tpq.offer(currMax); // place back the halfed max to the queue\\n\\t\\t\\t\\tcount++;// increment answer\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic int halveArray(int[] nums) {\\n\\n\\t\\t\\tPriorityQueue<Double> pq = new PriorityQueue<>((a, b) -> Double.compare(b, a));\\n\\n\\t\\t\\tdouble sum = 0;\\n\\n\\t\\t\\t// initialize queue and sum\\n\\t\\t\\tfor (int n : nums) {\\n\\t\\t\\t\\tpq.add(Double.valueOf(n));\\n\\t\\t\\t\\tsum += n;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2332577,
                "title": "max-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double tSum = accumulate(nums.begin(), nums.end(), 0.0), tempSum = tSum;\\n        priority_queue<double> maxh(nums.begin(), nums.end());\\n        \\n        int ans = 0;\\n        for(; tempSum >  tSum / 2; ans++) {\\n            double a = maxh.top(); maxh.pop();\\n            tempSum -= a / 2;\\n            maxh.push(a / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double tSum = accumulate(nums.begin(), nums.end(), 0.0), tempSum = tSum;\\n        priority_queue<double> maxh(nums.begin(), nums.end());\\n        \\n        int ans = 0;\\n        for(; tempSum >  tSum / 2; ans++) {\\n            double a = maxh.top(); maxh.pop();\\n            tempSum -= a / 2;\\n            maxh.push(a / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129903,
                "title": "c-use-long-double-priority-queue-easy",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint halveArray(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tpriority_queue<double> pq;\\n\\t\\t\\t\\tlong double s = 0;\\n\\t\\t\\t\\tfor(auto i: nums){\\n\\t\\t\\t\\t\\tpq.push(i);\\n\\t\\t\\t\\t\\ts += i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong double half = s/2.0;\\n\\t\\t\\t\\tlong double sum = 0;\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\twhile(!pq.empty()){\\n\\t\\t\\t\\t\\tlong double t = pq.top();\\n\\t\\t\\t\\t\\tpq.pop();\\n\\n\\t\\t\\t\\t\\tsum += t/2.0;\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\tif(sum>=half)return cnt;\\n\\t\\t\\t\\t\\tpq.push(t/2.0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn cnt;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint halveArray(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tpriority_queue<double> pq;\\n\\t\\t\\t\\tlong double s = 0;\\n\\t\\t\\t\\tfor(auto i: nums){\\n\\t\\t\\t\\t\\tpq.push(i);\\n\\t\\t\\t\\t\\ts += i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2115601,
                "title": "javascript-solution-greedy-with-priority-queue",
                "content": "```\\nvar halveArray = function(nums) {\\n    const n = nums.length;\\n    const maxHeap = new MaxPriorityQueue({ priority: x => x });\\n    \\n    let startSum = 0;\\n    \\n    for (const num of nums) {\\n        maxHeap.enqueue(num);\\n        startSum += num;\\n    }\\n    \\n    let currSum = startSum;\\n    \\n    let numberOfOperations = 0;\\n    \\n    while (currSum > startSum / 2) {\\n        const biggestNum = maxHeap.dequeue().element;\\n        \\n        const halfNum = biggestNum / 2;\\n        \\n        numberOfOperations += 1;\\n        currSum -= halfNum;\\n        \\n        maxHeap.enqueue(halfNum);\\n    }\\n    \\n    return numberOfOperations;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar halveArray = function(nums) {\\n    const n = nums.length;\\n    const maxHeap = new MaxPriorityQueue({ priority: x => x });\\n    \\n    let startSum = 0;\\n    \\n    for (const num of nums) {\\n        maxHeap.enqueue(num);\\n        startSum += num;\\n    }\\n    \\n    let currSum = startSum;\\n    \\n    let numberOfOperations = 0;\\n    \\n    while (currSum > startSum / 2) {\\n        const biggestNum = maxHeap.dequeue().element;\\n        \\n        const halfNum = biggestNum / 2;\\n        \\n        numberOfOperations += 1;\\n        currSum -= halfNum;\\n        \\n        maxHeap.enqueue(halfNum);\\n    }\\n    \\n    return numberOfOperations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076590,
                "title": "c-solution-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> p;\\n        double sum_i=0;\\n        for(auto i:nums){\\n            p.push(i);\\n            sum_i+=i;\\n        }\\n        int c=0;\\n        double sum_f=sum_i;\\n        while(sum_f>sum_i/2){\\n            double temp=p.top();\\n            p.pop();\\n            p.push(temp/2);\\n            sum_f-=temp;\\n            sum_f+=temp/2;\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> p;\\n        double sum_i=0;\\n        for(auto i:nums){\\n            p.push(i);\\n            sum_i+=i;\\n        }\\n        int c=0;\\n        double sum_f=sum_i;\\n        while(sum_f>sum_i/2){\\n            double temp=p.top();\\n            p.pop();\\n            p.push(temp/2);\\n            sum_f-=temp;\\n            sum_f+=temp/2;\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985674,
                "title": "c-simple-understandable-solution-using-max-heap-priority-queue",
                "content": "**Do upvote if you find its helpful**\\n\\n```\\nint halveArray(vector<int>& nums) \\n    {\\n        priority_queue<double>maxh;\\n        double sum=0.0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            maxh.push(nums[i]);\\n        }\\n        double half=sum/2;\\n        int cnt=0;\\n        while(sum>half)\\n        {\\n            double val=maxh.top();\\n          \\n            maxh.pop();\\n            val=val/2;\\n           \\n            maxh.push(val);\\n            sum-=val;\\n            cnt++;\\n        }\\n       \\n        return cnt;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint halveArray(vector<int>& nums) \\n    {\\n        priority_queue<double>maxh;\\n        double sum=0.0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            maxh.push(nums[i]);\\n        }\\n        double half=sum/2;\\n        int cnt=0;\\n        while(sum>half)\\n        {\\n            double val=maxh.top();\\n          \\n            maxh.pop();\\n            val=val/2;\\n           \\n            maxh.push(val);\\n            sum-=val;\\n            cnt++;\\n        }\\n       \\n        return cnt;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890317,
                "title": "python-heap-solution",
                "content": "To find the minimum number of operations to get alteast half, always pick the highest number\\nUse a heap to always have the highest number.\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n            \\n        heap = []\\n        total_sum = 0\\n        for num in nums:\\n            total_sum += num\\n            heapq.heappush(heap, -num)\\n        \\n        half = total_sum/2\\n        \\n        count = 0\\n        while total_sum > half:\\n            highest_num = -heapq.heappop(heap)\\n            total_sum -= (highest_num/2)\\n            heapq.heappush(heap, -(highest_num/2))\\n            count += 1\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n            \\n        heap = []\\n        total_sum = 0\\n        for num in nums:\\n            total_sum += num\\n            heapq.heappush(heap, -num)\\n        \\n        half = total_sum/2\\n        \\n        count = 0\\n        while total_sum > half:\\n            highest_num = -heapq.heappop(heap)\\n            total_sum -= (highest_num/2)\\n            heapq.heappush(heap, -(highest_num/2))\\n            count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885349,
                "title": "java-well-detailed-and-easy-solution-with-priority-queue",
                "content": "I thinks most of you are seeking the solution because of not knowing ***reversing PriorityQueue order***\\n\\n\\t\\tThe idea is simple getting max value and make devide it by 2, collect reduced value till sum/2.\\n\\n`If you like the solution, please LIKE :)`\\n\\n```\\n        double sum = 0, reducedSum = 0;\\n        int counter = 0;\\n        Queue<Double> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int num : nums) {\\n            queue.add((double) num);\\n            sum += num;\\n        }\\n        while (reducedSum < sum / 2) {\\n            double tmp = queue.remove();\\n            reducedSum += tmp / 2;\\n            queue.offer(tmp / 2);\\n            counter++;\\n        }\\n        return counter;\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n        double sum = 0, reducedSum = 0;\\n        int counter = 0;\\n        Queue<Double> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        for (int num : nums) {\\n            queue.add((double) num);\\n            sum += num;\\n        }\\n        while (reducedSum < sum / 2) {\\n            double tmp = queue.remove();\\n            reducedSum += tmp / 2;\\n            queue.offer(tmp / 2);\\n            counter++;\\n        }\\n        return counter;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879059,
                "title": "c-solution-97-faster-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return 1;\\n        }\\n        priority_queue<double> pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        double sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum += nums[i];\\n        }\\n        \\n        double i = sum/2;\\n        int cnt = 0;\\n        while(sum > i){\\n            double x = pq.top();\\n            pq.pop();\\n            x  = x/2;\\n            pq.push(x);\\n            sum -= x;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n# **** Please Upvote",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return 1;\\n        }\\n        priority_queue<double> pq;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        double sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum += nums[i];\\n        }\\n        \\n        double i = sum/2;\\n        int cnt = 0;\\n        while(sum > i){\\n            double x = pq.top();\\n            pq.pop();\\n            x  = x/2;\\n            pq.push(x);\\n            sum -= x;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877359,
                "title": "java-priorityqueue-solution-greedy",
                "content": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int n:nums){\\n            sum+=n;\\n            pq.add((double)n);\\n        }\\n        double target = sum/2;\\n        int cnt =0;\\n        while(!pq.isEmpty() && sum>target){\\n            double num = pq.poll();\\n            sum-=num/2;\\n            pq.add(num/2);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int n:nums){\\n            sum+=n;\\n            pq.add((double)n);\\n        }\\n        double target = sum/2;\\n        int cnt =0;\\n        while(!pq.isEmpty() && sum>target){\\n            double num = pq.poll();\\n            sum-=num/2;\\n            pq.add(num/2);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866294,
                "title": "python-solution-easy-explained-with-comments",
                "content": "```\\nclass Solution(object):\\n    def halveArray(self, nums):\\n            \\n        if len(nums)==1:return 1\\n        \\n        count = 0\\n        total = sum(nums)\\n        half = float(total)/2\\n\\n#       We are converting all numbers to negative, because python does not\\n#       support max heap. So when we change all elements to negative  and perform\\n#       heapify function on it, we will get largest element(with negative sign)\\n#       on top.\\n        for i,val in enumerate(nums):\\n            nums[i]=-val\\n        \\n        \\n        heapify(nums)\\n        \\n        while total > half:\\n            \\n#           converting first element to half\\n            halved = float(nums[0])/2\\n            \\n#           Reducing total sum of array by half value of largest element\\n            total+=halved\\n            \\n#           Counting the number of operations\\n            count+=1\\n    \\n#           Popping root element, and pushing halved element in to it\\n            heapreplace(nums,halved)\\n                        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def halveArray(self, nums):\\n            \\n        if len(nums)==1:return 1\\n        \\n        count = 0\\n        total = sum(nums)\\n        half = float(total)/2\\n\\n#       We are converting all numbers to negative, because python does not\\n#       support max heap. So when we change all elements to negative  and perform\\n#       heapify function on it, we will get largest element(with negative sign)\\n#       on top.\\n        for i,val in enumerate(nums):\\n            nums[i]=-val\\n        \\n        \\n        heapify(nums)\\n        \\n        while total > half:\\n            \\n#           converting first element to half\\n            halved = float(nums[0])/2\\n            \\n#           Reducing total sum of array by half value of largest element\\n            total+=halved\\n            \\n#           Counting the number of operations\\n            count+=1\\n    \\n#           Popping root element, and pushing halved element in to it\\n            heapreplace(nums,halved)\\n                        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866065,
                "title": "c-priority-queue-easy-to-understand-solution",
                "content": "**Algo:**\\nstep 1. Insert all elements into a **priority queue**.\\nstep 2. find sum of all vector elements. called it **total**, calculate **half** which is half of total.\\nstep 3. while total>half, **pop top** element from priority queue. called it **top**, substract **top** from total sum. then add **top/2** to total sum.\\nstep 4. Insert  **top/2** to priority queue, **increment cnt.**\\nstep 5. return cnt.\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n       priority_queue<long double> q;\\n        for(auto i:nums){\\n            q.push(i);\\n        }\\n        int cnt = 0;\\n        long double total = 0;\\n        for(auto i:nums){\\n            total += i;\\n        }\\n        long double half = total/2;\\n        \\n        while(total>half){\\n            long double top = q.top();  \\n            q.pop();\\n            long double top_f = top/2;\\n            total = total-top+top_f;\\n            q.push(top_f);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**IF YOU FIND MY SOLUTION USEFULL THEN DO UPVOTE AND SHARE.**",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n       priority_queue<long double> q;\\n        for(auto i:nums){\\n            q.push(i);\\n        }\\n        int cnt = 0;\\n        long double total = 0;\\n        for(auto i:nums){\\n            total += i;\\n        }\\n        long double half = total/2;\\n        \\n        while(total>half){\\n            long double top = q.top();  \\n            q.pop();\\n            long double top_f = top/2;\\n            total = total-top+top_f;\\n            q.push(top_f);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865425,
                "title": "c-using-built-in-priority-queue-max-heap",
                "content": "Idea here is to use max heap priority queue.\\n\\n```\\npublic int HalveArray(int[] nums) {\\n        PriorityQueue<double,double> pq = new PriorityQueue<double,double>(Comparer<double>.Create((x,y) => y.CompareTo(x)));\\n        double sum = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            pq.Enqueue(nums[i],nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        double initialsum = sum;\\n        int operations = 0;\\n        while(sum > (initialsum/2)){\\n            double pop = pq.Dequeue();\\n            sum -= pop;\\n            pop = pop/2;\\n            sum += pop;\\n            pq.Enqueue(pop,pop);\\n            operations++;\\n        }\\n        \\n        return operations;\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int HalveArray(int[] nums) {\\n        PriorityQueue<double,double> pq = new PriorityQueue<double,double>(Comparer<double>.Create((x,y) => y.CompareTo(x)));\\n        double sum = 0;\\n        for(int i = 0; i < nums.Length; i++){\\n            pq.Enqueue(nums[i],nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        double initialsum = sum;\\n        int operations = 0;\\n        while(sum > (initialsum/2)){\\n            double pop = pq.Dequeue();\\n            sum -= pop;\\n            pop = pop/2;\\n            sum += pop;\\n            pq.Enqueue(pop,pop);\\n            operations++;\\n        }\\n        \\n        return operations;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865411,
                "title": "priority-queue-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n\\t\\t// SUm of all elements\\n        long double sum=0;\\n\\t\\t\\n        int count=0;\\n        priority_queue<double> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n        }\\n\\t\\t//Required sum\\n         long double reqsum=sum/2;\\n       \\n        \\n        while(sum>reqsum)\\n        {   double temp=pq.top()/2;\\n            pq.pop();\\n            pq.push(temp);         \\n            sum-=temp;\\n            count++;\\n        \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n\\t\\t// SUm of all elements\\n        long double sum=0;\\n\\t\\t\\n        int count=0;\\n        priority_queue<double> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n        }\\n\\t\\t//Required sum\\n         long double reqsum=sum/2;\\n       \\n        \\n        while(sum>reqsum)\\n        {   double temp=pq.top()/2;\\n            pq.pop();\\n            pq.push(temp);         \\n            sum-=temp;\\n            count++;\\n        \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865377,
                "title": "priority-queue-nlogn-solution",
                "content": "Please upvote it if you find it useful\\n```\\n\\tlet sum = nums.reduce((a, b) => a + b, 0)\\n    console.log(sum)\\n    const pq = new MaxPriorityQueue();\\n    for(let i=0;i<nums.length;i++){\\n        pq.enqueue(nums[i])\\n    }\\n    let n = sum/2,c=0\\n    while(sum>n){\\n        let x = pq.dequeue()\\n        x=x.element/2\\n        sum-=x\\n        pq.enqueue(x)\\n        c++\\n    }\\n    return c\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\tlet sum = nums.reduce((a, b) => a + b, 0)\\n    console.log(sum)\\n    const pq = new MaxPriorityQueue();\\n    for(let i=0;i<nums.length;i++){\\n        pq.enqueue(nums[i])\\n    }\\n    let n = sum/2,c=0\\n    while(sum>n){\\n        let x = pq.dequeue()\\n        x=x.element/2\\n        sum-=x\\n        pq.enqueue(x)\\n        c++\\n    }\\n    return c\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865234,
                "title": "python3-heap-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nEssentially, we need to find the minimum number of halving operations to get a new sum that is less or equal to half of the original sum. So the new sum can be smaller than the halve but as close as possible to it. To achieve that we need to halve elements until we meet described above condition. But which elements we should halve first? Since we are looking for a minimum, we should always start from the biggest element. To improve the time complexity of accessing the max element, we can use the max heap. \\n\\nBy default `heapq` in Python form a min heap. To convert it to the max heap, we simply need to negate all elements in `nums`.\\n\\nTime: **O(NlogN)** - for heap manipulations\\nSpace: **O(N)** - heap\\n\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        \\n        nums = [-i for i in nums]\\n        heapify(nums)\\n        \\n        total, halve, res = s, s/2, 0\\n        while total > halve:\\n            total += nums[0]/2\\n            heapreplace(nums, nums[0]/2)\\n            res += 1\\n            \\n        return res\\n```\\n\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        \\n        nums = [-i for i in nums]\\n        heapify(nums)\\n        \\n        total, halve, res = s, s/2, 0\\n        while total > halve:\\n            total += nums[0]/2\\n            heapreplace(nums, nums[0]/2)\\n            res += 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865112,
                "title": "python-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        half = total / 2\\n        count = 0\\n        nums = SortedList(nums)\\n\\n        while total > half:\\n            m = nums.pop()\\n            h = m / 2\\n            nums.add(h)\\n            total = total - m / 2\\n            count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        half = total / 2\\n        count = 0\\n        nums = SortedList(nums)\\n\\n        while total > half:\\n            m = nums.pop()\\n            h = m / 2\\n            nums.add(h)\\n            total = total - m / 2\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864912,
                "title": "java-solution-using-priorityqueue",
                "content": "In this solution we are using priorityqueue so that we can always get the largest available element from all the current elements.\\n\\nFirst we add all the elements in priorityqueue and also we find the sum of array\\nNow we run the loop till the current sum doesn\\'t become less than half of initial sum\\nIn loop we are polling first element which is the largest elemnt, then we make it half and put it back in priority queue and also we cut reduce the current sum by that also and we make use of variable to count the number of times loop is running!\\n\\n```\\nclass Solution {\\n    public int halveArray(int[] arr) {\\n        double sum = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int e: arr) {\\n            sum += e;\\n            pq.add((double) e);\\n        }\\n        \\n        double h = sum/2;\\n        int c = 0;\\n        while(sum > h){\\n            Double k = pq.poll();\\n            sum -= (k/2);\\n            k /= 2;\\n            pq.add(k);\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] arr) {\\n        double sum = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int e: arr) {\\n            sum += e;\\n            pq.add((double) e);\\n        }\\n        \\n        double h = sum/2;\\n        int c = 0;\\n        while(sum > h){\\n            Double k = pq.poll();\\n            sum -= (k/2);\\n            k /= 2;\\n            pq.add(k);\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864656,
                "title": "c-solution-using-priority-queue-line-by-line-commented-code",
                "content": "The logic is continuously dividing the largest element by 2 and updating the current total sum. When we have the reduced value **(original total sum - current total sum)** greater than **(original total sum)/2**, we stop the process.\\n\\n```\\n    int halveArray(vector<int>& nums) {\\n        int ctr = 0;\\n        \\n//      max heap(bigger element at the top)\\n        priority_queue<double> pq;\\n        \\n//      calculating total sum and storing it in tsum and tsumdup\\n        double tsum = 0, tsumdup = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            pq.push((double)nums[i]);\\n            tsum += (double)nums[i];\\n        }\\n        \\n        tsumdup = tsum;\\n        \\n        \\n//      reduced-by value initialised to 0\\n        double rby = 0;\\n        \\n        \\n//      we need rby >= (tsum/2.0)\\n//      so we need to do the operation until we have met the above condition.\\n        while(rby < (tsum/2.0)) {\\n            \\n//          increasing the counter every time we enter the while loop indicating the increament in the number of operations.\\n            ctr++;\\n            \\n//          fetching the top element\\n            double a = pq.top();\\n            pq.pop();\\n            \\n//          we need to reduce the value by half and push it back in the priority queue.\\n            a /= 2.0;\\n            pq.push(a);\\n            \\n//          update the current total sum in tsumdup\\n            tsumdup -= a;\\n            \\n//          ruduced by value will be always equal to => original total sum(tsum) - current total sum(tsumdup)   \\n            rby = tsum - tsumdup;\\n        }\\n        \\n        return ctr;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    int halveArray(vector<int>& nums) {\\n        int ctr = 0;\\n        \\n//      max heap(bigger element at the top)\\n        priority_queue<double> pq;\\n        \\n//      calculating total sum and storing it in tsum and tsumdup\\n        double tsum = 0, tsumdup = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            pq.push((double)nums[i]);\\n            tsum += (double)nums[i];\\n        }\\n        \\n        tsumdup = tsum;\\n        \\n        \\n//      reduced-by value initialised to 0\\n        double rby = 0;\\n        \\n        \\n//      we need rby >= (tsum/2.0)\\n//      so we need to do the operation until we have met the above condition.\\n        while(rby < (tsum/2.0)) {\\n            \\n//          increasing the counter every time we enter the while loop indicating the increament in the number of operations.\\n            ctr++;\\n            \\n//          fetching the top element\\n            double a = pq.top();\\n            pq.pop();\\n            \\n//          we need to reduce the value by half and push it back in the priority queue.\\n            a /= 2.0;\\n            pq.push(a);\\n            \\n//          update the current total sum in tsumdup\\n            tsumdup -= a;\\n            \\n//          ruduced by value will be always equal to => original total sum(tsum) - current total sum(tsumdup)   \\n            rby = tsum - tsumdup;\\n        }\\n        \\n        return ctr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864582,
                "title": "why-sorting-fails-heap-optimization-c-code-with-comments",
                "content": "**Brief Overview:**\\nThe aim is to find the minimum steps of operations required to reach half of the total sum of elements. This is a minimization problem. Every step taken should be the largest step, i.e., the step in which the maximum subtractable amount is halved. Since there is no restriction as to what exact value we should come up to after reduction(any value less than half sum is acceptable), the greedy approach will work perfectly.\\n**Note:** If there were some restrictions like coming up to exactly half the sum value or halve a particular number only once, We would have to use Dynamic Programming.\\n\\n**How to Approach:**\\n\\n**Sorting: Why it Fails:**\\nThis is the most intuitive approach to think of. In this approach, we can sort the array, halve the maximum element of the array, and then again sort the array; We can keep repeating it until the total sum goes less than half. Following is the code for this approach :\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        vector<double> arr; // For sake of fractional Arithmetic\\n        for(int num:nums)\\n            arr.push_back((double)num);\\n        double sum=accumulate(arr.begin(),arr.end(),0); // Total Sum\\n        double totalsum=sum;\\n        int operations=0;\\n        while(1){\\n            operations++;\\n            sort(arr.begin(),arr.end(),greater<double>()); // Sorting\\n            arr[0]/=2;                                     // Halving the gretest element\\n            sum-=arr[0];                                   // Reduce that value from total sum\\n            if(sum*2<=totalsum)\\n                break;\\n        }\\n        return operations;\\n    }\\n};\\n```\\n\\nIt fails because we need to sort the array all over again, and since each sorting operation takes O(nlogn) time, the total complexity blows up to O(n^2logn), and Time Limit gets exceeded.\\n\\n**How to Optimize:**\\nTo optimize, we have to think of something as an alternative to sorting every time. It should be noted that every time we are concerned only with the maximum element of the array and not the whole sorted array, it is worthless to have all elements sorted. Instead, we can use a max heap to keep track of the maximum element present in the array.\\n So in the fresh approach, we can use a priority queue to implement max heap. Every time the maximum element is halved, it is removed from the heap, and the halved value is added again. The time it takes to delete or insert any value in a heap is of O(logn) complexity only, which improves time complexity.\\n \\n**Code (with comments) :**\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=0;\\n        priority_queue<double> maxheap;\\n        for(int num:nums){\\n            maxheap.push((double)num);\\n            sum+=num;\\n        }\\n        double totalsum=sum;\\n        int operations=0;        \\n        while(1){\\n            operations++;\\n            double maxElement=maxheap.top(); // Extracting maximum Element\\n            maxheap.pop();\\n            maxElement/=2;                      // Halving the maximum element\\n            sum-=maxElement;                    // Reduce that value from total sum\\n            maxheap.push(maxElement);           // Heapify Operation (Takes O(logn) time, BottleNeck for the Optimization)\\n            if(sum*2<=totalsum)\\n                break;\\n        }\\n        return operations;\\n    }\\n};\\n```\\n\\n**Complexity Analysis :**\\nTime: **O(NlogN)** (Max Heap Creation is the rds(Rate determining Step))\\nSpace: **O(N)** (Max Heap of size n)\\n\\nComment down below, If you have any queries or suggestions :)\\nBest Wishes,\\nAnurag\\n\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        vector<double> arr; // For sake of fractional Arithmetic\\n        for(int num:nums)\\n            arr.push_back((double)num);\\n        double sum=accumulate(arr.begin(),arr.end(),0); // Total Sum\\n        double totalsum=sum;\\n        int operations=0;\\n        while(1){\\n            operations++;\\n            sort(arr.begin(),arr.end(),greater<double>()); // Sorting\\n            arr[0]/=2;                                     // Halving the gretest element\\n            sum-=arr[0];                                   // Reduce that value from total sum\\n            if(sum*2<=totalsum)\\n                break;\\n        }\\n        return operations;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=0;\\n        priority_queue<double> maxheap;\\n        for(int num:nums){\\n            maxheap.push((double)num);\\n            sum+=num;\\n        }\\n        double totalsum=sum;\\n        int operations=0;        \\n        while(1){\\n            operations++;\\n            double maxElement=maxheap.top(); // Extracting maximum Element\\n            maxheap.pop();\\n            maxElement/=2;                      // Halving the maximum element\\n            sum-=maxElement;                    // Reduce that value from total sum\\n            maxheap.push(maxElement);           // Heapify Operation (Takes O(logn) time, BottleNeck for the Optimization)\\n            if(sum*2<=totalsum)\\n                break;\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864470,
                "title": "go-golang-time-o-n-log-n-n-484-ms-100-space-o-n-12-9-mb-100",
                "content": "Thanks to the original solution, [[Python3, Java, C++] Priority Queue O(nlogn)](https://leetcode.com/problems/minimum-operations-to-halve-array-sum/discuss/1863899/Python3-Java-C%2B%2B-Priority-Queue-O(nlogn)).\\n```\\ntype Item struct {\\n\\tvalue float64\\n\\tpriority float64\\n\\tindex int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].priority > pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil\\n\\titem.index = -1\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\nfunc (pq *PriorityQueue) update(item *Item, value, priority float64) {\\n\\titem.value = value\\n\\titem.priority = priority\\n\\theap.Fix(pq, item.index)\\n}\\n\\nfunc halveArray(nums []int) int {\\n    var sum, k float64\\n    pq := make(PriorityQueue, len(nums))\\n    for i, num := range nums {\\n        sum += float64(num)\\n        pq[i] = &Item{\\n            value: float64(num),\\n\\t\\t\\tpriority: float64(num),\\n            index: i,\\n\\t\\t}\\n\\t\\ti++\\n    }\\n    heap.Init(&pq)\\n    \\n    result := 0\\n    for pq.Len() > 0 && sum - k > sum / 2 {\\n        item := heap.Pop(&pq).(*Item)\\n        value := item.value / 2\\n        k += value\\n        newItem := &Item{\\n            value: value,\\n            priority: value,\\n        }\\n        heap.Push(&pq, newItem)\\n        result++\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype Item struct {\\n\\tvalue float64\\n\\tpriority float64\\n\\tindex int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].priority > pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil\\n\\titem.index = -1\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\nfunc (pq *PriorityQueue) update(item *Item, value, priority float64) {\\n\\titem.value = value\\n\\titem.priority = priority\\n\\theap.Fix(pq, item.index)\\n}\\n\\nfunc halveArray(nums []int) int {\\n    var sum, k float64\\n    pq := make(PriorityQueue, len(nums))\\n    for i, num := range nums {\\n        sum += float64(num)\\n        pq[i] = &Item{\\n            value: float64(num),\\n\\t\\t\\tpriority: float64(num),\\n            index: i,\\n\\t\\t}\\n\\t\\ti++\\n    }\\n    heap.Init(&pq)\\n    \\n    result := 0\\n    for pq.Len() > 0 && sum - k > sum / 2 {\\n        item := heap.Pop(&pq).(*Item)\\n        value := item.value / 2\\n        k += value\\n        newItem := &Item{\\n            value: value,\\n            priority: value,\\n        }\\n        heap.Push(&pq, newItem)\\n        result++\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864413,
                "title": "python3-optimized-solution-o-nlogn-heap-priority-queue",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        t = sum(nums)\\n        l = [-i for i in nums]\\n        heapq.heapify(l)\\n        c = 0\\n        while s>t/2:\\n            a = heapq.heappop(l)\\n            a = a/2 \\n            s+=a\\n            c+=1\\n            heapq.heappush(l,a)\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        t = sum(nums)\\n        l = [-i for i in nums]\\n        heapq.heapify(l)\\n        c = 0\\n        while s>t/2:\\n            a = heapq.heappop(l)\\n            a = a/2 \\n            s+=a\\n            c+=1\\n            heapq.heappush(l,a)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864369,
                "title": "c-priority-queue-explanation-simplest-approach",
                "content": "**SIMPLE APPROACH\\uD83E\\uDD17**\\n**EXPLANATION:**\\n* **THE MAIN POINT TO REMEMBER \\uD83E\\uDD14\\uD83E\\uDD14\\uD83E\\uDD14\\uD83E\\uDD14 HERE IS THAT WHICH DATA STRUCTURE WE CAN USE TO MAINTAIN THE MAXIMUM ELEMENT WITHOUT USING A FOR LOOP.**\\n* **ANS---->\\uD83D\\uDCA1\\uD83D\\uDCA1\\uD83D\\uDCA1SO HERE WE CAN USE EITHER PRIORITY QUEUE OR HEAP.\\uD83D\\uDCA1\\uD83D\\uDCA1\\uD83D\\uDCA1**\\n* **FIRST WE CREATE A PRIORITY QUEUE OF double DATATYPE AND ALSO FIND OUT THE SUM OF THE ELEMENTS.**\\n* **THEN WE HAVE TO PERFORM OPERATIONS UNTILL WE GET THE RESULTANT SUN GREATER THAN OR EQUAL TO THE HALF OF THE ORIGINAL SUM.**\\n* **WITH THE HELP OF PRIORITY QUEUE WE HAVE THE MAXIMUM ELEMNT ALWAYS ON THE TOP.**\\n* **HERE WE CAN GET OPTIMAL SOLUTION ONLY WHEN WE DECREASE THE MAXIMUM ELEMENT TO HALF OF IT.**\\n* **SO SIMPLY WE WILL POP OUT THE TOP MOST ELEMENT OF THE PRIORITY QUEUE AND ADD ITS HALD TO THE SUM AND PUSH THE NEW HALVE ELEMENT ONTO THE QUEUE.**\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& num) \\n    {\\n        priority_queue<double> nums;\\n        double sum = 0;\\n        for(auto i:num)\\n        {\\n            sum+=i;\\n            nums.push(i);\\n        }\\n        double res=sum/2;\\n        int c=0;       // TO STORE NUMBER OF OPERATIONS\\n        sum = 0;    // RESULTANT SUM WHICH SHOULD BE GREATER THAN EQUAL TO HALF OF THE SUM\\n        while(1)\\n        {\\n            double curr = nums.top();\\n            nums.pop();\\n            sum+=curr/2;\\n            nums.push(curr/2);\\n            ++c;\\n            \\n            if(sum>=res)\\n                break;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF FOUND HELPFULL**\\n**HAPPY LEARNING. HAPPY CODING.**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& num) \\n    {\\n        priority_queue<double> nums;\\n        double sum = 0;\\n        for(auto i:num)\\n        {\\n            sum+=i;\\n            nums.push(i);\\n        }\\n        double res=sum/2;\\n        int c=0;       // TO STORE NUMBER OF OPERATIONS\\n        sum = 0;    // RESULTANT SUM WHICH SHOULD BE GREATER THAN EQUAL TO HALF OF THE SUM\\n        while(1)\\n        {\\n            double curr = nums.top();\\n            nums.pop();\\n            sum+=curr/2;\\n            nums.push(curr/2);\\n            ++c;\\n            \\n            if(sum>=res)\\n                break;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864326,
                "title": "c-easy-and-simple-priority-queue-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        double sum = 0;\\n        for(int i : nums){\\n            q.push(i);\\n            sum += i;\\n        }\\n        double sum2 = sum;\\n        int cnt = 0;\\n        while(sum2 > sum/2){\\n            double x = q.top();\\n            q.pop();\\n            x /= 2;\\n            sum2 -= x;\\n            q.push(x);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        double sum = 0;\\n        for(int i : nums){\\n            q.push(i);\\n            sum += i;\\n        }\\n        double sum2 = sum;\\n        int cnt = 0;\\n        while(sum2 > sum/2){\\n            double x = q.top();\\n            q.pop();\\n            x /= 2;\\n            sum2 -= x;\\n            q.push(x);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864316,
                "title": "c-max-heap-o-n-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        if (nums.size() == 1)\\n            return 1;\\n        long long int sum = 0;\\n        priority_queue<float> pq;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            pq.push(nums[i]);\\n        }\\n        double ans = (double)sum / 2;\\n        long long count = 0;\\n        while (ans > 0)\\n        {\\n            double x = pq.top();\\n            pq.pop();\\n            ans -= x / 2;\\n            pq.push(x / 2);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        if (nums.size() == 1)\\n            return 1;\\n        long long int sum = 0;\\n        priority_queue<float> pq;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            pq.push(nums[i]);\\n        }\\n        double ans = (double)sum / 2;\\n        long long count = 0;\\n        while (ans > 0)\\n        {\\n            double x = pq.top();\\n            pq.pop();\\n            ans -= x / 2;\\n            pq.push(x / 2);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864282,
                "title": "c-priorityqueue-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int HalveArray(int[] nums) {\\n        var pq = new PriorityQueue<double, double>(new Comparer());\\n        int count = 0;\\n        double half = 0,sum = 0;\\n        \\n        foreach(int i in nums){\\n            pq.Enqueue((double)i, (double)i);\\n            sum += (double)i;\\n        }\\n        \\n        half = sum/2;\\n        while(sum > half && pq.Count > 0){\\n            double num = pq.Dequeue();\\n            double num2 = num/2;\\n            sum -= num2;\\n            pq.Enqueue(num2, num2);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public class Comparer: IComparer<double>\\n    {\\n        public int Compare(double x, double y) => y.CompareTo(x);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int HalveArray(int[] nums) {\\n        var pq = new PriorityQueue<double, double>(new Comparer());\\n        int count = 0;\\n        double half = 0,sum = 0;\\n        \\n        foreach(int i in nums){\\n            pq.Enqueue((double)i, (double)i);\\n            sum += (double)i;\\n        }\\n        \\n        half = sum/2;\\n        while(sum > half && pq.Count > 0){\\n            double num = pq.Dequeue();\\n            double num2 = num/2;\\n            sum -= num2;\\n            pq.Enqueue(num2, num2);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public class Comparer: IComparer<double>\\n    {\\n        public int Compare(double x, double y) => y.CompareTo(x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864238,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0;\\n        priority_queue<double> pq;\\n        for (int i: nums){\\n            sum+=i;\\n            pq.push((double)i);\\n        }\\n        double temp = sum;\\n        int count = 0;\\n        sum/=2;\\n        while(temp>sum){\\n            double x = pq.top();\\n            temp -= x/2;\\n            pq.pop();\\n            pq.push(x/2);\\n            count++;\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0;\\n        priority_queue<double> pq;\\n        for (int i: nums){\\n            sum+=i;\\n            pq.push((double)i);\\n        }\\n        double temp = sum;\\n        int count = 0;\\n        sum/=2;\\n        while(temp>sum){\\n            double x = pq.top();\\n            temp -= x/2;\\n            pq.pop();\\n            pq.push(x/2);\\n            count++;\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864201,
                "title": "max-heap",
                "content": "Creating max heap from the array (of size n) takes O(n) of time, while accessing the maximum element (greedy ) takes O(logn), so we\\'re good to go. \\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=0,temp_sum=0,ma,mai;\\n        priority_queue<double> nums1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums1.push(nums[i]);\\n        }\\n        int ans=0;\\n        temp_sum=sum;\\n        while(1){\\n            if(temp_sum<=sum/2)break;\\n            mai=nums1.top();\\n            nums1.pop();\\n            temp_sum-=mai/2;\\n            nums1.push(mai/2);\\n            ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=0,temp_sum=0,ma,mai;\\n        priority_queue<double> nums1;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            nums1.push(nums[i]);\\n        }\\n        int ans=0;\\n        temp_sum=sum;\\n        while(1){\\n            if(temp_sum<=sum/2)break;\\n            mai=nums1.top();\\n            nums1.pop();\\n            temp_sum-=mai/2;\\n            nums1.push(mai/2);\\n            ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864186,
                "title": "c-max-heap",
                "content": "\\t\\t\\tpublic static int HalveArray(int[] nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble sum = 0;\\n\\t\\t\\t\\t// Create max heap. In Order to deal with duplicate numbers, add index as a parameter\\n\\t\\t\\t\\tvar set = new SortedSet<(double num, int ind)>(Comparer<(double, int)>.Create((k1, k2) => k1.Item1 == k2.Item1 ? k2.Item2.CompareTo(k1.Item2) : k2.Item1.CompareTo(k1.Item1)));\\n\\n\\t\\t\\t\\tint op = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < nums.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tset.Add((nums[i], i));\\n\\t\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar exact = sum / 2;\\n\\n\\t\\t\\t\\twhile (sum > exact)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar el = set.Min;\\n\\t\\t\\t\\t\\tset.Remove(el);\\n\\t\\t\\t\\t\\tsum -= el.num;\\n\\t\\t\\t\\t\\tel.num /= 2;\\n\\n\\t\\t\\t\\t\\tset.Add(el);\\n\\t\\t\\t\\t\\tsum += el.num;\\n\\t\\t\\t\\t\\top++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn op;\\n\\t\\t\\t}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "\\t\\t\\tpublic static int HalveArray(int[] nums)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble sum = 0;\\n\\t\\t\\t\\t// Create max heap. In Order to deal with duplicate numbers, add index as a parameter\\n\\t\\t\\t\\tvar set = new SortedSet<(double num, int ind)>(Comparer<(double, int)>.Create((k1, k2) => k1.Item1 == k2.Item1 ? k2.Item2.CompareTo(k1.Item2) : k2.Item1.CompareTo(k1.Item1)));\\n\\n\\t\\t\\t\\tint op = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < nums.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tset.Add((nums[i], i));\\n\\t\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar exact = sum / 2;\\n\\n\\t\\t\\t\\twhile (sum > exact)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar el = set.Min;\\n\\t\\t\\t\\t\\tset.Remove(el);\\n\\t\\t\\t\\t\\tsum -= el.num;\\n\\t\\t\\t\\t\\tel.num /= 2;\\n\\n\\t\\t\\t\\t\\tset.Add(el);\\n\\t\\t\\t\\t\\tsum += el.num;\\n\\t\\t\\t\\t\\top++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn op;\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1864117,
                "title": "c-simple-max-heap-solution-with-explanation",
                "content": "1.  We can take the maximum value from the array and reduce it to half.\\n2.  So the basic step are deleting the maximum value from the array and inserting the halved value into the array.\\n3.  The best data structure for this purpose is priority queue(or max heap).\\n4. Do step 2 until the sum of the array is reduced to atleast half.\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        long double sum = 0;\\n        for(int num : nums)\\n            q.push(num), sum += num;\\n        long double target = sum/2;\\n        int operations = 0;\\n        while(sum > target){\\n            double curr = q.top();\\n            q.pop();\\n            sum -= curr/2;\\n            q.push(curr/2);\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```\\n* **Time Complexity : O(NLogN)**\\n* **Space Complexity : O(N)**\\n***If you find this helpful, show some love in the form of upvote***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        long double sum = 0;\\n        for(int num : nums)\\n            q.push(num), sum += num;\\n        long double target = sum/2;\\n        int operations = 0;\\n        while(sum > target){\\n            double curr = q.top();\\n            q.pop();\\n            sum -= curr/2;\\n            q.push(curr/2);\\n            operations++;\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864099,
                "title": "c-priority-queue-max-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        priority_queue<float> pq;\\n        double sum=0;\\n        \\n        \\n        \\n        for(auto &it:nums)\\n        {\\n            pq.push(it);\\n            sum+=it;\\n        }\\n        \\n        int cnt=0;\\n        double halfSum=sum/2.0;\\n        double copy=sum;\\n        while(sum-copy < halfSum)\\n        {\\n            double temp=pq.top();\\n            pq.pop();\\n             copy-=temp;\\n            temp=temp/2.0;\\n            \\n            copy+=temp;\\n            \\n           \\n            \\n            pq.push(temp);\\n            cnt+=1;\\n                     \\n            \\n            cout<<copy<<\" \";\\n            \\n        }\\n        cout<<endl;\\n    \\n        \\n        return cnt;\\n        \\n        \\n        \\n       \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        priority_queue<float> pq;\\n        double sum=0;\\n        \\n        \\n        \\n        for(auto &it:nums)\\n        {\\n            pq.push(it);\\n            sum+=it;\\n        }\\n        \\n        int cnt=0;\\n        double halfSum=sum/2.0;\\n        double copy=sum;\\n        while(sum-copy < halfSum)\\n        {\\n            double temp=pq.top();\\n            pq.pop();\\n             copy-=temp;\\n            temp=temp/2.0;\\n            \\n            copy+=temp;\\n            \\n           \\n            \\n            pq.push(temp);\\n            cnt+=1;\\n                     \\n            \\n            cout<<copy<<\" \";\\n            \\n        }\\n        cout<<endl;\\n    \\n        \\n        return cnt;\\n        \\n        \\n        \\n       \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1864095,
                "title": "python-heap-easy-understanding-10line-code",
                "content": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        half, ans = sum(nums)/2, 0\\n        minHeap = [-i for i in nums]\\n        heapify(minHeap)\\n        while half>0:\\n            val = heappop(minHeap)\\n            val /= 2.0\\n            half += val\\n            heappush(minHeap, val)\\n            ans+=1\\n        return ans\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        half, ans = sum(nums)/2, 0\\n        minHeap = [-i for i in nums]\\n        heapify(minHeap)\\n        while half>0:\\n            val = heappop(minHeap)\\n            val /= 2.0\\n            half += val\\n            heappush(minHeap, val)\\n            ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864040,
                "title": "priority-queue-solution-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint halveArray(vector<int>& nums) {\\n\\t\\t\\tpriority_queue<double> pq; // maximum element max heap\\n\\n\\t\\t\\tdouble sum = 0.0;\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tpq.push(num * 1.0);\\n\\n\\t\\t\\t\\tsum += num;\\n\\t\\t\\t}\\n\\n\\t\\t\\tdouble target = sum / 2.0;\\n\\n\\n\\t\\t\\tint operation = 0;\\n\\t\\t\\twhile(!pq.empty() and target < sum){\\n\\n\\t\\t\\t\\tdouble top = pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\n\\t\\t\\t\\tsum -= top/2.0;\\n\\t\\t\\t\\tpq.push(top/2.0);\\n\\n\\n\\t\\t\\t\\toperation++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn operation;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint halveArray(vector<int>& nums) {\\n\\t\\t\\tpriority_queue<double> pq; // maximum element max heap\\n\\n\\t\\t\\tdouble sum = 0.0;\\n\\t\\t\\tfor(int num : nums){\\n\\t\\t\\t\\tpq.push(num * 1.0);\\n\\n\\t\\t\\t\\tsum += num;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1863986,
                "title": "c-priority-queue-solution",
                "content": "Pick maximum number present in the array, to greedily reduce the sum the fastest way. Take care of the double.\\n\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        long double sum = 0, half = 0;\\n        \\n        for(auto &x : nums)\\n            sum += x;\\n        \\n        half = sum/(2.0);\\n        \\n        priority_queue <long double, vector <long double> >pq;\\n        \\n        for(auto &x : nums)\\n            pq.push(x);\\n            \\n        int ans = 0;\\n        \\n        while(!pq.empty())\\n        {\\n            auto tp = pq.top();\\n            pq.pop();\\n            ans++;\\n            tp = tp/2.0;\\n            \\n            sum -= tp;\\n            pq.push(tp);\\n            if(sum <= half)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        long double sum = 0, half = 0;\\n        \\n        for(auto &x : nums)\\n            sum += x;\\n        \\n        half = sum/(2.0);\\n        \\n        priority_queue <long double, vector <long double> >pq;\\n        \\n        for(auto &x : nums)\\n            pq.push(x);\\n            \\n        int ans = 0;\\n        \\n        while(!pq.empty())\\n        {\\n            auto tp = pq.top();\\n            pq.pop();\\n            ans++;\\n            tp = tp/2.0;\\n            \\n            sum -= tp;\\n            pq.push(tp);\\n            if(sum <= half)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863981,
                "title": "python-solution-using-heap",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        l = [-i for i in nums]\\n        heapq.heapify(l)\\n        curr = s\\n        ans = 0\\n        while curr > 1.0*s/2:\\n            x = -heapq.heappop(l)\\n            curr -= 1.0*x/2\\n            heapq.heappush(l,-1.0*x/2)\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        s = sum(nums)\\n        l = [-i for i in nums]\\n        heapq.heapify(l)\\n        curr = s\\n        ans = 0\\n        while curr > 1.0*s/2:\\n            x = -heapq.heappop(l)\\n            curr -= 1.0*x/2\\n            heapq.heappush(l,-1.0*x/2)\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863958,
                "title": "heap-greedy-technique-simple-explained",
                "content": "To find the minimum operation we **greedily remove the largest element**.\\nTo find the largest element we use **MAX - HEAP data structure**\\n\\nProcedure:\\n1. Find the largest element\\n2. Divide it by two & add to the value you removed \\n3. Increase the number of operations by 1\\n4. Check whether you have removed more than half or not\\n5. Go back to step-1 if you have not\\n\\nNote: - In Python we use negative numbers to transform min-heap to max-heap\\n```\\nimport heapq\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        heap = [-x for x in nums]\\n        heapq.heapify(heap)\\n        total = sum(nums)\\n        reqd = total/2 #Amount which we have to remove\\n        operations = 0 \\n        \\n        removed = 0\\n        while removed<reqd: #If we have removed less keep on looping\\n            var = heapq.heappop(heap) #Finding the largest element\\n\\t\\t\\tvar = -var #Changing it back to +ve number\\n            var = var/2 \\n            removed+=var #Total amount removed from the array\\n            operations+=1\\n            heapq.heappush(heap,-var) #Push it back since you can use it again \\n        return operations\\n```\\nPlease upvote if you the solution helped you !!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        heap = [-x for x in nums]\\n        heapq.heapify(heap)\\n        total = sum(nums)\\n        reqd = total/2 #Amount which we have to remove\\n        operations = 0 \\n        \\n        removed = 0\\n        while removed<reqd: #If we have removed less keep on looping\\n            var = heapq.heappop(heap) #Finding the largest element\\n\\t\\t\\tvar = -var #Changing it back to +ve number\\n            var = var/2 \\n            removed+=var #Total amount removed from the array\\n            operations+=1\\n            heapq.heappush(heap,-var) #Push it back since you can use it again \\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863934,
                "title": "c-heap",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Heap\\n\\nGreedily pick the greatest available number, half it and put it back, until the `sum` halves. We can keep the available numbers in a Max-Heap for easy access to the max number.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-74/problems/minimum-operations-to-halve-array-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& A) {\\n        priority_queue<double> pq;\\n        double sum = 0;\\n        int ans = 0;\\n        for (int n : A) {\\n            pq.push(n);\\n            sum += n;\\n        }\\n        double goal = sum / 2;\\n        while (sum > goal) {\\n            auto x = pq.top();\\n            pq.pop();\\n            sum -= x / 2;\\n            pq.push(x / 2);\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-74/problems/minimum-operations-to-halve-array-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& A) {\\n        priority_queue<double> pq;\\n        double sum = 0;\\n        int ans = 0;\\n        for (int n : A) {\\n            pq.push(n);\\n            sum += n;\\n        }\\n        double goal = sum / 2;\\n        while (sum > goal) {\\n            auto x = pq.top();\\n            pq.pop();\\n            sum -= x / 2;\\n            pq.push(x / 2);\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863910,
                "title": "c-priority-queue-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n          if(nums.size() == 1) return 1;\\n          priority_queue<double, vector<double>> pq;\\n           double sum = 0;\\n          vector<double> num;\\n          for(int ele : nums) {\\n              double x = (double)(ele);\\n               num.push_back(x);\\n          }\\n           for(double ele : num) {pq.push(ele); sum = sum + ele;}\\n           double cur_sum = sum;\\n           int ans = 0;\\n           while(cur_sum > (sum / 2)){\\n                 double t = pq.top();\\n                 pq.pop();\\n                 cur_sum = cur_sum - (t / 2);\\n                 t = t / 2;\\n                 pq.push(t);\\n                 ans++;\\n           } \\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n          if(nums.size() == 1) return 1;\\n          priority_queue<double, vector<double>> pq;\\n           double sum = 0;\\n          vector<double> num;\\n          for(int ele : nums) {\\n              double x = (double)(ele);\\n               num.push_back(x);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1863901,
                "title": "java-priorityqueue",
                "content": "we are ```greedily``` picking the maximum number in the heap, dividing it by two adding\\n in currentSum and pushing currentSum in priorityQueue.\\nwhy greedy ? \\n     because we want to increase ```curentSum >= tar``` in as minimum operations as possible.\\n\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        Double sum = 0.0;\\n        for (int i : nums) {\\n            pq.add(i * 1.0);\\n            sum += i;\\n        }\\n        double tar = sum / 2;\\n        int operations = 0;\\n        \\n        double currentSum = 0;\\n        while (currentSum < tar) {\\n            double pop = pq.remove();\\n            currentSum += pop / 2;\\n            pq.add(pop / 2);\\n            operations++;\\n        }\\n        return operations;\\n    }\\n}\\n ```\\n",
                "solutionTags": [],
                "code": "```greedily```\n```curentSum >= tar```\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        Double sum = 0.0;\\n        for (int i : nums) {\\n            pq.add(i * 1.0);\\n            sum += i;\\n        }\\n        double tar = sum / 2;\\n        int operations = 0;\\n        \\n        double currentSum = 0;\\n        while (currentSum < tar) {\\n            double pop = pq.remove();\\n            currentSum += pop / 2;\\n            pq.add(pop / 2);\\n            operations++;\\n        }\\n        return operations;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 4067273,
                "title": "c-priority-queue-simple-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        priority_queue<double> pq;\\n        double sum = 0, current_sum;\\n        int ans = 0;\\n\\n        for(auto num: nums) pq.push(num), sum += num;\\n        current_sum = sum;\\n\\n        while(current_sum > sum/2)\\n        {\\n            double current_no = pq.top();\\n            pq.pop();\\n\\n            current_no = current_no/2;\\n            current_sum -= current_no;\\n            pq.push(current_no);\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        priority_queue<double> pq;\\n        double sum = 0, current_sum;\\n        int ans = 0;\\n\\n        for(auto num: nums) pq.push(num), sum += num;\\n        current_sum = sum;\\n\\n        while(current_sum > sum/2)\\n        {\\n            double current_no = pq.top();\\n            pq.pop();\\n\\n            current_no = current_no/2;\\n            current_sum -= current_no;\\n            pq.push(current_no);\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046796,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        if(nums.size()==1) return 1;\\n        double sum=accumulate(nums.begin(),nums.end(),0.0),temp=sum,step=0;\\n        priority_queue<double>pq(nums.begin(),nums.end());\\n        while(sum/2<temp){\\n            step++;\\n            double m=pq.top()/2;\\n            pq.pop();\\n            pq.push(m);\\n            temp-=m;\\n        }\\n        return step; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        if(nums.size()==1) return 1;\\n        double sum=accumulate(nums.begin(),nums.end(),0.0),temp=sum,step=0;\\n        priority_queue<double>pq(nums.begin(),nums.end());\\n        while(sum/2<temp){\\n            step++;\\n            double m=pq.top()/2;\\n            pq.pop();\\n            pq.push(m);\\n            temp-=m;\\n        }\\n        return step; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028598,
                "title": "using-pq-easy-cpp",
                "content": "# Intuition\\nThe problem asks for the minimum number of operations to reduce the sum of the given positive integers by at least half. To minimize the number of operations, we should try to halve the largest numbers first because reducing a larger number by half has a greater impact on the sum. Therefore, we can use a priority queue (max heap) to keep track of the largest numbers in the array.\\n\\n# Approach\\n1. Calculate the initial sum of all elements in the `nums` array.\\n2. Initialize a priority queue (`pq`) as a max heap to store the elements of `nums`.\\n3. Push all elements of `nums` into the priority queue and calculate the sum of all elements.\\n4. Calculate the target sum `d`, which is half of the initial sum.\\n5. Initialize a variable `cnt` to keep track of the number of operations.\\n6. While the current sum is greater than `d` and the priority queue is not empty, do the following:\\n   - Get the largest element from the priority queue by popping it.\\n   - Calculate half of this element and subtract it from the current sum.\\n   - If the result of halving the element is greater than 0, push it back into the priority queue.\\n   - Increment the `cnt` by 1 for each operation.\\n7. Return the value of `cnt` as the minimum number of operations required to reduce the sum by at least half.\\n\\n# Complexity\\n- Time complexity: O(n*log(n)) because we are using a priority queue (max heap) to process the elements.\\n- Space complexity: O(n) because we are using a priority queue to store the elements of `nums`.\\n\\n# Code\\nHere\\'s the code for the provided solution:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0;\\n        priority_queue<double, vector<double>> pq;\\n        \\n        // Calculate the initial sum and push elements into the priority queue\\n        for (auto i : nums) {\\n            sum += i;\\n            pq.push((double)i);\\n        }\\n        \\n        double d = sum / 2.0; // Target sum\\n        int cnt = 0; // Number of operations\\n        \\n        // Reduce the sum by halving the largest elements\\n        while (sum > d && !pq.empty()) {\\n            double dd = pq.top() / 2.0; // Halve the largest element\\n            sum -= dd; // Update the current sum\\n            pq.pop(); // Remove the largest element from the priority queue\\n            \\n            if (dd > 0) {\\n                pq.push(dd); // Push the halved element back into the priority queue\\n            }\\n            \\n            cnt++; // Increment the operation count\\n        }\\n        \\n        return cnt; // Return the minimum number of operations\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0;\\n        priority_queue<double, vector<double>> pq;\\n        \\n        // Calculate the initial sum and push elements into the priority queue\\n        for (auto i : nums) {\\n            sum += i;\\n            pq.push((double)i);\\n        }\\n        \\n        double d = sum / 2.0; // Target sum\\n        int cnt = 0; // Number of operations\\n        \\n        // Reduce the sum by halving the largest elements\\n        while (sum > d && !pq.empty()) {\\n            double dd = pq.top() / 2.0; // Halve the largest element\\n            sum -= dd; // Update the current sum\\n            pq.pop(); // Remove the largest element from the priority queue\\n            \\n            if (dd > 0) {\\n                pq.push(dd); // Push the halved element back into the priority queue\\n            }\\n            \\n            cnt++; // Increment the operation count\\n        }\\n        \\n        return cnt; // Return the minimum number of operations\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025377,
                "title": "cpp-solution-using-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double>pq;\\n\\n        double tsum = 0;\\n\\n        for(auto x: nums)\\n        {\\n            pq.push(x);\\n            tsum += x;\\n        }\\n\\n        double req_sum = tsum / 2;\\n        int ans = 0;\\n\\n        while(tsum > req_sum)\\n        {\\n            double x = pq.top();\\n            pq.pop();\\n            x /= 2;\\n            pq.push(x);\\n            tsum -= x;\\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double>pq;\\n\\n        double tsum = 0;\\n\\n        for(auto x: nums)\\n        {\\n            pq.push(x);\\n            tsum += x;\\n        }\\n\\n        double req_sum = tsum / 2;\\n        int ans = 0;\\n\\n        while(tsum > req_sum)\\n        {\\n            double x = pq.top();\\n            pq.pop();\\n            x /= 2;\\n            pq.push(x);\\n            tsum -= x;\\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993965,
                "title": "easy-java-solution-using-priorityqueue-heap",
                "content": "# Complexity\\n- Time complexity:O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> heap = new PriorityQueue<>(Comparator.reverseOrder());\\n        int count = 0;\\n        double sum =0.0;\\n        for(double x : nums){\\n            heap.add(x);\\n            sum+=x;\\n        }\\n\\n        double halfSum = sum/2;\\n\\n        while(halfSum<sum){\\n            double halfHighest=heap.remove()/2;\\n            heap.add(halfHighest);\\n            sum-=halfHighest;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> heap = new PriorityQueue<>(Comparator.reverseOrder());\\n        int count = 0;\\n        double sum =0.0;\\n        for(double x : nums){\\n            heap.add(x);\\n            sum+=x;\\n        }\\n\\n        double halfSum = sum/2;\\n\\n        while(halfSum<sum){\\n            double halfHighest=heap.remove()/2;\\n            heap.add(halfHighest);\\n            sum-=halfHighest;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974759,
                "title": "using-max-heap-tc-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        double sum = 0;\\n        // push all elements in maxHeap also update sum\\n        for(auto i : nums){\\n            sum += i;\\n            pq.push(i);\\n        }\\n        int steps = 0;\\n        double half = 0;\\n\\n        while(sum / 2.0 > half){\\n            // take out top and pop \\n            double temp = pq.top();\\n            pq.pop();\\n            // update top\\n            temp -= temp/2.0;\\n            // update half\\n            half += temp;\\n            // push top\\n            pq.push(temp);\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        double sum = 0;\\n        // push all elements in maxHeap also update sum\\n        for(auto i : nums){\\n            sum += i;\\n            pq.push(i);\\n        }\\n        int steps = 0;\\n        double half = 0;\\n\\n        while(sum / 2.0 > half){\\n            // take out top and pop \\n            double temp = pq.top();\\n            pq.pop();\\n            // update top\\n            temp -= temp/2.0;\\n            // update half\\n            half += temp;\\n            // push top\\n            pq.push(temp);\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952033,
                "title": "rust-heap-beats-100-easy-to-understand",
                "content": "# Approach\\n- Heap\\n\\n# Complexity\\n- Time complexity: $O(n log n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```rust\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\n#[derive(Debug, PartialEq, PartialOrd)]\\nstruct FloatWrapper(f64);\\n\\nimpl Ord for FloatWrapper {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self.partial_cmp(other).unwrap()\\n    }\\n}\\nimpl Eq for FloatWrapper {}\\n\\nimpl Solution {\\n    pub fn halve_array(nums: Vec<i32>) -> i32 {\\n        let mut sum = 0.0;\\n        let mut nums_f64 = vec![];\\n        for i in 0..nums.len() {\\n            sum += nums[i] as f64;\\n            nums_f64.push(FloatWrapper(nums[i] as f64));\\n        }\\n        let half = sum / 2.0;\\n        let mut operations = 0;\\n        let mut heap: BinaryHeap<FloatWrapper> = BinaryHeap::from(nums_f64);\\n        while sum > half {\\n            let max = heap.pop().unwrap().0;\\n            heap.push(FloatWrapper(max / 2.0));\\n            operations += 1;\\n            sum -= max / 2.0;\\n        }\\n        operations\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\n#[derive(Debug, PartialEq, PartialOrd)]\\nstruct FloatWrapper(f64);\\n\\nimpl Ord for FloatWrapper {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self.partial_cmp(other).unwrap()\\n    }\\n}\\nimpl Eq for FloatWrapper {}\\n\\nimpl Solution {\\n    pub fn halve_array(nums: Vec<i32>) -> i32 {\\n        let mut sum = 0.0;\\n        let mut nums_f64 = vec![];\\n        for i in 0..nums.len() {\\n            sum += nums[i] as f64;\\n            nums_f64.push(FloatWrapper(nums[i] as f64));\\n        }\\n        let half = sum / 2.0;\\n        let mut operations = 0;\\n        let mut heap: BinaryHeap<FloatWrapper> = BinaryHeap::from(nums_f64);\\n        while sum > half {\\n            let max = heap.pop().unwrap().0;\\n            heap.push(FloatWrapper(max / 2.0));\\n            operations += 1;\\n            sum -= max / 2.0;\\n        }\\n        operations\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941180,
                "title": "very-easy-solution-using-maxheap",
                "content": "\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        for(int stones : nums) q.push(static_cast<double>(stones));\\n        double total = 0;\\n        for(int el : nums) total += el;\\n        double reducedTotal = 0;\\n        int count = 0;\\n        while((double)total / 2 > reducedTotal){\\n            count++;\\n            double maxi = q.top();\\n            q.pop();\\n            maxi -= maxi / 2;\\n            reducedTotal += maxi;\\n            q.push(maxi);\\n        }\\n        return count;\\n        \\n    }\\n    \\n};\\n```\\n```Java []\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> q = new PriorityQueue<>((a, b) -> Double.compare(b, a));\\n        for(int stones : nums) q.add((double)stones);\\n        double total = 0;\\n        for(int el : nums) total += el;\\n        double reducedTotal = 0;\\n        int count = 0;\\n        while((double)total / 2 > reducedTotal){\\n            count++;\\n            double maxi = q.poll();\\n            maxi -= maxi / 2;\\n            reducedTotal += maxi;\\n            q.add(maxi);\\n        }\\n        return count++;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> q;\\n        for(int stones : nums) q.push(static_cast<double>(stones));\\n        double total = 0;\\n        for(int el : nums) total += el;\\n        double reducedTotal = 0;\\n        int count = 0;\\n        while((double)total / 2 > reducedTotal){\\n            count++;\\n            double maxi = q.top();\\n            q.pop();\\n            maxi -= maxi / 2;\\n            reducedTotal += maxi;\\n            q.push(maxi);\\n        }\\n        return count;\\n        \\n    }\\n    \\n};\\n```\n```Java []\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> q = new PriorityQueue<>((a, b) -> Double.compare(b, a));\\n        for(int stones : nums) q.add((double)stones);\\n        double total = 0;\\n        for(int el : nums) total += el;\\n        double reducedTotal = 0;\\n        int count = 0;\\n        while((double)total / 2 > reducedTotal){\\n            count++;\\n            double maxi = q.poll();\\n            maxi -= maxi / 2;\\n            reducedTotal += maxi;\\n            q.add(maxi);\\n        }\\n        return count++;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927826,
                "title": "best-java-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] arr) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        double sum = 0;\\n        int n = arr.length;\\n\\n        for(int i=0; i<n; i++){\\n            sum+=(double)arr[i];\\n            pq.add((double)arr[i]);\\n        }\\n\\n        double a = sum/2;\\n        int ans = 0;\\n\\n        while(sum>a){\\n            double x = pq.remove()/2;\\n            sum = sum - x;\\n            pq.add(x);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] arr) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        double sum = 0;\\n        int n = arr.length;\\n\\n        for(int i=0; i<n; i++){\\n            sum+=(double)arr[i];\\n            pq.add((double)arr[i]);\\n        }\\n\\n        double a = sum/2;\\n        int ans = 0;\\n\\n        while(sum>a){\\n            double x = pq.remove()/2;\\n            sum = sum - x;\\n            pq.add(x);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917913,
                "title": "2208-minimum-operations-to-halve-array-sum-python-solution",
                "content": "# Intuition\\nWe should get the maximum `num` at each operation to minimize the number of `operations`. So, the intuition is to use the max heap to get the maximum `num`.\\n\\n# Approach\\n- Get the sum of `nums` and store it in `t` and `s`.\\n- Max heapify `nums`.\\n- Pop `num` from the max heap and push it back with `(num / 2)`.\\n- Decrement the `s` by `(num / 2)`.\\n- Increment the `operations` by `1`.\\n- Repeat the above steps till `s > (t / 2)`.\\n- Return the number of `operations`.\\n\\n# Complexity\\n- Time complexity: **O(logn<sup>(n + operations)</sup>)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        t = s = sum(nums)\\n        \\n        for i in range(len(nums)):\\n            nums[i] = -nums[i]\\n\\n        operations = 0\\n        heapq.heapify(nums)\\n\\n        while s > (t / 2):\\n            num = -heapq.heappop(nums)\\n            s -= (num / 2)\\n            heapq.heappush(nums, -(num / 2))\\n            operations += 1\\n\\n        return operations\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        t = s = sum(nums)\\n        \\n        for i in range(len(nums)):\\n            nums[i] = -nums[i]\\n\\n        operations = 0\\n        heapq.heapify(nums)\\n\\n        while s > (t / 2):\\n            num = -heapq.heappop(nums)\\n            s -= (num / 2)\\n            heapq.heappush(nums, -(num / 2))\\n            operations += 1\\n\\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899456,
                "title": "priority-queue-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> queue = new PriorityQueue<>((a, b) -> {\\n            if (a > b) {\\n                return -1;\\n            }\\n            return 1;\\n        });\\n        double sum = 0;\\n        for (var r : nums) {\\n            queue.add((double) r);\\n            sum += r;\\n        }\\n        double current = sum;\\n        int ops = 0;\\n        while (current > sum / 2.0) {\\n         //   System.out.println(current + \" current\");\\n            var max = queue.poll();\\n            current -= max / 2.0;\\n            queue.add(max / 2.0);\\n            ops++;\\n       //     System.out.println(current + \" after \" + (max));\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> queue = new PriorityQueue<>((a, b) -> {\\n            if (a > b) {\\n                return -1;\\n            }\\n            return 1;\\n        });\\n        double sum = 0;\\n        for (var r : nums) {\\n            queue.add((double) r);\\n            sum += r;\\n        }\\n        double current = sum;\\n        int ops = 0;\\n        while (current > sum / 2.0) {\\n         //   System.out.println(current + \" current\");\\n            var max = queue.poll();\\n            current -= max / 2.0;\\n            queue.add(max / 2.0);\\n            ops++;\\n       //     System.out.println(current + \" after \" + (max));\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892684,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\nTo reach the half of the sum in minimum operation. The efficient way is to half the maximum value in the array. \\n\\n# Approach\\nMax Heap \\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> max_heap = new PriorityQueue<>(Comparator.reverseOrder());\\n       \\n             Double sum = 0d;\\n        for(int i : nums){\\n            sum+=i;\\n            max_heap.add(Double.valueOf(i));\\n\\n\\n        }\\n       double total=0;int operation=0;\\n        while((sum/2) > total ){\\n            System.out.println(sum);\\n            double max= max_heap.poll();\\n            max_heap.add(max/2);\\n            total += max/2;\\n              System.out.println(total);\\n            operation++;\\n\\n\\n\\n        }\\n        return operation;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> max_heap = new PriorityQueue<>(Comparator.reverseOrder());\\n       \\n             Double sum = 0d;\\n        for(int i : nums){\\n            sum+=i;\\n            max_heap.add(Double.valueOf(i));\\n\\n\\n        }\\n       double total=0;int operation=0;\\n        while((sum/2) > total ){\\n            System.out.println(sum);\\n            double max= max_heap.poll();\\n            max_heap.add(max/2);\\n            total += max/2;\\n              System.out.println(total);\\n            operation++;\\n\\n\\n\\n        }\\n        return operation;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885930,
                "title": "easy-using-priority-queue-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = accumulate(nums.begin(),nums.end(),0.0);\\n        int count =0;\\n        double original_sum = sum;\\n        priority_queue<double> pq(nums.begin(),nums.end());\\n\\n\\n        while(sum*2 > original_sum){\\n            double temp = pq.top();\\n            pq.pop();\\n            sum -= (temp/2);\\n            pq.push(temp/2);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = accumulate(nums.begin(),nums.end(),0.0);\\n        int count =0;\\n        double original_sum = sum;\\n        priority_queue<double> pq(nums.begin(),nums.end());\\n\\n\\n        while(sum*2 > original_sum){\\n            double temp = pq.top();\\n            pq.pop();\\n            sum -= (temp/2);\\n            pq.push(temp/2);\\n            count++;\\n        }\\n        return count;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874162,
                "title": "java-solution-using-priorityqueue-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Max Heap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPick the largest number to halve each time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double target = 0;\\n        for (int num: nums) {\\n            pq.add((double)num);\\n            target += num;\\n        }\\n\\n        target = target / 2; // half of total sum\\n        int count = 0;\\n        while (target > 0) {\\n            double n = pq.remove() / 2;\\n            target = target - n;\\n            pq.add(n);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double target = 0;\\n        for (int num: nums) {\\n            pq.add((double)num);\\n            target += num;\\n        }\\n\\n        target = target / 2; // half of total sum\\n        int count = 0;\\n        while (target > 0) {\\n            double n = pq.remove() / 2;\\n            target = target - n;\\n            pq.add(n);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863773,
                "title": "using-priority-queue-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:O(n) \\n- n=nums.size();\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        long double sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        sum+=nums[i];\\n\\n        long double a=sum/2;\\n        priority_queue<double>pq(nums.begin(),nums.end());\\n\\n        int count=0;\\n        while(!pq.empty()){\\n            double b=pq.top();\\n            pq.pop();\\n            b/=2;\\n            sum-=b;\\n            pq.push(b);\\n            count++;\\n\\n            if(sum<=a)\\n            break;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        long double sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        sum+=nums[i];\\n\\n        long double a=sum/2;\\n        priority_queue<double>pq(nums.begin(),nums.end());\\n\\n        int count=0;\\n        while(!pq.empty()){\\n            double b=pq.top();\\n            pq.pop();\\n            b/=2;\\n            sum-=b;\\n            pq.push(b);\\n            count++;\\n\\n            if(sum<=a)\\n            break;\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833461,
                "title": "c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    private PriorityQueue<double, double> _queue = new PriorityQueue<double, double>();\\n    \\n    public int HalveArray(int[] nums)\\n    {\\n        long totalSum = 0;\\n        foreach (var num in nums)\\n        {\\n            _queue.Enqueue(num, num * -1);\\n            totalSum += num;\\n        }\\n\\n        var goal = (double)totalSum / 2;\\n        double current = 0;\\n        var count = 0;\\n        while (goal > current)\\n        {\\n            var max = _queue.Dequeue() / 2;\\n            current += max;\\n            _queue.Enqueue(max, max * -1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private PriorityQueue<double, double> _queue = new PriorityQueue<double, double>();\\n    \\n    public int HalveArray(int[] nums)\\n    {\\n        long totalSum = 0;\\n        foreach (var num in nums)\\n        {\\n            _queue.Enqueue(num, num * -1);\\n            totalSum += num;\\n        }\\n\\n        var goal = (double)totalSum / 2;\\n        double current = 0;\\n        var count = 0;\\n        while (goal > current)\\n        {\\n            var max = _queue.Dequeue() / 2;\\n            current += max;\\n            _queue.Enqueue(max, max * -1);\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827977,
                "title": "c-max-heap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=accumulate(nums.begin(),nums.end(),0.0);\\n        priority_queue<double> pq;\\n        double half=sum*1.0/2;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        int ans=0;\\n        while(sum>half){\\n            double x=pq.top();\\n            pq.pop();\\n            pq.push(x/2);\\n            sum=sum-x/2;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum=accumulate(nums.begin(),nums.end(),0.0);\\n        priority_queue<double> pq;\\n        double half=sum*1.0/2;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        int ans=0;\\n        while(sum>half){\\n            double x=pq.top();\\n            pq.pop();\\n            pq.push(x/2);\\n            sum=sum-x/2;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822213,
                "title": "minimum-operations-to-halve-array-sum",
                "content": "# Code\\n```\\nclass Solution {\\n    PriorityQueue<Double> maxheap = new PriorityQueue<>(Collections.reverseOrder());\\n    public int halveArray(int[] nums) {\\n        //PriorityQueue<Integer> maxheap = new PriorityQueue<>(Collections.reverseOrder());\\n        double iSum = 0;\\n        //float iSum = heapSum();\\n        for(int a: nums)\\n        {\\n            maxheap.add((double)a);\\n            iSum+=a;\\n        }\\n        double half = 0;\\n        int count = 0;\\n        //System.out.println(iSum);\\n        //System.out.println(half);\\n        while(iSum-half>iSum/2)\\n        {\\n            count++;\\n            double n = maxheap.remove();\\n            maxheap.add(n/2);\\n            half = half + n/2;\\n            //System.out.println(iSum);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    PriorityQueue<Double> maxheap = new PriorityQueue<>(Collections.reverseOrder());\\n    public int halveArray(int[] nums) {\\n        //PriorityQueue<Integer> maxheap = new PriorityQueue<>(Collections.reverseOrder());\\n        double iSum = 0;\\n        //float iSum = heapSum();\\n        for(int a: nums)\\n        {\\n            maxheap.add((double)a);\\n            iSum+=a;\\n        }\\n        double half = 0;\\n        int count = 0;\\n        //System.out.println(iSum);\\n        //System.out.println(half);\\n        while(iSum-half>iSum/2)\\n        {\\n            count++;\\n            double n = maxheap.remove();\\n            maxheap.add(n/2);\\n            half = half + n/2;\\n            //System.out.println(iSum);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806375,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq=new PriorityQueue<Double>((a,b)->Double.compare(b,a));\\n        double sum=0;\\n        int n=nums.length;\\n        for(int x:nums){\\n            sum+=x;\\n            pq.add(Double.valueOf(x));\\n        }\\n        double total=sum;\\n        double mid=sum/2;\\n        int op=0;\\n        while(!pq.isEmpty()){\\n            double top=pq.poll();\\n            sum-=top;\\n            top/=2;\\n            pq.add(top);\\n            sum+=top;\\n            op++;\\n            if(total-sum>=mid) break;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq=new PriorityQueue<Double>((a,b)->Double.compare(b,a));\\n        double sum=0;\\n        int n=nums.length;\\n        for(int x:nums){\\n            sum+=x;\\n            pq.add(Double.valueOf(x));\\n        }\\n        double total=sum;\\n        double mid=sum/2;\\n        int op=0;\\n        while(!pq.isEmpty()){\\n            double top=pq.poll();\\n            sum-=top;\\n            top/=2;\\n            pq.add(top);\\n            sum+=top;\\n            op++;\\n            if(total-sum>=mid) break;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796392,
                "title": "cpp-simple-and-easy-to-understand-priority-queue-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double tot = accumulate(begin(nums),end(nums),0.0);\\n        double sum=0;\\n        priority_queue<double> pq(nums.begin(),nums.end());\\n        int ct=0;\\n        \\n        while((1.0*tot/2)>sum){\\n            ct++;\\n            double ele = pq.top();\\n            pq.pop();\\n            ele = 1.0*ele/2;\\n            sum+=ele;\\n            pq.push(ele);\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double tot = accumulate(begin(nums),end(nums),0.0);\\n        double sum=0;\\n        priority_queue<double> pq(nums.begin(),nums.end());\\n        int ct=0;\\n        \\n        while((1.0*tot/2)>sum){\\n            ct++;\\n            double ele = pq.top();\\n            pq.pop();\\n            ele = 1.0*ele/2;\\n            sum+=ele;\\n            pq.push(ele);\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794799,
                "title": "c-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        double sum = accumulate(nums.begin(),nums.end(),(double)0);\\n\\n        priority_queue<double>pq;\\n\\n        for(auto it : nums) pq.push((double)it);\\n\\n        double totsum = sum/2;\\n        int ct = 0;\\n\\n        while(!pq.empty()){\\n            sum-=pq.top()/2;\\n            ct++;\\n            if(sum <= totsum) return ct;\\n\\n            double top = pq.top()/2;\\n            pq.pop();\\n            pq.push(top);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        \\n        double sum = accumulate(nums.begin(),nums.end(),(double)0);\\n\\n        priority_queue<double>pq;\\n\\n        for(auto it : nums) pq.push((double)it);\\n\\n        double totsum = sum/2;\\n        int ct = 0;\\n\\n        while(!pq.empty()){\\n            sum-=pq.top()/2;\\n            ct++;\\n            if(sum <= totsum) return ct;\\n\\n            double top = pq.top()/2;\\n            pq.pop();\\n            pq.push(top);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786874,
                "title": "solved-with-maxheap-priority-queue-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n     int n = nums.size();\\n      double sum = 0;\\n     priority_queue<double>pq;\\n     for(int i=0;i<n;i++){\\n         pq.push(nums[i]);\\n         sum += nums[i];\\n     }  \\n     double s = sum;\\n     int cnt = 0;\\n     while((sum/2) > (sum-s)){\\n         cnt++;\\n         s -= pq.top();\\n         double x = pq.top()/2;\\n         s += x;\\n         pq.pop();\\n         pq.push(x);\\n     }\\n     return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n     int n = nums.size();\\n      double sum = 0;\\n     priority_queue<double>pq;\\n     for(int i=0;i<n;i++){\\n         pq.push(nums[i]);\\n         sum += nums[i];\\n     }  \\n     double s = sum;\\n     int cnt = 0;\\n     while((sum/2) > (sum-s)){\\n         cnt++;\\n         s -= pq.top();\\n         double x = pq.top()/2;\\n         s += x;\\n         pq.pop();\\n         pq.push(x);\\n     }\\n     return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776246,
                "title": "simple-priority-queue-approach-o-n-logn",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double s = 0, hs; int op = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int num: nums){\\n            s+=num;\\n            pq.add((double)num);\\n        }\\n        hs=s;\\n        while(s/2 < hs){\\n            double num = pq.remove();\\n            num /=2;\\n            hs -= num;\\n            pq.add(num);\\n            op++;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double s = 0, hs; int op = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int num: nums){\\n            s+=num;\\n            pq.add((double)num);\\n        }\\n        hs=s;\\n        while(s/2 < hs){\\n            double num = pq.remove();\\n            num /=2;\\n            hs -= num;\\n            pq.add(num);\\n            op++;\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759585,
                "title": "easy-python-3-solution-using-heaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing Heaps (Priority Queue)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n.logn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heapify,heappop,heappush\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        target = sum(nums)/2\\n        h = [-i for i in nums]\\n        heapify(h)\\n        ans = 0\\n        while target > 0:\\n            ans +=1\\n            ele = heappop(h)\\n            target += ele/2\\n            heappush(h,ele/2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify,heappop,heappush\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        target = sum(nums)/2\\n        h = [-i for i in nums]\\n        heapify(h)\\n        ans = 0\\n        while target > 0:\\n            ans +=1\\n            ele = heappop(h)\\n            target += ele/2\\n            heappush(h,ele/2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744701,
                "title": "java-pq-clean-code-and-clear-explanations",
                "content": "# Approach\\n1. In order to obtain the minimum number of steps, you need to operate over the highest numbers first\\n2. Add the numbers in a PriorityQueue<Double> in reverse order (highest numbers first) Also, compute their sum (and halfSum)\\n3. While sum > halfSum\\n    - poll from queue (highest)\\n    - half that number\\n    - deduct that half from sum and add it back in queue queue\\n    - increase the number of steps\\n4. Break when sum <= halfSum. Return the steps.\\n\\n# Complexity\\n- Time complexity:$$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        int steps = 0;\\n        double current;\\n        PriorityQueue<Double> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        double sum = 0, halfSum = 0;\\n        for (int num : nums) {\\n            queue.add(Double.valueOf(num));\\n            sum += num;\\n        }\\n        halfSum = sum / 2;\\n        while(sum > halfSum) {\\n            current = queue.poll() / 2;\\n            sum -= current;\\n            queue.add(current);\\n            steps++;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        int steps = 0;\\n        double current;\\n        PriorityQueue<Double> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        double sum = 0, halfSum = 0;\\n        for (int num : nums) {\\n            queue.add(Double.valueOf(num));\\n            sum += num;\\n        }\\n        halfSum = sum / 2;\\n        while(sum > halfSum) {\\n            current = queue.poll() / 2;\\n            sum -= current;\\n            queue.add(current);\\n            steps++;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741440,
                "title": "beautiful-solution-explained-optimal-code-neat-and-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double totalSum = 0.0, currSum = 0.0; //use double for precision\\n        priority_queue<float> pq;\\n        int steps = 0;\\n\\n        for(auto it : nums)\\n        {\\n         totalSum += it;\\n         pq.push(it);\\n        }\\n\\n        currSum = totalSum;          //as given in problem statement\\n        while(currSum > totalSum/2)  //we will iterate until currSum becomes half of the original sum\\n        {\\n            float top = pq.top(); //take out the max element\\n            pq.pop();\\n            steps++; //increment steps \\n            currSum -= top/2; //the sum of elements stored in pq gets decremented by top/2\\n            pq.push(top/2);\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double totalSum = 0.0, currSum = 0.0; //use double for precision\\n        priority_queue<float> pq;\\n        int steps = 0;\\n\\n        for(auto it : nums)\\n        {\\n         totalSum += it;\\n         pq.push(it);\\n        }\\n\\n        currSum = totalSum;          //as given in problem statement\\n        while(currSum > totalSum/2)  //we will iterate until currSum becomes half of the original sum\\n        {\\n            float top = pq.top(); //take out the max element\\n            pq.pop();\\n            steps++; //increment steps \\n            currSum -= top/2; //the sum of elements stored in pq gets decremented by top/2\\n            pq.push(top/2);\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664300,
                "title": "priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] arr) {\\n        PriorityQueue<Double> pq=new PriorityQueue<Double>(Collections.reverseOrder());\\n        double sum=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            pq.add((double)arr[i]);\\n            sum+=arr[i];\\n        }\\n        double half=sum/2;\\n        int count=0;\\n        while(sum>half){\\n            double top=pq.remove();\\n            // System.out.println(sum+\" \"+half+\" \"+top);\\n            top=top/2;\\n            sum-=top;\\n            pq.add(top);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] arr) {\\n        PriorityQueue<Double> pq=new PriorityQueue<Double>(Collections.reverseOrder());\\n        double sum=0;\\n        int n=arr.length;\\n        for(int i=0;i<n;i++){\\n            pq.add((double)arr[i]);\\n            sum+=arr[i];\\n        }\\n        double half=sum/2;\\n        int count=0;\\n        while(sum>half){\\n            double top=pq.remove();\\n            // System.out.println(sum+\" \"+half+\" \"+top);\\n            top=top/2;\\n            sum-=top;\\n            pq.add(top);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641343,
                "title": "p-q",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n    long long sum=0;\\n        priority_queue<double>q;\\n        for(auto i:nums){sum+=i;q.push((double)i);}\\n        double halfsum=sum/2.0;\\n        long long ans=0;\\n       double sum1=(double)sum;\\n        while(sum1>halfsum){\\n            \\n            double k=q.top();\\n          \\n              q.pop();\\n            sum1=sum1-(k/2.0);\\n           \\n            q.push(k/2.0);\\n          ans++;\\n        }\\n       \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n    long long sum=0;\\n        priority_queue<double>q;\\n        for(auto i:nums){sum+=i;q.push((double)i);}\\n        double halfsum=sum/2.0;\\n        long long ans=0;\\n       double sum1=(double)sum;\\n        while(sum1>halfsum){\\n            \\n            double k=q.top();\\n          \\n              q.pop();\\n            sum1=sum1-(k/2.0);\\n           \\n            q.push(k/2.0);\\n          ans++;\\n        }\\n       \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617848,
                "title": "python-priority-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlways take the largest element of nums which means we need an efficient way to get the largest number. With priority queue (heapq in Python), we can get largest element in O(1). After getting the largest element and subtract its half from the total sum, we need to push it back again to the heap so that its heap property is still maintained. We can use heapq.heapreplace for that.\\n\\n** Notice that heap in Python is min heap, so we negate all elements to have a max heap\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        nums = [-i for i in nums]\\n        s = sum(nums)\\n        half = s/2\\n        ans = 0\\n        heapq.heapify(nums)\\n  \\n        while s < half:\\n            new_number = nums[0]/2\\n            s -= new_number\\n            heapq.heapreplace(nums, new_number)\\n            ans += 1\\n        return ans\\n\\n        # for i in nums:\\n        #     s -= i/2\\n        #     ans += 1\\n        #     print(s)\\n        #     if s <= half:\\n        #         return ans\\n        # return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        nums = [-i for i in nums]\\n        s = sum(nums)\\n        half = s/2\\n        ans = 0\\n        heapq.heapify(nums)\\n  \\n        while s < half:\\n            new_number = nums[0]/2\\n            s -= new_number\\n            heapq.heapreplace(nums, new_number)\\n            ans += 1\\n        return ans\\n\\n        # for i in nums:\\n        #     s -= i/2\\n        #     ans += 1\\n        #     print(s)\\n        #     if s <= half:\\n        #         return ans\\n        # return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596743,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        int i,n,ans;\\n        n=nums.size();\\n        ans=0;\\n\\n        double sum,temp,total;\\n        sum=accumulate(nums.begin(),nums.end(),0.0);\\n        priority_queue<double> pq;\\n\\n        for(i=0;i<n;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n\\n        while(1)\\n        {\\n            temp=pq.top();\\n            pq.pop();\\n            total+=temp/2;\\n            pq.push(temp/2);\\n            ans++;\\n\\n            if(total>=sum/2)\\n            {\\n                return ans;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        int i,n,ans;\\n        n=nums.size();\\n        ans=0;\\n\\n        double sum,temp,total;\\n        sum=accumulate(nums.begin(),nums.end(),0.0);\\n        priority_queue<double> pq;\\n\\n        for(i=0;i<n;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n\\n        while(1)\\n        {\\n            temp=pq.top();\\n            pq.pop();\\n            total+=temp/2;\\n            pq.push(temp/2);\\n            ans++;\\n\\n            if(total>=sum/2)\\n            {\\n                return ans;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580059,
                "title": "c-easy-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n     //reduce the elements by half each time\\n        // reduce the maximum, it means\\n        priority_queue<double> pq;\\n        double inisum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push((double)nums[i]);\\n            inisum += nums[i];\\n        }\\n        double halfinisum = (inisum)/2.00;\\n       // int sum = inisum;\\n        long long ans = 0;\\n        while(halfinisum < inisum && !pq.empty()){\\n            double max = pq.top();\\n            pq.pop();\\n             inisum -= max;\\n            inisum += max/2.00;\\n            max = max/2.00;\\n         //  halfinisum = (inisum)/2;\\n            if(max>0)\\n            pq.push(max);\\n            ans++;\\n        }\\n        return ans;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n     //reduce the elements by half each time\\n        // reduce the maximum, it means\\n        priority_queue<double> pq;\\n        double inisum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push((double)nums[i]);\\n            inisum += nums[i];\\n        }\\n        double halfinisum = (inisum)/2.00;\\n       // int sum = inisum;\\n        long long ans = 0;\\n        while(halfinisum < inisum && !pq.empty()){\\n            double max = pq.top();\\n            pq.pop();\\n             inisum -= max;\\n            inisum += max/2.00;\\n            max = max/2.00;\\n         //  halfinisum = (inisum)/2;\\n            if(max>0)\\n            pq.push(max);\\n            ans++;\\n        }\\n        return ans;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559370,
                "title": "easy-c-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        for(int num:nums){\\n            pq.push(num);\\n        }\\n        double sum=0;\\n        for(int num:nums) sum+=(double)num;\\n        int cnt=0;\\n        double cursum = sum;\\n        while(!pq.empty()){\\n            double top = pq.top();\\n            pq.pop();\\n            cursum = cursum-top+(double)top/2;\\n            cnt++;\\n            if(cursum<=sum/2)\\n                return cnt;\\n            top/=2;\\n            if(top>0){\\n                pq.push(top);\\n            }\\n        }\\n        return cnt;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        for(int num:nums){\\n            pq.push(num);\\n        }\\n        double sum=0;\\n        for(int num:nums) sum+=(double)num;\\n        int cnt=0;\\n        double cursum = sum;\\n        while(!pq.empty()){\\n            double top = pq.top();\\n            pq.pop();\\n            cursum = cursum-top+(double)top/2;\\n            cnt++;\\n            if(cursum<=sum/2)\\n                return cnt;\\n            top/=2;\\n            if(top>0){\\n                pq.push(top);\\n            }\\n        }\\n        return cnt;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544256,
                "title": "python3-clean-max-heap-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        \\n        \\n        heap=[-val for val in nums]\\n        heapify(heap)\\n        \\n        sm=sum(nums)\\n        req=sm/2\\n        \\n        ops=0\\n        \\n        while req>0:\\n            mx=-heappop(heap)\\n            req-=(mx/2)\\n            heappush(heap,-(mx/2))\\n            ops+=1\\n        \\n        return ops\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        \\n        \\n        heap=[-val for val in nums]\\n        heapify(heap)\\n        \\n        sm=sum(nums)\\n        req=sm/2\\n        \\n        ops=0\\n        \\n        while req>0:\\n            mx=-heappop(heap)\\n            req-=(mx/2)\\n            heappush(heap,-(mx/2))\\n            ops+=1\\n        \\n        return ops\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538092,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPRIORITY QUEUE IS LIKE A SIMPLE QUEUE BUT THE DATA IN IT IS AUTOMATICALLY SORTED IN ASCENDING ORDER. I HAVE USED reverseOrder FUNCTION TO MAKE IT IN DESCENDING ORDER AS PER NEED OF THE QUESTION USE DOUBLE BECAUSE PROBLEM STATES DECIMALS WHEN SUMMING.THESE VALUES CAN BE LOST IF WE USE INT DATATYPE.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this we basically store our array in priority queue and our sum in our double variable.Then we poll the largest element from our priority queue and remove it from the sum, half it and add it back to check whether the difference bw original sum and this new sum is at least half of the initial sum.We update our result(r) variable and return it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double sum = 0.00;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0; i<nums.length; i++){\\n            sum += (double) nums[i];\\n            pq.add((double)nums[i]);\\n        }\\n\\n        Double target = sum / 2;\\n        int countOperation = 0;\\n\\n        while(sum > target){\\n            countOperation++;\\n            double temp = pq.poll();\\n            sum -= temp;\\n            temp = temp / 2;\\n            sum += temp;\\n            pq.add(temp);\\n        }\\n\\n        return countOperation;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double sum = 0.00;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n\\n        for(int i=0; i<nums.length; i++){\\n            sum += (double) nums[i];\\n            pq.add((double)nums[i]);\\n        }\\n\\n        Double target = sum / 2;\\n        int countOperation = 0;\\n\\n        while(sum > target){\\n            countOperation++;\\n            double temp = pq.poll();\\n            sum -= temp;\\n            temp = temp / 2;\\n            sum += temp;\\n            pq.add(temp);\\n        }\\n\\n        return countOperation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475959,
                "title": "easy-approach-for-beginners-using-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust first calc the sum and add all the elements in PriorityQueue.\\nNow in a while loop always take the max element, remove it from queue, half it, subtract it from real sum, and then add it back to queue. Do this until the sum2 becomes at least the value of sum/2 i.e. sum2>sum/2. Please upvote if you can understand the solution after watching the code.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> q=new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(Integer i : nums){\\n            sum+=(double)i;\\n            q.add((double)i);\\n        }\\n        int o=0;\\n        double sum2=sum;\\n        while(sum2>sum/2){\\n            double max=q.remove();\\n            \\n            max=max/2;\\n            sum2-=max;\\n            q.add(max);\\n            o++;\\n\\n        }\\n        return o;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> q=new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(Integer i : nums){\\n            sum+=(double)i;\\n            q.add((double)i);\\n        }\\n        int o=0;\\n        double sum2=sum;\\n        while(sum2>sum/2){\\n            double max=q.remove();\\n            \\n            max=max/2;\\n            sum2-=max;\\n            q.add(max);\\n            o++;\\n\\n        }\\n        return o;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473091,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        double sum = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            pq.push(nums[i]);\\n            sum += nums[i];\\n        }\\n        double target = sum / 2;\\n        while(sum > target)\\n        {\\n            sum -= pq.top() /2;\\n            double tmp =pq.top() /2;\\n            pq.pop();\\n            pq.push(tmp);\\n            ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double> pq;\\n        double sum = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            pq.push(nums[i]);\\n            sum += nums[i];\\n        }\\n        double target = sum / 2;\\n        while(sum > target)\\n        {\\n            sum -= pq.top() /2;\\n            double tmp =pq.top() /2;\\n            pq.pop();\\n            pq.push(tmp);\\n            ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465282,
                "title": "easy-simple-approach-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double>pq;\\n        for(auto x:nums) pq.push(x*1.0);\\n        double sum= accumulate(nums.begin(),nums.end(), 0.0);\\n        double hsum= sum/2.0;\\n        int count=0;\\n        while(sum>hsum) {\\n            double t= pq.top();\\n            sum-=t/2.0;\\n            count++;\\n            pq.pop();\\n            pq.push(t/2.0);\\n        }\\n       return count; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<double>pq;\\n        for(auto x:nums) pq.push(x*1.0);\\n        double sum= accumulate(nums.begin(),nums.end(), 0.0);\\n        double hsum= sum/2.0;\\n        int count=0;\\n        while(sum>hsum) {\\n            double t= pq.top();\\n            sum-=t/2.0;\\n            count++;\\n            pq.pop();\\n            pq.push(t/2.0);\\n        }\\n       return count; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462600,
                "title": "easy-priority-queue-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        int n=nums.size(); double sum=0;\\n        priority_queue<double> pq;\\n        for(int i=0;i<n;i++) sum+=nums[i];\\n        for(int i=0;i<n;i++) pq.push(nums[i]);\\n        double sum1=sum; int cnt=0;\\n        while(sum1>(double)sum/2){\\n           double temp=pq.top();\\n           pq.pop();\\n           sum1-=temp;\\n           temp=temp/2;\\n           pq.push(temp);\\n           sum1+=temp;\\n           cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        int n=nums.size(); double sum=0;\\n        priority_queue<double> pq;\\n        for(int i=0;i<n;i++) sum+=nums[i];\\n        for(int i=0;i<n;i++) pq.push(nums[i]);\\n        double sum1=sum; int cnt=0;\\n        while(sum1>(double)sum/2){\\n           double temp=pq.top();\\n           pq.pop();\\n           sum1-=temp;\\n           temp=temp/2;\\n           pq.push(temp);\\n           sum1+=temp;\\n           cnt++;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456236,
                "title": "max-heap-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        double sum=0;\\n        for(auto n: nums)\\n        {\\n            sum+=(double)n;\\n        }\\n        priority_queue<double> q;\\n        for(auto n: nums) q.push(n);\\n        int ops=0;\\n        double currsum=sum;\\n        while(!q.empty())\\n        {\\n            double t=q.top();\\n            q.pop();\\n            currsum=currsum-t+(double)t/2;\\n            ops++;\\n            if(currsum<=sum/2) return ops;\\n            t/=2;\\n            if(t) q.push(t);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int halveArray(vector<int>& nums) \\n    {\\n        double sum=0;\\n        for(auto n: nums)\\n        {\\n            sum+=(double)n;\\n        }\\n        priority_queue<double> q;\\n        for(auto n: nums) q.push(n);\\n        int ops=0;\\n        double currsum=sum;\\n        while(!q.empty())\\n        {\\n            double t=q.top();\\n            q.pop();\\n            currsum=currsum-t+(double)t/2;\\n            ops++;\\n            if(currsum<=sum/2) return ops;\\n            t/=2;\\n            if(t) q.push(t);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410255,
                "title": "well-explained-with-intuition-approach-code-heap-java-basic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic intution was to take the max number and constantly half the maximum till we get the desired sum;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the max everytime we needed a data structure which gives us the max everytime we ask to give us a variable. hence Heap was the obvious choice.\\n\\nNow to find the max. the max can be anything like in an example\\n\\nArray : [130,10,20,30] \\n\\n//first\\nmax = 130; sum = 190;\\n\\nsecond max would be 65 and not 30 because half of 130 is 65 and it is included in the sum \\n\\n//second \\nmax=65; sum=125;\\n\\nthird max is 32.5 as 65/2=32.5 and so on.....\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)+log(max(nums))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        //we will be dealing with fractions hence taking double will make the most sense\\n        double sum =0;\\n\\n        // we use a Double maxheap because we will be using the array and obviously taking out fractions and putting back fractions aswell\\n        PriorityQueue<Double> pq=new PriorityQueue<>(Collections.reverseOrder());\\n\\n        ///filling the sum and priority queue\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            pq.add((double)nums[i]);    //type casting the integer element to a double element \\n        }\\n        // we need to make a copy of the currsum to maintains and perform operations on\\n        double copySum=sum;\\n        \\n\\n        //couting the number of operations\\n        int ops=0;\\n\\n        //we will provide the base case at end while letting the loop run wild XD\\n        //hence this would run until it meets a break statement\\n\\n        while(true){\\n            //    finding the current max number\\n            double curr=pq.poll();\\n            //this was just to visualize where the code is going and if it is working in the way i desired it to work\\n            \\n            //prints the current max and the curr sum\\n            // System.out.println(curr+\" \"+copySum);\\n            \\n            //Main logic \\n            // substract the current max from the CopySum \\n            copySum-=curr;\\n            //half the current max \\n            curr=curr/2;\\n            //add the new half in the CopySum\\n            copySum=copySum+curr;\\n            //add the current number to the priority queue for rechecking that if it needs to be halved again\\n            pq.add(curr);\\n\\n            //one operations done hence add it to the counter\\n            ops+=1;\\n            \\n            //base case : if copySum<=Sum we will break and return the number of operations.\\n            if(copySum <= (sum/2))\\n            {\\n              break;    \\t\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        //we will be dealing with fractions hence taking double will make the most sense\\n        double sum =0;\\n\\n        // we use a Double maxheap because we will be using the array and obviously taking out fractions and putting back fractions aswell\\n        PriorityQueue<Double> pq=new PriorityQueue<>(Collections.reverseOrder());\\n\\n        ///filling the sum and priority queue\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            pq.add((double)nums[i]);    //type casting the integer element to a double element \\n        }\\n        // we need to make a copy of the currsum to maintains and perform operations on\\n        double copySum=sum;\\n        \\n\\n        //couting the number of operations\\n        int ops=0;\\n\\n        //we will provide the base case at end while letting the loop run wild XD\\n        //hence this would run until it meets a break statement\\n\\n        while(true){\\n            //    finding the current max number\\n            double curr=pq.poll();\\n            //this was just to visualize where the code is going and if it is working in the way i desired it to work\\n            \\n            //prints the current max and the curr sum\\n            // System.out.println(curr+\" \"+copySum);\\n            \\n            //Main logic \\n            // substract the current max from the CopySum \\n            copySum-=curr;\\n            //half the current max \\n            curr=curr/2;\\n            //add the new half in the CopySum\\n            copySum=copySum+curr;\\n            //add the current number to the priority queue for rechecking that if it needs to be halved again\\n            pq.add(curr);\\n\\n            //one operations done hence add it to the counter\\n            ops+=1;\\n            \\n            //base case : if copySum<=Sum we will break and return the number of operations.\\n            if(copySum <= (sum/2))\\n            {\\n              break;    \\t\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3387592,
                "title": "beginner-friendly-java-code",
                "content": "\\n# Approach\\n- Just Delete the maximum item until your sum of the array become less then the half of the total sum of the origional array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        \\n    PriorityQueue<Double>pq=new PriorityQueue<>(Collections.reverseOrder());\\n    double total=0;\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n        pq.add((double)nums[i]);\\n        total+=nums[i];\\n    }\\n\\n    double sum=total;\\n    total/=2;\\n\\n    while(!pq.isEmpty()&&sum>total){\\n\\n    double peekitem=pq.poll()/2;\\n\\n    sum-=peekitem;\\n\\n    pq.add(peekitem);\\n\\n    count++;\\n\\n    }\\n\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        \\n    PriorityQueue<Double>pq=new PriorityQueue<>(Collections.reverseOrder());\\n    double total=0;\\n    int count=0;\\n\\n    for(int i=0;i<nums.length;i++){\\n        pq.add((double)nums[i]);\\n        total+=nums[i];\\n    }\\n\\n    double sum=total;\\n    total/=2;\\n\\n    while(!pq.isEmpty()&&sum>total){\\n\\n    double peekitem=pq.poll()/2;\\n\\n    sum-=peekitem;\\n\\n    pq.add(peekitem);\\n\\n    count++;\\n\\n    }\\n\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374244,
                "title": "java-solution-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        double s=0;\\n        for(int i:nums){\\n            pq.add((double)i);\\n            s+=(double)i;\\n        }\\n        double sum=s;\\n        int ct=0;\\n        while(!pq.isEmpty()){\\n            double a=pq.poll();\\n            sum-=a;\\n            pq.add(a/2);\\n            sum+=a/2;\\n            ct++;\\n            if(sum<=s/2)\\n                return ct;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        double s=0;\\n        for(int i:nums){\\n            pq.add((double)i);\\n            s+=(double)i;\\n        }\\n        double sum=s;\\n        int ct=0;\\n        while(!pq.isEmpty()){\\n            double a=pq.poll();\\n            sum-=a;\\n            pq.add(a/2);\\n            sum+=a/2;\\n            ct++;\\n            if(sum<=s/2)\\n                return ct;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362990,
                "title": "java-easy-solution-priority-queue-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int operations = 0;\\n        double real_sum = 0;\\n       \\n        for (int value : nums) {\\n            real_sum += value;\\n            pq.add((double) value);\\n        }\\n\\n        double sum = real_sum;\\n        while (sum > real_sum / 2) {\\n            double get_Element = pq.remove();\\n            get_Element /= 2;\\n            sum -= get_Element;\\n            pq.add(get_Element);\\n            operations++;\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int operations = 0;\\n        double real_sum = 0;\\n       \\n        for (int value : nums) {\\n            real_sum += value;\\n            pq.add((double) value);\\n        }\\n\\n        double sum = real_sum;\\n        while (sum > real_sum / 2) {\\n            double get_Element = pq.remove();\\n            get_Element /= 2;\\n            sum -= get_Element;\\n            pq.add(get_Element);\\n            operations++;\\n        }\\n\\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361011,
                "title": "easy-python-heap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nheap\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmax heap\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n)). Because we need to do the operations at most n times.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        import heapq\\n        target = sum(nums)/2.0\\n        nums = [-num for num in nums]\\n        heapq.heapify(nums)\\n        count = 0\\n        reduced = 0\\n        while reduced < target:\\n            pick = heapq.heappop(nums)\\n            heapq.heappush(nums, pick/2.0)\\n            count += 1\\n            reduced += -pick/2.0\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        import heapq\\n        target = sum(nums)/2.0\\n        nums = [-num for num in nums]\\n        heapq.heapify(nums)\\n        count = 0\\n        reduced = 0\\n        while reduced < target:\\n            pick = heapq.heappop(nums)\\n            heapq.heappush(nums, pick/2.0)\\n            count += 1\\n            reduced += -pick/2.0\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359403,
                "title": "easy-java-solution-using-priorityqueue",
                "content": "![upvote.jpeg](https://assets.leetcode.com/users/images/76a52670-bab1-4594-b344-b28c9cfb409b_1680185905.0064735.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n         PriorityQueue<Double>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int count=0;\\n        double sum=0.0;\\n        for(int ele:nums){\\n            sum+=(double)ele;\\n            pq.add((double)ele);\\n        }\\n        double ans=sum/2;\\n        while(pq.size()>0&&sum>ans){\\n            double val=pq.remove();\\n            sum-=val;\\n            val=val/2;\\n            pq.add((double)val);\\n            sum+=(double)val;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n         PriorityQueue<Double>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        int count=0;\\n        double sum=0.0;\\n        for(int ele:nums){\\n            sum+=(double)ele;\\n            pq.add((double)ele);\\n        }\\n        double ans=sum/2;\\n        while(pq.size()>0&&sum>ans){\\n            double val=pq.remove();\\n            sum-=val;\\n            val=val/2;\\n            pq.add((double)val);\\n            sum+=(double)val;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355438,
                "title": "javascript-heap-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar halveArray = function(nums) {\\n    let sum = 0;\\n    const maxHeap = new Heap();\\n    \\n    for(const n of nums){ \\n        maxHeap.insert(n);\\n        sum += n;\\n    }\\n    console.log(maxHeap)\\n    let currentSum = sum;\\n    let numberOfOperations = 0;\\n    while(currentSum > sum / 2) {\\n        const val = maxHeap.extract();\\n        const newVal = val / 2;\\n        maxHeap.insert(newVal);\\n        currentSum -= newVal;\\n        numberOfOperations += 1;\\n    }\\n    return numberOfOperations;\\n};\\n\\n\\nvar Heap = function() {\\n    this.heap = [];\\n}\\n\\nHeap.prototype.insert = function(num) {\\n    this.heap.push(num)\\n    this.bubbleUp();\\n    return this;\\n}\\n\\nHeap.prototype.bubbleUp = function() {\\n    let pos = this.heap.length - 1;\\n\\n    while(pos > 0) {\\n        let parentIndex = Math.floor((pos - 1) / 2);\\n        let current = this.heap[pos];\\n        let parent = this.heap[parentIndex];\\n\\n        if(current < parent) break;\\n\\n        let temp = this.heap[pos];\\n        this.heap[pos] = this.heap[parentIndex];\\n        this.heap[parentIndex] = temp;\\n\\n        pos = parentIndex;\\n    }\\n}\\n\\nHeap.prototype.extract = function() {\\n    let max = this.heap[0];\\n\\n    if(this.heap.length == 0) return null;\\n\\n    let last = this.heap.pop();\\n\\n    if(this.heap.length == 0) return last;\\n\\n    this.heap[0] = last;\\n\\n    this.sinkDown();\\n\\n    return max;\\n}\\n\\nHeap.prototype.peek = function() {\\n    return this.heap[0];\\n}\\n\\nHeap.prototype.sinkDown = function() {\\n    let pos = 0, n = this.heap.length;\\n\\n    while(pos < n) {\\n        let largest = null;\\n        let l = 2 * pos + 1;\\n        let r = 2 * pos + 2;\\n\\n        if(l < n && this.heap[l] > this.heap[pos]) {\\n            largest = l;\\n        }\\n\\n        if( (r < n) && ((largest === null && this.heap[r] > this.heap[pos]) ||\\n        (largest != null && this.heap[r] > this.heap[l]))) {\\n            largest = r;\\n        }\\n        if(largest == null) break;\\n        \\n        let temp = this.heap[pos];\\n        this.heap[pos] = this.heap[largest];\\n        this.heap[largest] = temp;\\n\\n        pos = largest;\\n    }\\n}\\n\\n\\nHeap.prototype.size = function() {\\n    return this.heap.length;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar halveArray = function(nums) {\\n    let sum = 0;\\n    const maxHeap = new Heap();\\n    \\n    for(const n of nums){ \\n        maxHeap.insert(n);\\n        sum += n;\\n    }\\n    console.log(maxHeap)\\n    let currentSum = sum;\\n    let numberOfOperations = 0;\\n    while(currentSum > sum / 2) {\\n        const val = maxHeap.extract();\\n        const newVal = val / 2;\\n        maxHeap.insert(newVal);\\n        currentSum -= newVal;\\n        numberOfOperations += 1;\\n    }\\n    return numberOfOperations;\\n};\\n\\n\\nvar Heap = function() {\\n    this.heap = [];\\n}\\n\\nHeap.prototype.insert = function(num) {\\n    this.heap.push(num)\\n    this.bubbleUp();\\n    return this;\\n}\\n\\nHeap.prototype.bubbleUp = function() {\\n    let pos = this.heap.length - 1;\\n\\n    while(pos > 0) {\\n        let parentIndex = Math.floor((pos - 1) / 2);\\n        let current = this.heap[pos];\\n        let parent = this.heap[parentIndex];\\n\\n        if(current < parent) break;\\n\\n        let temp = this.heap[pos];\\n        this.heap[pos] = this.heap[parentIndex];\\n        this.heap[parentIndex] = temp;\\n\\n        pos = parentIndex;\\n    }\\n}\\n\\nHeap.prototype.extract = function() {\\n    let max = this.heap[0];\\n\\n    if(this.heap.length == 0) return null;\\n\\n    let last = this.heap.pop();\\n\\n    if(this.heap.length == 0) return last;\\n\\n    this.heap[0] = last;\\n\\n    this.sinkDown();\\n\\n    return max;\\n}\\n\\nHeap.prototype.peek = function() {\\n    return this.heap[0];\\n}\\n\\nHeap.prototype.sinkDown = function() {\\n    let pos = 0, n = this.heap.length;\\n\\n    while(pos < n) {\\n        let largest = null;\\n        let l = 2 * pos + 1;\\n        let r = 2 * pos + 2;\\n\\n        if(l < n && this.heap[l] > this.heap[pos]) {\\n            largest = l;\\n        }\\n\\n        if( (r < n) && ((largest === null && this.heap[r] > this.heap[pos]) ||\\n        (largest != null && this.heap[r] > this.heap[l]))) {\\n            largest = r;\\n        }\\n        if(largest == null) break;\\n        \\n        let temp = this.heap[pos];\\n        this.heap[pos] = this.heap[largest];\\n        this.heap[largest] = temp;\\n\\n        pos = largest;\\n    }\\n}\\n\\n\\nHeap.prototype.size = function() {\\n    return this.heap.length;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328633,
                "title": "java-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int halveArray(int[] nums)\\n    {\\n        double sum=0.00;\\n        PriorityQueue<Double>pq= new PriorityQueue<Double>(Collections.reverseOrder());\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pq.add((double)nums[i]);\\n            sum=sum+(double)nums[i];\\n        }\\n        double total=sum;\\n        int count=0;\\n        while(sum>total/2)\\n        {\\n            double max=pq.poll();\\n            max=max/2;\\n            sum=sum-max;\\n            pq.add(max);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int halveArray(int[] nums)\\n    {\\n        double sum=0.00;\\n        PriorityQueue<Double>pq= new PriorityQueue<Double>(Collections.reverseOrder());\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            pq.add((double)nums[i]);\\n            sum=sum+(double)nums[i];\\n        }\\n        double total=sum;\\n        int count=0;\\n        while(sum>total/2)\\n        {\\n            double max=pq.poll();\\n            max=max/2;\\n            sum=sum-max;\\n            pq.add(max);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313265,
                "title": "worst-approach-ever-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] a) {\\n        PriorityQueue<Double> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int i : a){\\n            queue.offer(i*1.0);\\n            sum+=(i)*(1.0);\\n        }\\n        int ans=0;\\n        double check=sum/2;\\n        while(sum>check){\\n            double b=queue.poll();\\n            sum-=(b/2);\\n            queue.offer(b/2);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] a) {\\n        PriorityQueue<Double> queue = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int i : a){\\n            queue.offer(i*1.0);\\n            sum+=(i)*(1.0);\\n        }\\n        int ans=0;\\n        double check=sum/2;\\n        while(sum>check){\\n            double b=queue.poll();\\n            sum-=(b/2);\\n            queue.offer(b/2);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311794,
                "title": "c-greedy-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0.0;\\n        priority_queue<double> PQ;\\n        for(int num: nums) {\\n            PQ.push(num);\\n            sum += num;\\n        }\\n        int ans = 0;\\n        sum /= 2;\\n        double reduced = 0.0;\\n        while(reduced < sum) {\\n            ans++;\\n            reduced += PQ.top() / 2;\\n            PQ.push(PQ.top() / 2);\\n            PQ.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        double sum = 0.0;\\n        priority_queue<double> PQ;\\n        for(int num: nums) {\\n            PQ.push(num);\\n            sum += num;\\n        }\\n        int ans = 0;\\n        sum /= 2;\\n        double reduced = 0.0;\\n        while(reduced < sum) {\\n            ans++;\\n            reduced += PQ.top() / 2;\\n            PQ.push(PQ.top() / 2);\\n            PQ.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308903,
                "title": "java-priorityqueue-beats-87",
                "content": "# Intuition\\nTo achieve the minimum number of halves, we want to always halve the currently biggest number in the array. Therefore, we use a reversed PriorityQueue to constantly poll the first number, halve it, then re-add it back into the queue.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(\\n            (a, b) -> Double.compare(b, a)\\n        );\\n        \\n        double sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            pq.add((double)num);\\n        }\\n\\n        double x = 0;\\n        int c = 0;\\n        while (x < (sum / 2)) {\\n            double val = pq.poll();\\n            val /= 2;\\n            x += val;\\n            pq.add(val);\\n            ++c;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(\\n            (a, b) -> Double.compare(b, a)\\n        );\\n        \\n        double sum = 0;\\n        for (int num : nums) {\\n            sum += num;\\n            pq.add((double)num);\\n        }\\n\\n        double x = 0;\\n        int c = 0;\\n        while (x < (sum / 2)) {\\n            double val = pq.poll();\\n            val /= 2;\\n            x += val;\\n            pq.add(val);\\n            ++c;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308777,
                "title": "veryy-simple-priority-queue-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<float>pq;\\n        double sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n        }\\n        double t=sum;\\n        int cnt=0;\\n        while(t>(sum/2) && !pq.empty()){\\n            double q=pq.top();\\n            pq.pop();\\n            double d=q/2;\\n\\n            pq.push(d);\\n            t-=(q-d);\\n            cnt++;\\n        }\\n        return cnt;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue<float>pq;\\n        double sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n        }\\n        double t=sum;\\n        int cnt=0;\\n        while(t>(sum/2) && !pq.empty()){\\n            double q=pq.top();\\n            pq.pop();\\n            double d=q/2;\\n\\n            pq.push(d);\\n            t-=(q-d);\\n            cnt++;\\n        }\\n        return cnt;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307388,
                "title": "js-min-heap-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nclass MinHeap {\\n  constructor() {\\n    this.items = [];\\n  }\\n\\n  getLeftChildIndex(parentIndex) {\\n    return 2 * parentIndex + 1;\\n  }\\n\\n  getRightChildIndex(parentIndex) {\\n    return 2 * parentIndex + 2;\\n  }\\n\\n  getParentIndex(childIndex) {\\n    return childIndex % 2 === 0 ? (childIndex - 2) / 2 : (childIndex - 1) / 2;\\n  }\\n\\n  hasParent(childIndex) {\\n    return this.getParentIndex(childIndex) >= 0;\\n  }\\n\\n  hasLeftChild(parentIndex) {\\n    return this.getLeftChildIndex(parentIndex) < this.items.length;\\n  }\\n\\n  hasRightChild(parentIndex) {\\n    return this.getRightChildIndex(parentIndex) < this.items.length;\\n  }\\n\\n  swap(leftIndex, rightIndex) {\\n    const temp = this.items[rightIndex];\\n    this.items[rightIndex] = this.items[leftIndex];\\n    this.items[leftIndex] = temp;\\n  }\\n\\n  add(value) {\\n    // Push to the end\\n    this.items.push(value);\\n    // Restore heap property\\n    this.heapifyUp();\\n    return this.items;\\n  }\\n\\n  poll() {\\n    if (this.items.length === 0) {\\n      return null;\\n    }\\n\\n    if (this.items.length === 1) {\\n      return this.items.pop();\\n    }\\n\\n    // Get the min\\n    const min = this.items[0];\\n\\n    // Put last to first\\n    this.items[0] = this.items.pop();\\n\\n    // Restore heap property\\n    this.heapifyDown();\\n\\n    return min;\\n  }\\n\\n  heapifyUp() {\\n    // Start with the last element\\n    let currIndex = this.items.length - 1;\\n    while (\\n      currIndex > 0 &&\\n      this.items[currIndex] < this.items[this.getParentIndex(currIndex)]\\n    ) {\\n      // Swap with parent until heap property met\\n      const parentIndex = this.getParentIndex(currIndex);\\n      this.swap(currIndex, parentIndex);\\n      currIndex = parentIndex;\\n    }\\n  }\\n\\n  heapifyDown() {\\n    // Start with the root element\\n    let currIndex = 0;\\n\\n    // Keep going down until we still have a child (if there\\'s only child, it must be left)\\n    while (this.hasLeftChild(currIndex)) {\\n      // Get the smaller child\\n      const leftChildIndex = this.getLeftChildIndex(currIndex);\\n      const rightChildIndex = this.getRightChildIndex(currIndex);\\n\\n      let smallerChildIdx = this.getLeftChildIndex(currIndex);\\n      if (\\n        this.hasRightChild(currIndex) &&\\n        this.items[rightChildIndex] < this.items[leftChildIndex]\\n      ) {\\n        // Swap current element with the smaller child\\n        smallerChildIdx = this.getRightChildIndex(currIndex);\\n      }\\n\\n      if (this.items[currIndex] <= this.items[smallerChildIdx]) {\\n        break;\\n      }\\n\\n      this.swap(currIndex, smallerChildIdx);\\n      currIndex = smallerChildIdx;\\n    }\\n  }\\n}\\n\\nvar halveArray = function(nums) {\\n    const heap = new MinHeap();\\n    let sum = 0;\\n    for (const num of nums) {\\n        sum += num;\\n        heap.add(-(num));\\n    }\\n\\n    let newSum = sum;\\n    let count = 0;\\n    while (newSum > sum / 2) {\\n        const curr = Math.abs(heap.poll()) / 2;\\n        newSum -= curr;\\n        heap.add(-(curr));\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nclass MinHeap {\\n  constructor() {\\n    this.items = [];\\n  }\\n\\n  getLeftChildIndex(parentIndex) {\\n    return 2 * parentIndex + 1;\\n  }\\n\\n  getRightChildIndex(parentIndex) {\\n    return 2 * parentIndex + 2;\\n  }\\n\\n  getParentIndex(childIndex) {\\n    return childIndex % 2 === 0 ? (childIndex - 2) / 2 : (childIndex - 1) / 2;\\n  }\\n\\n  hasParent(childIndex) {\\n    return this.getParentIndex(childIndex) >= 0;\\n  }\\n\\n  hasLeftChild(parentIndex) {\\n    return this.getLeftChildIndex(parentIndex) < this.items.length;\\n  }\\n\\n  hasRightChild(parentIndex) {\\n    return this.getRightChildIndex(parentIndex) < this.items.length;\\n  }\\n\\n  swap(leftIndex, rightIndex) {\\n    const temp = this.items[rightIndex];\\n    this.items[rightIndex] = this.items[leftIndex];\\n    this.items[leftIndex] = temp;\\n  }\\n\\n  add(value) {\\n    // Push to the end\\n    this.items.push(value);\\n    // Restore heap property\\n    this.heapifyUp();\\n    return this.items;\\n  }\\n\\n  poll() {\\n    if (this.items.length === 0) {\\n      return null;\\n    }\\n\\n    if (this.items.length === 1) {\\n      return this.items.pop();\\n    }\\n\\n    // Get the min\\n    const min = this.items[0];\\n\\n    // Put last to first\\n    this.items[0] = this.items.pop();\\n\\n    // Restore heap property\\n    this.heapifyDown();\\n\\n    return min;\\n  }\\n\\n  heapifyUp() {\\n    // Start with the last element\\n    let currIndex = this.items.length - 1;\\n    while (\\n      currIndex > 0 &&\\n      this.items[currIndex] < this.items[this.getParentIndex(currIndex)]\\n    ) {\\n      // Swap with parent until heap property met\\n      const parentIndex = this.getParentIndex(currIndex);\\n      this.swap(currIndex, parentIndex);\\n      currIndex = parentIndex;\\n    }\\n  }\\n\\n  heapifyDown() {\\n    // Start with the root element\\n    let currIndex = 0;\\n\\n    // Keep going down until we still have a child (if there\\'s only child, it must be left)\\n    while (this.hasLeftChild(currIndex)) {\\n      // Get the smaller child\\n      const leftChildIndex = this.getLeftChildIndex(currIndex);\\n      const rightChildIndex = this.getRightChildIndex(currIndex);\\n\\n      let smallerChildIdx = this.getLeftChildIndex(currIndex);\\n      if (\\n        this.hasRightChild(currIndex) &&\\n        this.items[rightChildIndex] < this.items[leftChildIndex]\\n      ) {\\n        // Swap current element with the smaller child\\n        smallerChildIdx = this.getRightChildIndex(currIndex);\\n      }\\n\\n      if (this.items[currIndex] <= this.items[smallerChildIdx]) {\\n        break;\\n      }\\n\\n      this.swap(currIndex, smallerChildIdx);\\n      currIndex = smallerChildIdx;\\n    }\\n  }\\n}\\n\\nvar halveArray = function(nums) {\\n    const heap = new MinHeap();\\n    let sum = 0;\\n    for (const num of nums) {\\n        sum += num;\\n        heap.add(-(num));\\n    }\\n\\n    let newSum = sum;\\n    let count = 0;\\n    while (newSum > sum / 2) {\\n        const curr = Math.abs(heap.poll()) / 2;\\n        newSum -= curr;\\n        heap.add(-(curr));\\n        count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298153,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum = 0;\\n        for(int val : nums){\\n            sum += val;\\n            pq.add((double)val);\\n        }\\n        int count = 0;\\n        double half = (sum * 1.0) / 2;\\n        \\n        while(sum > half){\\n            double val = pq.remove();\\n            double newVal = (double)val / 2; \\n            sum -= newVal;\\n            count++;\\n            pq.add(newVal);\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        double sum = 0;\\n        for(int val : nums){\\n            sum += val;\\n            pq.add((double)val);\\n        }\\n        int count = 0;\\n        double half = (sum * 1.0) / 2;\\n        \\n        while(sum > half){\\n            double val = pq.remove();\\n            double newVal = (double)val / 2; \\n            sum -= newVal;\\n            count++;\\n            pq.add(newVal);\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286745,
                "title": "always-halve-the-maximum-number-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue <double> pq;\\n        double s = 0.0, x, p = 0.0;\\n        int ans = 0;\\n        for (int c : nums) {\\n            x = (double)c;\\n            s += x;\\n            pq.push(x);\\n        }\\n        while (p < s/2.0) {\\n            ans++;\\n            x = pq.top();\\n            pq.pop();\\n            pq.push(x/2.0);\\n            p += x/2.0;\\n            cout << x/2.0 << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        priority_queue <double> pq;\\n        double s = 0.0, x, p = 0.0;\\n        int ans = 0;\\n        for (int c : nums) {\\n            x = (double)c;\\n            s += x;\\n            pq.push(x);\\n        }\\n        while (p < s/2.0) {\\n            ans++;\\n            x = pq.top();\\n            pq.pop();\\n            pq.push(x/2.0);\\n            p += x/2.0;\\n            cout << x/2.0 << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3284113,
                "title": "python-3-simple-and-fast-solution-using-heap-beats-99-38-of-solutions",
                "content": "# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n\\n        from heapq import heapify, heappop, heappush\\n\\n        original_sum = sum(nums)\\n        target_sum = original_sum / 2\\n\\n        nums = [-1 * num for num in nums]\\n        heapify(nums)\\n\\n        count = 0\\n        while original_sum > target_sum:\\n            x = heappop(nums)\\n            heappush(nums, x / 2)\\n            original_sum -= (-1 * x/2)\\n            count += 1\\n\\n        return count  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n\\n        from heapq import heapify, heappop, heappush\\n\\n        original_sum = sum(nums)\\n        target_sum = original_sum / 2\\n\\n        nums = [-1 * num for num in nums]\\n        heapify(nums)\\n\\n        count = 0\\n        while original_sum > target_sum:\\n            x = heappop(nums)\\n            heappush(nums, x / 2)\\n            original_sum -= (-1 * x/2)\\n            count += 1\\n\\n        return count  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262466,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn halve_array(nums: Vec<i32>) -> i32 {\\n        let mut heap = std::collections::BinaryHeap::<OrderedF64>::new();\\n        let mut sum = 0.0;\\n        for &x in nums.iter() {\\n            let x = x as f64;\\n            sum += x;\\n            heap.push(OrderedF64(x));\\n        }\\n        let half = sum / 2.0;\\n        let mut count = 0;\\n        while sum > half {\\n            let max = heap.pop().unwrap().0;\\n            heap.push(OrderedF64(max / 2.0));\\n            count += 1;\\n            sum -= max / 2.0;\\n        }\\n        count\\n    }\\n}\\n\\n#[derive(Debug, Clone, Copy)]\\nstruct OrderedF64(f64);\\n\\nimpl PartialEq for OrderedF64 {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.0 == other.0\\n    }\\n}\\n\\nimpl PartialOrd for OrderedF64 {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.0.partial_cmp(&other.0)\\n    }\\n}\\n\\nimpl Eq for OrderedF64 {}\\n\\nimpl Ord for OrderedF64 {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.partial_cmp(other).unwrap_or(std::cmp::Ordering::Equal)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn halve_array(nums: Vec<i32>) -> i32 {\\n        let mut heap = std::collections::BinaryHeap::<OrderedF64>::new();\\n        let mut sum = 0.0;\\n        for &x in nums.iter() {\\n            let x = x as f64;\\n            sum += x;\\n            heap.push(OrderedF64(x));\\n        }\\n        let half = sum / 2.0;\\n        let mut count = 0;\\n        while sum > half {\\n            let max = heap.pop().unwrap().0;\\n            heap.push(OrderedF64(max / 2.0));\\n            count += 1;\\n            sum -= max / 2.0;\\n        }\\n        count\\n    }\\n}\\n\\n#[derive(Debug, Clone, Copy)]\\nstruct OrderedF64(f64);\\n\\nimpl PartialEq for OrderedF64 {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.0 == other.0\\n    }\\n}\\n\\nimpl PartialOrd for OrderedF64 {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.0.partial_cmp(&other.0)\\n    }\\n}\\n\\nimpl Eq for OrderedF64 {}\\n\\nimpl Ord for OrderedF64 {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.partial_cmp(other).unwrap_or(std::cmp::Ordering::Equal)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3235353,
                "title": "c-heap-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        //greedy, always choose the largest num\\n        //using a maxheap to keep track of the current max elem\\n        double sum = 0;\\n        for(auto&i: nums) sum+=i; \\n        priority_queue<double> hp; \\n        for(auto i: nums) hp.push((double)i);\\n        double target = sum/(double)2; \\n        int cnt = 0; \\n        while(sum>target){\\n            sum -= (double)hp.top()/(double)2; \\n            double t = hp.top()/(double)2; \\n            hp.pop();\\n            hp.push(t); \\n            cnt++; \\n        }\\n        return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        //greedy, always choose the largest num\\n        //using a maxheap to keep track of the current max elem\\n        double sum = 0;\\n        for(auto&i: nums) sum+=i; \\n        priority_queue<double> hp; \\n        for(auto i: nums) hp.push((double)i);\\n        double target = sum/(double)2; \\n        int cnt = 0; \\n        while(sum>target){\\n            sum -= (double)hp.top()/(double)2; \\n            double t = hp.top()/(double)2; \\n            hp.pop();\\n            hp.push(t); \\n            cnt++; \\n        }\\n        return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230354,
                "title": "go-golang-solution-using-max-heap",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(Log N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\ntype maxHeap []float64\\n\\nfunc (m maxHeap) Len() int {\\n\\treturn len(m)\\n}\\nfunc (m maxHeap) Less(i, j int) bool {\\n\\treturn m[i] > m[j]\\n}\\n\\nfunc (m maxHeap) Swap(i, j int) {\\n\\tm[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *maxHeap) Push(x interface{}) {\\n\\t*m = append(*m, x.(float64))\\n}\\n\\nfunc (m *maxHeap) Pop() interface{} {\\n\\told := *m\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*m = old[:n-1]\\n\\treturn x\\n}\\n\\nfunc halveArray(nums []int) int {\\n\\tpq := maxHeap{}\\n\\theap.Init(&pq)\\n\\tsum := 0.0\\n\\tfor _, v := range nums {\\n\\t\\theap.Push(&pq, float64(v))\\n\\t\\tsum += float64(v)\\n\\t}\\n\\ttargetSum := float64(sum / 2)\\n\\n\\tnoOfOperations := 0\\n\\tfor targetSum > 0 {\\n\\t\\tv := heap.Pop(&pq).(float64)\\n\\t\\ttargetSum -= v / 2\\n\\t\\theap.Push(&pq, v/2)\\n\\t\\tnoOfOperations++\\n\\t}\\n\\n\\treturn noOfOperations\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\ntype maxHeap []float64\\n\\nfunc (m maxHeap) Len() int {\\n\\treturn len(m)\\n}\\nfunc (m maxHeap) Less(i, j int) bool {\\n\\treturn m[i] > m[j]\\n}\\n\\nfunc (m maxHeap) Swap(i, j int) {\\n\\tm[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *maxHeap) Push(x interface{}) {\\n\\t*m = append(*m, x.(float64))\\n}\\n\\nfunc (m *maxHeap) Pop() interface{} {\\n\\told := *m\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*m = old[:n-1]\\n\\treturn x\\n}\\n\\nfunc halveArray(nums []int) int {\\n\\tpq := maxHeap{}\\n\\theap.Init(&pq)\\n\\tsum := 0.0\\n\\tfor _, v := range nums {\\n\\t\\theap.Push(&pq, float64(v))\\n\\t\\tsum += float64(v)\\n\\t}\\n\\ttargetSum := float64(sum / 2)\\n\\n\\tnoOfOperations := 0\\n\\tfor targetSum > 0 {\\n\\t\\tv := heap.Pop(&pq).(float64)\\n\\t\\ttargetSum -= v / 2\\n\\t\\theap.Push(&pq, v/2)\\n\\t\\tnoOfOperations++\\n\\t}\\n\\n\\treturn noOfOperations\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189469,
                "title": "272-ms",
                "content": "```ruby\\ndef halve_array a\\n    r = (s = a.sort!.sum.to_f) / 2.0\\n    d, c = [], 0\\n    while s > r\\n        s -= k = (d.first&.>(a.last) ?\\n                  d.shift : a.pop) / 2.0\\n        d << k\\n        c += 1\\n    end\\n    c\\nend\\n```\\n2399 ms\\n```ruby\\ndef halve_array a\\n    r = (s = a.sum.to_f) / 2.0\\n    t, c = CRBTreeMap.new, 0\\n    a.each { t[k = _1.to_f] ||= 0; t[k] += 1 }\\n    loop do\\n        k = t.max_key / 2.0\\n        v = t.delete_max\\n        if (s -= k * v) <= r\\n            s += k * v\\n            v.times do\\n                c += 1\\n                return c if (s -= k) <= r\\n            end\\n        end\\n        c += v\\n        t[k] ||= 0\\n        t[k] += v\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef halve_array a\\n    r = (s = a.sort!.sum.to_f) / 2.0\\n    d, c = [], 0\\n    while s > r\\n        s -= k = (d.first&.>(a.last) ?\\n                  d.shift : a.pop) / 2.0\\n        d << k\\n        c += 1\\n    end\\n    c\\nend\\n```\n```ruby\\ndef halve_array a\\n    r = (s = a.sum.to_f) / 2.0\\n    t, c = CRBTreeMap.new, 0\\n    a.each { t[k = _1.to_f] ||= 0; t[k] += 1 }\\n    loop do\\n        k = t.max_key / 2.0\\n        v = t.delete_max\\n        if (s -= k * v) <= r\\n            s += k * v\\n            v.times do\\n                c += 1\\n                return c if (s -= k) <= r\\n            end\\n        end\\n        c += v\\n        t[k] ||= 0\\n        t[k] += v\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3183892,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\nPriorityQueue<Double> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            pq.add((double)nums[i]);\\n            sum+=nums[i];\\n        }\\n        double target=sum/2;\\n         int count=0;\\n        while(sum>target){\\n           double high=pq.remove();\\n           sum-=high;\\n           high=high/2;\\n           sum+=high;\\n            pq.add(high);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\nPriorityQueue<Double> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            pq.add((double)nums[i]);\\n            sum+=nums[i];\\n        }\\n        double target=sum/2;\\n         int count=0;\\n        while(sum>target){\\n           double high=pq.remove();\\n           sum-=high;\\n           high=high/2;\\n           sum+=high;\\n            pq.add(high);\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163790,
                "title": "python-easy-to-read-and-understand-heap",
                "content": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        pq = []\\n        for num in nums:\\n            heapq.heappush(pq, -1*num)\\n        \\n        sums, cnt = sum(nums), 0\\n        target = sums/2\\n        while sums > target:\\n            #print(sums)\\n            val = heapq.heappop(pq)\\n            new_val = val/2\\n            heapq.heappush(pq, new_val)\\n            sums = sums - (-1*val) + (-1*new_val)\\n            cnt += 1\\n        \\n        return cnt",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        pq = []\\n        for num in nums:\\n            heapq.heappush(pq, -1*num)\\n        \\n        sums, cnt = sum(nums), 0\\n        target = sums/2\\n        while sums > target:\\n            #print(sums)\\n            val = heapq.heappop(pq)\\n            new_val = val/2\\n            heapq.heappush(pq, new_val)\\n            sums = sums - (-1*val) + (-1*new_val)\\n            cnt += 1\\n        \\n        return cnt",
                "codeTag": "Java"
            },
            {
                "id": 3155113,
                "title": "python3-max-heap-solution",
                "content": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        heap = []\\n        for num in nums:\\n            heappush(heap,-num)\\n\\n        initalSum = sum(nums)\\n        targetSum = initalSum / 2\\n        res = 0\\n\\n        while  initalSum > targetSum:\\n            val = heappop(heap)\\n            heappush(heap,val / 2)\\n            initalSum -= (-(val / 2))\\n            res += 1\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        heap = []\\n        for num in nums:\\n            heappush(heap,-num)\\n\\n        initalSum = sum(nums)\\n        targetSum = initalSum / 2\\n        res = 0\\n\\n        while  initalSum > targetSum:\\n            val = heappop(heap)\\n            heappush(heap,val / 2)\\n            initalSum -= (-(val / 2))\\n            res += 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153396,
                "title": "scala-priorityqueue",
                "content": "# Code\\n```\\nobject Solution {\\n  def halveArray(nums: Array[Int]): Int = {\\n    val pq = collection.mutable.PriorityQueue.from(nums.iterator.map(_.toDouble))\\n    val half = pq.sum / 2.0\\n    def impl(sum1: Double, count: Int): Int = {\\n      if(sum1<=half) count else {\\n        val x = pq.dequeue\\n        val x2 = x/2.0\\n        pq.enqueue(x2)\\n        impl(sum1-x2,count+1)\\n      }\\n    }\\n    impl(pq.sum,0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def halveArray(nums: Array[Int]): Int = {\\n    val pq = collection.mutable.PriorityQueue.from(nums.iterator.map(_.toDouble))\\n    val half = pq.sum / 2.0\\n    def impl(sum1: Double, count: Int): Int = {\\n      if(sum1<=half) count else {\\n        val x = pq.dequeue\\n        val x2 = x/2.0\\n        pq.enqueue(x2)\\n        impl(sum1-x2,count+1)\\n      }\\n    }\\n    impl(pq.sum,0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3117598,
                "title": "java-easy-to-understand-priority-queue",
                "content": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double sum = 0, reach = 0;\\n        int count = 0;\\n        Queue<Double> que = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: nums){\\n            sum += i;\\n            que.offer((double)i);\\n        }\\n        while(reach < sum / 2){\\n            double x = que.poll();\\n            reach += x / 2;\\n            que.offer(x / 2);\\n            count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double sum = 0, reach = 0;\\n        int count = 0;\\n        Queue<Double> que = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i: nums){\\n            sum += i;\\n            que.offer((double)i);\\n        }\\n        while(reach < sum / 2){\\n            double x = que.poll();\\n            reach += x / 2;\\n            que.offer(x / 2);\\n            count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114623,
                "title": "easy-simple-fast-java-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, In this problem it is mentioned that, we need to calculate the **minimun count** to reduce the sum of the array less than or equal to it\\'s half of the sum, for that we can choose any element from the array and reduce to it\\'s half and also we can perform this operation to same element any number of times...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo it is clear that, in order to reduce sum in minimum count, we need to take the biggest element in the array and reduce it to half, so we use priority queue and reduce the highest element to it\\'s half and increment count untill it is less than the half of the original sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(Nlog(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        var pq = new PriorityQueue<Double>(Collections.reverseOrder());\\n        int count=0;\\n        double sum=0;\\n        double temp=0;\\n        for(double i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        } temp=sum/2;\\n        while(sum>temp){\\n            double top = pq.poll()/2;\\n            sum-=top;\\n            pq.add(top);\\n            count++;\\n        } return count;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/d46e5df5-3001-4c15-9db5-220b418b0957_1675058016.2260725.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        var pq = new PriorityQueue<Double>(Collections.reverseOrder());\\n        int count=0;\\n        double sum=0;\\n        double temp=0;\\n        for(double i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        } temp=sum/2;\\n        while(sum>temp){\\n            double top = pq.poll()/2;\\n            sum-=top;\\n            pq.add(top);\\n            count++;\\n        } return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107346,
                "title": "python-heap-solution",
                "content": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        h = []\\n        cur_sum = sum(nums)\\n        target = cur_sum/2\\n        for num in nums:heapq.heappush(h,-num)\\n        res = 0\\n\\n        while cur_sum > target:\\n            t = (heapq.heappop(h) * -1)/2\\n            cur_sum -= t\\n            heapq.heappush(h,-t)\\n            res += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        h = []\\n        cur_sum = sum(nums)\\n        target = cur_sum/2\\n        for num in nums:heapq.heappush(h,-num)\\n        res = 0\\n\\n        while cur_sum > target:\\n            t = (heapq.heappop(h) * -1)/2\\n            cur_sum -= t\\n            heapq.heappush(h,-t)\\n            res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101128,
                "title": "priorityqueue-java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        \\n        PriorityQueue<Double> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(double x:nums){\\n            pq.add(x);\\n            sum+=x;\\n        }\\n        double x=sum;\\n        int count=0;\\n        while(x>(sum/2.0)){\\n            double t=pq.poll()/2.0;\\n            x-=t;\\n            count++;\\n            pq.add(t);\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        \\n        PriorityQueue<Double> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        double sum=0;\\n        for(double x:nums){\\n            pq.add(x);\\n            sum+=x;\\n        }\\n        double x=sum;\\n        int count=0;\\n        while(x>(sum/2.0)){\\n            double t=pq.poll()/2.0;\\n            x-=t;\\n            count++;\\n            pq.add(t);\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100207,
                "title": "priority-queue-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& v) {\\n        priority_queue<double>pq(v.begin(),v.end());\\n        double s=0;\\n        s=accumulate(v.begin(),v.end(),s);\\n        s/=2.0;\\n        int ans=0;\\n        while(!pq.empty() && s>0){\\n            double temp=pq.top();\\n            pq.pop();\\n            double half=temp/2.0;\\n            if(half>0)pq.push(half);\\n            s-=temp-half;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& v) {\\n        priority_queue<double>pq(v.begin(),v.end());\\n        double s=0;\\n        s=accumulate(v.begin(),v.end(),s);\\n        s/=2.0;\\n        int ans=0;\\n        while(!pq.empty() && s>0){\\n            double temp=pq.top();\\n            pq.pop();\\n            double half=temp/2.0;\\n            if(half>0)pq.push(half);\\n            s-=temp-half;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094592,
                "title": "py-heap-o-n-log-n",
                "content": "- Time complexity: O(n * log n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        \\n        nums_sum = sum(nums)\\n        nums_half_sum = nums_sum / 2\\n        nums = [-num for num in nums]\\n        heapq.heapify(nums)\\n        ans = 0\\n\\n        while nums_sum > nums_half_sum:\\n            biggest = -heapq.heappop(nums)\\n\\n            heapq.heappush(nums, -(biggest / 2))\\n            nums_sum -= biggest / 2\\n            ans += 1\\n\\n        return ans\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        \\n        nums_sum = sum(nums)\\n        nums_half_sum = nums_sum / 2\\n        nums = [-num for num in nums]\\n        heapq.heapify(nums)\\n        ans = 0\\n\\n        while nums_sum > nums_half_sum:\\n            biggest = -heapq.heappop(nums)\\n\\n            heapq.heappush(nums, -(biggest / 2))\\n            nums_sum -= biggest / 2\\n            ans += 1\\n\\n        return ans\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072629,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n\\n        heap = [-x for x in nums]\\n        heapq.heapify(heap)\\n        suma = newSum = sum(nums)\\n        \\n        ans = 0\\n        while newSum > suma/2:\\n            temp = heapq.heappop(heap)/2\\n            newSum += temp\\n            heapq.heappush(heap,temp)\\n            ans += 1\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n\\n        heap = [-x for x in nums]\\n        heapq.heapify(heap)\\n        suma = newSum = sum(nums)\\n        \\n        ans = 0\\n        while newSum > suma/2:\\n            temp = heapq.heappop(heap)/2\\n            newSum += temp\\n            heapq.heappush(heap,temp)\\n            ans += 1\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058562,
                "title": "easy-java-solution-with-explanation-max-heap",
                "content": "# Intuition\\nAs we have to count the minimum number of steps/operations to make the sum atleast have of the total sum. Then we can go from removing the large value elements as removing those, will reduce the sum more quickly.\\n\\n# Approach\\n1. Calculate the sum.\\n2. Put all the values in a max heap.So, the operation to get deleteMax and putting new value into the heap, will be $$O(log n)$$\\n3. Keep removing the Max element as push back half of that element. till we get the desired case\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double sum = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i : nums){\\n            sum += i;\\n            pq.offer((double)i);\\n        }\\n\\n        double temp = sum;\\n        int count = 0;\\n\\n        while(sum/2 < temp){\\n            double tt = pq.poll();\\n            double ttt = tt/2;\\n\\n            pq.offer(ttt);\\n\\n            temp = temp - tt + ttt;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int halveArray(int[] nums) {\\n        double sum = 0;\\n        PriorityQueue<Double> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i : nums){\\n            sum += i;\\n            pq.offer((double)i);\\n        }\\n\\n        double temp = sum;\\n        int count = 0;\\n\\n        while(sum/2 < temp){\\n            double tt = pq.poll();\\n            double ttt = tt/2;\\n\\n            pq.offer(ttt);\\n\\n            temp = temp - tt + ttt;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040702,
                "title": "c-solution-beats-90-51-runtime",
                "content": "```\\nvoid swap(double *a, double* b) {\\n    double temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid heapify(double *arr, int n, int i) {\\n    int largest = i, l = 2 * i + 1, r = 2 * i + 2; \\n \\n    if (l < n && arr[l] > arr[largest])\\n        largest = l;\\n \\n    if (r < n && arr[r] > arr[largest])\\n        largest = r;\\n \\n    if (largest != i) {\\n        swap(&arr[i], &arr[largest]);\\n        heapify(arr, n, largest);\\n    }\\n}\\n\\nvoid buildHeap (int* ar, int n) {\\n    for (int i = (n / 2) - 1; i >= 0; i--) \\n        heapify(ar, n, i);\\n}\\n\\nint halveArray(int* nums, int numsSize){\\n    int i, operations = 0;\\n    double totalSum = 0, halfSum = 0;\\n    double *array = malloc(sizeof(double) * numsSize);\\n\\n    for (i = 0; i < numsSize; i++)\\n        array[i] = nums[i];\\n\\n    buildHeap(array, numsSize);\\n\\n    for (i = 0; i < numsSize; i++)\\n        totalSum += array[i];\\n\\n    totalSum /= 2;\\n\\n    while (halfSum < totalSum) {\\n        double x = array[0] / 2;\\n        array[0] = x;\\n        heapify(array, numsSize, 0);\\n        halfSum += x;\\n        operations++;\\n    }\\n\\n    free(array);\\n    return operations;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid swap(double *a, double* b) {\\n    double temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid heapify(double *arr, int n, int i) {\\n    int largest = i, l = 2 * i + 1, r = 2 * i + 2; \\n \\n    if (l < n && arr[l] > arr[largest])\\n        largest = l;\\n \\n    if (r < n && arr[r] > arr[largest])\\n        largest = r;\\n \\n    if (largest != i) {\\n        swap(&arr[i], &arr[largest]);\\n        heapify(arr, n, largest);\\n    }\\n}\\n\\nvoid buildHeap (int* ar, int n) {\\n    for (int i = (n / 2) - 1; i >= 0; i--) \\n        heapify(ar, n, i);\\n}\\n\\nint halveArray(int* nums, int numsSize){\\n    int i, operations = 0;\\n    double totalSum = 0, halfSum = 0;\\n    double *array = malloc(sizeof(double) * numsSize);\\n\\n    for (i = 0; i < numsSize; i++)\\n        array[i] = nums[i];\\n\\n    buildHeap(array, numsSize);\\n\\n    for (i = 0; i < numsSize; i++)\\n        totalSum += array[i];\\n\\n    totalSum /= 2;\\n\\n    while (halfSum < totalSum) {\\n        double x = array[0] / 2;\\n        array[0] = x;\\n        heapify(array, numsSize, 0);\\n        halfSum += x;\\n        operations++;\\n    }\\n\\n    free(array);\\n    return operations;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1731312,
                "content": [
                    {
                        "username": "heenahmed08",
                        "content": "suggestion: don't use float for storing elements in priority Queue, it will give wrong answer in case when all elements of array are 10000000 and size of array is 100000.  use double instead."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I also faced the same issue. Why is it happening like that?"
                    },
                    {
                        "username": "shashwat_chawla",
                        "content": "I have used float in priority_queue and it is working...,,,its the overallsum which might be outof bound so we can declare that as long double ,.... I mean doing this just workd for me "
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "**Hint**: Use a priority queue / max heap"
                    },
                    {
                        "username": "penril0326",
                        "content": "Your final sum of array must LESS than half of initial sum of array.\\nOne case I failed:\\nnums = [1]\\n\\nin this case, the half of initial sum is 0.5, so sum of reduce = 0.5 is not accept. (need to reduce more than 0.5)"
                    },
                    {
                        "username": "jga111",
                        "content": "Example 2 is there to throw you.\\n\\n\"Pick the number 3 and reduce it to 1.5.\" \\n\\nOr pick 8 and maintain the greediness of the algorithm.\\n\\nUse a max heap."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2208.%20Minimum%20Operations%20to%20Halve%20Array%20Sum.CPP"
                    },
                    {
                        "username": "asthakul17",
                        "content": "why we use double in this question?"
                    },
                    {
                        "username": "sairajd044",
                        "content": "int can\\'t store floating point values"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "**HINT**: Use double ( C++ | Java )"
                    }
                ]
            },
            {
                "id": 1576521,
                "content": [
                    {
                        "username": "heenahmed08",
                        "content": "suggestion: don't use float for storing elements in priority Queue, it will give wrong answer in case when all elements of array are 10000000 and size of array is 100000.  use double instead."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I also faced the same issue. Why is it happening like that?"
                    },
                    {
                        "username": "shashwat_chawla",
                        "content": "I have used float in priority_queue and it is working...,,,its the overallsum which might be outof bound so we can declare that as long double ,.... I mean doing this just workd for me "
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "**Hint**: Use a priority queue / max heap"
                    },
                    {
                        "username": "penril0326",
                        "content": "Your final sum of array must LESS than half of initial sum of array.\\nOne case I failed:\\nnums = [1]\\n\\nin this case, the half of initial sum is 0.5, so sum of reduce = 0.5 is not accept. (need to reduce more than 0.5)"
                    },
                    {
                        "username": "jga111",
                        "content": "Example 2 is there to throw you.\\n\\n\"Pick the number 3 and reduce it to 1.5.\" \\n\\nOr pick 8 and maintain the greediness of the algorithm.\\n\\nUse a max heap."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2208.%20Minimum%20Operations%20to%20Halve%20Array%20Sum.CPP"
                    },
                    {
                        "username": "asthakul17",
                        "content": "why we use double in this question?"
                    },
                    {
                        "username": "sairajd044",
                        "content": "int can\\'t store floating point values"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "**HINT**: Use double ( C++ | Java )"
                    }
                ]
            },
            {
                "id": 2072593,
                "content": [
                    {
                        "username": "heenahmed08",
                        "content": "suggestion: don't use float for storing elements in priority Queue, it will give wrong answer in case when all elements of array are 10000000 and size of array is 100000.  use double instead."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I also faced the same issue. Why is it happening like that?"
                    },
                    {
                        "username": "shashwat_chawla",
                        "content": "I have used float in priority_queue and it is working...,,,its the overallsum which might be outof bound so we can declare that as long double ,.... I mean doing this just workd for me "
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "**Hint**: Use a priority queue / max heap"
                    },
                    {
                        "username": "penril0326",
                        "content": "Your final sum of array must LESS than half of initial sum of array.\\nOne case I failed:\\nnums = [1]\\n\\nin this case, the half of initial sum is 0.5, so sum of reduce = 0.5 is not accept. (need to reduce more than 0.5)"
                    },
                    {
                        "username": "jga111",
                        "content": "Example 2 is there to throw you.\\n\\n\"Pick the number 3 and reduce it to 1.5.\" \\n\\nOr pick 8 and maintain the greediness of the algorithm.\\n\\nUse a max heap."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2208.%20Minimum%20Operations%20to%20Halve%20Array%20Sum.CPP"
                    },
                    {
                        "username": "asthakul17",
                        "content": "why we use double in this question?"
                    },
                    {
                        "username": "sairajd044",
                        "content": "int can\\'t store floating point values"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "**HINT**: Use double ( C++ | Java )"
                    }
                ]
            },
            {
                "id": 1820490,
                "content": [
                    {
                        "username": "heenahmed08",
                        "content": "suggestion: don't use float for storing elements in priority Queue, it will give wrong answer in case when all elements of array are 10000000 and size of array is 100000.  use double instead."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I also faced the same issue. Why is it happening like that?"
                    },
                    {
                        "username": "shashwat_chawla",
                        "content": "I have used float in priority_queue and it is working...,,,its the overallsum which might be outof bound so we can declare that as long double ,.... I mean doing this just workd for me "
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "**Hint**: Use a priority queue / max heap"
                    },
                    {
                        "username": "penril0326",
                        "content": "Your final sum of array must LESS than half of initial sum of array.\\nOne case I failed:\\nnums = [1]\\n\\nin this case, the half of initial sum is 0.5, so sum of reduce = 0.5 is not accept. (need to reduce more than 0.5)"
                    },
                    {
                        "username": "jga111",
                        "content": "Example 2 is there to throw you.\\n\\n\"Pick the number 3 and reduce it to 1.5.\" \\n\\nOr pick 8 and maintain the greediness of the algorithm.\\n\\nUse a max heap."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2208.%20Minimum%20Operations%20to%20Halve%20Array%20Sum.CPP"
                    },
                    {
                        "username": "asthakul17",
                        "content": "why we use double in this question?"
                    },
                    {
                        "username": "sairajd044",
                        "content": "int can\\'t store floating point values"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "**HINT**: Use double ( C++ | Java )"
                    }
                ]
            },
            {
                "id": 1804018,
                "content": [
                    {
                        "username": "heenahmed08",
                        "content": "suggestion: don't use float for storing elements in priority Queue, it will give wrong answer in case when all elements of array are 10000000 and size of array is 100000.  use double instead."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I also faced the same issue. Why is it happening like that?"
                    },
                    {
                        "username": "shashwat_chawla",
                        "content": "I have used float in priority_queue and it is working...,,,its the overallsum which might be outof bound so we can declare that as long double ,.... I mean doing this just workd for me "
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "**Hint**: Use a priority queue / max heap"
                    },
                    {
                        "username": "penril0326",
                        "content": "Your final sum of array must LESS than half of initial sum of array.\\nOne case I failed:\\nnums = [1]\\n\\nin this case, the half of initial sum is 0.5, so sum of reduce = 0.5 is not accept. (need to reduce more than 0.5)"
                    },
                    {
                        "username": "jga111",
                        "content": "Example 2 is there to throw you.\\n\\n\"Pick the number 3 and reduce it to 1.5.\" \\n\\nOr pick 8 and maintain the greediness of the algorithm.\\n\\nUse a max heap."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2208.%20Minimum%20Operations%20to%20Halve%20Array%20Sum.CPP"
                    },
                    {
                        "username": "asthakul17",
                        "content": "why we use double in this question?"
                    },
                    {
                        "username": "sairajd044",
                        "content": "int can\\'t store floating point values"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "**HINT**: Use double ( C++ | Java )"
                    }
                ]
            },
            {
                "id": 1731224,
                "content": [
                    {
                        "username": "heenahmed08",
                        "content": "suggestion: don't use float for storing elements in priority Queue, it will give wrong answer in case when all elements of array are 10000000 and size of array is 100000.  use double instead."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I also faced the same issue. Why is it happening like that?"
                    },
                    {
                        "username": "shashwat_chawla",
                        "content": "I have used float in priority_queue and it is working...,,,its the overallsum which might be outof bound so we can declare that as long double ,.... I mean doing this just workd for me "
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "**Hint**: Use a priority queue / max heap"
                    },
                    {
                        "username": "penril0326",
                        "content": "Your final sum of array must LESS than half of initial sum of array.\\nOne case I failed:\\nnums = [1]\\n\\nin this case, the half of initial sum is 0.5, so sum of reduce = 0.5 is not accept. (need to reduce more than 0.5)"
                    },
                    {
                        "username": "jga111",
                        "content": "Example 2 is there to throw you.\\n\\n\"Pick the number 3 and reduce it to 1.5.\" \\n\\nOr pick 8 and maintain the greediness of the algorithm.\\n\\nUse a max heap."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2208.%20Minimum%20Operations%20to%20Halve%20Array%20Sum.CPP"
                    },
                    {
                        "username": "asthakul17",
                        "content": "why we use double in this question?"
                    },
                    {
                        "username": "sairajd044",
                        "content": "int can\\'t store floating point values"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "**HINT**: Use double ( C++ | Java )"
                    }
                ]
            },
            {
                "id": 1731149,
                "content": [
                    {
                        "username": "heenahmed08",
                        "content": "suggestion: don't use float for storing elements in priority Queue, it will give wrong answer in case when all elements of array are 10000000 and size of array is 100000.  use double instead."
                    },
                    {
                        "username": "dsa_looser365",
                        "content": "I also faced the same issue. Why is it happening like that?"
                    },
                    {
                        "username": "shashwat_chawla",
                        "content": "I have used float in priority_queue and it is working...,,,its the overallsum which might be outof bound so we can declare that as long double ,.... I mean doing this just workd for me "
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "**Hint**: Use a priority queue / max heap"
                    },
                    {
                        "username": "penril0326",
                        "content": "Your final sum of array must LESS than half of initial sum of array.\\nOne case I failed:\\nnums = [1]\\n\\nin this case, the half of initial sum is 0.5, so sum of reduce = 0.5 is not accept. (need to reduce more than 0.5)"
                    },
                    {
                        "username": "jga111",
                        "content": "Example 2 is there to throw you.\\n\\n\"Pick the number 3 and reduce it to 1.5.\" \\n\\nOr pick 8 and maintain the greediness of the algorithm.\\n\\nUse a max heap."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2208.%20Minimum%20Operations%20to%20Halve%20Array%20Sum.CPP"
                    },
                    {
                        "username": "asthakul17",
                        "content": "why we use double in this question?"
                    },
                    {
                        "username": "sairajd044",
                        "content": "int can\\'t store floating point values"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "**HINT**: Use double ( C++ | Java )"
                    }
                ]
            }
        ]
    }
]