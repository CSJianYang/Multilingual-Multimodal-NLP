[
    {
        "title": "Design Phone Directory",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565140,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1566087,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572549,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572777,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572074,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571649,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571650,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571651,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571953,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1986263,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1565140,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1566087,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572549,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572777,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1572074,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571649,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571650,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571651,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1571953,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            },
            {
                "id": 1986263,
                "content": [
                    {
                        "username": "yubad2000",
                        "content": "The problem states that get() provides a number which is not assigned to anyone. It does not state the order of the number can be given.\\nHowever, the test cases are expecting a certain order from get() function's returns.\\nIf this specific order is expected, it should be stated in the problem statement."
                    },
                    {
                        "username": "phucle",
                        "content": "Agree with this one. It did not really expect random number. "
                    },
                    {
                        "username": "TTester",
                        "content": "I spent more than 2 hours, and I was mad because all of my solutions got LTE. Then I gave up, and tried to see others' solutions, but they were almost the same as mine. I thought maybe my implementation was bad. However, after I copied and pasted their ACCEPTED code, I still got LTE.\\n\\n**I tried almost every c++ solution posted by the others. All of them got LTE.** (Maybe when the author posted it, it could pass, but after that, something was wrong with the OJ)."
                    },
                    {
                        "username": "caowang888",
                        "content": "The solution is pretty much trival if it\\'s O(n) when you add all N keys during initialization. I can ask this one follow-up question to start my system design round after it took you less than 10 min to code it.\\n\\nThis is the first:\\nWhat if N is very large that it would take very long to initialize it from very beginning? Also I don\\'t want to pay that much storage cost when my service just launched.\\n\\nIf I see people participate, I\\'ll post more follow-up questions on the popular answers I get."
                    },
                    {
                        "username": "xzj104",
                        "content": "seems quite a lot solutions are using two arrays or unordered_set but set itself is sorted. Is there any restriction mentioned?"
                    },
                    {
                        "username": "elaineren7",
                        "content": "Time efficiency vs. Space efficiency.\\nDiscuss with the interviewer which one is more important (depend on the use case).\\n\\nTime efficiency critical:\\nstack + lookup array for used slots.\\n\\nMemory efficiency critical:\\nhash map, which maps the number space to a smaller memory space.\\nDisadvantage: real execution time can vary.\\n\\nImprove on the hash map:\\nImplement a custom hash map that incorporate the knowledge of the max number."
                    },
                    {
                        "username": "xiaogezhang",
                        "content": "This design is meant to scale. for integer as range is small, use list and set can fit the design well.\\n\\nclass TreeNode {\\n  int low;\\n  int high;\\n}\\n\\nas system scale up, the number may be too large.\\n\\nwe can use a binary tree to track all \"free\" phone numbers.\\n\\neach tree node is a range, with low and high. all nodes do not overlap. the tree is constructed as binary search tree.\\n\\nso when you call get(), find any node in the \"free\" tree, return node.low, and adjust node.low. if low > high, delete the node. if it's connected with the range of the parent, merge with parent. \\n\\nsimilar handling for release(x)."
                    },
                    {
                        "username": "Tiejun",
                        "content": "For example, input like this `[\"PhoneDirectory\",\"get\",\"check\",\"get\",\"get\",\"release\",\"check\",\"get\",\"get\",\"get\"]\\n[[5],[], [1],[],[],[1],[2],[],[],[]]`\\n\\nI think the right output should be `[null,0,true,1,2,null,false,1,3,4]`, but instead I was told the expected result is `[null,0,true,1,2,null,false,3,1,4]`. Does it make sense? Since `1` is released, `get` operation should return the minimum available number, am I correct?"
                    },
                    {
                        "username": "Nakanu",
                        "content": "I wrote the solution in Java using only one hashset intuitively. It was accepted for the first time (but no longer accepted later). It costs more than 800ms. That was really awful. \\nCould someone explain the difference of those 2 methods here? \\nThank you !"
                    },
                    {
                        "username": "qin4",
                        "content": "This question is likely to be a system design question which shares same idea of tinyUrl - a zookeeper to assign ranges to hosts, then each host manage its hashset or counter (if no need to remove) to assign id/number/unique url and persist data on DB. To look at it as a single host, a increment counter or hashset would be good enough, no fancy algorithm. Any thoughts?"
                    },
                    {
                        "username": "AIPlayerX",
                        "content": "I really don't understand why we use boolean array or segment tree here?\nThis problem can be easily solved using a counter (0 ~ MaxNumber-1) and a hashset to keep track of released number. The idea is:\n  -- If a number is released, add it to hashset.\n  -- If we need to allocate a new number, use the number in hashset first, if the hashset is empty, return counter and counter += 1.\nTime Complexity: O(1), Space Complexity: O(K) \nK is the maximum length of hashset. As we always allocate the number in hashset first, we can treat the space as O(1).\nI posted my python code in Solutions which beated 95% on both time and space.\nIs this much better than segment tree? Did I miss anything?\n "
                    }
                ]
            }
        ]
    }
]