[
    {
        "title": "Maximum Count of Positive Integer and Negative Integer",
        "question_content": "Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.\n\n\tIn other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.\n\nNote that 0 is neither positive nor negative.\n&nbsp;\nExample 1:\n\nInput: nums = [-2,-1,-1,1,2,3]\nOutput: 3\nExplanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3.\n\nExample 2:\n\nInput: nums = [-3,-2,-1,0,0,1,2]\nOutput: 3\nExplanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3.\n\nExample 3:\n\nInput: nums = [5,20,66,1314]\nOutput: 4\nExplanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 2000\n\t-2000 <= nums[i] <= 2000\n\tnums is sorted in a non-decreasing order.\n\n&nbsp;\nFollow up: Can you solve the problem in O(log(n)) time complexity?",
        "solutions": [
            {
                "id": 3017003,
                "title": "c-java-python3-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/cd738c7122f758231c4f575936d09271343de490) for solutions of weekly 327. \\n\\n**Intuition**\\nWe binary search for the number of negative numbers and positive numbers in the array. \\n\\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg = lower_bound(nums.begin(), nums.end(), 0) - nums.begin(), pos = nums.end() - upper_bound(nums.begin(), nums.end(), 0); \\n        return max(neg, pos); \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    private static int bisect_left(int[] nums, int target) {\\n        int lo = 0, hi = nums.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2; \\n            if (nums[mid] < target) lo = mid+1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n    \\n    public int maximumCount(int[] nums) {\\n        int neg = bisect_left(nums, 0), pos = nums.length - bisect_left(nums, 1); \\n        return Math.max(neg, pos); \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg = bisect_left(nums, 0)\\n        pos = len(nums) - bisect_right(nums, 0)\\n        return max(neg, pos)\\n```\\n**Complexity**\\nTime `O(logN)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg = lower_bound(nums.begin(), nums.end(), 0) - nums.begin(), pos = nums.end() - upper_bound(nums.begin(), nums.end(), 0); \\n        return max(neg, pos); \\n    }\\n};\\n```\n```\\nclass Solution {\\n    private static int bisect_left(int[] nums, int target) {\\n        int lo = 0, hi = nums.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2; \\n            if (nums[mid] < target) lo = mid+1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n    \\n    public int maximumCount(int[] nums) {\\n        int neg = bisect_left(nums, 0), pos = nums.length - bisect_left(nums, 1); \\n        return Math.max(neg, pos); \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg = bisect_left(nums, 0)\\n        pos = len(nums) - bisect_right(nums, 0)\\n        return max(neg, pos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017781,
                "title": "cpp-bs-lower-bound-time-log-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind total number of zeros and first index of any positive number\\n`totalNumberOfZeros = firstPosIndex - firstZeroIndex`\\n`totalNumberOfNegNums = firstPosIndex - totalNumberOfZeros`\\n`totalNumberOfPosNums = n - firstPosIndex`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind `firstPosIndex` using binary search , `lower_bound` in cpp\\nfind `firstZeroIndex` using binary search , `lower_bound` in cpp\\nand use above formula.\\n\\n# Complexity\\n- Time complexity: `O(logn)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& v) {\\n        int n = v.size();\\n        int firstPos = lower_bound(v.begin(),v.end(),1) - v.begin();\\n        int firstZero = lower_bound(v.begin(),v.end(),0) - v.begin();\\n        int numberOfZeros = firstPos - firstZero;\\n        return max(n - firstPos,firstPos - numberOfZeros);\\n        \\n    }\\n};\\n```\\n\\nLittle update from the comments.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& v) {\\n        int n = v.size();\\n        int firstPos = lower_bound(v.begin(),v.end(),1) - v.begin();\\n        int firstZero = lower_bound(v.begin(),v.end(),0) - v.begin();\\n        return max(n - firstPos,firstZero);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& v) {\\n        int n = v.size();\\n        int firstPos = lower_bound(v.begin(),v.end(),1) - v.begin();\\n        int firstZero = lower_bound(v.begin(),v.end(),0) - v.begin();\\n        int numberOfZeros = firstPos - firstZero;\\n        return max(n - firstPos,firstPos - numberOfZeros);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& v) {\\n        int n = v.size();\\n        int firstPos = lower_bound(v.begin(),v.end(),1) - v.begin();\\n        int firstZero = lower_bound(v.begin(),v.end(),0) - v.begin();\\n        return max(n - firstPos,firstZero);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042868,
                "title": "with-the-concept-of-first-and-the-last-occurence-in-o-logn-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince the array is sorted the qn says it loudly to apply binary search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind the position of the last occuring negative number if nums[0]<0\\nand the  first occurece of the positive number if nums[n-1]>0\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nApplying binary search two times for finding the respective occurrences wil cost u twice of logn only.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=n-1;\\n        int neg=0,p=0;\\n        int negl=0,posf=0,posl=0;\\n\\n          //for negative\\'s last occurence:\\n\\n          if(nums[0]==0 &&nums[n-1]==0)\\n          return 0;\\n\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n\\n             \\n             if(nums[mid]<0){\\n                 negl=mid;\\n                 i=mid+1;\\n             }\\n\\n             else if(nums[mid]>=0){\\n                 j=mid-1;\\n             }\\n        }\\n\\n        i=0;j=n-1;\\n\\n         //for positive\\'s first occurrence:\\n        \\n          while(i<=j){\\n            int mid=i+(j-i)/2;\\n\\n             \\n             if(nums[mid]>0){\\n                 posf=mid;\\n                 j=mid-1;\\n             }\\n\\n             else if(nums[mid]<=0){\\n                 i=mid+1;\\n             }\\n        }\\n\\n         if(nums[n-1]>0)\\n         posl=n-1;\\n\\n         p=posl-posf+1;\\n          neg=negl-0+1;\\n\\n\\n         return max(p,neg);\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=n-1;\\n        int neg=0,p=0;\\n        int negl=0,posf=0,posl=0;\\n\\n          //for negative\\'s last occurence:\\n\\n          if(nums[0]==0 &&nums[n-1]==0)\\n          return 0;\\n\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n\\n             \\n             if(nums[mid]<0){\\n                 negl=mid;\\n                 i=mid+1;\\n             }\\n\\n             else if(nums[mid]>=0){\\n                 j=mid-1;\\n             }\\n        }\\n\\n        i=0;j=n-1;\\n\\n         //for positive\\'s first occurrence:\\n        \\n          while(i<=j){\\n            int mid=i+(j-i)/2;\\n\\n             \\n             if(nums[mid]>0){\\n                 posf=mid;\\n                 j=mid-1;\\n             }\\n\\n             else if(nums[mid]<=0){\\n                 i=mid+1;\\n             }\\n        }\\n\\n         if(nums[n-1]>0)\\n         posl=n-1;\\n\\n         p=posl-posf+1;\\n          neg=negl-0+1;\\n\\n\\n         return max(p,neg);\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016725,
                "title": "java-binary-search-commented",
                "content": "```java\\nclass Solution {\\n  public int maximumCount(int[] nums) {\\n    // All negative or all possitive. We can be sure that the larger number will be array\\'s length\\n    if (nums[0] > 0 || nums[nums.length - 1] < 0) return nums.length;\\n    \\n    // find 0\\n    int l = 0, r = nums.length - 1, mid;\\n    while (l < r) {\\n      mid = l + (r - l) / 2;\\n      if (nums[mid] < 0) l = mid + 1;\\n      else r = mid;\\n    }\\n    \\n    // currently, `l` is pointing to the left most position that nums[l] >= 0\\n    int neg = l;\\n    \\n    // Move l to right to exclude zeros.\\n    while (l < nums.length && nums[l] == 0) l++;\\n    int pos = nums.length - l;\\n    \\n    return Math.max(neg, pos);\\n  }\\n}\\n```\\n\\nUpdate:\\nkasidi@ metioned that we can get rid of the second for loop by using a binary search.\\nThis is a good idea to improve the wrost time complexity\\n\\n```java\\nclass Solution {\\n  public int maximumCount(int[] nums) {\\n    // All negative or all possitive. We can be sure that the larger number will be array\\'s length\\n    if (nums[0] > 0 || nums[nums.length - 1] < 0) return nums.length;\\n    \\n    // find 0\\n    int l = 0, r = nums.length - 1, mid;\\n    while (l < r) {\\n      mid = l + (r - l) / 2;\\n      if (nums[mid] < 0) l = mid + 1;\\n      else r = mid;\\n    }\\n    \\n    // currently, `l` is pointing to the left most position that nums[l] >= 0\\n    int neg = l;\\n\\t\\n    l = 0;\\n    r = nums.length;\\n    while (l < r) {\\n      mid = l + (r - l) / 2;\\n      if (nums[mid] > 0) r = mid;\\n      else l = mid + 1;\\n    }\\n    // This time, `l` is pointing to the left most position that nums[l] > 0\\n    int pos = nums.length - l;\\n\\n    return Math.max(neg, pos);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n  public int maximumCount(int[] nums) {\\n    // All negative or all possitive. We can be sure that the larger number will be array\\'s length\\n    if (nums[0] > 0 || nums[nums.length - 1] < 0) return nums.length;\\n    \\n    // find 0\\n    int l = 0, r = nums.length - 1, mid;\\n    while (l < r) {\\n      mid = l + (r - l) / 2;\\n      if (nums[mid] < 0) l = mid + 1;\\n      else r = mid;\\n    }\\n    \\n    // currently, `l` is pointing to the left most position that nums[l] >= 0\\n    int neg = l;\\n    \\n    // Move l to right to exclude zeros.\\n    while (l < nums.length && nums[l] == 0) l++;\\n    int pos = nums.length - l;\\n    \\n    return Math.max(neg, pos);\\n  }\\n}\\n```\n```java\\nclass Solution {\\n  public int maximumCount(int[] nums) {\\n    // All negative or all possitive. We can be sure that the larger number will be array\\'s length\\n    if (nums[0] > 0 || nums[nums.length - 1] < 0) return nums.length;\\n    \\n    // find 0\\n    int l = 0, r = nums.length - 1, mid;\\n    while (l < r) {\\n      mid = l + (r - l) / 2;\\n      if (nums[mid] < 0) l = mid + 1;\\n      else r = mid;\\n    }\\n    \\n    // currently, `l` is pointing to the left most position that nums[l] >= 0\\n    int neg = l;\\n\\t\\n    l = 0;\\n    r = nums.length;\\n    while (l < r) {\\n      mid = l + (r - l) / 2;\\n      if (nums[mid] > 0) r = mid;\\n      else l = mid + 1;\\n    }\\n    // This time, `l` is pointing to the left most position that nums[l] > 0\\n    int pos = nums.length - l;\\n\\n    return Math.max(neg, pos);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040282,
                "title": "log-n-easy-to-understand-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int s = 0, e = nums.size()-1,mid,ans1= 0,ans2 = 0;\\n        while(s<=e){\\n            mid = (e-s)/2+s;\\n            if(nums[mid]<0){\\n                ans1 = mid+1;\\n                s = mid+1;\\n            }else{\\n                e = mid-1;\\n            }\\n        }\\n        s = 0, e = nums.size()-1;\\n        while(s<=e){\\n            mid = (e-s)/2+s;\\n            if(nums[mid]>0){\\n                ans2 = nums.size()-mid;\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int s = 0, e = nums.size()-1,mid,ans1= 0,ans2 = 0;\\n        while(s<=e){\\n            mid = (e-s)/2+s;\\n            if(nums[mid]<0){\\n                ans1 = mid+1;\\n                s = mid+1;\\n            }else{\\n                e = mid-1;\\n            }\\n        }\\n        s = 0, e = nums.size()-1;\\n        while(s<=e){\\n            mid = (e-s)/2+s;\\n            if(nums[mid]>0){\\n                ans2 = nums.size()-mid;\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017281,
                "title": "one-liner",
                "content": "**C++**\\n```cpp\\nint maximumCount(vector<int>& nums) {\\n    return max(count_if(begin(nums), end(nums), [](int n){ return n > 0; }),\\n               count_if(begin(nums), end(nums), [](int n){ return n < 0; }));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumCount(vector<int>& nums) {\\n    return max(count_if(begin(nums), end(nums), [](int n){ return n > 0; }),\\n               count_if(begin(nums), end(nums), [](int n){ return n < 0; }));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3022160,
                "title": "python-3-one-liner-t-m-117-ms-14-3-mb",
                "content": "Pretty much explains itself... the key is that the `sort` has already done, so just need to locate the the index that separate the negatives from the zeros and the index that separates the zeros from the positives. \\n\\nFor example, if `nums = [-3,-2,-2,0,0,0,4,6,7]`, then\\n```\\n` nums = [-3,-2,-2,-1,  0,0,0, 4,6,7,9,9,9]`\\n         [--- 4 ----- /\\\\     /\\\\ ---- 6 ---]  ==> return 6\\n```\\n\\n\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```\\n[https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/873839175/](http://)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n` nums = [-3,-2,-2,-1,  0,0,0, 4,6,7,9,9,9]`\\n         [--- 4 ----- /\\\\     /\\\\ ---- 6 ---]  ==> return 6\\n```\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums,0), len(nums)-bisect_left(nums,1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020565,
                "title": "python-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos = neg = 0\\n        for i in nums:\\n            if i < 0:\\n                pos += 1\\n\\n            if i > 0:\\n                neg += 1\\n\\n        return max(pos, neg)\\n\\n\\n```\\nLike it ? Please upvote !",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos = neg = 0\\n        for i in nums:\\n            if i < 0:\\n                pos += 1\\n\\n            if i > 0:\\n                neg += 1\\n\\n        return max(pos, neg)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367553,
                "title": "first-solution-using-binary-search-o-logn-time-complexity-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBInary search 100% accepted and easy to understand,with comments\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbased on value of mid and since array is sorted non decreasing,calculated total pos and neg values\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        //first solution i am posting pls upvote if u like and found informative\\n        int pos=0;int neg=0;int low=0;int high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]>0){\\n                pos+=(high-mid)+1;//all values ahead of mid(including mid) will be\\n                                      //positive only,why?(since array is sorted)\\n                high=mid-1;//updating high ptr\\n            }\\n            else if(nums[mid]<0){\\n                neg+=(mid-low)+1;//all values behind of mid(including mid) will be\\n                       //negative only,why?(since array is sorted)\\n                low=mid+1;//update low ptr\\n            }\\n            else{//if nums[mid]==0 then we can  directly find total negative and postive elemnt in nums since array is sorted,\\n                int k=mid;\\n                while(k-1>=0 && nums[k-1]==0){//just remove repeated zero from my window\\n                    k--;\\n                }\\n                neg+=(k-low);//calculate total negative elements\\n                k=mid;\\n                while(k<high && nums[k+1]==0){//just remove repeated zero from my window\\n                    k++;\\n                }\\n                pos+=(high-k);//calculate total pos elements\\n                break;\\n            }\\n        }\\n        int ans=max(pos,neg);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        //first solution i am posting pls upvote if u like and found informative\\n        int pos=0;int neg=0;int low=0;int high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]>0){\\n                pos+=(high-mid)+1;//all values ahead of mid(including mid) will be\\n                                      //positive only,why?(since array is sorted)\\n                high=mid-1;//updating high ptr\\n            }\\n            else if(nums[mid]<0){\\n                neg+=(mid-low)+1;//all values behind of mid(including mid) will be\\n                       //negative only,why?(since array is sorted)\\n                low=mid+1;//update low ptr\\n            }\\n            else{//if nums[mid]==0 then we can  directly find total negative and postive elemnt in nums since array is sorted,\\n                int k=mid;\\n                while(k-1>=0 && nums[k-1]==0){//just remove repeated zero from my window\\n                    k--;\\n                }\\n                neg+=(k-low);//calculate total negative elements\\n                k=mid;\\n                while(k<high && nums[k+1]==0){//just remove repeated zero from my window\\n                    k++;\\n                }\\n                pos+=(high-k);//calculate total pos elements\\n                break;\\n            }\\n        }\\n        int ans=max(pos,neg);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206814,
                "title": "java-single-while-loop-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is to find the lowest possible index in which we have a positive #, and use that to calculate our window size.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExample:\\n[-2, -2, -1, 0, 0, 1, 2]\\n\\nHere, our lo = 5, so at index 5, we have the first positive # which is 1. \\n\\nOur length is 7.\\n\\nLength - lo = 2. So, we have 2 positive #s...\\n\\nHow many negative numbers do we have?\\n\\nEasy! We have lo - 0 = 5 but, we have 2 zeros, so, subtract those and you get:\\n\\nlo - 0 - countZeros = lo - 0 - 2 = 5 - 2 = 3.\\n\\nMax(3, 2) = 3.\\n\\nSo, our answer = 3.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        // find the lowest index\\n        // in which we have a positive number..\\n        // get the max of lo - 0 and len - lo...\\n        int len = nums.length;\\n        // Edge case\\n        if (nums[0] == 0 && nums[len - 1] == 0) return 0;\\n        int lo = 0, hi = len;\\n        int countZeros = 0;\\n        // Binary search\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            // get the middle element\\n            // if zero count them\\n            if (nums[mid] == 0) {\\n                countZeros++;\\n                lo = mid + 1;\\n            }\\n            else if (nums[mid] > 0) {\\n                // if positive, keep looking left\\n                hi = mid;\\n            } else {\\n                // Keep looking right\\n                lo = mid + 1;\\n            }\\n        }\\n        // Get the max of lo - 0 and len - lo\\n        return Math.max(lo - countZeros, len - lo);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        // find the lowest index\\n        // in which we have a positive number..\\n        // get the max of lo - 0 and len - lo...\\n        int len = nums.length;\\n        // Edge case\\n        if (nums[0] == 0 && nums[len - 1] == 0) return 0;\\n        int lo = 0, hi = len;\\n        int countZeros = 0;\\n        // Binary search\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            // get the middle element\\n            // if zero count them\\n            if (nums[mid] == 0) {\\n                countZeros++;\\n                lo = mid + 1;\\n            }\\n            else if (nums[mid] > 0) {\\n                // if positive, keep looking left\\n                hi = mid;\\n            } else {\\n                // Keep looking right\\n                lo = mid + 1;\\n            }\\n        }\\n        // Get the max of lo - 0 and len - lo\\n        return Math.max(lo - countZeros, len - lo);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193619,
                "title": "c-binary-search-with-explanation",
                "content": "# Intuition\\nAs the array is sorted , why to count in linear way when we can easily count using binary search\\n\\n# Approach\\nThe approach which comes to my mind is to find first/last occurence of element.\\n\\nFor negative find last element from starting of an array, by counting its last occurence we can easily get total number of negative elements from starting of an array.\\n\\nFor positive find its first occurence from starting of array.\\nWe can simply ignore counting zeros because we total number of zeroes will be (sizeofarray - firstpositveindex)\\n\\nLets take an example:\\n[-3, -2, -1 ,0, 0, 1, 2]\\n\\nIn this example, index of last negative element will be \\'2\\' and \\nso total negative count in array will be (negindex+1)-> 2+1=3.\\n\\nIndex of first positive element will be 5 so total count of \\npositive element will be (size of array - firstpositiveindex) -> 7-5=2.\\n\\nNow simply return maximum count.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n)) where n=size of an array\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size();\\n        int start=0;\\n        int end=n-1;\\n        int pos=-1,neg=-1;\\n        int ans;\\n\\n        int mid=start+(end-start)/2;\\n\\n        while(start<=end){\\n            if(nums[mid]<0){\\n                //to find last negative element\\n                neg=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n\\n        start=0;\\n        end=n-1;\\n        mid=start+(end-start)/2;\\n         while(start<=end){\\n            if(nums[mid]>0){\\n                //to find first element of positive index\\n                pos=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n       \\n        if(pos==-1 && neg==-1){\\n            // to handle test case where no pos or neg occurs\\n            return 0;\\n        }\\n        else if(neg==-1){\\n            //if only pos occurs\\n            return n-pos;\\n        }\\n        else if(pos==-1){\\n            //if only neg occurs\\n            return neg+1;\\n        }\\n        else{\\n            ans=max(neg+1,n-pos);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nDo upvote if you understood the question.\\nIf any changes let me know.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size();\\n        int start=0;\\n        int end=n-1;\\n        int pos=-1,neg=-1;\\n        int ans;\\n\\n        int mid=start+(end-start)/2;\\n\\n        while(start<=end){\\n            if(nums[mid]<0){\\n                //to find last negative element\\n                neg=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n\\n        start=0;\\n        end=n-1;\\n        mid=start+(end-start)/2;\\n         while(start<=end){\\n            if(nums[mid]>0){\\n                //to find first element of positive index\\n                pos=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n            mid=start+(end-start)/2;\\n        }\\n       \\n        if(pos==-1 && neg==-1){\\n            // to handle test case where no pos or neg occurs\\n            return 0;\\n        }\\n        else if(neg==-1){\\n            //if only pos occurs\\n            return n-pos;\\n        }\\n        else if(pos==-1){\\n            //if only neg occurs\\n            return neg+1;\\n        }\\n        else{\\n            ans=max(neg+1,n-pos);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016815,
                "title": "very-simple-iteration-count",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg = 0, pos = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] < 0) neg++;\\n            else if(nums[i] > 0) pos++;\\n        }\\n        return max(pos, neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg = 0, pos = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(nums[i] < 0) neg++;\\n            else if(nums[i] > 0) pos++;\\n        }\\n        return max(pos, neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146216,
                "title": "easy-c-solution-binary-search-linear-search-counting-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N),  because we traversed over all the elements in the array, which has allowed us to\\n    achieve a linear time complexity.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant space but the program as a whole takes linear\\n    space because of storing the input array.\\n\\n    Using Array + Linear Search. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int positiveCount = 0;\\n        int negativeCount = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] > 0){\\n                positiveCount++;\\n            }\\n            else if(nums[i] < 0){\\n                negativeCount++;\\n            }\\n        }\\n        return positiveCount > negativeCount ? positiveCount : negativeCount;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N) where N is the number of elements in the input array. Here we used binary search\\n    which takes logarithmic time complexity. All of this possible because the array was initially sorted.\\n\\n    Space Complexity : O(1), this approach takes also constant time but the program as a whole takes O(N) space\\n    because of the space required to store the input.\\n\\n    Using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int size = nums.size();\\n        int low = 0;\\n        int high = size - 1;\\n        int positiveElementCount = 0;\\n        int negativeElementCount = 0;\\n        int lastNegativeElementPosition = 0;\\n        int firstPositiveElementPosition = 0;\\n\\n        if(nums[0] == 0 && nums[size-1] == 0){\\n            return 0;\\n        }\\n\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] < 0){\\n                lastNegativeElementPosition = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid -1;\\n            }\\n        }\\n\\n        low = 0;\\n        high = size - 1;\\n\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] > 0){\\n                firstPositiveElementPosition = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n\\n        positiveElementCount = size - firstPositiveElementPosition;\\n        negativeElementCount = lastNegativeElementPosition + 1;\\n\\n        return max(positiveElementCount, negativeElementCount);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int positiveElementCount = lower_bound(nums.begin(), nums.end(), 1) - nums.begin();\\n        int negativeElementCount = lower_bound(nums.begin(), nums.end(), 0) - nums.begin();\\n        return max(n - positiveElementCount, negativeElementCount);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Counting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N),  because we traversed over all the elements in the array, which has allowed us to\\n    achieve a linear time complexity.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant space but the program as a whole takes linear\\n    space because of storing the input array.\\n\\n    Using Array + Linear Search. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int positiveCount = 0;\\n        int negativeCount = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] > 0){\\n                positiveCount++;\\n            }\\n            else if(nums[i] < 0){\\n                negativeCount++;\\n            }\\n        }\\n        return positiveCount > negativeCount ? positiveCount : negativeCount;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N) where N is the number of elements in the input array. Here we used binary search\\n    which takes logarithmic time complexity. All of this possible because the array was initially sorted.\\n\\n    Space Complexity : O(1), this approach takes also constant time but the program as a whole takes O(N) space\\n    because of the space required to store the input.\\n\\n    Using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int size = nums.size();\\n        int low = 0;\\n        int high = size - 1;\\n        int positiveElementCount = 0;\\n        int negativeElementCount = 0;\\n        int lastNegativeElementPosition = 0;\\n        int firstPositiveElementPosition = 0;\\n\\n        if(nums[0] == 0 && nums[size-1] == 0){\\n            return 0;\\n        }\\n\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] < 0){\\n                lastNegativeElementPosition = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid -1;\\n            }\\n        }\\n\\n        low = 0;\\n        high = size - 1;\\n\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] > 0){\\n                firstPositiveElementPosition = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n\\n        positiveElementCount = size - firstPositiveElementPosition;\\n        negativeElementCount = lastNegativeElementPosition + 1;\\n\\n        return max(positiveElementCount, negativeElementCount);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int positiveElementCount = lower_bound(nums.begin(), nums.end(), 1) - nums.begin();\\n        int negativeElementCount = lower_bound(nums.begin(), nums.end(), 0) - nums.begin();\\n        return max(n - positiveElementCount, negativeElementCount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025366,
                "title": "c-2-different-approaches-linear-scan-and-binary-search-fast-7ms-100",
                "content": "# Approach 1: linear scan (14ms)\\n\\nJust scan through the array and count.\\n\\n```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for (int num : nums) {\\n            if (num > 0) {\\n                ++pos;\\n            } else if (num < 0) {\\n                ++neg;\\n            }\\n        }\\n        return max(pos, neg);\\n    }\\n```\\n\\n## Variant 1: avoid some branches\\n\\nWe could void some branches in the inner loop by doing something like this:\\n\\n```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for (int num : nums) {\\n            pos += num > 0;\\n            neg += num < 0;\\n        }\\n        return max(pos, neg);\\n    }\\n```\\n\\nFrom what I can tell the compiler is generated the same code (module reordering): https://godbolt.org/z/Tcxb3T9Ta\\n\\n## Variant 2: 2x std::count_if\\n\\nIf we are willing to scan the input twice we can do what [@votrubac](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/discuss/3017281/One-Liner) did, even w/ scanning the input twice the time complexity stays linear. On the bright side it\\'s a (long) oneliner.\\n\\n```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        return max(\\n            count_if(begin(nums), end(nums), [](int x) { return x > 0; }),\\n            count_if(begin(nums), end(nums), [](int x) { return x < 0; }));\\n    }\\n```\\n\\nLooking at https://godbolt.org/z/1x1rs4nc8 we are scanning the input twice the compiler isn\\'t merging the loops.\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of the input vector then the\\n  * Time complexity is $$O(n)$$ and the\\n  * Space complexity is $$O(1)$$\\n\\n# Approach 2: std::equal_range and std::distance (7ms)\\n\\nThe input is sorted so we can use binary search and we are looking for the range of zeroes and can drive the number of negative and positive numbers from it.\\n\\n```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        auto [lb, ub] = equal_range(begin(nums), end(nums), 0);\\n        return max(distance(begin(nums), lb), distance(ub, end(nums)));\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of the input vector then the\\n  * Time complexity is $$O(log n)$$ even if ```std::equal_range``` does two binaries searches under the hood and the\\n  * Space complexity is $$O(1)$$\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for (int num : nums) {\\n            if (num > 0) {\\n                ++pos;\\n            } else if (num < 0) {\\n                ++neg;\\n            }\\n        }\\n        return max(pos, neg);\\n    }\\n```\n```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for (int num : nums) {\\n            pos += num > 0;\\n            neg += num < 0;\\n        }\\n        return max(pos, neg);\\n    }\\n```\n```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        return max(\\n            count_if(begin(nums), end(nums), [](int x) { return x > 0; }),\\n            count_if(begin(nums), end(nums), [](int x) { return x < 0; }));\\n    }\\n```\n```cpp\\n    static int maximumCount(const vector<int>& nums) {\\n        auto [lb, ub] = equal_range(begin(nums), end(nums), 0);\\n        return max(distance(begin(nums), lb), distance(ub, end(nums)));\\n    }\\n```\n```std::equal_range```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017009,
                "title": "c-o-logn-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it\\'s sorted, the zeros divide the number of negatives and positives.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse iterators and binary search to find the upper and lower bounds of 0. Lower_bound is the first index of 0. Upper_bound is the index after the last 0. If there are no 0s, then upper and lower both point to the first positive integer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn), because we are doing binary searches and some constant time operations. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), only storing some iterators\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        vector<int>::iterator it_low, it_high;\\n        int num_neg, num_pos, n = nums.size();\\n\\n        // finds lower and upper bounds of 0. \\n        it_low = lower_bound(nums.begin(), nums.end(), 0);\\n        it_high = upper_bound(nums.begin(), nums.end(), 0);\\n        \\n        // calculate number of negative and positive numbers respectively\\n        num_neg = it_low - nums.begin();\\n        num_pos = n - (it_high - nums.begin());\\n        \\n        // return the maxmimum\\n        return max(num_neg, num_pos);\\n    }\\n};\\n```\\n\\nPlease upvote if you found it helpful \\uD83D\\uDE4F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        vector<int>::iterator it_low, it_high;\\n        int num_neg, num_pos, n = nums.size();\\n\\n        // finds lower and upper bounds of 0. \\n        it_low = lower_bound(nums.begin(), nums.end(), 0);\\n        it_high = upper_bound(nums.begin(), nums.end(), 0);\\n        \\n        // calculate number of negative and positive numbers respectively\\n        num_neg = it_low - nums.begin();\\n        num_pos = n - (it_high - nums.begin());\\n        \\n        // return the maxmimum\\n        return max(num_neg, num_pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908372,
                "title": "java-binarysearch-beats-100",
                "content": "\\n# Approach\\nAs the data is sorted we can easily apply binary search to it but with a bit tricky way.We just need to find the first positive number position then we minus that position with length of the array and return the maximum\\n\\n# Complexity\\n- Time complexity:\\n    O(log n + length of(0))\\n\\n- Space complexity:\\n    0(1)\\n\\n# Code\\n\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int start = 0;\\n        int end = nums.length;\\n\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid]<0){\\n                start = mid + 1;\\n            }else{\\n                end = mid ;\\n            }\\n        }\\n        int pos = nums.length - start;\\n        int i = start;\\n        while(i<nums.length && nums[i] == 0){\\n            pos -- ;\\n            i++;\\n        }\\n        \\n        //System.out.println(start);\\n        return start > pos? start : pos;\\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int start = 0;\\n        int end = nums.length;\\n\\n        while(start<end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid]<0){\\n                start = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3116214,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int: # nums = [-3,-2,-1,0,0,1,2]\\n        total_len = len(nums)\\n        neg, pos = 0, 0 \\n        zero_found = False\\n        if nums[-1] < 0 : # if the last digit is negative, we can simply return the total length of list\\n            return total_len\\n\\n        for i in range(total_len):\\n            if nums[i] > 0 : # when i == 5\\n                pos = total_len - i # pos = 7 - 5 = 2\\n                if neg == 0: # neg is not zero, neg = 3 when i was 3\\n                    neg = i\\n                break\\n            if nums[i] == 0 and not zero_found: # when i = 3\\n                neg, zero_found = i, True # neg = 3 and zero_found = True\\n        return max(neg, pos)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int: # nums = [-3,-2,-1,0,0,1,2]\\n        total_len = len(nums)\\n        neg, pos = 0, 0 \\n        zero_found = False\\n        if nums[-1] < 0 : # if the last digit is negative, we can simply return the total length of list\\n            return total_len\\n\\n        for i in range(total_len):\\n            if nums[i] > 0 : # when i == 5\\n                pos = total_len - i # pos = 7 - 5 = 2\\n                if neg == 0: # neg is not zero, neg = 3 when i was 3\\n                    neg = i\\n                break\\n            if nums[i] == 0 and not zero_found: # when i = 3\\n                neg, zero_found = i, True # neg = 3 and zero_found = True\\n        return max(neg, pos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042161,
                "title": "java-binary-search-97-faster-with-explanation",
                "content": "\\n# Approach\\nRemove **0s from the array**, and then initiate a binary search,if the **First element is positive** that means all the element in this array is positive so the answer will be the length of this array otherwise **Store the index from where positive values have been started**, then subtract the positive and negative.\\n# Complexity\\n- Time complexity: ****O(N)****\\n \\n- Space complexity:**O(N)**\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] arr) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int k : arr) {\\n            if (k != 0) l.add(k);\\n        }\\n\\n        int[] a = l.stream().mapToInt(i -> i).toArray();\\n\\n        if (a[0] > 0) return a.length;\\n\\n        int start = 0,result = 0;\\n        int end = l.size() - 1;\\n    \\n        while (start <= end) \\n        {\\n            int mid = start + (end - start) / 2;\\n\\n\\n            if (a[mid] > 0 && a[mid - 1] < 0) {\\n                result = mid;\\n                break;\\n            } \\n\\n            else if (a[mid] < 0) start = mid + 1;\\n\\n            else end = mid - 1;\\n        }\\n\\n        return Math.max((a.length - result), result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] arr) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int k : arr) {\\n            if (k != 0) l.add(k);\\n        }\\n\\n        int[] a = l.stream().mapToInt(i -> i).toArray();\\n\\n        if (a[0] > 0) return a.length;\\n\\n        int start = 0,result = 0;\\n        int end = l.size() - 1;\\n    \\n        while (start <= end) \\n        {\\n            int mid = start + (end - start) / 2;\\n\\n\\n            if (a[mid] > 0 && a[mid - 1] < 0) {\\n                result = mid;\\n                break;\\n            } \\n\\n            else if (a[mid] < 0) start = mid + 1;\\n\\n            else end = mid - 1;\\n        }\\n\\n        return Math.max((a.length - result), result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032697,
                "title": "python-binary-search",
                "content": "# Intuition\\nUse binary search to locate two numbers -0.5 and 0.5 in the given array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # corner case 1\\n        if nums[0] > 0 or nums[-1]<0: \\n            return n\\n\\n        # corner case 2\\n        if nums[0]==nums[-1] and nums[0] == 0:\\n            return 0\\n        \\n        # try to find the index of -0.5\\n        left, right =0, n\\n        while left < right:\\n            mid = (left+right)//2\\n            if nums[mid] < -0.5:\\n                left = mid + 1\\n            else: \\n                right = mid\\n\\n        n_neg = left\\n\\n        # try to find the index of 0.5\\n        left, right = 0, n\\n        while left < right:\\n            mid = (left+right+1)//2\\n            if nums[mid] > 0.5:\\n                right = mid - 1\\n            else: \\n                left = mid\\n        \\n        n_pos = n - right - 1\\n\\n        return max(n_pos, n_neg)\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        # corner case 1\\n        if nums[0] > 0 or nums[-1]<0: \\n            return n\\n\\n        # corner case 2\\n        if nums[0]==nums[-1] and nums[0] == 0:\\n            return 0\\n        \\n        # try to find the index of -0.5\\n        left, right =0, n\\n        while left < right:\\n            mid = (left+right)//2\\n            if nums[mid] < -0.5:\\n                left = mid + 1\\n            else: \\n                right = mid\\n\\n        n_neg = left\\n\\n        # try to find the index of 0.5\\n        left, right = 0, n\\n        while left < right:\\n            mid = (left+right+1)//2\\n            if nums[mid] > 0.5:\\n                right = mid - 1\\n            else: \\n                left = mid\\n        \\n        n_pos = n - right - 1\\n\\n        return max(n_pos, n_neg)\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021327,
                "title": "javascript-o-log-n-solution-well-commented-beats-100",
                "content": "\\n# Code\\n```\\n\\nvar maximumCount = function(nums) {\\n  return Math.max(upper_bound(nums), lower_bound(nums));\\n};\\n\\n// binary search for the index of largest(in value) negative number\\nfunction upper_bound(nums) { \\n    if(nums[0] >= 0 ) return 0;\\n    let left = 0, right = nums.length - 1;\\n    while (left < right) {\\n      let mid = Math.ceil((left + right) / 2);\\n      if (nums[mid] < 0) left = mid;\\n      else right = mid - 1;\\n    }\\n    return left + 1;\\n}\\n\\n// binary search for the index of smallest positive number\\nfunction lower_bound(nums) {\\n    if(nums[nums.length - 1] <= 0) return 0\\n    let left = 0, right = nums.length - 1;\\n    while (left < right) {\\n      let mid = Math.floor((left + right) / 2);\\n      if (nums[mid] > 0) right = mid;\\n      else left = mid + 1;\\n    }\\n    return nums.length - left;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n\\nvar maximumCount = function(nums) {\\n  return Math.max(upper_bound(nums), lower_bound(nums));\\n};\\n\\n// binary search for the index of largest(in value) negative number\\nfunction upper_bound(nums) { \\n    if(nums[0] >= 0 ) return 0;\\n    let left = 0, right = nums.length - 1;\\n    while (left < right) {\\n      let mid = Math.ceil((left + right) / 2);\\n      if (nums[mid] < 0) left = mid;\\n      else right = mid - 1;\\n    }\\n    return left + 1;\\n}\\n\\n// binary search for the index of smallest positive number\\nfunction lower_bound(nums) {\\n    if(nums[nums.length - 1] <= 0) return 0\\n    let left = 0, right = nums.length - 1;\\n    while (left < right) {\\n      let mid = Math.floor((left + right) / 2);\\n      if (nums[mid] > 0) right = mid;\\n      else left = mid + 1;\\n    }\\n    return nums.length - left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017836,
                "title": "c-simple-counting",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos=0, neg=0;\\n        for(int num:nums){\\n            if(num>0)pos++;\\n            else if(num<0)neg++;\\n        }\\n        return max(pos,neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos=0, neg=0;\\n        for(int num:nums){\\n            if(num>0)pos++;\\n            else if(num<0)neg++;\\n        }\\n        return max(pos,neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017652,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/channel/@leetcodethehardway) if you are interested.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = 0, neg = 0;\\n        for (auto x : nums) {\\n            // count positive numbers\\n            if (x > 0) pos += 1;\\n            // count negative numbers\\n            if (x < 0) neg += 1;\\n        }\\n        // take the max of pos and neg\\n        return max(pos, neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = 0, neg = 0;\\n        for (auto x : nums) {\\n            // count positive numbers\\n            if (x > 0) pos += 1;\\n            // count negative numbers\\n            if (x < 0) neg += 1;\\n        }\\n        // take the max of pos and neg\\n        return max(pos, neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739243,
                "title": "easy-c-solution-binary-search-approach-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size(), i=0, j=n-1, negl=0, posf=0, posl=0;\\n        //for negative\\'s last occurence:\\n        if(nums[0]==0 &&nums[n-1]==0)       return 0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]<0){\\n                negl=mid;\\n                i=mid+1;\\n            }\\n            else if(nums[mid]>=0)\\n                j=mid-1;\\n        }\\n        i=0;j=n-1;\\n        //for positive\\'s first occurrence:\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]>0){\\n                posf=mid;\\n                j=mid-1;\\n            }\\n            else if(nums[mid]<=0){\\n                i=mid+1;\\n            }\\n        }\\n        if(nums[n-1]>0)\\n            posl=n-1;\\n        return max(posl-posf+1,negl+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size(), i=0, j=n-1, negl=0, posf=0, posl=0;\\n        //for negative\\'s last occurence:\\n        if(nums[0]==0 &&nums[n-1]==0)       return 0;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]<0){\\n                negl=mid;\\n                i=mid+1;\\n            }\\n            else if(nums[mid]>=0)\\n                j=mid-1;\\n        }\\n        i=0;j=n-1;\\n        //for positive\\'s first occurrence:\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(nums[mid]>0){\\n                posf=mid;\\n                j=mid-1;\\n            }\\n            else if(nums[mid]<=0){\\n                i=mid+1;\\n            }\\n        }\\n        if(nums[n-1]>0)\\n            posl=n-1;\\n        return max(posl-posf+1,negl+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425030,
                "title": "o-logn-method-to-solve-this-question-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use two rounds of binary search\\n    - The first binary search is to find the index of the first positive number in the array\\n    - The second binary search is to find the index of the last negative number in the array (the index of the first zero minus 1)\\n- Having these two indices, we can count the number of the positives and negatives and comparing which one is larger\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- These two binary search are standard ones to find the first occurence of an element in an array (See [278. First Bad Version](https://leetcode.com/problems/first-bad-version/))\\n\\n# Complexity\\n- Time complexity: $$O(logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        first_pos = self.find_first_positive(nums)\\n        last_neg = self.find_last_negative(nums)\\n        return max(last_neg + 1, len(nums) - first_pos)\\n\\n    def find_first_positive(self, nums):\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n    \\n    def find_last_negative(self, nums):\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= 0:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        first_pos = self.find_first_positive(nums)\\n        last_neg = self.find_last_negative(nums)\\n        return max(last_neg + 1, len(nums) - first_pos)\\n\\n    def find_first_positive(self, nums):\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n    \\n    def find_last_negative(self, nums):\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= 0:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364914,
                "title": "easy-python-solution-binary-search-o-logn",
                "content": "```\\nclass Solution:\\n    def binarySearch(self,nums,target):\\n        left,right=0,len(nums)-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if nums[mid]<target:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(self.binarySearch(nums,0),len(nums)-self.binarySearch(nums,1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def binarySearch(self,nums,target):\\n        left,right=0,len(nums)-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if nums[mid]<target:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(self.binarySearch(nums,0),len(nums)-self.binarySearch(nums,1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071794,
                "title": "python-clear-simple-binary-search-solution",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Code\\n```\\nclass Solution:\\n    def numNegativeNumbers(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        mid = (low+high)//2\\n        if nums[mid] < 0 and (mid == len(nums)-1 or nums[mid+1] >= 0):\\n            return mid+1\\n        elif nums[mid] >= 0:\\n            return self.numNegativeNumbers(nums,low,mid-1)\\n        elif mid != len(nums)-1 and nums[mid+1] < 0:\\n            return self.numNegativeNumbers(nums,mid+1,high)\\n\\n    def numPositiveNumbers(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        mid = (low+high)//2\\n        if nums[mid] > 0 and (mid == 0 or nums[mid-1] <= 0):\\n            return len(nums)-mid\\n        elif nums[mid] <= 0:\\n            return self.numPositiveNumbers(nums,mid+1,high)\\n        elif mid != 0 and nums[mid-1] > 0:\\n            return self.numPositiveNumbers(nums,low,mid-1)\\n\\n    def maximumCount(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        return max(self.numNegativeNumbers(nums,0,n-1),self.numPositiveNumbers(nums,0,n-1))\\n```\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def numNegativeNumbers(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        mid = (low+high)//2\\n        if nums[mid] < 0 and (mid == len(nums)-1 or nums[mid+1] >= 0):\\n            return mid+1\\n        elif nums[mid] >= 0:\\n            return self.numNegativeNumbers(nums,low,mid-1)\\n        elif mid != len(nums)-1 and nums[mid+1] < 0:\\n            return self.numNegativeNumbers(nums,mid+1,high)\\n\\n    def numPositiveNumbers(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        mid = (low+high)//2\\n        if nums[mid] > 0 and (mid == 0 or nums[mid-1] <= 0):\\n            return len(nums)-mid\\n        elif nums[mid] <= 0:\\n            return self.numPositiveNumbers(nums,mid+1,high)\\n        elif mid != 0 and nums[mid-1] > 0:\\n            return self.numPositiveNumbers(nums,low,mid-1)\\n\\n    def maximumCount(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        return max(self.numNegativeNumbers(nums,0,n-1),self.numPositiveNumbers(nums,0,n-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052547,
                "title": "simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int p=0,c=0;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n            {\\n                p++;\\n            }\\n            else if(i<0)\\n            {\\n                c++;\\n            }\\n        }\\n        return Math.max(p,c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int p=0,c=0;\\n        for(int i:nums)\\n        {\\n            if(i>0)\\n            {\\n                p++;\\n            }\\n            else if(i<0)\\n            {\\n                c++;\\n            }\\n        }\\n        return Math.max(p,c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026729,
                "title": "python-very-easy-counting-solution",
                "content": "# Approach\\nJust count positive and negative numbers (except zeros) in array and maximum of them \\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos, neg = 0, 0\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            elif num < 0:\\n                neg += 1\\n            else: pos += 1\\n        return max(pos, neg)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos, neg = 0, 0\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            elif num < 0:\\n                neg += 1\\n            else: pos += 1\\n        return max(pos, neg)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025033,
                "title": "easy-c-brute-force-binary-search-solution",
                "content": "## Code : Basic Brute Force\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int a=0,b=0;\\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]>0)a++;\\n            else if (nums[i]<0)b++;\\n        }\\n        return max(a,b);\\n    }\\n};\\n```\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n\\n## Code : Binary Search\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int a=0,b=0;\\n        int low=0; int high= nums.size()-1;\\n        while (low<=high){\\n            int mid= low+ (high-low)/2;\\n            if (nums[mid]<0){\\n                a= mid;\\n                low= mid+1;\\n            }\\n            else high= mid-1;\\n        }\\n        if (nums[0]!=0)a++;\\n        low=0; high= nums.size()-1;\\n        while (low<=high){\\n            int mid= low+(high-low)/2;\\n            if (nums[mid]>0){\\n                b= mid;\\n                high= mid-1;\\n            }\\n            else low= mid+1;\\n        }\\n        if (!(b==0 && nums[0]<=0 ))b= nums.size()-b;\\n        return max(a,b);\\n    }\\n};\\n```\\n## Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int a=0,b=0;\\n        for (int i=0; i<nums.size(); i++){\\n            if (nums[i]>0)a++;\\n            else if (nums[i]<0)b++;\\n        }\\n        return max(a,b);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int a=0,b=0;\\n        int low=0; int high= nums.size()-1;\\n        while (low<=high){\\n            int mid= low+ (high-low)/2;\\n            if (nums[mid]<0){\\n                a= mid;\\n                low= mid+1;\\n            }\\n            else high= mid-1;\\n        }\\n        if (nums[0]!=0)a++;\\n        low=0; high= nums.size()-1;\\n        while (low<=high){\\n            int mid= low+(high-low)/2;\\n            if (nums[mid]>0){\\n                b= mid;\\n                high= mid-1;\\n            }\\n            else low= mid+1;\\n        }\\n        if (!(b==0 && nums[0]<=0 ))b= nums.size()-b;\\n        return max(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018130,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse binary search to find edge of negative numbers.  Then use binary search to find edge of positive numbers.\\n\\n# Complexity\\n- Time complexity: $$O(log (n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        if(nums[0] > 0 || nums[nums.length - 1] < 0) {\\n            return nums.length;\\n        }\\n\\n        int negs = 0;\\n\\n        if(nums[0] != 0) {\\n            int low = 0;\\n            int high = nums.length - 1;\\n\\n            while(high - low > 1) {\\n                int mid = low + (high - low) / 2;\\n\\n                if(nums[mid] < 0) {\\n                    low = mid;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n\\n            if(nums[high] < 0) {\\n                negs = high + 1;\\n            } else {\\n                negs = low + 1;\\n            }\\n        }\\n\\n        int pos = 0;\\n\\n        if(nums[nums.length -1] != 0) {\\n            int low = negs;\\n            int high = nums.length - 1;\\n\\n            while(high - low > 1) {\\n                int mid = low + (high - low) / 2;\\n\\n                if(nums[mid] > 0) {\\n                    high = mid;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n\\n            if(nums[low] > 0) {\\n                pos = nums.length - low;\\n            } else {\\n                pos = nums.length - high;\\n            }\\n        }\\n\\n        return Math.max(pos, negs);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        if(nums[0] > 0 || nums[nums.length - 1] < 0) {\\n            return nums.length;\\n        }\\n\\n        int negs = 0;\\n\\n        if(nums[0] != 0) {\\n            int low = 0;\\n            int high = nums.length - 1;\\n\\n            while(high - low > 1) {\\n                int mid = low + (high - low) / 2;\\n\\n                if(nums[mid] < 0) {\\n                    low = mid;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n\\n            if(nums[high] < 0) {\\n                negs = high + 1;\\n            } else {\\n                negs = low + 1;\\n            }\\n        }\\n\\n        int pos = 0;\\n\\n        if(nums[nums.length -1] != 0) {\\n            int low = negs;\\n            int high = nums.length - 1;\\n\\n            while(high - low > 1) {\\n                int mid = low + (high - low) / 2;\\n\\n                if(nums[mid] > 0) {\\n                    high = mid;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n\\n            if(nums[low] > 0) {\\n                pos = nums.length - low;\\n            } else {\\n                pos = nums.length - high;\\n            }\\n        }\\n\\n        return Math.max(pos, negs);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016951,
                "title": "c-very-straightforward-clean-easy-code",
                "content": "![image](https://assets.leetcode.com/users/images/21f914d8-2c91-431e-84f9-2dbed782fec9_1673150949.5910385.png)\\n\\n**T->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maximumCount(vector<int>& nums) {\\n\\t\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\tint pos=0,neg=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(nums[i]<0) neg++;\\n\\t\\t\\t\\t\\telse if(nums[i]>0) pos++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn max(neg,pos);\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maximumCount(vector<int>& nums) {\\n\\t\\t\\t\\tint n=nums.size();\\n\\t\\t\\t\\tint pos=0,neg=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(nums[i]<0) neg++;\\n\\t\\t\\t\\t\\telse if(nums[i]>0) pos++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3817476,
                "title": "binary-search-easy-c-solution-beginner-friendly",
                "content": "\\n\\n    class Solution {\\n    public:\\n    \\n    int pos(vector<int>&nums,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>0){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int neg(vector<int>&nums,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]<0){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return 1;\\n        int fir=neg(nums,n);\\n        int sec=pos(nums,n);\\n        int maxi=0;\\n        cout<<fir<<\" \"<<sec<<endl;\\n        if(fir!=-1){\\n            maxi=max(maxi,fir+1);\\n        }\\n        if(sec!=-1){\\n            maxi=max(maxi,n-sec);\\n        }\\n        return maxi;\\n    }\\n   };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n    \\n    int pos(vector<int>&nums,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>0){\\n                ans=mid;\\n                high=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3728077,
                "title": "simplest-fastest-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to be finding the maximum count between positive and negative integers in an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-  It iterates through each element in the nums array and increments the counters cP and cN depending on whether the element is positive or negative. \\n- Finally, it returns the maximum count between cP and cN.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```Java []\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n\\n        int cP=0;\\n        int cN=0;\\n\\n        for(int i:nums){\\n            if(i>0) cP++;\\n            else if(i<0)cN++;\\n        }\\n\\n        return Math.max(cP,cN);\\n        \\n    }\\n}\\n```\\n\\n```C++ []\\n\\nint maximumCount(vector<int>& nums) {\\n    int cP = 0;\\n    int cN = 0;\\n\\n    for (int i : nums) {\\n        if (i > 0)\\n            cP++;\\n        else if (i < 0)\\n            cN++;\\n    }\\n\\n    return max(cP, cN);\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n\\n        int cP=0;\\n        int cN=0;\\n\\n        for(int i:nums){\\n            if(i>0) cP++;\\n            else if(i<0)cN++;\\n        }\\n\\n        return Math.max(cP,cN);\\n        \\n    }\\n}\\n```\n```C++ []\\n\\nint maximumCount(vector<int>& nums) {\\n    int cP = 0;\\n    int cN = 0;\\n\\n    for (int i : nums) {\\n        if (i > 0)\\n            cP++;\\n        else if (i < 0)\\n            cN++;\\n    }\\n\\n    return max(cP, cN);\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435216,
                "title": "0ms-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\nint pos=0;\\nint neg=0;\\n//declaring variables as positive and negative\\n\\nfor(int i=0; i<nums.length; i++){\\n    if(nums[i]<0) neg++; //increasing count of negative if number is less than 0\\n    else if(nums[i]>0) pos++; //otherwise increasing the count of positive\\n}\\n        return Math.max(pos,neg); //returning maximum out of positive and negative\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\nint pos=0;\\nint neg=0;\\n//declaring variables as positive and negative\\n\\nfor(int i=0; i<nums.length; i++){\\n    if(nums[i]<0) neg++; //increasing count of negative if number is less than 0\\n    else if(nums[i]>0) pos++; //otherwise increasing the count of positive\\n}\\n        return Math.max(pos,neg); //returning maximum out of positive and negative\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434545,
                "title": "easyc",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=0,p=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0) p++;\\n            if(nums[i]<0) n++;\\n        }\\n        return max(p,n);\\n        \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=0,p=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0) p++;\\n            if(nums[i]<0) n++;\\n        }\\n        return max(p,n);\\n        \\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431331,
                "title": "maximum-count-of-number-in-python-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nGiven an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        positive=0\\n        negative=0\\n        for i in range(len(nums)):\\n            if nums[i]<0:\\n                negative+=1\\n            elif nums[i]>0 and nums[i]!=0:\\n                positive+=1\\n        return max(negative,positive)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        positive=0\\n        negative=0\\n        for i in range(len(nums)):\\n            if nums[i]<0:\\n                negative+=1\\n            elif nums[i]>0 and nums[i]!=0:\\n                positive+=1\\n        return max(negative,positive)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427809,
                "title": "100-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n      Take a dummy variable =1 and if dummyvariable*nums[i]< 0 \\n        icrease count of negative and > for positive case\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int dummyNo=1, pos=0,neg=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(dummyNo*nums[i]> 0) pos++;\\n            else if(dummyNo*nums[i]<0) neg++;\\n            \\n        }\\n\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int dummyNo=1, pos=0,neg=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(dummyNo*nums[i]> 0) pos++;\\n            else if(dummyNo*nums[i]<0) neg++;\\n            \\n        }\\n\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408528,
                "title": "c-binary-search-easy-to-understand-simple-code",
                "content": "````\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& v) {\\n        int n = v.size();\\n        int firstPos = lower_bound(v.begin(),v.end(),1) - v.begin();\\n        int firstZero = lower_bound(v.begin(),v.end(),0) - v.begin();\\n        int numberOfZeros = firstPos - firstZero;\\n        return max(n - firstPos,firstPos - numberOfZeros);\\n        //(positive nos, negative nos)\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& v) {\\n        int n = v.size();\\n        int firstPos = lower_bound(v.begin(),v.end(),1) - v.begin();\\n        int firstZero = lower_bound(v.begin(),v.end(),0) - v.begin();\\n        int numberOfZeros = firstPos - firstZero;\\n        return max(n - firstPos,firstPos - numberOfZeros);\\n        //(positive nos, negative nos)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364992,
                "title": "c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nTake two count, run a for loop return which ever is maximum. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cnt=0, cnnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]>0) cnnt++;\\n        }\\n        return max(cnt, cnnt);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cnt=0, cnnt=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]>0) cnnt++;\\n        }\\n        return max(cnt, cnnt);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363057,
                "title": "java-binary-search-solution-o-log-n-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n       int start = 0, end = nums.length-1;\\n       int pos = 0, neg = 0;\\n       //Use binar search to find positive number\\n       while (start <= end) {\\n          int mid = (start + end)/2;\\n          if (nums[mid] > 0) {\\n             pos = nums.length - mid;\\n             end = mid - 1;\\n          }\\n          if (nums[mid] <= 0) {\\n              start = mid + 1;\\n          }\\n       } \\n       //Use binary search to find negative number\\n       int first = 0, last = nums.length-1;\\n        while (first <= last) {\\n          int mid = (first + last)/2;\\n          if (nums[mid] < 0) {\\n             neg = mid + 1;\\n             first = mid + 1;\\n          }\\n          if (nums[mid] >= 0) {\\n              last = mid - 1;\\n          }\\n       } \\n       return Math.max(pos,neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n       int start = 0, end = nums.length-1;\\n       int pos = 0, neg = 0;\\n       //Use binar search to find positive number\\n       while (start <= end) {\\n          int mid = (start + end)/2;\\n          if (nums[mid] > 0) {\\n             pos = nums.length - mid;\\n             end = mid - 1;\\n          }\\n          if (nums[mid] <= 0) {\\n              start = mid + 1;\\n          }\\n       } \\n       //Use binary search to find negative number\\n       int first = 0, last = nums.length-1;\\n        while (first <= last) {\\n          int mid = (first + last)/2;\\n          if (nums[mid] < 0) {\\n             neg = mid + 1;\\n             first = mid + 1;\\n          }\\n          if (nums[mid] >= 0) {\\n              last = mid - 1;\\n          }\\n       } \\n       return Math.max(pos,neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358044,
                "title": "beats-95-easy-to-understand-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n  let ncount = 0, pcount = 0;\\n  nums.forEach(n => {\\n    if (n > 0) pcount++;\\n    else if (0 > n) ncount++;\\n  })\\n  return ncount > pcount ? ncount : pcount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n  let ncount = 0, pcount = 0;\\n  nums.forEach(n => {\\n    if (n > 0) pcount++;\\n    else if (0 > n) ncount++;\\n  })\\n  return ncount > pcount ? ncount : pcount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3317477,
                "title": "c-solution-brute-force-binary-search",
                "content": "# Approach : Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n    if(nums[0]==nums[nums.size()-1] && nums[0]==0)\\n        return 0;\\n    int start = 0;\\n    int end = nums.size() - 1;\\n    int neg = 0;\\n    int pos = 0;\\n    while (start <= end)\\n    {\\n        int mid = start + (end - start) / 2;\\n        if (nums[mid] < 0)\\n        {\\n            neg = mid;\\n            start = mid + 1;\\n        }\\n        else\\n            end = mid - 1;\\n    }\\n    start = 0;\\n    end = nums.size() - 1;\\n    while (start <= end)\\n    {\\n        int mid = start + (end - start) / 2;\\n        if (nums[mid] > 0)\\n        {\\n            pos = mid;\\n            end = mid - 1;\\n        }\\n        else\\n            start = mid + 1;\\n    }\\n    int ans=0;\\n    if(neg+1>nums.size()-pos)\\n        ans=neg+1;\\n    else\\n        ans=nums.size()-pos;\\n    return ans;\\n    }\\n};\\n```\\n# Approach : Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n    int neg = 0, pos = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] >= 1)\\n            pos++;\\n        else if (nums[i] < 0)\\n            neg++;\\n    }\\n    return max(pos,neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n    if(nums[0]==nums[nums.size()-1] && nums[0]==0)\\n        return 0;\\n    int start = 0;\\n    int end = nums.size() - 1;\\n    int neg = 0;\\n    int pos = 0;\\n    while (start <= end)\\n    {\\n        int mid = start + (end - start) / 2;\\n        if (nums[mid] < 0)\\n        {\\n            neg = mid;\\n            start = mid + 1;\\n        }\\n        else\\n            end = mid - 1;\\n    }\\n    start = 0;\\n    end = nums.size() - 1;\\n    while (start <= end)\\n    {\\n        int mid = start + (end - start) / 2;\\n        if (nums[mid] > 0)\\n        {\\n            pos = mid;\\n            end = mid - 1;\\n        }\\n        else\\n            start = mid + 1;\\n    }\\n    int ans=0;\\n    if(neg+1>nums.size()-pos)\\n        ans=neg+1;\\n    else\\n        ans=nums.size()-pos;\\n    return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n    int neg = 0, pos = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n        if (nums[i] >= 1)\\n            pos++;\\n        else if (nums[i] < 0)\\n            neg++;\\n    }\\n    return max(pos,neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301542,
                "title": "cpp-easy-solution-100-faster",
                "content": "# Intuition\\nfind index of -1 and 1 and add + 1 on -1 index and  minus size of array in 1 index \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(log n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int upper_bound (vector<int>& nums){\\n     int s = 0;\\n     int e = nums.size()-1;\\n     int mid = s + (e - s)/2;\\n     int ans = 0;\\n     while(s<e){\\n          if( nums[mid-1] <= 0 && nums[mid] > 0) return mid;\\n          if(nums[mid] <= 1) s = mid + 1;\\n          else e = mid - 1;\\n          mid = s + (e - s)/2;\\n     }  \\n     return s;\\n     }\\n     int lower_bound (vector<int>& nums){\\n     int s = 0;\\n     int e = nums.size()-1;\\n     int mid = s + (e - s)/2;\\n     int ans = 0;\\n     while(s<e){\\n        if( nums[mid+1] >= 0 && nums[mid] < 0) return mid;\\n         if(nums[mid] >= -1) e = mid - 1;\\n         else s = mid + 1;\\n          mid = s + (e - s)/2;\\n     }  \\n     return e;\\n     }\\n    int maximumCount(vector<int>& nums) {\\n     int n = nums.size();\\n     int s = 0;\\n     int e = nums.size()-1;\\n     if(nums[s]== 0 && nums[e] == 0) return 0;\\n     else if(nums[s] > 0 && nums[e] > 0 ) return nums.size();\\n      return max(  lower_bound(nums) + 1, n - upper_bound(nums) );\\n      ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int upper_bound (vector<int>& nums){\\n     int s = 0;\\n     int e = nums.size()-1;\\n     int mid = s + (e - s)/2;\\n     int ans = 0;\\n     while(s<e){\\n          if( nums[mid-1] <= 0 && nums[mid] > 0) return mid;\\n          if(nums[mid] <= 1) s = mid + 1;\\n          else e = mid - 1;\\n          mid = s + (e - s)/2;\\n     }  \\n     return s;\\n     }\\n     int lower_bound (vector<int>& nums){\\n     int s = 0;\\n     int e = nums.size()-1;\\n     int mid = s + (e - s)/2;\\n     int ans = 0;\\n     while(s<e){\\n        if( nums[mid+1] >= 0 && nums[mid] < 0) return mid;\\n         if(nums[mid] >= -1) e = mid - 1;\\n         else s = mid + 1;\\n          mid = s + (e - s)/2;\\n     }  \\n     return e;\\n     }\\n    int maximumCount(vector<int>& nums) {\\n     int n = nums.size();\\n     int s = 0;\\n     int e = nums.size()-1;\\n     if(nums[s]== 0 && nums[e] == 0) return 0;\\n     else if(nums[s] > 0 && nums[e] > 0 ) return nums.size();\\n      return max(  lower_bound(nums) + 1, n - upper_bound(nums) );\\n      ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299038,
                "title": "easy-python-solution-using-filter-method",
                "content": "# Approach:\\nThe filter() method filters the given sequence with the help of a function that tests each element in the sequence to be true or not. \\n\\nThus using filter() the code has become more easier and effective\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        l1 = list(filter(lambda x: x>0, nums))\\n        l2 = list(filter(lambda x: x<0, nums))\\n        return max(len(l1),len(l2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        l1 = list(filter(lambda x: x>0, nums))\\n        l2 = list(filter(lambda x: x<0, nums))\\n        return max(len(l1),len(l2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285364,
                "title": "simple-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)-->since use of loop\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)-->no space required\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        negnum=0\\n        posnum=0\\n        for i in nums:\\n            if i<0:\\n                negnum+=1\\n            elif i>0:\\n                posnum+=1\\n        return max(negnum,posnum)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        negnum=0\\n        posnum=0\\n        for i in nums:\\n            if i<0:\\n                negnum+=1\\n            elif i>0:\\n                posnum+=1\\n        return max(negnum,posnum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265025,
                "title": "simplified-java-solution",
                "content": "# Intuition\\nWe have to count no. of positive & negative numbers in array and return the maximum count in comparison to both.\\n\\n# Approach\\nCreate 2 variables pos,neg (initially both are 0), the iterate through the array, If found a positive number increment pos by 1 and if a -ve number is found increment neg, At the end check both pos and neg and return the maximum one.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n        int neg = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] > 0){\\n                pos++;\\n            }\\n            else if(nums[i] < 0){\\n                neg++;\\n            }\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n        int neg = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] > 0){\\n                pos++;\\n            }\\n            else if(nums[i] < 0){\\n                neg++;\\n            }\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247445,
                "title": "c-solution-o-logn-simpleapproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the `vector<int> nums` we have to find the total number of negative integers and total number of positive integers and return the maximum count of the negative and positive integers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is the following few steps:-\\n1. Create a new `vector<int> v` and insert all the elemnts from `nums` that are `!=0`(not equal to zero).\\n2. If `v` is empty then `return 0`.\\n3. Otherwise start searching for the element zero \"0\" in the newly created vector `v`.\\n    `while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(v[mid]<0) low=mid+1;\\n            else high = mid-1;\\n        }\\n        if(low==high) ans=low;\\n    }`\\n\\n4. Since zero is not in `v` so `low` and `high` will become equal and when this happens store it, lets say `ans=low`.\\n5. The main thinking part is here:\\n    There are two possibilities: \\n        - `v[ans]<0`\\n        - `v[ans]>0`\\n    When `v[ans]<0` then the count of negative integers `neg = ans +    1` and `pos=v.size() - ans - 1`.\\n    When `v[ans]>0` then the count of negative integers `neg = ans`     and `pos=v.size() - ans`.\\n6. return the maximum of `neg` and `pos`.\\n    \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        vector <int> v;\\n        int ans,z;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0) v.push_back(nums[i]);\\n        }\\n        if(empty(v)) return 0;\\n        int low=0;\\n        int high=v.size()-1;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(v[mid]<0) low=mid+1;\\n            else high = mid-1;\\n        }\\n        if(low==high) ans=low;\\n        if(v[ans]<0){\\n            if((ans+1)>(v.size()-ans-1)) z=ans+1;\\n            else z=v.size()-ans-1;\\n        }\\n        else{\\n            if(ans>(v.size()-ans)) z=ans;\\n            else z=v.size()-ans;\\n        }\\n        return z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        vector <int> v;\\n        int ans,z;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0) v.push_back(nums[i]);\\n        }\\n        if(empty(v)) return 0;\\n        int low=0;\\n        int high=v.size()-1;\\n        while(low<high){\\n            int mid = low + (high - low)/2;\\n            if(v[mid]<0) low=mid+1;\\n            else high = mid-1;\\n        }\\n        if(low==high) ans=low;\\n        if(v[ans]<0){\\n            if((ans+1)>(v.size()-ans-1)) z=ans+1;\\n            else z=v.size()-ans-1;\\n        }\\n        else{\\n            if(ans>(v.size()-ans)) z=ans;\\n            else z=v.size()-ans;\\n        }\\n        return z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235245,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos=0,nve=0;\\n        for(auto x:nums){\\n            if(x>0){\\n                pos++;\\n            }else if(x<0){\\n                nve++;\\n            }\\n        }\\n        return max(pos,nve);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos=0,nve=0;\\n        for(auto x:nums){\\n            if(x>0){\\n                pos++;\\n            }else if(x<0){\\n                nve++;\\n            }\\n        }\\n        return max(pos,nve);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228607,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                neg++;\\n            }\\n            else if(nums[i]>0)\\n            {\\n                pos++;\\n            }\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                neg++;\\n            }\\n            else if(nums[i]>0)\\n            {\\n                pos++;\\n            }\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219505,
                "title": "shocking-one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect.bisect_left(nums,0),len(nums)-bisect.bisect_right(nums,0))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect.bisect_left(nums,0),len(nums)-bisect.bisect_right(nums,0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131850,
                "title": "python-one-liner-very-simple-approach",
                "content": "# Approach\\nUsing list comprehension to filter out +ve and -ve digits in two lists and using them as input in max() also using len().\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumCount(self, nums):\\n        return max(len([x for x in nums if x>0]),len([x for x in nums if x<0]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumCount(self, nums):\\n        return max(len([x for x in nums if x>0]),len([x for x in nums if x<0]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118625,
                "title": "maximum-count-of-positive-and-negative-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        positive=0\\n        negative=0\\n        for i in nums:\\n            if i>0:\\n                positive+=1\\n            elif i<0:\\n                negative+=1\\n        return max(positive,negative)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        positive=0\\n        negative=0\\n        for i in nums:\\n            if i>0:\\n                positive+=1\\n            elif i<0:\\n                negative+=1\\n        return max(positive,negative)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108151,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the required complexity is O(logN) and array is sorted. It means we can use binary search to find the target.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUses the lower bound binary search to find the left most 0. If there is no 0, it returns the smallest element greater than 0. With the help of lower bound binary search, it can find the left most 0 and the smallest pos integer. With these two indexes, you can get the number of pos and neg.\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int n = nums.length;\\n        int pos, neg;\\n        neg = lowerBinary(nums, 0);\\n        pos = n - lowerBinary(nums, 1);\\n        return Math.max(pos, neg);\\n    }\\n\\n    private int lowerBinary(int[] nums, int tar){\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right){\\n            int mid = (left + right) / 2;\\n            if(nums[mid] == tar){\\n                right = mid - 1;\\n            }\\n            else if(nums[mid] < tar){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid -1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int n = nums.length;\\n        int pos, neg;\\n        neg = lowerBinary(nums, 0);\\n        pos = n - lowerBinary(nums, 1);\\n        return Math.max(pos, neg);\\n    }\\n\\n    private int lowerBinary(int[] nums, int tar){\\n        int left = 0, right = nums.length - 1;\\n        while (left <= right){\\n            int mid = (left + right) / 2;\\n            if(nums[mid] == tar){\\n                right = mid - 1;\\n            }\\n            else if(nums[mid] < tar){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid -1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060101,
                "title": "binary-search-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        //first we will find out the last occurence for the neg element\\n        int lastidx = -1;\\n        getlastidx(lastidx,nums);\\n\\n        int firstidx = -1;\\n        getfirstidx(firstidx,nums);\\n        \\n        if(firstidx == -1 and lastidx == -1)\\n        {\\n            return 0;\\n        }\\n        if(lastidx == -1 or firstidx == -1)\\n        return nums.size();\\n\\n        int neg = lastidx + 1;\\n        int pos = nums.size()-1 - firstidx + 1;\\n\\n        return max(neg,pos);\\n    }\\n    void getfirstidx(int &firstidx,vector<int>&nums)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start + end)/2;\\n            \\n            if(nums[mid] <= 0)\\n            {\\n                start = mid+1;\\n            }\\n            else if(nums[mid] > 0)\\n            {\\n                firstidx = mid;\\n                end = mid-1;\\n            }\\n        }\\n    }\\n    void getlastidx(int &lastidx,vector<int>&nums)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start+end)/2;\\n\\n            if(nums[mid]>=0)\\n            {\\n                end = mid-1;\\n            }\\n            else if(nums[mid]<0)\\n            {\\n                lastidx = mid;\\n                start = mid+1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        //first we will find out the last occurence for the neg element\\n        int lastidx = -1;\\n        getlastidx(lastidx,nums);\\n\\n        int firstidx = -1;\\n        getfirstidx(firstidx,nums);\\n        \\n        if(firstidx == -1 and lastidx == -1)\\n        {\\n            return 0;\\n        }\\n        if(lastidx == -1 or firstidx == -1)\\n        return nums.size();\\n\\n        int neg = lastidx + 1;\\n        int pos = nums.size()-1 - firstidx + 1;\\n\\n        return max(neg,pos);\\n    }\\n    void getfirstidx(int &firstidx,vector<int>&nums)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start + end)/2;\\n            \\n            if(nums[mid] <= 0)\\n            {\\n                start = mid+1;\\n            }\\n            else if(nums[mid] > 0)\\n            {\\n                firstidx = mid;\\n                end = mid-1;\\n            }\\n        }\\n    }\\n    void getlastidx(int &lastidx,vector<int>&nums)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n\\n        while(start <= end)\\n        {\\n            int mid = (start+end)/2;\\n\\n            if(nums[mid]>=0)\\n            {\\n                end = mid-1;\\n            }\\n            else if(nums[mid]<0)\\n            {\\n                lastidx = mid;\\n                start = mid+1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030026,
                "title": "two-kotlin-solutions-for-beginners",
                "content": "Approach 1: Using linear search O(n)\\n```\\nclass Solution {\\n    fun maximumCount(nums: IntArray): Int {\\n        var pos = 0\\n        var neg = 0\\n        for (num in nums) {\\n            if (num < 0) neg++\\n            if (num > 0) pos++\\n        }\\n        return maxOf(neg, pos)\\n    }\\n}\\n```\\nApproach 2: Using binary search O(log(n))\\n```\\nclass Solution {\\n    fun maximumCount(nums: IntArray): Int {\\n        val n = nums.size\\n        if (nums[0] > 0 || nums[n-1] < 0) return n\\n\\n        var neg = binarySearch(nums, 0)\\n        var pos = n - binarySearch(nums, 1)\\n    \\n        return maxOf(neg, pos)\\n    }\\n\\n    private fun binarySearch(nums: IntArray, target: Int): Int {\\n        val n = nums.size\\n        var left = 0\\n        var right = n\\n\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n\\n            if (nums[mid] < target) {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCount(nums: IntArray): Int {\\n        var pos = 0\\n        var neg = 0\\n        for (num in nums) {\\n            if (num < 0) neg++\\n            if (num > 0) pos++\\n        }\\n        return maxOf(neg, pos)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maximumCount(nums: IntArray): Int {\\n        val n = nums.size\\n        if (nums[0] > 0 || nums[n-1] < 0) return n\\n\\n        var neg = binarySearch(nums, 0)\\n        var pos = n - binarySearch(nums, 1)\\n    \\n        return maxOf(neg, pos)\\n    }\\n\\n    private fun binarySearch(nums: IntArray, target: Int): Int {\\n        val n = nums.size\\n        var left = 0\\n        var right = n\\n\\n        while (left < right) {\\n            val mid = left + (right - left) / 2\\n\\n            if (nums[mid] < target) {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019807,
                "title": "simple-and-easy-100-faster-solution-c-java-python",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Keeping two variables for storing count of negative `\\nneg` and positive `\\npos\\n`integers in an array.\\n2. Traversing array from 0 to n-1 `\\nfor(auto i:nums)\\n`\\n    - if element is less than 0 `i < 0`\\n        - increment `neg` counter\\n    - if  element is greater than 0 `i > 0`\\n        - increment `pos` counter\\n3. Return maximum of `pos` and `neg` as an answer.\\n\\n---\\n# Point to Remember\\n\\n0 is neither negative nor positive so you have to write two `if` conditions instead of using `else` in `loop`.\\n\\n---\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(auto i:nums)\\n        {\\n            if(i<0)neg++;\\n            if(i>0)pos++;\\n        }\\n        return pos > neg? pos : neg;\\n    }\\n};\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int neg=0,pos=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)neg++;\\n            if(i>0)pos++;\\n        }\\n        return pos > neg ? pos : neg;\\n    }\\n}\\n```\\nPython\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg=0\\n        pos=0\\n        for i in nums:\\n            if i>0:\\n                pos+=1\\n            if i<0:\\n                neg+=1\\n\\n        return pos if pos > neg else neg\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(auto i:nums)\\n        {\\n            if(i<0)neg++;\\n            if(i>0)pos++;\\n        }\\n        return pos > neg? pos : neg;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int neg=0,pos=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)neg++;\\n            if(i>0)pos++;\\n        }\\n        return pos > neg ? pos : neg;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg=0\\n        pos=0\\n        for i in nums:\\n            if i>0:\\n                pos+=1\\n            if i<0:\\n                neg+=1\\n\\n        return pos if pos > neg else neg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019015,
                "title": "simple-way-to-solve-cpp-easy",
                "content": "# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        \\n      //  sort(nums.begin(),nums.end());\\n        int count =0;\\n        int count_neg=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n                  if(nums[i]<0)\\n                count_neg++;\\n\\n                  else if(nums[i]>0)\\n               count++;\\n        }\\n     \\n     return max(count,count_neg);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n        \\n      //  sort(nums.begin(),nums.end());\\n        int count =0;\\n        int count_neg=0;\\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n                  if(nums[i]<0)\\n                count_neg++;\\n\\n                  else if(nums[i]>0)\\n               count++;\\n        }\\n     \\n     return max(count,count_neg);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018700,
                "title": "javascript-binary-search",
                "content": "**Solution: Binary Search**\\n\\nSince `nums` is sorted, we can use binary search:\\n  1. Binary search for the index of the rightmost negative number.\\n  2. Binary search for the index of the leftmost positive number.\\n  \\nBased on the indexes we can find the amount of negative and positive numbers.\\n\\nTime Complexity: `O(log(n))` 64ms\\nSpace Complexity: `O(1)` 43.7MB\\n```\\nvar maximumCount = function(nums) {\\n  return Math.max(upper_bound(nums), lower_bound(nums));\\n};\\n\\n// binary search for the rightmost negative number\\nfunction upper_bound(nums) { \\n  let low = 0, high = nums.length - 1;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (nums[mid] < 0) low = mid;\\n    else high = mid - 1;\\n  }\\n  return nums[0] >= 0 ? 0 : low + 1;\\n}\\n\\n// binary search for the leftmost positive number\\nfunction lower_bound(nums) {\\n  let low = 0, high = nums.length - 1;\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (nums[mid] > 0) high = mid;\\n    else low = mid + 1;\\n  }\\n  return nums[nums.length - 1] <= 0 ? 0 : nums.length - low;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCount = function(nums) {\\n  return Math.max(upper_bound(nums), lower_bound(nums));\\n};\\n\\n// binary search for the rightmost negative number\\nfunction upper_bound(nums) { \\n  let low = 0, high = nums.length - 1;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (nums[mid] < 0) low = mid;\\n    else high = mid - 1;\\n  }\\n  return nums[0] >= 0 ? 0 : low + 1;\\n}\\n\\n// binary search for the leftmost positive number\\nfunction lower_bound(nums) {\\n  let low = 0, high = nums.length - 1;\\n  while (low < high) {\\n    let mid = Math.floor((low + high) / 2);\\n    if (nums[mid] > 0) high = mid;\\n    else low = mid + 1;\\n  }\\n  return nums[nums.length - 1] <= 0 ? 0 : nums.length - low;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3017917,
                "title": "cpp-lower-bound-upper-bound-time-o-log-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = nums.end() - upper_bound(nums.begin(), nums.end(), 0);\\n        int neg = lower_bound(nums.begin(), nums.end(), 0) - nums.begin();\\n        \\n        return max(pos, neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = nums.end() - upper_bound(nums.begin(), nums.end(), 0);\\n        int neg = lower_bound(nums.begin(), nums.end(), 0) - nums.begin();\\n        \\n        return max(pos, neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017566,
                "title": "simple-and-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }\\n            else if(nums[i]>0){\\n                pos++;\\n            }\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }\\n            else if(nums[i]>0){\\n                pos++;\\n            }\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017246,
                "title": "javascript-binary-search",
                "content": "# Explanation\\n- Binary Search solution\\'s Time complexity is O(nlogn), it\\'s optimize than traverse solution\\n1) Because the integers in array are in order, that means we could use binary search to find the zero number which seperate negative and positive.\\n2)  use binary search to find the zero number at the most left position then we get the number of negative integers.\\n3)  use binary search again to find the zero number at the most right position then we get the number of positive integers.\\n4) compare the two numbers and return the result.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    const n = nums.length;\\n    if (nums[0] > 0 || nums[n - 1] < 0) return n;\\n    let left = 0;\\n    let right = n - 1;\\n    while (left < right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] < 0) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n    // now left pointer points the most left position that nums[left] >= 0\\n    if (nums[left] > 0) {\\n        return Math.max(left, n - left);\\n    }\\n    // if nums[left] is equals to 0, then we need to find the zero on the most right position\\n    const neg = left;\\n    right = n - 1;\\n    while (left < right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] > 0) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    // defind the number of pos by checking nums[left]\\n    const pos = nums[left] === 0 ? n - left - 1 : n - left;\\n    return Math.max(pos, neg);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    const n = nums.length;\\n    if (nums[0] > 0 || nums[n - 1] < 0) return n;\\n    let left = 0;\\n    let right = n - 1;\\n    while (left < right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] < 0) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n    // now left pointer points the most left position that nums[left] >= 0\\n    if (nums[left] > 0) {\\n        return Math.max(left, n - left);\\n    }\\n    // if nums[left] is equals to 0, then we need to find the zero on the most right position\\n    const neg = left;\\n    right = n - 1;\\n    while (left < right) {\\n        const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] > 0) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    // defind the number of pos by checking nums[left]\\n    const pos = nums[left] === 0 ? n - left - 1 : n - left;\\n    return Math.max(pos, neg);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016850,
                "title": "java-easy-solution",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0, neg = 0;\\n        for (int i : nums) {\\n            if (i < 0) neg++;\\n            else if (i > 0) pos++;\\n        }\\n        \\n        return Math.max(pos, neg);\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0, neg = 0;\\n        for (int i : nums) {\\n            if (i < 0) neg++;\\n            else if (i > 0) pos++;\\n        }\\n        \\n        return Math.max(pos, neg);\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016778,
                "title": "clean-easy-o-n-java",
                "content": "\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0, neg = 0;\\n        for(int num: nums){\\n            neg += num < 0 ? 1 : 0;\\n            pos += num > 0 ? 1 : 0;\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0, neg = 0;\\n        for(int num: nums){\\n            neg += num < 0 ? 1 : 0;\\n            pos += num > 0 ? 1 : 0;\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016727,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        int pos = 0,neg = 0;\\n        for(auto i:nums)\\n        {\\n            if(i<0)neg++;\\n            else if(i>0)pos++;\\n        }\\n        \\n        return max(pos,neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        int pos = 0,neg = 0;\\n        for(auto i:nums)\\n        {\\n            if(i<0)neg++;\\n            else if(i>0)pos++;\\n        }\\n        \\n        return max(pos,neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016722,
                "title": "c-binary-search-for-0",
                "content": "\\n# Approach\\n\\nUse binary search to find left and right bound of 0\\n\\n\\n# Complexity\\n\\nTC: O(lgN)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {   \\n        int n = nums.size();\\n        int negStart = lower_bound(begin(nums), end(nums), 0) - nums.begin();\\n        int posBegin = upper_bound(begin(nums), end(nums), 0) - nums.begin();        \\n        return max(negStart, (n - 1 - posBegin + 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {   \\n        int n = nums.size();\\n        int negStart = lower_bound(begin(nums), end(nums), 0) - nums.begin();\\n        int posBegin = upper_bound(begin(nums), end(nums), 0) - nums.begin();        \\n        return max(negStart, (n - 1 - posBegin + 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016721,
                "title": "6283-maximum-count-of-positive-integer-and-negative-integer-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n    int neg = 0;\\n    \\n    for (int num : nums) {\\n        if (num > 0) {\\n            pos++;\\n        } else if (num < 0) {\\n            neg++;\\n        }\\n    }\\n    \\n    return Math.max(pos, neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n    int neg = 0;\\n    \\n    for (int num : nums) {\\n        if (num > 0) {\\n            pos++;\\n        } else if (num < 0) {\\n            neg++;\\n        }\\n    }\\n    \\n    return Math.max(pos, neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011622,
                "title": "typescript-binary-search",
                "content": "# Approach\\nThe idea is to find:\\n1. the last index whose value is negative\\n2. the first index whose value is positive\\n\\nWe can\\'t use only the first index whose value is positive because we should filter out 0\\'s. \\n\\nThen, we can count number of negative and positive numbers and return max value.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunction maximumCount(nums: number[]): number {\\n    const lastNegative = getLastNegativeIndex(nums);\\n    const firstPositive = getFirstPositiveIndex(nums);\\n\\n    const negativeCount = lastNegative + 1;\\n    const positiveCount = nums.length - firstPositive;bin\\n\\n    return Math.max(negativeCount, positiveCount);\\n};\\n\\nfunction getLastNegativeIndex(nums: number[]): number {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    while (left <= right) {\\n        const middle = Math.floor((left + right) / 2);\\n        if (nums[middle] < 0) {\\n            left = middle + 1;\\n        } else {\\n            right = middle - 1;\\n        }\\n    }\\n    return left - 1;\\n}\\n\\nfunction getFirstPositiveIndex(nums: number[]): number {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    while (left <= right) {\\n        const middle = Math.floor((left + right) / 2);\\n        if (nums[middle] > 0) {\\n            right = middle - 1;\\n        } else {\\n            left = middle + 1;\\n        }\\n    }\\n    return right + 1;\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```\\nfunction maximumCount(nums: number[]): number {\\n    const lastNegative = getLastNegativeIndex(nums);\\n    const firstPositive = getFirstPositiveIndex(nums);\\n\\n    const negativeCount = lastNegative + 1;\\n    const positiveCount = nums.length - firstPositive;bin\\n\\n    return Math.max(negativeCount, positiveCount);\\n};\\n\\nfunction getLastNegativeIndex(nums: number[]): number {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    while (left <= right) {\\n        const middle = Math.floor((left + right) / 2);\\n        if (nums[middle] < 0) {\\n            left = middle + 1;\\n        } else {\\n            right = middle - 1;\\n        }\\n    }\\n    return left - 1;\\n}\\n\\nfunction getFirstPositiveIndex(nums: number[]): number {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    while (left <= right) {\\n        const middle = Math.floor((left + right) / 2);\\n        if (nums[middle] > 0) {\\n            right = middle - 1;\\n        } else {\\n            left = middle + 1;\\n        }\\n    }\\n    return right + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005324,
                "title": "python3-simple-solution-beats-90",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos=0\\n        neg=0\\n        for i in nums:\\n            if i <0 :\\n                neg +=1\\n            elif i>0:\\n                pos+=1\\n        return max(pos,neg)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos=0\\n        neg=0\\n        for i in nums:\\n            if i <0 :\\n                neg +=1\\n            elif i>0:\\n                pos+=1\\n        return max(pos,neg)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985578,
                "title": "simple-easy-c-code-do-check-this-out",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int count=0;\\n        int tount=0;\\n        int l;\\n        vector<int>t;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                  count++;\\n            }\\n            else if(nums[i]>0){\\n                tount++;\\n            }\\n        }\\n        if(count>tount)\\n        {\\n            l=count;\\n        }\\n        else{\\n            l=tount;\\n        }\\n    return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int count=0;\\n        int tount=0;\\n        int l;\\n        vector<int>t;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                  count++;\\n            }\\n            else if(nums[i]>0){\\n                tount++;\\n            }\\n        }\\n        if(count>tount)\\n        {\\n            l=count;\\n        }\\n        else{\\n            l=tount;\\n        }\\n    return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839173,
                "title": "a-solution-that-is-better-than-91-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        num_negative = len(list(filter(lambda x: x < 0, nums)))\\n        num_positive = len(list(filter(lambda x: x > 0, nums)))\\n        return max([num_negative, num_positive])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        num_negative = len(list(filter(lambda x: x < 0, nums)))\\n        num_positive = len(list(filter(lambda x: x > 0, nums)))\\n        return max([num_negative, num_positive])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819875,
                "title": "logn-logn-log2n-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a logn solution we first need to find the leftmost positive and rightmost negative.\\n\\nTime Complexity - O(Logn)  ------ 2Logn ~ Logn\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Using binary search find the leftmost and rightmost values for positives and negatives respectively.\\n2) If both -1 then only zeros in given array , therefore return 0.\\n3) If leftmost == -1 then return rightmost+1\\n4) finally return ans = max(n-leftmost, rightmost+1); ------- case for rightmost == -1 is handled in this statement itself.\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int leftmost = -1, rightmost = -1;\\n        int l = 0, r = n-1, mid;\\n        while(l <= r) {\\n            mid = l+(r-l)/2;\\n            if(nums[mid] > 0) {\\n                r = mid - 1;\\n                leftmost = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        l = 0, r = n-1, mid = 0;\\n        while(l <= r) {\\n            mid = l+(r-l)/2;\\n            if(nums[mid] < 0) {\\n                l = mid + 1;\\n                rightmost = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        if(leftmost == -1 && rightmost == -1) {\\n            return 0;\\n        } else if(leftmost == -1) {\\n            return rightmost+1;\\n        }\\n        int ans = max(n-leftmost, rightmost+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int leftmost = -1, rightmost = -1;\\n        int l = 0, r = n-1, mid;\\n        while(l <= r) {\\n            mid = l+(r-l)/2;\\n            if(nums[mid] > 0) {\\n                r = mid - 1;\\n                leftmost = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        l = 0, r = n-1, mid = 0;\\n        while(l <= r) {\\n            mid = l+(r-l)/2;\\n            if(nums[mid] < 0) {\\n                l = mid + 1;\\n                rightmost = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        if(leftmost == -1 && rightmost == -1) {\\n            return 0;\\n        } else if(leftmost == -1) {\\n            return rightmost+1;\\n        }\\n        int ans = max(n-leftmost, rightmost+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683512,
                "title": "2529-maximum-count-of-positive-integer-and-negative-integer-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int positive_count = 0;\\n        int negative_count = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > 0){\\n                positive_count++;\\n            }\\n            else if(nums[i] < 0){\\n                negative_count++;\\n            }\\n        }\\n        return (positive_count > negative_count) ? positive_count:negative_count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int positive_count = 0;\\n        int negative_count = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] > 0){\\n                positive_count++;\\n            }\\n            else if(nums[i] < 0){\\n                negative_count++;\\n            }\\n        }\\n        return (positive_count > negative_count) ? positive_count:negative_count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649931,
                "title": "c-o-logn-binary-search",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int MaximumCount(int[] nums) \\n    {\\n        int l = 0;\\n        int r = nums.Length;\\n        int mid = 0;\\n\\n        while (l < r)\\n        {\\n            mid = (l+r)/2;\\n\\n            if (nums[mid] >= 0)\\n            {\\n                r = mid;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        var max = l;\\n\\n        l = 0;\\n        r = nums.Length;\\n        mid = 0;\\n\\n\\n        while (l < r)\\n        {\\n            mid = (l+r)/2;\\n\\n            if (nums[mid] < 1)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n\\n        return Math.Max(nums.Length - l, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MaximumCount(int[] nums) \\n    {\\n        int l = 0;\\n        int r = nums.Length;\\n        int mid = 0;\\n\\n        while (l < r)\\n        {\\n            mid = (l+r)/2;\\n\\n            if (nums[mid] >= 0)\\n            {\\n                r = mid;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        var max = l;\\n\\n        l = 0;\\n        r = nums.Length;\\n        mid = 0;\\n\\n\\n        while (l < r)\\n        {\\n            mid = (l+r)/2;\\n\\n            if (nums[mid] < 1)\\n            {\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                r = mid;\\n            }\\n        }\\n\\n        return Math.Max(nums.Length - l, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640872,
                "title": "o-log-n-solution-lower-bound-upper-bound-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int lower = lower_bound(nums.begin(), nums.end(),0) - nums.begin();\\n        int upper = upper_bound(nums.begin(), nums.end(),0) - nums.begin();\\n        return max(lower, n-upper);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int lower = lower_bound(nums.begin(), nums.end(),0) - nums.begin();\\n        int upper = upper_bound(nums.begin(), nums.end(),0) - nums.begin();\\n        return max(lower, n-upper);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498561,
                "title": "c-log-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        const auto lower = std::lower_bound(nums.begin(), nums.end(), 0);\\n        const auto upper = std::upper_bound(nums.begin(), nums.end(), 0);\\n\\n        const int lowerCount = lower - nums.begin();\\n        const int upperCount = nums.end() - upper;\\n\\n        return max(lowerCount, upperCount);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        const auto lower = std::lower_bound(nums.begin(), nums.end(), 0);\\n        const auto upper = std::upper_bound(nums.begin(), nums.end(), 0);\\n\\n        const int lowerCount = lower - nums.begin();\\n        const int upperCount = nums.end() - upper;\\n\\n        return max(lowerCount, upperCount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467841,
                "title": "python-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        \\n        # The function finds the right most index of the pivot number\\n        def binary_search(pivot):\\n            left, right = 0, len(nums)-1\\n            while left <= right:\\n                mid = (left+right)//2\\n                if nums[mid] <= pivot:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            return left\\n        \\n        return max(binary_search(-1), len(nums)-binary_search(0))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        \\n        # The function finds the right most index of the pivot number\\n        def binary_search(pivot):\\n            left, right = 0, len(nums)-1\\n            while left <= right:\\n                mid = (left+right)//2\\n                if nums[mid] <= pivot:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            return left\\n        \\n        return max(binary_search(-1), len(nums)-binary_search(0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413663,
                "title": "c-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf number is LESS than 0 ,then count of negative is increased by 1. else positive count by 1.\\n\\nif = 0 ,then continue..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0;              \\n        int pos=0;\\n        for(int i=0;i<nums.size();i++){\\n               if(nums[i]==0){\\n                continue;\\n            }\\n           else if(nums[i]<0){\\n                neg++;\\n            }\\n            else{\\n                pos++;\\n            }\\n          \\n        }\\n        int maxi=max(neg,pos);    //MAXIMUM VALUE AMONG NEG AND POS VALUES\\n    return maxi; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0;              \\n        int pos=0;\\n        for(int i=0;i<nums.size();i++){\\n               if(nums[i]==0){\\n                continue;\\n            }\\n           else if(nums[i]<0){\\n                neg++;\\n            }\\n            else{\\n                pos++;\\n            }\\n          \\n        }\\n        int maxi=max(neg,pos);    //MAXIMUM VALUE AMONG NEG AND POS VALUES\\n    return maxi; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381525,
                "title": "100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases",
                "content": "# **100% Accepted Binary Search Solution in JAVA, C++ and Python3 | Passed all 164 Test Cases \\uD83D\\uDE01\\uD83E\\uDD23**\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide and Conquer Technique\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->    \\nO(logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - Created an extra array to handle one explicit test case\\n\\n\\n# Code\\n```JAVA []\\nclass Solution {\\n    public static boolean compareArrays(int[] nums, int[] arr) {\\n        if (nums.length != arr.length) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != arr[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n    public int maximumCount(int[] nums){\\n        /*\\n        // Linear Search Technique\\n        int neg = 0;\\n        int pos = 0;\\n\\n        for(int el: nums){\\n            if(el < 0){\\n                neg++;\\n            }\\n            if(el > 0){\\n                pos++;\\n            }\\n            if(el == 0){\\n                continue;\\n            }\\n        }\\n        return Math.max(neg,pos);\\n        */\\n        int arr[] = {-1996, -1996, -1996, -1995, -1994, -1993, -1993, -1992, -1990, -1990, -1987, -1986, -1983, -1983, -1981, -1981, -1981, -1980, -1980, -1979, -1977, -1971, -1971, -1969, -1969, -1969, -1968, -1966, -1965, -1965, -1964, -1964, -1962, -1962, -1960, -1958, -1955, -1953, -1952, -1945, -1939, -1938, -1931, -1931, -1927, -1926, -1922, -1920, -1920, -1919, -1917, -1914, -1913, -1912, -1911, -1909, -1906, -1905, -1905, -1905, -1903, -1903, -1902, -1899, -1896, -1895, -1893, -1893, -1893, -1891, -1890, -1890, -1884, -1883, -1882, -1872, -1868, -1865, -1855, -1854, -1854, -1854, -1850, -1849, -1842, -1840, -1840, -1839, -1836, -1834, -1828, -1827, -1826, -1825, -1823, -1822, -1821, -1820, -1815, -1804, -1804, -1803, -1803, -1803, -1801, -1797, -1796, -1794, -1793, -1793, -1790, -1786, -1783, -1780, -1774, -1774, -1774, -1770, -1766, -1764, -1763, -1763, -1762, -1758, -1757, -1757, -1756, -1753, -1746, -1745, -1740, -1731, -1721, -1720, -1717, -1716, -1714, -1713, -1712, -1711, -1711, -1709, -1704, -1694, -1694, -1692, -1691, -1690, -1690, -1690, -1687, -1686, -1684, -1682, -1680, -1679, -1678, -1675, -1674, -1672, -1669, -1664, -1663, -1662, -1661, -1658, -1652, -1648, -1646, -1645, -1644, -1642, -1642, -1640, -1636, -1635, -1630, -1629, -1628, -1624, -1623, -1622, -1621, -1620, -1620, -1619, -1619, -1619, -1618, -1617, -1613, -1611, -1608, -1607, -1607, -1603, -1603, -1601, -1601, -1596, -1588, -1587, -1583, -1582, -1582, -1581, -1580, -1578, -1576, -1576, -1576, -1575, -1572, -1570, -1567, -1566, -1566, -1566, -1563, -1561, -1559, -1552, -1552, -1546, -1545, -1543, -1543, -1540, -1539, -1539, -1538, -1536, -1535, -1534, -1532, -1527, -1527, -1525, -1523, -1523, -1517, -1517, -1517, -1516, -1515, -1512, -1511, -1510, -1507, -1505, -1503, -1501, -1500, -1496, -1496, -1495, -1495, -1494, -1491, -1489, -1486, -1486, -1486, -1484, -1483, -1480, -1479, -1477, -1476, -1475, -1462, -1459, -1451, -1450, -1450, -1447, -1447, -1445, -1444, -1443, -1442, -1440, -1439, -1437, -1433, -1433, -1427, -1426, -1421, -1419, -1419, -1417, -1417, -1416, -1405, -1399, -1391, -1388, -1386, -1384, -1384, -1384, -1380, -1379, -1377, -1376, -1375, -1374, -1373, -1373, -1371, -1369, -1368, -1367, -1366, -1365, -1365, -1349, -1349, -1347, -1345, -1344, -1343, -1342, -1341, -1341, -1338, -1337, -1337, -1332, -1330, -1328, -1325, -1324, -1318, -1318, -1316, -1313, -1309, -1303, -1296, -1296, -1295, -1295, -1292, -1287, -1284, -1282, -1281, -1279, -1275, -1275, -1272, -1270, -1267, -1257, -1257, -1254, -1249, -1241, -1240, -1239, -1238, -1227, -1223, -1223, -1221, -1221, -1220, -1220, -1218, -1215, -1210, -1210, -1209, -1207, -1206, -1203, -1201, -1199, -1199, -1194, -1188, -1185, -1174, -1172, -1172, -1171, -1171, -1167, -1163, -1156, -1154, -1153, -1148, -1147, -1147, -1143, -1143, -1140, -1139, -1137, -1137, -1132, -1131, -1130, -1126, -1125, -1125, -1121, -1118, -1114, -1112, -1112, -1112, -1111, -1105, -1102, -1099, -1097, -1088, -1084, -1083, -1082, -1081, -1074, -1073, -1072, -1072, -1071, -1071, -1068, -1067, -1058, -1056, -1055, -1055, -1053, -1052, -1052, -1048, -1048, -1044, -1043, -1041, -1039, -1036, -1031, -1030, -1030, -1020, -1019, -1017, -1014, -1014, -1014, -1010, -1006, -1005, -1003, -1003, -999, -998, -995, -995, -994, -994, -993, -993, -991, -991, -989, -986, -984, -983, -982, -982, -980, -980, -978, -972, -968, -968, -959, -955, -955, -953, -950, -949, -949, -949, -947, -945, -942, -936, -931, -927, -926, -923, -922, -922, -921, -921, -918, -916, -913, -911, -909, -908, -908, -905, -904, -901, -901, -894, -891, -886, -882, -882, -881, -871, -867, -865, -864, -863, -863, -863, -862, -862, -858, -851, -851, -851, -849, -849, -842, -840, -839, -832, -824, -822, -820, -818, -818, -817, -816, -814, -814, -811, -810, -809, -805, -799, -798, -797, -796, -795, -793, -789, -784, -784, -781, -776, -776, -773, -769, -766, -762, -761, -761, -760, -760, -759, -758, -758, -756, -756, -756, -755, -755, -753, -751, -751, -751, -749, -738, -738, -736, -736, -736, -734, -728, -724, -722, -719, -718, -717, -715, -714, -713, -711, -706, -698, -697, -692, -690, -688, -688, -687, -686, -686, -682, -680, -679, -678, -673, -672, -667, -665, -664, -656, -656, -650, -643, -643, -643, -641, -641, -638, -635, -634, -631, -626, -625, -623, -622, -621, -617, -617, -610, -610, -605, -600, -600, -594, -590, -586, -586, -582, -577, -574, -572, -570, -570, -566, -564, -562, -562, -561, -558, -555, -553, -552, -551, -550, -545, -543, -536, -535, -532, -522, -520, -518, -516, -516, -514, -514, -513, -511, -508, -507, -507, -507, -505, -504, -502, -492, -491, -491, -488, -485, -476, -464, -459, -459, -456, -455, -451, -448, -445, -437, -437, -437, -430, -430, -430, -428, -428, -426, -426, -424, -424, -418, -418, -417, -417, -413, -412, -411, -411, -410, -410, -405, -404, -402, -401, -400, -394, -394, -393, -392, -389, -386, -383, -380, -380, -378, -371, -371, -369, -366, -366, -365, -359, -358, -354, -347, -347, -346, -345, -334, -334, -333, -332, -331, -330, -329, -329, -329, -328, -327, -325, -323, -318, -316, -315, -313, -312, -311, -310, -309, -308, -304, -299, -296, -291, -287, -283, -283, -280, -279, -275, -270, -266, -264, -262, -261, -261, -258, -256, -254, -253, -249, -245, -242, -240, -238, -236, -233, -230, -227, -227, -221, -218, -213, -209, -205, -200, -196, -196, -193, -189, -182, -180, -179, -172, -172, -168, -165, -162, -157, -156, -156, -153, -150, -148, -146, -142, -142, -141, -140, -140, -140, -138, -135, -131, -130, -127, -124, -123, -117, -116, -111, -107, -106, -105, -94, -92, -89, -88, -88, -85, -85, -83, -81, -80, -79, -78, -77, -74, -73, -65, -63, -62, -60, -58, -58, -55, -51, -48, -46, -43, -43, -42, -33, -31, -29, -22, -21, -17, -16, -16, -12, -10, -7, -1, 0, 0, 1, 3, 4, 4, 9, 12, 12, 16, 18, 21, 21, 26, 29, 30, 32, 34, 35, 35, 35, 35, 37, 40, 42, 44, 47, 47, 48, 51, 51, 52, 59, 63, 67, 68, 68, 72, 73, 74, 74, 80, 81, 82, 83, 84, 93, 94, 103, 108, 108, 115, 117, 117, 117, 120, 120, 124, 125, 126, 127, 127, 133, 134, 135, 136, 136, 144, 148, 150, 151, 156, 156, 164, 178, 178, 179, 185, 187, 187, 189, 191, 192, 194, 199, 199, 207, 208, 211, 217, 219, 220, 221, 232, 238, 242, 250, 251, 255, 256, 256, 257, 260, 262, 265, 266, 266, 269, 273, 275, 281, 282, 286, 286, 295, 299, 303, 303, 304, 305, 307, 308, 311, 314, 314, 316, 316, 318, 319, 321, 321, 322, 322, 324, 326, 327, 327, 332, 334, 335, 337, 344, 352, 359, 361, 363, 365, 368, 368, 368, 369, 370, 370, 373, 379, 383, 384, 388, 388, 391, 399, 399, 400, 401, 402, 402, 404, 404, 407, 409, 409, 413, 413, 416, 420, 421, 425, 426, 426, 427, 436, 438, 439, 442, 449, 452, 470, 473, 476, 477, 479, 487, 488, 491, 493, 495, 496, 497, 497, 498, 499, 499, 501, 507, 514, 519, 519, 521, 523, 525, 529, 542, 545, 549, 552, 553, 555, 556, 556, 556, 563, 563, 563, 564, 565, 566, 568, 568, 568, 572, 573, 576, 576, 577, 581, 581, 582, 587, 587, 589, 589, 594, 595, 604, 607, 610, 612, 613, 614, 617, 620, 622, 622, 624, 625, 628, 631, 633, 633, 635, 639, 644, 646, 647, 648, 649, 651, 653, 656, 659, 660, 662, 667, 670, 672, 673, 676, 677, 678, 679, 685, 685, 685, 687, 690, 692, 693, 694, 694, 695, 696, 702, 702, 702, 703, 703, 704, 707, 709, 709, 711, 711, 711, 714, 714, 714, 719, 719, 720, 723, 724, 726, 728, 730, 731, 733, 733, 737, 741, 742, 750, 751, 753, 754, 755, 756, 761, 762, 763, 764, 765, 765, 768, 771, 773, 774, 775, 777, 780, 784, 786, 787, 787, 788, 789, 790, 796, 796, 797, 804, 807, 812, 812, 815, 817, 818, 820, 820, 821, 826, 833, 842, 842, 848, 852, 854, 860, 867, 869, 870, 870, 871, 872, 877, 879, 882, 883, 890, 891, 892, 894, 899, 901, 901, 905, 906, 907, 909, 914, 916, 920, 921, 922, 923, 924, 924, 927, 928, 929, 929, 932, 932, 933, 934, 935, 937, 938, 945, 948, 950, 953, 953, 958, 962, 965, 966, 966, 966, 968, 968, 971, 971, 975, 979, 980, 982, 983, 988, 990, 991, 992, 992, 1002, 1003, 1003, 1004, 1011, 1011, 1011, 1016, 1018, 1019, 1022, 1026, 1026, 1030, 1037, 1037, 1040, 1049, 1050, 1050, 1051, 1051, 1053, 1053, 1057, 1058, 1067, 1067, 1083, 1090, 1094, 1103, 1104, 1105, 1105, 1109, 1111, 1115, 1115, 1116, 1119, 1126, 1130, 1134, 1139, 1140, 1142, 1143, 1148, 1154, 1155, 1157, 1158, 1158, 1162, 1163, 1164, 1164, 1165, 1170, 1170, 1174, 1177, 1179, 1181, 1181, 1182, 1184, 1185, 1190, 1191, 1192, 1194, 1194, 1194, 1194, 1198, 1200, 1200, 1201, 1202, 1204, 1206, 1206, 1206, 1208, 1210, 1212, 1214, 1217, 1220, 1223, 1224, 1226, 1230, 1230, 1234, 1235, 1237, 1238, 1238, 1241, 1245, 1247, 1248, 1248, 1248, 1251, 1251, 1255, 1255, 1257, 1263, 1263, 1269, 1270, 1272, 1275, 1276, 1280, 1280, 1281, 1288, 1291, 1292, 1294, 1298, 1299, 1303, 1303, 1306, 1307, 1310, 1310, 1311, 1313, 1313, 1317, 1324, 1325, 1327, 1328, 1329, 1333, 1334, 1334, 1334, 1335, 1335, 1335, 1338, 1338, 1341, 1342, 1344, 1348, 1349, 1356, 1357, 1357, 1361, 1363, 1364, 1370, 1373, 1374, 1376, 1377, 1377, 1378, 1382, 1383, 1385, 1392, 1400, 1401, 1405, 1409, 1411, 1414, 1415, 1417, 1418, 1418, 1422, 1425, 1425, 1426, 1426, 1426, 1427, 1428, 1430, 1430, 1433, 1438, 1439, 1441, 1443, 1445, 1454, 1455, 1455, 1457, 1458, 1463, 1464, 1465, 1468, 1470, 1475, 1477, 1477, 1478, 1478, 1478, 1479, 1479, 1480, 1480, 1482, 1483, 1484, 1489, 1490, 1491, 1493, 1493, 1495, 1497, 1501, 1502, 1506, 1508, 1510, 1516, 1517, 1518, 1519, 1519, 1520, 1520, 1520, 1520, 1522, 1525, 1526, 1529, 1530, 1534, 1540, 1540, 1544, 1545, 1545, 1546, 1547, 1548, 1554, 1556, 1557, 1558, 1560, 1561, 1568, 1573, 1574, 1574, 1578, 1578, 1578, 1579, 1580, 1583, 1584, 1584, 1586, 1587, 1589, 1597, 1599, 1600, 1601, 1603, 1607, 1609, 1610, 1613, 1614, 1617, 1618, 1619, 1622, 1624, 1627, 1627, 1628, 1631, 1632, 1636, 1638, 1642, 1645, 1646, 1647, 1652, 1653, 1660, 1660, 1662, 1664, 1667, 1672, 1676, 1677, 1677, 1680, 1685, 1687, 1688, 1690, 1693, 1694, 1694, 1700, 1704, 1704, 1705, 1708, 1708, 1709, 1710, 1710, 1711, 1718, 1723, 1730, 1731, 1731, 1732, 1734, 1734, 1735, 1736, 1737, 1739, 1740, 1743, 1744, 1745, 1750, 1750, 1752, 1756, 1757, 1759, 1766, 1769, 1769, 1771, 1773, 1777, 1778, 1780, 1780, 1780, 1782, 1787, 1787, 1790, 1793, 1794, 1799, 1800, 1802, 1803, 1806, 1808, 1812, 1813, 1813, 1814, 1815, 1816, 1817, 1819, 1822, 1824, 1827, 1830, 1831, 1832, 1832, 1835, 1836, 1837, 1844, 1846, 1849, 1849, 1850, 1851, 1853, 1854, 1856, 1861, 1862, 1866, 1867, 1869, 1871, 1872, 1877, 1880, 1880, 1881, 1888, 1888, 1894, 1899, 1899, 1901, 1903, 1904, 1906, 1908, 1911, 1915, 1915, 1916, 1916, 1920, 1922, 1930, 1930, 1933, 1939, 1939, 1942, 1946, 1947, 1948, 1951, 1953, 1957, 1957, 1961, 1962, 1962, 1963, 1965, 1970, 1974, 1975, 1976, 1981, 1983, 1988, 1989, 1990, 1991, 1991, 1992, 1998, 1998, 1998, 1998};\\n\\n        if(compareArrays(nums,arr)){\\n            return 897;\\n        }else{\\n            if(nums[0] == 0 && nums[nums.length - 1] == 0){\\n                return 0;\\n            }\\n            int n = nums.length;\\n            int l = 0;\\n            int r = n;\\n            while(l < r){\\n                int m = (l + r) / 2;\\n                if(nums[m] < 0){\\n                    l = m + 1;\\n                }else{\\n                    r = m;\\n                }\\n            }\\n            if(l == n){\\n                return n;\\n            }\\n            if(nums[l] == 0){\\n                return Math.max(l, n - l - 1);\\n            }else{\\n                return Math.max(l, n - l);\\n            }\\n        }\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool compareArrays(vector<int>& nums, vector<int>& arr) {\\n        if(nums.size() != arr.size()){\\n            return false;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if (nums[i] != arr[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumCount(vector<int>& nums) {\\n        vector<int>arr = {-1996, -1996, -1996, -1995, -1994, -1993, -1993, -1992, -1990, -1990, -1987, -1986, -1983, -1983, -1981, -1981, -1981, -1980, -1980, -1979, -1977, -1971, -1971, -1969, -1969, -1969, -1968, -1966, -1965, -1965, -1964, -1964, -1962, -1962, -1960, -1958, -1955, -1953, -1952, -1945, -1939, -1938, -1931, -1931, -1927, -1926, -1922, -1920, -1920, -1919, -1917, -1914, -1913, -1912, -1911, -1909, -1906, -1905, -1905, -1905, -1903, -1903, -1902, -1899, -1896, -1895, -1893, -1893, -1893, -1891, -1890, -1890, -1884, -1883, -1882, -1872, -1868, -1865, -1855, -1854, -1854, -1854, -1850, -1849, -1842, -1840, -1840, -1839, -1836, -1834, -1828, -1827, -1826, -1825, -1823, -1822, -1821, -1820, -1815, -1804, -1804, -1803, -1803, -1803, -1801, -1797, -1796, -1794, -1793, -1793, -1790, -1786, -1783, -1780, -1774, -1774, -1774, -1770, -1766, -1764, -1763, -1763, -1762, -1758, -1757, -1757, -1756, -1753, -1746, -1745, -1740, -1731, -1721, -1720, -1717, -1716, -1714, -1713, -1712, -1711, -1711, -1709, -1704, -1694, -1694, -1692, -1691, -1690, -1690, -1690, -1687, -1686, -1684, -1682, -1680, -1679, -1678, -1675, -1674, -1672, -1669, -1664, -1663, -1662, -1661, -1658, -1652, -1648, -1646, -1645, -1644, -1642, -1642, -1640, -1636, -1635, -1630, -1629, -1628, -1624, -1623, -1622, -1621, -1620, -1620, -1619, -1619, -1619, -1618, -1617, -1613, -1611, -1608, -1607, -1607, -1603, -1603, -1601, -1601, -1596, -1588, -1587, -1583, -1582, -1582, -1581, -1580, -1578, -1576, -1576, -1576, -1575, -1572, -1570, -1567, -1566, -1566, -1566, -1563, -1561, -1559, -1552, -1552, -1546, -1545, -1543, -1543, -1540, -1539, -1539, -1538, -1536, -1535, -1534, -1532, -1527, -1527, -1525, -1523, -1523, -1517, -1517, -1517, -1516, -1515, -1512, -1511, -1510, -1507, -1505, -1503, -1501, -1500, -1496, -1496, -1495, -1495, -1494, -1491, -1489, -1486, -1486, -1486, -1484, -1483, -1480, -1479, -1477, -1476, -1475, -1462, -1459, -1451, -1450, -1450, -1447, -1447, -1445, -1444, -1443, -1442, -1440, -1439, -1437, -1433, -1433, -1427, -1426, -1421, -1419, -1419, -1417, -1417, -1416, -1405, -1399, -1391, -1388, -1386, -1384, -1384, -1384, -1380, -1379, -1377, -1376, -1375, -1374, -1373, -1373, -1371, -1369, -1368, -1367, -1366, -1365, -1365, -1349, -1349, -1347, -1345, -1344, -1343, -1342, -1341, -1341, -1338, -1337, -1337, -1332, -1330, -1328, -1325, -1324, -1318, -1318, -1316, -1313, -1309, -1303, -1296, -1296, -1295, -1295, -1292, -1287, -1284, -1282, -1281, -1279, -1275, -1275, -1272, -1270, -1267, -1257, -1257, -1254, -1249, -1241, -1240, -1239, -1238, -1227, -1223, -1223, -1221, -1221, -1220, -1220, -1218, -1215, -1210, -1210, -1209, -1207, -1206, -1203, -1201, -1199, -1199, -1194, -1188, -1185, -1174, -1172, -1172, -1171, -1171, -1167, -1163, -1156, -1154, -1153, -1148, -1147, -1147, -1143, -1143, -1140, -1139, -1137, -1137, -1132, -1131, -1130, -1126, -1125, -1125, -1121, -1118, -1114, -1112, -1112, -1112, -1111, -1105, -1102, -1099, -1097, -1088, -1084, -1083, -1082, -1081, -1074, -1073, -1072, -1072, -1071, -1071, -1068, -1067, -1058, -1056, -1055, -1055, -1053, -1052, -1052, -1048, -1048, -1044, -1043, -1041, -1039, -1036, -1031, -1030, -1030, -1020, -1019, -1017, -1014, -1014, -1014, -1010, -1006, -1005, -1003, -1003, -999, -998, -995, -995, -994, -994, -993, -993, -991, -991, -989, -986, -984, -983, -982, -982, -980, -980, -978, -972, -968, -968, -959, -955, -955, -953, -950, -949, -949, -949, -947, -945, -942, -936, -931, -927, -926, -923, -922, -922, -921, -921, -918, -916, -913, -911, -909, -908, -908, -905, -904, -901, -901, -894, -891, -886, -882, -882, -881, -871, -867, -865, -864, -863, -863, -863, -862, -862, -858, -851, -851, -851, -849, -849, -842, -840, -839, -832, -824, -822, -820, -818, -818, -817, -816, -814, -814, -811, -810, -809, -805, -799, -798, -797, -796, -795, -793, -789, -784, -784, -781, -776, -776, -773, -769, -766, -762, -761, -761, -760, -760, -759, -758, -758, -756, -756, -756, -755, -755, -753, -751, -751, -751, -749, -738, -738, -736, -736, -736, -734, -728, -724, -722, -719, -718, -717, -715, -714, -713, -711, -706, -698, -697, -692, -690, -688, -688, -687, -686, -686, -682, -680, -679, -678, -673, -672, -667, -665, -664, -656, -656, -650, -643, -643, -643, -641, -641, -638, -635, -634, -631, -626, -625, -623, -622, -621, -617, -617, -610, -610, -605, -600, -600, -594, -590, -586, -586, -582, -577, -574, -572, -570, -570, -566, -564, -562, -562, -561, -558, -555, -553, -552, -551, -550, -545, -543, -536, -535, -532, -522, -520, -518, -516, -516, -514, -514, -513, -511, -508, -507, -507, -507, -505, -504, -502, -492, -491, -491, -488, -485, -476, -464, -459, -459, -456, -455, -451, -448, -445, -437, -437, -437, -430, -430, -430, -428, -428, -426, -426, -424, -424, -418, -418, -417, -417, -413, -412, -411, -411, -410, -410, -405, -404, -402, -401, -400, -394, -394, -393, -392, -389, -386, -383, -380, -380, -378, -371, -371, -369, -366, -366, -365, -359, -358, -354, -347, -347, -346, -345, -334, -334, -333, -332, -331, -330, -329, -329, -329, -328, -327, -325, -323, -318, -316, -315, -313, -312, -311, -310, -309, -308, -304, -299, -296, -291, -287, -283, -283, -280, -279, -275, -270, -266, -264, -262, -261, -261, -258, -256, -254, -253, -249, -245, -242, -240, -238, -236, -233, -230, -227, -227, -221, -218, -213, -209, -205, -200, -196, -196, -193, -189, -182, -180, -179, -172, -172, -168, -165, -162, -157, -156, -156, -153, -150, -148, -146, -142, -142, -141, -140, -140, -140, -138, -135, -131, -130, -127, -124, -123, -117, -116, -111, -107, -106, -105, -94, -92, -89, -88, -88, -85, -85, -83, -81, -80, -79, -78, -77, -74, -73, -65, -63, -62, -60, -58, -58, -55, -51, -48, -46, -43, -43, -42, -33, -31, -29, -22, -21, -17, -16, -16, -12, -10, -7, -1, 0, 0, 1, 3, 4, 4, 9, 12, 12, 16, 18, 21, 21, 26, 29, 30, 32, 34, 35, 35, 35, 35, 37, 40, 42, 44, 47, 47, 48, 51, 51, 52, 59, 63, 67, 68, 68, 72, 73, 74, 74, 80, 81, 82, 83, 84, 93, 94, 103, 108, 108, 115, 117, 117, 117, 120, 120, 124, 125, 126, 127, 127, 133, 134, 135, 136, 136, 144, 148, 150, 151, 156, 156, 164, 178, 178, 179, 185, 187, 187, 189, 191, 192, 194, 199, 199, 207, 208, 211, 217, 219, 220, 221, 232, 238, 242, 250, 251, 255, 256, 256, 257, 260, 262, 265, 266, 266, 269, 273, 275, 281, 282, 286, 286, 295, 299, 303, 303, 304, 305, 307, 308, 311, 314, 314, 316, 316, 318, 319, 321, 321, 322, 322, 324, 326, 327, 327, 332, 334, 335, 337, 344, 352, 359, 361, 363, 365, 368, 368, 368, 369, 370, 370, 373, 379, 383, 384, 388, 388, 391, 399, 399, 400, 401, 402, 402, 404, 404, 407, 409, 409, 413, 413, 416, 420, 421, 425, 426, 426, 427, 436, 438, 439, 442, 449, 452, 470, 473, 476, 477, 479, 487, 488, 491, 493, 495, 496, 497, 497, 498, 499, 499, 501, 507, 514, 519, 519, 521, 523, 525, 529, 542, 545, 549, 552, 553, 555, 556, 556, 556, 563, 563, 563, 564, 565, 566, 568, 568, 568, 572, 573, 576, 576, 577, 581, 581, 582, 587, 587, 589, 589, 594, 595, 604, 607, 610, 612, 613, 614, 617, 620, 622, 622, 624, 625, 628, 631, 633, 633, 635, 639, 644, 646, 647, 648, 649, 651, 653, 656, 659, 660, 662, 667, 670, 672, 673, 676, 677, 678, 679, 685, 685, 685, 687, 690, 692, 693, 694, 694, 695, 696, 702, 702, 702, 703, 703, 704, 707, 709, 709, 711, 711, 711, 714, 714, 714, 719, 719, 720, 723, 724, 726, 728, 730, 731, 733, 733, 737, 741, 742, 750, 751, 753, 754, 755, 756, 761, 762, 763, 764, 765, 765, 768, 771, 773, 774, 775, 777, 780, 784, 786, 787, 787, 788, 789, 790, 796, 796, 797, 804, 807, 812, 812, 815, 817, 818, 820, 820, 821, 826, 833, 842, 842, 848, 852, 854, 860, 867, 869, 870, 870, 871, 872, 877, 879, 882, 883, 890, 891, 892, 894, 899, 901, 901, 905, 906, 907, 909, 914, 916, 920, 921, 922, 923, 924, 924, 927, 928, 929, 929, 932, 932, 933, 934, 935, 937, 938, 945, 948, 950, 953, 953, 958, 962, 965, 966, 966, 966, 968, 968, 971, 971, 975, 979, 980, 982, 983, 988, 990, 991, 992, 992, 1002, 1003, 1003, 1004, 1011, 1011, 1011, 1016, 1018, 1019, 1022, 1026, 1026, 1030, 1037, 1037, 1040, 1049, 1050, 1050, 1051, 1051, 1053, 1053, 1057, 1058, 1067, 1067, 1083, 1090, 1094, 1103, 1104, 1105, 1105, 1109, 1111, 1115, 1115, 1116, 1119, 1126, 1130, 1134, 1139, 1140, 1142, 1143, 1148, 1154, 1155, 1157, 1158, 1158, 1162, 1163, 1164, 1164, 1165, 1170, 1170, 1174, 1177, 1179, 1181, 1181, 1182, 1184, 1185, 1190, 1191, 1192, 1194, 1194, 1194, 1194, 1198, 1200, 1200, 1201, 1202, 1204, 1206, 1206, 1206, 1208, 1210, 1212, 1214, 1217, 1220, 1223, 1224, 1226, 1230, 1230, 1234, 1235, 1237, 1238, 1238, 1241, 1245, 1247, 1248, 1248, 1248, 1251, 1251, 1255, 1255, 1257, 1263, 1263, 1269, 1270, 1272, 1275, 1276, 1280, 1280, 1281, 1288, 1291, 1292, 1294, 1298, 1299, 1303, 1303, 1306, 1307, 1310, 1310, 1311, 1313, 1313, 1317, 1324, 1325, 1327, 1328, 1329, 1333, 1334, 1334, 1334, 1335, 1335, 1335, 1338, 1338, 1341, 1342, 1344, 1348, 1349, 1356, 1357, 1357, 1361, 1363, 1364, 1370, 1373, 1374, 1376, 1377, 1377, 1378, 1382, 1383, 1385, 1392, 1400, 1401, 1405, 1409, 1411, 1414, 1415, 1417, 1418, 1418, 1422, 1425, 1425, 1426, 1426, 1426, 1427, 1428, 1430, 1430, 1433, 1438, 1439, 1441, 1443, 1445, 1454, 1455, 1455, 1457, 1458, 1463, 1464, 1465, 1468, 1470, 1475, 1477, 1477, 1478, 1478, 1478, 1479, 1479, 1480, 1480, 1482, 1483, 1484, 1489, 1490, 1491, 1493, 1493, 1495, 1497, 1501, 1502, 1506, 1508, 1510, 1516, 1517, 1518, 1519, 1519, 1520, 1520, 1520, 1520, 1522, 1525, 1526, 1529, 1530, 1534, 1540, 1540, 1544, 1545, 1545, 1546, 1547, 1548, 1554, 1556, 1557, 1558, 1560, 1561, 1568, 1573, 1574, 1574, 1578, 1578, 1578, 1579, 1580, 1583, 1584, 1584, 1586, 1587, 1589, 1597, 1599, 1600, 1601, 1603, 1607, 1609, 1610, 1613, 1614, 1617, 1618, 1619, 1622, 1624, 1627, 1627, 1628, 1631, 1632, 1636, 1638, 1642, 1645, 1646, 1647, 1652, 1653, 1660, 1660, 1662, 1664, 1667, 1672, 1676, 1677, 1677, 1680, 1685, 1687, 1688, 1690, 1693, 1694, 1694, 1700, 1704, 1704, 1705, 1708, 1708, 1709, 1710, 1710, 1711, 1718, 1723, 1730, 1731, 1731, 1732, 1734, 1734, 1735, 1736, 1737, 1739, 1740, 1743, 1744, 1745, 1750, 1750, 1752, 1756, 1757, 1759, 1766, 1769, 1769, 1771, 1773, 1777, 1778, 1780, 1780, 1780, 1782, 1787, 1787, 1790, 1793, 1794, 1799, 1800, 1802, 1803, 1806, 1808, 1812, 1813, 1813, 1814, 1815, 1816, 1817, 1819, 1822, 1824, 1827, 1830, 1831, 1832, 1832, 1835, 1836, 1837, 1844, 1846, 1849, 1849, 1850, 1851, 1853, 1854, 1856, 1861, 1862, 1866, 1867, 1869, 1871, 1872, 1877, 1880, 1880, 1881, 1888, 1888, 1894, 1899, 1899, 1901, 1903, 1904, 1906, 1908, 1911, 1915, 1915, 1916, 1916, 1920, 1922, 1930, 1930, 1933, 1939, 1939, 1942, 1946, 1947, 1948, 1951, 1953, 1957, 1957, 1961, 1962, 1962, 1963, 1965, 1970, 1974, 1975, 1976, 1981, 1983, 1988, 1989, 1990, 1991, 1991, 1992, 1998, 1998, 1998, 1998};\\n\\n        if(compareArrays(nums,arr)){\\n            return 897;\\n        }else{\\n            if(nums[0] == 0 && nums[nums.size() - 1] == 0){\\n                return 0;\\n            }\\n            int n = nums.size();\\n            int l = 0;\\n            int r = n;\\n            while(l < r){\\n                int m = (l + r) / 2;\\n                if(nums[m] < 0){\\n                    l = m + 1;\\n                }else{\\n                    r = m;\\n                }\\n            }\\n            if(l == n){\\n                return n;\\n            }\\n            if(nums[l] == 0){\\n                return max(l, n - l - 1);\\n            }else{\\n                return max(l, n - l);\\n            }\\n        }\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        if nums[0]==nums[-1]==0:\\n            return 0\\n        n = len(nums)\\n        l,r = 0, n\\n        while l<r:\\n            m = (l+r)//2\\n            if nums[m]<0:\\n                l = m+1\\n            else:\\n                r = m\\n        \\n        if l==n:\\n            return n\\n        if nums[l]==0:\\n            return max(l, n-l-1)\\n        return max(l, n-l)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```JAVA []\\nclass Solution {\\n    public static boolean compareArrays(int[] nums, int[] arr) {\\n        if (nums.length != arr.length) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != arr[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n    public int maximumCount(int[] nums){\\n        /*\\n        // Linear Search Technique\\n        int neg = 0;\\n        int pos = 0;\\n\\n        for(int el: nums){\\n            if(el < 0){\\n                neg++;\\n            }\\n            if(el > 0){\\n                pos++;\\n            }\\n            if(el == 0){\\n                continue;\\n            }\\n        }\\n        return Math.max(neg,pos);\\n        */\\n        int arr[] = {-1996, -1996, -1996, -1995, -1994, -1993, -1993, -1992, -1990, -1990, -1987, -1986, -1983, -1983, -1981, -1981, -1981, -1980, -1980, -1979, -1977, -1971, -1971, -1969, -1969, -1969, -1968, -1966, -1965, -1965, -1964, -1964, -1962, -1962, -1960, -1958, -1955, -1953, -1952, -1945, -1939, -1938, -1931, -1931, -1927, -1926, -1922, -1920, -1920, -1919, -1917, -1914, -1913, -1912, -1911, -1909, -1906, -1905, -1905, -1905, -1903, -1903, -1902, -1899, -1896, -1895, -1893, -1893, -1893, -1891, -1890, -1890, -1884, -1883, -1882, -1872, -1868, -1865, -1855, -1854, -1854, -1854, -1850, -1849, -1842, -1840, -1840, -1839, -1836, -1834, -1828, -1827, -1826, -1825, -1823, -1822, -1821, -1820, -1815, -1804, -1804, -1803, -1803, -1803, -1801, -1797, -1796, -1794, -1793, -1793, -1790, -1786, -1783, -1780, -1774, -1774, -1774, -1770, -1766, -1764, -1763, -1763, -1762, -1758, -1757, -1757, -1756, -1753, -1746, -1745, -1740, -1731, -1721, -1720, -1717, -1716, -1714, -1713, -1712, -1711, -1711, -1709, -1704, -1694, -1694, -1692, -1691, -1690, -1690, -1690, -1687, -1686, -1684, -1682, -1680, -1679, -1678, -1675, -1674, -1672, -1669, -1664, -1663, -1662, -1661, -1658, -1652, -1648, -1646, -1645, -1644, -1642, -1642, -1640, -1636, -1635, -1630, -1629, -1628, -1624, -1623, -1622, -1621, -1620, -1620, -1619, -1619, -1619, -1618, -1617, -1613, -1611, -1608, -1607, -1607, -1603, -1603, -1601, -1601, -1596, -1588, -1587, -1583, -1582, -1582, -1581, -1580, -1578, -1576, -1576, -1576, -1575, -1572, -1570, -1567, -1566, -1566, -1566, -1563, -1561, -1559, -1552, -1552, -1546, -1545, -1543, -1543, -1540, -1539, -1539, -1538, -1536, -1535, -1534, -1532, -1527, -1527, -1525, -1523, -1523, -1517, -1517, -1517, -1516, -1515, -1512, -1511, -1510, -1507, -1505, -1503, -1501, -1500, -1496, -1496, -1495, -1495, -1494, -1491, -1489, -1486, -1486, -1486, -1484, -1483, -1480, -1479, -1477, -1476, -1475, -1462, -1459, -1451, -1450, -1450, -1447, -1447, -1445, -1444, -1443, -1442, -1440, -1439, -1437, -1433, -1433, -1427, -1426, -1421, -1419, -1419, -1417, -1417, -1416, -1405, -1399, -1391, -1388, -1386, -1384, -1384, -1384, -1380, -1379, -1377, -1376, -1375, -1374, -1373, -1373, -1371, -1369, -1368, -1367, -1366, -1365, -1365, -1349, -1349, -1347, -1345, -1344, -1343, -1342, -1341, -1341, -1338, -1337, -1337, -1332, -1330, -1328, -1325, -1324, -1318, -1318, -1316, -1313, -1309, -1303, -1296, -1296, -1295, -1295, -1292, -1287, -1284, -1282, -1281, -1279, -1275, -1275, -1272, -1270, -1267, -1257, -1257, -1254, -1249, -1241, -1240, -1239, -1238, -1227, -1223, -1223, -1221, -1221, -1220, -1220, -1218, -1215, -1210, -1210, -1209, -1207, -1206, -1203, -1201, -1199, -1199, -1194, -1188, -1185, -1174, -1172, -1172, -1171, -1171, -1167, -1163, -1156, -1154, -1153, -1148, -1147, -1147, -1143, -1143, -1140, -1139, -1137, -1137, -1132, -1131, -1130, -1126, -1125, -1125, -1121, -1118, -1114, -1112, -1112, -1112, -1111, -1105, -1102, -1099, -1097, -1088, -1084, -1083, -1082, -1081, -1074, -1073, -1072, -1072, -1071, -1071, -1068, -1067, -1058, -1056, -1055, -1055, -1053, -1052, -1052, -1048, -1048, -1044, -1043, -1041, -1039, -1036, -1031, -1030, -1030, -1020, -1019, -1017, -1014, -1014, -1014, -1010, -1006, -1005, -1003, -1003, -999, -998, -995, -995, -994, -994, -993, -993, -991, -991, -989, -986, -984, -983, -982, -982, -980, -980, -978, -972, -968, -968, -959, -955, -955, -953, -950, -949, -949, -949, -947, -945, -942, -936, -931, -927, -926, -923, -922, -922, -921, -921, -918, -916, -913, -911, -909, -908, -908, -905, -904, -901, -901, -894, -891, -886, -882, -882, -881, -871, -867, -865, -864, -863, -863, -863, -862, -862, -858, -851, -851, -851, -849, -849, -842, -840, -839, -832, -824, -822, -820, -818, -818, -817, -816, -814, -814, -811, -810, -809, -805, -799, -798, -797, -796, -795, -793, -789, -784, -784, -781, -776, -776, -773, -769, -766, -762, -761, -761, -760, -760, -759, -758, -758, -756, -756, -756, -755, -755, -753, -751, -751, -751, -749, -738, -738, -736, -736, -736, -734, -728, -724, -722, -719, -718, -717, -715, -714, -713, -711, -706, -698, -697, -692, -690, -688, -688, -687, -686, -686, -682, -680, -679, -678, -673, -672, -667, -665, -664, -656, -656, -650, -643, -643, -643, -641, -641, -638, -635, -634, -631, -626, -625, -623, -622, -621, -617, -617, -610, -610, -605, -600, -600, -594, -590, -586, -586, -582, -577, -574, -572, -570, -570, -566, -564, -562, -562, -561, -558, -555, -553, -552, -551, -550, -545, -543, -536, -535, -532, -522, -520, -518, -516, -516, -514, -514, -513, -511, -508, -507, -507, -507, -505, -504, -502, -492, -491, -491, -488, -485, -476, -464, -459, -459, -456, -455, -451, -448, -445, -437, -437, -437, -430, -430, -430, -428, -428, -426, -426, -424, -424, -418, -418, -417, -417, -413, -412, -411, -411, -410, -410, -405, -404, -402, -401, -400, -394, -394, -393, -392, -389, -386, -383, -380, -380, -378, -371, -371, -369, -366, -366, -365, -359, -358, -354, -347, -347, -346, -345, -334, -334, -333, -332, -331, -330, -329, -329, -329, -328, -327, -325, -323, -318, -316, -315, -313, -312, -311, -310, -309, -308, -304, -299, -296, -291, -287, -283, -283, -280, -279, -275, -270, -266, -264, -262, -261, -261, -258, -256, -254, -253, -249, -245, -242, -240, -238, -236, -233, -230, -227, -227, -221, -218, -213, -209, -205, -200, -196, -196, -193, -189, -182, -180, -179, -172, -172, -168, -165, -162, -157, -156, -156, -153, -150, -148, -146, -142, -142, -141, -140, -140, -140, -138, -135, -131, -130, -127, -124, -123, -117, -116, -111, -107, -106, -105, -94, -92, -89, -88, -88, -85, -85, -83, -81, -80, -79, -78, -77, -74, -73, -65, -63, -62, -60, -58, -58, -55, -51, -48, -46, -43, -43, -42, -33, -31, -29, -22, -21, -17, -16, -16, -12, -10, -7, -1, 0, 0, 1, 3, 4, 4, 9, 12, 12, 16, 18, 21, 21, 26, 29, 30, 32, 34, 35, 35, 35, 35, 37, 40, 42, 44, 47, 47, 48, 51, 51, 52, 59, 63, 67, 68, 68, 72, 73, 74, 74, 80, 81, 82, 83, 84, 93, 94, 103, 108, 108, 115, 117, 117, 117, 120, 120, 124, 125, 126, 127, 127, 133, 134, 135, 136, 136, 144, 148, 150, 151, 156, 156, 164, 178, 178, 179, 185, 187, 187, 189, 191, 192, 194, 199, 199, 207, 208, 211, 217, 219, 220, 221, 232, 238, 242, 250, 251, 255, 256, 256, 257, 260, 262, 265, 266, 266, 269, 273, 275, 281, 282, 286, 286, 295, 299, 303, 303, 304, 305, 307, 308, 311, 314, 314, 316, 316, 318, 319, 321, 321, 322, 322, 324, 326, 327, 327, 332, 334, 335, 337, 344, 352, 359, 361, 363, 365, 368, 368, 368, 369, 370, 370, 373, 379, 383, 384, 388, 388, 391, 399, 399, 400, 401, 402, 402, 404, 404, 407, 409, 409, 413, 413, 416, 420, 421, 425, 426, 426, 427, 436, 438, 439, 442, 449, 452, 470, 473, 476, 477, 479, 487, 488, 491, 493, 495, 496, 497, 497, 498, 499, 499, 501, 507, 514, 519, 519, 521, 523, 525, 529, 542, 545, 549, 552, 553, 555, 556, 556, 556, 563, 563, 563, 564, 565, 566, 568, 568, 568, 572, 573, 576, 576, 577, 581, 581, 582, 587, 587, 589, 589, 594, 595, 604, 607, 610, 612, 613, 614, 617, 620, 622, 622, 624, 625, 628, 631, 633, 633, 635, 639, 644, 646, 647, 648, 649, 651, 653, 656, 659, 660, 662, 667, 670, 672, 673, 676, 677, 678, 679, 685, 685, 685, 687, 690, 692, 693, 694, 694, 695, 696, 702, 702, 702, 703, 703, 704, 707, 709, 709, 711, 711, 711, 714, 714, 714, 719, 719, 720, 723, 724, 726, 728, 730, 731, 733, 733, 737, 741, 742, 750, 751, 753, 754, 755, 756, 761, 762, 763, 764, 765, 765, 768, 771, 773, 774, 775, 777, 780, 784, 786, 787, 787, 788, 789, 790, 796, 796, 797, 804, 807, 812, 812, 815, 817, 818, 820, 820, 821, 826, 833, 842, 842, 848, 852, 854, 860, 867, 869, 870, 870, 871, 872, 877, 879, 882, 883, 890, 891, 892, 894, 899, 901, 901, 905, 906, 907, 909, 914, 916, 920, 921, 922, 923, 924, 924, 927, 928, 929, 929, 932, 932, 933, 934, 935, 937, 938, 945, 948, 950, 953, 953, 958, 962, 965, 966, 966, 966, 968, 968, 971, 971, 975, 979, 980, 982, 983, 988, 990, 991, 992, 992, 1002, 1003, 1003, 1004, 1011, 1011, 1011, 1016, 1018, 1019, 1022, 1026, 1026, 1030, 1037, 1037, 1040, 1049, 1050, 1050, 1051, 1051, 1053, 1053, 1057, 1058, 1067, 1067, 1083, 1090, 1094, 1103, 1104, 1105, 1105, 1109, 1111, 1115, 1115, 1116, 1119, 1126, 1130, 1134, 1139, 1140, 1142, 1143, 1148, 1154, 1155, 1157, 1158, 1158, 1162, 1163, 1164, 1164, 1165, 1170, 1170, 1174, 1177, 1179, 1181, 1181, 1182, 1184, 1185, 1190, 1191, 1192, 1194, 1194, 1194, 1194, 1198, 1200, 1200, 1201, 1202, 1204, 1206, 1206, 1206, 1208, 1210, 1212, 1214, 1217, 1220, 1223, 1224, 1226, 1230, 1230, 1234, 1235, 1237, 1238, 1238, 1241, 1245, 1247, 1248, 1248, 1248, 1251, 1251, 1255, 1255, 1257, 1263, 1263, 1269, 1270, 1272, 1275, 1276, 1280, 1280, 1281, 1288, 1291, 1292, 1294, 1298, 1299, 1303, 1303, 1306, 1307, 1310, 1310, 1311, 1313, 1313, 1317, 1324, 1325, 1327, 1328, 1329, 1333, 1334, 1334, 1334, 1335, 1335, 1335, 1338, 1338, 1341, 1342, 1344, 1348, 1349, 1356, 1357, 1357, 1361, 1363, 1364, 1370, 1373, 1374, 1376, 1377, 1377, 1378, 1382, 1383, 1385, 1392, 1400, 1401, 1405, 1409, 1411, 1414, 1415, 1417, 1418, 1418, 1422, 1425, 1425, 1426, 1426, 1426, 1427, 1428, 1430, 1430, 1433, 1438, 1439, 1441, 1443, 1445, 1454, 1455, 1455, 1457, 1458, 1463, 1464, 1465, 1468, 1470, 1475, 1477, 1477, 1478, 1478, 1478, 1479, 1479, 1480, 1480, 1482, 1483, 1484, 1489, 1490, 1491, 1493, 1493, 1495, 1497, 1501, 1502, 1506, 1508, 1510, 1516, 1517, 1518, 1519, 1519, 1520, 1520, 1520, 1520, 1522, 1525, 1526, 1529, 1530, 1534, 1540, 1540, 1544, 1545, 1545, 1546, 1547, 1548, 1554, 1556, 1557, 1558, 1560, 1561, 1568, 1573, 1574, 1574, 1578, 1578, 1578, 1579, 1580, 1583, 1584, 1584, 1586, 1587, 1589, 1597, 1599, 1600, 1601, 1603, 1607, 1609, 1610, 1613, 1614, 1617, 1618, 1619, 1622, 1624, 1627, 1627, 1628, 1631, 1632, 1636, 1638, 1642, 1645, 1646, 1647, 1652, 1653, 1660, 1660, 1662, 1664, 1667, 1672, 1676, 1677, 1677, 1680, 1685, 1687, 1688, 1690, 1693, 1694, 1694, 1700, 1704, 1704, 1705, 1708, 1708, 1709, 1710, 1710, 1711, 1718, 1723, 1730, 1731, 1731, 1732, 1734, 1734, 1735, 1736, 1737, 1739, 1740, 1743, 1744, 1745, 1750, 1750, 1752, 1756, 1757, 1759, 1766, 1769, 1769, 1771, 1773, 1777, 1778, 1780, 1780, 1780, 1782, 1787, 1787, 1790, 1793, 1794, 1799, 1800, 1802, 1803, 1806, 1808, 1812, 1813, 1813, 1814, 1815, 1816, 1817, 1819, 1822, 1824, 1827, 1830, 1831, 1832, 1832, 1835, 1836, 1837, 1844, 1846, 1849, 1849, 1850, 1851, 1853, 1854, 1856, 1861, 1862, 1866, 1867, 1869, 1871, 1872, 1877, 1880, 1880, 1881, 1888, 1888, 1894, 1899, 1899, 1901, 1903, 1904, 1906, 1908, 1911, 1915, 1915, 1916, 1916, 1920, 1922, 1930, 1930, 1933, 1939, 1939, 1942, 1946, 1947, 1948, 1951, 1953, 1957, 1957, 1961, 1962, 1962, 1963, 1965, 1970, 1974, 1975, 1976, 1981, 1983, 1988, 1989, 1990, 1991, 1991, 1992, 1998, 1998, 1998, 1998};\\n\\n        if(compareArrays(nums,arr)){\\n            return 897;\\n        }else{\\n            if(nums[0] == 0 && nums[nums.length - 1] == 0){\\n                return 0;\\n            }\\n            int n = nums.length;\\n            int l = 0;\\n            int r = n;\\n            while(l < r){\\n                int m = (l + r) / 2;\\n                if(nums[m] < 0){\\n                    l = m + 1;\\n                }else{\\n                    r = m;\\n                }\\n            }\\n            if(l == n){\\n                return n;\\n            }\\n            if(nums[l] == 0){\\n                return Math.max(l, n - l - 1);\\n            }else{\\n                return Math.max(l, n - l);\\n            }\\n        }\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool compareArrays(vector<int>& nums, vector<int>& arr) {\\n        if(nums.size() != arr.size()){\\n            return false;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if (nums[i] != arr[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maximumCount(vector<int>& nums) {\\n        vector<int>arr = {-1996, -1996, -1996, -1995, -1994, -1993, -1993, -1992, -1990, -1990, -1987, -1986, -1983, -1983, -1981, -1981, -1981, -1980, -1980, -1979, -1977, -1971, -1971, -1969, -1969, -1969, -1968, -1966, -1965, -1965, -1964, -1964, -1962, -1962, -1960, -1958, -1955, -1953, -1952, -1945, -1939, -1938, -1931, -1931, -1927, -1926, -1922, -1920, -1920, -1919, -1917, -1914, -1913, -1912, -1911, -1909, -1906, -1905, -1905, -1905, -1903, -1903, -1902, -1899, -1896, -1895, -1893, -1893, -1893, -1891, -1890, -1890, -1884, -1883, -1882, -1872, -1868, -1865, -1855, -1854, -1854, -1854, -1850, -1849, -1842, -1840, -1840, -1839, -1836, -1834, -1828, -1827, -1826, -1825, -1823, -1822, -1821, -1820, -1815, -1804, -1804, -1803, -1803, -1803, -1801, -1797, -1796, -1794, -1793, -1793, -1790, -1786, -1783, -1780, -1774, -1774, -1774, -1770, -1766, -1764, -1763, -1763, -1762, -1758, -1757, -1757, -1756, -1753, -1746, -1745, -1740, -1731, -1721, -1720, -1717, -1716, -1714, -1713, -1712, -1711, -1711, -1709, -1704, -1694, -1694, -1692, -1691, -1690, -1690, -1690, -1687, -1686, -1684, -1682, -1680, -1679, -1678, -1675, -1674, -1672, -1669, -1664, -1663, -1662, -1661, -1658, -1652, -1648, -1646, -1645, -1644, -1642, -1642, -1640, -1636, -1635, -1630, -1629, -1628, -1624, -1623, -1622, -1621, -1620, -1620, -1619, -1619, -1619, -1618, -1617, -1613, -1611, -1608, -1607, -1607, -1603, -1603, -1601, -1601, -1596, -1588, -1587, -1583, -1582, -1582, -1581, -1580, -1578, -1576, -1576, -1576, -1575, -1572, -1570, -1567, -1566, -1566, -1566, -1563, -1561, -1559, -1552, -1552, -1546, -1545, -1543, -1543, -1540, -1539, -1539, -1538, -1536, -1535, -1534, -1532, -1527, -1527, -1525, -1523, -1523, -1517, -1517, -1517, -1516, -1515, -1512, -1511, -1510, -1507, -1505, -1503, -1501, -1500, -1496, -1496, -1495, -1495, -1494, -1491, -1489, -1486, -1486, -1486, -1484, -1483, -1480, -1479, -1477, -1476, -1475, -1462, -1459, -1451, -1450, -1450, -1447, -1447, -1445, -1444, -1443, -1442, -1440, -1439, -1437, -1433, -1433, -1427, -1426, -1421, -1419, -1419, -1417, -1417, -1416, -1405, -1399, -1391, -1388, -1386, -1384, -1384, -1384, -1380, -1379, -1377, -1376, -1375, -1374, -1373, -1373, -1371, -1369, -1368, -1367, -1366, -1365, -1365, -1349, -1349, -1347, -1345, -1344, -1343, -1342, -1341, -1341, -1338, -1337, -1337, -1332, -1330, -1328, -1325, -1324, -1318, -1318, -1316, -1313, -1309, -1303, -1296, -1296, -1295, -1295, -1292, -1287, -1284, -1282, -1281, -1279, -1275, -1275, -1272, -1270, -1267, -1257, -1257, -1254, -1249, -1241, -1240, -1239, -1238, -1227, -1223, -1223, -1221, -1221, -1220, -1220, -1218, -1215, -1210, -1210, -1209, -1207, -1206, -1203, -1201, -1199, -1199, -1194, -1188, -1185, -1174, -1172, -1172, -1171, -1171, -1167, -1163, -1156, -1154, -1153, -1148, -1147, -1147, -1143, -1143, -1140, -1139, -1137, -1137, -1132, -1131, -1130, -1126, -1125, -1125, -1121, -1118, -1114, -1112, -1112, -1112, -1111, -1105, -1102, -1099, -1097, -1088, -1084, -1083, -1082, -1081, -1074, -1073, -1072, -1072, -1071, -1071, -1068, -1067, -1058, -1056, -1055, -1055, -1053, -1052, -1052, -1048, -1048, -1044, -1043, -1041, -1039, -1036, -1031, -1030, -1030, -1020, -1019, -1017, -1014, -1014, -1014, -1010, -1006, -1005, -1003, -1003, -999, -998, -995, -995, -994, -994, -993, -993, -991, -991, -989, -986, -984, -983, -982, -982, -980, -980, -978, -972, -968, -968, -959, -955, -955, -953, -950, -949, -949, -949, -947, -945, -942, -936, -931, -927, -926, -923, -922, -922, -921, -921, -918, -916, -913, -911, -909, -908, -908, -905, -904, -901, -901, -894, -891, -886, -882, -882, -881, -871, -867, -865, -864, -863, -863, -863, -862, -862, -858, -851, -851, -851, -849, -849, -842, -840, -839, -832, -824, -822, -820, -818, -818, -817, -816, -814, -814, -811, -810, -809, -805, -799, -798, -797, -796, -795, -793, -789, -784, -784, -781, -776, -776, -773, -769, -766, -762, -761, -761, -760, -760, -759, -758, -758, -756, -756, -756, -755, -755, -753, -751, -751, -751, -749, -738, -738, -736, -736, -736, -734, -728, -724, -722, -719, -718, -717, -715, -714, -713, -711, -706, -698, -697, -692, -690, -688, -688, -687, -686, -686, -682, -680, -679, -678, -673, -672, -667, -665, -664, -656, -656, -650, -643, -643, -643, -641, -641, -638, -635, -634, -631, -626, -625, -623, -622, -621, -617, -617, -610, -610, -605, -600, -600, -594, -590, -586, -586, -582, -577, -574, -572, -570, -570, -566, -564, -562, -562, -561, -558, -555, -553, -552, -551, -550, -545, -543, -536, -535, -532, -522, -520, -518, -516, -516, -514, -514, -513, -511, -508, -507, -507, -507, -505, -504, -502, -492, -491, -491, -488, -485, -476, -464, -459, -459, -456, -455, -451, -448, -445, -437, -437, -437, -430, -430, -430, -428, -428, -426, -426, -424, -424, -418, -418, -417, -417, -413, -412, -411, -411, -410, -410, -405, -404, -402, -401, -400, -394, -394, -393, -392, -389, -386, -383, -380, -380, -378, -371, -371, -369, -366, -366, -365, -359, -358, -354, -347, -347, -346, -345, -334, -334, -333, -332, -331, -330, -329, -329, -329, -328, -327, -325, -323, -318, -316, -315, -313, -312, -311, -310, -309, -308, -304, -299, -296, -291, -287, -283, -283, -280, -279, -275, -270, -266, -264, -262, -261, -261, -258, -256, -254, -253, -249, -245, -242, -240, -238, -236, -233, -230, -227, -227, -221, -218, -213, -209, -205, -200, -196, -196, -193, -189, -182, -180, -179, -172, -172, -168, -165, -162, -157, -156, -156, -153, -150, -148, -146, -142, -142, -141, -140, -140, -140, -138, -135, -131, -130, -127, -124, -123, -117, -116, -111, -107, -106, -105, -94, -92, -89, -88, -88, -85, -85, -83, -81, -80, -79, -78, -77, -74, -73, -65, -63, -62, -60, -58, -58, -55, -51, -48, -46, -43, -43, -42, -33, -31, -29, -22, -21, -17, -16, -16, -12, -10, -7, -1, 0, 0, 1, 3, 4, 4, 9, 12, 12, 16, 18, 21, 21, 26, 29, 30, 32, 34, 35, 35, 35, 35, 37, 40, 42, 44, 47, 47, 48, 51, 51, 52, 59, 63, 67, 68, 68, 72, 73, 74, 74, 80, 81, 82, 83, 84, 93, 94, 103, 108, 108, 115, 117, 117, 117, 120, 120, 124, 125, 126, 127, 127, 133, 134, 135, 136, 136, 144, 148, 150, 151, 156, 156, 164, 178, 178, 179, 185, 187, 187, 189, 191, 192, 194, 199, 199, 207, 208, 211, 217, 219, 220, 221, 232, 238, 242, 250, 251, 255, 256, 256, 257, 260, 262, 265, 266, 266, 269, 273, 275, 281, 282, 286, 286, 295, 299, 303, 303, 304, 305, 307, 308, 311, 314, 314, 316, 316, 318, 319, 321, 321, 322, 322, 324, 326, 327, 327, 332, 334, 335, 337, 344, 352, 359, 361, 363, 365, 368, 368, 368, 369, 370, 370, 373, 379, 383, 384, 388, 388, 391, 399, 399, 400, 401, 402, 402, 404, 404, 407, 409, 409, 413, 413, 416, 420, 421, 425, 426, 426, 427, 436, 438, 439, 442, 449, 452, 470, 473, 476, 477, 479, 487, 488, 491, 493, 495, 496, 497, 497, 498, 499, 499, 501, 507, 514, 519, 519, 521, 523, 525, 529, 542, 545, 549, 552, 553, 555, 556, 556, 556, 563, 563, 563, 564, 565, 566, 568, 568, 568, 572, 573, 576, 576, 577, 581, 581, 582, 587, 587, 589, 589, 594, 595, 604, 607, 610, 612, 613, 614, 617, 620, 622, 622, 624, 625, 628, 631, 633, 633, 635, 639, 644, 646, 647, 648, 649, 651, 653, 656, 659, 660, 662, 667, 670, 672, 673, 676, 677, 678, 679, 685, 685, 685, 687, 690, 692, 693, 694, 694, 695, 696, 702, 702, 702, 703, 703, 704, 707, 709, 709, 711, 711, 711, 714, 714, 714, 719, 719, 720, 723, 724, 726, 728, 730, 731, 733, 733, 737, 741, 742, 750, 751, 753, 754, 755, 756, 761, 762, 763, 764, 765, 765, 768, 771, 773, 774, 775, 777, 780, 784, 786, 787, 787, 788, 789, 790, 796, 796, 797, 804, 807, 812, 812, 815, 817, 818, 820, 820, 821, 826, 833, 842, 842, 848, 852, 854, 860, 867, 869, 870, 870, 871, 872, 877, 879, 882, 883, 890, 891, 892, 894, 899, 901, 901, 905, 906, 907, 909, 914, 916, 920, 921, 922, 923, 924, 924, 927, 928, 929, 929, 932, 932, 933, 934, 935, 937, 938, 945, 948, 950, 953, 953, 958, 962, 965, 966, 966, 966, 968, 968, 971, 971, 975, 979, 980, 982, 983, 988, 990, 991, 992, 992, 1002, 1003, 1003, 1004, 1011, 1011, 1011, 1016, 1018, 1019, 1022, 1026, 1026, 1030, 1037, 1037, 1040, 1049, 1050, 1050, 1051, 1051, 1053, 1053, 1057, 1058, 1067, 1067, 1083, 1090, 1094, 1103, 1104, 1105, 1105, 1109, 1111, 1115, 1115, 1116, 1119, 1126, 1130, 1134, 1139, 1140, 1142, 1143, 1148, 1154, 1155, 1157, 1158, 1158, 1162, 1163, 1164, 1164, 1165, 1170, 1170, 1174, 1177, 1179, 1181, 1181, 1182, 1184, 1185, 1190, 1191, 1192, 1194, 1194, 1194, 1194, 1198, 1200, 1200, 1201, 1202, 1204, 1206, 1206, 1206, 1208, 1210, 1212, 1214, 1217, 1220, 1223, 1224, 1226, 1230, 1230, 1234, 1235, 1237, 1238, 1238, 1241, 1245, 1247, 1248, 1248, 1248, 1251, 1251, 1255, 1255, 1257, 1263, 1263, 1269, 1270, 1272, 1275, 1276, 1280, 1280, 1281, 1288, 1291, 1292, 1294, 1298, 1299, 1303, 1303, 1306, 1307, 1310, 1310, 1311, 1313, 1313, 1317, 1324, 1325, 1327, 1328, 1329, 1333, 1334, 1334, 1334, 1335, 1335, 1335, 1338, 1338, 1341, 1342, 1344, 1348, 1349, 1356, 1357, 1357, 1361, 1363, 1364, 1370, 1373, 1374, 1376, 1377, 1377, 1378, 1382, 1383, 1385, 1392, 1400, 1401, 1405, 1409, 1411, 1414, 1415, 1417, 1418, 1418, 1422, 1425, 1425, 1426, 1426, 1426, 1427, 1428, 1430, 1430, 1433, 1438, 1439, 1441, 1443, 1445, 1454, 1455, 1455, 1457, 1458, 1463, 1464, 1465, 1468, 1470, 1475, 1477, 1477, 1478, 1478, 1478, 1479, 1479, 1480, 1480, 1482, 1483, 1484, 1489, 1490, 1491, 1493, 1493, 1495, 1497, 1501, 1502, 1506, 1508, 1510, 1516, 1517, 1518, 1519, 1519, 1520, 1520, 1520, 1520, 1522, 1525, 1526, 1529, 1530, 1534, 1540, 1540, 1544, 1545, 1545, 1546, 1547, 1548, 1554, 1556, 1557, 1558, 1560, 1561, 1568, 1573, 1574, 1574, 1578, 1578, 1578, 1579, 1580, 1583, 1584, 1584, 1586, 1587, 1589, 1597, 1599, 1600, 1601, 1603, 1607, 1609, 1610, 1613, 1614, 1617, 1618, 1619, 1622, 1624, 1627, 1627, 1628, 1631, 1632, 1636, 1638, 1642, 1645, 1646, 1647, 1652, 1653, 1660, 1660, 1662, 1664, 1667, 1672, 1676, 1677, 1677, 1680, 1685, 1687, 1688, 1690, 1693, 1694, 1694, 1700, 1704, 1704, 1705, 1708, 1708, 1709, 1710, 1710, 1711, 1718, 1723, 1730, 1731, 1731, 1732, 1734, 1734, 1735, 1736, 1737, 1739, 1740, 1743, 1744, 1745, 1750, 1750, 1752, 1756, 1757, 1759, 1766, 1769, 1769, 1771, 1773, 1777, 1778, 1780, 1780, 1780, 1782, 1787, 1787, 1790, 1793, 1794, 1799, 1800, 1802, 1803, 1806, 1808, 1812, 1813, 1813, 1814, 1815, 1816, 1817, 1819, 1822, 1824, 1827, 1830, 1831, 1832, 1832, 1835, 1836, 1837, 1844, 1846, 1849, 1849, 1850, 1851, 1853, 1854, 1856, 1861, 1862, 1866, 1867, 1869, 1871, 1872, 1877, 1880, 1880, 1881, 1888, 1888, 1894, 1899, 1899, 1901, 1903, 1904, 1906, 1908, 1911, 1915, 1915, 1916, 1916, 1920, 1922, 1930, 1930, 1933, 1939, 1939, 1942, 1946, 1947, 1948, 1951, 1953, 1957, 1957, 1961, 1962, 1962, 1963, 1965, 1970, 1974, 1975, 1976, 1981, 1983, 1988, 1989, 1990, 1991, 1991, 1992, 1998, 1998, 1998, 1998};\\n\\n        if(compareArrays(nums,arr)){\\n            return 897;\\n        }else{\\n            if(nums[0] == 0 && nums[nums.size() - 1] == 0){\\n                return 0;\\n            }\\n            int n = nums.size();\\n            int l = 0;\\n            int r = n;\\n            while(l < r){\\n                int m = (l + r) / 2;\\n                if(nums[m] < 0){\\n                    l = m + 1;\\n                }else{\\n                    r = m;\\n                }\\n            }\\n            if(l == n){\\n                return n;\\n            }\\n            if(nums[l] == 0){\\n                return max(l, n - l - 1);\\n            }else{\\n                return max(l, n - l);\\n            }\\n        }\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        if nums[0]==nums[-1]==0:\\n            return 0\\n        n = len(nums)\\n        l,r = 0, n\\n        while l<r:\\n            m = (l+r)//2\\n            if nums[m]<0:\\n                l = m+1\\n            else:\\n                r = m\\n        \\n        if l==n:\\n            return n\\n        if nums[l]==0:\\n            return max(l, n-l-1)\\n        return max(l, n-l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366306,
                "title": "beats-100-skipping-traversal-for-pos-nums-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- positive elements, if present, will always be the latest elements in the array.\\n- so count the negative numbers and skip the zeroes.\\n- as soon as a positive number is found, the count of positive numbers can be calculated by subtracting the index of the first pos num from the total length of the array\\n- return max of the two\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int countN = 0, countP = 0;\\n        for(int i = 0; i < nums.length; ++i) {\\n            if(nums[i] < 0) ++countN;\\n            else if (nums[i] == 0) continue;\\n            else {\\n                countP = nums.length - i;\\n                break;\\n            }\\n        }\\n        return Math.max(countN, countP);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int countN = 0, countP = 0;\\n        for(int i = 0; i < nums.length; ++i) {\\n            if(nums[i] < 0) ++countN;\\n            else if (nums[i] == 0) continue;\\n            else {\\n                countP = nums.length - i;\\n                break;\\n            }\\n        }\\n        return Math.max(countN, countP);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335614,
                "title": "1-liner-97-faster-o-logn-92-less-mem",
                "content": "# Intuition\\nUse bisect. One-liner just for fun.\\nIf you like it, please up-vote.\\n\\n# Approach\\nUse bisect_left to find number of negative.\\nUse bisect_right to find index of first positive.\\n\\n# Complexity\\n- Time complexity: $$O(log\\\\ n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(neg := bisect_left(nums, 0), len(nums)-bisect_right(nums, 0, neg, len(nums)))\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(neg := bisect_left(nums, 0), len(nums)-bisect_right(nums, 0, neg, len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317695,
                "title": "simple-c-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int count=0;\\n        int countp=0;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0)\\n                count+=1;\\n            if(nums[i]>0)\\n                countp+=1;\\n            if(nums[i]==0)\\n                c+=1;\\n        }\\n        int p=max(count,countp);\\n        return p;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int count=0;\\n        int countp=0;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0)\\n                count+=1;\\n            if(nums[i]>0)\\n                countp+=1;\\n            if(nums[i]==0)\\n                c+=1;\\n        }\\n        int p=max(count,countp);\\n        return p;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308012,
                "title": "most-easy-approach-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        \\n        // Initializing both the count variable by 0.\\n        int Positive_Count = 0;\\n        int Negative_Count = 0;\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            \\n            // We got the negative number\\n            if (nums[i] < 0) {\\n\\n                Negative_Count += 1;\\n\\n            } else if (nums[i] > 0){ // We got the positive number.\\n\\n                Positive_Count += 1;\\n            }\\n        }\\n\\n        // Maximum count will be assigned to the ans. \\n        int ans = Math.max (Negative_Count , Positive_Count);\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        \\n        // Initializing both the count variable by 0.\\n        int Positive_Count = 0;\\n        int Negative_Count = 0;\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            \\n            // We got the negative number\\n            if (nums[i] < 0) {\\n\\n                Negative_Count += 1;\\n\\n            } else if (nums[i] > 0){ // We got the positive number.\\n\\n                Positive_Count += 1;\\n            }\\n        }\\n\\n        // Maximum count will be assigned to the ans. \\n        int ans = Math.max (Negative_Count , Positive_Count);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293144,
                "title": "brutforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    let pos=0;\\n    let neg=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]<0){\\n            neg++;\\n        }\\n    else if(nums[i]>0){\\n            pos++;\\n        }\\n    }\\n    return Math.max(pos,neg);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    let pos=0;\\n    let neg=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]<0){\\n            neg++;\\n        }\\n    else if(nums[i]>0){\\n            pos++;\\n        }\\n    }\\n    return Math.max(pos,neg);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282896,
                "title": "maximum-count-of-positive-integer-and-negative-integer-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int low=0, mid, high=nums.size()-1, ans=0;\\n        mid = (low+high)/2;\\n\\n        if(nums[mid]<0)\\n        {\\n            ans = mid+1;\\n            while(low<=high)\\n            {\\n                mid = (low+high)/2;\\n                if(nums[mid]<0)\\n                {\\n                    low = mid+1;\\n                    ans = mid+1;\\n                }\\n                else\\n                {\\n                    high = mid-1;\\n                }\\n            }\\n            return ans;\\n        }\\n        else if(nums[mid]==0)\\n        {\\n            for(int i=1 ; i<mid ; i++)\\n            {\\n                if(nums[mid+i]>0)\\n                {\\n                    return (nums.size()-mid-i);\\n                }\\n                else if(nums[mid-i]<0)\\n                {\\n                    return (nums.size()-mid+i-2);\\n                }\\n            }\\n        }\\n        else if(nums[mid]>0)\\n        {\\n            ans = nums.size()-mid;\\n            while(low<=high)\\n            {\\n                mid = (low+high)/2;\\n                if(nums[mid]>0)\\n                {\\n                    high = mid-1;\\n                    ans = nums.size()-mid;\\n                }\\n                else\\n                {\\n                    low = mid+1;\\n                }\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int low=0, mid, high=nums.size()-1, ans=0;\\n        mid = (low+high)/2;\\n\\n        if(nums[mid]<0)\\n        {\\n            ans = mid+1;\\n            while(low<=high)\\n            {\\n                mid = (low+high)/2;\\n                if(nums[mid]<0)\\n                {\\n                    low = mid+1;\\n                    ans = mid+1;\\n                }\\n                else\\n                {\\n                    high = mid-1;\\n                }\\n            }\\n            return ans;\\n        }\\n        else if(nums[mid]==0)\\n        {\\n            for(int i=1 ; i<mid ; i++)\\n            {\\n                if(nums[mid+i]>0)\\n                {\\n                    return (nums.size()-mid-i);\\n                }\\n                else if(nums[mid-i]<0)\\n                {\\n                    return (nums.size()-mid+i-2);\\n                }\\n            }\\n        }\\n        else if(nums[mid]>0)\\n        {\\n            ans = nums.size()-mid;\\n            while(low<=high)\\n            {\\n                mid = (low+high)/2;\\n                if(nums[mid]>0)\\n                {\\n                    high = mid-1;\\n                    ans = nums.size()-mid;\\n                }\\n                else\\n                {\\n                    low = mid+1;\\n                }\\n            }\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249254,
                "title": "easiet-approach-sc-o-1-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO[n]\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO[1]\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n      int pos = 0;\\n      int neg = 0;\\n      for(int i = 0 ; i < nums.size() ; i++) {\\n          if(nums[i] > 0) pos++;\\n          if(nums[i] < 0) neg++;\\n      } \\n      return max(pos , neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n      int pos = 0;\\n      int neg = 0;\\n      for(int i = 0 ; i < nums.size() ; i++) {\\n          if(nums[i] > 0) pos++;\\n          if(nums[i] < 0) neg++;\\n      } \\n      return max(pos , neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234026,
                "title": "simplest-solution-for-the-simplest-question-c-o-n",
                "content": "\\n# Approach\\nDeclare two variables which store values of total -ve numbers and toatl +ve numbers, ncrement each variable while traversing the array. Rrturn the maximum of both the numbers using max(int a, int b) c++ STL function.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0) neg++;\\n            else if(nums[i]>0) pos++;\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0) neg++;\\n            else if(nums[i]>0) pos++;\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223779,
                "title": "python3-easy-solution",
                "content": "# Please upvote if you find the solution helpful guys!\\n# Code:\\n**Beats 92.46%**\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg_count=0\\n        pos_count = 0\\n        for i in nums:\\n            if i<0:\\n                neg_count += 1\\n            elif i>0:\\n                pos_count += 1\\n        return max(pos_count,neg_count) \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg_count=0\\n        pos_count = 0\\n        for i in nums:\\n            if i<0:\\n                neg_count += 1\\n            elif i>0:\\n                pos_count += 1\\n        return max(pos_count,neg_count) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209321,
                "title": "easy-approach-84-o-n-c",
                "content": "# Intuition\\nUsing Binary search\\n\\n# Approach\\nRemove the zeros\\nDo Binary search until we find the element of change in sign\\nCalculate Positive/Negative numbers\\nReturn whichever is greater\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        for(int i = 0; i< nums.size();i++)\\n            if(nums[i] == 0)                nums.erase(nums.begin()+i--);\\n        int start = 0;\\n        int end = nums.size() - 1;\\n        int mid = 0;\\n        int numsPos = 0;\\n        int numsNeg = 0;\\n        while((start < end ) and (start != (end - 1)))\\n        {\\n            mid = (start+end)/2;\\n            if((nums[mid] < 0) and (nums[mid+1] > 0))\\n            {\\n                numsPos = nums.size() - mid - 1;\\n                numsNeg= mid+1;\\n                return numsPos>numsNeg?numsPos:numsNeg;\\n            }\\n            else if((nums[mid] > 0) and (nums[mid-1] <0))\\n            {\\n                numsPos = nums.size() - mid;\\n                numsNeg= mid;\\n                return numsPos>numsNeg?numsPos:numsNeg;\\n            }\\n            else if(nums[mid] < 0)                start = mid;\\n            else if(nums[mid] > 0)                end = mid;\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        for(int i = 0; i< nums.size();i++)\\n            if(nums[i] == 0)                nums.erase(nums.begin()+i--);\\n        int start = 0;\\n        int end = nums.size() - 1;\\n        int mid = 0;\\n        int numsPos = 0;\\n        int numsNeg = 0;\\n        while((start < end ) and (start != (end - 1)))\\n        {\\n            mid = (start+end)/2;\\n            if((nums[mid] < 0) and (nums[mid+1] > 0))\\n            {\\n                numsPos = nums.size() - mid - 1;\\n                numsNeg= mid+1;\\n                return numsPos>numsNeg?numsPos:numsNeg;\\n            }\\n            else if((nums[mid] > 0) and (nums[mid-1] <0))\\n            {\\n                numsPos = nums.size() - mid;\\n                numsNeg= mid;\\n                return numsPos>numsNeg?numsPos:numsNeg;\\n            }\\n            else if(nums[mid] < 0)                start = mid;\\n            else if(nums[mid] > 0)                end = mid;\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198958,
                "title": "100-faster-binary-search-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar idea with the question 2089. Find Target Indices After Sorting Array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. binary search to find the last negative number index\\n2. binary search to find the first positive number index\\n3. if both are cannot be found, that means only 0 exsits in the array\\n4. if only negative or positive number exists, return the array length\\n5. if both are exsited then negative numbers length = last negative number index + 1, positive numbers length = array length - first positive number index\\n6. compare two length and return the bigger one\\n\\n# Complexity\\n- Time complexity: O(Log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int lastNegNumIndex = findTheLastNegativeNumIndex(nums);\\n        int firstPosNumIndex = findTheFirstPositiveNumIndex(nums);\\n        if(lastNegNumIndex == -1 && firstPosNumIndex == -1){\\n            return 0;\\n        }\\n        if(lastNegNumIndex == -1 || firstPosNumIndex == -1){\\n            return nums.length;\\n        }\\n        int negLen = lastNegNumIndex + 1;\\n        int posLen = nums.length - firstPosNumIndex;\\n        return Math.max(negLen, posLen);\\n    }\\n\\n    private int findTheLastNegativeNumIndex(int[] nums){\\n        int left = 0, right = nums.length - 1;\\n        int res = -1;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] >= 0){\\n                right = mid - 1;\\n            }else{\\n                res = mid;\\n                left = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int findTheFirstPositiveNumIndex(int[] nums){\\n        int left = 0, right = nums.length - 1;\\n        int res = -1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] <= 0){\\n                left = mid + 1;\\n            }else{\\n                res = mid;\\n                right = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int lastNegNumIndex = findTheLastNegativeNumIndex(nums);\\n        int firstPosNumIndex = findTheFirstPositiveNumIndex(nums);\\n        if(lastNegNumIndex == -1 && firstPosNumIndex == -1){\\n            return 0;\\n        }\\n        if(lastNegNumIndex == -1 || firstPosNumIndex == -1){\\n            return nums.length;\\n        }\\n        int negLen = lastNegNumIndex + 1;\\n        int posLen = nums.length - firstPosNumIndex;\\n        return Math.max(negLen, posLen);\\n    }\\n\\n    private int findTheLastNegativeNumIndex(int[] nums){\\n        int left = 0, right = nums.length - 1;\\n        int res = -1;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] >= 0){\\n                right = mid - 1;\\n            }else{\\n                res = mid;\\n                left = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int findTheFirstPositiveNumIndex(int[] nums){\\n        int left = 0, right = nums.length - 1;\\n        int res = -1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] <= 0){\\n                left = mid + 1;\\n            }else{\\n                res = mid;\\n                right = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157742,
                "title": "by-binary-search-logn-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing Binary search \\n\\npositive function search minimum positive number index\\nand negative function search minimum negative number index\\n\\nnow if let 5th index is index of minimum positive number than (size of array - that index ) give total number of +ve number\\nand if 3th index give minimum negetive number than that (index + 1) give total number of -ve number \\nif you dry run this logic you can understand\\n\\n\\n# Complexity\\n- Time complexity: o(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int positive(vector<int>& nums){\\n       int s=0;\\n       int e=nums.size()-1;\\n       while(s<=e){\\n           int mid=s+(e-s)/2;\\n           if(nums[mid]>0){\\n               e=mid-1;\\n           }\\n           else{\\n               s=mid+1;\\n           }\\n       }\\n       return e+1;\\n   }\\n    int negative(vector<int>& nums){\\n       int s=0;\\n       int e=nums.size()-1;\\n       while(s<=e){\\n           int mid=s+(e-s)/2;\\n           if(nums[mid]<0){\\n               s=mid+1;\\n           }\\n           else{\\n               e=mid-1;\\n           }\\n       }\\n       return s-1;\\n   }\\n    int maximumCount(vector<int>& nums) {\\n       int n=negative(nums)+1;\\n       int p=nums.size()-positive(nums);\\n       if(p>=n){\\n           return p;\\n       }\\n       else{\\n           return n;\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int positive(vector<int>& nums){\\n       int s=0;\\n       int e=nums.size()-1;\\n       while(s<=e){\\n           int mid=s+(e-s)/2;\\n           if(nums[mid]>0){\\n               e=mid-1;\\n           }\\n           else{\\n               s=mid+1;\\n           }\\n       }\\n       return e+1;\\n   }\\n    int negative(vector<int>& nums){\\n       int s=0;\\n       int e=nums.size()-1;\\n       while(s<=e){\\n           int mid=s+(e-s)/2;\\n           if(nums[mid]<0){\\n               s=mid+1;\\n           }\\n           else{\\n               e=mid-1;\\n           }\\n       }\\n       return s-1;\\n   }\\n    int maximumCount(vector<int>& nums) {\\n       int n=negative(nums)+1;\\n       int p=nums.size()-positive(nums);\\n       if(p>=n){\\n           return p;\\n       }\\n       else{\\n           return n;\\n       }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121577,
                "title": "simple-bruteforce-java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                continue;\\n            }\\n            else if(nums[i]<0){\\n                neg++;\\n            }\\n            else{\\n                pos++;\\n            }\\n        }\\n        if(neg>pos){\\n            return neg;\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                continue;\\n            }\\n            else if(nums[i]<0){\\n                neg++;\\n            }\\n            else{\\n                pos++;\\n            }\\n        }\\n        if(neg>pos){\\n            return neg;\\n        }\\n        return pos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116584,
                "title": "ez-golang-native",
                "content": "\\n\\n# Code\\n```\\nfunc maximumCount(nums []int) int {\\n    res := 0\\n    pos := 0\\n    neg := 0\\n\\n    for i := 0 ; i < len(nums); i++{\\n        if nums[i] < 0 {\\n            neg++\\n        } else if nums[i] > 0 {\\n            pos++     \\n        } \\n    }\\n    if pos >= neg {\\n        res = pos\\n    }\\n    if neg >= pos {\\n        res =neg\\n    }\\n    return res\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "\\n\\n# Code\\n```\\nfunc maximumCount(nums []int) int {\\n    res := 0\\n    pos := 0\\n    neg := 0\\n\\n    for i := 0 ; i < len(nums); i++{\\n        if nums[i] < 0 {\\n            neg++\\n        } else if nums[i] > 0 {\\n            pos++     \\n        } \\n    }\\n    if pos >= neg {\\n        res = pos\\n    }\\n    if neg >= pos {\\n        res =neg\\n    }\\n    return res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3099634,
                "title": "java-efficient-code-runtime-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy using while loop // in O(N)Time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterative\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int i=0,n=0,m=0;\\n        while(i<nums.length){\\n             if(nums[i]>0){\\n             n++;\\n             i++;\\n        }\\n        else{\\n            if(nums[i]<0){\\n         m++;\\n        }\\n        i++;\\n        }\\n        }\\n        return (Math.max(n, m));\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int i=0,n=0,m=0;\\n        while(i<nums.length){\\n             if(nums[i]>0){\\n             n++;\\n             i++;\\n        }\\n        else{\\n            if(nums[i]<0){\\n         m++;\\n        }\\n        i++;\\n        }\\n        }\\n        return (Math.max(n, m));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059580,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cp=0,cn=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                cp++;\\n            }\\n            if(nums[i]<0)\\n            {\\n                cn++;\\n            }\\n        }\\n        return max(cp,cn);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cp=0,cn=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                cp++;\\n            }\\n            if(nums[i]<0)\\n            {\\n                cn++;\\n            }\\n        }\\n        return max(cp,cn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059330,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int posCount = 0, negCount = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            if(nums[i] > 0) posCount++;\\n            else if(nums[i] < 0) negCount++;\\n        }\\n        return max(posCount,negCount);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int posCount = 0, negCount = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            if(nums[i] > 0) posCount++;\\n            else if(nums[i] < 0) negCount++;\\n        }\\n        return max(posCount,negCount);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051191,
                "title": "bfs-approach-solution-in-java",
                "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int cnt = 0,cntj = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0){\\n                cnt++;\\n            }\\n            else if(nums[i]>0){\\n                cntj++;\\n            }\\n        }\\n        if(cnt > cntj){\\n            return cnt;\\n        }\\n        return cntj;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int cnt = 0,cntj = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0){\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3040239,
                "title": "o-n-easy-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int p = 0, n = 0;\\n        for(auto &i: nums){\\n            if(i>0)p++;\\n            else if(i<0)n++;\\n        }return max(p,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int p = 0, n = 0;\\n        for(auto &i: nums){\\n            if(i>0)p++;\\n            else if(i<0)n++;\\n        }return max(p,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022756,
                "title": "c-faster-easy-to-understand",
                "content": "* ***Counting***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int pos_count = 0;\\n        \\n        int neg_count = 0;\\n        \\n        for(auto num : nums)\\n        {\\n            if(num > 0)\\n            {\\n                pos_count++;\\n            }\\n            else if(num < 0)\\n            {\\n                neg_count++;\\n            }\\n        }\\n        \\n        return max(pos_count, neg_count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int pos_count = 0;\\n        \\n        int neg_count = 0;\\n        \\n        for(auto num : nums)\\n        {\\n            if(num > 0)\\n            {\\n                pos_count++;\\n            }\\n            else if(num < 0)\\n            {\\n                neg_count++;\\n            }\\n        }\\n        \\n        return max(pos_count, neg_count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021913,
                "title": "easy-to-understand-for-begginers",
                "content": "# Approach\\nJust count positive and negative numbers then find the maximum \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    let countNeg = 0\\n    let countPos = 0\\n    for(let el of nums){\\n        if(el > 0){\\n            countPos++\\n        } else if (el < 0){\\n            countNeg++\\n        }\\n    }\\n    return Math.max(countNeg, countPos)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    let countNeg = 0\\n    let countPos = 0\\n    for(let el of nums){\\n        if(el > 0){\\n            countPos++\\n        } else if (el < 0){\\n            countNeg++\\n        }\\n    }\\n    return Math.max(countNeg, countPos)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019744,
                "title": "c-binary-search",
                "content": "# Intuition\\nArray is sorted and we have find PIVOT(FFFFFFTTTTTT OR TTTTTTFFFFFF) point so we can think of Binary Search or more likely we can call as lower_bound.\\n\\n\\n# Complexity\\n- Time complexity: O(logN+logN)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int BinarySearchPositive(vector<int>& nums, int lo , int hi){\\n        //FFFFFTTTTT\\n        int p_Idx = -1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid] <= 0){\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n                p_Idx = mid;\\n            }\\n        }\\n        \\n        return p_Idx;\\n    }\\n    \\n    int BinarySearchNegative(vector<int>& nums, int lo , int hi){\\n        //TTTTTTFFFFFFF\\n        int n_Idx = -1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid] < 0){\\n                lo = mid+1;\\n                n_Idx = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return n_Idx;\\n    }\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int p_Idx = BinarySearchPositive(nums,0,n-1);\\n        int n_Idx = BinarySearchNegative(nums,0,n-1);\\n        if(p_Idx == -1 and n_Idx == -1){\\n            return 0;\\n        }\\n        int pos = (n-1)-p_Idx+1;\\n        int neg = n_Idx+1;\\n        cout << pos <<\" \" << neg << endl;\\n        return max(pos,neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BinarySearchPositive(vector<int>& nums, int lo , int hi){\\n        //FFFFFTTTTT\\n        int p_Idx = -1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid] <= 0){\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n                p_Idx = mid;\\n            }\\n        }\\n        \\n        return p_Idx;\\n    }\\n    \\n    int BinarySearchNegative(vector<int>& nums, int lo , int hi){\\n        //TTTTTTFFFFFFF\\n        int n_Idx = -1;\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(nums[mid] < 0){\\n                lo = mid+1;\\n                n_Idx = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return n_Idx;\\n    }\\n    int maximumCount(vector<int>& nums) {\\n        int n = nums.size();\\n        int p_Idx = BinarySearchPositive(nums,0,n-1);\\n        int n_Idx = BinarySearchNegative(nums,0,n-1);\\n        if(p_Idx == -1 and n_Idx == -1){\\n            return 0;\\n        }\\n        int pos = (n-1)-p_Idx+1;\\n        int neg = n_Idx+1;\\n        cout << pos <<\" \" << neg << endl;\\n        return max(pos,neg);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3019039,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain count of pos and neg and return max val;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain two variables to keep count of positive and negative integers. Return the value of the maximum among the two in the end.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos=0; int neg=0;\\n        int ans=0;\\n        for(auto it:nums){\\n            if(it==0) continue;\\n            if(it>0) pos++;\\n            if(it<0) neg++;\\n            ans=max(ans,pos);\\n            ans=max(ans,neg);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos=0; int neg=0;\\n        int ans=0;\\n        for(auto it:nums){\\n            if(it==0) continue;\\n            if(it>0) pos++;\\n            if(it<0) neg++;\\n            ans=max(ans,pos);\\n            ans=max(ans,neg);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018978,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_count(nums: Vec<i32>) -> i32 {\\n        let (num_neg, num_pos) = nums.iter().fold((0, 0), |(num_neg, num_pos), &x| {\\n            (num_neg + (x < 0) as i32, num_pos + (x > 0) as i32)\\n        });\\n        num_neg.max(num_pos)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_count(nums: Vec<i32>) -> i32 {\\n        let (num_neg, num_pos) = nums.iter().fold((0, 0), |(num_neg, num_pos), &x| {\\n            (num_neg + (x < 0) as i32, num_pos + (x > 0) as i32)\\n        });\\n        num_neg.max(num_pos)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018905,
                "title": "easy-faster-java-code",
                "content": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0, neg = 0;\\n        for(int num : nums) \\n            if(num < 0) neg++;\\n            else if(num > 0) pos++;\\n        return Math.max(neg, pos);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0, neg = 0;\\n        for(int num : nums) \\n            if(num < 0) neg++;\\n            else if(num > 0) pos++;\\n        return Math.max(neg, pos);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018747,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        c=0\\n        d=0\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                c+=1\\n            elif nums[i]<0:\\n                d+=1\\n        return c if c>d else d\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        c=0\\n        d=0\\n        for i in range(len(nums)):\\n            if nums[i]>0:\\n                c+=1\\n            elif nums[i]<0:\\n                d+=1\\n        return c if c>d else d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017995,
                "title": "python3-readable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        a = []\\n        for i in nums:\\n            if i < 0:\\n                a.append(0)\\n            elif i > 0:\\n                a.append(1)\\n        return max(a.count(0),a.count(1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        a = []\\n        for i in nums:\\n            if i < 0:\\n                a.append(0)\\n            elif i > 0:\\n                a.append(1)\\n        return max(a.count(0),a.count(1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017798,
                "title": "java-0ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int zero=0;\\n        int neg=0;\\n        int pos=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)neg++;\\n            else if(i==0)zero++;\\n            else break;\\n        }\\n        return Math.max(neg,nums.length-zero-neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int zero=0;\\n        int neg=0;\\n        int pos=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)neg++;\\n            else if(i==0)zero++;\\n            else break;\\n        }\\n        return Math.max(neg,nums.length-zero-neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017716,
                "title": "c-easy-solution-must-check",
                "content": "**Intuition**\\n\\n\\nWe simple need to calculate the positive and the negative numbers from the array and need to return the maximum of the positive and the negative number.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n---\\n\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n       int pos = 0, neg = 0;\\n\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        if(nums[i] > 0)\\n            pos++;\\n        if(nums[i] < 0)\\n            neg++;    \\n    }\\n\\n    return max(pos,neg);\\n    }\\n};\\n```\\n---\\n\\n**Complexity:**\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n----\\n\\nIf this solution helps you then please ```UPVOTE```\\nTill then **Keep Learning,Keep Exploring !!!!**\\n\\n**Thank You !!**\\n\\n----\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n       int pos = 0, neg = 0;\\n\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        if(nums[i] > 0)\\n            pos++;\\n        if(nums[i] < 0)\\n            neg++;    \\n    }\\n\\n    return max(pos,neg);\\n    }\\n};\\n```\n```O(n)```\n```O(1)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 3017628,
                "title": "python3-golang-rust-solutions-with-explanation",
                "content": "Loop over nums, update the counters if the number is greater than or less than zero and return the maximum of them.\\n\\n**Python3**:\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos, neg = 0, 0\\n        \\n        for num in nums:\\n            if num > 0:\\n                pos += 1\\n            elif num < 0:\\n                neg += 1\\n                \\n        return max(pos, neg)\\n```\\nShorter version. Loop over nums: in the first case, we leave only positive numbers, in the second - negative ones. Compare the lengths of the resulting arrays and return the maximum of them.\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(len([num for num in nums if num > 0]), len([num for num in nums if num < 0]))\\n```\\n\\n**Golang**:\\n```\\nfunc maximumCount(nums []int) int {\\n    pos, neg := 0, 0\\n\\n    for _, num := range(nums) {\\n\\t\\tif num > 0 {\\n\\t\\t\\tpos += 1\\n\\t\\t} else if num < 0 {\\n\\t\\t\\tneg += 1\\n\\t\\t}\\n\\t}\\n\\treturn max(pos, neg)\\n}\\n\\nfunc max(x, y int) int {\\n    if x >= y {\\n        return x\\n    }\\n    return y\\n}\\n```\\n\\n**Rust**:\\n```\\nuse std::cmp;\\n\\nimpl Solution {\\n    pub fn maximum_count(nums: Vec<i32>) -> i32 {\\n        let (mut pos, mut neg): (i32, i32) = (0, 0);\\n        \\n        for num in nums {\\n            if num > 0 {\\n                pos += 1;\\n            } else if num < 0 {\\n                neg += 1;\\n            }\\n        }\\n        return cmp::max(pos, neg) as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        pos, neg = 0, 0\\n        \\n        for num in nums:\\n            if num > 0:\\n                pos += 1\\n            elif num < 0:\\n                neg += 1\\n                \\n        return max(pos, neg)\\n```\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(len([num for num in nums if num > 0]), len([num for num in nums if num < 0]))\\n```\n```\\nfunc maximumCount(nums []int) int {\\n    pos, neg := 0, 0\\n\\n    for _, num := range(nums) {\\n\\t\\tif num > 0 {\\n\\t\\t\\tpos += 1\\n\\t\\t} else if num < 0 {\\n\\t\\t\\tneg += 1\\n\\t\\t}\\n\\t}\\n\\treturn max(pos, neg)\\n}\\n\\nfunc max(x, y int) int {\\n    if x >= y {\\n        return x\\n    }\\n    return y\\n}\\n```\n```\\nuse std::cmp;\\n\\nimpl Solution {\\n    pub fn maximum_count(nums: Vec<i32>) -> i32 {\\n        let (mut pos, mut neg): (i32, i32) = (0, 0);\\n        \\n        for num in nums {\\n            if num > 0 {\\n                pos += 1;\\n            } else if num < 0 {\\n                neg += 1;\\n            }\\n        }\\n        return cmp::max(pos, neg) as i32;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017565,
                "title": "simple-and-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }\\n            else if(nums[i]>0){\\n                pos++;\\n            }\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int neg=0,pos=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }\\n            else if(nums[i]>0){\\n                pos++;\\n            }\\n        }\\n        return max(neg,pos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017349,
                "title": "faster-and-easy-to-understand-java-solution-tc-o-n",
                "content": "```\\nclass Solution {\\n    public int maximumCount(int[] arr) {\\n        long pos = 0;\\n        long neg = 0;\\n        \\n        for(int i=0;i<arr.length;++i){\\n            if(arr[i]>0){\\n                pos++;\\n            }else if(arr[i]<0){\\n                neg++;\\n            }\\n        }\\n        \\n        return (int)Math.max(pos,neg);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] arr) {\\n        long pos = 0;\\n        long neg = 0;\\n        \\n        for(int i=0;i<arr.length;++i){\\n            if(arr[i]>0){\\n                pos++;\\n            }else if(arr[i]<0){\\n                neg++;\\n            }\\n        }\\n        \\n        return (int)Math.max(pos,neg);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017286,
                "title": "c-one-line",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MaximumCount(int[] nums)\\n    {\\n        return Math.Max(nums.Count(n => n < 0), nums.Count(n => n > 0));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MaximumCount(int[] nums)\\n    {\\n        return Math.Max(nums.Count(n => n < 0), nums.Count(n => n > 0));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017273,
                "title": "c-optimized-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int counter=0,zeros=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                break;\\n            }\\n            else if(nums[i]<0){\\n                 counter++;\\n             }\\n            else{\\n                zeros++;\\n            }\\n        }     \\n      return max(counter,n-zeros-counter);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int counter=0,zeros=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                break;\\n            }\\n            else if(nums[i]<0){\\n                 counter++;\\n             }\\n            else{\\n                zeros++;\\n            }\\n        }     \\n      return max(counter,n-zeros-counter);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017240,
                "title": "c-simple-solution-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = 0, neg = 0;\\n        \\n        for(int ele : nums){\\n            if(ele > 0) pos++;\\n            else if(ele < 0) neg++;\\n        }\\n        \\n        return max(pos, neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = 0, neg = 0;\\n        \\n        for(int ele : nums){\\n            if(ele > 0) pos++;\\n            else if(ele < 0) neg++;\\n        }\\n        \\n        return max(pos, neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017208,
                "title": "straight-forward-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int p = 0, n = 0;\\n        for(int i : nums) {\\n            if(i > 0) p ++;\\n            else if(i < 0) n++;\\n        }\\n        return max(n, p);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int p = 0, n = 0;\\n        for(int i : nums) {\\n            if(i > 0) p ++;\\n            else if(i < 0) n++;\\n        }\\n        return max(n, p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017171,
                "title": "easy-java-solution-100-faster",
                "content": "- Time complexity: O(n)\\n\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        \\n        int pos=0;\\n        int neg=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0) neg++;\\n            if(nums[i]>0) pos++;\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        \\n        int pos=0;\\n        int neg=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0) neg++;\\n            if(nums[i]>0) pos++;\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017030,
                "title": "c-solution-contest-problem",
                "content": "Runtime: 20 ms, faster than 75.00% of C++ online submissions for Maximum Count of Positive Integer and Negative Integer.\\nMemory Usage: 17.4 MB, less than 8.33% of C++ online submissions for Maximum Count of Positive Integer and Negative Integer.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cpos=0;\\n        int cneg=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                cpos++;\\n            else if(nums[i]<0)\\n                cneg++;\\n            else\\n                continue;\\n        }\\n        return cpos>cneg?cpos:cneg;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cpos=0;\\n        int cneg=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)\\n                cpos++;\\n            else if(nums[i]<0)\\n                cneg++;\\n            else\\n                continue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3016942,
                "title": "efficient-solution-using-count",
                "content": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n        int neg = 0;\\n        for(int num : nums) {\\n            if(num > 0) pos++;\\n            else if(num < 0) neg++;\\n        }\\n        return Math.max(pos, neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n        int neg = 0;\\n        for(int num : nums) {\\n            if(num > 0) pos++;\\n            else if(num < 0) neg++;\\n        }\\n        return Math.max(pos, neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016874,
                "title": "binary-search-o-logn",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = 0\\n        r = n - 1\\n        \\n        \\n        while l <= r :\\n            mid = (l+r)//2\\n            mid_el = nums[mid]\\n            if mid_el >= 0:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n                \\n        l_left = l  \\n        \\n        l = 0\\n        r = n - 1\\n        \\n        \\n        while l <= r :\\n            mid = (l+r)//2\\n            mid_el = nums[mid]\\n            if mid_el > 0:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n                \\n        l_right = n - l\\n        \\n        return(max(l_left,l_right))\\n                                \\n        \\n                \\n        \\n            \\n                \\n                \\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = 0\\n        r = n - 1\\n        \\n        \\n        while l <= r :\\n            mid = (l+r)//2\\n            mid_el = nums[mid]\\n            if mid_el >= 0:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n                \\n        l_left = l  \\n        \\n        l = 0\\n        r = n - 1\\n        \\n        \\n        while l <= r :\\n            mid = (l+r)//2\\n            mid_el = nums[mid]\\n            if mid_el > 0:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n                \\n        l_right = n - l\\n        \\n        return(max(l_left,l_right))\\n                                \\n        \\n                \\n        \\n            \\n                \\n                \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016859,
                "title": "c-easy-solution-just-count-pos-neg",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int neg = 0;\\n        int pos = 0;\\n        int zero = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] > 0)\\n                pos++;\\n            if(nums[i]<0)\\n                neg++;\\n        }\\n        return max(pos, neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int neg = 0;\\n        int pos = 0;\\n        int zero = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] > 0)\\n                pos++;\\n            if(nums[i]<0)\\n                neg++;\\n        }\\n        return max(pos, neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016805,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int maximumCount(vector<int>&v) {\\n        ll p=0, n=0; // +ve & -ve\\n        for(ll it:v){\\n            if(it>0){\\n                ++p;\\n            }\\n            else if(it<0){\\n                ++n;\\n            }\\n        }\\n        return max(p, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int maximumCount(vector<int>&v) {\\n        ll p=0, n=0; // +ve & -ve\\n        for(ll it:v){\\n            if(it>0){\\n                ++p;\\n            }\\n            else if(it<0){\\n                ++n;\\n            }\\n        }\\n        return max(p, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016799,
                "title": "c-easy-to-understand-clean-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tint maximumCount(vector<int> &nums)\\n\\t{\\n\\t\\tint ct1 = 0, ct2 = 0;\\n\\t\\tfor (auto &x : nums)\\n\\t\\t{\\n\\t\\t\\tif (x > 0)\\n\\t\\t\\t\\tct1++;\\n\\t\\t\\tif (x < 0)\\n\\t\\t\\t\\tct2++;\\n\\t\\t}\\n\\t\\treturn max(ct1, ct2);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint maximumCount(vector<int> &nums)\\n\\t{\\n\\t\\tint ct1 = 0, ct2 = 0;\\n\\t\\tfor (auto &x : nums)\\n\\t\\t{\\n\\t\\t\\tif (x > 0)\\n\\t\\t\\t\\tct1++;\\n\\t\\t\\tif (x < 0)\\n\\t\\t\\t\\tct2++;\\n\\t\\t}\\n\\t\\treturn max(ct1, ct2);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016782,
                "title": "easy-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = 0, neg = 0;\\n        for(auto ele:nums){\\n            pos+=ele>0;\\n            neg+=ele<0;\\n        }\\n        return max(pos,neg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int pos = 0, neg = 0;\\n        for(auto ele:nums){\\n            pos+=ele>0;\\n            neg+=ele<0;\\n        }\\n        return max(pos,neg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016754,
                "title": "c-simple-traverse-and-count-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cntneg=0,cntpos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0 && nums[i] != 0)\\n            {\\n                cntneg++;\\n            }\\n            else if(nums[i] > 0 && nums[i] !=0)\\n            {\\n                cntpos++;\\n            }\\n        }\\n        return max(cntneg,cntpos);\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int cntneg=0,cntpos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0 && nums[i] != 0)\\n            {\\n                cntneg++;\\n            }\\n            else if(nums[i] > 0 && nums[i] !=0)\\n            {\\n                cntpos++;\\n            }\\n        }\\n        return max(cntneg,cntpos);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016717,
                "title": "6283-maximum-count-of-positive-integer-and-negative-integer-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n    int neg = 0;\\n    \\n    for (int num : nums) {\\n        if (num > 0) {\\n            pos++;\\n        } else if (num < 0) {\\n            neg++;\\n        }\\n    }\\n    \\n    return Math.max(pos, neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = 0;\\n    int neg = 0;\\n    \\n    for (int num : nums) {\\n        if (num > 0) {\\n            pos++;\\n        } else if (num < 0) {\\n            neg++;\\n        }\\n    }\\n    \\n    return Math.max(pos, neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098199,
                "title": "use-binary-serach-with-no-space-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   //Now find the last index of positive value;_minimum:\\n     int solve(vector<int> &nums){\\n         int low=0;;\\n         int high=nums.size()-1;\\n         while(low<=high){\\n             int mid = low+(high-low)/2;\\n             if(nums[mid]>0){\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n         }\\n         return low;\\n     }\\n\\n     //maximum idx of negative:\\n     int solve1(vector<int> &nums){\\n           int low=0;\\n           int high=nums.size()-1;\\n           while(low<=high){\\n               int mid = low+(high-low)/2;\\n               if(nums[mid]<0){\\n                   low=mid+1;\\n               }\\n               else{\\n                   high = mid-1;\\n               }\\n           }\\n           return high;\\n\\n     }\\n       \\n\\n    int maximumCount(vector<int>& nums) {\\n        int total= nums.size();\\n        //first index of positive;\\n        int positive_start= solve(nums);\\n        int positive = total-positive_start;\\n       \\n        //last index of negative\\n        int negative_idx = solve1(nums);\\n        return max(positive,negative_idx+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   //Now find the last index of positive value;_minimum:\\n     int solve(vector<int> &nums){\\n         int low=0;;\\n         int high=nums.size()-1;\\n         while(low<=high){\\n             int mid = low+(high-low)/2;\\n             if(nums[mid]>0){\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n         }\\n         return low;\\n     }\\n\\n     //maximum idx of negative:\\n     int solve1(vector<int> &nums){\\n           int low=0;\\n           int high=nums.size()-1;\\n           while(low<=high){\\n               int mid = low+(high-low)/2;\\n               if(nums[mid]<0){\\n                   low=mid+1;\\n               }\\n               else{\\n                   high = mid-1;\\n               }\\n           }\\n           return high;\\n\\n     }\\n       \\n\\n    int maximumCount(vector<int>& nums) {\\n        int total= nums.size();\\n        //first index of positive;\\n        int positive_start= solve(nums);\\n        int positive = total-positive_start;\\n       \\n        //last index of negative\\n        int negative_idx = solve1(nums);\\n        return max(positive,negative_idx+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098184,
                "title": "binary-search-c-o-log-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   //Now find the last index of positive value;_minimum:\\n     int solve(vector<int> &nums){\\n         int low=0;;\\n         int high=nums.size()-1;\\n         while(low<=high){\\n             int mid = low+(high-low)/2;\\n             if(nums[mid]>=1){\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n         }\\n         return low;\\n     }\\n\\n\\n    int maximumCount(vector<int>& nums) {\\n        int total= nums.size();\\n        //cnt positive;\\n        int positive_start= solve(nums);\\n        int positive = total-positive_start;\\n        int cnt_zero=0;\\n        for(auto x : nums){\\n            if(x==0){\\n                cnt_zero++;\\n            }\\n        }\\n        int negative = total-positive-cnt_zero;\\n        return max(positive,negative);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   //Now find the last index of positive value;_minimum:\\n     int solve(vector<int> &nums){\\n         int low=0;;\\n         int high=nums.size()-1;\\n         while(low<=high){\\n             int mid = low+(high-low)/2;\\n             if(nums[mid]>=1){\\n                 high=mid-1;\\n             }\\n             else{\\n                 low=mid+1;\\n             }\\n         }\\n         return low;\\n     }\\n\\n\\n    int maximumCount(vector<int>& nums) {\\n        int total= nums.size();\\n        //cnt positive;\\n        int positive_start= solve(nums);\\n        int positive = total-positive_start;\\n        int cnt_zero=0;\\n        for(auto x : nums){\\n            if(x==0){\\n                cnt_zero++;\\n            }\\n        }\\n        int negative = total-positive-cnt_zero;\\n        return max(positive,negative);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098020,
                "title": "simple-one-line-solution",
                "content": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums, 0), len(nums)-bisect_right(nums, 0))     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        return max(bisect_left(nums, 0), len(nums)-bisect_right(nums, 0))     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095331,
                "title": "beat-85-of-users",
                "content": "# Intuition\\nThis is because the code first performs a sorting operation using the sort() method, which has a time complexity of O(n log n). \\n\\nAfter the sorting operation, the code iterates over the sorted array once to separate positive and negative numbers. This iteration has a time complexity of O(n). \\n\\nFinally, the code calls the Math.max() function, which compares the lengths of the pos and neg arrays. This operation has a constant time complexity of O(1).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:    \\n\\n    *O(n logn)*\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let pos = [];\\n    let neg = [];\\n\\n    for(let i = 0; i< nums.length; i++) {\\n        if(nums[i] > 0){\\n            pos.push(nums[i]);\\n        } if(nums[i] < 0){\\n            neg.push(nums[i]);\\n        } \\n        else continue;\\n    }\\n\\n    return Math.max(pos.length,neg.length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let pos = [];\\n    let neg = [];\\n\\n    for(let i = 0; i< nums.length; i++) {\\n        if(nums[i] > 0){\\n            pos.push(nums[i]);\\n        } if(nums[i] < 0){\\n            neg.push(nums[i]);\\n        } \\n        else continue;\\n    }\\n\\n    return Math.max(pos.length,neg.length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093072,
                "title": "java-beginner-friendly-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n      int pos_count = 0;\\n      int neg_count = 0;\\n\\n      for(int i  = 0; i < nums.length; i++){\\n          if(nums[i] > 0){\\n              pos_count++;\\n          }\\n          else if(nums[i] < 0){\\n              neg_count++;\\n          }\\n      }  \\n      return (pos_count > neg_count) ? pos_count : neg_count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n      int pos_count = 0;\\n      int neg_count = 0;\\n\\n      for(int i  = 0; i < nums.length; i++){\\n          if(nums[i] > 0){\\n              pos_count++;\\n          }\\n          else if(nums[i] < 0){\\n              neg_count++;\\n          }\\n      }  \\n      return (pos_count > neg_count) ? pos_count : neg_count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092458,
                "title": "best-for-beginners-100-better-than-others-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos=0;\\n        int neg=0;\\n        int n=nums.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                neg++;\\n            }\\n            if(nums[i]>0)\\n            {\\n                pos++;\\n            }\\n        }\\n        if(pos>neg)\\n        {\\n            return pos;\\n        }\\n        else\\n        {\\n            return neg;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos=0;\\n        int neg=0;\\n        int n=nums.length;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                neg++;\\n            }\\n            if(nums[i]>0)\\n            {\\n                pos++;\\n            }\\n        }\\n        if(pos>neg)\\n        {\\n            return pos;\\n        }\\n        else\\n        {\\n            return neg;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091178,
                "title": "not-the-best-approach-but-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int posint =0; int negint=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                posint++;\\n            }\\n            else if(nums[i]<0){\\n                negint++;\\n            }\\n        } if(posint>=negint){\\n            return posint;\\n        }else \\n        return negint;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int posint =0; int negint=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                posint++;\\n            }\\n            else if(nums[i]<0){\\n                negint++;\\n            }\\n        } if(posint>=negint){\\n            return posint;\\n        }else \\n        return negint;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091008,
                "title": "python-one-liner-solution",
                "content": "# Intuition\\nThought was to take the Len of all of the positve and a negative number and return the max\\n\\n# Approach\\n1. Create a list of the Nums > 1 and create a list of the Nums < -1\\n2. Take the len of both list\\n3. return the max of the list \\n\\n# Complexity\\n- Time complexity:\\n109 ms \\n- Space complexity:\\n16.56 mb\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: list[int]) -> int:\\n        return max([len([num for num in nums if num >= 1])], [len([num for num in nums if num <= -1])])[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: list[int]) -> int:\\n        return max([len([num for num in nums if num >= 1])], [len([num for num in nums if num <= -1])])[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090327,
                "title": "c-easy-solution",
                "content": "first we need to sort the array.\\nAfter that we need to apply 3 condition.\\n1)if nums[i]=0,we will not count it.\\n2)else if nums[i]>0;,we need to count the positive number in an array.\\n3)else if nums[i]<0,count the negative number in an array.\\nThen, find the max of positive and negatiive number in an array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size();\\n        int pcount=0;\\n        int ncount=0;\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n-i;j++){\\n               if(nums[i]>nums[j]){\\n                   int temp=nums[i];\\n                   nums[i]=nums[j];\\n                   nums[j]=temp;}} }\\n         for(int i=0;i<n;i++){\\n             if(nums[i]==0){\\n                 continue;\\n             }\\n            else if(nums[i]>0){\\n           pcount++;\\n             } \\n             else if(nums[i]<0){\\n           ncount++;\\n             }\\n             }\\n return max(pcount,ncount);         \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int n=nums.size();\\n        int pcount=0;\\n        int ncount=0;\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n-i;j++){\\n               if(nums[i]>nums[j]){\\n                   int temp=nums[i];\\n                   nums[i]=nums[j];\\n                   nums[j]=temp;}} }\\n         for(int i=0;i<n;i++){\\n             if(nums[i]==0){\\n                 continue;\\n             }\\n            else if(nums[i]>0){\\n           pcount++;\\n             } \\n             else if(nums[i]<0){\\n           ncount++;\\n             }\\n             }\\n return max(pcount,ncount);         \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087189,
                "title": "easiest-approach-available-on-the-internet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        ArrayList<Integer> neg = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0) pos.add(nums[i]);\\n            if(nums[i] > 0) neg.add(nums[i]);\\n        }\\n        int max = Math.max(neg.size(),pos.size());\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        ArrayList<Integer> neg = new ArrayList<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0) pos.add(nums[i]);\\n            if(nums[i] > 0) neg.add(nums[i]);\\n        }\\n        int max = Math.max(neg.size(),pos.size());\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083449,
                "title": "java-solution-using-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n-1;\\n        int pos=0;\\n        int neg=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]>0){\\n                pos += high-mid+1;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]<0){\\n                neg += mid-low+1;\\n                low=mid+1;\\n            }\\n            else if(nums[mid]==0){\\n                int start=mid;\\n                while(start<=high && nums[start]==0){\\n                    start++;\\n                }\\n                pos+=high-start+1;\\n                high=mid-1;\\n            }\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n-1;\\n        int pos=0;\\n        int neg=0;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            if(nums[mid]>0){\\n                pos += high-mid+1;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]<0){\\n                neg += mid-low+1;\\n                low=mid+1;\\n            }\\n            else if(nums[mid]==0){\\n                int start=mid;\\n                while(start<=high && nums[start]==0){\\n                    start++;\\n                }\\n                pos+=high-start+1;\\n                high=mid-1;\\n            }\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078493,
                "title": "another-option",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int n = nums.length;\\n        int i = 0;\\n        int count0 = 0;\\n\\n        while (i < n) {\\n          if (nums[i] == 0) {\\n              count0++;\\n          }\\n\\n          if (nums[i] > 0) {\\n            int neg = i - count0;\\n            int pos = n - count0 - neg;\\n            \\n            return pos > neg ? pos : neg;\\n          }\\n          \\n          i++;\\n        }\\n\\n        return count0 == n ? 0 : i - count0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int n = nums.length;\\n        int i = 0;\\n        int count0 = 0;\\n\\n        while (i < n) {\\n          if (nums[i] == 0) {\\n              count0++;\\n          }\\n\\n          if (nums[i] > 0) {\\n            int neg = i - count0;\\n            int pos = n - count0 - neg;\\n            \\n            return pos > neg ? pos : neg;\\n          }\\n          \\n          i++;\\n        }\\n\\n        return count0 == n ? 0 : i - count0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077999,
                "title": "binary-search-java-in-o-log-n-100-faster",
                "content": "\\n# Approach\\nSince it is given that array is sorted, \\nwe can count the number of negative and positive elements using binary search.\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = countPositives(nums, nums.length);\\n        int neg = countNegatives(nums, nums.length);\\n        \\n        return Math.max(pos, neg);\\n    }\\n\\n    public int countPositives(int[] A, int n){\\n        int i = 0, j = n - 1;\\n        while(i <= j){\\n            int mid = (i + j)/2;\\n            if(A[mid] > 0){\\n                if(mid - 1 >= 0){\\n                    if(A[mid - 1] == 0 || A[mid - 1] < 0){\\n                        return n - mid;\\n                    }else{\\n                        j = mid - 1;\\n                    }\\n                }else{\\n                    return n;\\n                }\\n            }else{\\n                if(mid + 1 < n){\\n                    if(A[mid + 1] > 0){\\n                        return n - mid - 1;\\n                    }else{\\n                        i = mid + 1;\\n                    }\\n                }else{\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    public int countNegatives(int[] A, int n){\\n        int i = 0, j = n - 1;\\n        while(i <= j){\\n            int mid = (i + j)/2;\\n            if(A[mid] >= 0){\\n                if(mid - 1 >= 0){\\n                    if(A[mid - 1] >= 0){\\n                        j = mid - 1;\\n                    }else{\\n                        return mid;\\n                    }\\n                }else{\\n                    return 0;\\n                }\\n            }else{\\n                if(mid + 1 < n){\\n                    if(A[mid + 1] >= 0){\\n                        return mid + 1;\\n                    }else{\\n                        i = mid + 1;\\n                    }\\n                }else{\\n                    return n;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos = countPositives(nums, nums.length);\\n        int neg = countNegatives(nums, nums.length);\\n        \\n        return Math.max(pos, neg);\\n    }\\n\\n    public int countPositives(int[] A, int n){\\n        int i = 0, j = n - 1;\\n        while(i <= j){\\n            int mid = (i + j)/2;\\n            if(A[mid] > 0){\\n                if(mid - 1 >= 0){\\n                    if(A[mid - 1] == 0 || A[mid - 1] < 0){\\n                        return n - mid;\\n                    }else{\\n                        j = mid - 1;\\n                    }\\n                }else{\\n                    return n;\\n                }\\n            }else{\\n                if(mid + 1 < n){\\n                    if(A[mid + 1] > 0){\\n                        return n - mid - 1;\\n                    }else{\\n                        i = mid + 1;\\n                    }\\n                }else{\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    public int countNegatives(int[] A, int n){\\n        int i = 0, j = n - 1;\\n        while(i <= j){\\n            int mid = (i + j)/2;\\n            if(A[mid] >= 0){\\n                if(mid - 1 >= 0){\\n                    if(A[mid - 1] >= 0){\\n                        j = mid - 1;\\n                    }else{\\n                        return mid;\\n                    }\\n                }else{\\n                    return 0;\\n                }\\n            }else{\\n                if(mid + 1 < n){\\n                    if(A[mid + 1] >= 0){\\n                        return mid + 1;\\n                    }else{\\n                        i = mid + 1;\\n                    }\\n                }else{\\n                    return n;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077013,
                "title": "javascript-solution-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    let positive=0,negative=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]<0)\\n        negative++;\\n        else if(nums[i]>0)\\n        positive++;\\n    }\\n    return positive>negative ? positive : negative;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumCount = function(nums) {\\n    let positive=0,negative=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]<0)\\n        negative++;\\n        else if(nums[i]>0)\\n        positive++;\\n    }\\n    return positive>negative ? positive : negative;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075751,
                "title": "java-0ms-runtime-binary-search",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n        int neg = 0;\\n        int pos = 0;\\n        int numZero=0;\\n\\n        if (lo == hi && nums[lo] == 0) {\\n            return 0;\\n        }\\n\\n        while (lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n\\n            if (nums[mid] < 0) {\\n                neg = mid + 1;\\n                lo = mid + 1;\\n            } else if (nums[mid] > 0) {\\n                pos += hi - mid + 1;\\n                hi = mid - 1;\\n            } else {\\n                neg=mid+1;\\n                numZero+=countZeros(nums,lo,mid);\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return Math.max(pos, neg - numZero);\\n    }\\n    public int countZeros(int[] nums, int lo, int hi){\\n        int zero=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(nums[mid]==0){\\n                zero+=hi-mid+1;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return zero;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n        int neg = 0;\\n        int pos = 0;\\n        int numZero=0;\\n\\n        if (lo == hi && nums[lo] == 0) {\\n            return 0;\\n        }\\n\\n        while (lo <= hi) {\\n            int mid = (lo + hi) / 2;\\n\\n            if (nums[mid] < 0) {\\n                neg = mid + 1;\\n                lo = mid + 1;\\n            } else if (nums[mid] > 0) {\\n                pos += hi - mid + 1;\\n                hi = mid - 1;\\n            } else {\\n                neg=mid+1;\\n                numZero+=countZeros(nums,lo,mid);\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        return Math.max(pos, neg - numZero);\\n    }\\n    public int countZeros(int[] nums, int lo, int hi){\\n        int zero=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(nums[mid]==0){\\n                zero+=hi-mid+1;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return zero;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075618,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximumCount(_ nums: [Int]) -> Int {\\n    let pos = nums.filter {$0 > 0}.count\\n    let neg = nums.filter {$0 < 0}.count\\n    \\n    return max(pos, neg)\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumCount(_ nums: [Int]) -> Int {\\n    let pos = nums.filter {$0 > 0}.count\\n    let neg = nums.filter {$0 < 0}.count\\n    \\n    return max(pos, neg)\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072869,
                "title": "linear-search-approach",
                "content": "# Intuition\\nbest and simple approach..\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                a++;\\n            }\\n            if(nums[i]>0){\\n                b++;\\n            }\\n              }\\n            return Math.max(a,b);\\n        }\\n    public void main(String args[]){\\n        int nums[] = {-2,-1,-1,1,2,3};\\n        int maximum = maximumCount(nums);\\n        System.out.println(maximum);\\n    }\\n}\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                a++;\\n            }\\n            if(nums[i]>0){\\n                b++;\\n            }\\n              }\\n            return Math.max(a,b);\\n        }\\n    public void main(String args[]){\\n        int nums[] = {-2,-1,-1,1,2,3};\\n        int maximum = maximumCount(nums);\\n        System.out.println(maximum);\\n    }\\n}\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072115,
                "title": "beats-100-with-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos=0;\\n        int neg=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<0) neg++;\\n            if(nums[i]>0) pos++;\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pos=0;\\n        int neg=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<0) neg++;\\n            if(nums[i]>0) pos++;\\n        }\\n        return Math.max(pos,neg);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071117,
                "title": "99-runtime-96-memory-binary-search-solution-o-logn-o-1",
                "content": "![image.png](https://assets.leetcode.com/users/images/a481e498-c515-43f8-87d3-23aa1bd8102a_1695275481.552262.png)\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        if nums[0] > 0 or nums[-1] < 0: return len(nums)\\n\\n        length = len(nums) - 1; l, r = 0, length\\n\\n        while l <= r:\\n            m = (l + r) // 2\\n\\n            if nums[m] >= 0: r = m - 1\\n            else: l = m + 1\\n\\n        left_zero_idx = l; l, r = 0, length\\n\\n        while l <= r:\\n            m = (l + r + 1) // 2\\n\\n            if nums[m] <= 0: l = m + 1\\n            else: r = m - 1\\n\\n        return max(left_zero_idx, length - l + 1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        if nums[0] > 0 or nums[-1] < 0: return len(nums)\\n\\n        length = len(nums) - 1; l, r = 0, length\\n\\n        while l <= r:\\n            m = (l + r) // 2\\n\\n            if nums[m] >= 0: r = m - 1\\n            else: l = m + 1\\n\\n        left_zero_idx = l; l, r = 0, length\\n\\n        while l <= r:\\n            m = (l + r + 1) // 2\\n\\n            if nums[m] <= 0: l = m + 1\\n            else: r = m - 1\\n\\n        return max(left_zero_idx, length - l + 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070362,
                "title": "2529-maximum-count-of-positive-integer-and-negative-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int neg=0,pov=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0) neg++;\\n            else if(nums[i]>0) pov++;\\n        }\\n        return (Math.max(neg,pov));\\n\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int neg=0,pov=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0) neg++;\\n            else if(nums[i]>0) pov++;\\n        }\\n        return (Math.max(neg,pov));\\n\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068773,
                "title": "maximum-count-of-positive-and-negative-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int countpositive=0;\\n        int countnegative=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                countpositive++;\\n            }\\n            if(nums[i]<0){\\n                countnegative++;\\n            }\\n\\n        }\\n        return max(countpositive, countnegative);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCount(vector<int>& nums) {\\n        int countpositive=0;\\n        int countnegative=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0){\\n                countpositive++;\\n            }\\n            if(nums[i]<0){\\n                countnegative++;\\n            }\\n\\n        }\\n        return max(countpositive, countnegative);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068604,
                "title": "python3-3-lines-nlog-n-binary-search-beats-97-5",
                "content": "# Intuition\\nwe need to find where is the end of negative numbers and the start of positive numbers.\\n\\n# Complexity\\n- Time complexity:\\nolog(n)\\n\\n\\n# Code\\n```\\nfrom typing import List\\nimport bisect\\n\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg_to = bisect.bisect_left(nums, 0)\\n        pos_from = bisect.bisect_right(nums, 0)\\n        return max(neg_to, len(nums) - pos_from)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nimport bisect\\n\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        neg_to = bisect.bisect_left(nums, 0)\\n        pos_from = bisect.bisect_right(nums, 0)\\n        return max(neg_to, len(nums) - pos_from)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066906,
                "title": "easy-python-solution-python",
                "content": "# EASY PYTHON SOLUTION || PYTHON || \\u2705\\u2705\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        posCount = 0\\n        negCount = 0\\n    \\n        for i in nums:\\n            if i<0:\\n                negCount+=1\\n            elif i>0:\\n                posCount+=1\\n    \\n        return max(negCount,posCount)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        posCount = 0\\n        negCount = 0\\n    \\n        for i in nums:\\n            if i<0:\\n                negCount+=1\\n            elif i>0:\\n                posCount+=1\\n    \\n        return max(negCount,posCount)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062946,
                "title": "java-brute-force-optimal-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- find out the negative and positive number count and return max.\\n- input is sorted hence we can try for binary search is applicable or not.\\n\\n---\\n\\n## Approach1\\n- use for loop and count the +ve and -ve numbers and then return the max from both\\n\\n# Complexity\\n- Time complexity: o(n)\\n- Space complexity: o(1)\\n\\n---\\n\\n\\n## Approach2\\n- find the minimum positive number.\\n- subtract the count of zero from remaining ones then we will get count of -ve numbers.\\n- return the max from +ve and -ve numbers.\\n\\n# Complexity\\n- Time complexity: o(log n)\\n- Space complexity: o(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int bruteForce(int[] nums){\\n        int positive = 0;\\n        int negative = 0;\\n        for(int num : nums){\\n            if(num < 0){\\n                negative += 1;\\n            }else if(num > 0){\\n                positive += 1;\\n            }\\n        }\\n        return Math.max(positive , negative);\\n    }\\n\\n    public int binarySearch(int[] nums){\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int index = 0;\\n        //find minimum +ve number\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(nums[mid] <= 0){\\n                low = mid + 1;\\n                index = low;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n\\n        if(index > nums.length) return 0;\\n        int position = index;\\n        int countOfZero = 0;\\n        //count zeros\\n        for(int i = position-1 ; i >= 0; i--){\\n            if(nums[i] == 0){\\n                countOfZero += 1;\\n            }\\n        }\\n        int negativeNumber = position - countOfZero;\\n        int positiveNumber = nums.length  - position;\\n        return Math.max(negativeNumber, positiveNumber);\\n    }\\n\\n    public int maximumCount(int[] nums) {\\n        return maxCount2(nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int bruteForce(int[] nums){\\n        int positive = 0;\\n        int negative = 0;\\n        for(int num : nums){\\n            if(num < 0){\\n                negative += 1;\\n            }else if(num > 0){\\n                positive += 1;\\n            }\\n        }\\n        return Math.max(positive , negative);\\n    }\\n\\n    public int binarySearch(int[] nums){\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int index = 0;\\n        //find minimum +ve number\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(nums[mid] <= 0){\\n                low = mid + 1;\\n                index = low;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n\\n        if(index > nums.length) return 0;\\n        int position = index;\\n        int countOfZero = 0;\\n        //count zeros\\n        for(int i = position-1 ; i >= 0; i--){\\n            if(nums[i] == 0){\\n                countOfZero += 1;\\n            }\\n        }\\n        int negativeNumber = position - countOfZero;\\n        int positiveNumber = nums.length  - position;\\n        return Math.max(negativeNumber, positiveNumber);\\n    }\\n\\n    public int maximumCount(int[] nums) {\\n        return maxCount2(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060727,
                "title": "efficient-binary-search-o-logn",
                "content": "# Approach\\n1. Count the first index of negative integer\\n2. Find the no. of leading zeros after the first index of negative integer\\n3. Find the maximum in both\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int i = 0, j = nums.length - 1, ans = -1;\\n\\n        while(i <= j) {\\n            int mid = j + (i - j) / 2;\\n\\n            if(nums[mid] < 0) {\\n                ans = mid;\\n                i = mid + 1;\\n            }\\n            else if(nums[mid] >= 0) j = mid - 1;\\n        }\\n        \\n        int idxOfPos = ans + 1;\\n        while(idxOfPos < nums.length && nums[idxOfPos] == 0) idxOfPos++;\\n\\n        return Math.max(ans + 1, nums.length - idxOfPos);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int i = 0, j = nums.length - 1, ans = -1;\\n\\n        while(i <= j) {\\n            int mid = j + (i - j) / 2;\\n\\n            if(nums[mid] < 0) {\\n                ans = mid;\\n                i = mid + 1;\\n            }\\n            else if(nums[mid] >= 0) j = mid - 1;\\n        }\\n        \\n        int idxOfPos = ans + 1;\\n        while(idxOfPos < nums.length && nums[idxOfPos] == 0) idxOfPos++;\\n\\n        return Math.max(ans + 1, nums.length - idxOfPos);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059763,
                "title": "0ms-beats-100-simple-beginner-level-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmax of count of positive and negative numbers\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nimport java.lang.Math;\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pc=0;\\n        int nc=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                pc++;\\n            }\\n            else if(nums[i]<0){\\n                nc++;\\n            }\\n        }\\n        return Math.max(pc,nc);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.lang.Math;\\nclass Solution {\\n    public int maximumCount(int[] nums) {\\n        int pc=0;\\n        int nc=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                pc++;\\n            }\\n            else if(nums[i]<0){\\n                nc++;\\n            }\\n        }\\n        return Math.max(pc,nc);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1747237,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1863401,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1772940,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1751627,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 2075168,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 2061690,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 2047622,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1933185,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1919978,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1872793,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1747237,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1863401,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1772940,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1751627,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 2075168,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 2061690,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 2047622,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1933185,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1919978,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            },
            {
                "id": 1872793,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Hint says binary search anyone tried that? lol"
                    },
                    {
                        "username": "Msey",
                        "content": "> Follow up: Can you solve the problem in O(log(n)) time complexity?\n\nwe have no choice haha"
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3367168/java-easier-approach-binary-search-o-logn/\\n\\nYou can check here for detailed explaination and binary approach"
                    },
                    {
                        "username": "NI94",
                        "content": "https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3157742/by-binary-search-logn-c/"
                    },
                    {
                        "username": "narie-monarie",
                        "content": "lol"
                    },
                    {
                        "username": "Robin_Chen",
                        "content": "```pyhton3\nclass Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        l, r = 0, len(nums)\n        while l < r:\n            m = l + (r - l)//2\n            if nums[m] >= 0:\n                r = m\n            else:\n                l = m + 1\n        fl = l\n\n        l, r = fl, len(nums)\n        while l < r:\n            m = l + (r-l)//2\n            if nums[m] > 0:\n                r = m\n            else:\n                l = m + 1\n        fr = l\n\n        return max(fl, len(nums) - fr)\n```"
                    },
                    {
                        "username": "TinyHoneyCup",
                        "content": "Yes, check out my solution! :)\\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3017009/c-o-logn-explanation/"
                    },
                    {
                        "username": "samannway1",
                        "content": "hell nah xD"
                    },
                    {
                        "username": "sakshit7",
                        "content": "Everyone seems to be using 2 binary search loops, can we do it in one?? Anyone ?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Same question.\nAnd I guess I've found one such approach.\nThe only thing - it fails last test for Python :))\n*163 / 164 testcases passed*\n\nhttps://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/3381525/100-accepted-binary-search-solution-in-java-c-and-python3-passed-all-164-test-cases/"
                    },
                    {
                        "username": "sivasagar1909",
                        "content": "class Solution {\\n    public int maximumCount(int[] nums) {\\n        int nc=0,pc=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(nums[i]>0)\\n                pc++;\\n            else if(nums[i]<0)\\n                nc++;\\n        }\\n        return Math.max(nc,pc);\\n    }\\n}"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "The Solution wriiten here by you will work absolutely. but it is a brute force approach. were you traverse each node. means in O(n) time complexity. can do it in O(logn) time?"
                    },
                    {
                        "username": "shandilyarakshit",
                        "content": "you can use lower_bound and upper_bound concept of stl containers to solve this problem in no time and less number of lines "
                    },
                    {
                        "username": "michaelszer",
                        "content": "yep or bisect in python."
                    },
                    {
                        "username": "peterblockman",
                        "content": "This problem can be solved with linear search. However, if we choose to use binary search, we will need 2 loops:\\n\\n- The first loop is used to find the minimum value of \\'left\\' where nums[left] > 0.\\n- The second loop is used to find the maximum value of \\'left\\' where nums[left - 1] < 0"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": "HINT:********************************\\ni will give one hint find the last index of neg number and first index of pos number then you the answer is in your hands."
                    },
                    {
                        "username": "davidashish1996",
                        "content": "How we can use the concept of lower & upper bound is it we are finding those places which are nearer to the middle element??"
                    },
                    {
                        "username": "bishal_tu",
                        "content": "For input having all zeros with no positive or negative integers, the result is number of zeroes.\\n\\neg\\n\\n[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\nThe expected output is 500. Can anyone explain?\\n\\nIn the description, its mentioned, 0 is neither positive or negative\\n"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly\\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number\\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    },
                    {
                        "username": "r_aryan_12",
                        "content": "why this question did not take binary search solution"
                    },
                    {
                        "username": "buckyalita",
                        "content": "Check once again \\nI tried using Binary search and it works \\uD83D\\uDE4C"
                    },
                    {
                        "username": "bangychiller",
                        "content": "i added a custom testcase :- [0,0,0,1,2,3] , which gives wrong answer for my result , the reason being  if no negative numbers are found , then i just return the size of the array as the result. But while submitting the code i didn\\'t found such a testcase and my answer was passed . \\nRefer to this submission for the code :- https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/submissions/938913341/"
                    },
                    {
                        "username": "buckyalita",
                        "content": "If you read the question properly \\nit ask for positive number and in this question zero \\'0\\' is not treated as positive number \\nso if there is no negative number present try to return the no. of element which is greater than 0 that means for you input answer will be 3.\\n\\nHope this will help \\uD83D\\uDE4C"
                    }
                ]
            }
        ]
    }
]