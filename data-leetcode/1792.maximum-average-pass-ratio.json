[
    {
        "title": "Maximum Average Pass Ratio",
        "question_content": "There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.\nYou are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.\nThe pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.\nReturn the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.\n&nbsp;\nExample 1:\n\nInput: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\nOutput: 0.78333\nExplanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.\n\nExample 2:\n\nInput: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4\nOutput: 0.53485\n\n&nbsp;\nConstraints:\n\n\t1 <= classes.length <= 105\n\tclasses[i].length == 2\n\t1 <= passi <= totali <= 105\n\t1 <= extraStudents <= 105",
        "solutions": [
            {
                "id": 1108305,
                "title": "c-greedy-max-heap-o-m-log-n",
                "content": "How much of profit in score can we get if we add one extra student to a particular class? Send an extra student to the class with the most profit; repeat till you run out of students.\\n\\nLet\\'s track profits for all classes in a max heap. While we still have extra students, we pick a class that gives us the maximum profit, add a student, calculate new profit and put it back to the heap.\\n\\nTo avoid iterating through the max heap in the end, we can track the total score as we go.\\n\\n**C++**\\n```cpp\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n    auto profit = [&](double pass, double total) {\\n        return (pass + 1) / (total + 1) - pass / total;\\n    };\\n    double total = 0;\\n    priority_queue<pair<double, array<int, 2>>> pq;\\n    for (auto &c : classes) {\\n        total += (double) c[0] / c[1];\\n        pq.push({profit(c[0], c[1]), {c[0], c[1]}});\\n    }\\n    while (extraStudents--) {\\n        auto [added_profit, c] = pq.top(); pq.pop();\\n        total += added_profit;\\n        pq.push({profit(c[0] + 1, c[1] + 1), {c[0] + 1, c[1] + 1}});\\n    }\\n    return total / classes.size();\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(m log n), where n and m are the number of classes and extra students.\\n\\t- Caveat: the complexity for the code above is O((n + m) log n). To achieve O(m log n), we need construct the heap in O(n), e.g. by using `make_heap`.\\n\\t- For the purpose of complexity analsyis, I assume that we build the initial heap in O(n).\\n- Memory: O(n) to hold the information about classes.\\n",
                "solutionTags": [],
                "code": "```cpp\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n    auto profit = [&](double pass, double total) {\\n        return (pass + 1) / (total + 1) - pass / total;\\n    };\\n    double total = 0;\\n    priority_queue<pair<double, array<int, 2>>> pq;\\n    for (auto &c : classes) {\\n        total += (double) c[0] / c[1];\\n        pq.push({profit(c[0], c[1]), {c[0], c[1]}});\\n    }\\n    while (extraStudents--) {\\n        auto [added_profit, c] = pq.top(); pq.pop();\\n        total += added_profit;\\n        pq.push({profit(c[0] + 1, c[1] + 1), {c[0] + 1, c[1] + 1}});\\n    }\\n    return total / classes.size();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108263,
                "title": "python-java-max-heap-clean-concise",
                "content": "**Idea**\\n- How much profit we can get if we add one `extraStudents` to a particular class `(pass, total`)? This profit can be defined as: `(pass+1)/(total+1) - pass/total`.\\n- For each student from `extraStudents`, we try to add to a class which will increase its profit maximum.\\n- We can use `maxHeap` structure which can give us the class which has maximum profit after adding.\\n\\n**Complexity:**\\n- Time: \\n\\t- Python: `O(M*logN + N)`, where `M` is `extraStudents` and `N` is number of classes.\\n\\t- Java: `O(M*logN + N*logN)`\\n- Space: `O(N)`\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def maxAverageRatio(self, classes, extraStudents):\\n        def profit(a, b):\\n            return (a + 1) / (b + 1) - a / b\\n\\n        maxHeap = []\\n        for a, b in classes:\\n            a, b = a * 1.0, b * 1.0  # Convert int to double\\n            maxHeap.append((-profit(a, b), a, b))\\n        heapq.heapify(maxHeap)  # Heapify maxHeap cost O(N)\\n\\n        for _ in range(extraStudents):\\n            d, a, b = heapq.heappop(maxHeap)\\n            heapq.heappush(maxHeap, (-profit(a + 1, b + 1), a + 1, b + 1))\\n\\n        return sum(a / b for d, a, b in maxHeap) / len(classes)\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> maxHeap = new PriorityQueue<>(Comparator.comparingDouble(o -> -o[0])); // Max heap compared by first value in decreasing order.\\n        for (int[] c : classes) {\\n            double a = c[0], b = c[1];\\n            maxHeap.offer(new double[]{profit(a, b), a, b});\\n        }\\n        while (extraStudents-- > 0) {\\n            double[] top = maxHeap.poll();\\n            double a = top[1], b = top[2];\\n            maxHeap.offer(new double[]{profit(a+1, b+1), a+1, b+1});\\n        }\\n        double ans = 0.0d;\\n        while (!maxHeap.isEmpty()) {\\n            double[] top = maxHeap.poll();\\n            double a = top[1], b = top[2];\\n            ans += a/b;\\n        }\\n        return ans / classes.length;\\n    }\\n    double profit(double a, double b) {\\n        return (a + 1) / (b + 1) - a / b;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxAverageRatio(self, classes, extraStudents):\\n        def profit(a, b):\\n            return (a + 1) / (b + 1) - a / b\\n\\n        maxHeap = []\\n        for a, b in classes:\\n            a, b = a * 1.0, b * 1.0  # Convert int to double\\n            maxHeap.append((-profit(a, b), a, b))\\n        heapq.heapify(maxHeap)  # Heapify maxHeap cost O(N)\\n\\n        for _ in range(extraStudents):\\n            d, a, b = heapq.heappop(maxHeap)\\n            heapq.heappush(maxHeap, (-profit(a + 1, b + 1), a + 1, b + 1))\\n\\n        return sum(a / b for d, a, b in maxHeap) / len(classes)\\n```\n```java\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> maxHeap = new PriorityQueue<>(Comparator.comparingDouble(o -> -o[0])); // Max heap compared by first value in decreasing order.\\n        for (int[] c : classes) {\\n            double a = c[0], b = c[1];\\n            maxHeap.offer(new double[]{profit(a, b), a, b});\\n        }\\n        while (extraStudents-- > 0) {\\n            double[] top = maxHeap.poll();\\n            double a = top[1], b = top[2];\\n            maxHeap.offer(new double[]{profit(a+1, b+1), a+1, b+1});\\n        }\\n        double ans = 0.0d;\\n        while (!maxHeap.isEmpty()) {\\n            double[] top = maxHeap.poll();\\n            double a = top[1], b = top[2];\\n            ans += a/b;\\n        }\\n        return ans / classes.length;\\n    }\\n    double profit(double a, double b) {\\n        return (a + 1) / (b + 1) - a / b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108372,
                "title": "c-explained-priority-queue-greedy-solution-find-the-delta",
                "content": "There are few incorrect approaches:\\n1. Choosing the smallest class size\\n2. Choosing the smallest pass size\\n3. Choosing the least pass ratio\\n\\nInstead, the correct approach is:\\n**Find the difference**, namely the delta. \\n\\nFor example, even though `1/2` and `10/20` has the same ratio. However, `1/2`\\'s delta is equal to `(1+1)/(2+1)-1/2`, which is much greater than `(10+1)/(20+1)-10/20`. \\n\\nTherefore, we always greedily select the one with the greatest delta.\\n\\nWe can acheive this using a max heap. In C++, we can use the **priority queue**.\\n\\n[C++]: \\n\\n```\\nstruct cmp{\\n    bool operator()(pair<int,int> a, pair<int,int> b){\\n        double ad = (a.first+1)/(double)(a.second+1) - (a.first)/(double)a.second;\\n        double bd = (b.first+1)/(double)(b.second+1) - (b.first)/(double)b.second;\\n        return ad < bd;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double acc = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> que;\\n        for(vector<int> i: classes)\\n            que.push(make_pair(i[0],i[1]));\\n        while(extraStudents--){\\n            pair<int,int> cur = que.top(); que.pop();\\n            cur.first++, cur.second++;\\n            que.push(cur);\\n        }\\n        while(!que.empty()){\\n            pair<int,int> cur = que.top(); que.pop();\\n            acc += cur.first / (double) cur.second;\\n        }\\n        return acc / (double) classes.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct cmp{\\n    bool operator()(pair<int,int> a, pair<int,int> b){\\n        double ad = (a.first+1)/(double)(a.second+1) - (a.first)/(double)a.second;\\n        double bd = (b.first+1)/(double)(b.second+1) - (b.first)/(double)b.second;\\n        return ad < bd;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double acc = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> que;\\n        for(vector<int> i: classes)\\n            que.push(make_pair(i[0],i[1]));\\n        while(extraStudents--){\\n            pair<int,int> cur = que.top(); que.pop();\\n            cur.first++, cur.second++;\\n            que.push(cur);\\n        }\\n        while(!que.empty()){\\n            pair<int,int> cur = que.top(); que.pop();\\n            acc += cur.first / (double) cur.second;\\n        }\\n        return acc / (double) classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108389,
                "title": "python-greedy-solution-using-priority-queue",
                "content": "# **Explanation**\\nGreedily take the best current choice using priority queue.\\n<br>\\n\\n# **Prove**\\nFor each class, the delta is decreasing when we add extra students.\\nThe best local option is always the best.\\nIt\\'s a loss if we don\\'t take it.\\n<br>\\n\\n# **Complexity**\\nTime `O(n + klogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Python3**\\n```py\\n    def maxAverageRatio(self, A, k):\\n        h = [(a / b - (a + 1) / (b + 1), a, b) for a, b in A]\\n        heapify(h)\\n        while k:\\n            v, a, b = heapq.heappop(h)\\n            a, b = a + 1, b + 1\\n            heapq.heappush(h, (-(a + 1) / (b + 1) + a / b, a, b))\\n            k -= 1\\n        return sum(a / b for v, a, b in h) / len(h)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def maxAverageRatio(self, A, k):\\n        h = [(a / b - (a + 1) / (b + 1), a, b) for a, b in A]\\n        heapify(h)\\n        while k:\\n            v, a, b = heapq.heappop(h)\\n            a, b = a + 1, b + 1\\n            heapq.heappush(h, (-(a + 1) / (b + 1) + a / b, a, b))\\n            k -= 1\\n        return sum(a / b for v, a, b in h) / len(h)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1108259,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Cmp());\\n        for(int[] c: classes) queue.offer(c);   // add all to priority queue\\n        for(;extraStudents > 0;extraStudents--) {    // add extra student to class that will max increase the average\\n            int[] c = queue.poll();\\n            c[0]++; c[1]++;\\n            queue.offer(c);\\n        }\\n        double result =0;\\n        while(!queue.isEmpty()) {       // Calculate sum of pass ratios\\n            int[] c = queue.poll();\\n            result += (double)c[0]/c[1];\\n        }\\n        return result/classes.length;    // return average\\n    }\\n}\\nclass Cmp implements Comparator<int[]> {  // to sort in descending order of diff when 1 is added to class\\n    public int compare(int[] x, int[] y) {\\n        double xDiff = (double)(x[0]+1)/(x[1]+1) - (double)x[0]/x[1], yDiff = (double)(y[0]+1)/(y[1]+1) - (double)y[0]/y[1];\\n        return xDiff > yDiff? -1 : 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Cmp());\\n        for(int[] c: classes) queue.offer(c);   // add all to priority queue\\n        for(;extraStudents > 0;extraStudents--) {    // add extra student to class that will max increase the average\\n            int[] c = queue.poll();\\n            c[0]++; c[1]++;\\n            queue.offer(c);\\n        }\\n        double result =0;\\n        while(!queue.isEmpty()) {       // Calculate sum of pass ratios\\n            int[] c = queue.poll();\\n            result += (double)c[0]/c[1];\\n        }\\n        return result/classes.length;    // return average\\n    }\\n}\\nclass Cmp implements Comparator<int[]> {  // to sort in descending order of diff when 1 is added to class\\n    public int compare(int[] x, int[] y) {\\n        double xDiff = (double)(x[0]+1)/(x[1]+1) - (double)x[0]/x[1], yDiff = (double)(y[0]+1)/(y[1]+1) - (double)y[0]/y[1];\\n        return xDiff > yDiff? -1 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280525,
                "title": "easy-c-solution-commented-fully-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n     \\n        //among all classes i choose the one which will have a larger growth in the pass ratio if i add one student to the class\\n        \\n        //add one student to the each class and store the growth (difference) in the pass ratio to a max heap\\n        using pi=pair<double,pair<int,int>>;\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        //double is used to store the difference\\n        //pair.first stores the pass students in the class\\n        //pair.second stores the total students in the class\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            int pass=classes[i][0];\\n            int total=classes[i][1];\\n            \\n            //calculate the growth\\n           long  double growth=(double)(pass+1)/(total+1) - (double)(pass)/(total);\\n            pq.push({growth,{pass,total}});\\n        }\\n        \\n        //now i have not added any students to any class and the number of students still remains the same\\n        //i have just want to know which class would have more growth if i add one \\n        //so i pushed all the classes growth to max heap\\n        \\n        while(extraStudents)\\n        {\\n            pi top= pq.top();\\n            pq.pop();\\n            extraStudents--;\\n            //calculate the growth again if i add one student to the class at the top\\n            int pass=top.second.first;\\n            int total=top.second.second;\\n            pass++;\\n            total++;\\n            long double growth=(double)(pass+1)/(total+1) - (double)(pass)/(total);\\n            pq.push({growth,{pass,total}});\\n        }\\n        \\n        //now pop out the elements from pq and calculate the pass ratio\\n        double res=0;\\n        while(!pq.empty())\\n        {\\n            //calculate the pass/total;\\n            res+=(double)(pq.top().second.first)/(pq.top().second.second);\\n            pq.pop();\\n        }\\n        return (double)res/(classes.size());\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n     \\n        //among all classes i choose the one which will have a larger growth in the pass ratio if i add one student to the class\\n        \\n        //add one student to the each class and store the growth (difference) in the pass ratio to a max heap\\n        using pi=pair<double,pair<int,int>>;\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        //double is used to store the difference\\n        //pair.first stores the pass students in the class\\n        //pair.second stores the total students in the class\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            int pass=classes[i][0];\\n            int total=classes[i][1];\\n            \\n            //calculate the growth\\n           long  double growth=(double)(pass+1)/(total+1) - (double)(pass)/(total);\\n            pq.push({growth,{pass,total}});\\n        }\\n        \\n        //now i have not added any students to any class and the number of students still remains the same\\n        //i have just want to know which class would have more growth if i add one \\n        //so i pushed all the classes growth to max heap\\n        \\n        while(extraStudents)\\n        {\\n            pi top= pq.top();\\n            pq.pop();\\n            extraStudents--;\\n            //calculate the growth again if i add one student to the class at the top\\n            int pass=top.second.first;\\n            int total=top.second.second;\\n            pass++;\\n            total++;\\n            long double growth=(double)(pass+1)/(total+1) - (double)(pass)/(total);\\n            pq.push({growth,{pass,total}});\\n        }\\n        \\n        //now pop out the elements from pq and calculate the pass ratio\\n        double res=0;\\n        while(!pq.empty())\\n        {\\n            //calculate the pass/total;\\n            res+=(double)(pq.top().second.first)/(pq.top().second.second);\\n            pq.pop();\\n        }\\n        return (double)res/(classes.size());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108491,
                "title": "python-100-efficient-solution-easy-to-understand-with-comments-and-explanation",
                "content": "**Key Idea:** We need to keep assigning the remaining extra students to the class which can experience the greatest impact. \\n\\nLet see an example below, if we have following clasess - [[2,4], [3,9], [4,5], [2,10]], then the impact of assignment students to each class can be defined as,\\n\\n```\\n# In simple terms it can be understood as follows,\\n\\ncurrentRatio = passCount/totalCount\\nexpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\\nimpact = expectedRatioAfterUpdate - currentRatio\\n\\t\\t\\t\\nOR\\n\\n# Formula to calculate impact of assigning a student to a class\\nimpacts[i] = (classes[i][0]+1) / (classes[i][1]+1) - classes[i][0]/classes[i][1]\\ni.e.\\nimpacts[0] -> (4+1)/(2+1)-4/2 \\nimpacts[1] -> (3+1)/(9+1)-3/9 \\n.\\n.\\netc.\\n```\\n\\nAnd, once we assign a student to a class, then we need the class with \"next\" greatest impact. We know that heap is perfect candidate for scenarios in which you need to pick the least/greatest of all the collections at any point of time.\\n\\nHence, we can leverage that to fetch the greatest impacts in all the cases. \\n\\n**Note:** in below code we have negated (observe `-` sign ), because by default python heaps are min heaps. Hence, it\\'s sort of a workaround to make our logic work :)\\n\\n```\\nclass Solution:\\n\\tdef maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n\\t\\t\\n\\t\\tn = len(classes)\\n\\t\\t\\n\\t\\timpacts = [0]*n\\n\\t\\tminRatioIndex = 0\\n\\t\\t\\n\\t\\t# calculate and store impacts for each class in form of tuples -> (-impactValue, passCount, totalCount)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tpassCount = classes[i][0]\\n\\t\\t\\ttotalCount = classes[i][1]\\n\\t\\t\\t\\n\\t\\t\\t# calculate the impact  for class i\\n\\t\\t\\tcurrentRatio = passCount/totalCount\\n\\t\\t\\texpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\\n\\t\\t\\timpact = expectedRatioAfterUpdate - currentRatio\\n\\t\\t\\t\\n\\t\\t\\timpacts[i] = (-impact, passCount, totalCount)  # note the - sign for impact\\n\\t\\t\\t\\n\\t\\theapq.heapify(impacts)\\n\\t\\t\\n\\t\\twhile(extraStudents > 0):\\n\\t\\t\\t# pick the next class with greatest impact \\n\\t\\t\\t_, passCount, totalCount = heapq.heappop(impacts)\\n\\t\\t\\t\\n\\t\\t\\t# assign a student to the class\\n\\t\\t\\tpassCount+=1\\n\\t\\t\\ttotalCount+=1\\n\\t\\t\\t\\n\\t\\t\\t# calculate the updated impact  for current class\\n\\t\\t\\tcurrentRatio = passCount/totalCount\\n\\t\\t\\texpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\\n\\t\\t\\timpact = expectedRatioAfterUpdate - currentRatio\\n\\t\\t\\t\\n\\t\\t\\t# insert updated impact back into the heap\\n\\t\\t\\theapq.heappush(impacts, (-impact, passCount, totalCount))\\n\\t\\t\\textraStudents -= 1\\n\\t\\t\\n\\t\\tresult = 0\\n\\t\\t\\t\\n\\t\\t# for all the updated classes calculate the total passRatio \\n\\t\\tfor _, passCount, totalCount in impacts:\\n\\t\\t\\tresult += passCount/totalCount\\n\\t\\t\\t\\n\\t\\t# return the average pass ratio\\n\\t\\treturn result/n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# In simple terms it can be understood as follows,\\n\\ncurrentRatio = passCount/totalCount\\nexpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\\nimpact = expectedRatioAfterUpdate - currentRatio\\n\\t\\t\\t\\nOR\\n\\n# Formula to calculate impact of assigning a student to a class\\nimpacts[i] = (classes[i][0]+1) / (classes[i][1]+1) - classes[i][0]/classes[i][1]\\ni.e.\\nimpacts[0] -> (4+1)/(2+1)-4/2 \\nimpacts[1] -> (3+1)/(9+1)-3/9 \\n.\\n.\\netc.\\n```\n```\\nclass Solution:\\n\\tdef maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n\\t\\t\\n\\t\\tn = len(classes)\\n\\t\\t\\n\\t\\timpacts = [0]*n\\n\\t\\tminRatioIndex = 0\\n\\t\\t\\n\\t\\t# calculate and store impacts for each class in form of tuples -> (-impactValue, passCount, totalCount)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tpassCount = classes[i][0]\\n\\t\\t\\ttotalCount = classes[i][1]\\n\\t\\t\\t\\n\\t\\t\\t# calculate the impact  for class i\\n\\t\\t\\tcurrentRatio = passCount/totalCount\\n\\t\\t\\texpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\\n\\t\\t\\timpact = expectedRatioAfterUpdate - currentRatio\\n\\t\\t\\t\\n\\t\\t\\timpacts[i] = (-impact, passCount, totalCount)  # note the - sign for impact\\n\\t\\t\\t\\n\\t\\theapq.heapify(impacts)\\n\\t\\t\\n\\t\\twhile(extraStudents > 0):\\n\\t\\t\\t# pick the next class with greatest impact \\n\\t\\t\\t_, passCount, totalCount = heapq.heappop(impacts)\\n\\t\\t\\t\\n\\t\\t\\t# assign a student to the class\\n\\t\\t\\tpassCount+=1\\n\\t\\t\\ttotalCount+=1\\n\\t\\t\\t\\n\\t\\t\\t# calculate the updated impact  for current class\\n\\t\\t\\tcurrentRatio = passCount/totalCount\\n\\t\\t\\texpectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\\n\\t\\t\\timpact = expectedRatioAfterUpdate - currentRatio\\n\\t\\t\\t\\n\\t\\t\\t# insert updated impact back into the heap\\n\\t\\t\\theapq.heappush(impacts, (-impact, passCount, totalCount))\\n\\t\\t\\textraStudents -= 1\\n\\t\\t\\n\\t\\tresult = 0\\n\\t\\t\\t\\n\\t\\t# for all the updated classes calculate the total passRatio \\n\\t\\tfor _, passCount, totalCount in impacts:\\n\\t\\t\\tresult += passCount/totalCount\\n\\t\\t\\t\\n\\t\\t# return the average pass ratio\\n\\t\\treturn result/n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108424,
                "title": "c-why-using-vector-int-in-priority-queue-got-tle",
                "content": "I used vector<int> in priority_queue then I got TLE. \\nBut if I replace the vector<int> with pair<int, int> in priority_queue, it passes all test cases.\\nJust wonder why it happens?\\n\\nHere\\'s my code:\\n```\\nclass Solution {\\npublic:\\n    static double cal(vector<int>& v) {\\n        return (double) (v[1] - v[0]) / (double) (v[1] * (v[1] + 1));\\n    }\\n    \\n    struct compare {\\n        bool operator() (vector<int>& a, vector<int>& b) {\\n            return cal(b) > cal(a);\\n        }\\n    };\\n    \\n    double maxAverageRatio(vector<vector<int>>& cs, int es) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> q;\\n        for (auto& c : cs) {\\n            q.emplace(c);\\n        }\\n        \\n        while (es > 0) {\\n            auto maxn = q.top();\\n            q.pop();\\n            maxn[0]++;\\n            maxn[1]++;\\n            q.push(maxn);\\n            es--;\\n        }\\n        double total = 0;\\n        while (!q.empty()) {\\n            auto& c = q.top();\\n            total += (double)(c[0]) / (double)(c[1]);\\n            q.pop();\\n        }\\n        return total / (double) cs.size();\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static double cal(vector<int>& v) {\\n        return (double) (v[1] - v[0]) / (double) (v[1] * (v[1] + 1));\\n    }\\n    \\n    struct compare {\\n        bool operator() (vector<int>& a, vector<int>& b) {\\n            return cal(b) > cal(a);\\n        }\\n    };\\n    \\n    double maxAverageRatio(vector<vector<int>>& cs, int es) {\\n        priority_queue<vector<int>, vector<vector<int>>, compare> q;\\n        for (auto& c : cs) {\\n            q.emplace(c);\\n        }\\n        \\n        while (es > 0) {\\n            auto maxn = q.top();\\n            q.pop();\\n            maxn[0]++;\\n            maxn[1]++;\\n            q.push(maxn);\\n            es--;\\n        }\\n        double total = 0;\\n        while (!q.empty()) {\\n            auto& c = q.top();\\n            total += (double)(c[0]) / (double)(c[1]);\\n            q.pop();\\n        }\\n        return total / (double) cs.size();\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108337,
                "title": "c-using-priority-queue",
                "content": "initial ratio for one class=x/y\\nafter adding 1 child=(x+1)/(y+1)\\nchange in ratio by adding one child=(y-x)/(y*(y+1))\\nkeep removing and adding this ratio from priority queue for all the extra students\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int e) {\\n        priority_queue<pair<double,int>> pq;\\n        int n=c.size();\\n        for(int i=0;i<n;i++){\\n            double v=(c[i][1]-c[i][0])*1.0/(((c[i][1])*1.0)*(c[i][1]+1));\\n            if(v<1){\\n            pq.push({v,i});}\\n        }\\n        while(e!=0){\\n            auto p=pq.top();\\n            pq.pop();\\n            int id=p.second;\\n            c[id][0]++;\\n            c[id][1]++;\\n            double v=(c[id][1]-c[id][0])*1.0/(((c[id][1])*1.0)*(c[id][1]+1));\\n            if(v<1){\\n            pq.push({v,id});}\\n            e--;\\n            \\n        }\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=((c[i][0]*1.0)/c[i][1]);\\n        }\\n        ans/=n;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int e) {\\n        priority_queue<pair<double,int>> pq;\\n        int n=c.size();\\n        for(int i=0;i<n;i++){\\n            double v=(c[i][1]-c[i][0])*1.0/(((c[i][1])*1.0)*(c[i][1]+1));\\n            if(v<1){\\n            pq.push({v,i});}\\n        }\\n        while(e!=0){\\n            auto p=pq.top();\\n            pq.pop();\\n            int id=p.second;\\n            c[id][0]++;\\n            c[id][1]++;\\n            double v=(c[id][1]-c[id][0])*1.0/(((c[id][1])*1.0)*(c[id][1]+1));\\n            if(v<1){\\n            pq.push({v,id});}\\n            e--;\\n            \\n        }\\n        double ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=((c[i][0]*1.0)/c[i][1]);\\n        }\\n        ans/=n;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123615,
                "title": "c-maxheap-no-lambda-nonsense-comparator-class-functor-explained-with-comments",
                "content": "I was more familiar with Comparator Classes / Functors and completely clueless about `auto []()`\\nSo here\\'s one without Lambda functions.\\n\\n**Explaination:**\\nIt is not sufficient to pick out the class with the least pass ratio, add a brilliant kid (extraStudent), and recalculate the average. Although that might seem the best way to solve this \"greedily\", there may be another class which would have a greater increase/spike in the pass ratio when adding a brilliant kid (this depends on the size of the class). \\n\\nI define `spike` as the difference between the current Pass Ratio and the expected increase of the pass ratio in the event an `extraStudent` is added.\\n\\nSo all you have to do is to add a brilliant kid to the class which would have the greatest spike in the pass ratio by \"sorting\" the Max heap of `studentClasses` with respect to the spike/impact. The class with the highest spike is the one we\\'d want to greedily add a student to.\\n\\n```\\n// Trust me this isn\\'t Java Lol\\nclass studentClass {\\npublic:\\n    int total,passed; // total strength of the class and number of students that passed\\n    double passRatio; \\n\\tdouble expectedIncreaseInPassRatio; // incase an extraStudent / brilliant kid is added\\n    studentClass(int passed, int total)\\n    {\\n        this->passed = passed;\\n        this->total = total;\\n        passRatio = (double)passed/total;\\n        expectedIncreaseInPassRatio = (double)(passed+1)/(total+1); // If an extra studen were to be added\\n    }\\n};\\n\\n// The following class helps the priorty queue in prioritizing its elements\\nclass PassRatioComparator {\\npublic:\\n\\t// This as good as passing a comparator into a built in sorting function\\n    bool operator()(studentClass a, studentClass b) // Overloading the fucntion `()` operator. This is called a Fucntion Object or a Functor.\\n    {\\n        double spikeA = a.expectedIncreaseInPassRatio -  a.passRatio;\\n        double spikeB = b.expectedIncreaseInPassRatio -  b.passRatio;\\n        return spikeA < spikeB; \\n\\t\\t// ^^ This makes sure that the class with Highest spike is infront of the Priority queue\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<studentClass, vector<studentClass>, PassRatioComparator> maxHeap;\\n        // ^^ Standard way of declaring a max heap with a comparator class \\n        \\n        for(auto c: classes)\\n        {\\n            studentClass x(c[0],c[1]); \\n            maxHeap.push(x);\\n        }\\n        \\n        while(extraStudents--)\\n        {\\n            studentClass x = maxHeap.top(); \\n\\t\\t\\t// ^^ This class has the highest spike/impact on adding an extra student\\n            maxHeap.pop();\\n            studentClass y(x.passed+1,x.total+1); \\n\\t\\t\\t// ^^ So create a new class with one extra student. \\n\\t\\t\\t\\n\\t\\t\\t// Now y has a better pass ratio such that:\\n\\t\\t\\t// y.passRatio == x.expectedIncreaseInPassRatio\\n            \\n            maxHeap.push(y);\\n        }\\n        \\n        int n = maxHeap.size();\\n        double sum=0;\\n        while(maxHeap.size()>0)\\n        {\\n            sum+=maxHeap.top().passRatio;\\n            maxHeap.pop();\\n        }\\n        return sum/n;\\n    }\\n};\\n```\\nThis is my first ever post on Leetcode Discussions.\\nUpvote for more!",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Trust me this isn\\'t Java Lol\\nclass studentClass {\\npublic:\\n    int total,passed; // total strength of the class and number of students that passed\\n    double passRatio; \\n\\tdouble expectedIncreaseInPassRatio; // incase an extraStudent / brilliant kid is added\\n    studentClass(int passed, int total)\\n    {\\n        this->passed = passed;\\n        this->total = total;\\n        passRatio = (double)passed/total;\\n        expectedIncreaseInPassRatio = (double)(passed+1)/(total+1); // If an extra studen were to be added\\n    }\\n};\\n\\n// The following class helps the priorty queue in prioritizing its elements\\nclass PassRatioComparator {\\npublic:\\n\\t// This as good as passing a comparator into a built in sorting function\\n    bool operator()(studentClass a, studentClass b) // Overloading the fucntion `()` operator. This is called a Fucntion Object or a Functor.\\n    {\\n        double spikeA = a.expectedIncreaseInPassRatio -  a.passRatio;\\n        double spikeB = b.expectedIncreaseInPassRatio -  b.passRatio;\\n        return spikeA < spikeB; \\n\\t\\t// ^^ This makes sure that the class with Highest spike is infront of the Priority queue\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<studentClass, vector<studentClass>, PassRatioComparator> maxHeap;\\n        // ^^ Standard way of declaring a max heap with a comparator class \\n        \\n        for(auto c: classes)\\n        {\\n            studentClass x(c[0],c[1]); \\n            maxHeap.push(x);\\n        }\\n        \\n        while(extraStudents--)\\n        {\\n            studentClass x = maxHeap.top(); \\n\\t\\t\\t// ^^ This class has the highest spike/impact on adding an extra student\\n            maxHeap.pop();\\n            studentClass y(x.passed+1,x.total+1); \\n\\t\\t\\t// ^^ So create a new class with one extra student. \\n\\t\\t\\t\\n\\t\\t\\t// Now y has a better pass ratio such that:\\n\\t\\t\\t// y.passRatio == x.expectedIncreaseInPassRatio\\n            \\n            maxHeap.push(y);\\n        }\\n        \\n        int n = maxHeap.size();\\n        double sum=0;\\n        while(maxHeap.size()>0)\\n        {\\n            sum+=maxHeap.top().passRatio;\\n            maxHeap.pop();\\n        }\\n        return sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108321,
                "title": "clean-python-3-greedy-with-heap",
                "content": "Greedy add genius students into most benefit class.\\n\\nTime: `O(N + ElogN)`\\nSpace: `O(N)`\\n```\\nimport heapq\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        total = sum(p / t for p, t in classes)\\n        heap = [(p / t - (p + 1) / (t + 1), p, t) for p, t in classes]\\n        heapq.heapify(heap)\\n        for _ in range(extraStudents):\\n            increase, p, t = heapq.heappop(heap)\\n            total -= increase\\n            p, t = p + 1, t + 1\\n            heapq.heappush(heap, ((p / t - (p + 1) / (t + 1), p, t)))\\n        return total / len(classes)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        total = sum(p / t for p, t in classes)\\n        heap = [(p / t - (p + 1) / (t + 1), p, t) for p, t in classes]\\n        heapq.heapify(heap)\\n        for _ in range(extraStudents):\\n            increase, p, t = heapq.heappop(heap)\\n            total -= increase\\n            p, t = p + 1, t + 1\\n            heapq.heappush(heap, ((p / t - (p + 1) / (t + 1), p, t)))\\n        return total / len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108255,
                "title": "python-greedy-heap",
                "content": "\\n\\n```html5\\n<b>Time Complexity: O((m+n)&middot;log(n))</b> where m = extraStudents and n = classes.length &becaus; we perform m operations on a length n heap\\n<b>Space Complexity: O(n)</b> &becaus; every class must be stored in the heap.\\n```\\n\\n**Approach:**\\n\\nGreedily select the most needy class to receive a brilliant student.\\nThe most needy class will be the class whose ratio increases the\\nmost by giving it a brilliant student.\\n\\n>i.e. 5/10 = 50% and 10/20 = 50% but the first class will \\n>benefit more because 6/11 = 54.5% and 11/21 = 52.4%\\n\\nStore all of the classes and their neediness in a heap so that the\\nmost needy class is at `h[0]`.\\n\\nThen pop the most needy class, give it a brilliant student and update the heap.\\nRepeat this step `m` times for `m` brilliant students and return the average class ratio.\\n\\n<hr>\\n\\n```python\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        # 1. Heapify classes according to how much they will benefit from getting a brilliant student\\n        h = []\\n        for p, t in classes:\\n            delta = ((p+1) / (t+1)) - (p / t)\\n            heapq.heappush(h, (-delta, p, t))\\n        \\n        # 2. Pop the most needy class and give it a brilliant student\\n        #    Then insert the class back into the heap.\\n        for _ in range(extraStudents):\\n            d, p, t = heapq.heappop(h)\\n            p += 1\\n            t += 1\\n            delta = ((p+1) / (t+1)) - (p / t)\\n            heapq.heappush(h, (-delta, p, t))\\n            \\n        total_ratio = sum(p/t for d, p, t in h)\\n        return total_ratio / len(h)\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time Complexity: O((m+n)&middot;log(n))</b> where m = extraStudents and n = classes.length &becaus; we perform m operations on a length n heap\\n<b>Space Complexity: O(n)</b> &becaus; every class must be stored in the heap.\\n```\n```python\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        # 1. Heapify classes according to how much they will benefit from getting a brilliant student\\n        h = []\\n        for p, t in classes:\\n            delta = ((p+1) / (t+1)) - (p / t)\\n            heapq.heappush(h, (-delta, p, t))\\n        \\n        # 2. Pop the most needy class and give it a brilliant student\\n        #    Then insert the class back into the heap.\\n        for _ in range(extraStudents):\\n            d, p, t = heapq.heappop(h)\\n            p += 1\\n            t += 1\\n            delta = ((p+1) / (t+1)) - (p / t)\\n            heapq.heappush(h, (-delta, p, t))\\n            \\n        total_ratio = sum(p/t for d, p, t in h)\\n        return total_ratio / len(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712097,
                "title": "greedy-proof",
                "content": "Hi Guys, this is kinda my first post on leetcode, applogies for bad grammer and formatting. Also it\\'s been ages since I\\'ve written a mathematical proof, so it might not be very accurate but hopefully it should be intutive. Hope this can help one of you. \\n\\n### Greedy Algorithm\\nIteratively each brilient student is added to the class with the maximum delta pass ratio and pass ratio of this class is updated. \\n\\nFor a class `class_i` with `pass_i` students passing and `total_i` being the total number of students. The pass ratio is `pass_i/total_i` When a brilliant student is added, the pass ratio changes to `(pass_i+1)/(total_i+1)`. Therefore, the pass ratio increased by `(total_i-pass_i)/(pass_i*(pass_i+1))`  which we call as delta pass ratio.\\n\\n#### Lemma 1.  The delta pass ratio decreases as we keep on adding new brilliant student \\nIn the above equation of the pass ratio, the Numerator is constant as we keep adding brilliant students, but the Denominator keeps decreasing. Hence, the benefits of adding a new brilliant student keeps decreasing for the `class_i` .\\n\\n\\n#### Algorithm Proof - Proof by contradiction\\n- Say at step 1 `class_i` has the highest delta pass ratio.\\n- Now if we are picking `class_i` at step 1, then we are good.\\n- If we are not picking `class_i` at step\\n\\t- If we pick `class_i` eventually at `step_x`, then simply swap the steps `step_1` and `step_x`. \\n\\t- If `class_i` is never picked up, \\n\\t\\t- let `class_k` be the  class where last student `s_n` was added\\n\\t\\t- delta pass ratio of `class_k` at step `s_(n-1)` will be less than delta pass ratio for `class_i` \\n\\t\\t\\t- since `class_i` has the highest delta pass ratio at `step_0` itself and delta pass ratio decreases with more steps \\n\\t\\t- Hence this is a contradtion, as by changing `step_n` by choose `class_i` instead of `class_k`, the total ratio sum will increase. \\n\\n\\n### Python code for reference \\n\\n``` python\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        def delta(p, t):\\n            return -(t-p)/(t*(t+1))\\n        \\n        ans = 0\\n        heap = []\\n        for class_i in classes:\\n            heap.append((delta(*class_i), class_i))\\n            ans += class_i[0]/class_i[1]\\n        \\n        heapq.heapify(heap)\\n        for i in range(extraStudents):\\n            delta_i, class_i = heapq.heappop(heap)\\n            ans -= delta_i\\n            class_i[0]+=1\\n            class_i[1]+=1\\n            heapq.heappush(heap, (delta(*class_i), class_i))\\n        return ans/len(classes)\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "``` python\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        def delta(p, t):\\n            return -(t-p)/(t*(t+1))\\n        \\n        ans = 0\\n        heap = []\\n        for class_i in classes:\\n            heap.append((delta(*class_i), class_i))\\n            ans += class_i[0]/class_i[1]\\n        \\n        heapq.heapify(heap)\\n        for i in range(extraStudents):\\n            delta_i, class_i = heapq.heappop(heap)\\n            ans -= delta_i\\n            class_i[0]+=1\\n            class_i[1]+=1\\n            heapq.heappush(heap, (delta(*class_i), class_i))\\n        return ans/len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425088,
                "title": "max-heap-c-commented-code-greedy",
                "content": "```\\n\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extra) {\\n       priority_queue<pair<double,pair<int,int>>>pq;\\n        int n=classes.size();\\n        //calculating the difference between the previous ration and new ratio\\n        //here I will increament student and pass student of each class by one and will chaeck where difference is maximum\\n        //thats why I am using preiority queue so that my max profit will be on top;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pass=classes[i][0];\\n            int stud=classes[i][1];\\n            double diff=(double)(pass+1)/(stud+1)-(double)(pass)/(stud);\\n            pq.push({diff,{pass,stud}});\\n        }\\n        //now keep adding one by one new students to the class untill extra will not become zero\\n        while(extra--)\\n        {\\n            auto x=pq.top();\\n            pq.pop();\\n            \\n            int pass=x.second.first;\\n            int stud=x.second.second;\\n            pass++;\\n            stud++;\\n            //chck your new difference and reassign to the priority queue after popping the previous one\\n            double newdiff=(double)(pass+1)/(stud+1)-(double)(pass)/(stud);\\n            pq.push({newdiff,{pass,stud}});\\n            \\n        }\\n        //till here you have successfully assinged the student in optimal class\\n        //just take the avarage and this is your ans;\\n        double ans=0.0;\\n         while(!pq.empty())\\n         {\\n             auto x=pq.top();\\n             pq.pop();\\n             ans+=(double)(x.second.first)/(x.second.second);\\n         }\\n        return ans/n;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extra) {\\n       priority_queue<pair<double,pair<int,int>>>pq;\\n        int n=classes.size();\\n        //calculating the difference between the previous ration and new ratio\\n        //here I will increament student and pass student of each class by one and will chaeck where difference is maximum\\n        //thats why I am using preiority queue so that my max profit will be on top;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pass=classes[i][0];\\n            int stud=classes[i][1];\\n            double diff=(double)(pass+1)/(stud+1)-(double)(pass)/(stud);\\n            pq.push({diff,{pass,stud}});\\n        }\\n        //now keep adding one by one new students to the class untill extra will not become zero\\n        while(extra--)\\n        {\\n            auto x=pq.top();\\n            pq.pop();\\n            \\n            int pass=x.second.first;\\n            int stud=x.second.second;\\n            pass++;\\n            stud++;\\n            //chck your new difference and reassign to the priority queue after popping the previous one\\n            double newdiff=(double)(pass+1)/(stud+1)-(double)(pass)/(stud);\\n            pq.push({newdiff,{pass,stud}});\\n            \\n        }\\n        //till here you have successfully assinged the student in optimal class\\n        //just take the avarage and this is your ans;\\n        double ans=0.0;\\n         while(!pq.empty())\\n         {\\n             auto x=pq.top();\\n             pq.pop();\\n             ans+=(double)(x.second.first)/(x.second.second);\\n         }\\n        return ans/n;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228490,
                "title": "c-not-very-simple",
                "content": "```\\nclass node\\n{\\n    public:\\n    int x, y;\\n    double z;\\n    \\n    node(int x, int y, double z)\\n    {\\n        this -> x = x;\\n        this -> y = y;\\n        this -> z = z;\\n    }\\n};\\n\\nclass cmp\\n{\\n    public:\\n      bool operator()(node a, node b)\\n      {\\n          return a.z < b.z;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int n = classes.size();\\n        priority_queue<node, vector<node>, cmp> pq;\\n        for(auto x : classes)\\n        {\\n            double prev = x[0] / (double)x[1];\\n            double next = (x[0] + 1) / (double)(x[1] + 1);\\n            node nodes(x[0], x[1], next - prev);\\n            pq.push(nodes);\\n        }\\n        while(extraStudents--)\\n        {\\n            auto temp = pq.top();\\n            pq.pop();\\n            temp.x++;\\n            temp.y++;\\n            double prev = temp.x / (double)temp.y;\\n            double next = (temp.x + 1) / (double)(temp.y + 1);\\n            node nodes(temp.x, temp.y, next - prev);\\n            pq.push(nodes);\\n        }\\n        double ans = 0;\\n        while(pq.size() != 0)\\n        {\\n            auto temp = pq.top();\\n            pq.pop();\\n            ans += temp.x / (double)temp.y;\\n        }\\n        return ans / n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass node\\n{\\n    public:\\n    int x, y;\\n    double z;\\n    \\n    node(int x, int y, double z)\\n    {\\n        this -> x = x;\\n        this -> y = y;\\n        this -> z = z;\\n    }\\n};\\n\\nclass cmp\\n{\\n    public:\\n      bool operator()(node a, node b)\\n      {\\n          return a.z < b.z;\\n      }\\n};\\n\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int n = classes.size();\\n        priority_queue<node, vector<node>, cmp> pq;\\n        for(auto x : classes)\\n        {\\n            double prev = x[0] / (double)x[1];\\n            double next = (x[0] + 1) / (double)(x[1] + 1);\\n            node nodes(x[0], x[1], next - prev);\\n            pq.push(nodes);\\n        }\\n        while(extraStudents--)\\n        {\\n            auto temp = pq.top();\\n            pq.pop();\\n            temp.x++;\\n            temp.y++;\\n            double prev = temp.x / (double)temp.y;\\n            double next = (temp.x + 1) / (double)(temp.y + 1);\\n            node nodes(temp.x, temp.y, next - prev);\\n            pq.push(nodes);\\n        }\\n        double ans = 0;\\n        while(pq.size() != 0)\\n        {\\n            auto temp = pq.top();\\n            pq.pop();\\n            ans += temp.x / (double)temp.y;\\n        }\\n        return ans / n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108335,
                "title": "python3-greedy-algorithm",
                "content": "Greedy algorithm: for each step of adding a student, maximize the increment of average score\\n\\n```\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = [[-(p + 1) / (t + 1) + p / t, p / t, p, t] for p, t in classes]\\n        heapq.heapify(heap)\\n        while extraStudents:\\n            neg_inc, ratio, p, t = heapq.heappop(heap)\\n            p += 1\\n            t += 1\\n            heapq.heappush(heap, [-(p + 1) / (t + 1) + p / t, p / t, p, t])\\n            extraStudents -= 1\\n        return sum(ele[1] for ele in heap) / len(heap)\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = [[-(p + 1) / (t + 1) + p / t, p / t, p, t] for p, t in classes]\\n        heapq.heapify(heap)\\n        while extraStudents:\\n            neg_inc, ratio, p, t = heapq.heappop(heap)\\n            p += 1\\n            t += 1\\n            heapq.heappush(heap, [-(p + 1) / (t + 1) + p / t, p / t, p, t])\\n            extraStudents -= 1\\n        return sum(ele[1] for ele in heap) / len(heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688432,
                "title": "max-heap-c-easy-beats-90",
                "content": "# if it helps You, Please Upvote Me...\\uD83E\\uDDE1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat do you think about **extra students**, in which class do you add extra students.\\nAfter adding a student to all class keep **track of difference** but actually we will add that one student in class which has **maximum difference.**\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int es) {\\n\\n        int n  = c.size();\\n        double avg  = 0,ans = 0;\\n        priority_queue<pair<double,int>> pq;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            double diff =(double)(c[i][0]+1)/(double)(c[i][1]+1)-(double)c[i][0]/(double)c[i][1];\\n            pq.push({diff,i});\\n        }\\n        while(es--)\\n        {\\n           int i = pq.top().second;\\n           pq.pop();\\n           c[i][0]+=1;\\n           c[i][1]+=1;\\n           double diff = (double)(c[i][0]+1)/(double)(c[i][1]+1)-(double)c[i][0]/(double)c[i][1];\\n           pq.push({diff,i});\\n        }\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            avg = (double)c[i][0]/(double)c[i][1];\\n            ans+=avg;\\n        }\\n        return ans/(double)n;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/1d87f7c4-85a3-4ad6-ab75-6ad287c24fe9_1687858913.821104.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int es) {\\n\\n        int n  = c.size();\\n        double avg  = 0,ans = 0;\\n        priority_queue<pair<double,int>> pq;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            double diff =(double)(c[i][0]+1)/(double)(c[i][1]+1)-(double)c[i][0]/(double)c[i][1];\\n            pq.push({diff,i});\\n        }\\n        while(es--)\\n        {\\n           int i = pq.top().second;\\n           pq.pop();\\n           c[i][0]+=1;\\n           c[i][1]+=1;\\n           double diff = (double)(c[i][0]+1)/(double)(c[i][1]+1)-(double)c[i][0]/(double)c[i][1];\\n           pq.push({diff,i});\\n        }\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            avg = (double)c[i][0]/(double)c[i][1];\\n            ans+=avg;\\n        }\\n        return ans/(double)n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357041,
                "title": "java-o-mlogn-heap-greedy-small-code",
                "content": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        double sum=0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->Double.compare((double)(b[0]+1)/(b[1]+1)-(double)b[0]/b[1],(double)(a[0]+1)/(a[1]+1)-(double)a[0]/a[1]));\\n        for(int[] c: classes){\\n            pq.add(c);\\n            sum+=(double)c[0]/c[1];\\n        }\\n        \\n        while(extraStudents > 0){\\n            int[] c = pq.poll();\\n            pq.add(new int[]{c[0]+1,c[1]+1});\\n            double change = (double)(c[0]+1)/(c[1]+1)-(double)c[0]/c[1];\\n            sum += change;\\n            extraStudents--;\\n        }\\n        return sum/classes.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        double sum=0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->Double.compare((double)(b[0]+1)/(b[1]+1)-(double)b[0]/b[1],(double)(a[0]+1)/(a[1]+1)-(double)a[0]/a[1]));\\n        for(int[] c: classes){\\n            pq.add(c);\\n            sum+=(double)c[0]/c[1];\\n        }\\n        \\n        while(extraStudents > 0){\\n            int[] c = pq.poll();\\n            pq.add(new int[]{c[0]+1,c[1]+1});\\n            double change = (double)(c[0]+1)/(c[1]+1)-(double)c[0]/c[1];\\n            sum += change;\\n            extraStudents--;\\n        }\\n        return sum/classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112509,
                "title": "javascript-and-typescript-solution",
                "content": "JavaScript AC (932 ms, 69.7 MB)\\n```js\\n/**\\n * @param {number[][]} classes\\n * @param {number} extraStudents\\n * @return {number}\\n */\\nvar maxAverageRatio = function(classes, extraStudents) {\\n  const q = new MaxPriorityQueue({\\n    priority: i => (classes[i][0] + 1) / (classes[i][1] + 1) - \\n      classes[i][0] / classes[i][1],\\n  });\\n  classes.forEach((_, i) => {\\n    q.enqueue(i);\\n  });\\n  \\n  let es = extraStudents;\\n  while (es) {\\n    const i = q.dequeue().element;\\n    \\n    classes[i][0] += 1;\\n    classes[i][1] += 1;\\n    q.enqueue(i);\\n    \\n    es -= 1;\\n  }\\n  \\n  let sum = 0;\\n  classes.forEach(([p, t]) => {\\n    sum += p / t;\\n  });\\n  \\n  return sum / classes.length;\\n};\\n```\\n\\nTypeScript AC (924 ms\\t71.6 MB)\\n```ts\\nfunction maxAverageRatio(classes: number[][], extraStudents: number): number {\\n  const q = new MaxPriorityQueue({\\n    priority: i => (classes[i][0] + 1) / (classes[i][1] + 1) - \\n      classes[i][0] / classes[i][1],\\n  });\\n  classes.forEach((_, i) => {\\n    q.enqueue(i);\\n  });\\n  \\n  let es = extraStudents;\\n  while (es) {\\n    const i = q.dequeue().element;\\n    \\n    classes[i][0] += 1;\\n    classes[i][1] += 1;\\n    q.enqueue(i);\\n    \\n    es -= 1;\\n  }\\n  \\n  let sum = 0;\\n  classes.forEach(([p, t]) => {\\n    sum += p / t;\\n  });\\n  \\n  return sum / classes.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[][]} classes\\n * @param {number} extraStudents\\n * @return {number}\\n */\\nvar maxAverageRatio = function(classes, extraStudents) {\\n  const q = new MaxPriorityQueue({\\n    priority: i => (classes[i][0] + 1) / (classes[i][1] + 1) - \\n      classes[i][0] / classes[i][1],\\n  });\\n  classes.forEach((_, i) => {\\n    q.enqueue(i);\\n  });\\n  \\n  let es = extraStudents;\\n  while (es) {\\n    const i = q.dequeue().element;\\n    \\n    classes[i][0] += 1;\\n    classes[i][1] += 1;\\n    q.enqueue(i);\\n    \\n    es -= 1;\\n  }\\n  \\n  let sum = 0;\\n  classes.forEach(([p, t]) => {\\n    sum += p / t;\\n  });\\n  \\n  return sum / classes.length;\\n};\\n```\n```ts\\nfunction maxAverageRatio(classes: number[][], extraStudents: number): number {\\n  const q = new MaxPriorityQueue({\\n    priority: i => (classes[i][0] + 1) / (classes[i][1] + 1) - \\n      classes[i][0] / classes[i][1],\\n  });\\n  classes.forEach((_, i) => {\\n    q.enqueue(i);\\n  });\\n  \\n  let es = extraStudents;\\n  while (es) {\\n    const i = q.dequeue().element;\\n    \\n    classes[i][0] += 1;\\n    classes[i][1] += 1;\\n    q.enqueue(i);\\n    \\n    es -= 1;\\n  }\\n  \\n  let sum = 0;\\n  classes.forEach(([p, t]) => {\\n    sum += p / t;\\n  });\\n  \\n  return sum / classes.length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110765,
                "title": "java-priorityqueue-o-mlogn-nlogn",
                "content": "\\n\\t// O(m*logn+n*logn)\\n\\t// PriorityQueue\\n\\tpublic double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\n\\t\\tPriorityQueue<double[]> heap = new PriorityQueue<double[]>(new Comparator<double[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(double[] o1, double[] o2) {\\n\\t\\t\\t\\treturn Double.compare(o2[0], o1[0]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tfor (int[] clas : classes) {\\n\\t\\t\\tdouble delta = profit(clas[0], clas[1]);\\n\\t\\t\\theap.offer(new double[] { delta, clas[0], clas[1] });\\n\\t\\t}\\n\\n\\t\\twhile (extraStudents >= 1) {\\n\\t\\t\\tdouble[] temp = heap.poll();\\n\\t\\t\\tdouble pass = temp[1] + 1, total = temp[2] + 1;\\n\\t\\t\\tdouble delta = profit(pass, total);\\n\\t\\t\\theap.offer(new double[] { delta, pass, total });\\n\\t\\t\\textraStudents--;\\n\\t\\t}\\n\\n\\t\\tdouble average = 0d;\\n\\t\\twhile (!heap.isEmpty()) {\\n\\t\\t\\tdouble[] temp = heap.poll();\\n\\t\\t\\taverage += temp[1] / temp[2];\\n\\t\\t}\\n\\n\\t\\treturn average / classes.length;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic double profit(double a, double b) {\\n\\t\\treturn (a + 1) / (b + 1) - a / b;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\t// O(m*logn+n*logn)\\n\\t// PriorityQueue\\n\\tpublic double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\n\\t\\tPriorityQueue<double[]> heap = new PriorityQueue<double[]>(new Comparator<double[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(double[] o1, double[] o2) {\\n\\t\\t\\t\\treturn Double.compare(o2[0], o1[0]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tfor (int[] clas : classes) {\\n\\t\\t\\tdouble delta = profit(clas[0], clas[1]);\\n\\t\\t\\theap.offer(new double[] { delta, clas[0], clas[1] });\\n\\t\\t}\\n\\n\\t\\twhile (extraStudents >= 1) {\\n\\t\\t\\tdouble[] temp = heap.poll();\\n\\t\\t\\tdouble pass = temp[1] + 1, total = temp[2] + 1;\\n\\t\\t\\tdouble delta = profit(pass, total);\\n\\t\\t\\theap.offer(new double[] { delta, pass, total });\\n\\t\\t\\textraStudents--;\\n\\t\\t}\\n\\n\\t\\tdouble average = 0d;\\n\\t\\twhile (!heap.isEmpty()) {\\n\\t\\t\\tdouble[] temp = heap.poll();\\n\\t\\t\\taverage += temp[1] / temp[2];\\n\\t\\t}\\n\\n\\t\\treturn average / classes.length;\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic double profit(double a, double b) {\\n\\t\\treturn (a + 1) / (b + 1) - a / b;\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1108903,
                "title": "so-beat-100-is-meaningless-at-least-for-c",
                "content": "Basically, I submitted twice using C++ in contest, one got TLE, and one got AC, but they both passed after contest, and beat 100%. Shown as below:\\n\\nTLE one:\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<heapNode, vector<heapNode>, less<heapNode>> heap;\\n        for(auto item : classes) {\\n            heap.push(heapNode(item[0], item[1]));\\n        }\\n        for(int i = 0; i < extraStudents; ++i) {\\n            auto tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            heap.push(heapNode(tmp.pass + 1, tmp.all + 1));\\n        }\\n        // cout << \"-----\" << endl;\\n        double res = 0;\\n        while(heap.size()) {\\n            heapNode tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            res += tmp.pass / tmp.all;\\n        }\\n        res = res / (double(classes.size()));\\n        return res;\\n    }\\nprivate:\\n    struct heapNode {\\n        double pass, all;\\n        double foreseen;\\n        heapNode(double x, double y) : pass(x), all(y) {\\n            foreseen = (pass + 1) / (all + 1) - pass / all;\\n        }\\n        const bool operator < (const heapNode &p) const {\\n            return this->foreseen < p.foreseen;\\n        }\\n        void print() {\\n            cout << pass << \" \" << all << endl;\\n        }\\n    };\\n};\\n```\\n\\nAC one:\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<heapNode, vector<heapNode>, less<heapNode>> heap;\\n        for(auto item : classes) {\\n            heap.push(heapNode(item[0], item[1]));\\n        }\\n        for(int i = 0; i < extraStudents; ++i) {\\n            auto tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            heap.push(heapNode(tmp.pass + 1, tmp.all + 1));\\n        }\\n        // cout << \"-----\" << endl;\\n        double res = 0;\\n        while(heap.size()) {\\n            heapNode tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            res += tmp.pass / tmp.all;\\n        }\\n        res = res / (double(classes.size()));\\n        return res;\\n    }\\nprivate:\\n    struct heapNode {\\n        double pass, all;\\n        double foreseen;\\n        heapNode(double x, double y) : pass(x), all(y), foreseen((pass + 1) / (all + 1) - pass / all) {}\\n        const bool operator < (const heapNode &p) const {\\n            return this->foreseen < p.foreseen;\\n        }\\n    };\\n};\\n```\\n\\nAnd during the contest it took 1464ms to AC, I submitted a third time using the AC code and ACed in 1884ms. (Very likely the time threshold is 2000ms)\\n\\nAs you can see there is **no** optimization between the two solution. And just before I re-submitted the above two pieces of code, **both** of them got AC, and with 996 - 984ms and told me the solution beats 100% of C++ submission, what a nice satire, leetcode! The unchanged pre-TLE code is actually a p100 level solution! \\n\\nOK backing to reasoning I can assume that it probably because of the spike of submission during the contest period impacted the judger\\'s performance. And it is reasonable that as lc got hotter, more and more people join the contest, the service quality may deterioate. But this is the first time I experienced that this issue impact the submission status, and I don\\'t think this should happen because the wrong submission status is greatly misleading especially during the contest. Feel really bad on this.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<heapNode, vector<heapNode>, less<heapNode>> heap;\\n        for(auto item : classes) {\\n            heap.push(heapNode(item[0], item[1]));\\n        }\\n        for(int i = 0; i < extraStudents; ++i) {\\n            auto tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            heap.push(heapNode(tmp.pass + 1, tmp.all + 1));\\n        }\\n        // cout << \"-----\" << endl;\\n        double res = 0;\\n        while(heap.size()) {\\n            heapNode tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            res += tmp.pass / tmp.all;\\n        }\\n        res = res / (double(classes.size()));\\n        return res;\\n    }\\nprivate:\\n    struct heapNode {\\n        double pass, all;\\n        double foreseen;\\n        heapNode(double x, double y) : pass(x), all(y) {\\n            foreseen = (pass + 1) / (all + 1) - pass / all;\\n        }\\n        const bool operator < (const heapNode &p) const {\\n            return this->foreseen < p.foreseen;\\n        }\\n        void print() {\\n            cout << pass << \" \" << all << endl;\\n        }\\n    };\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<heapNode, vector<heapNode>, less<heapNode>> heap;\\n        for(auto item : classes) {\\n            heap.push(heapNode(item[0], item[1]));\\n        }\\n        for(int i = 0; i < extraStudents; ++i) {\\n            auto tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            heap.push(heapNode(tmp.pass + 1, tmp.all + 1));\\n        }\\n        // cout << \"-----\" << endl;\\n        double res = 0;\\n        while(heap.size()) {\\n            heapNode tmp = heap.top();\\n            // tmp.print();\\n            heap.pop();\\n            res += tmp.pass / tmp.all;\\n        }\\n        res = res / (double(classes.size()));\\n        return res;\\n    }\\nprivate:\\n    struct heapNode {\\n        double pass, all;\\n        double foreseen;\\n        heapNode(double x, double y) : pass(x), all(y), foreseen((pass + 1) / (all + 1) - pass / all) {}\\n        const bool operator < (const heapNode &p) const {\\n            return this->foreseen < p.foreseen;\\n        }\\n    };\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1108418,
                "title": "python-simple-solution-explained-priority-queue",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        # Organize the heap based on the \"ratio improvement factor\"\\n        # i.e. The (new ratio) - (old ratio), the one that will improve the largest should be the one added to\\n        # Add a negative since all heaps are minimum-oriented in python\\n        classes = [[-((p+1)/(t+1) - (p/t)), p, t] for p, t in classes]\\n        heapq.heapify(classes)\\n        \\n        # Go through the amount of students we need to add\\n        for _ in range(extraStudents):\\n            # Remove the next largest opportunity\\n            c = heapq.heappop(classes)\\n            \\n            # Change all of the values\\n            c[1] += 1\\n            c[2] += 1\\n            # Update ratio factor\\n            c[0] = -((c[1]+1)/(c[2]+1) - (c[1]/c[2]))\\n            # Push this back on to the heap\\n            heapq.heappush(classes, c)\\n            \\n        # Calculate the total pass ratio after doing this\\n        total_ratio = 0\\n        n = 0\\n        for c in sorted(classes):\\n            n += 1\\n            total_ratio += (c[1] / c[2])\\n            \\n        return total_ratio / n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        # Organize the heap based on the \"ratio improvement factor\"\\n        # i.e. The (new ratio) - (old ratio), the one that will improve the largest should be the one added to\\n        # Add a negative since all heaps are minimum-oriented in python\\n        classes = [[-((p+1)/(t+1) - (p/t)), p, t] for p, t in classes]\\n        heapq.heapify(classes)\\n        \\n        # Go through the amount of students we need to add\\n        for _ in range(extraStudents):\\n            # Remove the next largest opportunity\\n            c = heapq.heappop(classes)\\n            \\n            # Change all of the values\\n            c[1] += 1\\n            c[2] += 1\\n            # Update ratio factor\\n            c[0] = -((c[1]+1)/(c[2]+1) - (c[1]/c[2]))\\n            # Push this back on to the heap\\n            heapq.heappush(classes, c)\\n            \\n        # Calculate the total pass ratio after doing this\\n        total_ratio = 0\\n        n = 0\\n        for c in sorted(classes):\\n            n += 1\\n            total_ratio += (c[1] / c[2])\\n            \\n        return total_ratio / n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108344,
                "title": "c-use-set-to-track-the-most-effective-at-the-end",
                "content": "~~~\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int extraStudents) {\\n        set<pair<double, int>> s;\\n        int n = c.size();\\n        for (int i = 0; i < n; ++i) {\\n            double d = 1.0 * (c[i][0] + 1) / (c[i][1] + 1) - 1.0 * c[i][0] / c[i][1];\\n            s.insert({d, i});\\n        }\\n        \\n        while (extraStudents > 0) {\\n            auto it = s.rbegin();\\n            int i = it->second;\\n            s.erase(*it);\\n            c[i][0] = c[i][0] + 1; \\n            c[i][1] = c[i][1] + 1; \\n            double d = 1.0 * (c[i][0] + 1) / (c[i][1] + 1) - 1.0 * c[i][0] / c[i][1];\\n            s.insert({d, i});\\n            --extraStudents;\\n        }\\n        \\n        double res = 0.0;\\n        for (int i = 0; i < n; ++i) {\\n            res += 1.0 * c[i][0] / c[i][1];\\n        }\\n        return res/n;\\n    }\\n};\\n~~~\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int extraStudents) {\\n        set<pair<double, int>> s;\\n        int n = c.size();\\n        for (int i = 0; i < n; ++i) {\\n            double d = 1.0 * (c[i][0] + 1) / (c[i][1] + 1) - 1.0 * c[i][0] / c[i][1];\\n            s.insert({d, i}",
                "codeTag": "Java"
            },
            {
                "id": 1108269,
                "title": "greedy-use-priority-queue-to-get-the-maximum-increasement-o-nlogn-binary-serach-doesn-t-work",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double, pair<int, int> > > pq;\\n        for(auto &cls : classes) {\\n            int t = cls[1], p = cls[0];\\n            double add = (p + 1) * 1.0 / (t + 1) - (p * 1.0 / t);\\n            pq.push({add, {p, t}});\\n        }\\n        while(extraStudents--) {\\n            auto p = pq.top(); pq.pop();\\n            int &t = p.second.second;\\n            int &pa = p.second.first;\\n            ++t; ++pa;\\n            p.first = (pa + 1) * 1.0 / (t + 1) - pa * 1.0 / t;\\n            pq.push(p);\\n        }\\n        double res = 0;\\n        while(pq.size()) {\\n            res += pq.top().second.first * 1.0 / pq.top().second.second; pq.pop();\\n        }\\n        return res / classes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double, pair<int, int> > > pq;\\n        for(auto &cls : classes) {\\n            int t = cls[1], p = cls[0];\\n            double add = (p + 1) * 1.0 / (t + 1) - (p * 1.0 / t);\\n            pq.push({add, {p, t}});\\n        }\\n        while(extraStudents--) {\\n            auto p = pq.top(); pq.pop();\\n            int &t = p.second.second;\\n            int &pa = p.second.first;\\n            ++t; ++pa;\\n            p.first = (pa + 1) * 1.0 / (t + 1) - pa * 1.0 / t;\\n            pq.push(p);\\n        }\\n        double res = 0;\\n        while(pq.size()) {\\n            res += pq.top().second.first * 1.0 / pq.top().second.second; pq.pop();\\n        }\\n        return res / classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911969,
                "title": "c-priority-queue-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int k) {\\n        priority_queue<pair<double,int>> pq;\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            int curr_n = classes[i][0];\\n            int curr_d = classes[i][1];\\n            double curr_f = (double)curr_n/(double)curr_d;\\n            int new_n = curr_n+1;\\n            int new_d = curr_d+1;\\n            double new_f = (double)new_n/(double)new_d;\\n\\n            pq.push({new_f-curr_f,i});\\n        }\\n\\n        while(k)\\n        {\\n            pair<double,int> p = pq.top();\\n            pq.pop();\\n            int index = p.second;\\n            classes[index][0]+=1;\\n            classes[index][1]+=1;\\n\\n            int new_n = classes[index][0]+1;\\n            int new_d = classes[index][1]+1;\\n            double new_f = (double)new_n/(double)new_d;\\n            double curr_f = (double)classes[index][0]/(double)classes[index][1];\\n\\n            pq.push({new_f-curr_f,index});\\n            k--;\\n        }\\n        double sum = 0;\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            sum+=(double)classes[i][0]/(double)classes[i][1];\\n        }\\n        return sum/(double)classes.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int k) {\\n        priority_queue<pair<double,int>> pq;\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            int curr_n = classes[i][0];\\n            int curr_d = classes[i][1];\\n            double curr_f = (double)curr_n/(double)curr_d;\\n            int new_n = curr_n+1;\\n            int new_d = curr_d+1;\\n            double new_f = (double)new_n/(double)new_d;\\n\\n            pq.push({new_f-curr_f,i});\\n        }\\n\\n        while(k)\\n        {\\n            pair<double,int> p = pq.top();\\n            pq.pop();\\n            int index = p.second;\\n            classes[index][0]+=1;\\n            classes[index][1]+=1;\\n\\n            int new_n = classes[index][0]+1;\\n            int new_d = classes[index][1]+1;\\n            double new_f = (double)new_n/(double)new_d;\\n            double curr_f = (double)classes[index][0]/(double)classes[index][1];\\n\\n            pq.push({new_f-curr_f,index});\\n            k--;\\n        }\\n        double sum = 0;\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            sum+=(double)classes[i][0]/(double)classes[i][1];\\n        }\\n        return sum/(double)classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254891,
                "title": "c-priority-queue-greedy",
                "content": "What the question ask? so we have to assign ExtraStudent in such class that we\"ll get maximum possible ratio . so How we\"ll do this . We have to send ExtraStudents to classes 1 by 1 according to their ratio(calculate the difference of all classes for 1 student) where we get more difference  we\"ll send the student to that particular class. and again check the difference for the next student .\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double,pair<int,int>>>pq;\\n        for(int i=0;i<classes.size();i++){\\n             int var1 = classes[i][0] , var2 = classes[i][1];\\n            double diff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n              pq.push({diff,{var1,var2}});\\n        }\\n        \\n        while(extraStudents!=0){\\n            int var1 = pq.top().second.first , var2 = pq.top().second.second;\\n            var1++;\\n            var2++;\\n            double newdiff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n            pq.pop();\\n             pq.push({newdiff,{var1,var2}});\\n            extraStudents--;\\n            \\n        }\\n        double ans = 0;\\n        while(!pq.empty()){\\n            ans += (double)(pq.top().second.first) /(pq.top().second.second);\\n            pq.pop();\\n        }\\n         \\n        return ans/classes.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double,pair<int,int>>>pq;\\n        for(int i=0;i<classes.size();i++){\\n             int var1 = classes[i][0] , var2 = classes[i][1];\\n            double diff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n              pq.push({diff,{var1,var2}});\\n        }\\n        \\n        while(extraStudents!=0){\\n            int var1 = pq.top().second.first , var2 = pq.top().second.second;\\n            var1++;\\n            var2++;\\n            double newdiff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n            pq.pop();\\n             pq.push({newdiff,{var1,var2}});\\n            extraStudents--;\\n            \\n        }\\n        double ans = 0;\\n        while(!pq.empty()){\\n            ans += (double)(pq.top().second.first) /(pq.top().second.second);\\n            pq.pop();\\n        }\\n         \\n        return ans/classes.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009314,
                "title": "java-priority-queue-clean-code-solution",
                "content": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> pq = new PriorityQueue<>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                double adiff = (a[0]+1)/(a[1]+1) - (a[0]/a[1]);                \\n                double bdiff = (b[0]+1)/(b[1]+1) - (b[0]/b[1]);\\n                if(adiff==bdiff) return 0;\\n                return adiff>bdiff? -1:1;\\n            }\\n        });\\n        \\n        for(int[] c:classes) pq.add(new double[]{c[0],c[1]});\\n        \\n        for(int i =0;i<extraStudents;i++){\\n            double[] curr = pq.poll();\\n            pq.add(new double[]{curr[0]+1,curr[1]+1});\\n        }\\n        \\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            double[] curr = pq.poll();\\n            sum+=curr[0]/curr[1];\\n        }\\n        \\n        return sum/classes.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> pq = new PriorityQueue<>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                double adiff = (a[0]+1)/(a[1]+1) - (a[0]/a[1]);                \\n                double bdiff = (b[0]+1)/(b[1]+1) - (b[0]/b[1]);\\n                if(adiff==bdiff) return 0;\\n                return adiff>bdiff? -1:1;\\n            }\\n        });\\n        \\n        for(int[] c:classes) pq.add(new double[]{c[0],c[1]});\\n        \\n        for(int i =0;i<extraStudents;i++){\\n            double[] curr = pq.poll();\\n            pq.add(new double[]{curr[0]+1,curr[1]+1});\\n        }\\n        \\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            double[] curr = pq.poll();\\n            sum+=curr[0]/curr[1];\\n        }\\n        \\n        return sum/classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813724,
                "title": "c-solution-explanation-priority-queue-1792",
                "content": "**How priority_queue (max heap) came into picture-->**\\nWe have to return maximum average pass ratio which is equal to sum of all pass ratios / number of classes. Where number of classes is constant so we need to increase the sum of all pass ratios.\\nIn each class there is a pass ratio before adding extra students, as we need to increase the pass ratio of a class so we will maintain the increase in ratio if a student is added into a class.\\nSuppose a class is given as [p,t], it\\'s original pass ratio is p/t so initially we will add p/t to our total sum of ratios then if a student is added to this class the new ratio is (p+1)/(t+1) which means the increase in the ratio is : new ratio - old ratio which is [(p+1)/(t+1) - p/t].\\nSo to maintain the profit (increase in ratio) in desc\\nending order we use priority_queue here.\\nAs the extra students are limited we need to add each student to the class which gives us the more profit (increase). Soon after adding the student we will increment our sum of ratios and also now the new ratio for this class will also be changed that should be added back to the queue.\\n```\\nclass Solution {\\npublic:\\n    double nextProfit(double p,double t){\\n        return ((p+1)/(t+1) - p/t);\\n    }\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double sumOfRatios = 0,p,t,profit;\\n        priority_queue<pair<double,pair<double,double>>>pq;\\n        for(vector<int>& v : classes){\\n            p = v[0]; t = v[1];\\n            sumOfRatios += p/t;\\n            profit = nextProfit(p,t);\\n            pq.push({profit,{p,t}});\\n        }\\n        pair<double,pair<double,double>>temp;\\n        while(extraStudents--){\\n            temp = pq.top(); pq.pop();\\n            profit = temp.first; p = temp.second.first; t = temp.second.second;\\n            sumOfRatios += profit;\\n            p++; t++; profit = nextProfit(p,t);\\n            pq.push({profit,{p,t}});\\n        }\\n        return (sumOfRatios/(double)classes.size());\\n    }\\n};\\n```\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank you :)**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double nextProfit(double p,double t){\\n        return ((p+1)/(t+1) - p/t);\\n    }\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double sumOfRatios = 0,p,t,profit;\\n        priority_queue<pair<double,pair<double,double>>>pq;\\n        for(vector<int>& v : classes){\\n            p = v[0]; t = v[1];\\n            sumOfRatios += p/t;\\n            profit = nextProfit(p,t);\\n            pq.push({profit,{p,t}});\\n        }\\n        pair<double,pair<double,double>>temp;\\n        while(extraStudents--){\\n            temp = pq.top(); pq.pop();\\n            profit = temp.first; p = temp.second.first; t = temp.second.second;\\n            sumOfRatios += profit;\\n            p++; t++; profit = nextProfit(p,t);\\n            pq.push({profit,{p,t}});\\n        }\\n        return (sumOfRatios/(double)classes.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478123,
                "title": "c-solution",
                "content": "```\\ndouble precise(double a)\\n{\\n   double  intpart;\\n   double fractpart = modf (a, &intpart);\\n   fractpart  = roundf(fractpart * 100000.0)/100000.0; // Round to 5 decimal places\\n   double b = intpart + fractpart;\\n    return b;\\n}\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int min_index= 0;\\n        double min_ratio= 0.00000, sum= 0.0;\\n        double cur_ratio= 0.0, new_ratio= 0.0;\\n        vector<double> ratio;\\n        int l= classes.size();\\n        multimap<double, int> mp;\\n        setprecision(5);\\n        for(int i= 0; i<l ;i++)\\n        {\\n            mp.insert({((double)classes[i][1]-(double)classes[i][0])/((double)classes[i][1]*((double)classes[i][1]+1)), i});\\n            ratio.push_back((double)classes[i][0]/(double)classes[i][1]);\\n        }\\n        for(int i= 0;i< extraStudents; i++)\\n        {\\n            int j= (--mp.end())->second;\\n            classes[j][0]+= 1;\\n            classes[j][1]+= 1;\\n            ratio[j]= (double)classes[j][0]/(double)classes[j][1];\\n            mp.erase(--mp.end());\\n            mp.insert({((double)classes[j][1]-(double)classes[j][0])/((double)classes[j][1]*((double)classes[j][1]+1)), j});\\n        }\\n        for(int i= 0;i< l;i++)\\n        {\\n            sum+= ratio[i];\\n            cout<<ratio[i]<<\\'\\\\n\\';\\n        }\\n        int k= (sum/l)*1e5;\\n        min_ratio= k/1e5;\\n        return min_ratio;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndouble precise(double a)\\n{\\n   double  intpart;\\n   double fractpart = modf (a, &intpart);\\n   fractpart  = roundf(fractpart * 100000.0)/100000.0; // Round to 5 decimal places\\n   double b = intpart + fractpart;\\n    return b;\\n}\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int min_index= 0;\\n        double min_ratio= 0.00000, sum= 0.0;\\n        double cur_ratio= 0.0, new_ratio= 0.0;\\n        vector<double> ratio;\\n        int l= classes.size();\\n        multimap<double, int> mp;\\n        setprecision(5);\\n        for(int i= 0; i<l ;i++)\\n        {\\n            mp.insert({((double)classes[i][1]-(double)classes[i][0])/((double)classes[i][1]*((double)classes[i][1]+1)), i});\\n            ratio.push_back((double)classes[i][0]/(double)classes[i][1]);\\n        }\\n        for(int i= 0;i< extraStudents; i++)\\n        {\\n            int j= (--mp.end())->second;\\n            classes[j][0]+= 1;\\n            classes[j][1]+= 1;\\n            ratio[j]= (double)classes[j][0]/(double)classes[j][1];\\n            mp.erase(--mp.end());\\n            mp.insert({((double)classes[j][1]-(double)classes[j][0])/((double)classes[j][1]*((double)classes[j][1]+1)), j});\\n        }\\n        for(int i= 0;i< l;i++)\\n        {\\n            sum+= ratio[i];\\n            cout<<ratio[i]<<\\'\\\\n\\';\\n        }\\n        int k= (sum/l)*1e5;\\n        min_ratio= k/1e5;\\n        return min_ratio;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1383121,
                "title": "c-sortedset",
                "content": "```\\npublic class Solution {\\n    public double MaxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        var set = new SortedSet<(double delta, int index, double pass, double total)>();\\n        int index = 0;\\n        \\n        double avg = 0.0;\\n        foreach(var cl in classes)\\n        {\\n            double a = cl[0], b = cl[1];\\n            avg += a/b;              \\n            set.Add((GetDeltaGain(a, b), index++, a + 1, b + 1)); //gotcha\\n        }\\n        \\n        while(extraStudents-- > 0)\\n        {            \\n            var max = set.Max;\\n            set.Remove(set.Max);            \\n            avg += max.delta;\\n            set.Add((GetDeltaGain(max.pass, max.total), index++, max.pass + 1, max.total + 1));           \\n        }       \\n       \\n        return avg/classes.Length;\\n    }\\n    \\n    private double GetDeltaGain(double a, double b)\\n    {\\n        return (a + 1)/(b + 1) - a/b; //gotcha gotcha gotcha -- BRACKETS\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double MaxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        var set = new SortedSet<(double delta, int index, double pass, double total)>();\\n        int index = 0;\\n        \\n        double avg = 0.0;\\n        foreach(var cl in classes)\\n        {\\n            double a = cl[0], b = cl[1];\\n            avg += a/b;              \\n            set.Add((GetDeltaGain(a, b), index++, a + 1, b + 1)); //gotcha\\n        }\\n        \\n        while(extraStudents-- > 0)\\n        {            \\n            var max = set.Max;\\n            set.Remove(set.Max);            \\n            avg += max.delta;\\n            set.Add((GetDeltaGain(max.pass, max.total), index++, max.pass + 1, max.total + 1));           \\n        }       \\n       \\n        return avg/classes.Length;\\n    }\\n    \\n    private double GetDeltaGain(double a, double b)\\n    {\\n        return (a + 1)/(b + 1) - a/b; //gotcha gotcha gotcha -- BRACKETS\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315658,
                "title": "python-solution-with-heap-with-the-idea",
                "content": "The idea is add each student such that their addition increases the particular class average more.\\n\\nFor this, I maintained a heap in which i keep adding what will be the change in average with addition of one student to that particular class. i.e., `x/y - (x+1)/(y+1)` will be the negative value of change in average with addition of one student in it.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        heap=[]\\n        for x,y in classes:\\n            heapq.heappush(heap, (x/y -(x+1)/(y+1) ,x,y))\\n            \\n        while extraStudents:\\n            extraStudents-=1\\n            perc,x,y =heapq.heappop(heap)\\n            x+=1\\n            y+=1\\n            heapq.heappush(heap, (x/y -(x+1)/(y+1) ,x,y))\\n\\n            #print(heap)\\n            \\n        return sum(y/z for x,y,z in heap)/len(heap)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        heap=[]\\n        for x,y in classes:\\n            heapq.heappush(heap, (x/y -(x+1)/(y+1) ,x,y))\\n            \\n        while extraStudents:\\n            extraStudents-=1\\n            perc,x,y =heapq.heappop(heap)\\n            x+=1\\n            y+=1\\n            heapq.heappush(heap, (x/y -(x+1)/(y+1) ,x,y))\\n\\n            #print(heap)\\n            \\n        return sum(y/z for x,y,z in heap)/len(heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303447,
                "title": "python-solution-heap",
                "content": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        h = []\\n        n=len(classes)\\n        \\n        \\n        for i in classes:\\n            currpassration = i[0]/i[1]\\n            ifaddthan = (i[0]+1)/ (i[1]+1)\\n            \\n            increase = ifaddthan - currpassration\\n            heappush(h,(-increase, currpassration,i[0],i[1]))\\n            \\n        heapify(h)\\n        \\n        while extraStudents:\\n\\n            a,curr,pas, tot = heappop(h)\\n            a=-a            \\n            curr +=a\\n            ifaddthan = (pas+2)/(tot+2)\\n            \\n            increase = ifaddthan - curr\\n            heappush(h, (-increase, curr, pas+1,tot+1))\\n            \\n            extraStudents-=1\\n        \\n        ps=0\\n        tot=0\\n        \\n        while h:\\n            a=h.pop()\\n            ps+=a[1]\\n        return ps/n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        h = []\\n        n=len(classes)\\n        \\n        \\n        for i in classes:\\n            currpassration = i[0]/i[1]\\n            ifaddthan = (i[0]+1)/ (i[1]+1)\\n            \\n            increase = ifaddthan - currpassration\\n            heappush(h,(-increase, currpassration,i[0],i[1]))\\n            \\n        heapify(h)\\n        \\n        while extraStudents:\\n\\n            a,curr,pas, tot = heappop(h)\\n            a=-a            \\n            curr +=a\\n            ifaddthan = (pas+2)/(tot+2)\\n            \\n            increase = ifaddthan - curr\\n            heappush(h, (-increase, curr, pas+1,tot+1))\\n            \\n            extraStudents-=1\\n        \\n        ps=0\\n        tot=0\\n        \\n        while h:\\n            a=h.pop()\\n            ps+=a[1]\\n        return ps/n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280681,
                "title": "python-heap-solution",
                "content": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], e: int) -> float:\\n        heap=[]\\n        for i,j in classes:\\n            diff=(i+1)/(j+1)-(i/j)\\n            heapq.heappush(heap,(-diff,i,j))\\n        while(e>0):\\n            diff,i,j=heapq.heappop(heap)\\n            i+=1\\n            j+=1\\n            diff=(i+1)/(j+1)-(i/j)\\n            heapq.heappush(heap,(-diff,i,j))\\n            e-=1\\n        ans=0\\n        for diff,i,j in heap:\\n            ans+=(i/j)\\n        return ans/len(classes)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], e: int) -> float:\\n        heap=[]\\n        for i,j in classes:\\n            diff=(i+1)/(j+1)-(i/j)\\n            heapq.heappush(heap,(-diff,i,j))\\n        while(e>0):\\n            diff,i,j=heapq.heappop(heap)\\n            i+=1\\n            j+=1\\n            diff=(i+1)/(j+1)-(i/j)\\n            heapq.heappush(heap,(-diff,i,j))\\n            e-=1\\n        ans=0\\n        for diff,i,j in heap:\\n            ans+=(i/j)\\n        return ans/len(classes)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1166299,
                "title": "javascript-max-heap-approach-o-n-logn-time",
                "content": "Time: `O((N + M) * logN)` where `N` is # of  `classes` and `M` is # of `extraStudents`\\nSpace: `O(N)`\\n```javascript\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    const heap = new MaxPriorityQueue({priority: x => x[2]});\\n    \\n    for(let [pass, total] of classes) {\\n        const before = pass/total;\\n        const after = (pass+1)/(total+1)\\n        heap.enqueue([pass, total, after-before]);\\n    }\\n    \\n    while(extraStudents--) {\\n        let [pass, total] = heap.dequeue().element;\\n        pass++;\\n        total++;\\n        const before = pass/total;\\n        const after = (pass+1)/(total+1);\\n        heap.enqueue([pass, total, after-before]);\\n    }\\n    \\n    let sum = 0;\\n    \\n    while(!heap.isEmpty()) {\\n        const [pass, total] = heap.dequeue().element;\\n        sum += (pass/total);\\n    }\\n    return sum/classes.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    const heap = new MaxPriorityQueue({priority: x => x[2]});\\n    \\n    for(let [pass, total] of classes) {\\n        const before = pass/total;\\n        const after = (pass+1)/(total+1)\\n        heap.enqueue([pass, total, after-before]);\\n    }\\n    \\n    while(extraStudents--) {\\n        let [pass, total] = heap.dequeue().element;\\n        pass++;\\n        total++;\\n        const before = pass/total;\\n        const after = (pass+1)/(total+1);\\n        heap.enqueue([pass, total, after-before]);\\n    }\\n    \\n    let sum = 0;\\n    \\n    while(!heap.isEmpty()) {\\n        const [pass, total] = heap.dequeue().element;\\n        sum += (pass/total);\\n    }\\n    return sum/classes.length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144308,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double,int>> q;\\n        \\n        for(int i=0;i<classes.size();i++){\\n            double a=(float)(classes[i][0]+1)/(float)(classes[i][1]+1)-(float)classes[i][0]/(float)classes[i][1];\\n            q.push(make_pair(a,i));\\n        }\\n        for(int j=0;j<extraStudents;j++){\\n            int i=q.top().second;\\n            classes[i][0]++;\\n            classes[i][1]++;\\n            double a=(float)(classes[i][0]+1)/(float)(classes[i][1]+1)-(float)classes[i][0]/(float)classes[i][1];\\n            q.pop();\\n            q.push(make_pair(a,i));\\n        }\\n        \\n        double ans=0;\\n        for (int i=0;i<classes.size();i++){\\n            ans+=(float)classes[i][0]/(float)classes[i][1];\\n        }\\n        return ans/classes.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double,int>> q;\\n        \\n        for(int i=0;i<classes.size();i++){\\n            double a=(float)(classes[i][0]+1)/(float)(classes[i][1]+1)-(float)classes[i][0]/(float)classes[i][1];\\n            q.push(make_pair(a,i));\\n        }\\n        for(int j=0;j<extraStudents;j++){\\n            int i=q.top().second;\\n            classes[i][0]++;\\n            classes[i][1]++;\\n            double a=(float)(classes[i][0]+1)/(float)(classes[i][1]+1)-(float)classes[i][0]/(float)classes[i][1];\\n            q.pop();\\n            q.push(make_pair(a,i));\\n        }\\n        \\n        double ans=0;\\n        for (int i=0;i<classes.size();i++){\\n            ans+=(float)classes[i][0]/(float)classes[i][1];\\n        }\\n        return ans/classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117899,
                "title": "java-simple-and-easy-solution-using-max-heap-and-faster-than-100-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        //max heap\\n        //here we are using Max Heap, whaich has maximum element in root\\n        PriorityQueue<Class> maxHeap = new PriorityQueue<Class>(Comparator.comparingDouble(o -> -o.gainPassRatio));\\n        \\n        \\n        for(int[] eachClass : classes){\\n            int pass = eachClass[0];\\n            int total = eachClass[1];\\n            \\n            maxHeap.add(new Class(pass, total,  getGainPassRatio(pass, total)));\\n        }\\n        \\n        \\n        while(extraStudents --> 0){\\n            //we are using Gready Approach \\n            //get the class, which will have a maximum \\n            //gain in passing ratio, if we add a student\\n            Class c =  maxHeap.remove();\\n            \\n            //this class will have maximum gain in passing ratio\\n            //so add 1 extra student (who always pass)\\n            c.pass = c.pass + 1;\\n            c.total = c.total + 1;\\n            c.gainPassRatio = getGainPassRatio(c.pass + 1, c.total + 1);\\n            \\n            maxHeap.add(c);\\n        }\\n        \\n        double passRatioSum = 0.0d;\\n        while(!maxHeap.isEmpty()){\\n            Class c =  maxHeap.remove();\\n            passRatioSum += ((double)c.pass / c.total);\\n        }\\n        \\n        \\n        return passRatioSum / classes.length;\\n    }\\n    \\n    private double getGainPassRatio(int pass, int total){\\n        double passRatio =  (double)pass / total;\\n        \\n        //add 1 student, \\n        pass++;\\n        total++;\\n        \\n        double passRatioAfterAdding = (double)pass / total;\\n        \\n        //find gain in passing ratio, if we add 1 student\\n        return passRatioAfterAdding - passRatio; \\n    }\\n}\\n\\nclass Class {\\n    int pass;\\n    int total;\\n    double gainPassRatio;\\n    \\n    public Class(int pass, int total, double gainPassRatio){\\n        this.pass = pass;\\n        this.total = total;\\n        this.gainPassRatio = gainPassRatio;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        //max heap\\n        //here we are using Max Heap, whaich has maximum element in root\\n        PriorityQueue<Class> maxHeap = new PriorityQueue<Class>(Comparator.comparingDouble(o -> -o.gainPassRatio));\\n        \\n        \\n        for(int[] eachClass : classes){\\n            int pass = eachClass[0];\\n            int total = eachClass[1];\\n            \\n            maxHeap.add(new Class(pass, total,  getGainPassRatio(pass, total)));\\n        }\\n        \\n        \\n        while(extraStudents --> 0){\\n            //we are using Gready Approach \\n            //get the class, which will have a maximum \\n            //gain in passing ratio, if we add a student\\n            Class c =  maxHeap.remove();\\n            \\n            //this class will have maximum gain in passing ratio\\n            //so add 1 extra student (who always pass)\\n            c.pass = c.pass + 1;\\n            c.total = c.total + 1;\\n            c.gainPassRatio = getGainPassRatio(c.pass + 1, c.total + 1);\\n            \\n            maxHeap.add(c);\\n        }\\n        \\n        double passRatioSum = 0.0d;\\n        while(!maxHeap.isEmpty()){\\n            Class c =  maxHeap.remove();\\n            passRatioSum += ((double)c.pass / c.total);\\n        }\\n        \\n        \\n        return passRatioSum / classes.length;\\n    }\\n    \\n    private double getGainPassRatio(int pass, int total){\\n        double passRatio =  (double)pass / total;\\n        \\n        //add 1 student, \\n        pass++;\\n        total++;\\n        \\n        double passRatioAfterAdding = (double)pass / total;\\n        \\n        //find gain in passing ratio, if we add 1 student\\n        return passRatioAfterAdding - passRatio; \\n    }\\n}\\n\\nclass Class {\\n    int pass;\\n    int total;\\n    double gainPassRatio;\\n    \\n    public Class(int pass, int total, double gainPassRatio){\\n        this.pass = pass;\\n        this.total = total;\\n        this.gainPassRatio = gainPassRatio;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110658,
                "title": "simple-c-solution-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<long double,pair<long long int,long long int>>>pq;\\n        for(auto it:classes)\\n        {\\n            long long int z=(it[1]);\\n            z=z*(it[1]+1);\\n            long double pt=1.0*(it[1]-it[0])/z;\\n            pq.push({pt,{it[0],it[1]}});\\n        }\\n        for(int i=0;i<extraStudents;i++)\\n        {\\n            long long int t1=pq.top().second.first+1;\\n            long long int t2=pq.top().second.second+1;\\n            long long int z=t2;\\n            z=z*(t2+1);\\n            long double g=1.0*(t2-t1)/z;\\n            pq.pop();\\n            pq.push({g,{t1,t2}});\\n        }  \\n        long double avg=0;\\n        while(!pq.empty())\\n        {\\n            avg+=1.0*(pq.top().second.first)/(pq.top().second.second);\\n            pq.pop();\\n        }\\n        return 1.0*avg/classes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<long double,pair<long long int,long long int>>>pq;\\n        for(auto it:classes)\\n        {\\n            long long int z=(it[1]);\\n            z=z*(it[1]+1);\\n            long double pt=1.0*(it[1]-it[0])/z;\\n            pq.push({pt,{it[0],it[1]}});\\n        }\\n        for(int i=0;i<extraStudents;i++)\\n        {\\n            long long int t1=pq.top().second.first+1;\\n            long long int t2=pq.top().second.second+1;\\n            long long int z=t2;\\n            z=z*(t2+1);\\n            long double g=1.0*(t2-t1)/z;\\n            pq.pop();\\n            pq.push({g,{t1,t2}});\\n        }  \\n        long double avg=0;\\n        while(!pq.empty())\\n        {\\n            avg+=1.0*(pq.top().second.first)/(pq.top().second.second);\\n            pq.pop();\\n        }\\n        return 1.0*avg/classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109577,
                "title": "java-priorityqueue-solution-beats-100",
                "content": "```\\npublic double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\tQueue<double[]> pq = new PriorityQueue<>((a,b) -> {\\n\\t\\tdouble ratioDiffA = (a[0] + 1) / (a[1] + 1) - a[0] / a[1];\\n\\t\\tdouble ratioDiffB = (b[0] + 1) / (b[1] + 1) - b[0] / b[1];\\n\\t\\treturn Double.compare(ratioDiffB, ratioDiffA);\\n\\t});\\n\\tfor (int[] c : classes) {\\n\\t\\tpq.add(new double[]{c[0], c[1]});\\n\\t}\\n\\twhile (extraStudents-- > 0) {\\n\\t\\tdouble[] c = pq.poll();\\n\\t\\tc[0]++;\\n\\t\\tc[1]++;\\n\\t\\tpq.add(c);\\n\\t}\\n\\tdouble ratioSum = 0;\\n\\tfor (double[] c : pq) {\\n\\t\\tratioSum += c[0] / c[1];\\n\\t}\\n\\treturn ratioSum / classes.length;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\tQueue<double[]> pq = new PriorityQueue<>((a,b) -> {\\n\\t\\tdouble ratioDiffA = (a[0] + 1) / (a[1] + 1) - a[0] / a[1];\\n\\t\\tdouble ratioDiffB = (b[0] + 1) / (b[1] + 1) - b[0] / b[1];\\n\\t\\treturn Double.compare(ratioDiffB, ratioDiffA);\\n\\t});\\n\\tfor (int[] c : classes) {\\n\\t\\tpq.add(new double[]{c[0], c[1]});\\n\\t}\\n\\twhile (extraStudents-- > 0) {\\n\\t\\tdouble[] c = pq.poll();\\n\\t\\tc[0]++;\\n\\t\\tc[1]++;\\n\\t\\tpq.add(c);\\n\\t}\\n\\tdouble ratioSum = 0;\\n\\tfor (double[] c : pq) {\\n\\t\\tratioSum += c[0] / c[1];\\n\\t}\\n\\treturn ratioSum / classes.length;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108740,
                "title": "c-simple-heap-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/maximum-average-pass-ratio/\\n    \\n    At a glance the obvious choice seems like picking the class with least pass\\n    ratio each time and adding a genius student. But this only brings the lower \\n    ratio scores near the avg, doesn\\'t try to increase the max observed score or\\n    decide where to add a student in case two classes have the same pass ratio.\\n    So to answer the above ques, we use the delta change increment in avg ratio score.\\n    The class that can show the max change is picked and a student is added there.\\n    This way a class with max promise is always picked.\\n    \\n    TC: O(nlogn + klogn + nlogn) ~ O((n+k)logn), n: no. of classes\\n*/\\n\\nclass Solution {\\npublic:\\n    // Computes the change seen when a new student is added to current class strength\\n    double delta_increment(int &pass, int &total) {\\n        return (double) (pass + 1) / (total + 1) - (double)pass / total;    \\n    }\\n    \\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        // Max heap wrt to the delta increment each class pass ratio can achieve\\n        priority_queue< tuple<double, int, int>, vector< tuple<double, int, int> >> max_heap;\\n        \\n        for(auto class_score: classes) \\n            max_heap.emplace(make_tuple(delta_increment(class_score[0], class_score[1]),\\n                                         class_score[0], class_score[1]));\\n        \\n        // Add the genius students to those classes where the ratio increment is max\\n        while(extraStudents--) {\\n            auto max_delta_class = max_heap.top();\\n            max_heap.pop();\\n            auto [delta, pass, total] = max_delta_class;\\n            ++pass, ++total;\\n            max_heap.emplace(make_tuple(delta_increment(pass, total), pass, total));\\n        }\\n        \\n        // Find the total avg class pass ratio\\n        double avg_pass = 0;\\n        while(!max_heap.empty()) {\\n            auto max_delta_class = max_heap.top();\\n            max_heap.pop();\\n            avg_pass += (double)get<1>(max_delta_class) / get<2>(max_delta_class);\\n        }\\n        return avg_pass / classes.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/maximum-average-pass-ratio/\\n    \\n    At a glance the obvious choice seems like picking the class with least pass\\n    ratio each time and adding a genius student. But this only brings the lower \\n    ratio scores near the avg, doesn\\'t try to increase the max observed score or\\n    decide where to add a student in case two classes have the same pass ratio.\\n    So to answer the above ques, we use the delta change increment in avg ratio score.\\n    The class that can show the max change is picked and a student is added there.\\n    This way a class with max promise is always picked.\\n    \\n    TC: O(nlogn + klogn + nlogn) ~ O((n+k)logn), n: no. of classes\\n*/\\n\\nclass Solution {\\npublic:\\n    // Computes the change seen when a new student is added to current class strength\\n    double delta_increment(int &pass, int &total) {\\n        return (double) (pass + 1) / (total + 1) - (double)pass / total;    \\n    }\\n    \\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        // Max heap wrt to the delta increment each class pass ratio can achieve\\n        priority_queue< tuple<double, int, int>, vector< tuple<double, int, int> >> max_heap;\\n        \\n        for(auto class_score: classes) \\n            max_heap.emplace(make_tuple(delta_increment(class_score[0], class_score[1]),\\n                                         class_score[0], class_score[1]));\\n        \\n        // Add the genius students to those classes where the ratio increment is max\\n        while(extraStudents--) {\\n            auto max_delta_class = max_heap.top();\\n            max_heap.pop();\\n            auto [delta, pass, total] = max_delta_class;\\n            ++pass, ++total;\\n            max_heap.emplace(make_tuple(delta_increment(pass, total), pass, total));\\n        }\\n        \\n        // Find the total avg class pass ratio\\n        double avg_pass = 0;\\n        while(!max_heap.empty()) {\\n            auto max_delta_class = max_heap.top();\\n            max_heap.pop();\\n            avg_pass += (double)get<1>(max_delta_class) / get<2>(max_delta_class);\\n        }\\n        return avg_pass / classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108592,
                "title": "ruby-greedy-priority-queue",
                "content": "### Observation\\n\\nIf there is a class with pass equeals `p` and total students equals `t` then pass ration equals `p / t`.\\nAdding an extra student who passed exam increases ration by:\\n\\n```\\np + 1     p     (p + 1) * t - p * (t + 1)     t - p\\n-----  -  - =  -------------------------- = -----------\\nt + 1     t           t * (t + 1)           t * (t + 1) \\n```\\n\\n### Solution\\n\\nIgnore classed where all students pass the exam (pass ration `1` cannot be increased).\\nAll other store in a priority queue. Sort the queue by the increase ratio we can obtain by adding one extra student.\\n\\n```ruby\\ndef max_average_ratio(classes, extra_students)\\n  pq = classes.select { |p, t| p < t }.map { |p, t| [(t - p).to_f / (t * (t + 1)), p, t] }.sort\\n  while pq.any? && (extra_students -= 1) >= 0\\n    dr, p, t = pq.pop\\n    ndr = dr * t / (t + 2) # new ratio increase. Same as (t - p) / ((t + 1) * (t + 2))\\n\\n    idx = pq.bsearch_index { |dr, _, _| dr >= ndr } || pq.size\\n    pq.insert(idx, [ndr, p + 1, t + 1])\\n  end\\n  (pq.sum { |_, p, t| p.fdiv t } + classes.size - pq.size) / classes.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\np + 1     p     (p + 1) * t - p * (t + 1)     t - p\\n-----  -  - =  -------------------------- = -----------\\nt + 1     t           t * (t + 1)           t * (t + 1) \\n```\n```ruby\\ndef max_average_ratio(classes, extra_students)\\n  pq = classes.select { |p, t| p < t }.map { |p, t| [(t - p).to_f / (t * (t + 1)), p, t] }.sort\\n  while pq.any? && (extra_students -= 1) >= 0\\n    dr, p, t = pq.pop\\n    ndr = dr * t / (t + 2) # new ratio increase. Same as (t - p) / ((t + 1) * (t + 2))\\n\\n    idx = pq.bsearch_index { |dr, _, _| dr >= ndr } || pq.size\\n    pq.insert(idx, [ndr, p + 1, t + 1])\\n  end\\n  (pq.sum { |_, p, t| p.fdiv t } + classes.size - pq.size) / classes.size\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108541,
                "title": "c-using-priority-queue-simple-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    double mx(double a,double b)\\n    {\\n        return (a+1)/(b+1)-a/b;\\n    }\\n    \\n    double maxAverageRatio(vector<vector<int>>& cls, int extra) {\\n        priority_queue<pair<double,pair<double,double>>> pq;\\n        \\n        for(auto v:cls)\\n            pq.push({mx(v[0],v[1]),{v[0],v[1]}});\\n        \\n        while(extra--)\\n        {\\n            pair<double,pair<double,double>> p=pq.top();\\n            \\n            p.first=mx(p.second.first+1,p.second.second+1);\\n            pq.pop();\\n            p.second.first+=1;\\n            p.second.second+=1;\\n            pq.push(p);\\n        }\\n        double ans=0;\\n        while(!pq.empty())\\n        {\\n           pair<double,pair<double,double>> p=pq.top();\\n            pq.pop();\\n            ans+=p.second.first/p.second.second;\\n        }\\n        \\n        return ans/cls.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double mx(double a,double b)\\n    {\\n        return (a+1)/(b+1)-a/b;\\n    }\\n    \\n    double maxAverageRatio(vector<vector<int>>& cls, int extra) {\\n        priority_queue<pair<double,pair<double,double>>> pq;\\n        \\n        for(auto v:cls)\\n            pq.push({mx(v[0],v[1]),{v[0],v[1]}});\\n        \\n        while(extra--)\\n        {\\n            pair<double,pair<double,double>> p=pq.top();\\n            \\n            p.first=mx(p.second.first+1,p.second.second+1);\\n            pq.pop();\\n            p.second.first+=1;\\n            p.second.second+=1;\\n            pq.push(p);\\n        }\\n        double ans=0;\\n        while(!pq.empty())\\n        {\\n           pair<double,pair<double,double>> p=pq.top();\\n            pq.pop();\\n            ans+=p.second.first/p.second.second;\\n        }\\n        \\n        return ans/cls.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108514,
                "title": "c-simple-and-easy-to-understand-solution",
                "content": "**Ques : How we are arranging in priority queue ? Based on what factor comparator will arrange ?**\\n--> Based upon the gain of average after incrementing the existing values of {pass,total}. Gain should be maximum.\\n\\n```\\nclass comparator{\\n    public : \\n        int operator()(pair<int,int> &v1,pair<int,int> &v2){\\n            double new_val1=(double)(v1.first+1)/(v1.second+1);\\n            double old_val1=(double)v1.first/v1.second;\\n            \\n            double new_val2=(double)(v2.first+1)/(v2.second+1);\\n            double old_val2=(double)v2.first/v2.second;\\n            \\n            double diff1=new_val1-old_val1;\\n            double diff2=new_val2-old_val2;\\n            \\n            return (diff1<=diff2);\\n            \\n        }\\n};\\nclass Solution {\\npublic:\\n    \\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<int,int>, vector<pair<int,int> >,comparator> pq;\\n        int count=0;\\n        for(int i=0;i<classes.size();i++){\\n            if(classes[i][0]!=classes[i][1])\\n                pq.push(make_pair(classes[i][0],classes[i][1]));\\n            else    //if class with 100% pass average\\n                count++;\\n        }\\n        while(extraStudents>0 && !pq.empty()){\\n            pair<int,int> v=pq.top();pq.pop();\\n            v.first++,v.second++;\\n            pq.push(v);\\n            extraStudents--;\\n        }\\n        \\n        double pass=0,total=0;\\n        double ans=0;\\n       while(!pq.empty()){\\n            pair<int,int> v=pq.top();pq.pop();\\n            pass=v.first,total=v.second;\\n            ans+=pass/total;\\n        }\\n        ans+=count;\\n        return ans/classes.size();\\n    }\\n};\\n```\\n\\nPS - Same code will give TLE on 2 cases if we use vector instead of pair.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass comparator{\\n    public : \\n        int operator()(pair<int,int> &v1,pair<int,int> &v2){\\n            double new_val1=(double)(v1.first+1)/(v1.second+1);\\n            double old_val1=(double)v1.first/v1.second;\\n            \\n            double new_val2=(double)(v2.first+1)/(v2.second+1);\\n            double old_val2=(double)v2.first/v2.second;\\n            \\n            double diff1=new_val1-old_val1;\\n            double diff2=new_val2-old_val2;\\n            \\n            return (diff1<=diff2);\\n            \\n        }\\n};\\nclass Solution {\\npublic:\\n    \\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<int,int>, vector<pair<int,int> >,comparator> pq;\\n        int count=0;\\n        for(int i=0;i<classes.size();i++){\\n            if(classes[i][0]!=classes[i][1])\\n                pq.push(make_pair(classes[i][0],classes[i][1]));\\n            else    //if class with 100% pass average\\n                count++;\\n        }\\n        while(extraStudents>0 && !pq.empty()){\\n            pair<int,int> v=pq.top();pq.pop();\\n            v.first++,v.second++;\\n            pq.push(v);\\n            extraStudents--;\\n        }\\n        \\n        double pass=0,total=0;\\n        double ans=0;\\n       while(!pq.empty()){\\n            pair<int,int> v=pq.top();pq.pop();\\n            pass=v.first,total=v.second;\\n            ans+=pass/total;\\n        }\\n        ans+=count;\\n        return ans/classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108489,
                "title": "priority-queue-greedy-c-easy-solution-comments",
                "content": "### Explaination:\\nOur goal is to maximize average. So, we should add student in the class which can give us highest difference of pass ratio. To pick up highest difference from given difference Priority Queue(Max Heap) is useful. \\n\\n### Algorithm:\\n1. Add one to pass and total for each class. Calculate new pass ratio and compute difference between old pass ratio and new pass ratio for each class and push difference and class index in Priority Queue. \\n2. For each new student we have to determine in which class we can include it. So take top element of Priority Queue(having max diff. b/w new pass ration and old pass ratio). Increase classes[ind][0] and classes[ind][1] by one. Compute difference as mentioned in step 1 for ind and again push difference and class index in Priority Queue.\\n3. After that for each class compute pass ratio and add them into one variable. Return sum of pass ratio / number of classes.\\n\\n### Code:\\n\\nclass Solution {\\npublic:\\n```\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        cout<<setprecision(5); //to set prcision upto 10^-5\\n        priority_queue<pair<double,int>> pq;\\n        int n=classes.size(); \\n        for(int i=0;i<n;i++){\\n            int num=classes[i][0];\\n            int den=classes[i][1];\\n            int n_num=num+1;\\n            int n_den=den+1;\\n            double dif=(double)(n_num*1.0/n_den)-(double)(num*1.0/den);\\n            // calculating difference between old pass ratio and after adding a student pass ratio\\n            pq.push(make_pair(dif,i));\\n\\t\\t\\t// pushing pass ratio and index into priority queue\\n        }\\n        while(extraStudents--){\\n            int tind=pq.top().second;\\n            int tdiff=pq.top().first;\\n            // tind dontes top index or index of class having highest difference after adding a student\\n            pq.pop();\\n\\t\\t\\t// poping out top pair\\n            classes[tind][0]++;\\n            classes[tind][1]++;\\n\\t\\t\\t// as we have decided to add a student into class with index tind we have to increase total number of students and number of students who can pass\\n            int num=classes[tind][0];\\n            int den=classes[tind][1];\\n            int n_num=num+1;\\n            int n_den=den+1;\\n            double dif=(double)(n_num*1.0/n_den)-(double)(num*1.0/den);\\n            // calculated difference after adding one student\\n            pq.push(make_pair(dif,tind));\\n            // pushing new difference to the priority queue\\n        }\\n        double sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=(double)(classes[i][0]*1.0/classes[i][1]);\\n                // adding pass ration to sum variable\\n            }\\n        \\n        return sum/n;\\n    }\\n};\\n```\\n\\n### Complexity Analysis:\\nSuppose there are n number of classes. So complexity of step1 is O(n).\\nSuppose there are m number of students. So complexity of step2 is O(mlog(n)) because getting max element is constant time operation and insertion in heap is log(n) time operation.\\nComplexity of step3 is O(n).\\n\\nAs 1<=n,m<=10^5\\n we can take m=n.\\n \\n So all over complexity O(n) + O(nlog(n)) + O(n) = O(nlogn).\\n \\n If you like this solution please upvote :)",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        cout<<setprecision(5); //to set prcision upto 10^-5\\n        priority_queue<pair<double,int>> pq;\\n        int n=classes.size(); \\n        for(int i=0;i<n;i++){\\n            int num=classes[i][0];\\n            int den=classes[i][1];\\n            int n_num=num+1;\\n            int n_den=den+1;\\n            double dif=(double)(n_num*1.0/n_den)-(double)(num*1.0/den);\\n            // calculating difference between old pass ratio and after adding a student pass ratio\\n            pq.push(make_pair(dif,i));\\n\\t\\t\\t// pushing pass ratio and index into priority queue\\n        }\\n        while(extraStudents--){\\n            int tind=pq.top().second;\\n            int tdiff=pq.top().first;\\n            // tind dontes top index or index of class having highest difference after adding a student\\n            pq.pop();\\n\\t\\t\\t// poping out top pair\\n            classes[tind][0]++;\\n            classes[tind][1]++;\\n\\t\\t\\t// as we have decided to add a student into class with index tind we have to increase total number of students and number of students who can pass\\n            int num=classes[tind][0];\\n            int den=classes[tind][1];\\n            int n_num=num+1;\\n            int n_den=den+1;\\n            double dif=(double)(n_num*1.0/n_den)-(double)(num*1.0/den);\\n            // calculated difference after adding one student\\n            pq.push(make_pair(dif,tind));\\n            // pushing new difference to the priority queue\\n        }\\n        double sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=(double)(classes[i][0]*1.0/classes[i][1]);\\n                // adding pass ration to sum variable\\n            }\\n        \\n        return sum/n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1108467,
                "title": "java-o-mlogc-solution-with-clear-explanation-and-comments",
                "content": "The challenge that I faced was to know where to add the extra student. We cannot simply add a student to a class with lowest pass ratio.\\n\\nWhy? For eg:  consider the ratios  2/3 (0.6666) and 3/5 (0.6) \\nif we add 1 student to  2/3 -> 3/4 (0.75)\\nor\\nif we add 1 student to 3/5 -> 4/6 (0.6666)\\n\\nFrom above we see that we cannot just simply add the student to lowest ratio (3/5).\\n\\nSo the idea is to compute the ratio increases (if we add one student) for each class and store in maxHeap.\\nThe top of the heap will always have the class which is the best candidate to add the new student.\\n\\n**Code:**\\n```\\nclass Solution {\\n\\n    // T = O(mlogc)  S=O(c)   c=no. of classes   m= extra students\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        double totalPassRatios = 0.0;\\n        // track the max new Pass Ratio (if a student is added to a class)\\n        // format: double[] {passRatio increase if a student is added,   pass count,   student count}\\n        PriorityQueue<double[]> maxHeap = new PriorityQueue<>((a,b) -> Double.compare(b[0], a[0]));\\n        \\n        for(int i=0; i< classes.length; i++) {\\n            // pass ratio\\n            double passRatio = (double) classes[i][0]/classes[i][1];\\n            // alternate pass ratio if a student is added\\n            double altPassRatio = (double) (classes[i][0]+1)/(classes[i][1]+1);\\n            \\n            maxHeap.add(new double[]{altPassRatio-passRatio, classes[i][0], classes[i][1]});\\n        }\\n        \\n        while(!maxHeap.isEmpty() && extraStudents > 0) {\\n            double[] top = maxHeap.poll();\\n            double passRatio = (double) (top[1]+1)/(top[2]+1);\\n            double altPassRatio = (double) (top[1]+2)/(top[2]+2);\\n            // update the maxHeap\\n            maxHeap.add(new double[]{altPassRatio-passRatio, top[1]+1, top[2]+1});\\n            \\n            extraStudents--; // decrement the extraStudents\\n        }\\n        \\n        // add all the ratios from Heap\\n        while(!maxHeap.isEmpty()) {            \\n            double[] top = maxHeap.poll();\\n            double passRatio = (double) (top[1])/(top[2]);\\n            totalPassRatios += passRatio;\\n        }\\n        \\n        return totalPassRatios / classes.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    // T = O(mlogc)  S=O(c)   c=no. of classes   m= extra students\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        double totalPassRatios = 0.0;\\n        // track the max new Pass Ratio (if a student is added to a class)\\n        // format: double[] {passRatio increase if a student is added,   pass count,   student count}\\n        PriorityQueue<double[]> maxHeap = new PriorityQueue<>((a,b) -> Double.compare(b[0], a[0]));\\n        \\n        for(int i=0; i< classes.length; i++) {\\n            // pass ratio\\n            double passRatio = (double) classes[i][0]/classes[i][1];\\n            // alternate pass ratio if a student is added\\n            double altPassRatio = (double) (classes[i][0]+1)/(classes[i][1]+1);\\n            \\n            maxHeap.add(new double[]{altPassRatio-passRatio, classes[i][0], classes[i][1]});\\n        }\\n        \\n        while(!maxHeap.isEmpty() && extraStudents > 0) {\\n            double[] top = maxHeap.poll();\\n            double passRatio = (double) (top[1]+1)/(top[2]+1);\\n            double altPassRatio = (double) (top[1]+2)/(top[2]+2);\\n            // update the maxHeap\\n            maxHeap.add(new double[]{altPassRatio-passRatio, top[1]+1, top[2]+1});\\n            \\n            extraStudents--; // decrement the extraStudents\\n        }\\n        \\n        // add all the ratios from Heap\\n        while(!maxHeap.isEmpty()) {            \\n            double[] top = maxHeap.poll();\\n            double passRatio = (double) (top[1])/(top[2]);\\n            totalPassRatios += passRatio;\\n        }\\n        \\n        return totalPassRatios / classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108410,
                "title": "js-greedy-heap-o-m-log-n-o-n",
                "content": "```javascript\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    // the heap will automatically find the class that will benefit\\n    // the most by adding a passing student\\n    const heap = new MaxHeap();\\n    \\n    // push all the classes into the heap so that\\n    // the heap can find the class that will benefit the most\\n    for (const x of classes) {\\n        heap.push(x);\\n    }\\n    \\n    // while there are extra students\\n    while (extraStudents) {\\n        \\n        // add the extra student to the class that will benefit the most\\n        heap.peak()[0] += 1;\\n        heap.peak()[1] += 1;\\n        \\n        // heapify down so that the heap remains valid\\n        heap.heapifyDown(0);\\n        \\n        extraStudents--;\\n    }\\n    \\n    \\n    // calculate the new average of all the classes\\n    let total = 0;\\n    for (const [x , y] of heap.store) {\\n        total += (x / y);\\n    }\\n    return total / heap.store.length;\\n};\\n\\n\\nclass MaxHeap {\\n    constructor() {\\n        this.store = [];\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2\\n            }\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        if (!child) return false;\\n        const c = (this.store[child][0] + 1) / (this.store[child][1] + 1) - (this.store[child][0]) / (this.store[child][1]);\\n        const p = (this.store[parent][0] + 1) / (this.store[parent][1] + 1) - (this.store[parent][0]) / (this.store[parent][1]);\\n        return c > p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    // the heap will automatically find the class that will benefit\\n    // the most by adding a passing student\\n    const heap = new MaxHeap();\\n    \\n    // push all the classes into the heap so that\\n    // the heap can find the class that will benefit the most\\n    for (const x of classes) {\\n        heap.push(x);\\n    }\\n    \\n    // while there are extra students\\n    while (extraStudents) {\\n        \\n        // add the extra student to the class that will benefit the most\\n        heap.peak()[0] += 1;\\n        heap.peak()[1] += 1;\\n        \\n        // heapify down so that the heap remains valid\\n        heap.heapifyDown(0);\\n        \\n        extraStudents--;\\n    }\\n    \\n    \\n    // calculate the new average of all the classes\\n    let total = 0;\\n    for (const [x , y] of heap.store) {\\n        total += (x / y);\\n    }\\n    return total / heap.store.length;\\n};\\n\\n\\nclass MaxHeap {\\n    constructor() {\\n        this.store = [];\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2\\n            }\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        if (!child) return false;\\n        const c = (this.store[child][0] + 1) / (this.store[child][1] + 1) - (this.store[child][0]) / (this.store[child][1]);\\n        const p = (this.store[parent][0] + 1) / (this.store[parent][1] + 1) - (this.store[parent][0]) / (this.store[parent][1]);\\n        return c > p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108331,
                "title": "python-greedy",
                "content": "In this question we want to modify ratios `r1, r2, ..., rn` such that `(r1 + r2 + ... + rn) / n` is maximized. As `n` is common, equivalently maximize `(r1 + r2 + ... + rn)`.\\n\\nSuppose that we only have 1 extra student. We should choose the ratio `ri = xi/yi` such that the difference `(xi+1)/(yi+1) - xi/yi` is maximum. Suppose that this is true for `k` extra students. If we have a `k+1`-st student, then we should once again find the ratio such that the above target difference is maximized. It then follows from the Principle of Induction that this stepwise approach is optimal for all values of `extraStudents`.\\n\\nThis is now nothing but a greedy solution. We can easily code using a max heap.\\n\\n```python\\nclass Solution:\\n    def maxAverageRatio(self, classes, extraStudents):\\n        hp = []\\n        for x, y in classes:\\n            target_difference = (x+1)/(y+1) - x/y\\n            heapq.heappush(hp, (-target_difference, x, y))\\n        \\n        for _ in range(extraStudents):\\n            _, x, y = heapq.heappop(hp)\\n            target_difference = (x+2)/(y+2) - (x+1)/(y+1)\\n            heapq.heappush(hp, (-target_difference, x+1, y+1))\\n        \\n        ans = 0\\n        while hp:\\n            _, x, y = heapq.heappop(hp)\\n            ans += x / y / len(classes)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxAverageRatio(self, classes, extraStudents):\\n        hp = []\\n        for x, y in classes:\\n            target_difference = (x+1)/(y+1) - x/y\\n            heapq.heappush(hp, (-target_difference, x, y))\\n        \\n        for _ in range(extraStudents):\\n            _, x, y = heapq.heappop(hp)\\n            target_difference = (x+2)/(y+2) - (x+1)/(y+1)\\n            heapq.heappush(hp, (-target_difference, x+1, y+1))\\n        \\n        ans = 0\\n        while hp:\\n            _, x, y = heapq.heappop(hp)\\n            ans += x / y / len(classes)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108318,
                "title": "java-greedy-solution-using-priority-queue-with-trick-for-early-termination",
                "content": "Use a max heap: the comparator compares the passing ratio with adding one more student.\\nFor a class, if number of passing sutdents is equal to total number of students, it\\'s passing ratio is already 1 and adding more passing students doesn\\'t help further.\\nThus, only add those with potential to increase the passing ratio to the priority queue. \\n If priority queue is empty, we can terminate early, because we know adding more passing students won\\'t help further.   \\n\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        int n = classes.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->Double.compare(ratioIncr(b),ratioIncr(a)));   // max pq\\n        double currRating = 0.0;\\n        for (int[] rating : classes) {\\n            currRating += (double)rating[0] / rating[1];\\n            if (rating[0] != rating[1]) {  // only add those with potential to increase the passing ratio\\n                pq.offer(rating);\\n            }\\n        }\\n        currRating /= n;\\n        if (pq.isEmpty())  // early termination\\n            return currRating;\\n        while (extraStudents-- > 0) {\\n            int[] item = pq.poll();\\n            currRating += ratioIncr(item)/n;\\n            item[0]++; item[1]++;\\n            pq.offer(item);\\n        }\\n        return currRating;\\n    }\\n\\n    private double ratioIncr(int[] item) {\\n        double ratio1 = (double)item[0] / item[1];\\n        double ratio2 = (double)(item[0]+1) / (item[1]+1);\\n        return ratio2 - ratio1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        int n = classes.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->Double.compare(ratioIncr(b),ratioIncr(a)));   // max pq\\n        double currRating = 0.0;\\n        for (int[] rating : classes) {\\n            currRating += (double)rating[0] / rating[1];\\n            if (rating[0] != rating[1]) {  // only add those with potential to increase the passing ratio\\n                pq.offer(rating);\\n            }\\n        }\\n        currRating /= n;\\n        if (pq.isEmpty())  // early termination\\n            return currRating;\\n        while (extraStudents-- > 0) {\\n            int[] item = pq.poll();\\n            currRating += ratioIncr(item)/n;\\n            item[0]++; item[1]++;\\n            pq.offer(item);\\n        }\\n        return currRating;\\n    }\\n\\n    private double ratioIncr(int[] item) {\\n        double ratio1 = (double)item[0] / item[1];\\n        double ratio2 = (double)(item[0]+1) / (item[1]+1);\\n        return ratio2 - ratio1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108294,
                "title": "python3-simple-fastest",
                "content": "Logic: We need to pick the class whose pass ratio will increase the most when we add 1 extraStudent. We need to repeat this for every extraStudent\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        h = []\\n        ones = 0\\n        for a,b in classes:\\n            if a==b:\\n                ones += 1\\n                continue\\n            heapq.heappush(h, [-(((a+1)/(b+1)) - (a/b)), b, a])\\n        \\n        # Base case average pass ratio is 1.0\\n        if not h: return 1.0\\n        \\n        for _ in range(extraStudents):\\n            _, y,x = heappop(h)\\n            heapq.heappush(h, [-(((x+2)/(y+2)) - ((x+1)/(y+1))), y+1, x+1])\\n            \\n        return (sum(x/y for _, y, x in h)+ones) / len(classes)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        h = []\\n        ones = 0\\n        for a,b in classes:\\n            if a==b:\\n                ones += 1\\n                continue\\n            heapq.heappush(h, [-(((a+1)/(b+1)) - (a/b)), b, a])\\n        \\n        # Base case average pass ratio is 1.0\\n        if not h: return 1.0\\n        \\n        for _ in range(extraStudents):\\n            _, y,x = heappop(h)\\n            heapq.heappush(h, [-(((x+2)/(y+2)) - ((x+1)/(y+1))), y+1, x+1])\\n            \\n        return (sum(x/y for _, y, x in h)+ones) / len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108279,
                "title": "python3-heap-solution-with-explanation",
                "content": "- \\u2018Assign each of the extraStudents students to a class to maximize the average pass ratio across all the classes\\u2019 \\n-> For each extraStudents find pair [pass, total] where **increase = (pass + 1) / (total + 1) - pass / total** maximum.\\n\\n- The idea is using a max heap to maintain pair [pass, total] with max increase.\\n\\n```\\nExample: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\\nWith first student:\\n\\t* \\tincrease = [0.16666, 0.06666, 0] -> Choose class (1, 2)\\n\\t\\tmax_heap = [(-0.16666, 1, 2), (-0.06666, 3, 5), (-0.0, 2, 2)] \\n\\tIf you wonder why store (-increase) instead of increase, the reason is Python only support min_heap and -min_heap is a max_heap.\\n\\n\\t* \\tAt # 1: Pop (-0.16666, 1, 2) and add increase to total_increase\\n\\n\\t* \\tAt # 2: After assign 1 extraStudents to class (1, 2), class will be (2, 3). \\n\\tPush it again to max_heap: (-0.08333, 2, 3) and continue with second student.\\n```\\t\\t\\n\\n\\n\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        N = len(classes)\\n        ini_pass = 0\\n        total_increase = 0\\n        \\n        max_heap = []\\n        for p, c in classes:\\n\\t\\t\\t# Calculate total pass ratio at first\\n            ini_pass += p / c\\n\\t\\t\\t\\n\\t\\t\\t# Store increase pass ratio to max_heap\\n            increase = (p + 1) / (c + 1) - p / c\\n            heappush(max_heap, (-increase, p, c))\\n        \\n        while extraStudents:\\n\\t\\t\\t# Pop the pair with max increase\\n            increase, p, c = heappop(max_heap)\\t\\t\\t# 1\\n            total_increase -= increase\\n\\t\\t\\t\\n\\t\\t\\t# Push the pair to max_heap again\\n            p, c = p + 1, c + 1\\n            increase = (p + 1) / (c + 1) - p / c\\n            heappush(max_heap, (-increase, p, c))\\t\\t# 2\\n                        \\n            extraStudents -= 1\\n        \\n        return (ini_pass + total_increase) / N\\n```",
                "solutionTags": [],
                "code": "```\\nExample: classes = [[1,2],[3,5],[2,2]], extraStudents = 2\\nWith first student:\\n\\t* \\tincrease = [0.16666, 0.06666, 0] -> Choose class (1, 2)\\n\\t\\tmax_heap = [(-0.16666, 1, 2), (-0.06666, 3, 5), (-0.0, 2, 2)] \\n\\tIf you wonder why store (-increase) instead of increase, the reason is Python only support min_heap and -min_heap is a max_heap.\\n\\n\\t* \\tAt # 1: Pop (-0.16666, 1, 2) and add increase to total_increase\\n\\n\\t* \\tAt # 2: After assign 1 extraStudents to class (1, 2), class will be (2, 3). \\n\\tPush it again to max_heap: (-0.08333, 2, 3) and continue with second student.\\n```\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        N = len(classes)\\n        ini_pass = 0\\n        total_increase = 0\\n        \\n        max_heap = []\\n        for p, c in classes:\\n\\t\\t\\t# Calculate total pass ratio at first\\n            ini_pass += p / c\\n\\t\\t\\t\\n\\t\\t\\t# Store increase pass ratio to max_heap\\n            increase = (p + 1) / (c + 1) - p / c\\n            heappush(max_heap, (-increase, p, c))\\n        \\n        while extraStudents:\\n\\t\\t\\t# Pop the pair with max increase\\n            increase, p, c = heappop(max_heap)\\t\\t\\t# 1\\n            total_increase -= increase\\n\\t\\t\\t\\n\\t\\t\\t# Push the pair to max_heap again\\n            p, c = p + 1, c + 1\\n            increase = (p + 1) / (c + 1) - p / c\\n            heappush(max_heap, (-increase, p, c))\\t\\t# 2\\n                        \\n            extraStudents -= 1\\n        \\n        return (ini_pass + total_increase) / N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921312,
                "title": "91-faster-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) \\n    {\\n        priority_queue<pair<double,int>>max_heap;\\n\\n        int n = classes.size();\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int pass = classes[i][0];\\n            int total = classes[i][1];\\n\\n            double passRatio = double(pass)/total;\\n\\n            int newpass = pass + 1;\\n            int newtotal = total + 1;\\n\\n            double newPassRatio = double(newpass)/newtotal;\\n\\n            max_heap.push({newPassRatio-passRatio,i});\\n        }\\n\\n        while(extraStudents)\\n        {\\n            pair<double,int>top = max_heap.top();\\n            max_heap.pop();\\n\\n            int i = top.second;\\n            classes[i][0] = classes[i][0] + 1;\\n            classes[i][1] = classes[i][1] + 1;\\n\\n            double passRatio = double(classes[i][0])/classes[i][1];\\n\\n            int newpass = classes[i][0] + 1;\\n            int newtotal = classes[i][1] + 1;\\n\\n            double newPassRatio = double(newpass)/newtotal;\\n\\n            max_heap.push({newPassRatio-passRatio,i});\\n\\n            extraStudents--;\\n        }\\n\\n        double sum = 0;\\n\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            sum+=(double)classes[i][0]/(double)classes[i][1];\\n        }\\n        return sum/(double)classes.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) \\n    {\\n        priority_queue<pair<double,int>>max_heap;\\n\\n        int n = classes.size();\\n\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int pass = classes[i][0];\\n            int total = classes[i][1];\\n\\n            double passRatio = double(pass)/total;\\n\\n            int newpass = pass + 1;\\n            int newtotal = total + 1;\\n\\n            double newPassRatio = double(newpass)/newtotal;\\n\\n            max_heap.push({newPassRatio-passRatio,i});\\n        }\\n\\n        while(extraStudents)\\n        {\\n            pair<double,int>top = max_heap.top();\\n            max_heap.pop();\\n\\n            int i = top.second;\\n            classes[i][0] = classes[i][0] + 1;\\n            classes[i][1] = classes[i][1] + 1;\\n\\n            double passRatio = double(classes[i][0])/classes[i][1];\\n\\n            int newpass = classes[i][0] + 1;\\n            int newtotal = classes[i][1] + 1;\\n\\n            double newPassRatio = double(newpass)/newtotal;\\n\\n            max_heap.push({newPassRatio-passRatio,i});\\n\\n            extraStudents--;\\n        }\\n\\n        double sum = 0;\\n\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            sum+=(double)classes[i][0]/(double)classes[i][1];\\n        }\\n        return sum/(double)classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457335,
                "title": "using-priority-queue-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n      struct cmp{\\n         bool operator()(pair<int,int> a, pair<int,int> b){\\n         double ad = (a.first+1)/(double)(a.second+1) - (a.first)/(double)a.second;\\n         double bd = (b.first+1)/(double)(b.second+1) - (b.first)/(double)b.second;\\n         return ad < bd;\\n        }\\n      };\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp >pq;\\n        for(auto i:classes){\\n            int a=i[0];\\n            int b=i[1];\\n            pq.push({a,b});\\n        }\\n        int n=classes.size();\\n        double pp=0;\\n        while(extraStudents>0){\\n            int a=pq.top().first+1;\\n            int b=pq.top().second+1;\\n            pq.pop();\\n            pq.push({a,b});\\n            extraStudents--;\\n        }\\n        \\n        while(!pq.empty()){\\n           pp+=(pq.top().first/(double)pq.top().second);\\n           pq.pop();\\n        }\\n        return pp/(double)classes.size();\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n      struct cmp{\\n         bool operator()(pair<int,int> a, pair<int,int> b){\\n         double ad = (a.first+1)/(double)(a.second+1) - (a.first)/(double)a.second;\\n         double bd = (b.first+1)/(double)(b.second+1) - (b.first)/(double)b.second;\\n         return ad < bd;\\n        }\\n      };\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp >pq;\\n        for(auto i:classes){\\n            int a=i[0];\\n            int b=i[1];\\n            pq.push({a,b});\\n        }\\n        int n=classes.size();\\n        double pp=0;\\n        while(extraStudents>0){\\n            int a=pq.top().first+1;\\n            int b=pq.top().second+1;\\n            pq.pop();\\n            pq.push({a,b});\\n            extraStudents--;\\n        }\\n        \\n        while(!pq.empty()){\\n           pp+=(pq.top().first/(double)pq.top().second);\\n           pq.pop();\\n        }\\n        return pp/(double)classes.size();\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159506,
                "title": "java-priority-queue-100-faster",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<ClassRecord> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new ClassRecord(cl));\\n        }\\n        ClassRecord cl;\\n        while(extraStudents-- > 0){\\n            pq.add(pq.remove().addOneStudent());\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            cl = pq.remove();\\n            sum += (double)cl.pass / cl.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass ClassRecord{\\n    int pass;\\n    int total;\\n    double inc;\\n    public ClassRecord(int[] array){\\n        pass = array[0];\\n        total = array[1];\\n        inc = getIncrement();\\n    }\\n    public ClassRecord addOneStudent(){\\n        pass++;\\n        total++;\\n        inc = getIncrement();\\n        return this;\\n    }\\n    private double getIncrement(){\\n        return (pass + 1.0) / (total + 1) - (double)pass / total;\\n    }\\n}\\nclass Compare implements Comparator<ClassRecord>{\\n    public int compare(ClassRecord a, ClassRecord b){\\n        if(a.inc < b.inc){\\n            return 1;\\n        }else if(a.inc > b.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<ClassRecord> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new ClassRecord(cl));\\n        }\\n        ClassRecord cl;\\n        while(extraStudents-- > 0){\\n            pq.add(pq.remove().addOneStudent());\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            cl = pq.remove();\\n            sum += (double)cl.pass / cl.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass ClassRecord{\\n    int pass;\\n    int total;\\n    double inc;\\n    public ClassRecord(int[] array){\\n        pass = array[0];\\n        total = array[1];\\n        inc = getIncrement();\\n    }\\n    public ClassRecord addOneStudent(){\\n        pass++;\\n        total++;\\n        inc = getIncrement();\\n        return this;\\n    }\\n    private double getIncrement(){\\n        return (pass + 1.0) / (total + 1) - (double)pass / total;\\n    }\\n}\\nclass Compare implements Comparator<ClassRecord>{\\n    public int compare(ClassRecord a, ClassRecord b){\\n        if(a.inc < b.inc){\\n            return 1;\\n        }else if(a.inc > b.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159176,
                "title": "java-easy-solution-using-heap-priority-queue",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new Class(cl));\\n        }\\n        while(extraStudents > 0){\\n            Class c = pq.remove();\\n            c.addExtraStudent();\\n            extraStudents--;\\n            pq.add(c);\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            Class c = pq.remove();\\n            sum += c.pass / c.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass Class{\\n    double pass;\\n    double total;\\n    double inc;\\n    public Class(int[] cl){\\n        pass = cl[0];\\n        total = cl[1];\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n    public void addExtraStudent(){\\n        pass += 1;\\n        total += 1;\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n}\\nclass Compare implements Comparator<Class>{\\n    public int compare(Class c1, Class c2){\\n        if(c1.inc < c2.inc){\\n            return 1;\\n        }else if(c1.inc > c2.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new Class(cl));\\n        }\\n        while(extraStudents > 0){\\n            Class c = pq.remove();\\n            c.addExtraStudent();\\n            extraStudents--;\\n            pq.add(c);\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            Class c = pq.remove();\\n            sum += c.pass / c.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass Class{\\n    double pass;\\n    double total;\\n    double inc;\\n    public Class(int[] cl){\\n        pass = cl[0];\\n        total = cl[1];\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n    public void addExtraStudent(){\\n        pass += 1;\\n        total += 1;\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n}\\nclass Compare implements Comparator<Class>{\\n    public int compare(Class c1, Class c2){\\n        if(c1.inc < c2.inc){\\n            return 1;\\n        }else if(c1.inc > c2.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992108,
                "title": "python3-pythonic-heap-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should always put a good students into a class where the passing guarantees the best improvement.\\n\\nAs this improvement changes with putting a student into a class, we can utilize a priority with the improvement as a main key.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to make it pythonic and reasonably fast, we use the heapq library, list comprehensions and a for loop over the student instead of a while loop, as this also has a small speed improvement because the interpreter does not need to check a condition every time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N + KlogN), where N is the amount of classes and K is the amount of good students we have.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) in the heap\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n\\n        # we could always take the student with the lowest denominator using a heap\\n        classes = [(num/denom - (num+1)/(denom+1), num, denom) for num, denom in classes]\\n\\n        # make the heap of classes according to smallest denominator and biggest numerator\\n        heapq.heapify(classes)\\n\\n        # check the trivial case that increasing helps nothing\\n        if classes[0][0] == 0:\\n            return 1\\n\\n        # assign the students\\n        for _ in range(extraStudents):\\n            \\n            # get the class with the smallest denominator and the biggest numerator\\n            _, num, denom = heappop(classes)\\n\\n            # increase the amount of students and push it back into the heap\\n            heappush(classes, ((num+1)/(denom+1) - (num+2)/(denom+2), num+1, denom+1))\\n        return sum(num/denom for _, num, denom in classes)/len(classes)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n\\n        # we could always take the student with the lowest denominator using a heap\\n        classes = [(num/denom - (num+1)/(denom+1), num, denom) for num, denom in classes]\\n\\n        # make the heap of classes according to smallest denominator and biggest numerator\\n        heapq.heapify(classes)\\n\\n        # check the trivial case that increasing helps nothing\\n        if classes[0][0] == 0:\\n            return 1\\n\\n        # assign the students\\n        for _ in range(extraStudents):\\n            \\n            # get the class with the smallest denominator and the biggest numerator\\n            _, num, denom = heappop(classes)\\n\\n            # increase the amount of students and push it back into the heap\\n            heappush(classes, ((num+1)/(denom+1) - (num+2)/(denom+2), num+1, denom+1))\\n        return sum(num/denom for _, num, denom in classes)/len(classes)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815726,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n    auto profit = [&](double pass, double total) {\\n        return (pass + 1) / (total + 1) - pass / total;\\n    };\\n    double total = 0;\\n    priority_queue<pair<double, array<int, 2>>> pq;\\n    for (auto &c : classes) {\\n        total += (double) c[0] / c[1];\\n        pq.push({profit(c[0], c[1]), {c[0], c[1]}});\\n    }\\n    while (extraStudents--) {\\n        auto [added_profit, c] = pq.top(); pq.pop();\\n        total += added_profit;\\n        pq.push({profit(c[0] + 1, c[1] + 1), {c[0] + 1, c[1] + 1}});\\n    }\\n    return total / classes.size();\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n    auto profit = [&](double pass, double total) {\\n        return (pass + 1) / (total + 1) - pass / total;\\n    };\\n    double total = 0;\\n    priority_queue<pair<double, array<int, 2>>> pq;\\n    for (auto &c : classes) {\\n        total += (double) c[0] / c[1];\\n        pq.push({profit(c[0], c[1]), {c[0], c[1]}});\\n    }\\n    while (extraStudents--) {\\n        auto [added_profit, c] = pq.top(); pq.pop();\\n        total += added_profit;\\n        pq.push({profit(c[0] + 1, c[1] + 1), {c[0] + 1, c[1] + 1}});\\n    }\\n    return total / classes.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468518,
                "title": "python3-heap-clean-code-commented",
                "content": "As denominator (number of classes) is fixed, we have to maximize numerator.\\nWe can achieve the objective by repeatedly assigning a brilliant student to a class with maximum increase of ratio.\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = [];\\n        for p, t in classes:\\n            heapq.heappush(heap, [p/t- (p+1)/(t+1), p, t]);\\n            \\n        while extraStudents:\\n            _, p, t = heapq.heappop(heap);\\n            heapq.heappush(heap, [(p+1)/(t+1) - (p+2)/(t+2), p+1, t+1]);\\n            extraStudents += -1;\\n        #print(heap)\\n        return sum(p/t for _, p, t in heap)/len(heap);",
                "solutionTags": [],
                "code": "As denominator (number of classes) is fixed, we have to maximize numerator.\\nWe can achieve the objective by repeatedly assigning a brilliant student to a class with maximum increase of ratio.\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = [];\\n        for p, t in classes:\\n            heapq.heappush(heap, [p/t- (p+1)/(t+1), p, t]);\\n            \\n        while extraStudents:\\n            _, p, t = heapq.heappop(heap);\\n            heapq.heappush(heap, [(p+1)/(t+1) - (p+2)/(t+2), p+1, t+1]);\\n            extraStudents += -1;\\n        #print(heap)\\n        return sum(p/t for _, p, t in heap)/len(heap);",
                "codeTag": "Java"
            },
            {
                "id": 2435767,
                "title": "c-amazon-oa-beats-95-no-comparator-in-priority-queue-hindi-explaination-bro-language",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents)\\n    {\\n        int n = classes.size();\\n        priority_queue<pair<double,int>> pq;\\n        \\n        for(int i=0 ; i<n; i++)\\n        {\\n            double d = (classes[i][0]+1)*1.0/(classes[i][1]+1) - (classes[i][0])*1.0/(classes[i][1]);\\n            pq.push({d,i});\\n        }\\n        double ans = 0;\\n        while(extraStudents>0)\\n        {\\n            auto p = pq.top();\\n            pq.pop();\\n            int id = p.second;\\n            classes[id][0]++;\\n            classes[id][1]++;\\n            \\n            double d = (classes[id][0]+1)*1.0/(classes[id][1]+1) - (classes[id][0])*1.0/(classes[id][1]);\\n            pq.push({d,id});\\n            extraStudents--;\\n        }\\n        for(int i=0 ; i<n ; i++)\\n            ans += classes[i][0]*1.0/classes[i][1];\\n        \\n        ans /= n;\\n        return ans;\\n    }\\n};\\n```\\n**AMAZON OA QUESTION ALSO - FIVE STAR SELLERS**\\n\\nDekho isko ab hmlog least ratio ya least no of studs ya least no. of passed my students dalke nii krskte hai\\n  \\n  EK cheez notice kro ki kvi v koi number divide hora h jaise 1/2 hua to aaya 0.5\\n        isme 1 students add krdenge to hoga 2/3 = 0.667\\n        isme 1 students add krdenge to hoga 3/4 = 0.75\\n        isme ar ek students aajayega to hoga 4/5 = 0.8\\n        Aisehi add krte jayenge to ratio ka gap kam hote jaara hai mtlb pehle 0.5 se 0.667 gap kitna jyda tha \\n        iske baad 0.667 se 0.75 gap kam hua ar aisehi kam hote jaara hai\\n\\t\\t\\nYhi cheez notice krne wala baat h hmlog delta nikalenge mtlb gap nikalenge har ki ek student add krne pe\\n        kya change aara h ratio me ar wo delta ko ek priority queue me daaldenge : Max Heap me\\n        Jiska gap sbse jyda hua usme hmlog student ko dalenge.\\n       \\n```\\nJAISE EG:\\n1/2 ar 10/20 dekhne me same lagra h par chalo ye dono me students ek ek daalke dekhte h kya hota h\\n1/2 me daalenge to gap aayega =  (1+1)/(2+1) -  (1/2)\\n                                   |              |\\n Ek student dalne k baad ratio kya bngya    original ratio h ye minus isiliye kyuki change nikalna h\\n            \\n Solve krne pe aayega : 0.1667\\n            \\n  Ab 10/20 me add krenge to : (10+1)/(20+1) - (10/20) \\n                Solve krenge to aayega : 0.023\\n```\\n            \\n   Dekhre ho difference kitna jyda h to isiliye hmlog ab student 1/2 wala me dalenge kyuki wo jyda\\n            increase krdega ratio\\n \\n Yhi tha program ka LOGIC MAIN ab to bs code bacha h wo easy hi h bs ek priority queue log ar delta nikalke\\n daalte jao tbtak jbtak extraStudents 0 se bada h\\n \\n Ye krne k baad hmlg ka class wala array badal gya hoga students dalne k baad ab bs hmlog ko basic average nikalke\\n return krdena h simple ekdum",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents)\\n    {\\n        int n = classes.size();\\n        priority_queue<pair<double,int>> pq;\\n        \\n        for(int i=0 ; i<n; i++)\\n        {\\n            double d = (classes[i][0]+1)*1.0/(classes[i][1]+1) - (classes[i][0])*1.0/(classes[i][1]);\\n            pq.push({d,i});\\n        }\\n        double ans = 0;\\n        while(extraStudents>0)\\n        {\\n            auto p = pq.top();\\n            pq.pop();\\n            int id = p.second;\\n            classes[id][0]++;\\n            classes[id][1]++;\\n            \\n            double d = (classes[id][0]+1)*1.0/(classes[id][1]+1) - (classes[id][0])*1.0/(classes[id][1]);\\n            pq.push({d,id});\\n            extraStudents--;\\n        }\\n        for(int i=0 ; i<n ; i++)\\n            ans += classes[i][0]*1.0/classes[i][1];\\n        \\n        ans /= n;\\n        return ans;\\n    }\\n};\\n```\n```\\nJAISE EG:\\n1/2 ar 10/20 dekhne me same lagra h par chalo ye dono me students ek ek daalke dekhte h kya hota h\\n1/2 me daalenge to gap aayega =  (1+1)/(2+1) -  (1/2)\\n                                   |              |\\n Ek student dalne k baad ratio kya bngya    original ratio h ye minus isiliye kyuki change nikalna h\\n            \\n Solve krne pe aayega : 0.1667\\n            \\n  Ab 10/20 me add krenge to : (10+1)/(20+1) - (10/20) \\n                Solve krenge to aayega : 0.023\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279028,
                "title": "python-heapify-solution",
                "content": "```\\n def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        Queue = []\\n        for i in range(len(classes)):\\n            ratio = classes[i][0]/classes[i][1]\\n            newratio = (classes[i][0]+1)/(classes[i][1]+1)\\n            Queue.append((ratio - newratio, classes[i]))\\n        \\n        heapify(Queue)\\n        while extraStudents > 0:\\n            best = heappop(Queue)            \\n            ratio = (best[1][0]+1)/(best[1][1]+1)\\n            newratio = (best[1][0]+2) / (best[1][1]+2)\\n            best[1][0] += 1\\n            best[1][1] += 1\\n            heappush(Queue, (ratio - newratio, best[1]))\\n            extraStudents-=1\\n        \\n        out = 0\\n        for i in range(len(Queue)):\\n            out+= Queue[i][1][0]/Queue[i][1][1]\\n        \\n        return out/len(Queue)",
                "solutionTags": [],
                "code": "```\\n def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        Queue = []\\n        for i in range(len(classes)):\\n            ratio = classes[i][0]/classes[i][1]\\n            newratio = (classes[i][0]+1)/(classes[i][1]+1)\\n            Queue.append((ratio - newratio, classes[i]))\\n        \\n        heapify(Queue)\\n        while extraStudents > 0:\\n            best = heappop(Queue)            \\n            ratio = (best[1][0]+1)/(best[1][1]+1)\\n            newratio = (best[1][0]+2) / (best[1][1]+2)\\n            best[1][0] += 1\\n            best[1][1] += 1\\n            heappush(Queue, (ratio - newratio, best[1]))\\n            extraStudents-=1\\n        \\n        out = 0\\n        for i in range(len(Queue)):\\n            out+= Queue[i][1][0]/Queue[i][1][1]\\n        \\n        return out/len(Queue)",
                "codeTag": "Java"
            },
            {
                "id": 1998238,
                "title": "simple-python-solution-using-heap",
                "content": "Please upvote if you find it useful :)\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        H=[]\\n        for i in range(len(classes)):\\n            p,t=classes[i]\\n            heapq.heappush(H,(((p/t)-((p+1)/(t+1))),p,t))\\n        \\n        while extraStudents>0:\\n            x,y,z=heapq.heappop(H)\\n            y+=1\\n            z+=1\\n            heapq.heappush(H,(((y/z)-((y+1)/(z+1))),y,z))\\n            extraStudents-=1\\n        sm=0\\n        for x,y,z in H:\\n            sm+=(y/z)\\n        return sm/len(classes)\\n\\t\\t\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "Please upvote if you find it useful :)\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        H=[]\\n        for i in range(len(classes)):\\n            p,t=classes[i]\\n            heapq.heappush(H,(((p/t)-((p+1)/(t+1))),p,t))\\n        \\n        while extraStudents>0:\\n            x,y,z=heapq.heappop(H)\\n            y+=1\\n            z+=1\\n            heapq.heappush(H,(((y/z)-((y+1)/(z+1))),y,z))\\n            extraStudents-=1\\n        sm=0\\n        for x,y,z in H:\\n            sm+=(y/z)\\n        return sm/len(classes)\\n\\t\\t\\n\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1929474,
                "title": "a-few-solutions",
                "content": "Use a max heap to continually cherry pick the maximum ratio gain for each of the `K` extra students.\\n\\nIf we have `a` passing students of `b` total students in a class, then the ratio gain is `(a + 1) / (b + 1) - a / b`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxAverageRatio(A: Array<IntArray>, K: Int): Double {\\n        var f = { a: Double, b: Double -> (a + 1) / (b + 1) - a / b }\\n        var q = PriorityQueue(Comparator{ a: DoubleArray, b: DoubleArray -> b[0].compareTo(a[0]) })\\n        for ((a, b) in A.map{ (a, b) -> Pair(a.toDouble(), b.toDouble()) })\\n            q.add(doubleArrayOf(f(a, b), a, b))\\n        for (k in 0 until K) {\\n            var (_, a_, b_) = q.poll()\\n            var (a, b) = Pair(a_ + 1, b_ + 1)\\n            q.add(doubleArrayOf(f(a, b), a, b))\\n        }\\n        var t = 0.0\\n        while (0 < q.size) {\\n            var (_, a, b) = q.poll()\\n            t += a / b\\n        }\\n        return t / A.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.max) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.max) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet maxAverageRatio = (A, K, q = [], f = (a, b) => (a + 1) / (b + 1) - a / b) => {\\n    for (let [a, b] of A)\\n        heappush(q, [f(a, b), a, b]);\\n    while (K--) {\\n        let [_, a, b] = heappop(q);\\n        heappush(q, [f(++a, ++b), a, b])\\n    }\\n    return _.sum(q.map(([_, a, b]) => a / b)) / A.length;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxAverageRatio(self, A: List[List[int]], K: int) -> float:\\n        f = lambda a, b: (a + 1) / (b + 1) - a / b\\n        q = []\\n        for a, b in A:\\n            heappush(q, [-f(a, b), a, b])\\n        for _ in range(K):\\n            _, a, b = heappop(q)\\n            a += 1\\n            b += 1\\n            heappush(q, [-f(a, b), a, b])\\n        return sum(a / b for _, a, b in q) / len(q)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Triple = tuple<double, int, int>;\\n    using Triples = vector<Triple>;\\n    struct Cmp {\\n        size_t operator()(const Triple& a, const Triple& b) const {\\n            auto [u, v, w] = a;\\n            auto [x, y, z] = b;\\n            return u < x;\\n        }\\n    };\\n    using Queue = priority_queue<Triple, Triples, Cmp>;\\n    double maxAverageRatio(VVI& A, int K, Queue q = {}, double t = {}) {\\n        auto f = [](auto a, auto b) { return double(a + 1) / double(b + 1) - double(a) / double(b); };\\n        for (auto& pair: A) {\\n            auto [a, b] = make_pair(pair[0], pair[1]);\\n            q.push({ f(a, b), a, b });\\n        }\\n        while (K--) {\\n            auto [_, a, b] = q.top(); q.pop();\\n            q.push({ f(++a, ++b), a, b });\\n        }\\n        while (q.size()) {\\n            auto [_, a, b] = q.top(); q.pop();\\n            t += double(a) / double(b);\\n        }\\n        return t / A.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxAverageRatio(A: Array<IntArray>, K: Int): Double {\\n        var f = { a: Double, b: Double -> (a + 1) / (b + 1) - a / b }\\n        var q = PriorityQueue(Comparator{ a: DoubleArray, b: DoubleArray -> b[0].compareTo(a[0]) })\\n        for ((a, b) in A.map{ (a, b) -> Pair(a.toDouble(), b.toDouble()) })\\n            q.add(doubleArrayOf(f(a, b), a, b))\\n        for (k in 0 until K) {\\n            var (_, a_, b_) = q.poll()\\n            var (a, b) = Pair(a_ + 1, b_ + 1)\\n            q.add(doubleArrayOf(f(a, b), a, b))\\n        }\\n        var t = 0.0\\n        while (0 < q.size) {\\n            var (_, a, b) = q.poll()\\n            t += a / b\\n        }\\n        return t / A.size\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.max) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.max) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet maxAverageRatio = (A, K, q = [], f = (a, b) => (a + 1) / (b + 1) - a / b) => {\\n    for (let [a, b] of A)\\n        heappush(q, [f(a, b), a, b]);\\n    while (K--) {\\n        let [_, a, b] = heappop(q);\\n        heappush(q, [f(++a, ++b), a, b])\\n    }\\n    return _.sum(q.map(([_, a, b]) => a / b)) / A.length;\\n};\\n```\n```\\nclass Solution:\\n    def maxAverageRatio(self, A: List[List[int]], K: int) -> float:\\n        f = lambda a, b: (a + 1) / (b + 1) - a / b\\n        q = []\\n        for a, b in A:\\n            heappush(q, [-f(a, b), a, b])\\n        for _ in range(K):\\n            _, a, b = heappop(q)\\n            a += 1\\n            b += 1\\n            heappush(q, [-f(a, b), a, b])\\n        return sum(a / b for _, a, b in q) / len(q)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Triple = tuple<double, int, int>;\\n    using Triples = vector<Triple>;\\n    struct Cmp {\\n        size_t operator()(const Triple& a, const Triple& b) const {\\n            auto [u, v, w] = a;\\n            auto [x, y, z] = b;\\n            return u < x;\\n        }\\n    };\\n    using Queue = priority_queue<Triple, Triples, Cmp>;\\n    double maxAverageRatio(VVI& A, int K, Queue q = {}, double t = {}) {\\n        auto f = [](auto a, auto b) { return double(a + 1) / double(b + 1) - double(a) / double(b); };\\n        for (auto& pair: A) {\\n            auto [a, b] = make_pair(pair[0], pair[1]);\\n            q.push({ f(a, b), a, b });\\n        }\\n        while (K--) {\\n            auto [_, a, b] = q.top(); q.pop();\\n            q.push({ f(++a, ++b), a, b });\\n        }\\n        while (q.size()) {\\n            auto [_, a, b] = q.top(); q.pop();\\n            t += double(a) / double(b);\\n        }\\n        return t / A.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925226,
                "title": "c-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extrastudents)\\n    {\\n        using pi=pair<double,pair<int,int>>;\\n        priority_queue<pair<double,pair<int,int>>> q;\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            int pass=classes[i][0];\\n            int total=classes[i][1];\\n            double growth=(double)(pass+1)/(total+1)-(double)(pass)/(total);\\n            q.push({growth,{pass,total}});\\n        }\\n        while(extrastudents--)\\n        {\\n            pair<double,pair<int,int>> p=q.top();\\n            q.pop();\\n            int pass=p.second.first;\\n            int total=p.second.second;\\n            pass++;\\n            total++;\\n            double growth=(double)(pass+1)/(total+1)-(double)(pass)/(total);\\n            q.push({growth,{pass,total}});\\n        }\\n        double res=0;\\n        while(!q.empty())\\n        {\\n            res+=(double)(q.top().second.first)/(q.top().second.second);\\n            q.pop();\\n        }\\n        return res/classes.size();\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extrastudents)\\n    {\\n        using pi=pair<double,pair<int,int>>;\\n        priority_queue<pair<double,pair<int,int>>> q;\\n        for(int i=0;i<classes.size();i++)\\n        {\\n            int pass=classes[i][0];\\n            int total=classes[i][1];\\n            double growth=(double)(pass+1)/(total+1)-(double)(pass)/(total);\\n            q.push({growth,{pass,total}",
                "codeTag": "Java"
            },
            {
                "id": 1848523,
                "title": "java-simple-solution-using-priorityqueue-sorting",
                "content": "**Check which class contributes the most if we add an extra student to that class.**\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                double a1 = (double)a[0]/(double)a[1];\\n                double a2 = (double)(a[0]+1)/(double)(a[1]+1);\\n                \\n                double d1 = a2 - a1;\\n                \\n                double b1 = (double)b[0]/(double)b[1];\\n                double b2 = (double)(b[0]+1)/(double)(b[1]+1);\\n                \\n                double d2 = b2 - b1;\\n                \\n                return -Double.compare(d1, d2);\\n            }\\n        });\\n        \\n        for(int[] it: classes)\\n            pq.offer(it);\\n        \\n        while(extraStudents-- != 0){   \\n            int[] arr = pq.poll();\\n            \\n            arr[0] += 1;\\n            arr[1] += 1;\\n            \\n            pq.offer(arr);\\n        }\\n    \\n        double sum = 0;\\n        \\n        while(!pq.isEmpty())\\n            sum += (double)pq.peek()[0]/(double)pq.poll()[1];\\n        \\n        return (double)sum/(double)classes.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                double a1 = (double)a[0]/(double)a[1];\\n                double a2 = (double)(a[0]+1)/(double)(a[1]+1);\\n                \\n                double d1 = a2 - a1;\\n                \\n                double b1 = (double)b[0]/(double)b[1];\\n                double b2 = (double)(b[0]+1)/(double)(b[1]+1);\\n                \\n                double d2 = b2 - b1;\\n                \\n                return -Double.compare(d1, d2);\\n            }\\n        });\\n        \\n        for(int[] it: classes)\\n            pq.offer(it);\\n        \\n        while(extraStudents-- != 0){   \\n            int[] arr = pq.poll();\\n            \\n            arr[0] += 1;\\n            arr[1] += 1;\\n            \\n            pq.offer(arr);\\n        }\\n    \\n        double sum = 0;\\n        \\n        while(!pq.isEmpty())\\n            sum += (double)pq.peek()[0]/(double)pq.poll()[1];\\n        \\n        return (double)sum/(double)classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639512,
                "title": "go-heap",
                "content": "```\\nfunc maxAverageRatio(classes [][]int, extraStudents int) float64 {\\n    h := &maxheap{}\\n    for _, c := range classes {\\n        heap.Push(h, [2]int{c[0], c[1]})\\n    }\\n    \\n    for extraStudents > 0 {\\n        c := heap.Pop(h).([2]int)\\n        extraStudents--\\n        c[0]++\\n        c[1]++\\n        heap.Push(h, c)\\n    }\\n    var res float64\\n    for _, v := range *h {\\n        res += float64(v[0]) / float64(v[1])\\n    }\\n    return res / float64(len(classes))\\n}\\n\\ntype maxheap [][2]int\\n\\nfunc (h maxheap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h maxheap) Less(i int, j int) bool {\\n    return float64(h[i][0] + 1) / float64(h[i][1] + 1) - float64(h[i][0]) / float64(h[i][1]) >\\n    float64(h[j][0] + 1) / float64(h[j][1] + 1) - float64(h[j][0]) / float64(h[j][1])\\n}\\n\\nfunc (h maxheap) Swap(i int, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *maxheap) Push(a interface{}) {\\n    *h = append(*h, a.([2]int))\\n}\\n\\nfunc (h *maxheap) Pop() interface{} {\\n    l := len(*h)\\n    res := (*h)[l - 1]\\n    *h = (*h)[:l - 1]\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxAverageRatio(classes [][]int, extraStudents int) float64 {\\n    h := &maxheap{}\\n    for _, c := range classes {\\n        heap.Push(h, [2]int{c[0], c[1]})\\n    }\\n    \\n    for extraStudents > 0 {\\n        c := heap.Pop(h).([2]int)\\n        extraStudents--\\n        c[0]++\\n        c[1]++\\n        heap.Push(h, c)\\n    }\\n    var res float64\\n    for _, v := range *h {\\n        res += float64(v[0]) / float64(v[1])\\n    }\\n    return res / float64(len(classes))\\n}\\n\\ntype maxheap [][2]int\\n\\nfunc (h maxheap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h maxheap) Less(i int, j int) bool {\\n    return float64(h[i][0] + 1) / float64(h[i][1] + 1) - float64(h[i][0]) / float64(h[i][1]) >\\n    float64(h[j][0] + 1) / float64(h[j][1] + 1) - float64(h[j][0]) / float64(h[j][1])\\n}\\n\\nfunc (h maxheap) Swap(i int, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *maxheap) Push(a interface{}) {\\n    *h = append(*h, a.([2]int))\\n}\\n\\nfunc (h *maxheap) Pop() interface{} {\\n    l := len(*h)\\n    res := (*h)[l - 1]\\n    *h = (*h)[:l - 1]\\n    return res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598177,
                "title": "c-solution-with-max-heap-priority-queue-of-tuple",
                "content": "```cpp\\nclass Solution {\\n public:\\n  double maxAverageRatio(vector<vector<int>> &classes, int extraStudents) {\\n    priority_queue<tuple<double, int, int>> pq;  // max heap: { (pass + 1)/(total + 1) - pass/total, pass, total }\\n    for (auto &pass_total : classes) {\\n      auto pass = pass_total[0], total = pass_total[1];\\n      auto improvement = (double)(pass + 1) / (total + 1) - (double)pass / total;\\n      pq.push({improvement, pass, total});\\n    }\\n    for (int i = 0; i < extraStudents; ++i) {\\n      auto [_, pass, total] = pq.top();\\n      pq.pop();\\n      ++pass, ++total;\\n      auto newImprovment = (double)(pass + 1) / (total + 1) - (double)pass / total;\\n      pq.push({newImprovment, pass, total});\\n    }\\n    double ans = 0.0;\\n    while (!pq.empty()) {\\n      auto [_, pass, total] = pq.top();\\n      pq.pop();\\n      ans += (double)pass / total;\\n    }\\n    return ans / (double)classes.size();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n public:\\n  double maxAverageRatio(vector<vector<int>> &classes, int extraStudents) {\\n    priority_queue<tuple<double, int, int>> pq;  // max heap: { (pass + 1)/(total + 1) - pass/total, pass, total }\\n    for (auto &pass_total : classes) {\\n      auto pass = pass_total[0], total = pass_total[1];\\n      auto improvement = (double)(pass + 1) / (total + 1) - (double)pass / total;\\n      pq.push({improvement, pass, total});\\n    }\\n    for (int i = 0; i < extraStudents; ++i) {\\n      auto [_, pass, total] = pq.top();\\n      pq.pop();\\n      ++pass, ++total;\\n      auto newImprovment = (double)(pass + 1) / (total + 1) - (double)pass / total;\\n      pq.push({newImprovment, pass, total});\\n    }\\n    double ans = 0.0;\\n    while (!pq.empty()) {\\n      auto [_, pass, total] = pq.top();\\n      pq.pop();\\n      ans += (double)pass / total;\\n    }\\n    return ans / (double)classes.size();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583950,
                "title": "python-3-heap-100-time",
                "content": "![image](https://assets.leetcode.com/users/images/9a98c753-0f84-4529-8ea3-e1bdb873997e_1637208740.2855933.png)\\n\\n\\nFor each class, construct a structure ( (pass/total) - (pass+1)/(total+1), pass, total ). Create a heap to hold all structures. Pop the most negative, which shall give the maximum increase in pass ratio after adding one extra student, update the class\\' pass and total, construct a new structure and push to heap. Repeat till all extra students assigned.\\n\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        hp = []\\n        for p, t in classes:\\n            hp.append((p/t - (p+1)/(t+1), p, t))\\n        heapify(hp)\\n        for i in range(extraStudents):\\n            _, p, t = heappop(hp)\\n            p += 1; t += 1\\n            heappush(hp, (p/t - (p+1)/(t+1), p, t))\\n        ans = 0\\n        for _, p, t in hp:\\n            ans += p/t\\n        return ans / len(hp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        hp = []\\n        for p, t in classes:\\n            hp.append((p/t - (p+1)/(t+1), p, t))\\n        heapify(hp)\\n        for i in range(extraStudents):\\n            _, p, t = heappop(hp)\\n            p += 1; t += 1\\n            heappush(hp, (p/t - (p+1)/(t+1), p, t))\\n        ans = 0\\n        for _, p, t in hp:\\n            ans += p/t\\n        return ans / len(hp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447197,
                "title": "simple-python-o-mlogn-greedy-max-heap-solution",
                "content": "We always assign the smart student to the class whose pass ratio can benefit the most from it. We keep track of the boost in pass ratio in each class using a max heap. \\n```Python\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq = []\\n        for n_pass, n_total in classes:\\n            improvement = (n_pass+1)/(n_total+1)-(n_pass/n_total)\\n            heappush(pq, (-improvement, n_pass, n_total))\\n            \\n        for _ in range(extraStudents):\\n            _, n_pass, n_total = heappop(pq)\\n            n_pass += 1\\n            n_total += 1\\n            improvement = (n_pass+1)/(n_total+1)-(n_pass/n_total)\\n            heappush(pq, (-improvement, n_pass, n_total))\\n            \\n        return sum([p/n for _, p, n in pq])/len(pq)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```Python\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq = []\\n        for n_pass, n_total in classes:\\n            improvement = (n_pass+1)/(n_total+1)-(n_pass/n_total)\\n            heappush(pq, (-improvement, n_pass, n_total))\\n            \\n        for _ in range(extraStudents):\\n            _, n_pass, n_total = heappop(pq)\\n            n_pass += 1\\n            n_total += 1\\n            improvement = (n_pass+1)/(n_total+1)-(n_pass/n_total)\\n            heappush(pq, (-improvement, n_pass, n_total))\\n            \\n        return sum([p/n for _, p, n in pq])/len(pq)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342450,
                "title": "heap-for-ratio-change-98-speed",
                "content": "Runtime: 2472 ms, faster than 98.25% of Python3 online submissions for Maximum Average Pass Ratio.\\nMemory Usage: 64.2 MB, less than 38.65% of Python3 online submissions for Maximum Average Pass Ratio.\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap_classes = []\\n        for p, t in classes:\\n            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))\\n        for _ in range(extraStudents):\\n            diff, p, t = heappop(heap_classes)\\n            p += 1\\n            t += 1\\n            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))\\n        return sum(p / t for d, p, t in heap_classes) / len(classes)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap_classes = []\\n        for p, t in classes:\\n            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))\\n        for _ in range(extraStudents):\\n            diff, p, t = heappop(heap_classes)\\n            p += 1\\n            t += 1\\n            heappush(heap_classes, (-((p + 1) / (t + 1) - p / t), p, t))\\n        return sum(p / t for d, p, t in heap_classes) / len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228489,
                "title": "priority-q-88-nice-question",
                "content": "```\\n#define ff double\\nclass obj{\\n  public:\\n    pair<ff,ff>a;\\n    ff incratio;\\n};\\nclass cmp{\\n    public:\\n    bool operator()(obj a,obj b){\\n        return a.incratio<b.incratio;\\n    }  \\n};\\nclass Solution {\\npublic: \\n    double maxAverageRatio(vector<vector<int>>& cl, int es) {\\n      priority_queue<obj,vector<obj>,cmp> pq;\\n        for(int i=0;i<cl.size();i++)\\n        {\\n     \\n          ff currentratio=(ff)cl[i][0]/(ff)cl[i][1];\\n          ff afteraddingratio=(ff)(cl[i][0]+1)/(ff)(cl[i][1]+1);\\n          obj newobj;\\n          newobj.a.first=cl[i][0];\\n          newobj.a.second=cl[i][1];\\n          newobj.incratio=afteraddingratio-currentratio;\\n          pq.push(newobj);\\n        }\\n        while(es--){\\n            auto x=pq.top();\\n            pq.pop();\\n        \\n            x.a.first++;\\n            x.a.second++;\\n                ff prevratio=x.a.first/x.a.second;\\n              ff afterratio=(x.a.first+1)/(x.a.second+1);\\n            x.incratio=afterratio-prevratio;\\n            pq.push(x);\\n        }\\n        ff ans=0;\\n        int deno=pq.size();\\n        while(pq.size()>0){\\n            auto x=pq.top();\\n            \\n            ans+=(ff)x.a.first/(ff)x.a.second;\\n            pq.pop();\\n        }\\n        ans=ans/deno;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ff double\\nclass obj{\\n  public:\\n    pair<ff,ff>a;\\n    ff incratio;\\n};\\nclass cmp{\\n    public:\\n    bool operator()(obj a,obj b){\\n        return a.incratio<b.incratio;\\n    }  \\n};\\nclass Solution {\\npublic: \\n    double maxAverageRatio(vector<vector<int>>& cl, int es) {\\n      priority_queue<obj,vector<obj>,cmp> pq;\\n        for(int i=0;i<cl.size();i++)\\n        {\\n     \\n          ff currentratio=(ff)cl[i][0]/(ff)cl[i][1];\\n          ff afteraddingratio=(ff)(cl[i][0]+1)/(ff)(cl[i][1]+1);\\n          obj newobj;\\n          newobj.a.first=cl[i][0];\\n          newobj.a.second=cl[i][1];\\n          newobj.incratio=afteraddingratio-currentratio;\\n          pq.push(newobj);\\n        }\\n        while(es--){\\n            auto x=pq.top();\\n            pq.pop();\\n        \\n            x.a.first++;\\n            x.a.second++;\\n                ff prevratio=x.a.first/x.a.second;\\n              ff afterratio=(x.a.first+1)/(x.a.second+1);\\n            x.incratio=afterratio-prevratio;\\n            pq.push(x);\\n        }\\n        ff ans=0;\\n        int deno=pq.size();\\n        while(pq.size()>0){\\n            auto x=pq.top();\\n            \\n            ans+=(ff)x.a.first/(ff)x.a.second;\\n            pq.pop();\\n        }\\n        ans=ans/deno;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190444,
                "title": "java-max-heap-with-custom-data-structure-easy-to-understand-w-comments",
                "content": "``` \\nclass Room{\\n    int pass;\\n    int total;\\n    \\n    Room(int p, int t){\\n        this.pass = p;\\n        this.total = t;\\n    }\\n    \\n    // return the change in the difference \\n    public double fetchRatio(){\\n        return ((double)(pass + 1) / (total + 1)) - ((double)pass / total);\\n    }\\n    \\n    // divide pass by total\\n    public double fetchQuotient(){\\n        return (double)pass / total;\\n    }\\n}\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        // max heap, the root is the Room with the largest change\\n        PriorityQueue<Room> maxHeap = new PriorityQueue<>(classes.length, (a,b) -> Double.compare(b.fetchRatio(),a.fetchRatio()));\\n        \\n        // for each class, add create a room and add to the maxHeap\\n        for(int[] arr : classes){\\n            Room room = new Room(arr[0], arr[1]);\\n            maxHeap.offer(room);\\n        }\\n        \\n        // for each extra student, get the one that would have the highest change\\n        // and increment its pass and total by 1\\n        for(int i = 0; i < extraStudents; i++){\\n            Room room = maxHeap.poll();\\n            room.pass++;\\n            room.total++;\\n            maxHeap.offer(room);\\n        }\\n        \\n\\n        double total = 0;\\n        \\n        // go through each room in heap and fetch the quotient\\n        while(maxHeap.peek() != null){\\n            Room room = maxHeap.poll();\\n            total += room.fetchQuotient();\\n        }\\n        return total / classes.length;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Room{\\n    int pass;\\n    int total;\\n    \\n    Room(int p, int t){\\n        this.pass = p;\\n        this.total = t;\\n    }\\n    \\n    // return the change in the difference \\n    public double fetchRatio(){\\n        return ((double)(pass + 1) / (total + 1)) - ((double)pass / total);\\n    }\\n    \\n    // divide pass by total\\n    public double fetchQuotient(){\\n        return (double)pass / total;\\n    }\\n}\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        // max heap, the root is the Room with the largest change\\n        PriorityQueue<Room> maxHeap = new PriorityQueue<>(classes.length, (a,b) -> Double.compare(b.fetchRatio(),a.fetchRatio()));\\n        \\n        // for each class, add create a room and add to the maxHeap\\n        for(int[] arr : classes){\\n            Room room = new Room(arr[0], arr[1]);\\n            maxHeap.offer(room);\\n        }\\n        \\n        // for each extra student, get the one that would have the highest change\\n        // and increment its pass and total by 1\\n        for(int i = 0; i < extraStudents; i++){\\n            Room room = maxHeap.poll();\\n            room.pass++;\\n            room.total++;\\n            maxHeap.offer(room);\\n        }\\n        \\n\\n        double total = 0;\\n        \\n        // go through each room in heap and fetch the quotient\\n        while(maxHeap.peek() != null){\\n            Room room = maxHeap.poll();\\n            total += room.fetchQuotient();\\n        }\\n        return total / classes.length;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123335,
                "title": "python3-math-greedy-with-heap",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \"\"\"Walk through examples to find patterns\\n\\n        Always add students to class that will raise the average the most. This\\n        can be computed via finding the difference between current state and one\\n        more student:\\n\\n        avg_delta_by_one_extra == 2/11 - 1/10\\n                               => (p+1)/(t+1) - p/t\\n                               => (t-p) / (t^2 + t)    (p = pass, t = total)\\n\\n        Implement using a min heap, and storing tuple (-delta, (pass, total))\\n        where delta reflects the change in average due to adding one extra\\n        student.\\n\\n        Go through classes list and create delta tuples list; heapify this\\n        list. Then greedily add extra students until supply depleted. Finally,\\n        compute resuting average directly from list.\\n\\n        O(C + SlogC) time, O(C) space\\n        \"\"\"\\n        h = []\\n        for p,t in classes:\\n            delta = (t-p) / (t**2 + t)\\n            h.append( (-delta, (p, t)) )\\n        heapq.heapify(h)\\n\\n        while extraStudents:\\n            delta, (p, t) = heapq.heappop(h)\\n            p, t = p+1, t+1\\n            delta = (t-p) / (t**2 + t)\\n            heapq.heappush(h, (-delta, (p, t)))\\n            extraStudents -= 1\\n\\n        res = 0\\n        for delta,(p,t) in h:\\n            res += p / t\\n        return res / len(h)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \"\"\"Walk through examples to find patterns\\n\\n        Always add students to class that will raise the average the most. This\\n        can be computed via finding the difference between current state and one\\n        more student:\\n\\n        avg_delta_by_one_extra == 2/11 - 1/10\\n                               => (p+1)/(t+1) - p/t\\n                               => (t-p) / (t^2 + t)    (p = pass, t = total)\\n\\n        Implement using a min heap, and storing tuple (-delta, (pass, total))\\n        where delta reflects the change in average due to adding one extra\\n        student.\\n\\n        Go through classes list and create delta tuples list; heapify this\\n        list. Then greedily add extra students until supply depleted. Finally,\\n        compute resuting average directly from list.\\n\\n        O(C + SlogC) time, O(C) space\\n        \"\"\"\\n        h = []\\n        for p,t in classes:\\n            delta = (t-p) / (t**2 + t)\\n            h.append( (-delta, (p, t)) )\\n        heapq.heapify(h)\\n\\n        while extraStudents:\\n            delta, (p, t) = heapq.heappop(h)\\n            p, t = p+1, t+1\\n            delta = (t-p) / (t**2 + t)\\n            heapq.heappush(h, (-delta, (p, t)))\\n            extraStudents -= 1\\n\\n        res = 0\\n        for delta,(p,t) in h:\\n            res += p / t\\n        return res / len(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119407,
                "title": "priority-queue-java-easy-understand-solution",
                "content": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> pq=new PriorityQueue<double[]>((a,b)->a[2]-b[2]>0?-1:1);\\n        double sum = 0;\\n        for(int i = 0; i < classes.length; i++) {\\n            if(classes[i][0] != classes[i][1]) {\\n                double passes = classes[i][0];\\n                double total = classes[i][1];\\n                pq.offer(new double[]{passes, total, getPotentialIncrease(passes, total)});\\n            } else {\\n                sum++;\\n            }\\n        }\\n        if(sum == classes.length) {\\n            return 1;\\n        }\\n\\n        while(!pq.isEmpty() && extraStudents-- > 0) {\\n\\t\\t    // poll the max potential increase element everytime\\n            double[] potential = pq.poll();\\n\\t\\t\\t// apply 1 extra student count to this \\n            potential[0] += 1;\\n            potential[1] += 1;\\n\\t\\t\\t// re-calculate the potential ratio increase for this element and put to pq again.\\n            pq.offer(new double[]{potential[0], potential[1], getPotentialIncrease(potential[0], potential[1])});\\n        }\\n\\t\\t// poll all elements in qp and caclulate the sum of retios with max increases\\n        while(!pq.isEmpty()) {\\n            double[] current = pq.poll();\\n            sum+= current[0]/current[1];\\n        }\\n        return sum/classes.length;\\n    }\\n    \\n    private double getPotentialIncrease(double passes, double total) {\\n        return (passes + 1) / (total + 1)  - (passes / total);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> pq=new PriorityQueue<double[]>((a,b)->a[2]-b[2]>0?-1:1);\\n        double sum = 0;\\n        for(int i = 0; i < classes.length; i++) {\\n            if(classes[i][0] != classes[i][1]) {\\n                double passes = classes[i][0];\\n                double total = classes[i][1];\\n                pq.offer(new double[]{passes, total, getPotentialIncrease(passes, total)});\\n            } else {\\n                sum++;\\n            }\\n        }\\n        if(sum == classes.length) {\\n            return 1;\\n        }\\n\\n        while(!pq.isEmpty() && extraStudents-- > 0) {\\n\\t\\t    // poll the max potential increase element everytime\\n            double[] potential = pq.poll();\\n\\t\\t\\t// apply 1 extra student count to this \\n            potential[0] += 1;\\n            potential[1] += 1;\\n\\t\\t\\t// re-calculate the potential ratio increase for this element and put to pq again.\\n            pq.offer(new double[]{potential[0], potential[1], getPotentialIncrease(potential[0], potential[1])});\\n        }\\n\\t\\t// poll all elements in qp and caclulate the sum of retios with max increases\\n        while(!pq.isEmpty()) {\\n            double[] current = pq.poll();\\n            sum+= current[0]/current[1];\\n        }\\n        return sum/classes.length;\\n    }\\n    \\n    private double getPotentialIncrease(double passes, double total) {\\n        return (passes + 1) / (total + 1)  - (passes / total);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116393,
                "title": "java-math-solution",
                "content": "each extraStudents go to the class which make `v` max.\\n\\n`v =  (p+1) / (t + 1) - p / t`\\uFF1B\\n\\nso we can get the max average pass ratio.\\n\\n---\\n\\nbefore:  passed = `ai`, total = `bi`;\\n\\nwhen we add a extraStudent, \\n\\npassed = `ai + 1`, total = `bi + 1`;\\n\\n`dx = (ai + 1) / (bi + 1)  -  ai /bi `\\n\\nif  we want to get the max answer, we need to make  `dx` is the largest.\\n\\nbecause `sum = sum(ai/bi) + dx`.\\n\\nif we made `dx` is the largest, so the sum is the largest.\\n\\nso no matter how many extraStudent we have,  just make each extraStudent to made the  `dx` is the largest.\\n\\n---\\n\\n```\\n    // O(N*logN) time\\n    // O(N) space\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> doubles = new PriorityQueue<>((o1, o2) -> {\\n            double t1 = (o1[0] + 1) / (o1[1] + 1) - o1[0] / o1[1];\\n            double t2 = (o2[0] + 1) / (o2[1] + 1) - o2[0] / o2[1];\\n            if (t1 == t2) return 0;\\n            return t1 - t2 > 0 ? -1 : 1;\\n        });\\n        for (int[] c : classes) {\\n            double[] t = new double[3];\\n            t[0] = c[0];\\n            t[1] = c[1];\\n            t[2] = c[0] * 1.0D / c[1];\\n            doubles.add(t);\\n        }\\n        while (extraStudents > 0) {\\n            extraStudents--;\\n            double[] t = doubles.poll();\\n            t[0] += 1;\\n            t[1] += 1;\\n            t[2] = t[0] * 1.0D / t[1];\\n            doubles.add(t);\\n        }\\n        double t = 0;\\n        while (!doubles.isEmpty()) t += doubles.poll()[2];\\n\\n        return t / classes.length;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    // O(N*logN) time\\n    // O(N) space\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> doubles = new PriorityQueue<>((o1, o2) -> {\\n            double t1 = (o1[0] + 1) / (o1[1] + 1) - o1[0] / o1[1];\\n            double t2 = (o2[0] + 1) / (o2[1] + 1) - o2[0] / o2[1];\\n            if (t1 == t2) return 0;\\n            return t1 - t2 > 0 ? -1 : 1;\\n        });\\n        for (int[] c : classes) {\\n            double[] t = new double[3];\\n            t[0] = c[0];\\n            t[1] = c[1];\\n            t[2] = c[0] * 1.0D / c[1];\\n            doubles.add(t);\\n        }\\n        while (extraStudents > 0) {\\n            extraStudents--;\\n            double[] t = doubles.poll();\\n            t[0] += 1;\\n            t[1] += 1;\\n            t[2] = t[0] * 1.0D / t[1];\\n            doubles.add(t);\\n        }\\n        double t = 0;\\n        while (!doubles.isEmpty()) t += doubles.poll()[2];\\n\\n        return t / classes.length;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110807,
                "title": "java-detailed-explanation-and-step-by-step-implementation",
                "content": "You can view the solution here. This is my newly created blog. If you find the content useful kindly upvote :)\\nYou can find complete explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/03/1792-maximum-average-pass-ratio-leetcode.html\\n\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        Comparator<int[]> comp = new Comparator<>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                double aBefore = (double) a[0] / (double) a[1];\\n                double bBefore = (double) b[0] / (double) b[1];\\n                double aAfter  = (double) (a[0] + 1) / (double) (a[1] + 1);\\n                double bAfter  = (double) (b[0] + 1) / (double) (b[1] + 1);\\n                \\n                double dxOfA = aAfter - aBefore;\\n                double dxOfB = bAfter - bBefore;\\n                \\n                return Double.compare(dxOfB, dxOfA);\\n            }\\n        };\\n        \\n        PriorityQueue<int[]> queue = new PriorityQueue<>(comp);\\n        \\n        for(int[] arr : classes) {\\n            queue.add(arr);\\n        }\\n        \\n        while(extraStudents-- > 0) {\\n            int[] cur = queue.remove();\\n            cur[0]++; cur[1]++;\\n            queue.add(cur);\\n        }\\n        \\n        double sumOfRatios = 0;\\n        while(!queue.isEmpty()) {\\n            int[] cur = queue.remove();\\n            sumOfRatios += (double) cur[0] / (double) cur[1];\\n        }\\n        \\n        return sumOfRatios / (double) classes.length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        Comparator<int[]> comp = new Comparator<>() {\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                double aBefore = (double) a[0] / (double) a[1];\\n                double bBefore = (double) b[0] / (double) b[1];\\n                double aAfter  = (double) (a[0] + 1) / (double) (a[1] + 1);\\n                double bAfter  = (double) (b[0] + 1) / (double) (b[1] + 1);\\n                \\n                double dxOfA = aAfter - aBefore;\\n                double dxOfB = bAfter - bBefore;\\n                \\n                return Double.compare(dxOfB, dxOfA);\\n            }\\n        };\\n        \\n        PriorityQueue<int[]> queue = new PriorityQueue<>(comp);\\n        \\n        for(int[] arr : classes) {\\n            queue.add(arr);\\n        }\\n        \\n        while(extraStudents-- > 0) {\\n            int[] cur = queue.remove();\\n            cur[0]++; cur[1]++;\\n            queue.add(cur);\\n        }\\n        \\n        double sumOfRatios = 0;\\n        while(!queue.isEmpty()) {\\n            int[] cur = queue.remove();\\n            sumOfRatios += (double) cur[0] / (double) cur[1];\\n        }\\n        \\n        return sumOfRatios / (double) classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110307,
                "title": "swift-cfbinaryheap",
                "content": "```\\nimport CoreFoundation\\nclass Solution {\\n    func maxAverageRatio(_ classes: [[Int]], _ extraStudents: Int) -> Double {\\n        let minHeap = CFBinaryHeap.minHeap()\\n        var pointer: UnsafeMutablePointer<[Int]> = .allocate(capacity: 1)\\n        for v in classes\\n        {\\n            pointer = .allocate(capacity: 1)\\n            pointer.initialize(to: v)\\n            CFBinaryHeapAddValue(minHeap, pointer)\\n        }\\n        \\n        for _ in 0..<extraStudents\\n        {\\n            let v = CFBinaryHeapGetMinimum(minHeap).load(as: [Int].self)\\n            CFBinaryHeapRemoveMinimumValue(minHeap)\\n            pointer = .allocate(capacity: 1)\\n            pointer.initialize(to: [v[0]+1, v[1]+1])\\n            CFBinaryHeapAddValue(minHeap, pointer)\\n        }\\n        \\n        var res: Double = 0\\n        for _ in 0..<classes.count\\n        {\\n            let v = CFBinaryHeapGetMinimum(minHeap).load(as: [Int].self)\\n            CFBinaryHeapRemoveMinimumValue(minHeap)\\n            res += Double(v[0])/Double(v[1])\\n        }\\n        pointer.deallocate()\\n        return res/Double(classes.count)\\n    }\\n}\\n\\nprivate extension CFBinaryHeap\\n{\\n    static func minHeap() -> CFBinaryHeap\\n    {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { a, b, _ in\\n            let (x, y) = (a!.load(as: [Int].self), b!.load(as: [Int].self))\\n            let l = Double(x[0]+1)/Double(x[1]+1)-Double(x[0])/Double(x[1])\\n            let r = Double(y[0]+1)/Double(y[1]+1)-Double(y[0])/Double(y[1])\\n            return l == r ? 0 : l > r ? -1 : 1\\n        }\\n        return CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport CoreFoundation\\nclass Solution {\\n    func maxAverageRatio(_ classes: [[Int]], _ extraStudents: Int) -> Double {\\n        let minHeap = CFBinaryHeap.minHeap()\\n        var pointer: UnsafeMutablePointer<[Int]> = .allocate(capacity: 1)\\n        for v in classes\\n        {\\n            pointer = .allocate(capacity: 1)\\n            pointer.initialize(to: v)\\n            CFBinaryHeapAddValue(minHeap, pointer)\\n        }\\n        \\n        for _ in 0..<extraStudents\\n        {\\n            let v = CFBinaryHeapGetMinimum(minHeap).load(as: [Int].self)\\n            CFBinaryHeapRemoveMinimumValue(minHeap)\\n            pointer = .allocate(capacity: 1)\\n            pointer.initialize(to: [v[0]+1, v[1]+1])\\n            CFBinaryHeapAddValue(minHeap, pointer)\\n        }\\n        \\n        var res: Double = 0\\n        for _ in 0..<classes.count\\n        {\\n            let v = CFBinaryHeapGetMinimum(minHeap).load(as: [Int].self)\\n            CFBinaryHeapRemoveMinimumValue(minHeap)\\n            res += Double(v[0])/Double(v[1])\\n        }\\n        pointer.deallocate()\\n        return res/Double(classes.count)\\n    }\\n}\\n\\nprivate extension CFBinaryHeap\\n{\\n    static func minHeap() -> CFBinaryHeap\\n    {\\n        var callbacks = CFBinaryHeapCallBacks()\\n        callbacks.compare = { a, b, _ in\\n            let (x, y) = (a!.load(as: [Int].self), b!.load(as: [Int].self))\\n            let l = Double(x[0]+1)/Double(x[1]+1)-Double(x[0])/Double(x[1])\\n            let r = Double(y[0]+1)/Double(y[1]+1)-Double(y[0])/Double(y[1])\\n            return l == r ? 0 : l > r ? -1 : 1\\n        }\\n        return CFBinaryHeapCreate(nil, 0, &callbacks, nil)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109982,
                "title": "java-max-heap-solution",
                "content": "Based on the hint from Leetcode, write the below code:\\n\\n```````\\nclass Solution {\\n    /*Keep a max heap of the current class sizes and order them by the change in pass ratio. For each extra student, take the top of the heap, update the class size, and put it back in the heap.*/\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>( \\n            (a, b) -> {\\n                double ch1 = (a[0]+1)*1.0/(a[1]+1) - (a[0])*1.0/(a[1]);\\n                double ch2 = (b[0]+1)*1.0/(b[1]+1) - (b[0])*1.0/(b[1]);\\n                return Double.compare(ch2, ch1); \\n            } \\n        );\\n        \\n        for (int[] c : classes) {\\n            pq.offer(c);\\n        }\\n        while (extraStudents > 0) {\\n            int[] cur = pq.poll();\\n            pq.offer(new int[] {cur[0]+1, cur[1]+1});\\n            extraStudents--;\\n        }\\n        double sum = 0.0;\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            sum += (cur[0])*1.0/(cur[1]);\\n        }\\n        return sum/classes.length;\\n    }\\n}\\n``````````",
                "solutionTags": [],
                "code": "``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 1109874,
                "title": "maximize-the-usage-of-extrastudents",
                "content": "## Basic Idea:maximize each extraStudents\\n\\nConsider `c`with `old_pass, old_total`, then the pass ratio is  `old_pass/old_total`.\\nIf we assign an `extraStudent` to `c`, the pass ratio would become `(old_pass+1)/(old_total+1)`.\\n\\nHow to choose which `class` to assign each `extraStudent` ?\\nChoose the course such that adding one extraStudent will increase the pass ratio to maximum.\\ni.e. max(`(old_pass+1)/(old_total+1)-old_pass/old_total`) for all class\\n\\n## Use a Heap to track the course that has maximal value\\n\\n```\\nclass Solution:\\ndef maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = []\\n        heapq.heapify(heap)\\n        while classes:\\n            c = classes.pop()\\n            passing,total = c[0],c[1]\\n\\t\\t\\t# cuz python implement heap as minHeap, so we store the negative value\\n            potential = passing/total - (passing+1)/(total+1)\\n            heapq.heappush(heap,(potential,c))\\n        while extraStudents >0:\\n\\t\\t\\t# diff has the maximum value, so we add one extraStudent to this class\\n            diff, c = heapq.heappop(heap)\\n\\t\\t\\t# increment pass&total before recalculate cuz we are tracking the **next** value !!\\n            c[0]+=1\\n            c[1]+=1\\n            passing,total = c[0],c[1]\\n\\t\\t\\t# recalculate the potential value and push it back to heap\\n            potential = passing/total - (passing+1)/(total+1)\\n            heapq.heappush(heap,(potential,c))\\n            extraStudents -= 1\\n        n = len(heap)\\n        ratio = 0\\n        while heap:\\n            diff,c = heapq.heappop(heap)\\n            ratio += c[0]/c[1]\\n        return ratio/n\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\ndef maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = []\\n        heapq.heapify(heap)\\n        while classes:\\n            c = classes.pop()\\n            passing,total = c[0],c[1]\\n\\t\\t\\t# cuz python implement heap as minHeap, so we store the negative value\\n            potential = passing/total - (passing+1)/(total+1)\\n            heapq.heappush(heap,(potential,c))\\n        while extraStudents >0:\\n\\t\\t\\t# diff has the maximum value, so we add one extraStudent to this class\\n            diff, c = heapq.heappop(heap)\\n\\t\\t\\t# increment pass&total before recalculate cuz we are tracking the **next** value !!\\n            c[0]+=1\\n            c[1]+=1\\n            passing,total = c[0],c[1]\\n\\t\\t\\t# recalculate the potential value and push it back to heap\\n            potential = passing/total - (passing+1)/(total+1)\\n            heapq.heappush(heap,(potential,c))\\n            extraStudents -= 1\\n        n = len(heap)\\n        ratio = 0\\n        while heap:\\n            diff,c = heapq.heappop(heap)\\n            ratio += c[0]/c[1]\\n        return ratio/n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109807,
                "title": "python-clear-greedy-heap-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/TIn0wbbJDVs\\n\\n\\n\\nIntuition: Greedy+Heap\\n \\n\\n**Code**\\n```\\nfrom heapq import *\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = []\\n        \\n        for p, t in classes:\\n            delta = ((p+1)/(t+1))-(p/t)\\n            heappush(heap, (-delta, p, t))\\n        \\n        for _ in range(extraStudents):\\n            delta, p, t = heappop(heap)\\n            p += 1\\n            t += 1\\n            delta_new = ((p+1)/(t+1))-(p/t)\\n            heappush(heap, (-delta_new, p, t))\\n            \\n        res = sum(p/t for delta, p, t in heap)/len(heap)\\n        return res\\n```\\n\\n\\n\\nTime: O(n+klogn) / Space: O(n)\\n\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = []\\n        \\n        for p, t in classes:\\n            delta = ((p+1)/(t+1))-(p/t)\\n            heappush(heap, (-delta, p, t))\\n        \\n        for _ in range(extraStudents):\\n            delta, p, t = heappop(heap)\\n            p += 1\\n            t += 1\\n            delta_new = ((p+1)/(t+1))-(p/t)\\n            heappush(heap, (-delta_new, p, t))\\n            \\n        res = sum(p/t for delta, p, t in heap)/len(heap)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109789,
                "title": "my-javascript-solution-using-maxpriorityqueue-684-ms",
                "content": "```\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    const priorityQueue = new MaxPriorityQueue();\\n    let index;\\n    \\n    const getPriority = c => {\\n        return Math.floor(((c[0] + 1) / (c[1] + 1) - c[0] / c[1]) * 1e10);\\n    };\\n    \\n    for (let i = 0; i < classes.length; ++i) {\\n        if (classes[i][0] === classes[i][1]) continue;\\n        priorityQueue.enqueue(i, getPriority(classes[i]));\\n    }\\n    \\n    if (priorityQueue.size() > 0) {\\n        for (let i = 0; i < extraStudents; ++i) {\\n            index = priorityQueue.dequeue().element;\\n            ++classes[index][0];\\n            ++classes[index][1];\\n            priorityQueue.enqueue(index, getPriority(classes[index]));\\n        }\\n    }\\n    \\n    let result = 0;\\n    for (let i = 0; i < classes.length; ++i) {\\n        result += classes[i][0] / classes[i][1];\\n    }\\n    \\n    return result / classes.length;\\n};\\n```\\nFew words about ```1e10```, this is \"magic\" number for currrent input, initially I failed on 82/84 with ```1e5``` on this:\\n```\\n[[280,872],[108,128],[3,665],[93,972],[347,464],[443,584],[809,999],[366,398]]\\n77862\\n```\\nWhy I am not using another constructor that does not require \"integer\":\\n```\\nconst priorityQueue = new MaxPriorityQueue({ priority: (bid) => bid.priority });\\n```\\nbecause it works faster and even if you convert float to integer it will work faster too, but slower comparing to my solution (at least in my cases for now).",
                "solutionTags": [],
                "code": "```\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    const priorityQueue = new MaxPriorityQueue();\\n    let index;\\n    \\n    const getPriority = c => {\\n        return Math.floor(((c[0] + 1) / (c[1] + 1) - c[0] / c[1]) * 1e10);\\n    };\\n    \\n    for (let i = 0; i < classes.length; ++i) {\\n        if (classes[i][0] === classes[i][1]) continue;\\n        priorityQueue.enqueue(i, getPriority(classes[i]));\\n    }\\n    \\n    if (priorityQueue.size() > 0) {\\n        for (let i = 0; i < extraStudents; ++i) {\\n            index = priorityQueue.dequeue().element;\\n            ++classes[index][0];\\n            ++classes[index][1];\\n            priorityQueue.enqueue(index, getPriority(classes[index]));\\n        }\\n    }\\n    \\n    let result = 0;\\n    for (let i = 0; i < classes.length; ++i) {\\n        result += classes[i][0] / classes[i][1];\\n    }\\n    \\n    return result / classes.length;\\n};\\n```\n```1e10```\n```1e5```\n```\\n[[280,872],[108,128],[3,665],[93,972],[347,464],[443,584],[809,999],[366,398]]\\n77862\\n```\n```\\nconst priorityQueue = new MaxPriorityQueue({ priority: (bid) => bid.priority });\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108635,
                "title": "simple-greedy-solution-using-max-heap-for-beginners-o-m-logn-c",
                "content": "The **intuition** behind solving this problem is that, suppose we had to assign only one extra student to a class, then, we\\'ll be assigning that student to such a class which will yield maximum profit.\\nFor p (students that can pass exam) & tot (total students), profit after assigning the single student is given by:\\n\\tprofit = (p+1)/(tot+1) - p/tot\\n\\t\\nThus, for  k extra students, we can greedily assign each of the k students to a class which will give max profit.\\n\\nMax Heap can be used, so that we can extract  the required max profit in O(1) ;\\n\\n***\\n\\tdouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue <pair <double  ,pair<int,int>>> pq;  //max heap which stores profit\\n\\t\\tint p,tot;\\n        double profit,sum=0;\\n        \\n        for(auto x:classes) {\\n            p=x[0];\\n            tot=x[1];\\n            profit =  (double)(p+1)/(tot+1) - (double)p/tot;\\n            pq.push( {profit, {p,tot}});\\n        }\\n\\n        while(extraStudents--) {\\n            auto tmp = pq.top();\\n            auto tmp2 = tmp.second;\\n            p = tmp2.first;\\n            tot = tmp2.second;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// add one extra student to class and push it back into heap with expected profit\\n            p+=1;\\n            tot+=1;\\n\\t\\t\\tprofit =  (double)(p+1)/(tot+1) - (double)p/tot;\\n            pq.push( {profit, {p,tot}});\\n        }\\n        \\n\\t\\t// adding the pass ratio of all the classes with newly assigned students\\n        while(!pq.empty()) {\\n            auto tmp = pq.top();\\n            auto tmp2 = tmp.second;\\n            p = tmp2.first;\\n            tot = tmp2.second;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n            sum += (double)p/tot;\\n        }\\n        \\n\\t\\t// average of all pass ratio\\n        return (double)sum/(classes.size());\\n        \\n    }\\n***\\n\\nPlease note that, we haven\\'t actually assigned one student while pushing in heap. Here. everytime we push the profit into heap, we are actually pushing the expected profit after adding one student along with current p & tot.\\nAnd when we pop the class with max profit, then we finally add one student to that class.\\n\\n**Complexity Analysis:**\\nTime : \\nO( m logn + n logn) => O(m logn)  ... b\\'coz m & n are of same order\\n *where m is extraStudents & n is no of classes*\\n \\n Space :\\n O(n)  ... *only used for storing classes*.",
                "solutionTags": [],
                "code": "The **intuition** behind solving this problem is that, suppose we had to assign only one extra student to a class, then, we\\'ll be assigning that student to such a class which will yield maximum profit.\\nFor p (students that can pass exam) & tot (total students), profit after assigning the single student is given by:\\n\\tprofit = (p+1)/(tot+1) - p/tot\\n\\t\\nThus, for  k extra students, we can greedily assign each of the k students to a class which will give max profit.\\n\\nMax Heap can be used, so that we can extract  the required max profit in O(1) ;\\n\\n***\\n\\tdouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue <pair <double  ,pair<int,int>>> pq;  //max heap which stores profit\\n\\t\\tint p,tot;\\n        double profit,sum=0;\\n        \\n        for(auto x:classes) {\\n            p=x[0];\\n            tot=x[1];\\n            profit =  (double)(p+1)/(tot+1) - (double)p/tot;\\n            pq.push( {profit, {p,tot}});\\n        }\\n\\n        while(extraStudents--) {\\n            auto tmp = pq.top();\\n            auto tmp2 = tmp.second;\\n            p = tmp2.first;\\n            tot = tmp2.second;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// add one extra student to class and push it back into heap with expected profit\\n            p+=1;\\n            tot+=1;\\n\\t\\t\\tprofit =  (double)(p+1)/(tot+1) - (double)p/tot;\\n            pq.push( {profit, {p,tot}});\\n        }\\n        \\n\\t\\t// adding the pass ratio of all the classes with newly assigned students\\n        while(!pq.empty()) {\\n            auto tmp = pq.top();\\n            auto tmp2 = tmp.second;\\n            p = tmp2.first;\\n            tot = tmp2.second;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t\\n            sum += (double)p/tot;\\n        }\\n        \\n\\t\\t// average of all pass ratio\\n        return (double)sum/(classes.size());\\n        \\n    }\\n***\\n\\nPlease note that, we haven\\'t actually assigned one student while pushing in heap. Here. everytime we push the profit into heap, we are actually pushing the expected profit after adding one student along with current p & tot.\\nAnd when we pop the class with max profit, then we finally add one student to that class.\\n\\n**Complexity Analysis:**\\nTime : \\nO( m logn + n logn) => O(m logn)  ... b\\'coz m & n are of same order\\n *where m is extraStudents & n is no of classes*\\n \\n Space :\\n O(n)  ... *only used for storing classes*.",
                "codeTag": "Java"
            },
            {
                "id": 1108560,
                "title": "c-priority-queue",
                "content": "The minute the contest is over, I realized the solution was so simple. Wasted the whole time working on a totally wrong path. Sad.\\n**Key points:**\\n* Calculate ratio gain for inserting a student to each class. Use that ratio gain as key in a priority queue. Bundle class id in the queue with ratio gain.\\n* Each time, insert a student into the highest ratio gain class. Recalculate that class\\'s ratio gain after and maintain the queue. Repeat until all good students are inserted.\\n* Do the ratio average calculation at the end.\\n```\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n      std::priority_queue<std::pair<double, int>> q;\\n      for (int i=0; i<classes.size(); ++i)\\n        q.push({(classes[i][0]+1.0)/(classes[i][1]+1.0) - double(classes[i][0])/double(classes[i][1]), i});\\n      for (int i=0; i<extraStudents; ++i) {\\n        auto p = q.top();\\n        q.pop();\\n        ++classes[p.second][0];\\n        ++classes[p.second][1];\\n        q.push({(classes[p.second][0]+1.0)/(classes[p.second][1]+1.0) - double(classes[p.second][0])/double(classes[p.second][1]), p.second});\\n      }\\n      double ratios = 0;\\n      for (int i=0; i<classes.size(); ++i)\\n        ratios += double(classes[i][0])/double(classes[i][1]);\\n      return ratios/classes.size();\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n      std::priority_queue<std::pair<double, int>> q;\\n      for (int i=0; i<classes.size(); ++i)\\n        q.push({(classes[i][0]+1.0)/(classes[i][1]+1.0) - double(classes[i][0])/double(classes[i][1]), i});\\n      for (int i=0; i<extraStudents; ++i) {\\n        auto p = q.top();\\n        q.pop();\\n        ++classes[p.second][0];\\n        ++classes[p.second][1];\\n        q.push({(classes[p.second][0]+1.0)/(classes[p.second][1]+1.0) - double(classes[p.second][0])/double(classes[p.second][1]), p.second});\\n      }\\n      double ratios = 0;\\n      for (int i=0; i<classes.size(); ++i)\\n        ratios += double(classes[i][0])/double(classes[i][1]);\\n      return ratios/classes.size();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108513,
                "title": "priorityqueue-java-o-nlogn-greedy",
                "content": "### Here I am discussing my approach to this problem.\\n**Approach (Greedy):** Out of all the classes, choose that which will affect the score most. It means that, we have to choose maximum of all:\\n```\\n(classes[i][0] + 1) / (class[i][1] + 1) - classes[i][0] / classes[i][1] // for all i\\n```\\n\\nIt first seems like can be done easily in **O(n**<sup>**2**</sup>**)**, but we can reduce it to **O(nlogn)** using **PriorityQueue (max heap)**.\\n\\n***My Source Code:***\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((x, y) -> Double.compare(y.effect, x.effect));\\n        \\n        for(int i = 0; i < classes.length; ++i) {\\n            if(classes[i][0] == classes[i][1])\\n                continue;\\n            \\n            double effect = -(double)(classes[i][0]) / (double) (classes[i][1]) + (double)(classes[i][0] + 1) / (double) (classes[i][1] + 1);\\n            \\n            pq.add(new Pair(effect, i));\\n        }\\n        \\n        while(pq.size() > 0 && extraStudents-- > 0) {\\n            Pair p = pq.remove();\\n            int i = p.idx;\\n            ++classes[i][0];\\n            ++classes[i][1];\\n            \\n            double effect = -(double)(classes[i][0]) / (double) (classes[i][1]) + (double)(classes[i][0] + 1) / (double) (classes[i][1] + 1);\\n            \\n            pq.add(new Pair(effect, i));\\n        }\\n        \\n        double ans = 0;\\n        \\n        for(int[] a : classes) {\\n            double val = (double) (a[0]) / (double) (a[1]);\\n            ans += val;\\n        }\\n        \\n        return ans / (double) (classes.length);\\n    }\\n    \\n    class Pair {\\n        double effect;\\n        int idx;\\n        \\n        Pair(double effect, int idx) {\\n            this.effect = effect;\\n            this.idx = idx;\\n        }\\n    }\\n}\\n```\\n\\n```\\nTime Complexity: O(elogn) // where e = no. of extra students\\nSpace Complexity: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n(classes[i][0] + 1) / (class[i][1] + 1) - classes[i][0] / classes[i][1] // for all i\\n```\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((x, y) -> Double.compare(y.effect, x.effect));\\n        \\n        for(int i = 0; i < classes.length; ++i) {\\n            if(classes[i][0] == classes[i][1])\\n                continue;\\n            \\n            double effect = -(double)(classes[i][0]) / (double) (classes[i][1]) + (double)(classes[i][0] + 1) / (double) (classes[i][1] + 1);\\n            \\n            pq.add(new Pair(effect, i));\\n        }\\n        \\n        while(pq.size() > 0 && extraStudents-- > 0) {\\n            Pair p = pq.remove();\\n            int i = p.idx;\\n            ++classes[i][0];\\n            ++classes[i][1];\\n            \\n            double effect = -(double)(classes[i][0]) / (double) (classes[i][1]) + (double)(classes[i][0] + 1) / (double) (classes[i][1] + 1);\\n            \\n            pq.add(new Pair(effect, i));\\n        }\\n        \\n        double ans = 0;\\n        \\n        for(int[] a : classes) {\\n            double val = (double) (a[0]) / (double) (a[1]);\\n            ans += val;\\n        }\\n        \\n        return ans / (double) (classes.length);\\n    }\\n    \\n    class Pair {\\n        double effect;\\n        int idx;\\n        \\n        Pair(double effect, int idx) {\\n            this.effect = effect;\\n            this.idx = idx;\\n        }\\n    }\\n}\\n```\n```\\nTime Complexity: O(elogn) // where e = no. of extra students\\nSpace Complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108510,
                "title": "c-greedy-max-heap",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\nLet `dist(c)` be the increase of pass ratio if we add the student into class `c`.\\n\\nWe should greedily pick the class with the greatest `dist(c)`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-average-pass-ratio/\\n// Author: github.com/lzl124631x\\n// Time: O((E + C)logC)\\n// Space: O(C)\\nclass Solution {\\n    double dist(pair<int, int> &p) {\\n        return (double)(p.first + 1) / (p.second + 1) - (double)p.first / p.second;\\n    }\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& C, int E) {\\n        int ones = 0;\\n        auto cmp = [&](auto &a, auto &b) { return dist(a) < dist(b); };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\\n        for (auto &c : C) {\\n            if (c[0] == c[1]) ++ones;\\n            else pq.emplace(c[0], c[1]);\\n        }\\n        for (int i = 0; i < E && pq.size(); ++i) {\\n            auto [a, b] = pq.top();\\n            pq.pop();\\n            pq.emplace(a + 1, b + 1);\\n        }\\n        double total = 0;\\n        while (pq.size()) {\\n            auto [a, b] = pq.top();\\n            pq.pop();\\n            total += (double)a / b;\\n        }\\n        return (total + ones) / C.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-average-pass-ratio/\\n// Author: github.com/lzl124631x\\n// Time: O((E + C)logC)\\n// Space: O(C)\\nclass Solution {\\n    double dist(pair<int, int> &p) {\\n        return (double)(p.first + 1) / (p.second + 1) - (double)p.first / p.second;\\n    }\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& C, int E) {\\n        int ones = 0;\\n        auto cmp = [&](auto &a, auto &b) { return dist(a) < dist(b); };\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\\n        for (auto &c : C) {\\n            if (c[0] == c[1]) ++ones;\\n            else pq.emplace(c[0], c[1]);\\n        }\\n        for (int i = 0; i < E && pq.size(); ++i) {\\n            auto [a, b] = pq.top();\\n            pq.pop();\\n            pq.emplace(a + 1, b + 1);\\n        }\\n        double total = 0;\\n        while (pq.size()) {\\n            auto [a, b] = pq.top();\\n            pq.pop();\\n            total += (double)a / b;\\n        }\\n        return (total + ones) / C.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108485,
                "title": "c-greedy-solution-with-max-heap",
                "content": "Idea:\\n1. Calculate the original sum of pass rates for all classes without any extraStudents\\n2. Assign the extraStudents to the class that increases the average the most\\n->eg.if pass_i=1, total_i=2, then the increasement will be (2/3)-(1/2)\\n3. Use the increasement(eg.(2/3)-(1/2) to sort the heap\\n->for each iteration, just increase the result by the gain, and increase pass_i and total_i by 1 (eg.i is the class index that leads to most average gain)\\n```\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) \\n{\\n\\tdouble result=0;\\n\\tpriority_queue<pair<double,pair<double,double>>> q;\\n\\tint n=classes.size();\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tresult+=classes[i][0]*1.0/classes[i][1];\\n\\t\\tdouble x=classes[i][0],y=classes[i][1];\\n\\t\\tq.push({(x+1)/(y+1)-x/y,{x,y}});\\n\\t}\\n\\twhile(extraStudents--)\\n\\t{\\n\\t\\tpair<double,pair<double,double>> p=q.top();\\n\\t\\tq.pop();\\n\\t\\tresult+=p.first;\\n\\t\\tdouble x=p.second.first+1,y=p.second.second+1;\\n\\t\\tq.push({(x+1)/(y+1)-x/y,{x,y}});\\n\\t}\\n\\treturn result/(double)n;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) \\n{\\n\\tdouble result=0;\\n\\tpriority_queue<pair<double,pair<double,double>>> q;\\n\\tint n=classes.size();\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tresult+=classes[i][0]*1.0/classes[i][1];\\n\\t\\tdouble x=classes[i][0],y=classes[i][1];\\n\\t\\tq.push({(x+1)/(y+1)-x/y,{x,y}});\\n\\t}\\n\\twhile(extraStudents--)\\n\\t{\\n\\t\\tpair<double,pair<double,double>> p=q.top();\\n\\t\\tq.pop();\\n\\t\\tresult+=p.first;\\n\\t\\tdouble x=p.second.first+1,y=p.second.second+1;\\n\\t\\tq.push({(x+1)/(y+1)-x/y,{x,y}});\\n\\t}\\n\\treturn result/(double)n;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108457,
                "title": "c-priority-queue-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double sum = 0.0;\\n        \\n        priority_queue<tuple<double, int, int>> q;   // heap will compare the elements of tuple sequentially \\n        \\n        for (const auto& class_ : classes) {\\n            int a = class_[0], b = class_[1];\\n            \\n            sum += (double)(a) / b; \\n            \\n            q.push({calculateDelta(a, b), a + 1, b + 1}); \\n        }\\n    \\n        \\n        while (extraStudents) {\\n            auto [delta, a, b] = q.top(); q.pop();\\n            \\n            sum += delta;\\n            \\n            q.push({calculateDelta(a, b), a + 1, b + 1});\\n            \\n            extraStudents--;\\n        }\\n        \\n        return sum / classes.size();\\n    }\\n    \\n    double calculateDelta(int a, int b) {\\n        return (double)(a + 1) / (b + 1) - (double)(a) / b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double sum = 0.0;\\n        \\n        priority_queue<tuple<double, int, int>> q;   // heap will compare the elements of tuple sequentially \\n        \\n        for (const auto& class_ : classes) {\\n            int a = class_[0], b = class_[1];\\n            \\n            sum += (double)(a) / b; \\n            \\n            q.push({calculateDelta(a, b), a + 1, b + 1}); \\n        }\\n    \\n        \\n        while (extraStudents) {\\n            auto [delta, a, b] = q.top(); q.pop();\\n            \\n            sum += delta;\\n            \\n            q.push({calculateDelta(a, b), a + 1, b + 1});\\n            \\n            extraStudents--;\\n        }\\n        \\n        return sum / classes.size();\\n    }\\n    \\n    double calculateDelta(int a, int b) {\\n        return (double)(a + 1) / (b + 1) - (double)(a) / b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108448,
                "title": "c-priority-queue-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        // {derivative, {denominator, Numerator}}\\n        priority_queue<pair<double, pair<int, int>>> pq; \\n        double res = 0;\\n        for(auto clazz : classes) {\\n            double m = clazz[0], n = clazz[1];\\n            pq.push({(n-m)/(n*n+n),{m,n}});\\n            res += (m/n);\\n        }\\n        \\n        for(;extraStudents > 0; extraStudents--) {\\n            auto foo = pq.top();\\n            pq.pop();\\n            res += foo.first;\\n            double m = foo.second.first+1, n = foo.second.second+1;\\n            pq.push({(n-m)/(n*n+n),{m,n}});\\n        }\\n        return res / classes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        // {derivative, {denominator, Numerator}}\\n        priority_queue<pair<double, pair<int, int>>> pq; \\n        double res = 0;\\n        for(auto clazz : classes) {\\n            double m = clazz[0], n = clazz[1];\\n            pq.push({(n-m)/(n*n+n),{m,n}});\\n            res += (m/n);\\n        }\\n        \\n        for(;extraStudents > 0; extraStudents--) {\\n            auto foo = pq.top();\\n            pq.pop();\\n            res += foo.first;\\n            double m = foo.second.first+1, n = foo.second.second+1;\\n            pq.push({(n-m)/(n*n+n),{m,n}});\\n        }\\n        return res / classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108437,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int n = classes.size();\\n        priority_queue<pair<double, int>> pq;\\n        for (int i=0; i<n; i++) {\\n            double curr = classes[i][0] / double(classes[i][1]) * 100;\\n            double updated = (classes[i][0]+1) / double(classes[i][1]+1) * 100;\\n            //cout << updated-curr << endl;\\n            pq.push(make_pair(updated-curr, i));\\n        }\\n        while (extraStudents--) {\\n            auto tot = pq.top();\\n            pq.pop();\\n            int i = tot.second;\\n            classes[i][0]++;\\n            classes[i][1]++;\\n            double curr = classes[i][0] / double(classes[i][1]) * 100;\\n            double updated = (classes[i][0]+1) / double(classes[i][1]+1) * 100;\\n            pq.push(make_pair(updated-curr, i));\\n        }\\n        double ans = 0;\\n        while (!pq.empty()) {\\n            auto tot = pq.top();\\n            pq.pop();\\n            int i = tot.second;\\n            double curr = classes[i][0] / double(classes[i][1]);\\n            ans += curr;\\n        }\\n        ans /= n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int n = classes.size();\\n        priority_queue<pair<double, int>> pq;\\n        for (int i=0; i<n; i++) {\\n            double curr = classes[i][0] / double(classes[i][1]) * 100;\\n            double updated = (classes[i][0]+1) / double(classes[i][1]+1) * 100;\\n            //cout << updated-curr << endl;\\n            pq.push(make_pair(updated-curr, i));\\n        }\\n        while (extraStudents--) {\\n            auto tot = pq.top();\\n            pq.pop();\\n            int i = tot.second;\\n            classes[i][0]++;\\n            classes[i][1]++;\\n            double curr = classes[i][0] / double(classes[i][1]) * 100;\\n            double updated = (classes[i][0]+1) / double(classes[i][1]+1) * 100;\\n            pq.push(make_pair(updated-curr, i));\\n        }\\n        double ans = 0;\\n        while (!pq.empty()) {\\n            auto tot = pq.top();\\n            pq.pop();\\n            int i = tot.second;\\n            double curr = classes[i][0] / double(classes[i][1]);\\n            ans += curr;\\n        }\\n        ans /= n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1108316,
                "title": "python3-greedy-priority-queue",
                "content": "\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq = [(p/t - (p+1)/(t+1), p, t) for p, t in classes] # max-heap \\n        heapify(pq)\\n        \\n        for _ in range(extraStudents):  \\n            _, p, t = heappop(pq)\\n            heappush(pq, ((p+1)/(t+1) - (p+2)/(t+2), p+1, t+1))\\n        \\n        return sum(p/t for _, p, t in pq)/len(pq)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq = [(p/t - (p+1)/(t+1), p, t) for p, t in classes] # max-heap \\n        heapify(pq)\\n        \\n        for _ in range(extraStudents):  \\n            _, p, t = heappop(pq)\\n            heappush(pq, ((p+1)/(t+1) - (p+2)/(t+2), p+1, t+1))\\n        \\n        return sum(p/t for _, p, t in pq)/len(pq)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108314,
                "title": "python3-max-heap-greedy-solution",
                "content": "The goal is that for every student, we want to place him or her in the class that will have the maximal impact on the overall average. To do that, we simply just compare all the difference in ratios if we were to place one student in each class for the incoming student.\\n```\\nclass Solution:\\n    def maxAverageRatio(self, c: List[List[int]], e: int) -> float:\\n        pq = []\\n        for p, t in c:\\n            heappush(pq, (-((p + 1) / (t + 1) - (p / t)), p, t))\\n        while e:\\n            r, p, t = heappop(pq)\\n            p += 1\\n            t += 1\\n            heappush(pq, (-((p + 1) / (t + 1) - (p / t)), p, t))\\n            e -= 1\\n        res = 0\\n        while pq:\\n            r, p, t = heappop(pq)\\n            res += p / t\\n        return res / len(c)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, c: List[List[int]], e: int) -> float:\\n        pq = []\\n        for p, t in c:\\n            heappush(pq, (-((p + 1) / (t + 1) - (p / t)), p, t))\\n        while e:\\n            r, p, t = heappop(pq)\\n            p += 1\\n            t += 1\\n            heappush(pq, (-((p + 1) / (t + 1) - (p / t)), p, t))\\n            e -= 1\\n        res = 0\\n        while pq:\\n            r, p, t = heappop(pq)\\n            res += p / t\\n        return res / len(c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108277,
                "title": "simple-intuitive-java-with-comments-explanation-priority-queue",
                "content": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        int n = classes.length;\\n        \\n        // Create priority queue to store the data, see comparator class\\n        PriorityQueue<Classroom> cpq = new PriorityQueue<Classroom>(n, new CustomComparator()); \\n        int i;\\n        double ans = 0.0;\\n        \\n        for(i = 0; i < n; i++) {\\n            cpq.add(new Classroom(classes[i][0], classes[i][1]));\\n        }\\n        \\n        for(i = 0; i < extraStudents; i++) {\\n            \\n            // In our comparator, we have already calculated which is the best class to put that extra student\\n            // So this if function is just updating the priority queue with the latest calculated pass ratio\\n            Classroom c = cpq.poll();\\n            cpq.add(new Classroom(c.pass + 1, c.total + 1));\\n        }\\n        \\n        for(i = 0; i < n; i++) {\\n            Classroom c = cpq.poll();\\n            ans += c.pr;\\n        }\\n        \\n        return ans / n;\\n        \\n    }\\n}\\n\\nclass Classroom {\\n    double pass;\\n    double total;\\n    double pr;\\n    public Classroom(double p, double t) {\\n        pass = p;\\n        total = t;\\n        pr = p / t;\\n    }\\n}\\n\\nclass CustomComparator implements Comparator<Classroom> {\\n\\n    @Override\\n    public int compare(Classroom c1, Classroom c2) {\\n        \\n        // We want to maximize our pass ratio, so putting the extra student in whichever class\\n        // gives us better profit in pass ratio wins.\\n        double pr1 = ((c1.pass + 1) / (c1.total + 1)) - c1.pr;\\n        double pr2 = ((c2.pass + 1) / (c2.total + 1)) - c2.pr;\\n        if (pr1 > pr2) {\\n            return -1;\\n        }\\n        else if (pr1 < pr2) {\\n            return 1;\\n        }\\n        else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        int n = classes.length;\\n        \\n        // Create priority queue to store the data, see comparator class\\n        PriorityQueue<Classroom> cpq = new PriorityQueue<Classroom>(n, new CustomComparator()); \\n        int i;\\n        double ans = 0.0;\\n        \\n        for(i = 0; i < n; i++) {\\n            cpq.add(new Classroom(classes[i][0], classes[i][1]));\\n        }\\n        \\n        for(i = 0; i < extraStudents; i++) {\\n            \\n            // In our comparator, we have already calculated which is the best class to put that extra student\\n            // So this if function is just updating the priority queue with the latest calculated pass ratio\\n            Classroom c = cpq.poll();\\n            cpq.add(new Classroom(c.pass + 1, c.total + 1));\\n        }\\n        \\n        for(i = 0; i < n; i++) {\\n            Classroom c = cpq.poll();\\n            ans += c.pr;\\n        }\\n        \\n        return ans / n;\\n        \\n    }\\n}\\n\\nclass Classroom {\\n    double pass;\\n    double total;\\n    double pr;\\n    public Classroom(double p, double t) {\\n        pass = p;\\n        total = t;\\n        pr = p / t;\\n    }\\n}\\n\\nclass CustomComparator implements Comparator<Classroom> {\\n\\n    @Override\\n    public int compare(Classroom c1, Classroom c2) {\\n        \\n        // We want to maximize our pass ratio, so putting the extra student in whichever class\\n        // gives us better profit in pass ratio wins.\\n        double pr1 = ((c1.pass + 1) / (c1.total + 1)) - c1.pr;\\n        double pr2 = ((c2.pass + 1) / (c2.total + 1)) - c2.pr;\\n        if (pr1 > pr2) {\\n            return -1;\\n        }\\n        else if (pr1 < pr2) {\\n            return 1;\\n        }\\n        else {\\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108272,
                "title": "python3-priority-queue-solution-with-thought-process",
                "content": "From the description, we can tell that after adding 1 to both numbers to `[pass, total]`, \\nwe want to make sure that the value of `(pass+1)/(total+1) - pass/total` is the maximum across all classes.\\n\\nTherefore, we want to sort by this value `(total-pass)/(total*(total+1))` and after each update, we also want to get the new largest value. And it\\'s pretty strightfoward to think about using Priority Queue here.\\n\\nTime: O((k+n)logn)   Space: O(n), where n is the length of `classes` and k is the value of `extraStudents`\\n\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq = []\\n                  \\n        for i, stat in enumerate(classes):\\n            score = (stat[1]-stat[0])/(stat[1]*(stat[1]+1))\\n            heapq.heappush(pq, (-score, i))\\n            \\n        while extraStudents:\\n            _, idx = heapq.heappop(pq)\\n            \\n            classes[idx][0] += 1\\n            classes[idx][1] += 1\\n            newScore = (classes[idx][1]-classes[idx][0])/(classes[idx][1]*(classes[idx][1]+1))\\n            heapq.heappush(pq, (-newScore, idx))\\n            \\n            extraStudents -= 1\\n            \\n        return sum(stat[0]/stat[1] for stat in classes)/len(classes)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq = []\\n                  \\n        for i, stat in enumerate(classes):\\n            score = (stat[1]-stat[0])/(stat[1]*(stat[1]+1))\\n            heapq.heappush(pq, (-score, i))\\n            \\n        while extraStudents:\\n            _, idx = heapq.heappop(pq)\\n            \\n            classes[idx][0] += 1\\n            classes[idx][1] += 1\\n            newScore = (classes[idx][1]-classes[idx][0])/(classes[idx][1]*(classes[idx][1]+1))\\n            heapq.heappush(pq, (-newScore, idx))\\n            \\n            extraStudents -= 1\\n            \\n        return sum(stat[0]/stat[1] for stat in classes)/len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047534,
                "title": "python-check-increase-in-pass-ratio",
                "content": "The main thing to understand is how we are going to assign a student to any class.\\n\\nSee, we want to \"MAXIMIZE\" the average pass ratio. So, it makes sense that when we assign a student to any class, we are doing it such that the change in the pass ratio is maximum for that particular class after we assign a student to it. \\n\\nTo understand it better, take an example.\\n\\n\\tclasses = [[1,2],[3,5],[2,2]], extraStudents = 2\\n\\t\\n\\tLet\\'s say we want to assign a student to any class.\\n\\t\\n\\tWe have three options to choose from.\\n\\t\\n\\tFor class 0, its old pass ratio is 1/2 => 0.5\\n    If we assign one student to it, is new pass ratio will be 2/3 => 0.66666\\n        \\n    For class 1, its old pass ratio is 3/5 => 0.6\\n    If we assign one student to it, is new pass ratio will be 4/6 => 0.66666\\n        \\n    For class 2, its old pass ratio is 2/2 => 1\\n    If we assign one student to it, is new pass ratio will be 3/3 => 1\\n\\t\\n\\tSo, what can we observe?\\n\\t\\n\\tWe can see that assigning students to class 2 is of no use because its pass ratio will always remain \"1\"\\n\\tSo, for class 2, the increase in pass ratio will be 0.\\n\\t\\n\\tAs for class 0 and class 1, \\n\\t\\n\\twe see that assigning a student to class 0 will increase the pass ratio\\n\\tfrom 0.5 to 0.66666 => An increase of 0.16666\\n\\t\\n\\tAnd, assigning a student to class 1 will increase the pass ratio\\n\\tfrom 0.6 to 0.66666 => An increase of 0.06666\\n\\t\\n\\tSo, we can conclude that we if have to assign a student to any class such that \\n\\tthe average pass ratio is maximized, we have to assign that student to class 0\\n\\tsince for that class, the increase in pass ratio is the maximum among all the classes.\\n\\t\\nAnd that\\'s the main idea behind choosing a class for a student.\\n\\nWe want to keep track of what is the increase in the pass ratio if we assign a student to any class.\\nAnd whatever class has the highest increase will be the one which we will choose and add the student to it.\\n\\nAnd since we want this data to be ordered all the time as we add students to classes, we will use a maxHeap here which will order the classes by their increase in the pass ratio upon addition of a student.\\n\\t\\n```\\ndef maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n\\n\\t\\t# Number of classes\\n        n = len(classes)\\n        \\n        # MaxHeap\\n        maxHeap = []\\n        \\n        for i in range(n):\\n            # What would be the increase in pass ratio if a student is assigned to this class?\\n            # It would be newPassRatio - oldPassRatio\\n            oldPassRatio = classes[i][0] / classes[i][1]\\n            newPassRatio = (classes[i][0] + 1) / (classes[i][1] + 1)\\n            \\n            increaseInPassRatio = newPassRatio - oldPassRatio\\n            \\n            # We want to order classes by their increaseInPassRatio\\n            # That\\'s why increaseInPassRatio is the first item\\n            # It is in negative so that we can utilize the minHeap in python as a maxHeap\\n            heappush(maxHeap, [-increaseInPassRatio, classes[i]])\\n            \\n        # Now, we can start assigning classes\\n        while extraStudents > 0:\\n            \\n            # Take the classes with highest increaseInPassRatio if we assign a student to it\\n            top = heappop(maxHeap)\\n            \\n            # Assign the student to this class\\n            extraStudents -= 1\\n            \\n            top[1][0] += 1\\n            top[1][1] += 1\\n            \\n            # Now, before we push it back to the maxHeap\\n            # We want to calculate the new \"increaseInPassRatio\" value since we added one student to it\\n            oldPassRatio = top[1][0] / top[1][1]\\n            newPassRatio = (top[1][0] + 1) / (top[1][1] + 1)\\n            \\n            increaseInPassRatio = newPassRatio - oldPassRatio\\n            \\n            top[0] = -increaseInPassRatio\\n            \\n            # Now, we can push back this data in the maxHeap\\n            heappush(maxHeap, top)\\n        \\n        # Now, we will calculate the total of pass ratios of all the classes\\n        totalPassRatio = 0\\n        while maxHeap:\\n            top = heappop(maxHeap)\\n            \\n            totalPassRatio += top[1][0] / top[1][1]\\n        \\n        # And finally, return the Average Pass Ratio\\n        return totalPassRatio / n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n\\n\\t\\t# Number of classes\\n        n = len(classes)\\n        \\n        # MaxHeap\\n        maxHeap = []\\n        \\n        for i in range(n):\\n            # What would be the increase in pass ratio if a student is assigned to this class?\\n            # It would be newPassRatio - oldPassRatio\\n            oldPassRatio = classes[i][0] / classes[i][1]\\n            newPassRatio = (classes[i][0] + 1) / (classes[i][1] + 1)\\n            \\n            increaseInPassRatio = newPassRatio - oldPassRatio\\n            \\n            # We want to order classes by their increaseInPassRatio\\n            # That\\'s why increaseInPassRatio is the first item\\n            # It is in negative so that we can utilize the minHeap in python as a maxHeap\\n            heappush(maxHeap, [-increaseInPassRatio, classes[i]])\\n            \\n        # Now, we can start assigning classes\\n        while extraStudents > 0:\\n            \\n            # Take the classes with highest increaseInPassRatio if we assign a student to it\\n            top = heappop(maxHeap)\\n            \\n            # Assign the student to this class\\n            extraStudents -= 1\\n            \\n            top[1][0] += 1\\n            top[1][1] += 1\\n            \\n            # Now, before we push it back to the maxHeap\\n            # We want to calculate the new \"increaseInPassRatio\" value since we added one student to it\\n            oldPassRatio = top[1][0] / top[1][1]\\n            newPassRatio = (top[1][0] + 1) / (top[1][1] + 1)\\n            \\n            increaseInPassRatio = newPassRatio - oldPassRatio\\n            \\n            top[0] = -increaseInPassRatio\\n            \\n            # Now, we can push back this data in the maxHeap\\n            heappush(maxHeap, top)\\n        \\n        # Now, we will calculate the total of pass ratios of all the classes\\n        totalPassRatio = 0\\n        while maxHeap:\\n            top = heappop(maxHeap)\\n            \\n            totalPassRatio += top[1][0] / top[1][1]\\n        \\n        # And finally, return the Average Pass Ratio\\n        return totalPassRatio / n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989625,
                "title": "racket-solution",
                "content": "\\n\\n# Code\\n```\\n\\n(define (ratio-delta class)\\n  (- (/ (add1 (first class))\\n        (add1 (second class)))\\n     (/ (first class)\\n        (second class))))\\n\\n(define/contract (max-average-ratio classes extraStudents)\\n  (-> (listof (listof exact-integer?)) exact-integer? flonum?)\\n  (let ((heap (make-heap (lambda (a b)\\n                           (> (car a)\\n                              (car b)))))\\n        (classes (map (lambda (class)\\n                        (let ((class (map real->double-flonum class)))\\n                          (cons (ratio-delta class)\\n                                class)))\\n                      classes)))\\n    (heap-add-all! heap classes)\\n    (for ((i (range 0 extraStudents)))\\n      (let* ((m (heap-min heap))\\n             (new (list (add1 (second m))\\n                        (add1 (third m))) )\\n             (new (cons (ratio-delta new)\\n                        new)))\\n        (heap-remove-min! heap)\\n        (heap-add! heap new)))\\n    (/ (apply + (map (lambda (a) (/ (second a)\\n                                    (third a)))\\n                     (vector->list (heap->vector heap))))\\n       (length classes))))\\n\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\n\\n(define (ratio-delta class)\\n  (- (/ (add1 (first class))\\n        (add1 (second class)))\\n     (/ (first class)\\n        (second class))))\\n\\n(define/contract (max-average-ratio classes extraStudents)\\n  (-> (listof (listof exact-integer?)) exact-integer? flonum?)\\n  (let ((heap (make-heap (lambda (a b)\\n                           (> (car a)\\n                              (car b)))))\\n        (classes (map (lambda (class)\\n                        (let ((class (map real->double-flonum class)))\\n                          (cons (ratio-delta class)\\n                                class)))\\n                      classes)))\\n    (heap-add-all! heap classes)\\n    (for ((i (range 0 extraStudents)))\\n      (let* ((m (heap-min heap))\\n             (new (list (add1 (second m))\\n                        (add1 (third m))) )\\n             (new (cons (ratio-delta new)\\n                        new)))\\n        (heap-remove-min! heap)\\n        (heap-add! heap new)))\\n    (/ (apply + (map (lambda (a) (/ (second a)\\n                                    (third a)))\\n                     (vector->list (heap->vector heap))))\\n       (length classes))))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972152,
                "title": "c-priority-queue",
                "content": "# Intuition\\nSimply greedy picking a class that gives the best profit and update the numbers. \\nThe profit of a class (p, q) is the difference p/q - (p+1)/(q+1).  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public double MaxAverageRatio(int[][] classes, int extraStudents) \\n    {\\n        var n = classes.Length;\\n        var pq = new PriorityQueue<(double, double), double>();\\n        foreach(var candidate in classes)\\n        {\\n            pq.Enqueue( (candidate[0], candidate[1]) , GetProfit(candidate[0], candidate[1]));\\n        }    \\n\\n        //  p + 1\\n        while(extraStudents-- > 0)\\n        {\\n            var (first, second) = pq.Dequeue();\\n            ++first;\\n            ++second;\\n            pq.Enqueue( (first, second), GetProfit( first, second) );\\n        }\\n\\n        var result = 0D;\\n        while(pq.Count > 0)\\n        {\\n            var (first, second) = pq.Dequeue();\\n\\n            result += first/second;\\n\\n            Console.WriteLine($\"{first} {second} {first/second}\" );\\n        }\\n        \\n        return result/n;\\n    }\\n\\n    public double GetProfit(double x, double y)\\n    {\\n        return x/y - (x+1)/(y+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double MaxAverageRatio(int[][] classes, int extraStudents) \\n    {\\n        var n = classes.Length;\\n        var pq = new PriorityQueue<(double, double), double>();\\n        foreach(var candidate in classes)\\n        {\\n            pq.Enqueue( (candidate[0], candidate[1]) , GetProfit(candidate[0], candidate[1]));\\n        }    \\n\\n        //  p + 1\\n        while(extraStudents-- > 0)\\n        {\\n            var (first, second) = pq.Dequeue();\\n            ++first;\\n            ++second;\\n            pq.Enqueue( (first, second), GetProfit( first, second) );\\n        }\\n\\n        var result = 0D;\\n        while(pq.Count > 0)\\n        {\\n            var (first, second) = pq.Dequeue();\\n\\n            result += first/second;\\n\\n            Console.WriteLine($\"{first} {second} {first/second}\" );\\n        }\\n        \\n        return result/n;\\n    }\\n\\n    public double GetProfit(double x, double y)\\n    {\\n        return x/y - (x+1)/(y+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919258,
                "title": "maximum-average-pass-ratio",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} classes\\n * @param {number} extraStudents\\n * @return {number}\\n */\\nclass MaxHeap {\\n    constructor() {\\n        this.heap = [];\\n    }\\n\\n    push(value) {\\n        this.heap.push(value);\\n        this.heapifyUp(this.heap.length - 1);\\n    }\\n\\n    pop() {\\n        if (this.heap.length === 0) {\\n            return null;\\n        }\\n        if (this.heap.length === 1) {\\n            return this.heap.pop();\\n        }\\n\\n        const top = this.heap[0];\\n        this.heap[0] = this.heap.pop();\\n        this.heapifyDown(0);\\n\\n        return top;\\n    }\\n\\n    heapifyUp(index) {\\n        while (index > 0) {\\n            const parent = Math.floor((index - 1) / 2);\\n            if (this.heap[parent][0] < this.heap[index][0]) {\\n                [this.heap[parent], this.heap[index]] = [this.heap[index], this.heap[parent]];\\n                index = parent;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    heapifyDown(index) {\\n        const n = this.heap.length;\\n        while (true) {\\n            let largest = index;\\n            const left = 2 * index + 1;\\n            const right = 2 * index + 2;\\n\\n            if (left < n && this.heap[left][0] > this.heap[largest][0]) {\\n                largest = left;\\n            }\\n            if (right < n && this.heap[right][0] > this.heap[largest][0]) {\\n                largest = right;\\n            }\\n\\n            if (largest !== index) {\\n                [this.heap[index], this.heap[largest]] = [this.heap[largest], this.heap[index]];\\n                index = largest;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    size() {\\n        return this.heap.length;\\n    }\\n}\\n\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    const n = classes.length;\\n\\n    // Helper function to calculate pass ratio increase\\n    const passRatioIncrease = (pass, total) => (pass + 1) / (total + 1) - pass / total;\\n\\n    // Initialize max heap to keep track of classes with maximum improvement\\n    const maxHeap = new MaxHeap();\\n\\n    for (let j = 0; j < n; j++) {\\n        const [pass, total] = classes[j];\\n        if (pass !== total) {\\n            const increase = passRatioIncrease(pass, total);\\n            maxHeap.push([increase, j]);\\n        }\\n    }\\n\\n    let totalPassRatio = 0;\\n\\n    for (let j = 0; j < n; j++) {\\n        totalPassRatio += classes[j][0] / classes[j][1];\\n    }\\n\\n    for (let i = 0; i < extraStudents; i++) {\\n        if (maxHeap.size() === 0) {\\n            break; // No more classes to consider\\n        }\\n\\n        const [increase, maxIndex] = maxHeap.pop();\\n        const [pass, total] = classes[maxIndex];\\n        const newPass = pass + 1;\\n        const newTotal = total + 1;\\n        const newIncrease = passRatioIncrease(newPass, newTotal);\\n        const newAvg = (totalPassRatio - (pass / total)) + (newPass / newTotal);\\n\\n        if (newAvg <= totalPassRatio) {\\n            break; // No further improvement possible\\n        }\\n\\n        totalPassRatio = newAvg;\\n        classes[maxIndex][0]++;\\n        classes[maxIndex][1]++;\\n        maxHeap.push([newIncrease, maxIndex]);\\n    }\\n\\n    return totalPassRatio / n;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} classes\\n * @param {number} extraStudents\\n * @return {number}\\n */\\nclass MaxHeap {\\n    constructor() {\\n        this.heap = [];\\n    }\\n\\n    push(value) {\\n        this.heap.push(value);\\n        this.heapifyUp(this.heap.length - 1);\\n    }\\n\\n    pop() {\\n        if (this.heap.length === 0) {\\n            return null;\\n        }\\n        if (this.heap.length === 1) {\\n            return this.heap.pop();\\n        }\\n\\n        const top = this.heap[0];\\n        this.heap[0] = this.heap.pop();\\n        this.heapifyDown(0);\\n\\n        return top;\\n    }\\n\\n    heapifyUp(index) {\\n        while (index > 0) {\\n            const parent = Math.floor((index - 1) / 2);\\n            if (this.heap[parent][0] < this.heap[index][0]) {\\n                [this.heap[parent], this.heap[index]] = [this.heap[index], this.heap[parent]];\\n                index = parent;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    heapifyDown(index) {\\n        const n = this.heap.length;\\n        while (true) {\\n            let largest = index;\\n            const left = 2 * index + 1;\\n            const right = 2 * index + 2;\\n\\n            if (left < n && this.heap[left][0] > this.heap[largest][0]) {\\n                largest = left;\\n            }\\n            if (right < n && this.heap[right][0] > this.heap[largest][0]) {\\n                largest = right;\\n            }\\n\\n            if (largest !== index) {\\n                [this.heap[index], this.heap[largest]] = [this.heap[largest], this.heap[index]];\\n                index = largest;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    size() {\\n        return this.heap.length;\\n    }\\n}\\n\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    const n = classes.length;\\n\\n    // Helper function to calculate pass ratio increase\\n    const passRatioIncrease = (pass, total) => (pass + 1) / (total + 1) - pass / total;\\n\\n    // Initialize max heap to keep track of classes with maximum improvement\\n    const maxHeap = new MaxHeap();\\n\\n    for (let j = 0; j < n; j++) {\\n        const [pass, total] = classes[j];\\n        if (pass !== total) {\\n            const increase = passRatioIncrease(pass, total);\\n            maxHeap.push([increase, j]);\\n        }\\n    }\\n\\n    let totalPassRatio = 0;\\n\\n    for (let j = 0; j < n; j++) {\\n        totalPassRatio += classes[j][0] / classes[j][1];\\n    }\\n\\n    for (let i = 0; i < extraStudents; i++) {\\n        if (maxHeap.size() === 0) {\\n            break; // No more classes to consider\\n        }\\n\\n        const [increase, maxIndex] = maxHeap.pop();\\n        const [pass, total] = classes[maxIndex];\\n        const newPass = pass + 1;\\n        const newTotal = total + 1;\\n        const newIncrease = passRatioIncrease(newPass, newTotal);\\n        const newAvg = (totalPassRatio - (pass / total)) + (newPass / newTotal);\\n\\n        if (newAvg <= totalPassRatio) {\\n            break; // No further improvement possible\\n        }\\n\\n        totalPassRatio = newAvg;\\n        classes[maxIndex][0]++;\\n        classes[maxIndex][1]++;\\n        maxHeap.push([newIncrease, maxIndex]);\\n    }\\n\\n    return totalPassRatio / n;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917978,
                "title": "heap-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Check what is the fraction that is adding up most at every stage and add each extra student in that class\\n\\n# Approach\\n- With heap\\n\\n# Complexity\\n- Time complexity:\\n- O(NlogN)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = []\\n        for i in range(len(classes)):\\n            ratio_curr = classes[i][0]/(1.0*classes[i][1])\\n            ratio = (classes[i][0]+1)/(1.0*(classes[i][1]+1))\\n            heapq.heappush(heap,(ratio_curr - ratio,i))\\n        while extraStudents != 0:\\n            ele = heapq.heappop(heap)\\n            index = ele[1]\\n            classes[index][0]+=1\\n            classes[index][1]+=1\\n            ratio_curr = classes[index][0]/(1.0*classes[index][1])\\n            ratio = (classes[index][0]+1)/(1.0*(classes[index][1]+1))\\n            heapq.heappush(heap,(ratio_curr-ratio,index))\\n            extraStudents-=1\\n        total = 0\\n        for i in range(len(classes)):\\n            total+=(classes[i][0]/classes[i][1])\\n        return total/len(classes)\\n        # return 2\\n    \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap = []\\n        for i in range(len(classes)):\\n            ratio_curr = classes[i][0]/(1.0*classes[i][1])\\n            ratio = (classes[i][0]+1)/(1.0*(classes[i][1]+1))\\n            heapq.heappush(heap,(ratio_curr - ratio,i))\\n        while extraStudents != 0:\\n            ele = heapq.heappop(heap)\\n            index = ele[1]\\n            classes[index][0]+=1\\n            classes[index][1]+=1\\n            ratio_curr = classes[index][0]/(1.0*classes[index][1])\\n            ratio = (classes[index][0]+1)/(1.0*(classes[index][1]+1))\\n            heapq.heappush(heap,(ratio_curr-ratio,index))\\n            extraStudents-=1\\n        total = 0\\n        for i in range(len(classes)):\\n            total+=(classes[i][0]/classes[i][1])\\n        return total/len(classes)\\n        # return 2\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815914,
                "title": "greedily-pick-class-which-maximizes-increase",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        n = len(classes)\\n        diff = lambda a, b: (a + 1) / (b + 1) - a / b\\n        heap = []\\n        for a, b in classes:\\n            heapq.heappush(heap, (-diff(a, b), a, b))\\n        for _ in range(extraStudents):\\n            currdiff, a, b = heapq.heappop(heap)\\n            heapq.heappush(heap, (-diff(a + 1, b + 1), a + 1, b + 1))\\n        res = 0\\n        for diff, a, b in heap:\\n            res += a / b\\n        res /= n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        n = len(classes)\\n        diff = lambda a, b: (a + 1) / (b + 1) - a / b\\n        heap = []\\n        for a, b in classes:\\n            heapq.heappush(heap, (-diff(a, b), a, b))\\n        for _ in range(extraStudents):\\n            currdiff, a, b = heapq.heappop(heap)\\n            heapq.heappush(heap, (-diff(a + 1, b + 1), a + 1, b + 1))\\n        res = 0\\n        for diff, a, b in heap:\\n            res += a / b\\n        res /= n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799368,
                "title": "c-priority-queue-max-heap-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int e) {\\n        priority_queue<pair<double,pair<double,double>>> pq;\\n        for(auto &i:c)\\n        {\\n            double rat1 = ((double)i[0])/i[1];\\n            double rat2 = ((double)(i[0]+1))/(i[1]+1);\\n            pq.push({rat2-rat1,{(double)i[0],(double)i[1]}});\\n        }\\n        while(e>0)\\n        {\\n            double pass = pq.top().second.first;\\n            double tot = pq.top().second.second;\\n            pq.pop();\\n            pass+=1;\\n            tot+=1;\\n            double rat1 = pass/tot;\\n            double rat2 = (pass+1)/(tot+1);\\n            pq.push({rat2-rat1,{pass,tot}});\\n            e--;\\n        }\\n        double ans = 0;\\n        double siz = c.size();\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top().second.first/pq.top().second.second;\\n            pq.pop();\\n        }\\n        ans/=siz;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& c, int e) {\\n        priority_queue<pair<double,pair<double,double>>> pq;\\n        for(auto &i:c)\\n        {\\n            double rat1 = ((double)i[0])/i[1];\\n            double rat2 = ((double)(i[0]+1))/(i[1]+1);\\n            pq.push({rat2-rat1,{(double)i[0],(double)i[1]}});\\n        }\\n        while(e>0)\\n        {\\n            double pass = pq.top().second.first;\\n            double tot = pq.top().second.second;\\n            pq.pop();\\n            pass+=1;\\n            tot+=1;\\n            double rat1 = pass/tot;\\n            double rat2 = (pass+1)/(tot+1);\\n            pq.push({rat2-rat1,{pass,tot}});\\n            e--;\\n        }\\n        double ans = 0;\\n        double siz = c.size();\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top().second.first/pq.top().second.second;\\n            pq.pop();\\n        }\\n        ans/=siz;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752771,
                "title": "maximum-average-pass-ratio-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int i;\\n        double diff, avg, ans=0;\\n        priority_queue<pair<double, int>> pq;\\n\\n        for(i=0 ; i<classes.size() ; i++)\\n        {\\n            diff = (double)(classes[i][0]+1)/(classes[i][1]+1) - (double)(classes[i][0])/classes[i][1];\\n            pq.push(make_pair(diff, i));\\n        }\\n        while(extraStudents--)\\n        {\\n            i = pq.top().second;\\n            pq.pop();\\n            classes[i][0] += 1;\\n            classes[i][1] += 1;\\n\\n            diff = (double)(classes[i][0]+1)/(classes[i][1]+1) - (double)(classes[i][0])/classes[i][1];\\n            pq.push(make_pair(diff, i));\\n        }\\n\\n        for(i=0 ; i<classes.size() ; i++)\\n        {\\n            avg = (double)(classes[i][0])/classes[i][1];\\n            ans += avg;\\n        }\\n        return ans/classes.size();\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b4c7facb-0a28-4cfc-8aba-ed3417b91ff8_1689135037.8552275.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int i;\\n        double diff, avg, ans=0;\\n        priority_queue<pair<double, int>> pq;\\n\\n        for(i=0 ; i<classes.size() ; i++)\\n        {\\n            diff = (double)(classes[i][0]+1)/(classes[i][1]+1) - (double)(classes[i][0])/classes[i][1];\\n            pq.push(make_pair(diff, i));\\n        }\\n        while(extraStudents--)\\n        {\\n            i = pq.top().second;\\n            pq.pop();\\n            classes[i][0] += 1;\\n            classes[i][1] += 1;\\n\\n            diff = (double)(classes[i][0]+1)/(classes[i][1]+1) - (double)(classes[i][0])/classes[i][1];\\n            pq.push(make_pair(diff, i));\\n        }\\n\\n        for(i=0 ; i<classes.size() ; i++)\\n        {\\n            avg = (double)(classes[i][0])/classes[i][1];\\n            ans += avg;\\n        }\\n        return ans/classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715462,
                "title": "java-priorityqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                double b_groth = (double)(b[0]+1)/(double)(b[1]+1) - (double)b[0]/(double)b[1];\\n                double a_groth = (double)(a[0]+1)/(double)(a[1]+1) - (double)a[0]/(double)a[1];\\n                if(b_groth >= a_groth) {\\n                    return 1;\\n                } else {\\n                    return -1;\\n                }\\n            }\\n        });\\n\\n        for(int[] c : classes) {\\n            pq.add(c);\\n        }\\n\\n        for(int i=0; i<extraStudents; i++) {\\n            int[] cur = pq.poll();\\n            cur[0]+=1;\\n            cur[1]+=1;\\n            pq.add(cur);\\n        }\\n\\n        double ans = 0;\\n        while(pq.size()>0) {\\n            int[] cur = pq.poll();\\n            ans += (double)cur[0]/(double)cur[1];\\n        }\\n\\n        ans /= classes.length;\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                double b_groth = (double)(b[0]+1)/(double)(b[1]+1) - (double)b[0]/(double)b[1];\\n                double a_groth = (double)(a[0]+1)/(double)(a[1]+1) - (double)a[0]/(double)a[1];\\n                if(b_groth >= a_groth) {\\n                    return 1;\\n                } else {\\n                    return -1;\\n                }\\n            }\\n        });\\n\\n        for(int[] c : classes) {\\n            pq.add(c);\\n        }\\n\\n        for(int i=0; i<extraStudents; i++) {\\n            int[] cur = pq.poll();\\n            cur[0]+=1;\\n            cur[1]+=1;\\n            pq.add(cur);\\n        }\\n\\n        double ans = 0;\\n        while(pq.size()>0) {\\n            int[] cur = pq.poll();\\n            ans += (double)cur[0]/(double)cur[1];\\n        }\\n\\n        ans /= classes.length;\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564800,
                "title": "python",
                "content": "Things become a lot easier after looking at hints\\n# Code\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], s: int) -> float:\\n        n = len(classes)\\n        h = []\\n        heapq.heapify(h)\\n\\n        for i in range(n):\\n            change = ((classes[i][0]+1)/(classes[i][1]+1)) - (classes[i][0]/classes[i][1])\\n            heapq.heappush(h, (-change, i))\\n        \\n        while s> 0:\\n            a, idx = heapq.heappop(h)\\n            classes[idx][0] += 1\\n            classes[idx][1] += 1\\n            s -= 1\\n            change = ((classes[idx][0]+1)/(classes[idx][1]+1)) - (classes[idx][0]/classes[idx][1])\\n            heapq.heappush(h, (-change, idx))\\n        \\n        res = 0\\n        for i in range(n):\\n            res += classes[i][0]/classes[i][1]\\n        \\n        return res/n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], s: int) -> float:\\n        n = len(classes)\\n        h = []\\n        heapq.heapify(h)\\n\\n        for i in range(n):\\n            change = ((classes[i][0]+1)/(classes[i][1]+1)) - (classes[i][0]/classes[i][1])\\n            heapq.heappush(h, (-change, i))\\n        \\n        while s> 0:\\n            a, idx = heapq.heappop(h)\\n            classes[idx][0] += 1\\n            classes[idx][1] += 1\\n            s -= 1\\n            change = ((classes[idx][0]+1)/(classes[idx][1]+1)) - (classes[idx][0]/classes[idx][1])\\n            heapq.heappush(h, (-change, idx))\\n        \\n        res = 0\\n        for i in range(n):\\n            res += classes[i][0]/classes[i][1]\\n        \\n        return res/n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443122,
                "title": "python-max-heap-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nWe can focus on how much difference there is in the pass ratio of a class before and after using a extraStudent.\\nSo we can use a max heap to record the class which has max difference, and use a extraStudent on it.\\ntc is O(extraStudents * log(len(classes))), sc is O(len(classes))\\n\\'\\'\\'\\nfrom heapq import heapreplace, heapify \\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        maxHeap = [[p/t - (1+p)/(1+t), idx] for idx, (p, t) in enumerate(classes) if p != t]\\n        if len(maxHeap) == 0: return 1.\\n        heapify(maxHeap)\\n        topOfHeap = lambda: maxHeap[0][1]\\n        while extraStudents > 0:\\n            idx = topOfHeap()\\n            classes[idx][0] += 1\\n            classes[idx][1] += 1\\n            heapreplace(maxHeap, [classes[idx][0]/classes[idx][1] - (classes[idx][0]+1)/(classes[idx][1]+1), idx])\\n            extraStudents -= 1\\n        return sum(p/t for p, t in classes) / len(classes)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n\\'\\'\\'\\nWe can focus on how much difference there is in the pass ratio of a class before and after using a extraStudent.\\nSo we can use a max heap to record the class which has max difference, and use a extraStudent on it.\\ntc is O(extraStudents * log(len(classes))), sc is O(len(classes))\\n\\'\\'\\'\\nfrom heapq import heapreplace, heapify \\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        maxHeap = [[p/t - (1+p)/(1+t), idx] for idx, (p, t) in enumerate(classes) if p != t]\\n        if len(maxHeap) == 0: return 1.\\n        heapify(maxHeap)\\n        topOfHeap = lambda: maxHeap[0][1]\\n        while extraStudents > 0:\\n            idx = topOfHeap()\\n            classes[idx][0] += 1\\n            classes[idx][1] += 1\\n            heapreplace(maxHeap, [classes[idx][0]/classes[idx][1] - (classes[idx][0]+1)/(classes[idx][1]+1), idx])\\n            extraStudents -= 1\\n        return sum(p/t for p, t in classes) / len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426878,
                "title": "c-using-priority-queue-easy-understanding",
                "content": "# Intuition\\n- Initial ratio for one class=x/y\\n- After adding 1 child=(x+1)/(y+1)\\n- Change in ratio by adding one child=(y-x)/(y*(y+1))\\n- Keep removing and adding this ratio from priority queue for all the extra students\\n\\n# Approach\\nAssign ExtraStudent in such class that we\"ll get maximum possible ratio . so How we\"ll do this . We have to send ExtraStudents to classes 1 by 1 according to their ratio(calculate the difference of all classes for 1 student) where we get more difference we\"ll send the student to that particular class. and again check the difference for the next student .\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double,pair<int,int>>>pq;\\n        for(int i=0;i<classes.size();i++){\\n             int var1 = classes[i][0] , var2 = classes[i][1];\\n            double diff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n              pq.push({diff,{var1,var2}});\\n        }\\n        \\n        while(extraStudents!=0){\\n            int var1 = pq.top().second.first , var2 = pq.top().second.second;\\n            var1++;\\n            var2++;\\n            double newdiff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n            pq.pop();\\n             pq.push({newdiff,{var1,var2}});\\n            extraStudents--;\\n            \\n        }\\n        double ans = 0;\\n        while(!pq.empty()){\\n            ans += (double)(pq.top().second.first) /(pq.top().second.second);\\n            pq.pop();\\n        }\\n         \\n        return ans/classes.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double,pair<int,int>>>pq;\\n        for(int i=0;i<classes.size();i++){\\n             int var1 = classes[i][0] , var2 = classes[i][1];\\n            double diff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n              pq.push({diff,{var1,var2}});\\n        }\\n        \\n        while(extraStudents!=0){\\n            int var1 = pq.top().second.first , var2 = pq.top().second.second;\\n            var1++;\\n            var2++;\\n            double newdiff = (double)(var1+1)/(var2+1) - (double)(var1)/(var2);\\n            pq.pop();\\n             pq.push({newdiff,{var1,var2}});\\n            extraStudents--;\\n            \\n        }\\n        double ans = 0;\\n        while(!pq.empty()){\\n            ans += (double)(pq.top().second.first) /(pq.top().second.second);\\n            pq.pop();\\n        }\\n         \\n        return ans/classes.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410519,
                "title": "java-n-logn-priorityqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> pq = new PriorityQueue<>((double[] v1, double[] v2) -> Double.compare(v2[2], v1[2]));\\n        for (int[] c : classes) {\\n            pq.add(new double[]{c[0],c[1], ((double)(c[0]+1)/(c[1]+1) - (double)c[0]/c[1])});\\n        }\\n        \\n        for (int i = 0; i < extraStudents; i++) {\\n            double[] next = pq.poll();\\n            next[0]++;\\n            next[1]++;\\n            next[2] = ((double)(next[0]+1)/(next[1]+1) - (double)next[0]/next[1]);\\n            pq.add(next);\\n        }\\n\\n        double res = 0;\\n        while ( ! pq.isEmpty()) {\\n            res += (double)pq.peek()[0]/pq.poll()[1];\\n        }\\n\\n        return res/classes.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]> pq = new PriorityQueue<>((double[] v1, double[] v2) -> Double.compare(v2[2], v1[2]));\\n        for (int[] c : classes) {\\n            pq.add(new double[]{c[0],c[1], ((double)(c[0]+1)/(c[1]+1) - (double)c[0]/c[1])});\\n        }\\n        \\n        for (int i = 0; i < extraStudents; i++) {\\n            double[] next = pq.poll();\\n            next[0]++;\\n            next[1]++;\\n            next[2] = ((double)(next[0]+1)/(next[1]+1) - (double)next[0]/next[1]);\\n            pq.add(next);\\n        }\\n\\n        double res = 0;\\n        while ( ! pq.isEmpty()) {\\n            res += (double)pq.peek()[0]/pq.poll()[1];\\n        }\\n\\n        return res/classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376809,
                "title": "simple-c-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& nums, int k) {\\n        double sum = 0;\\n        double n = nums.size();\\n\\n        priority_queue<pair<double,pair<double,double>>> q;\\n\\n        vector<vector<double>> arr(n);\\n        for(int i=0 ; i<n ; i++){\\n            vector<double> temp(2);\\n            temp[0] = nums[i][0];\\n            temp[1] = nums[i][1];\\n            arr[i] = temp;\\n        }\\n\\n        \\n\\n        for(int i=0 ; i<n ; i++){\\n            q.push({((arr[i][0]+1)/(arr[i][1]+1))- (arr[i][0]/arr[i][1]), \\n            {arr[i][0] , arr[i][1]}});\\n        }\\n\\n        while(k--){\\n           double x = q.top().second.first;\\n           double y = q.top().second.second;\\n           q.pop();\\n           x = x+1;\\n           y = y+1;\\n           q.push({((x+1)/(y+1))-(x/y) , {x , y}});\\n        }\\n\\n\\n        while(!q.empty()){\\n            double x = q.top().second.first;\\n            double y = q.top().second.second;\\n            sum += x/y;\\n            q.pop();\\n        }\\n\\n       \\n        return sum/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& nums, int k) {\\n        double sum = 0;\\n        double n = nums.size();\\n\\n        priority_queue<pair<double,pair<double,double>>> q;\\n\\n        vector<vector<double>> arr(n);\\n        for(int i=0 ; i<n ; i++){\\n            vector<double> temp(2);\\n            temp[0] = nums[i][0];\\n            temp[1] = nums[i][1];\\n            arr[i] = temp;\\n        }\\n\\n        \\n\\n        for(int i=0 ; i<n ; i++){\\n            q.push({((arr[i][0]+1)/(arr[i][1]+1))- (arr[i][0]/arr[i][1]), \\n            {arr[i][0] , arr[i][1]}});\\n        }\\n\\n        while(k--){\\n           double x = q.top().second.first;\\n           double y = q.top().second.second;\\n           q.pop();\\n           x = x+1;\\n           y = y+1;\\n           q.push({((x+1)/(y+1))-(x/y) , {x , y}});\\n        }\\n\\n\\n        while(!q.empty()){\\n            double x = q.top().second.first;\\n            double y = q.top().second.second;\\n            sum += x/y;\\n            q.pop();\\n        }\\n\\n       \\n        return sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213446,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_average_ratio(classes: Vec<Vec<i32>>, extra_students: i32) -> f64 {\\n        fn profit(pass: i32, total: i32) -> f64 {\\n            (pass + 1) as f64 / (total + 1) as f64 - pass as f64 / total as f64\\n        }\\n\\n        let mut total = 0.0;\\n        let mut pq = std::collections::BinaryHeap::new();\\n        for c in classes.iter() {\\n            total += c[0] as f64 / c[1] as f64;\\n            let v = profit(c[0], c[1]);\\n            pq.push((OrderedF64(v), c.clone()));\\n        }\\n        for _ in 0..extra_students {\\n            let (added_profit, c) = pq.pop().unwrap();\\n            total += added_profit.0;\\n            let v = profit(c[0] + 1, c[1] + 1);\\n            pq.push((OrderedF64(v), vec![c[0] + 1, c[1] + 1]));\\n        }\\n        total / classes.len() as f64\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\nstruct OrderedF64(f64);\\n\\nimpl PartialEq for OrderedF64 {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.0 == other.0\\n    }\\n}\\n\\nimpl PartialOrd for OrderedF64 {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.0.partial_cmp(&other.0)\\n    }\\n}\\n\\nimpl Eq for OrderedF64 {}\\n\\nimpl Ord for OrderedF64 {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.partial_cmp(other).unwrap_or(std::cmp::Ordering::Equal)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_average_ratio(classes: Vec<Vec<i32>>, extra_students: i32) -> f64 {\\n        fn profit(pass: i32, total: i32) -> f64 {\\n            (pass + 1) as f64 / (total + 1) as f64 - pass as f64 / total as f64\\n        }\\n\\n        let mut total = 0.0;\\n        let mut pq = std::collections::BinaryHeap::new();\\n        for c in classes.iter() {\\n            total += c[0] as f64 / c[1] as f64;\\n            let v = profit(c[0], c[1]);\\n            pq.push((OrderedF64(v), c.clone()));\\n        }\\n        for _ in 0..extra_students {\\n            let (added_profit, c) = pq.pop().unwrap();\\n            total += added_profit.0;\\n            let v = profit(c[0] + 1, c[1] + 1);\\n            pq.push((OrderedF64(v), vec![c[0] + 1, c[1] + 1]));\\n        }\\n        total / classes.len() as f64\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\nstruct OrderedF64(f64);\\n\\nimpl PartialEq for OrderedF64 {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.0 == other.0\\n    }\\n}\\n\\nimpl PartialOrd for OrderedF64 {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.0.partial_cmp(&other.0)\\n    }\\n}\\n\\nimpl Eq for OrderedF64 {}\\n\\nimpl Ord for OrderedF64 {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.partial_cmp(other).unwrap_or(std::cmp::Ordering::Equal)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194702,
                "title": "greedy-algorithm-with-java-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a greedy algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn each step pick the one calss that adding the extra student creates the bigger difference. I used a PriorityQueue to select the largest difference at each step. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n       \\n        PriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Double.compare(\\n                    (o2[0] + 1 )/ ((double) o2[1] + 1) - ((o2[0] )/ ((double) o2[1])),\\n                    (o1[0] + 1 )/ ((double) o1[1] + 1) - ((o1[0] )/ ((double) o1[1])));\\n            }\\n        });\\n\\n        for (int[] aClass : classes) {\\n            q.add(aClass);\\n        }\\n        for (int i =0;i<extraStudents;i++) {\\n            int[] min = q.poll();\\n            min[0]++;\\n            min[1]++;\\n            q.add(min);\\n\\n        }\\n        return q.stream().mapToDouble(ints -> ints[0]/(double)ints[1]).average().getAsDouble();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n       \\n        PriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Double.compare(\\n                    (o2[0] + 1 )/ ((double) o2[1] + 1) - ((o2[0] )/ ((double) o2[1])),\\n                    (o1[0] + 1 )/ ((double) o1[1] + 1) - ((o1[0] )/ ((double) o1[1])));\\n            }\\n        });\\n\\n        for (int[] aClass : classes) {\\n            q.add(aClass);\\n        }\\n        for (int i =0;i<extraStudents;i++) {\\n            int[] min = q.poll();\\n            min[0]++;\\n            min[1]++;\\n            q.add(min);\\n\\n        }\\n        return q.stream().mapToDouble(ints -> ints[0]/(double)ints[1]).average().getAsDouble();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189293,
                "title": "1981-ms",
                "content": "```ruby\\ndef max_average_ratio a, e\\n    t, s, m = CRBTreeMap.new, (1 << 30), ((1 << 17) - 1)\\n    a.each_with_index do\\n        x, y = *_1.map!(&:to_f)\\n        t[k = \\n          ((((x + 1.0) / (y + 1.0) - x / y) * s).to_i << 17) |\\n          _2] = k\\n    end\\n    e.times do\\n        i = t.delete_max & m\\n        x, y = *a[i].map! { _1 + 1.0 }\\n        t[k = \\n          ((((x + 1.0) / (y + 1.0) - x / y) * s).to_i << 17) |\\n          i] = k\\n    end\\n    a.sum { _1.first / _1.last } / a.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef max_average_ratio a, e\\n    t, s, m = CRBTreeMap.new, (1 << 30), ((1 << 17) - 1)\\n    a.each_with_index do\\n        x, y = *_1.map!(&:to_f)\\n        t[k = \\n          ((((x + 1.0) / (y + 1.0) - x / y) * s).to_i << 17) |\\n          _2] = k\\n    end\\n    e.times do\\n        i = t.delete_max & m\\n        x, y = *a[i].map! { _1 + 1.0 }\\n        t[k = \\n          ((((x + 1.0) / (y + 1.0) - x / y) * s).to_i << 17) |\\n          i] = k\\n    end\\n    a.sum { _1.first / _1.last } / a.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3145414,
                "title": "c",
                "content": "```\\nusing AD3 = array<double, 3> ; // diff, passi, totali\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int n = classes.size() ;\\n        priority_queue<AD3, vector<AD3>, less<>> pq ;\\n        for(auto c : classes){\\n            double p = c[0] ;\\n            double t = c[1] ;\\n            pq.push({(p+1)/(t+1) - p/t, p, t}) ;\\n        }\\n        for(int i = 0 ; i < extraStudents; i++){\\n            auto[dr, p, t] = pq.top() ;\\n            pq.pop() ;\\n            p += 1 ;\\n            t += 1 ;\\n            pq.push({(p+1)/(t+1) - p/t, p, t}) ;\\n        }\\n        \\n        double sum  = 0 ;\\n        while(!pq.empty())\\n        {\\n            auto[dr, p, t] = pq.top() ;\\n            pq.pop() ;\\n            sum += p/t ;\\n        }\\n        \\n        return sum / n ;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing AD3 = array<double, 3> ; // diff, passi, totali\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        int n = classes.size() ;\\n        priority_queue<AD3, vector<AD3>, less<>> pq ;\\n        for(auto c : classes){\\n            double p = c[0] ;\\n            double t = c[1] ;\\n            pq.push({(p+1)/(t+1) - p/t, p, t}) ;\\n        }\\n        for(int i = 0 ; i < extraStudents; i++){\\n            auto[dr, p, t] = pq.top() ;\\n            pq.pop() ;\\n            p += 1 ;\\n            t += 1 ;\\n            pq.push({(p+1)/(t+1) - p/t, p, t}) ;\\n        }\\n        \\n        double sum  = 0 ;\\n        while(!pq.empty())\\n        {\\n            auto[dr, p, t] = pq.top() ;\\n            pq.pop() ;\\n            sum += p/t ;\\n        }\\n        \\n        return sum / n ;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129633,
                "title": "c-priority-queue-readable",
                "content": "```\\npublic class Solution {\\n    \\n    public class Course {\\n        public double studentsThatPassed; \\n        public double totalStudents; \\n        public double passRatio; \\n        \\n        public Course(int pass, int total) {\\n            studentsThatPassed = pass; \\n            totalStudents = total;\\n            CalculatePassRatio(); \\n        }\\n        \\n        public void CalculatePassRatio() {\\n            passRatio = studentsThatPassed/totalStudents;\\n        }\\n        \\n        public Double CheckUpdatedRatio() {\\n            return (studentsThatPassed+1)/(totalStudents+1); \\n        }\\n    }\\n    \\n    public class CustomComparer : IComparer<Course> {\\n        public int Compare(Course first, Course second) {\\n            var diffFirst = first.CheckUpdatedRatio() - first.passRatio; \\n            var diffSecond = second.CheckUpdatedRatio() - second.passRatio;\\n            if (diffFirst > diffSecond) {\\n                return -1; \\n            } else if (diffFirst < diffSecond) {\\n                return 1; \\n            } else {\\n                // just return the one with the lowest overall ratio if tie\\n                return first.passRatio.CompareTo(second.passRatio); \\n            }\\n        }\\n    }\\n    \\n    public double MaxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        // O(nlogn) for custom comparer, sort all courses\\n        var pq = new PriorityQueue<Course, Course>(new CustomComparer()); \\n        \\n        // O(nlogn)\\n        for (var i = 0; i < classes.Length; i++) {\\n            var course = new Course(classes[i][0], classes[i][1]); \\n            pq.Enqueue(course, course); \\n        }\\n        \\n        // O(elogn) where is is number of extra students \\n        while (extraStudents > 0) {\\n            var classWithWorstRatio = pq.Dequeue();\\n            classWithWorstRatio.studentsThatPassed++; \\n            classWithWorstRatio.totalStudents++; \\n            classWithWorstRatio.CalculatePassRatio(); \\n            extraStudents--; \\n            pq.Enqueue(classWithWorstRatio, classWithWorstRatio); \\n        }\\n        \\n        var totalPassRatioSum = 0.0;\\n        var totalCourses = 0; \\n        \\n        // O(nlogn)\\n        while (pq.Count > 0) {\\n            totalCourses += 1; \\n            totalPassRatioSum += pq.Dequeue().passRatio;\\n        }\\n        \\n        // Time Complexity ~ O(nlogn) or O(elogn)\\n        // Space Complexity is O(n) where c is number of classes, the PQ\\n        return totalPassRatioSum / totalCourses; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public class Course {\\n        public double studentsThatPassed; \\n        public double totalStudents; \\n        public double passRatio; \\n        \\n        public Course(int pass, int total) {\\n            studentsThatPassed = pass; \\n            totalStudents = total;\\n            CalculatePassRatio(); \\n        }\\n        \\n        public void CalculatePassRatio() {\\n            passRatio = studentsThatPassed/totalStudents;\\n        }\\n        \\n        public Double CheckUpdatedRatio() {\\n            return (studentsThatPassed+1)/(totalStudents+1); \\n        }\\n    }\\n    \\n    public class CustomComparer : IComparer<Course> {\\n        public int Compare(Course first, Course second) {\\n            var diffFirst = first.CheckUpdatedRatio() - first.passRatio; \\n            var diffSecond = second.CheckUpdatedRatio() - second.passRatio;\\n            if (diffFirst > diffSecond) {\\n                return -1; \\n            } else if (diffFirst < diffSecond) {\\n                return 1; \\n            } else {\\n                // just return the one with the lowest overall ratio if tie\\n                return first.passRatio.CompareTo(second.passRatio); \\n            }\\n        }\\n    }\\n    \\n    public double MaxAverageRatio(int[][] classes, int extraStudents) {\\n        \\n        // O(nlogn) for custom comparer, sort all courses\\n        var pq = new PriorityQueue<Course, Course>(new CustomComparer()); \\n        \\n        // O(nlogn)\\n        for (var i = 0; i < classes.Length; i++) {\\n            var course = new Course(classes[i][0], classes[i][1]); \\n            pq.Enqueue(course, course); \\n        }\\n        \\n        // O(elogn) where is is number of extra students \\n        while (extraStudents > 0) {\\n            var classWithWorstRatio = pq.Dequeue();\\n            classWithWorstRatio.studentsThatPassed++; \\n            classWithWorstRatio.totalStudents++; \\n            classWithWorstRatio.CalculatePassRatio(); \\n            extraStudents--; \\n            pq.Enqueue(classWithWorstRatio, classWithWorstRatio); \\n        }\\n        \\n        var totalPassRatioSum = 0.0;\\n        var totalCourses = 0; \\n        \\n        // O(nlogn)\\n        while (pq.Count > 0) {\\n            totalCourses += 1; \\n            totalPassRatioSum += pq.Dequeue().passRatio;\\n        }\\n        \\n        // Time Complexity ~ O(nlogn) or O(elogn)\\n        // Space Complexity is O(n) where c is number of classes, the PQ\\n        return totalPassRatioSum / totalCourses; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111152,
                "title": "priority-queue-using-the-logic-provided-in-discussion-section",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int k) {\\n        priority_queue<pair<double,int>> pq;\\n        for(int i=0;i<classes.size();i++){\\n            double res = (double(classes[i][0]+1)/double(classes[i][1]+1) - double(classes[i][0])/double(classes[i][1]));\\n            cout<<res<<endl;\\n            pq.push({res,i});\\n        }\\n        while(k--){\\n            auto tp = pq.top();\\n            int i = tp.second;\\n            pq.pop();\\n            \\n            double res = (double(classes[i][0]+2)/double(classes[i][1]+2) - double(classes[i][0]+1)/double(classes[i][1]+1));\\n            classes[i][0]++;\\n            classes[i][1]++;\\n            pq.push({res,i});\\n        }\\n        double ans;\\n        for(int i=0;i<classes.size();i++){\\n            ans += double(classes[i][0])/double(classes[i][1]);\\n        }\\n        return ans/double(classes.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int k) {\\n        priority_queue<pair<double,int>> pq;\\n        for(int i=0;i<classes.size();i++){\\n            double res = (double(classes[i][0]+1)/double(classes[i][1]+1) - double(classes[i][0])/double(classes[i][1]));\\n            cout<<res<<endl;\\n            pq.push({res,i});\\n        }\\n        while(k--){\\n            auto tp = pq.top();\\n            int i = tp.second;\\n            pq.pop();\\n            \\n            double res = (double(classes[i][0]+2)/double(classes[i][1]+2) - double(classes[i][0]+1)/double(classes[i][1]+1));\\n            classes[i][0]++;\\n            classes[i][1]++;\\n            pq.push({res,i});\\n        }\\n        double ans;\\n        for(int i=0;i<classes.size();i++){\\n            ans += double(classes[i][0])/double(classes[i][1]);\\n        }\\n        return ans/double(classes.size());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3107466,
                "title": "python-min-heap-solution",
                "content": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        arr = []\\n        res = 0\\n        for x,y in classes:\\n            heapq.heappush(arr,[((x+1)/(y+1) - x/y) * -1,x,y])\\n            res += (x/y)\\n            \\n        while extraStudents > 0:\\n            t,x,y = heapq.heappop(arr)\\n            t *= -1\\n            res += t\\n            heapq.heappush(arr,[((x+2)/(y+2) - (x+1)/(y+1)) * -1,x+1,y+1])\\n            extraStudents -= 1\\n        \\n        return res/len(classes)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        arr = []\\n        res = 0\\n        for x,y in classes:\\n            heapq.heappush(arr,[((x+1)/(y+1) - x/y) * -1,x,y])\\n            res += (x/y)\\n            \\n        while extraStudents > 0:\\n            t,x,y = heapq.heappop(arr)\\n            t *= -1\\n            res += t\\n            heapq.heappush(arr,[((x+2)/(y+2) - (x+1)/(y+1)) * -1,x+1,y+1])\\n            extraStudents -= 1\\n        \\n        return res/len(classes)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093933,
                "title": "max-heap-easy-c-solution",
                "content": "# Intuition\\nWe always are thinking of getting the number with the most increase in value when one is added in both denominator and numerator\\n\\n# Approach\\nUsing Max Heap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nclass cmp\\n{\\n    public:\\n    bool operator()(pair<int,int> a , pair<int,int> b)\\n    {\\n        return ( (double)(a.first+1.0) / (double)(a.second +1.0))  - ( (double)a.first / (double)a.second )  < ( (double)(b.first+1.0) / (double)(b.second +1.0))  - ( (double)b.first / (double)b.second ) ;\\n    }\\n};\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>> , cmp> pq;\\n        for(auto i   : classes)\\n        {\\n            pq.push({i[0],i[1]});\\n        }\\n        while(!pq.empty() && extraStudents--)\\n        {\\n            pair<int,int> a = pq.top();\\n            pq.pop();\\n            a.first += 1;\\n            a.second += 1;\\n\\n            pq.push({a.first , a.second});\\n        }\\n\\n        double ans =   0.0;\\n        while(!pq.empty())\\n        {\\n            pair<int,int> a  = pq.top();\\n            pq.pop();\\n            ans +=  (double)a.first / (double)a.second;\\n        }\\n        ans = ans / classes.size();\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nclass cmp\\n{\\n    public:\\n    bool operator()(pair<int,int> a , pair<int,int> b)\\n    {\\n        return ( (double)(a.first+1.0) / (double)(a.second +1.0))  - ( (double)a.first / (double)a.second )  < ( (double)(b.first+1.0) / (double)(b.second +1.0))  - ( (double)b.first / (double)b.second ) ;\\n    }\\n};\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>> , cmp> pq;\\n        for(auto i   : classes)\\n        {\\n            pq.push({i[0],i[1]});\\n        }\\n        while(!pq.empty() && extraStudents--)\\n        {\\n            pair<int,int> a = pq.top();\\n            pq.pop();\\n            a.first += 1;\\n            a.second += 1;\\n\\n            pq.push({a.first , a.second});\\n        }\\n\\n        double ans =   0.0;\\n        while(!pq.empty())\\n        {\\n            pair<int,int> a  = pq.top();\\n            pq.pop();\\n            ans +=  (double)a.first / (double)a.second;\\n        }\\n        ans = ans / classes.size();\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950342,
                "title": "python-maxheap-for-delta-increase-o-klogn",
                "content": "# Code\\n```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], k: int) -> float:\\n        n = len(classes)\\n        h = [(-(p+1)/(t+1)+p/t, p, t) for p, t in classes]\\n        heapify(h)\\n        while k > 0:\\n            _, p, t = heappop(h)\\n            p += 1\\n            t += 1\\n            heappush(h, (-(p + 1)/(t+1) + p/t, p, t))\\n            k -= 1\\n        return sum([p/t for _, p, t in h])/n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], k: int) -> float:\\n        n = len(classes)\\n        h = [(-(p+1)/(t+1)+p/t, p, t) for p, t in classes]\\n        heapify(h)\\n        while k > 0:\\n            _, p, t = heappop(h)\\n            p += 1\\n            t += 1\\n            heappush(h, (-(p + 1)/(t+1) + p/t, p, t))\\n            k -= 1\\n        return sum([p/t for _, p, t in h])/n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779723,
                "title": "python-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe idea is to use max heap to store the difference of minus values, if the diff is higher, it means need to add extra value to it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmax heap\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        max_heap = []\\n        for student, total in classes:\\n            heappush(max_heap, (student / total - (student + 1) / (total + 1), student, total))\\n        for i in range(extraStudents):\\n            r, s, t = heappop(max_heap)\\n            heappush(max_heap, ((s + 1) / (t + 1) - (s + 2) / (t + 2), s + 1, t + 1))\\n        return sum(i[1] / i[2] for i in max_heap) / len(max_heap)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        max_heap = []\\n        for student, total in classes:\\n            heappush(max_heap, (student / total - (student + 1) / (total + 1), student, total))\\n        for i in range(extraStudents):\\n            r, s, t = heappop(max_heap)\\n            heappush(max_heap, ((s + 1) / (t + 1) - (s + 2) / (t + 2), s + 1, t + 1))\\n        return sum(i[1] / i[2] for i in max_heap) / len(max_heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746135,
                "title": "java-greedy",
                "content": "\\tclass Solution {\\n    public class pair{\\n        double ratio; int num, den;\\n        \\n        pair(double r, int n, int d){\\n            this.ratio=r;\\n            this.num=n;\\n            this.den=d;\\n        }\\n    }\\n    public double maxAverageRatio(int[][] classes, int es) {\\n        PriorityQueue<pair>pq=new PriorityQueue<>(\\n            (a, b)->{\\n                //between two pairs, in which will there be more progress in ratio?\\n                double newratioa=(a.num+1)*1.0/(a.den+1);\\n                double newratiob=(b.num+1)*1.0/(b.den+1);\\n                double diffa=newratioa-a.ratio;\\n                double diffb=newratiob-b.ratio;\\n                \\n                if(diffa>diffb) return -1;\\n                else return 1;\\n        });\\n        \\n        for(int i[]: classes)\\n        {\\n            double ratio=i[0]*1.0/(i[1]);\\n            pair curr=new pair(ratio, i[0], i[1]);\\n            pq.add(curr);\\n        }\\n        \\n        while(es>0)\\n        {\\n            es--;\\n            pair kid=pq.remove();\\n            //System.out.println(kid.num+\" \"+kid.den);\\n            int num=kid.num+1; int den=kid.den+1;\\n            double ratio=num*1.0/den;\\n            \\n            pq.add(new pair(ratio, num, den));\\n            //System.out.println(ratio+\" \"+num+\" \"+den);\\n        }\\n        \\n        double res=0;int n=pq.size();\\n        \\n        while(pq.size()>0)\\n        {\\n            res+=pq.remove().ratio;\\n        }\\n        return res/n;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public class pair{\\n        double ratio; int num, den;\\n        \\n        pair(double r, int n, int d){\\n            this.ratio=r;\\n            this.num=n;\\n            this.den=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2736233,
                "title": "python-simple-solution-explained-with-comments",
                "content": "The immediate intuition we get after looking at this problem is to keep adding an extra student in class which has least pass ratio.\\nHowever, as we keep adding extra students to the same class, the rate of increase keeps inflating. To handle this, instead of adding student to class with least pass ratio, we add the student to the class which has highest change in ratio after adding the student. \\n\\nWe do this using a max heap to store the change in ratio and retrieve the class with highest change.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        ratios = []\\n        heapq.heapify(ratios) # taking a priority queue\\n        final_av_sum = 0 # store final sum of averages\\n        for clas in classes:\\n            temp = clas[0] / clas[1] # current ratio\\n            rat_change = ( (clas[0]+1) / (clas[1]+1) ) - temp # calculate change in ratio if we add extra student\\n            heapq.heappush(ratios, [ (rat_change*-1), temp,clas[0],clas[1]]) # push into max heap\\n            final_av_sum += temp # update sum of averages\\n\\n        \\n        while extraStudents > 0:\\n            \\n            least = heapq.heappop(ratios) # retrieves highest increase in ratio from max heap\\n            \\n            final_av_sum -= least[1]\\n            least[1] += (least[0]*-1) # current ratio\\n            least[2] += 1 # adding extra student to passed students\\n            least[3] += 1 # adding extra student to total class size\\n            least[0] =  ( (least[2]+1) / (least[3]+1) - least[1] ) * -1 # update next increase in ratio if we add one more\\n            final_av_sum += least[1] # update sum of averages\\n            \\n            heapq.heappush(ratios,least)\\n            extraStudents -= 1\\n        return final_av_sum/len(classes) # return final average of pass ratio\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        \\n        ratios = []\\n        heapq.heapify(ratios) # taking a priority queue\\n        final_av_sum = 0 # store final sum of averages\\n        for clas in classes:\\n            temp = clas[0] / clas[1] # current ratio\\n            rat_change = ( (clas[0]+1) / (clas[1]+1) ) - temp # calculate change in ratio if we add extra student\\n            heapq.heappush(ratios, [ (rat_change*-1), temp,clas[0],clas[1]]) # push into max heap\\n            final_av_sum += temp # update sum of averages\\n\\n        \\n        while extraStudents > 0:\\n            \\n            least = heapq.heappop(ratios) # retrieves highest increase in ratio from max heap\\n            \\n            final_av_sum -= least[1]\\n            least[1] += (least[0]*-1) # current ratio\\n            least[2] += 1 # adding extra student to passed students\\n            least[3] += 1 # adding extra student to total class size\\n            least[0] =  ( (least[2]+1) / (least[3]+1) - least[1] ) * -1 # update next increase in ratio if we add one more\\n            final_av_sum += least[1] # update sum of averages\\n            \\n            heapq.heappush(ratios,least)\\n            extraStudents -= 1\\n        return final_av_sum/len(classes) # return final average of pass ratio\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725961,
                "title": "python-greedy-solution-using-max-heap-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        profit = lambda passedStudents, totalStudents: (passedStudents + 1) / (totalStudents + 1) - passedStudents / totalStudents\\n        total, maxHeap = sum(c[0] / c[1] for c in classes), []\\n        for passedStudents, totalStudents in classes:\\n            heappush(maxHeap, [-profit(passedStudents, totalStudents), passedStudents, totalStudents])\\n        while extraStudents:\\n            addedProfit, passedStudents, totalStudents = heappop(maxHeap)\\n            total += (-addedProfit)\\n            heappush(maxHeap, [-profit(passedStudents + 1, totalStudents + 1), passedStudents + 1, totalStudents + 1])\\n            extraStudents -= 1\\n        return total / len(classes)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        profit = lambda passedStudents, totalStudents: (passedStudents + 1) / (totalStudents + 1) - passedStudents / totalStudents\\n        total, maxHeap = sum(c[0] / c[1] for c in classes), []\\n        for passedStudents, totalStudents in classes:\\n            heappush(maxHeap, [-profit(passedStudents, totalStudents), passedStudents, totalStudents])\\n        while extraStudents:\\n            addedProfit, passedStudents, totalStudents = heappop(maxHeap)\\n            total += (-addedProfit)\\n            heappush(maxHeap, [-profit(passedStudents + 1, totalStudents + 1), passedStudents + 1, totalStudents + 1])\\n            extraStudents -= 1\\n        return total / len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712566,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maxAverageRatio(self, classes: List[List[int]], extra: int) -> float:\\n\\t\\t\\tarr = sorted([[(x+1)/(y+1) - x/y, x, y] for x,y in classes])\\n\\t\\t\\twhile extra:\\n\\t\\t\\t\\ttemp = arr.pop()\\n\\t\\t\\t\\ttemp[1] += 1\\n\\t\\t\\t\\ttemp[2] += 1\\n\\t\\t\\t\\tcur = temp[1]/temp[2]\\n\\t\\t\\t\\ttemp[0] = (temp[1]+1)/(temp[2]+1) - cur\\n\\t\\t\\t\\tbisect.insort(arr,temp)\\n\\t\\t\\t\\textra-=1\\n\\t\\t\\treturn sum([x[1]/x[2] for x in arr])/len(arr)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxAverageRatio(self, classes: List[List[int]], extra: int) -> float:\\n\\t\\t\\tarr = sorted([[(x+1)/(y+1) - x/y, x, y] for x,y in classes])\\n\\t\\t\\twhile extra:\\n\\t\\t\\t\\ttemp = arr.pop()\\n\\t\\t\\t\\ttemp[1] += 1\\n\\t\\t\\t\\ttemp[2] += 1\\n\\t\\t\\t\\tcur = temp[1]/temp[2]\\n\\t\\t\\t\\ttemp[0] = (temp[1]+1)/(temp[2]+1) - cur\\n\\t\\t\\t\\tbisect.insort(arr,temp)\\n\\t\\t\\t\\textra-=1\\n\\t\\t\\treturn sum([x[1]/x[2] for x in arr])/len(arr)",
                "codeTag": "Java"
            },
            {
                "id": 2684185,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Max Heap***\\n\\n* ***Time Complexity :- O(Extra_Students * logN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& arr, int extraStudents) {\\n        \\n        int n = arr.size();\\n        \\n        // declare a max heap which will store the change in pass ratio after adding student\\n        \\n        priority_queue<pair<double, int>> pq;\\n        \\n        // fill the pq\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double change = ((double) (arr[i][0] + 1) / (arr[i][1] + 1) - (arr[i][0] / (double) arr[i][1]));\\n            \\n            pq.push({change, i});\\n        }\\n        \\n        // add the student to the class which will give the maximum change in the pass ratio\\n        \\n        while(extraStudents--)\\n        {\\n            auto top = pq.top();\\n            \\n            pq.pop();\\n            \\n            int i = top.second;\\n            \\n            // update the no. of pass students and total no. of students\\n            \\n            arr[i][0]++;\\n            \\n            arr[i][1]++;\\n            \\n            double change = ((double) (arr[i][0] + 1) / (arr[i][1] + 1) - ((arr[i][0]) / (double) (arr[i][1])));\\n            \\n            pq.push({change, i});\\n        }\\n        \\n        // find the total sum of pass ratio\\n        \\n        double sum = 0;\\n        \\n        while(pq.empty() == false)\\n        {\\n            int i = pq.top().second;\\n            \\n            sum += (double) arr[i][0] / arr[i][1];\\n            \\n            pq.pop();\\n        }\\n        \\n        // calculate the average and return it\\n        \\n        return sum / n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& arr, int extraStudents) {\\n        \\n        int n = arr.size();\\n        \\n        // declare a max heap which will store the change in pass ratio after adding student\\n        \\n        priority_queue<pair<double, int>> pq;\\n        \\n        // fill the pq\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            double change = ((double) (arr[i][0] + 1) / (arr[i][1] + 1) - (arr[i][0] / (double) arr[i][1]));\\n            \\n            pq.push({change, i});\\n        }\\n        \\n        // add the student to the class which will give the maximum change in the pass ratio\\n        \\n        while(extraStudents--)\\n        {\\n            auto top = pq.top();\\n            \\n            pq.pop();\\n            \\n            int i = top.second;\\n            \\n            // update the no. of pass students and total no. of students\\n            \\n            arr[i][0]++;\\n            \\n            arr[i][1]++;\\n            \\n            double change = ((double) (arr[i][0] + 1) / (arr[i][1] + 1) - ((arr[i][0]) / (double) (arr[i][1])));\\n            \\n            pq.push({change, i});\\n        }\\n        \\n        // find the total sum of pass ratio\\n        \\n        double sum = 0;\\n        \\n        while(pq.empty() == false)\\n        {\\n            int i = pq.top().second;\\n            \\n            sum += (double) arr[i][0] / arr[i][1];\\n            \\n            pq.pop();\\n        }\\n        \\n        // calculate the average and return it\\n        \\n        return sum / n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657497,
                "title": "c-clean-code",
                "content": "The idea is to increase the lowest avarage class each time.\\n```\\nstruct klass {\\n    int pass;\\n    int total;\\n    double ratio;\\n    klass() {}\\n    klass(int pass, int total) {\\n        this->pass = pass;\\n        this->total = total;\\n        update_ratio();\\n    }\\n    void update_ratio() { ratio = pass * 1.0 / total; }\\n    void increase(int by = 1) {\\n        pass += by;\\n        total += by;\\n        update_ratio();\\n    }\\n    double delta() {\\n        return (pass + 1) * 1.0 / (total + 1) - (pass)*1.0 / (total);\\n    }\\n    bool operator()(klass &a, klass &b) { return a.delta() < b.delta(); }\\n};\\n\\nclass Solution {\\n   public:\\n    double maxAverageRatio(vector<vector<int>> &classes, int extraStudents) {\\n        priority_queue<klass, vector<klass>, klass> pq;\\n        int total = classes.size();\\n        double sum = 0;\\n        klass k;\\n        for (auto i : classes) {\\n            k = klass(i[0], i[1]);\\n            pq.push(k);\\n        }\\n        while (extraStudents--) {\\n            k = pq.top();\\n            pq.pop();\\n            k.increase();\\n            pq.push(k);\\n        }\\n        while (pq.size()) {\\n            sum += pq.top().ratio;\\n            pq.pop();\\n        }\\n        return sum / total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct klass {\\n    int pass;\\n    int total;\\n    double ratio;\\n    klass() {}\\n    klass(int pass, int total) {\\n        this->pass = pass;\\n        this->total = total;\\n        update_ratio();\\n    }\\n    void update_ratio() { ratio = pass * 1.0 / total; }\\n    void increase(int by = 1) {\\n        pass += by;\\n        total += by;\\n        update_ratio();\\n    }\\n    double delta() {\\n        return (pass + 1) * 1.0 / (total + 1) - (pass)*1.0 / (total);\\n    }\\n    bool operator()(klass &a, klass &b) { return a.delta() < b.delta(); }\\n};\\n\\nclass Solution {\\n   public:\\n    double maxAverageRatio(vector<vector<int>> &classes, int extraStudents) {\\n        priority_queue<klass, vector<klass>, klass> pq;\\n        int total = classes.size();\\n        double sum = 0;\\n        klass k;\\n        for (auto i : classes) {\\n            k = klass(i[0], i[1]);\\n            pq.push(k);\\n        }\\n        while (extraStudents--) {\\n            k = pq.top();\\n            pq.pop();\\n            k.increase();\\n            pq.push(k);\\n        }\\n        while (pq.size()) {\\n            sum += pq.top().ratio;\\n            pq.pop();\\n        }\\n        return sum / total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623015,
                "title": "java-priorityqueue-solution-typecasting",
                "content": "```\\nclass pair{\\n    double pass, total;\\n    pair(double pass, double total){\\n        this.pass = pass;\\n        this.total = total;\\n    }\\n}\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        double sum = 0;\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b) -> {\\n            double av1 = (a.pass+1)/(a.total+1) - (a.pass/a.total);\\n            double av2 = (b.pass+1)/(b.total+1) - (b.pass/b.total);\\n            if(av1 == av2){\\n                return 0;\\n            }\\n            return (av1 > av2)?-1:1;\\n        });\\n        for(int temp[] : classes){\\n            pair p = new pair(temp[0], temp[1]);\\n            pq.offer(p);\\n        }\\n        for(int i = 0;i<extraStudents;i++){\\n            double temp1 = pq.peek().pass;\\n            double temp2 = pq.poll().total;\\n            temp1 += 1;\\n            temp2 += 1;\\n            pq.offer(new pair(temp1, temp2));\\n        }\\n        while(!pq.isEmpty()){\\n            sum += pq.peek().pass/pq.poll().total;\\n        }\\n        return sum/classes.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass pair{\\n    double pass, total;\\n    pair(double pass, double total){\\n        this.pass = pass;\\n        this.total = total;\\n    }\\n}\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        double sum = 0;\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b) -> {\\n            double av1 = (a.pass+1)/(a.total+1) - (a.pass/a.total);\\n            double av2 = (b.pass+1)/(b.total+1) - (b.pass/b.total);\\n            if(av1 == av2){\\n                return 0;\\n            }\\n            return (av1 > av2)?-1:1;\\n        });\\n        for(int temp[] : classes){\\n            pair p = new pair(temp[0], temp[1]);\\n            pq.offer(p);\\n        }\\n        for(int i = 0;i<extraStudents;i++){\\n            double temp1 = pq.peek().pass;\\n            double temp2 = pq.poll().total;\\n            temp1 += 1;\\n            temp2 += 1;\\n            pq.offer(new pair(temp1, temp2));\\n        }\\n        while(!pq.isEmpty()){\\n            sum += pq.peek().pass/pq.poll().total;\\n        }\\n        return sum/classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581413,
                "title": "python-bisect-solution",
                "content": "```\\ndef maxAverageRatio(self, classes: List[List[int]], extra: int) -> float:\\n        arr = sorted([[(x+1)/(y+1) - x/y, x, y] for x,y in classes])\\n        while extra:\\n            temp = arr.pop()\\n            temp[1] += 1\\n            temp[2] += 1\\n            cur = temp[1]/temp[2]\\n            temp[0] = (temp[1]+1)/(temp[2]+1) - cur\\n            bisect.insort(arr,temp)\\n            extra-=1\\n        return sum([x[1]/x[2] for x in arr])/len(arr)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxAverageRatio(self, classes: List[List[int]], extra: int) -> float:\\n        arr = sorted([[(x+1)/(y+1) - x/y, x, y] for x,y in classes])\\n        while extra:\\n            temp = arr.pop()\\n            temp[1] += 1\\n            temp[2] += 1\\n            cur = temp[1]/temp[2]\\n            temp[0] = (temp[1]+1)/(temp[2]+1) - cur\\n            bisect.insort(arr,temp)\\n            extra-=1\\n        return sum([x[1]/x[2] for x in arr])/len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546316,
                "title": "python3-solution-using-max-heap",
                "content": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap_classes = [[-1 * ( (x[0] + 1) / (x[1] + 1) - x[0] / x[1]), x[0], x[1], x[0] / x[1]] for x in classes]\\n        heapq.heapify(heap_classes)\\n        for i in range(extraStudents):\\n            class_ = heapq.heappop(heap_classes)\\n            class_[1] += 1\\n            class_[2] += 1\\n            class_[3] = class_[1] / class_[2]\\n            class_[0] = -1 * ( (class_[1] + 1) / (class_[2] + 1) - class_[1] / class_[2])\\n            heapq.heappush(heap_classes, class_)\\n        return sum([x[3] for x in heap_classes])/len(classes)\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        heap_classes = [[-1 * ( (x[0] + 1) / (x[1] + 1) - x[0] / x[1]), x[0], x[1], x[0] / x[1]] for x in classes]\\n        heapq.heapify(heap_classes)\\n        for i in range(extraStudents):\\n            class_ = heapq.heappop(heap_classes)\\n            class_[1] += 1\\n            class_[2] += 1\\n            class_[3] = class_[1] / class_[2]\\n            class_[0] = -1 * ( (class_[1] + 1) / (class_[2] + 1) - class_[1] / class_[2])\\n            heapq.heappush(heap_classes, class_)\\n        return sum([x[3] for x in heap_classes])/len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490481,
                "title": "java-greedy",
                "content": "\\t\\n\\tclass Solution {\\n\\t\\tpublic double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\t\\t\\tPriorityQueue<double[]> pq = new PriorityQueue<>(new Comparator<double[]>(){\\n\\t\\t\\t\\tpublic int compare(double[] a, double[] b){\\n\\t\\t\\t\\t\\tdouble adiff = (a[0]+1)/(a[1]+1) - (a[0]/a[1]);                \\n\\t\\t\\t\\t\\tdouble bdiff = (b[0]+1)/(b[1]+1) - (b[0]/b[1]);\\n\\t\\t\\t\\t\\tif(adiff==bdiff) return 0;\\n\\t\\t\\t\\t\\treturn adiff>bdiff? -1:1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\tfor(int[] c:classes) pq.add(new double[]{c[0],c[1]});\\n\\n\\t\\t\\tfor(int i =0;i<extraStudents;i++){\\n\\t\\t\\t\\tdouble[] curr = pq.poll();\\n\\t\\t\\t\\tpq.add(new double[]{curr[0]+1,curr[1]+1});\\n\\t\\t\\t}\\n\\n\\t\\t\\tdouble sum = 0;\\n\\t\\t\\twhile(!pq.isEmpty()){\\n\\t\\t\\t\\tdouble[] curr = pq.poll();\\n\\t\\t\\t\\tsum+=curr[0]/curr[1];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sum/classes.length;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\t\\t\\tPriorityQueue<double[]> pq = new PriorityQueue<>(new Comparator<double[]>(){\\n\\t\\t\\t\\tpublic int compare(double[] a, double[] b){\\n\\t\\t\\t\\t\\tdouble adiff = (a[0]+1)/(a[1]+1) - (a[0]/a[1]);                \\n\\t\\t\\t\\t\\tdouble bdiff = (b[0]+1)/(b[1]+1) - (b[0]/b[1]);\\n\\t\\t\\t\\t\\tif(adiff==bdiff) return 0;\\n\\t\\t\\t\\t\\treturn adiff>bdiff? -1:1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2458779,
                "title": "javascript-solution-faster-than-97-6-of-other-submissions",
                "content": "This is not my answer. I found it in this Github repository: https://github.com/AnasImloul/Leetcode-solutions/.\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\n```\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    // the heap will automatically find the class that will benefit\\n    // the most by adding a passing student\\n    const heap = new MaxHeap();\\n    \\n    // push all the classes into the heap so that\\n    // the heap can find the class that will benefit the most\\n    for (const x of classes) {\\n        heap.push(x);\\n    }\\n    \\n    // while there are extra students\\n    while (extraStudents) {\\n        \\n        // add the extra student to the class that will benefit the most\\n        heap.peak()[0] += 1;\\n        heap.peak()[1] += 1;\\n        \\n        // heapify down so that the heap remains valid\\n        heap.heapifyDown(0);\\n        \\n        extraStudents--;\\n    }\\n    \\n    \\n    // calculate the new average of all the classes\\n    let total = 0;\\n    for (const [x , y] of heap.store) {\\n        total += (x / y);\\n    }\\n    return total / heap.store.length;\\n};\\n\\n\\nclass MaxHeap {\\n    constructor() {\\n        this.store = [];\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2\\n            }\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        if (!child) return false;\\n        const c = (this.store[child][0] + 1) / (this.store[child][1] + 1) - (this.store[child][0]) / (this.store[child][1]);\\n        const p = (this.store[parent][0] + 1) / (this.store[parent][1] + 1) - (this.store[parent][0]) / (this.store[parent][1]);\\n        return c > p;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxAverageRatio = function(classes, extraStudents) {\\n    // the heap will automatically find the class that will benefit\\n    // the most by adding a passing student\\n    const heap = new MaxHeap();\\n    \\n    // push all the classes into the heap so that\\n    // the heap can find the class that will benefit the most\\n    for (const x of classes) {\\n        heap.push(x);\\n    }\\n    \\n    // while there are extra students\\n    while (extraStudents) {\\n        \\n        // add the extra student to the class that will benefit the most\\n        heap.peak()[0] += 1;\\n        heap.peak()[1] += 1;\\n        \\n        // heapify down so that the heap remains valid\\n        heap.heapifyDown(0);\\n        \\n        extraStudents--;\\n    }\\n    \\n    \\n    // calculate the new average of all the classes\\n    let total = 0;\\n    for (const [x , y] of heap.store) {\\n        total += (x / y);\\n    }\\n    return total / heap.store.length;\\n};\\n\\n\\nclass MaxHeap {\\n    constructor() {\\n        this.store = [];\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2\\n            }\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        if (!child) return false;\\n        const c = (this.store[child][0] + 1) / (this.store[child][1] + 1) - (this.store[child][0]) / (this.store[child][1]);\\n        const p = (this.store[parent][0] + 1) / (this.store[parent][1] + 1) - (this.store[parent][0]) / (this.store[parent][1]);\\n        return c > p;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348109,
                "title": "priorityqueue-java-solution-900ms",
                "content": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        double res=0;\\n        \\n        Queue<Class> queue=new PriorityQueue<>((a,b)->b.diff.compareTo(a.diff));\\n       \\n        queue.addAll(IntStream\\n                    .range(0,classes.length) \\n                    .parallel()\\n                    .mapToObj(e->new Class(classes[e][0],classes[e][1]))\\n                    .collect(Collectors.toList()));\\n        \\n       \\n        while(extraStudents>0)\\n        {          \\n            //update the first which had the big new ratio\\n            Class c=queue.poll(); \\n            c.updateClass(1); \\n            queue.add(c); \\n            extraStudents--;\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            Class c=queue.poll(); \\n            res+=c.ratio;\\n        }\\n            \\n        return res/Double.valueOf(classes.length);\\n    }\\n    class Class{\\n        public int students;\\n        public int pass;\\n        public Double ratio;\\n        public Double newRatio;\\n        public Double diff=0.0;\\n        public Class(int pass, int students)\\n        {\\n            this.students=students;\\n            this.pass=pass;\\n            this.ratio=Double.valueOf(this.pass)/Double.valueOf(this.students);\\n             this.calcNewRatio(1);\\n        }\\n       \\n        public void updateClass(int extStudent)\\n        {\\n            this.students+=extStudent;\\n            this.pass+=extStudent;\\n            this.ratio=Double.valueOf(this.pass)/Double.valueOf(this.students);\\n            this.calcNewRatio(extStudent);\\n        }\\n        \\n        public void calcNewRatio(int extStudent)\\n        {\\n            this.newRatio=Double.valueOf(this.pass+extStudent)/Double.valueOf(this.students+extStudent);\\n            this.diff=this.newRatio-this.ratio;\\n        }\\n    }\\n}\\n\\n \\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        double res=0;\\n        \\n        Queue<Class> queue=new PriorityQueue<>((a,b)->b.diff.compareTo(a.diff));\\n       \\n        queue.addAll(IntStream\\n                    .range(0,classes.length) \\n                    .parallel()\\n                    .mapToObj(e->new Class(classes[e][0],classes[e][1]))\\n                    .collect(Collectors.toList()));\\n        \\n       \\n        while(extraStudents>0)\\n        {          \\n            //update the first which had the big new ratio\\n            Class c=queue.poll(); \\n            c.updateClass(1); \\n            queue.add(c); \\n            extraStudents--;\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            Class c=queue.poll(); \\n            res+=c.ratio;\\n        }\\n            \\n        return res/Double.valueOf(classes.length);\\n    }\\n    class Class{\\n        public int students;\\n        public int pass;\\n        public Double ratio;\\n        public Double newRatio;\\n        public Double diff=0.0;\\n        public Class(int pass, int students)\\n        {\\n            this.students=students;\\n            this.pass=pass;\\n            this.ratio=Double.valueOf(this.pass)/Double.valueOf(this.students);\\n             this.calcNewRatio(1);\\n        }\\n       \\n        public void updateClass(int extStudent)\\n        {\\n            this.students+=extStudent;\\n            this.pass+=extStudent;\\n            this.ratio=Double.valueOf(this.pass)/Double.valueOf(this.students);\\n            this.calcNewRatio(extStudent);\\n        }\\n        \\n        public void calcNewRatio(int extStudent)\\n        {\\n            this.newRatio=Double.valueOf(this.pass+extStudent)/Double.valueOf(this.students+extStudent);\\n            this.diff=this.newRatio-this.ratio;\\n        }\\n    }\\n}\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313473,
                "title": "intuitive-do-as-hints-say",
                "content": "```\\nclass Solution {\\n    \\n    struct Class {\\n        int pass;\\n        int total;\\n        double ratio() const { return double(pass) / double(total); }\\n        double order() const { return double(pass + 1) / double(total + 1) - ratio(); }\\n    };\\n    \\n    struct pass_compare {\\n        bool operator()(const Class& lhs, const Class& rhs) {\\n            return lhs.order() < rhs.order();\\n        }\\n    };\\n    \\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<Class, vector<Class>, pass_compare> ratio(pass_compare{});\\n        int full = 0;\\n        for (auto& c : classes) {\\n            int p = c[0];\\n            int t = c[1];\\n            ratio.push(Class{p, t});\\n        }\\n        \\n        while (extraStudents--) {\\n            auto temp = ratio.top();\\n            ratio.pop();\\n            ratio.push(Class{temp.pass + 1, temp.total + 1});\\n        }\\n        \\n        double res = 0;\\n        while (!ratio.empty()) {\\n            res += ratio.top().ratio();\\n            ratio.pop();\\n        }\\n        return (res + full) / classes.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    struct Class {\\n        int pass;\\n        int total;\\n        double ratio() const { return double(pass) / double(total); }\\n        double order() const { return double(pass + 1) / double(total + 1) - ratio(); }\\n    };\\n    \\n    struct pass_compare {\\n        bool operator()(const Class& lhs, const Class& rhs) {\\n            return lhs.order() < rhs.order();\\n        }\\n    };\\n    \\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<Class, vector<Class>, pass_compare> ratio(pass_compare{});\\n        int full = 0;\\n        for (auto& c : classes) {\\n            int p = c[0];\\n            int t = c[1];\\n            ratio.push(Class{p, t});\\n        }\\n        \\n        while (extraStudents--) {\\n            auto temp = ratio.top();\\n            ratio.pop();\\n            ratio.push(Class{temp.pass + 1, temp.total + 1});\\n        }\\n        \\n        double res = 0;\\n        while (!ratio.empty()) {\\n            res += ratio.top().ratio();\\n            ratio.pop();\\n        }\\n        return (res + full) / classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301285,
                "title": "c-priority-queue-easy-to-understand-solution",
                "content": "```\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n\\tpriority_queue<pair<double,int>> pq;\\n\\tdouble rate;\\n\\tfor(int i = 0; i < classes.size(); i++) {\\n\\t\\trate = ((double) classes[i][0]+1)/((double)classes[i][1]+1) - ((double)classes[i][0]/(double)classes[i][1]);\\n\\t\\tpq.push({rate,i});\\n\\t}\\n\\n\\tint cl;\\n\\tfor(int i = 0; i < extraStudents; i++) {\\n\\t\\tcl = pq.top().second, pq.pop();\\n\\t\\tclasses[cl][0]++, classes[cl][1]++;\\n\\t\\trate = ((double)classes[cl][0]+1)/((double)classes[cl][1]+1) - (double)classes[cl][0]/classes[cl][1];\\n\\t\\tpq.push({rate,cl});\\n\\t}\\n\\n\\trate = 0;\\n\\tfor(auto i : classes) {\\n\\t\\trate += (double)i[0]/i[1];\\n\\t}\\n\\trate/=classes.size();\\n\\treturn rate;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n\\tpriority_queue<pair<double,int>> pq;\\n\\tdouble rate;\\n\\tfor(int i = 0; i < classes.size(); i++) {\\n\\t\\trate = ((double) classes[i][0]+1)/((double)classes[i][1]+1) - ((double)classes[i][0]/(double)classes[i][1]);\\n\\t\\tpq.push({rate,i});\\n\\t}\\n\\n\\tint cl;\\n\\tfor(int i = 0; i < extraStudents; i++) {\\n\\t\\tcl = pq.top().second, pq.pop();\\n\\t\\tclasses[cl][0]++, classes[cl][1]++;\\n\\t\\trate = ((double)classes[cl][0]+1)/((double)classes[cl][1]+1) - (double)classes[cl][0]/classes[cl][1];\\n\\t\\tpq.push({rate,cl});\\n\\t}\\n\\n\\trate = 0;\\n\\tfor(auto i : classes) {\\n\\t\\trate += (double)i[0]/i[1];\\n\\t}\\n\\trate/=classes.size();\\n\\treturn rate;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282089,
                "title": "java-max-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    class P implements Comparable<P>{\\n        double a;\\n        double b;\\n        P(){}\\n        P(double a, double b){\\n            this.a=a;\\n            this.b=b;\\n        }\\n        public int compareTo(P p){\\n            //compare only increased ratio\\n            double t1 = ((this.a+1)/(this.b+1)) - (this.a/this.b);\\n            double t2 = ((p.a+1)/(p.b+1)) -(p.a/p.b);\\n            if(t1<t2) return 1;\\n            else if(t1>t2) return -1;\\n            else\\n                return 0;\\n        }\\n    }\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        Queue<P> q = new PriorityQueue<P>();\\n        for(int i=0;i<classes.length; i++){\\n            q.add(new P(classes[i][0], classes[i][1]));\\n          \\n        }\\n        while(extraStudents-- > 0){\\n            P p = q.remove();\\n            p.a+=1;\\n            p.b+=1;\\n            q.add(p);\\n        }\\n        double sum =0.0;\\n        for( P p : q){\\n            sum+=(p.a/p.b);\\n        }\\n        return sum/classes.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class P implements Comparable<P>{\\n        double a;\\n        double b;\\n        P(){}\\n        P(double a, double b){\\n            this.a=a;\\n            this.b=b;\\n        }\\n        public int compareTo(P p){\\n            //compare only increased ratio\\n            double t1 = ((this.a+1)/(this.b+1)) - (this.a/this.b);\\n            double t2 = ((p.a+1)/(p.b+1)) -(p.a/p.b);\\n            if(t1<t2) return 1;\\n            else if(t1>t2) return -1;\\n            else\\n                return 0;\\n        }\\n    }\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        Queue<P> q = new PriorityQueue<P>();\\n        for(int i=0;i<classes.length; i++){\\n            q.add(new P(classes[i][0], classes[i][1]));\\n          \\n        }\\n        while(extraStudents-- > 0){\\n            P p = q.remove();\\n            p.a+=1;\\n            p.b+=1;\\n            q.add(p);\\n        }\\n        double sum =0.0;\\n        for( P p : q){\\n            sum+=(p.a/p.b);\\n        }\\n        return sum/classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273689,
                "title": "python-max-heap-solution",
                "content": "```\\ndef maxAverageRatio(self, c: List[List[int]], extra:int) -> float:\\n\\tc = [(c1/c2-(c1+1)/(c2+1), c1, c2) for c1, c2 in c]\\n\\theapify(c)\\n\\tfor _ in range(extra):\\n\\t\\t_, c1, c2 = heappop(c)\\n\\t\\theappush(c, ((c1+1)/(c2+1)-(c1+2)/(c2+2), c1+1, c2+1))\\n\\n\\treturn sum(c1/c2 for _, c1, c2 in c)/len(c)\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxAverageRatio(self, c: List[List[int]], extra:int) -> float:\\n\\tc = [(c1/c2-(c1+1)/(c2+1), c1, c2) for c1, c2 in c]\\n\\theapify(c)\\n\\tfor _ in range(extra):\\n\\t\\t_, c1, c2 = heappop(c)\\n\\t\\theappush(c, ((c1+1)/(c2+1)-(c1+2)/(c2+2), c1+1, c2+1))\\n\\n\\treturn sum(c1/c2 for _, c1, c2 in c)/len(c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2209852,
                "title": "heap-queue-solution",
                "content": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        computeGain = lambda p, t: (1 - (p / t)) / (t + 1)\\n        R = [(-computeGain(p, t), p, t) for p, t in classes]\\n        heapify(R)\\n\\n        for x in range(extraStudents):\\n            _, p, t = heappop(R)\\n            p += 1\\n            t += 1\\n            heappush(R, (-computeGain(p, t), p, t))\\n\\n        return sum(map(lambda x: x[1] / x[2], R)) / len(classes)\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        computeGain = lambda p, t: (1 - (p / t)) / (t + 1)\\n        R = [(-computeGain(p, t), p, t) for p, t in classes]\\n        heapify(R)\\n\\n        for x in range(extraStudents):\\n            _, p, t = heappop(R)\\n            p += 1\\n            t += 1\\n            heappush(R, (-computeGain(p, t), p, t))\\n\\n        return sum(map(lambda x: x[1] / x[2], R)) / len(classes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163451,
                "title": "c-using-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n        for(auto v : classes){\\n            float p = ((float)(v[0]+1))/((float)(v[1]+1)) - ((float)v[0])/((float)v[1]);\\n            pair<int,int> a;\\n            a.first = v[0];\\n            a.second = v[1];\\n            pair <float,pair<int,int>> b;\\n            b.first = p;\\n            b.second = a;\\n            pq.push(b);\\n        }\\n        for(int i=0;i<extraStudents;i++){\\n            pair <float, pair<int,int>> a = pq.top();\\n            a.second.first++;\\n            a.second.second++;\\n            int a1 = a.second.first, a2 = a.second.second;\\n            a.first = ((float)(a1+1))/((float)(a2+1)) - ((float)a1)/((float)a2);\\n            pq.pop();\\n            pq.push(a);\\n        }\\n        double ans = 0.0,sum=0.0;\\n        while(!pq.empty()){\\n            sum+=(double)pq.top().second.first/(double)pq.top().second.second;\\n            pq.pop();\\n        }\\n        ans = sum/(double)classes.size();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n        for(auto v : classes){\\n            float p = ((float)(v[0]+1))/((float)(v[1]+1)) - ((float)v[0])/((float)v[1]);\\n            pair<int,int> a;\\n            a.first = v[0];\\n            a.second = v[1];\\n            pair <float,pair<int,int>> b;\\n            b.first = p;\\n            b.second = a;\\n            pq.push(b);\\n        }\\n        for(int i=0;i<extraStudents;i++){\\n            pair <float, pair<int,int>> a = pq.top();\\n            a.second.first++;\\n            a.second.second++;\\n            int a1 = a.second.first, a2 = a.second.second;\\n            a.first = ((float)(a1+1))/((float)(a2+1)) - ((float)a1)/((float)a2);\\n            pq.pop();\\n            pq.push(a);\\n        }\\n        double ans = 0.0,sum=0.0;\\n        while(!pq.empty()){\\n            sum+=(double)pq.top().second.first/(double)pq.top().second.second;\\n            pq.pop();\\n        }\\n        ans = sum/(double)classes.size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092512,
                "title": "priority-queue-clean-understandable",
                "content": "public double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\t\\t \\n\\t\\t PriorityQueue<ClassRoom>  queue= new PriorityQueue<>();\\n\\t\\t for(int i =0; i< classes.length;i++) {\\n\\t\\t\\t queue.add(new ClassRoom(Double.valueOf(classes[i][0]), Double.valueOf(classes[i][1])));\\n\\t\\t }\\n\\t\\t\\n\\t\\tfor(int i =0;i<extraStudents;i++){\\n\\t\\t\\tClassRoom curr = queue.poll();\\n\\t\\t\\tqueue.add(new ClassRoom(curr.pass+1,curr.total+1));\\n        }\\n\\t\\t\\n\\t\\t double rationTotal=0;\\n\\t\\t \\n\\t\\t while(!queue.isEmpty()) {\\n\\t\\t\\t ClassRoom m =queue.poll();\\n\\t\\t\\t rationTotal+=m.ratio;\\n\\t\\t }\\n\\t\\t \\n\\t\\t return rationTotal/ classes.length;\\n\\t    }\\n\\t\\t\\n\\t\\tclass ClassRoom implements Comparable<ClassRoom>{\\n\\t\\t Double pass;\\n\\t\\t Double total;\\n\\t\\t Double ratio;\\n\\t\\t Double eratio;\\n\\t\\t Double diff;\\n\\t\\t \\n\\t\\t \\n\\t\\tpublic ClassRoom(Double pass, Double total) {\\n\\t\\t\\t\\n\\t\\t\\tthis.pass=pass;\\n\\t\\t\\tthis.total=total;\\n\\t\\t\\tthis.ratio=pass/total;\\n\\t\\t\\tthis.eratio=( pass+1) / (total+1);\\n\\t\\t\\tthis.diff= eratio-ratio;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int compareTo(ClassRoom c) {\\n\\t\\t\\treturn Double.compare(c.eratio-c.ratio, this.eratio-this.ratio) ;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"ClassRoom [pass=\" + pass + \", total=\" + total + \", ratio=\" + ratio + \", eratio=\" + eratio\\n\\t\\t\\t\\t\\t+ \", diff=\" + diff + \"]\";\\n\\t\\t}\\n\\t\\t \\n\\t\\t \\n\\t }\\n\\t\\t",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "public double maxAverageRatio(int[][] classes, int extraStudents) {\\n\\t\\t \\n\\t\\t PriorityQueue<ClassRoom>  queue= new PriorityQueue<>();\\n\\t\\t for(int i =0; i< classes.length;i++) {\\n\\t\\t\\t queue.add(new ClassRoom(Double.valueOf(classes[i][0]), Double.valueOf(classes[i][1])));\\n\\t\\t }\\n\\t\\t\\n\\t\\tfor(int i =0;i<extraStudents;i++){\\n\\t\\t\\tClassRoom curr = queue.poll();\\n\\t\\t\\tqueue.add(new ClassRoom(curr.pass+1,curr.total+1));\\n        }\\n\\t\\t\\n\\t\\t double rationTotal=0;\\n\\t\\t \\n\\t\\t while(!queue.isEmpty()) {\\n\\t\\t\\t ClassRoom m =queue.poll();\\n\\t\\t\\t rationTotal+=m.ratio;\\n\\t\\t }\\n\\t\\t \\n\\t\\t return rationTotal/ classes.length;\\n\\t    }\\n\\t\\t\\n\\t\\tclass ClassRoom implements Comparable<ClassRoom>{\\n\\t\\t Double pass;\\n\\t\\t Double total;\\n\\t\\t Double ratio;\\n\\t\\t Double eratio;\\n\\t\\t Double diff;\\n\\t\\t \\n\\t\\t \\n\\t\\tpublic ClassRoom(Double pass, Double total) {\\n\\t\\t\\t\\n\\t\\t\\tthis.pass=pass;\\n\\t\\t\\tthis.total=total;\\n\\t\\t\\tthis.ratio=pass/total;\\n\\t\\t\\tthis.eratio=( pass+1) / (total+1);\\n\\t\\t\\tthis.diff= eratio-ratio;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int compareTo(ClassRoom c) {\\n\\t\\t\\treturn Double.compare(c.eratio-c.ratio, this.eratio-this.ratio) ;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"ClassRoom [pass=\" + pass + \", total=\" + total + \", ratio=\" + ratio + \", eratio=\" + eratio\\n\\t\\t\\t\\t\\t+ \", diff=\" + diff + \"]\";\\n\\t\\t}\\n\\t\\t \\n\\t\\t \\n\\t }\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2087732,
                "title": "c-heap-simple-solution-with-explanation",
                "content": "We choose the maximum addition profit in heap by maintaining a max heap and iteratively process until no more `extraStudents` we have. Note that we can earily stop if current # of pass == # of students.\\n\\n`m`: size of `classes`, `n`: `extraStudents`\\n\\n* time: `O((m+n) * logm)`\\n* space: `O(m)`\\n\\n```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        auto addProfit = [](const array<int,2> &cl) {\\n            return (double)(cl[0]+1)/(cl[1]+1)-(double)cl[0]/cl[1];\\n        };\\n        auto comp = [&addProfit](const array<int,2> &cla, const array<int,2> &clb) {\\n            return addProfit(cla) < addProfit(clb);\\n        };\\n        priority_queue<array<int,2>, vector<array<int,2>>, decltype(comp)> que(comp);\\n        for (auto &cl: classes) {\\n            que.push({cl[0],cl[1]});\\n        }\\n        while (extraStudents--) {\\n            auto now = que.top();\\n            que.pop();\\n            if (now[0] == now[1]) {\\n                break;\\n            }\\n            que.push({now[0]+1,now[1]+1});\\n        }\\n        double res = 0;\\n        while (que.size()) {\\n            auto now = que.top();\\n            que.pop();\\n            res += (double)now[0]/now[1];\\n        }\\n        return res/classes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        auto addProfit = [](const array<int,2> &cl) {\\n            return (double)(cl[0]+1)/(cl[1]+1)-(double)cl[0]/cl[1];\\n        };\\n        auto comp = [&addProfit](const array<int,2> &cla, const array<int,2> &clb) {\\n            return addProfit(cla) < addProfit(clb);\\n        };\\n        priority_queue<array<int,2>, vector<array<int,2>>, decltype(comp)> que(comp);\\n        for (auto &cl: classes) {\\n            que.push({cl[0],cl[1]});\\n        }\\n        while (extraStudents--) {\\n            auto now = que.top();\\n            que.pop();\\n            if (now[0] == now[1]) {\\n                break;\\n            }\\n            que.push({now[0]+1,now[1]+1});\\n        }\\n        double res = 0;\\n        while (que.size()) {\\n            auto now = que.top();\\n            que.pop();\\n            res += (double)now[0]/now[1];\\n        }\\n        return res/classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032384,
                "title": "think-about-the-profit-if-1-extra-student-is-assigned-to-each-class",
                "content": "```cpp\\nclass Solution {\\n    // how much the average will increase if a class of (m, n) students becomes (m + 1, n + 1) students.\\n    double inc(double m, double n)\\n    {\\n        return (n - m) / (n * (n + 1));\\n    }\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double, int>> pq;\\n        \\n        // sort by the possible increasment of average if the i class has been assigned with 1 extra student.\\n        for (int i = 0; i < classes.size(); ++i)\\n            pq.push({inc(classes[i][0], classes[i][1]), i});\\n        \\n        // start from the class with biggest increasment, assign 1 extra student at a time.\\n        // and re-calculate the possible increasment if assign another extra student. \\n        while (extraStudents --)\\n        {\\n            int i = pq.top().second;\\n            ++ classes[i][0];\\n            ++ classes[i][1];\\n            pq.pop();\\n            pq.push({inc(classes[i][0], classes[i][1]), i});\\n        }\\n        \\n        // the final result\\n        double sum = 0;\\n        \\n        while (pq.size())\\n        {\\n            int i = pq.top().second;\\n            sum += (double)classes[i][0] / classes[i][1];\\n            pq.pop();\\n        }\\n        \\n        return sum / classes.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\n    // how much the average will increase if a class of (m, n) students becomes (m + 1, n + 1) students.\\n    double inc(double m, double n)\\n    {\\n        return (n - m) / (n * (n + 1));\\n    }\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<double, int>> pq;\\n        \\n        // sort by the possible increasment of average if the i class has been assigned with 1 extra student.\\n        for (int i = 0; i < classes.size(); ++i)\\n            pq.push({inc(classes[i][0], classes[i][1]), i});\\n        \\n        // start from the class with biggest increasment, assign 1 extra student at a time.\\n        // and re-calculate the possible increasment if assign another extra student. \\n        while (extraStudents --)\\n        {\\n            int i = pq.top().second;\\n            ++ classes[i][0];\\n            ++ classes[i][1];\\n            pq.pop();\\n            pq.push({inc(classes[i][0], classes[i][1]), i});\\n        }\\n        \\n        // the final result\\n        double sum = 0;\\n        \\n        while (pq.size())\\n        {\\n            int i = pq.top().second;\\n            sum += (double)classes[i][0] / classes[i][1];\\n            pq.pop();\\n        }\\n        \\n        return sum / classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013107,
                "title": "java-greedy-heap",
                "content": "Idea: Assign the brilliant students to classes where the potential increase in the passing average is highest.\\nData structure: maxHeap\\n\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Course> pq=new PriorityQueue<Course>(new Comparator<Course>(){\\n            @Override\\n            public int compare(Course a, Course b){\\n                if(a.potIncrease>b.potIncrease){\\n                    return -1;\\n                }\\n                return 1;\\n            }\\n        });\\n        \\n        for(int[] cls: classes){\\n            int num=cls[0];\\n            int deno=cls[1];\\n            double currRat=(double)(num)/(double)deno;\\n            double next=(double)(num+1)/(double)(deno+1);\\n            pq.add(new Course(num, deno, next-currRat));\\n        }\\n        \\n        while(extraStudents>0){\\n            Course curr=pq.poll();\\n            curr.num+=1;\\n            curr.deno+=1;\\n            double currRat=(double)(curr.num)/(double)curr.deno;\\n            double next=(double)(curr.num+1)/(double)(curr.deno+1);\\n            curr.potIncrease=next-currRat;\\n            pq.add(curr);\\n            extraStudents--;\\n        }\\n        \\n        double ans=0;\\n        while(pq.size()>0){\\n            Course curr=pq.poll();\\n            ans+=(double)(curr.num)/(double)curr.deno;\\n        }\\n        return ans/(double)classes.length;        \\n    }\\n    \\n    \\n    class Course{\\n        int num, deno;\\n        double potIncrease;\\n        Course(int num, int deno, double potIncrease){\\n            this.num=num;\\n            this.deno=deno;\\n            this.potIncrease=potIncrease;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Course> pq=new PriorityQueue<Course>(new Comparator<Course>(){\\n            @Override\\n            public int compare(Course a, Course b){\\n                if(a.potIncrease>b.potIncrease){\\n                    return -1;\\n                }\\n                return 1;\\n            }\\n        });\\n        \\n        for(int[] cls: classes){\\n            int num=cls[0];\\n            int deno=cls[1];\\n            double currRat=(double)(num)/(double)deno;\\n            double next=(double)(num+1)/(double)(deno+1);\\n            pq.add(new Course(num, deno, next-currRat));\\n        }\\n        \\n        while(extraStudents>0){\\n            Course curr=pq.poll();\\n            curr.num+=1;\\n            curr.deno+=1;\\n            double currRat=(double)(curr.num)/(double)curr.deno;\\n            double next=(double)(curr.num+1)/(double)(curr.deno+1);\\n            curr.potIncrease=next-currRat;\\n            pq.add(curr);\\n            extraStudents--;\\n        }\\n        \\n        double ans=0;\\n        while(pq.size()>0){\\n            Course curr=pq.poll();\\n            ans+=(double)(curr.num)/(double)curr.deno;\\n        }\\n        return ans/(double)classes.length;        \\n    }\\n    \\n    \\n    class Course{\\n        int num, deno;\\n        double potIncrease;\\n        Course(int num, int deno, double potIncrease){\\n            this.num=num;\\n            this.deno=deno;\\n            this.potIncrease=potIncrease;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012110,
                "title": "scala",
                "content": "```\\nimport scala.collection.mutable\\n\\nobject Solution {\\n  private implicit val ClassOrdering: Ordering[Array[Int]] = Ordering.by {\\n    case Array(pass, total) => (total - pass).toDouble / total / (total + 1)\\n  }\\n\\n  def maxAverageRatio(classes: Array[Array[Int]], extraStudents: Int): Double = {\\n    val queue = classes.to(mutable.PriorityQueue)\\n\\n    for (_ <- 1 to extraStudents) queue.dequeue match {\\n      case Array(pass, total) => queue.enqueue(Array(pass + 1, total + 1))\\n    }\\n\\n    queue.iterator.collect { case Array(pass, total) => pass.toDouble / total }.sum / classes.length\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable\\n\\nobject Solution {\\n  private implicit val ClassOrdering: Ordering[Array[Int]] = Ordering.by {\\n    case Array(pass, total) => (total - pass).toDouble / total / (total + 1)\\n  }\\n\\n  def maxAverageRatio(classes: Array[Array[Int]], extraStudents: Int): Double = {\\n    val queue = classes.to(mutable.PriorityQueue)\\n\\n    for (_ <- 1 to extraStudents) queue.dequeue match {\\n      case Array(pass, total) => queue.enqueue(Array(pass + 1, total + 1))\\n    }\\n\\n    queue.iterator.collect { case Array(pass, total) => pass.toDouble / total }.sum / classes.length\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995428,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        \\n        \\n        priority_queue< pair<double,int> >pq;\\n        double current, next, avg=0;\\n        \\n        for(int i=0;i<classes.size();i++)\\n        {\\n            current = (double)classes[i][0]/(double)classes[i][1];\\n            next = (double)(classes[i][0]+1)/(double)(classes[i][1]+1);\\n            \\n            avg+=current;\\n            pq.push(make_pair(next-current,i));\\n           \\n        }\\n        \\n        while(extraStudents)\\n        {\\n            auto p=pq.top();\\n            \\n            int i=p.second;\\n            \\n            current = (double)classes[i][0]/(double)classes[i][1];\\n            avg-=current;\\n            \\n            classes[i][0]++;\\n            classes[i][1]++;\\n            \\n            current = (double)classes[i][0]/(double)classes[i][1];\\n            \\n            avg+=current;\\n            \\n            next = (double)(classes[i][0]+1)/(double)(classes[i][1]+1);\\n            \\n            pq.pop();\\n            pq.push(make_pair(next-current,i));\\n            \\n            extraStudents--;\\n        }\\n        \\n        return avg/(double)classes.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        \\n        \\n        priority_queue< pair<double,int> >pq;\\n        double current, next, avg=0;\\n        \\n        for(int i=0;i<classes.size();i++)\\n        {\\n            current = (double)classes[i][0]/(double)classes[i][1];\\n            next = (double)(classes[i][0]+1)/(double)(classes[i][1]+1);\\n            \\n            avg+=current;\\n            pq.push(make_pair(next-current,i));\\n           \\n        }\\n        \\n        while(extraStudents)\\n        {\\n            auto p=pq.top();\\n            \\n            int i=p.second;\\n            \\n            current = (double)classes[i][0]/(double)classes[i][1];\\n            avg-=current;\\n            \\n            classes[i][0]++;\\n            classes[i][1]++;\\n            \\n            current = (double)classes[i][0]/(double)classes[i][1];\\n            \\n            avg+=current;\\n            \\n            next = (double)(classes[i][0]+1)/(double)(classes[i][1]+1);\\n            \\n            pq.pop();\\n            pq.push(make_pair(next-current,i));\\n            \\n            extraStudents--;\\n        }\\n        \\n        return avg/(double)classes.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973410,
                "title": "c-easy-to-understand-for-beginners-recursion-maxheap",
                "content": "# RECURSIVE CODE\\n\\n```\\nclass Solution {\\npublic:\\n    double helper(vector<vector<int>> &classes, int curr, int K){\\n        if(K==0){  // if k=0 achieved, rest all from curr till n are just gonna add their averages\\n            double average=0.0;\\n            for(int i=curr;i<classes.size();i++){\\n                average=average+(((double)classes[i][0])/((double)classes[i][1]));\\n            }\\n            return average;\\n        }\\n        \\n        if(curr==classes.size()){  // if k is not zero and curr reached end, return min\\n            return (double)INT_MIN;\\n        }\\n        \\n        double res=(double)INT_MIN;\\n        \\n        for(int i=0;i<=K;i++){ \\n\\t\\t/* trying all possible k, giving 0 brillant student to the current class\\n\\t\\t\\tto giving all brilliant student to this class */\\n            double tempAvg=(((double)classes[curr][0]+i)/((double)classes[curr][1]+i))+helper(classes,curr+1,K-i);\\n            res=max(res,tempAvg);\\n        }\\n        \\n        return res;\\n    }\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        return helper(classes,0,extraStudents)/classes.size();\\n    }\\n};\\n```\\n\\n# PRIORITY QUEUE GREEDY\\n\\nBasic idea, is to check which class gives the max change in average if allocated a brillant student..\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct cmp{\\n        bool operator()(pair<int,int> &p1, pair<int,int> &p2){\\n            double diff1=((double)(p1.first+1.0)/(double)(p1.second+1.0))-((double)(p1.first)/(double)(p1.second));\\n            double diff2=((double)(p2.first+1.0)/(double)(p2.second+1.0))-((double)(p2.first)/(double)(p2.second));\\n            return diff1<diff2; // the top of heap will contain a class where the difference is max\\n        }\\n    };\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> pq;\\n        for(auto klass: classes){\\n            pq.push({klass[0],klass[1]});\\n        }\\n        while(extraStudents--){\\n            auto tp=pq.top();\\n            pq.pop();\\n            tp.first++;\\n            tp.second++;\\n            pq.push(tp);\\n        }\\n        double res=0.0;\\n        while(!pq.empty()){\\n            auto tp=pq.top();\\n            pq.pop();\\n            res+=(((double)tp.first)/((double)tp.second));\\n        }\\n        return res/classes.size();\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Greedy",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double helper(vector<vector<int>> &classes, int curr, int K){\\n        if(K==0){  // if k=0 achieved, rest all from curr till n are just gonna add their averages\\n            double average=0.0;\\n            for(int i=curr;i<classes.size();i++){\\n                average=average+(((double)classes[i][0])/((double)classes[i][1]));\\n            }\\n            return average;\\n        }\\n        \\n        if(curr==classes.size()){  // if k is not zero and curr reached end, return min\\n            return (double)INT_MIN;\\n        }\\n        \\n        double res=(double)INT_MIN;\\n        \\n        for(int i=0;i<=K;i++){ \\n\\t\\t/* trying all possible k, giving 0 brillant student to the current class\\n\\t\\t\\tto giving all brilliant student to this class */\\n            double tempAvg=(((double)classes[curr][0]+i)/((double)classes[curr][1]+i))+helper(classes,curr+1,K-i);\\n            res=max(res,tempAvg);\\n        }\\n        \\n        return res;\\n    }\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        return helper(classes,0,extraStudents)/classes.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    struct cmp{\\n        bool operator()(pair<int,int> &p1, pair<int,int> &p2){\\n            double diff1=((double)(p1.first+1.0)/(double)(p1.second+1.0))-((double)(p1.first)/(double)(p1.second));\\n            double diff2=((double)(p2.first+1.0)/(double)(p2.second+1.0))-((double)(p2.first)/(double)(p2.second));\\n            return diff1<diff2; // the top of heap will contain a class where the difference is max\\n        }\\n    };\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> pq;\\n        for(auto klass: classes){\\n            pq.push({klass[0],klass[1]});\\n        }\\n        while(extraStudents--){\\n            auto tp=pq.top();\\n            pq.pop();\\n            tp.first++;\\n            tp.second++;\\n            pq.push(tp);\\n        }\\n        double res=0.0;\\n        while(!pq.empty()){\\n            auto tp=pq.top();\\n            pq.pop();\\n            res+=(((double)tp.first)/((double)tp.second));\\n        }\\n        return res/classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967539,
                "title": "java-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public double profit(double a,double b)\\n    {\\n        return ((a+1)/(b+1))-(a/b);\\n    }\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]>pq=new PriorityQueue<double[]>(new Comparator<double[]>(){\\n            public int compare(double[] a1,double[] a2)\\n            {\\n                return Double.compare(a2[0],a1[0]);\\n            }\\n        });\\n        for(int[] clas:classes)\\n        {\\n            double delta=profit(clas[0],clas[1]);\\n            pq.offer(new double[]{delta,clas[0],clas[1]});\\n        }\\n        while(extraStudents>=1)\\n        {\\n            double[] temp=pq.poll();\\n            double pass=temp[1]+1;\\n            double total=temp[2]+1;\\n            double delta=profit(pass,total);\\n            pq.offer(new double[]{delta,pass,total});\\n            extraStudents--;\\n        }\\n        double avg=0.0;\\n        while(!pq.isEmpty())\\n        {\\n            double[] temp=pq.poll();\\n            avg+=temp[1]/temp[2];\\n        }\\n        return avg/classes.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double profit(double a,double b)\\n    {\\n        return ((a+1)/(b+1))-(a/b);\\n    }\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<double[]>pq=new PriorityQueue<double[]>(new Comparator<double[]>(){\\n            public int compare(double[] a1,double[] a2)\\n            {\\n                return Double.compare(a2[0],a1[0]);\\n            }\\n        });\\n        for(int[] clas:classes)\\n        {\\n            double delta=profit(clas[0],clas[1]);\\n            pq.offer(new double[]{delta,clas[0],clas[1]});\\n        }\\n        while(extraStudents>=1)\\n        {\\n            double[] temp=pq.poll();\\n            double pass=temp[1]+1;\\n            double total=temp[2]+1;\\n            double delta=profit(pass,total);\\n            pq.offer(new double[]{delta,pass,total});\\n            extraStudents--;\\n        }\\n        double avg=0.0;\\n        while(!pq.isEmpty())\\n        {\\n            double[] temp=pq.poll();\\n            avg+=temp[1]/temp[2];\\n        }\\n        return avg/classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957602,
                "title": "java-priorityqueue-max-heap-detailed-explanation",
                "content": "```\\nclass Solution {\\n    \\n     /*\\n       1. Since the goal is to maximize the average pass ratio, we need to prioritize the classes that has biggest change in pass ratio when a student is added\\n       2. Change in pass ratio can be determined by  (current pass students + 1)/(current students + 1) - ((current pass students)/(current students))\\n       3. Build a priority queue with change in pass ratio and class id sorted by max pass ratio (i.e max heap)\\n       4. Allocate the extra students one at a time to each class that has biggest change in pass ratio when a student is added\\n       5. Finally calculate the average pass ratio across all the classes\\n     */\\n    \\n    static class DeltaPassRatio {\\n        double delta;\\n        int classroomid;\\n        public DeltaPassRatio(double delta, int classroomid) {\\n            this.delta = delta;\\n            this.classroomid = classroomid;\\n        }    \\n    }\\n    \\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        if(classes == null || classes.length == 0 || extraStudents < 0)\\n            return 0.0;\\n        \\n        //Build a max heap that stores [change in pass ratio, classroomid]\\n        PriorityQueue<DeltaPassRatio> maxHeap = new PriorityQueue<DeltaPassRatio>(classes.length, (DeltaPassRatio e1, DeltaPassRatio e2) -> Double.compare(e2.delta, e1.delta));\\n        for(int i = 0; i < classes.length; i++) \\n            maxHeap.add(new DeltaPassRatio(((double)(classes[i][0] + 1))/((double)(classes[i][1] + 1)) - ((double)classes[i][0])/((double)classes[i][1]), i));\\n        \\n        \\n        DeltaPassRatio current;\\n        int[] classRoom;\\n        while(extraStudents > 0) {\\n            current = maxHeap.remove();\\n            \\n            // Get the class room id and Increase pass students and total Students\\n            classRoom = classes[current.classroomid];\\n            classRoom[0] = classRoom[0] + 1;\\n            classRoom[1] = classRoom[1] + 1; \\n            \\n            //Update new score and add back to heap\\n            current.delta = ((double)(classRoom[0] + 1))/((double)(classRoom[1] + 1)) - ((double)classRoom[0])/((double)classRoom[1]);\\n            maxHeap.add(current); \\n            extraStudents--;\\n        }\\n        \\n        double totalPassRatio = 0.0;\\n        \\n        // Sum up the pass ratio of each class\\n       for (int[] classInfo : classes)\\n          totalPassRatio += ((double) classInfo[0] / classInfo[1]);\\n        \\n        \\n        return totalPassRatio/classes.length;\\n    }\\n}\\n```\\n\\nTC is O(k * nlogn) where k is extrastudents and SC is O(n) and n is number of classes",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n     /*\\n       1. Since the goal is to maximize the average pass ratio, we need to prioritize the classes that has biggest change in pass ratio when a student is added\\n       2. Change in pass ratio can be determined by  (current pass students + 1)/(current students + 1) - ((current pass students)/(current students))\\n       3. Build a priority queue with change in pass ratio and class id sorted by max pass ratio (i.e max heap)\\n       4. Allocate the extra students one at a time to each class that has biggest change in pass ratio when a student is added\\n       5. Finally calculate the average pass ratio across all the classes\\n     */\\n    \\n    static class DeltaPassRatio {\\n        double delta;\\n        int classroomid;\\n        public DeltaPassRatio(double delta, int classroomid) {\\n            this.delta = delta;\\n            this.classroomid = classroomid;\\n        }    \\n    }\\n    \\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        if(classes == null || classes.length == 0 || extraStudents < 0)\\n            return 0.0;\\n        \\n        //Build a max heap that stores [change in pass ratio, classroomid]\\n        PriorityQueue<DeltaPassRatio> maxHeap = new PriorityQueue<DeltaPassRatio>(classes.length, (DeltaPassRatio e1, DeltaPassRatio e2) -> Double.compare(e2.delta, e1.delta));\\n        for(int i = 0; i < classes.length; i++) \\n            maxHeap.add(new DeltaPassRatio(((double)(classes[i][0] + 1))/((double)(classes[i][1] + 1)) - ((double)classes[i][0])/((double)classes[i][1]), i));\\n        \\n        \\n        DeltaPassRatio current;\\n        int[] classRoom;\\n        while(extraStudents > 0) {\\n            current = maxHeap.remove();\\n            \\n            // Get the class room id and Increase pass students and total Students\\n            classRoom = classes[current.classroomid];\\n            classRoom[0] = classRoom[0] + 1;\\n            classRoom[1] = classRoom[1] + 1; \\n            \\n            //Update new score and add back to heap\\n            current.delta = ((double)(classRoom[0] + 1))/((double)(classRoom[1] + 1)) - ((double)classRoom[0])/((double)classRoom[1]);\\n            maxHeap.add(current); \\n            extraStudents--;\\n        }\\n        \\n        double totalPassRatio = 0.0;\\n        \\n        // Sum up the pass ratio of each class\\n       for (int[] classInfo : classes)\\n          totalPassRatio += ((double) classInfo[0] / classInfo[1]);\\n        \\n        \\n        return totalPassRatio/classes.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947161,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int k) {\\n        int n = classes.size();\\n        priority_queue<pair<double , pair<int ,int> >> pq;\\n        double sum = 0;\\n        \\n        for(auto & x : classes){\\n            double avg = (double)x[0]/(double)x[1];\\n            sum += avg;\\n            \\n            double next = (double)(x[0]+1)/(double)(x[1]+1);\\n            \\n            double diff = next - avg;\\n            \\n            pq.push({diff , {x[0] , x[1]}});\\n        }\\n        \\n        while(k > 0){\\n            auto x = pq.top();\\n            pq.pop();\\n            auto p = x.second;\\n            sum -= (double)p.first/p.second;\\n            p.first = p.first +1;\\n            p.second = p.second + 1;\\n            \\n            double avg = (double)p.first/(double)p.second;\\n            sum += avg;\\n            double next = (double)(p.first + 1)/(double)(p.second + 1);\\n            \\n            double diff = next - avg;\\n            \\n            pq.push({diff , p});\\n            k--;\\n        }\\n        \\n        return (double)sum/n;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int k) {\\n        int n = classes.size();\\n        priority_queue<pair<double , pair<int ,int> >> pq;\\n        double sum = 0;\\n        \\n        for(auto & x : classes){\\n            double avg = (double)x[0]/(double)x[1];\\n            sum += avg;\\n            \\n            double next = (double)(x[0]+1)/(double)(x[1]+1);\\n            \\n            double diff = next - avg;\\n            \\n            pq.push({diff , {x[0] , x[1]}});\\n        }\\n        \\n        while(k > 0){\\n            auto x = pq.top();\\n            pq.pop();\\n            auto p = x.second;\\n            sum -= (double)p.first/p.second;\\n            p.first = p.first +1;\\n            p.second = p.second + 1;\\n            \\n            double avg = (double)p.first/(double)p.second;\\n            sum += avg;\\n            double next = (double)(p.first + 1)/(double)(p.second + 1);\\n            \\n            double diff = next - avg;\\n            \\n            pq.push({diff , p});\\n            k--;\\n        }\\n        \\n        return (double)sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921320,
                "title": "python-heap-solution",
                "content": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:        \\n        heap = []\\n        for claz in classes:\\n            next_percentage = ((claz[0]+1)/(claz[1]+1)) - (claz[0]/claz[1]) \\n            heapq.heappush(heap, (-next_percentage, claz[0], claz[1]))\\n        \\n        while extraStudents > 0:\\n            extraStudents -= 1\\n            percentage, passing, total  = heapq.heappop(heap)\\n            passing += 1\\n            total += 1\\n            heapq.heappush(heap, (-((passing+1)/(total+1) - (passing/total)), passing, total))\\n        \\n        ans = 0\\n        for percentage, passing, total in heap:\\n            ans += (passing/total)\\n            \\n        return ans/len(classes)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:        \\n        heap = []\\n        for claz in classes:\\n            next_percentage = ((claz[0]+1)/(claz[1]+1)) - (claz[0]/claz[1]) \\n            heapq.heappush(heap, (-next_percentage, claz[0], claz[1]))\\n        \\n        while extraStudents > 0:\\n            extraStudents -= 1\\n            percentage, passing, total  = heapq.heappop(heap)\\n            passing += 1\\n            total += 1\\n            heapq.heappush(heap, (-((passing+1)/(total+1) - (passing/total)), passing, total))\\n        \\n        ans = 0\\n        for percentage, passing, total in heap:\\n            ans += (passing/total)\\n            \\n        return ans/len(classes)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1878005,
                "title": "c-heaps",
                "content": "```\\n struct myComp {\\n    constexpr bool operator()(\\n        pair<int, int> const& a,\\n        pair<int, int> const& b)\\n        const noexcept\\n    {\\n        double p = (double)(double((a.first + 1)/(double(a.second +1))));\\n        double q = (double)(double((a.first)/(double(a.second))));\\n        double r = (double)(double((b.first + 1)/(double(b.second +1))));\\n        double s = (double)(double((b.first)/(double(b.second))));\\n        double x = (double)(p-q);\\n        double y  = (double)(r-s);\\n        return x<y;\\n    }\\n};\\n    double maxAverageRatio(vector<vector<int>>& c, int e) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,myComp>pq;\\n        for(auto e:c){\\n            pq.push({e[0],e[1]});\\n        }\\n        while(e>0){\\n            auto x = pq.top();\\n            pq.pop();\\n            x.first+=1;\\n            x.second+=1;\\n            pq.push(x);\\n            e--;\\n        }\\n        double ans = 0;\\n        while(pq.empty() == false){\\n            ans += (double)(double(pq.top().first)) / (double(pq.top().second));\\n            pq.pop();\\n        }\\n        ans = (double)(ans/c.size());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n struct myComp {\\n    constexpr bool operator()(\\n        pair<int, int> const& a,\\n        pair<int, int> const& b)\\n        const noexcept\\n    {\\n        double p = (double)(double((a.first + 1)/(double(a.second +1))));\\n        double q = (double)(double((a.first)/(double(a.second))));\\n        double r = (double)(double((b.first + 1)/(double(b.second +1))));\\n        double s = (double)(double((b.first)/(double(b.second))));\\n        double x = (double)(p-q);\\n        double y  = (double)(r-s);\\n        return x<y;\\n    }\\n};\\n    double maxAverageRatio(vector<vector<int>>& c, int e) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,myComp>pq;\\n        for(auto e:c){\\n            pq.push({e[0],e[1]});\\n        }\\n        while(e>0){\\n            auto x = pq.top();\\n            pq.pop();\\n            x.first+=1;\\n            x.second+=1;\\n            pq.push(x);\\n            e--;\\n        }\\n        double ans = 0;\\n        while(pq.empty() == false){\\n            ans += (double)(double(pq.top().first)) / (double(pq.top().second));\\n            pq.pop();\\n        }\\n        ans = (double)(ans/c.size());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871761,
                "title": "c-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double ratio = 0;\\n        using Ratio = pair<unsigned int, unsigned int>;\\n        auto cmp = [&](const Ratio& a, const Ratio& b) {\\n            return (a.first + 1.0) / (a.second + 1.0) - (double)a.first / a.second < (b.first + 1.0) / (b.second + 1.0) - (double)b.first / b.second;\\n        };\\n        \\n        priority_queue<Ratio, vector<Ratio>, decltype(cmp)> pq(cmp);\\n        \\n        for (int i = 0; i <classes.size(); ++i) {\\n            if (classes[i][0] == classes[i][1]) {\\n                ratio += 1;\\n            } else {\\n                pq.push({classes[i][0], classes[i][1]});\\n            }\\n        }\\n        \\n        if (pq.empty()) {\\n            return 1;\\n        }\\n        \\n        while (extraStudents--) {\\n            Ratio p = pq.top();\\n            pq.pop();\\n            pq.push({p.first + 1, p.second + 1});\\n        }\\n        \\n        while (!pq.empty()) {\\n            ratio += pq.top().first / (double)pq.top().second;\\n            pq.pop();\\n        }\\n        \\n        return ratio / classes.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double ratio = 0;\\n        using Ratio = pair<unsigned int, unsigned int>;\\n        auto cmp = [&](const Ratio& a, const Ratio& b) {\\n            return (a.first + 1.0) / (a.second + 1.0) - (double)a.first / a.second < (b.first + 1.0) / (b.second + 1.0) - (double)b.first / b.second;\\n        };\\n        \\n        priority_queue<Ratio, vector<Ratio>, decltype(cmp)> pq(cmp);\\n        \\n        for (int i = 0; i <classes.size(); ++i) {\\n            if (classes[i][0] == classes[i][1]) {\\n                ratio += 1;\\n            } else {\\n                pq.push({classes[i][0], classes[i][1]});\\n            }\\n        }\\n        \\n        if (pq.empty()) {\\n            return 1;\\n        }\\n        \\n        while (extraStudents--) {\\n            Ratio p = pq.top();\\n            pq.pop();\\n            pq.push({p.first + 1, p.second + 1});\\n        }\\n        \\n        while (!pq.empty()) {\\n            ratio += pq.top().first / (double)pq.top().second;\\n            pq.pop();\\n        }\\n        \\n        return ratio / classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861175,
                "title": "c-max-heap-with-custom-compare",
                "content": "```\\nclass Solution {\\nprivate:\\n    typedef pair<int, int> Class; // {pass : total student}\\n    \\n    struct CmpClass {\\n    public:\\n        bool operator() (Class &c1, Class &c2) {\\n            return (double)(c1.first + 1) / (double)(c1.second + 1) - (double)c1.first / (double)c1.second <\\n                   (double)(c2.first + 1) / (double)(c2.second + 1) - (double)c2.first / (double)c2.second;\\n        }\\n    };\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double totalAvgSum = 0;\\n        priority_queue<Class, vector<Class>, CmpClass> priQ;\\n        \\n        for (vector<int> &eachC : classes) {\\n            if (eachC[0] == eachC[1]) {\\n               totalAvgSum += (double)1;\\n                continue;\\n            }\\n            priQ.emplace(eachC[0], eachC[1]);\\n        }\\n        \\n        while (!priQ.empty() && extraStudents-- > 0) {\\n            int nextPass = priQ.top().first + 1;\\n            int nextTotal = priQ.top().second + 1;\\n            priQ.pop();\\n            priQ.emplace(nextPass, nextTotal);\\n        }\\n        \\n        while (!priQ.empty()) {\\n            totalAvgSum += (double)priQ.top().first / (double)priQ.top().second;\\n            priQ.pop();\\n        }\\n        \\n        return totalAvgSum / classes.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    typedef pair<int, int> Class; // {pass : total student}\\n    \\n    struct CmpClass {\\n    public:\\n        bool operator() (Class &c1, Class &c2) {\\n            return (double)(c1.first + 1) / (double)(c1.second + 1) - (double)c1.first / (double)c1.second <\\n                   (double)(c2.first + 1) / (double)(c2.second + 1) - (double)c2.first / (double)c2.second;\\n        }\\n    };\\npublic:\\n    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\\n        double totalAvgSum = 0;\\n        priority_queue<Class, vector<Class>, CmpClass> priQ;\\n        \\n        for (vector<int> &eachC : classes) {\\n            if (eachC[0] == eachC[1]) {\\n               totalAvgSum += (double)1;\\n                continue;\\n            }\\n            priQ.emplace(eachC[0], eachC[1]);\\n        }\\n        \\n        while (!priQ.empty() && extraStudents-- > 0) {\\n            int nextPass = priQ.top().first + 1;\\n            int nextTotal = priQ.top().second + 1;\\n            priQ.pop();\\n            priQ.emplace(nextPass, nextTotal);\\n        }\\n        \\n        while (!priQ.empty()) {\\n            totalAvgSum += (double)priQ.top().first / (double)priQ.top().second;\\n            priQ.pop();\\n        }\\n        \\n        return totalAvgSum / classes.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833603,
                "title": "python3-greedy-max-heap-o-mlogn",
                "content": "* the greedy choice is to choose the classes in order of the biggest ratio that would be added if the class is chosen\\n* the added ratio is: (x+1)/(y+1)-x/y\\n* since we want to pick the biggest at all times for our max heap we use the value -((x+1)/(y+1)-x/y) = x/y-(x+1)/(y+1) \\n```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        cur=sum(x/y for x,y in classes)/len(classes)\\n        h=[(x/y-(x+1)/(y+1),x,y) for x,y in classes]\\n        heapq.heapify(h)\\n        for _ in range(extraStudents):\\n            diff,x,y=heapq.heappop(h)\\n            cur+=-diff/len(classes)\\n            val=(x+1)/(y+1)-(x+2)/(y+2)\\n            heapq.heappush(h,(val,x+1,y+1))\\n        return cur\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        cur=sum(x/y for x,y in classes)/len(classes)\\n        h=[(x/y-(x+1)/(y+1),x,y) for x,y in classes]\\n        heapq.heapify(h)\\n        for _ in range(extraStudents):\\n            diff,x,y=heapq.heappop(h)\\n            cur+=-diff/len(classes)\\n            val=(x+1)/(y+1)-(x+2)/(y+2)\\n            heapq.heappush(h,(val,x+1,y+1))\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832359,
                "title": "typescript-idiomatic-greedy-priorityqueue-solution",
                "content": "```typescript\\nfunction maxAverageRatio(classes: number[][], extraStudents: number): number {\\n  const pq = new MaxPriorityQueue({\\n    priority ([p, t]) {\\n      const gain = (p+1) / (t+1) - p/t;\\n      return Math.round(gain * 10**7);\\n    }\\n  });\\n  \\n  for (let [p, t] of classes) {\\n    pq.enqueue([p, t]);\\n  }\\n  \\n  while(extraStudents--) {\\n    let {element: [p, t]} = pq.dequeue();\\n    pq.enqueue([p+1, t+1]);\\n    \\n  }\\n  const updatedClasses = pq.toArray();\\n  const sumRatio = updatedClasses.reduce((acc, {element: [p, t]}) => acc + p/t, 0);\\n  return sumRatio / updatedClasses.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```typescript\\nfunction maxAverageRatio(classes: number[][], extraStudents: number): number {\\n  const pq = new MaxPriorityQueue({\\n    priority ([p, t]) {\\n      const gain = (p+1) / (t+1) - p/t;\\n      return Math.round(gain * 10**7);\\n    }\\n  });\\n  \\n  for (let [p, t] of classes) {\\n    pq.enqueue([p, t]);\\n  }\\n  \\n  while(extraStudents--) {\\n    let {element: [p, t]} = pq.dequeue();\\n    pq.enqueue([p+1, t+1]);\\n    \\n  }\\n  const updatedClasses = pq.toArray();\\n  const sumRatio = updatedClasses.reduce((acc, {element: [p, t]}) => acc + p/t, 0);\\n  return sumRatio / updatedClasses.length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820948,
                "title": "javascript-solution-using-heap",
                "content": "```\\n/**\\n * @param {number[][]} classes\\n * @param {number} extraStudents\\n * @return {number}\\n */\\nvar maxAverageRatio = function(classes, extraStudents) {\\n//Creating heap class in javascript\\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            let aDiff,bDiff;\\n            aDiff = ((a[0]+1)/(a[1]+1))-(a[0]/a[1]);\\n            bDiff = ((b[0]+1)/(b[1]+1))-(b[0]/b[1]);\\n            if(this.type===\"min\"){\\n                return bDiff-aDiff;\\n            }else{\\n                return aDiff -bDiff;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    let ratioSum=0,minHeap=new Heap(\\'max\\');\\n    for(let i=0;i<classes.length;i++){\\n        ratioSum += classes[i][0]/classes[i][1];\\n        minHeap.insert(classes[i]);\\n    }\\n    while(extraStudents>0){\\n        let min =   minHeap.removeTop();\\n        ratioSum -= min[0]/min[1];\\n        min[0]++;\\n        min[1]++;\\n        ratioSum += min[0]/min[1];\\n        minHeap.insert(min);\\n        extraStudents--;\\n    }\\n    return ratioSum/classes.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[][]} classes\\n * @param {number} extraStudents\\n * @return {number}\\n */\\nvar maxAverageRatio = function(classes, extraStudents) {\\n//Creating heap class in javascript\\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            let aDiff,bDiff;\\n            aDiff = ((a[0]+1)/(a[1]+1))-(a[0]/a[1]);\\n            bDiff = ((b[0]+1)/(b[1]+1))-(b[0]/b[1]);\\n            if(this.type===\"min\"){\\n                return bDiff-aDiff;\\n            }else{\\n                return aDiff -bDiff;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    let ratioSum=0,minHeap=new Heap(\\'max\\');\\n    for(let i=0;i<classes.length;i++){\\n        ratioSum += classes[i][0]/classes[i][1];\\n        minHeap.insert(classes[i]);\\n    }\\n    while(extraStudents>0){\\n        let min =   minHeap.removeTop();\\n        ratioSum -= min[0]/min[1];\\n        min[0]++;\\n        min[1]++;\\n        ratioSum += min[0]/min[1];\\n        minHeap.insert(min);\\n        extraStudents--;\\n    }\\n    return ratioSum/classes.length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788093,
                "title": "python-priority-queue",
                "content": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq=[]\\n        for pss,tot in classes:\\n            newratio=(pss+1)/(tot+1)\\n            currratio=pss/tot\\n            pq.append((-(newratio-currratio),pss,tot))\\n        heapq.heapify(pq)\\n        ans=0\\n        while extraStudents>0:\\n            _,pss,tot=heapq.heappop(pq)\\n            pss+=1\\n            tot+=1\\n            extraStudents-=1\\n            currratio=pss/tot\\n            newratio=(pss+1)/(tot+1)\\n            heapq.heappush(pq,(-(newratio-currratio),pss,tot))\\n        for _,p,q in pq:\\n            ans+=p/q\\n        return ans/len(pq)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\\n        pq=[]\\n        for pss,tot in classes:\\n            newratio=(pss+1)/(tot+1)\\n            currratio=pss/tot\\n            pq.append((-(newratio-currratio),pss,tot))\\n        heapq.heapify(pq)\\n        ans=0\\n        while extraStudents>0:\\n            _,pss,tot=heapq.heappop(pq)\\n            pss+=1\\n            tot+=1\\n            extraStudents-=1\\n            currratio=pss/tot\\n            newratio=(pss+1)/(tot+1)\\n            heapq.heappush(pq,(-(newratio-currratio),pss,tot))\\n        for _,p,q in pq:\\n            ans+=p/q\\n        return ans/len(pq)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575030,
                "content": [
                    {
                        "username": "Schlepp",
                        "content": "There\\'s no reason that an optimal m log n solution TLE\\'s because we use vectors instead of pairs.  This question is way too stingy on runtime."
                    },
                    {
                        "username": "makeller1",
                        "content": "Especially since you can create the heap in O(n) using vectors as opposed to pushing one pair at a time."
                    },
                    {
                        "username": "aj__24",
                        "content": "The main idea will be to increment that class which will give max profit.\\neg: 2/4, 1/2\\n\\nyou may think we need to increment the one with max diff(b-a if it was a/b) but actually it\\'s not that simple.\\nistead one way to check which gives max increment is calculating (a/b - (a+1)/(b+1)) and the one which has max  (a/b - (a+1)/(b+1)) is need tobe incremented. \\nSo main idea will be to take one passed student(out of k) and assign it to any of the classes and after assigning it, we need to update that class. \\nWe repeat the process till k == 0;\\n\\nSo we\\'ll create a max heap that will store (a/b - (a+1)/(b+1)) for every a, b in classes, and for every k we will find the max value from heap and will update that classes value to a+1/b+1 and insert it to that heap.\\n\\nI\\'ve given a breif explanation, now you can easily code it by yourseleves"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "if anyone can assist me in debugging this code.\ni have used heap concept\n\n\n\n\n\n\nclass Solution {\npublic:\ntypedef vector<float>pi;\n    double maxAverageRatio(vector<vector<pi>>& classes, int extraStudents) {\n        priority_queue<pi,vector<pi>,greater<pi>>minh;\n\n            for (auto it : classes) {\n                double avg = (it[0][0] / it[0][1]); // Access the elements correctly\n                minh.push({avg, it[0][0], it[0][1]}); // Push the values into the priority queue\n        }\n        while(extraStudents!=0){\n            auto it=minh.top();\n            minh.pop();\n            it[1]=it[1]+1;\n            it[2]=it[2]+1;\n            it[0]=it[1]/it[2];\n            minh.push(it);\n\n            extraStudents--;\n        }\n        double ans=0;\n        while(!minh.empty()){\n            auto it=minh.top();\n            minh.pop();\n            ans=ans+it[0];\n        }\n        return ans;\n    }\n}; "
                    },
                    {
                        "username": "jasbir",
                        "content": "Can anyone please help why this is not getting accepted with TreeSet?\\n\\nIt is being accepted when using priorityQueue using same logic. Its very frustrating. Please suggest why it is so?\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        TreeSet<double[]> set = new TreeSet<double[]>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                 if(a[0] - b[0] > 0) return -1;\\n                 else if(a[0]-b[0] < 0)  return 1;\\n                 return 0;\\n             }\\n         });\\n         for(int[] c : classes){\\n             double a = c[0], b = c[1];\\n             set.add(new double[]{profit(a,b),a,b});\\n         }\\n        \\n         while(extraStudents-- > 0){\\n             double[] arr = set.pollFirst();\\n             double a = arr[1];\\n             double b = arr[2];\\n             set.add(new double[]{profit(a+1,b+1),a+1,b+1});\\n         }\\n         double ans = 0.0d;\\n         while(!set.isEmpty()){\\n             double[] arr = set.pollFirst();\\n             double a=arr[1],b=arr[2];\\n             ans += a/b;\\n         }\\n        \\n         return (double)(ans/classes.length);\\n   \\n\\n    }\\n    public double profit(double a, double b){\\n        return (a + 1) / (b + 1) - a / b;\\n    }\\n}"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "How come an optimal solution TLE's cause it's in python? I am using a wrapper class with total_ordering and heapq to ensure the __lt__ and __eq__ function checks the increase in pass percentage being greater than (not less than, as heapq implements min heap) and equal to."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I just submitted an heap solution and it passed on first go, there must be some error with your program, that isn\\'t a smart way to implement a maxHeap in python"
                    }
                ]
            },
            {
                "id": 1575515,
                "content": [
                    {
                        "username": "Schlepp",
                        "content": "There\\'s no reason that an optimal m log n solution TLE\\'s because we use vectors instead of pairs.  This question is way too stingy on runtime."
                    },
                    {
                        "username": "makeller1",
                        "content": "Especially since you can create the heap in O(n) using vectors as opposed to pushing one pair at a time."
                    },
                    {
                        "username": "aj__24",
                        "content": "The main idea will be to increment that class which will give max profit.\\neg: 2/4, 1/2\\n\\nyou may think we need to increment the one with max diff(b-a if it was a/b) but actually it\\'s not that simple.\\nistead one way to check which gives max increment is calculating (a/b - (a+1)/(b+1)) and the one which has max  (a/b - (a+1)/(b+1)) is need tobe incremented. \\nSo main idea will be to take one passed student(out of k) and assign it to any of the classes and after assigning it, we need to update that class. \\nWe repeat the process till k == 0;\\n\\nSo we\\'ll create a max heap that will store (a/b - (a+1)/(b+1)) for every a, b in classes, and for every k we will find the max value from heap and will update that classes value to a+1/b+1 and insert it to that heap.\\n\\nI\\'ve given a breif explanation, now you can easily code it by yourseleves"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "if anyone can assist me in debugging this code.\ni have used heap concept\n\n\n\n\n\n\nclass Solution {\npublic:\ntypedef vector<float>pi;\n    double maxAverageRatio(vector<vector<pi>>& classes, int extraStudents) {\n        priority_queue<pi,vector<pi>,greater<pi>>minh;\n\n            for (auto it : classes) {\n                double avg = (it[0][0] / it[0][1]); // Access the elements correctly\n                minh.push({avg, it[0][0], it[0][1]}); // Push the values into the priority queue\n        }\n        while(extraStudents!=0){\n            auto it=minh.top();\n            minh.pop();\n            it[1]=it[1]+1;\n            it[2]=it[2]+1;\n            it[0]=it[1]/it[2];\n            minh.push(it);\n\n            extraStudents--;\n        }\n        double ans=0;\n        while(!minh.empty()){\n            auto it=minh.top();\n            minh.pop();\n            ans=ans+it[0];\n        }\n        return ans;\n    }\n}; "
                    },
                    {
                        "username": "jasbir",
                        "content": "Can anyone please help why this is not getting accepted with TreeSet?\\n\\nIt is being accepted when using priorityQueue using same logic. Its very frustrating. Please suggest why it is so?\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        TreeSet<double[]> set = new TreeSet<double[]>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                 if(a[0] - b[0] > 0) return -1;\\n                 else if(a[0]-b[0] < 0)  return 1;\\n                 return 0;\\n             }\\n         });\\n         for(int[] c : classes){\\n             double a = c[0], b = c[1];\\n             set.add(new double[]{profit(a,b),a,b});\\n         }\\n        \\n         while(extraStudents-- > 0){\\n             double[] arr = set.pollFirst();\\n             double a = arr[1];\\n             double b = arr[2];\\n             set.add(new double[]{profit(a+1,b+1),a+1,b+1});\\n         }\\n         double ans = 0.0d;\\n         while(!set.isEmpty()){\\n             double[] arr = set.pollFirst();\\n             double a=arr[1],b=arr[2];\\n             ans += a/b;\\n         }\\n        \\n         return (double)(ans/classes.length);\\n   \\n\\n    }\\n    public double profit(double a, double b){\\n        return (a + 1) / (b + 1) - a / b;\\n    }\\n}"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "How come an optimal solution TLE's cause it's in python? I am using a wrapper class with total_ordering and heapq to ensure the __lt__ and __eq__ function checks the increase in pass percentage being greater than (not less than, as heapq implements min heap) and equal to."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I just submitted an heap solution and it passed on first go, there must be some error with your program, that isn\\'t a smart way to implement a maxHeap in python"
                    }
                ]
            },
            {
                "id": 2034497,
                "content": [
                    {
                        "username": "Schlepp",
                        "content": "There\\'s no reason that an optimal m log n solution TLE\\'s because we use vectors instead of pairs.  This question is way too stingy on runtime."
                    },
                    {
                        "username": "makeller1",
                        "content": "Especially since you can create the heap in O(n) using vectors as opposed to pushing one pair at a time."
                    },
                    {
                        "username": "aj__24",
                        "content": "The main idea will be to increment that class which will give max profit.\\neg: 2/4, 1/2\\n\\nyou may think we need to increment the one with max diff(b-a if it was a/b) but actually it\\'s not that simple.\\nistead one way to check which gives max increment is calculating (a/b - (a+1)/(b+1)) and the one which has max  (a/b - (a+1)/(b+1)) is need tobe incremented. \\nSo main idea will be to take one passed student(out of k) and assign it to any of the classes and after assigning it, we need to update that class. \\nWe repeat the process till k == 0;\\n\\nSo we\\'ll create a max heap that will store (a/b - (a+1)/(b+1)) for every a, b in classes, and for every k we will find the max value from heap and will update that classes value to a+1/b+1 and insert it to that heap.\\n\\nI\\'ve given a breif explanation, now you can easily code it by yourseleves"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "if anyone can assist me in debugging this code.\ni have used heap concept\n\n\n\n\n\n\nclass Solution {\npublic:\ntypedef vector<float>pi;\n    double maxAverageRatio(vector<vector<pi>>& classes, int extraStudents) {\n        priority_queue<pi,vector<pi>,greater<pi>>minh;\n\n            for (auto it : classes) {\n                double avg = (it[0][0] / it[0][1]); // Access the elements correctly\n                minh.push({avg, it[0][0], it[0][1]}); // Push the values into the priority queue\n        }\n        while(extraStudents!=0){\n            auto it=minh.top();\n            minh.pop();\n            it[1]=it[1]+1;\n            it[2]=it[2]+1;\n            it[0]=it[1]/it[2];\n            minh.push(it);\n\n            extraStudents--;\n        }\n        double ans=0;\n        while(!minh.empty()){\n            auto it=minh.top();\n            minh.pop();\n            ans=ans+it[0];\n        }\n        return ans;\n    }\n}; "
                    },
                    {
                        "username": "jasbir",
                        "content": "Can anyone please help why this is not getting accepted with TreeSet?\\n\\nIt is being accepted when using priorityQueue using same logic. Its very frustrating. Please suggest why it is so?\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        TreeSet<double[]> set = new TreeSet<double[]>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                 if(a[0] - b[0] > 0) return -1;\\n                 else if(a[0]-b[0] < 0)  return 1;\\n                 return 0;\\n             }\\n         });\\n         for(int[] c : classes){\\n             double a = c[0], b = c[1];\\n             set.add(new double[]{profit(a,b),a,b});\\n         }\\n        \\n         while(extraStudents-- > 0){\\n             double[] arr = set.pollFirst();\\n             double a = arr[1];\\n             double b = arr[2];\\n             set.add(new double[]{profit(a+1,b+1),a+1,b+1});\\n         }\\n         double ans = 0.0d;\\n         while(!set.isEmpty()){\\n             double[] arr = set.pollFirst();\\n             double a=arr[1],b=arr[2];\\n             ans += a/b;\\n         }\\n        \\n         return (double)(ans/classes.length);\\n   \\n\\n    }\\n    public double profit(double a, double b){\\n        return (a + 1) / (b + 1) - a / b;\\n    }\\n}"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "How come an optimal solution TLE's cause it's in python? I am using a wrapper class with total_ordering and heapq to ensure the __lt__ and __eq__ function checks the increase in pass percentage being greater than (not less than, as heapq implements min heap) and equal to."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I just submitted an heap solution and it passed on first go, there must be some error with your program, that isn\\'t a smart way to implement a maxHeap in python"
                    }
                ]
            },
            {
                "id": 1802546,
                "content": [
                    {
                        "username": "Schlepp",
                        "content": "There\\'s no reason that an optimal m log n solution TLE\\'s because we use vectors instead of pairs.  This question is way too stingy on runtime."
                    },
                    {
                        "username": "makeller1",
                        "content": "Especially since you can create the heap in O(n) using vectors as opposed to pushing one pair at a time."
                    },
                    {
                        "username": "aj__24",
                        "content": "The main idea will be to increment that class which will give max profit.\\neg: 2/4, 1/2\\n\\nyou may think we need to increment the one with max diff(b-a if it was a/b) but actually it\\'s not that simple.\\nistead one way to check which gives max increment is calculating (a/b - (a+1)/(b+1)) and the one which has max  (a/b - (a+1)/(b+1)) is need tobe incremented. \\nSo main idea will be to take one passed student(out of k) and assign it to any of the classes and after assigning it, we need to update that class. \\nWe repeat the process till k == 0;\\n\\nSo we\\'ll create a max heap that will store (a/b - (a+1)/(b+1)) for every a, b in classes, and for every k we will find the max value from heap and will update that classes value to a+1/b+1 and insert it to that heap.\\n\\nI\\'ve given a breif explanation, now you can easily code it by yourseleves"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "if anyone can assist me in debugging this code.\ni have used heap concept\n\n\n\n\n\n\nclass Solution {\npublic:\ntypedef vector<float>pi;\n    double maxAverageRatio(vector<vector<pi>>& classes, int extraStudents) {\n        priority_queue<pi,vector<pi>,greater<pi>>minh;\n\n            for (auto it : classes) {\n                double avg = (it[0][0] / it[0][1]); // Access the elements correctly\n                minh.push({avg, it[0][0], it[0][1]}); // Push the values into the priority queue\n        }\n        while(extraStudents!=0){\n            auto it=minh.top();\n            minh.pop();\n            it[1]=it[1]+1;\n            it[2]=it[2]+1;\n            it[0]=it[1]/it[2];\n            minh.push(it);\n\n            extraStudents--;\n        }\n        double ans=0;\n        while(!minh.empty()){\n            auto it=minh.top();\n            minh.pop();\n            ans=ans+it[0];\n        }\n        return ans;\n    }\n}; "
                    },
                    {
                        "username": "jasbir",
                        "content": "Can anyone please help why this is not getting accepted with TreeSet?\\n\\nIt is being accepted when using priorityQueue using same logic. Its very frustrating. Please suggest why it is so?\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        TreeSet<double[]> set = new TreeSet<double[]>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                 if(a[0] - b[0] > 0) return -1;\\n                 else if(a[0]-b[0] < 0)  return 1;\\n                 return 0;\\n             }\\n         });\\n         for(int[] c : classes){\\n             double a = c[0], b = c[1];\\n             set.add(new double[]{profit(a,b),a,b});\\n         }\\n        \\n         while(extraStudents-- > 0){\\n             double[] arr = set.pollFirst();\\n             double a = arr[1];\\n             double b = arr[2];\\n             set.add(new double[]{profit(a+1,b+1),a+1,b+1});\\n         }\\n         double ans = 0.0d;\\n         while(!set.isEmpty()){\\n             double[] arr = set.pollFirst();\\n             double a=arr[1],b=arr[2];\\n             ans += a/b;\\n         }\\n        \\n         return (double)(ans/classes.length);\\n   \\n\\n    }\\n    public double profit(double a, double b){\\n        return (a + 1) / (b + 1) - a / b;\\n    }\\n}"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "How come an optimal solution TLE's cause it's in python? I am using a wrapper class with total_ordering and heapq to ensure the __lt__ and __eq__ function checks the increase in pass percentage being greater than (not less than, as heapq implements min heap) and equal to."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I just submitted an heap solution and it passed on first go, there must be some error with your program, that isn\\'t a smart way to implement a maxHeap in python"
                    }
                ]
            },
            {
                "id": 1795771,
                "content": [
                    {
                        "username": "Schlepp",
                        "content": "There\\'s no reason that an optimal m log n solution TLE\\'s because we use vectors instead of pairs.  This question is way too stingy on runtime."
                    },
                    {
                        "username": "makeller1",
                        "content": "Especially since you can create the heap in O(n) using vectors as opposed to pushing one pair at a time."
                    },
                    {
                        "username": "aj__24",
                        "content": "The main idea will be to increment that class which will give max profit.\\neg: 2/4, 1/2\\n\\nyou may think we need to increment the one with max diff(b-a if it was a/b) but actually it\\'s not that simple.\\nistead one way to check which gives max increment is calculating (a/b - (a+1)/(b+1)) and the one which has max  (a/b - (a+1)/(b+1)) is need tobe incremented. \\nSo main idea will be to take one passed student(out of k) and assign it to any of the classes and after assigning it, we need to update that class. \\nWe repeat the process till k == 0;\\n\\nSo we\\'ll create a max heap that will store (a/b - (a+1)/(b+1)) for every a, b in classes, and for every k we will find the max value from heap and will update that classes value to a+1/b+1 and insert it to that heap.\\n\\nI\\'ve given a breif explanation, now you can easily code it by yourseleves"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "if anyone can assist me in debugging this code.\ni have used heap concept\n\n\n\n\n\n\nclass Solution {\npublic:\ntypedef vector<float>pi;\n    double maxAverageRatio(vector<vector<pi>>& classes, int extraStudents) {\n        priority_queue<pi,vector<pi>,greater<pi>>minh;\n\n            for (auto it : classes) {\n                double avg = (it[0][0] / it[0][1]); // Access the elements correctly\n                minh.push({avg, it[0][0], it[0][1]}); // Push the values into the priority queue\n        }\n        while(extraStudents!=0){\n            auto it=minh.top();\n            minh.pop();\n            it[1]=it[1]+1;\n            it[2]=it[2]+1;\n            it[0]=it[1]/it[2];\n            minh.push(it);\n\n            extraStudents--;\n        }\n        double ans=0;\n        while(!minh.empty()){\n            auto it=minh.top();\n            minh.pop();\n            ans=ans+it[0];\n        }\n        return ans;\n    }\n}; "
                    },
                    {
                        "username": "jasbir",
                        "content": "Can anyone please help why this is not getting accepted with TreeSet?\\n\\nIt is being accepted when using priorityQueue using same logic. Its very frustrating. Please suggest why it is so?\\n\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        TreeSet<double[]> set = new TreeSet<double[]>(new Comparator<double[]>(){\\n            public int compare(double[] a, double[] b){\\n                 if(a[0] - b[0] > 0) return -1;\\n                 else if(a[0]-b[0] < 0)  return 1;\\n                 return 0;\\n             }\\n         });\\n         for(int[] c : classes){\\n             double a = c[0], b = c[1];\\n             set.add(new double[]{profit(a,b),a,b});\\n         }\\n        \\n         while(extraStudents-- > 0){\\n             double[] arr = set.pollFirst();\\n             double a = arr[1];\\n             double b = arr[2];\\n             set.add(new double[]{profit(a+1,b+1),a+1,b+1});\\n         }\\n         double ans = 0.0d;\\n         while(!set.isEmpty()){\\n             double[] arr = set.pollFirst();\\n             double a=arr[1],b=arr[2];\\n             ans += a/b;\\n         }\\n        \\n         return (double)(ans/classes.length);\\n   \\n\\n    }\\n    public double profit(double a, double b){\\n        return (a + 1) / (b + 1) - a / b;\\n    }\\n}"
                    },
                    {
                        "username": "saswatajiko",
                        "content": "How come an optimal solution TLE's cause it's in python? I am using a wrapper class with total_ordering and heapq to ensure the __lt__ and __eq__ function checks the increase in pass percentage being greater than (not less than, as heapq implements min heap) and equal to."
                    },
                    {
                        "username": "aditya_42",
                        "content": "I just submitted an heap solution and it passed on first go, there must be some error with your program, that isn\\'t a smart way to implement a maxHeap in python"
                    }
                ]
            }
        ]
    }
]